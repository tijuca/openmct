diff -Naru linux-2.4.35.3/drivers/usb/Config.in linux-2.4.35.3-mct/drivers/usb/Config.in
--- linux-2.4.35.3/drivers/usb/Config.in	2007-09-24 00:02:58.000000000 +0200
+++ linux-2.4.35.3-mct/drivers/usb/Config.in	2007-10-03 13:14:27.000000000 +0200
@@ -96,6 +96,14 @@
       dep_tristate '  USB-to-USB Networking cables, Linux PDAs, ... (EXPERIMENTAL)' CONFIG_USB_USBNET $CONFIG_USB $CONFIG_NET $CONFIG_EXPERIMENTAL
    fi
 
+   comment 'USB WLAN adaptors'
+   if [ "$CONFIG_NET_WIRELESS" = "n" ]; then
+      comment '  Wireless LAN (non-hamradio) support is needed for USB WLAN device support'
+   else
+      dep_tristate '  USB ZD1211 WLAN Support' CONFIG_USB_ZD1211
+      dep_tristate '  USB RT2570 WLAN Support' CONFIG_USB_RT2570
+   fi
+
    comment 'USB port drivers'
    dep_tristate '  USS720 parport driver' CONFIG_USB_USS720 $CONFIG_USB $CONFIG_PARPORT
    source drivers/usb/serial/Config.in
diff -Naru linux-2.4.35.3/drivers/usb/Makefile linux-2.4.35.3-mct/drivers/usb/Makefile
--- linux-2.4.35.3/drivers/usb/Makefile	2007-09-24 00:02:58.000000000 +0200
+++ linux-2.4.35.3-mct/drivers/usb/Makefile	2007-10-03 13:14:27.000000000 +0200
@@ -137,6 +137,16 @@
 	obj-y += storage/storage.o
 endif
 
+ifeq ($(CONFIG_USB_ZD1211),y)
+obj-$(CONFIG_USB_ZD1211)           += zd1211/zd1211usb.o
+endif
+subdir-$(CONFIG_USB_ZD1211)        += zd1211
+
+ifeq ($(CONFIG_USB_RT2570),y)
+obj-$(CONFIG_USB_RT2570)           += rt2570/rt2570.o
+endif
+subdir-$(CONFIG_USB_RT2570)        += rt2570
+
 include $(TOPDIR)/Rules.make
 
 # Link rules for multi-part drivers.
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/.depend linux-2.4.35.3-mct/drivers/usb/rt2570/.depend
--- linux-2.4.35.3/drivers/usb/rt2570/.depend	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/.depend	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,80 @@
+assoc.o: assoc.c \
+   rt_config.h
+auth.o: auth.c \
+   rt_config.h
+auth_rsp.o: auth_rsp.c \
+   rt_config.h
+connect.o: connect.c \
+   rt_config.h
+md5.o: md5.c \
+   rt_config.h
+mlme.o: mlme.c \
+   rt_config.h
+rt_config.h: \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/version.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/string.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/timer.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/ioport.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/pci.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/netdevice.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/etherdevice.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/skbuff.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/delay.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/ethtool.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/wireless.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/proc_fs.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/delay.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/if_arp.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/ctype.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/sched.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/smp_lock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kmod.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/mii.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/processor.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/bitops.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/io.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/irq.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/atomic.h \
+   rt2570.h \
+   rtmp_type.h \
+   rtmp_def.h \
+   oid.h \
+   mlme.h \
+   md5.h \
+   wpa.h \
+   sha1.h \
+   rt2570sw.h \
+   rtusb.h
+	@touch rt_config.h
+rtmp_tkip.o: rtmp_tkip.c \
+   rt_config.h
+rtmp_wep.o: rtmp_wep.c \
+   rt_config.h
+rtusb_bulk.o: rtusb_bulk.c \
+   rt_config.h
+rtusb_data.o: rtusb_data.c \
+   rt_config.h
+rtusb_info.o: rtusb_info.c \
+   rt_config.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/net/iw_handler.h
+rtusb_init.o: rtusb_init.c \
+   rt_config.h
+rtusb_io.o: rtusb_io.c \
+   rt_config.h
+rtusb_main.o: rtusb_main.c \
+   rt_config.h
+sanity.o: sanity.c \
+   rt_config.h
+sync.o: sync.c \
+   rt_config.h
+wpa.o: wpa.c \
+   rt_config.h
+.PRECIOUS:	rt_config.h \
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/Makefile linux-2.4.35.3-mct/drivers/usb/rt2570/Makefile
--- linux-2.4.35.3/drivers/usb/rt2570/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/Makefile	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,14 @@
+#
+# Makefile for the USB RT2570 device drivers.
+#
+
+O_TARGET	:= rt2570.o
+
+obj-y		:= mlme.o rtusb_bulk.o connect.o sync.o rtusb_init.o rtmp_tkip.o \
+		   wpa.o rtmp_wep.o rtusb_info.o assoc.o auth.o auth_rsp.o md5.o \
+		   rtusb_io.o sanity.o rtusb_data.o rtusb_main.o
+
+obj-m		= rt2570.o
+
+include $(TOPDIR)/Rules.make
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/assoc.c linux-2.4.35.3-mct/drivers/usb/rt2570/assoc.c
--- linux-2.4.35.3/drivers/usb/rt2570/assoc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/assoc.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,919 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	assoc.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+UCHAR	CipherWpaTemplate[] = {
+		0xdd, 					// WPA IE
+		0x16,					// Length
+		0x00, 0x50, 0xf2, 0x01,	// oui
+		0x01, 0x00,				// Version
+		0x00, 0x50, 0xf2, 0x02,	// Multicast
+		0x01, 0x00,				// Number of unicast
+		0x00, 0x50, 0xf2, 0x02,	// unicast
+		0x01, 0x00,				// number of authentication method
+		0x00, 0x50, 0xf2, 0x01	// authentication
+		};
+
+UCHAR	CipherWpa2Template[] = {
+		0x30,					// RSN IE
+		0x14,					// Length
+		0x01, 0x00,				// Version
+		0x00, 0x0f, 0xac, 0x02,	// group cipher, TKIP
+		0x01, 0x00,				// number of pairwise
+		0x00, 0x0f, 0xac, 0x02,	// unicast
+		0x01, 0x00,				// number of authentication method
+		0x00, 0x0f, 0xac, 0x02,	// authentication
+		0x00, 0x00,				// RSN capability
+		};
+
+/*  
+    ==========================================================================
+    Description: 
+        association state machine init, including state transition and timer init
+    Parameters: 
+        S - pointer to the association state machine
+    Note:
+        The state machine looks like the following 
+        
+                               ASSOC_IDLE               ASSOC_WAIT_RSP             REASSOC_WAIT_RSP             DISASSOC_WAIT_RSP
+    MT2_MLME_ASSOC_REQ       mlme_assoc_req_action    invalid_state_when_assoc   invalid_state_when_assoc       invalid_state_when_assoc
+    MT2_MLME_REASSOC_REQ     mlme_reassoc_req_action  invalid_state_when_reassoc invalid_state_when_reassoc     invalid_state_when_reassoc
+    MT2_MLME_DISASSOC_REQ    mlme_disassoc_req_action mlme_disassoc_req_action   mlme_disassoc_req_action       mlme_disassoc_req_action
+    MT2_PEER_DISASSOC_REQ    peer_disassoc_action     peer_disassoc_action       peer_disassoc_action           peer_disassoc_action
+    MT2_PEER_ASSOC_REQ       drop                     drop                       drop                           drop
+    MT2_PEER_ASSOC_RSP       drop                     peer_assoc_rsp_action      drop                           drop
+    MT2_PEER_REASSOC_REQ     drop                     drop                       drop                           drop
+    MT2_PEER_REASSOC_RSP     drop                     drop                       peer_reassoc_rsp_action        drop
+    MT2_CLS3ERR              cls3err_action           cls3err_action             cls3err_action                 cls3err_action
+    MT2_ASSOC_TIMEOUT        timer_nop                assoc_timeout_action       timer_nop                      timer_nop
+    MT2_REASSOC_TIMEOUT      timer_nop                timer_nop                  reassoc_timeout_action         timer_nop
+    MT2_DISASSOC_TIMEOUT     timer_nop                timer_nop                  timer_nop                      disassoc_timeout_action
+
+	IRQL = PASSIVE_LEVEL
+	
+    ==========================================================================
+ */
+VOID AssocStateMachineInit(
+    IN	PRT2570ADAPTER	pAd, 
+    IN  STATE_MACHINE *S, 
+    OUT STATE_MACHINE_FUNC Trans[]) 
+{
+	StateMachineInit(S, Trans, MAX_ASSOC_STATE, MAX_ASSOC_MSG, (STATE_MACHINE_FUNC)Drop, ASSOC_IDLE, ASSOC_MACHINE_BASE);
+
+	// first column
+	StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)MlmeAssocReqAction);
+	StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)MlmeReassocReqAction);
+	StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)MlmeDisassocReqAction);
+	StateMachineSetAction(S, ASSOC_IDLE, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
+	//StateMachineSetAction(S, ASSOC_IDLE, MT2_CLS3ERR, Cls3errAction);
+
+	// second column
+	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
+	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
+	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
+	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
+	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_ASSOC_RSP, (STATE_MACHINE_FUNC)PeerAssocRspAction);
+	//StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_CLS3ERR, Cls3errAction);
+	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_ASSOC_TIMEOUT, (STATE_MACHINE_FUNC)AssocTimeoutAction);
+
+	// third column
+	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
+	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
+	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
+	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
+	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_REASSOC_RSP, (STATE_MACHINE_FUNC)PeerReassocRspAction);
+	// StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_CLS3ERR, Cls3errAction);
+	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_REASSOC_TIMEOUT, (STATE_MACHINE_FUNC)ReassocTimeoutAction);
+
+	// fourth column
+	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
+	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
+	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
+	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
+	//StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_CLS3ERR, Cls3errAction);
+	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_DISASSOC_TIMEOUT, (STATE_MACHINE_FUNC)DisassocTimeoutAction);
+
+	// initialize the timer
+	RTMPInitTimer(pAd, &pAd->Mlme.AssocAux.AssocTimer, AssocTimeout);
+	RTMPInitTimer(pAd, &pAd->Mlme.AssocAux.ReassocTimer, ReassocTimeout);
+	RTMPInitTimer(pAd, &pAd->Mlme.AssocAux.DisassocTimer, DisassocTimeout);
+}
+
+/*
+    ==========================================================================
+    Description:
+        Association timeout procedure. After association timeout, this function 
+        will be called and it will put a message into the MLME queue
+    Parameters:
+        Standard timer parameters
+
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID  AssocTimeout(unsigned long data)
+{
+	PRT2570ADAPTER	pAd = (PRT2570ADAPTER)data;
+	DBGPRINT(RT_DEBUG_TRACE, "ASSOC - enqueue MT2_ASSOC_TIMEOUT \n");
+	
+	// Do nothing if the driver is starting halt state.
+	// This might happen when timer already been fired before cancel timer with mlmehalt
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+		return;
+
+	MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_ASSOC_TIMEOUT, 0, NULL);
+	//KeSetEvent(&pAd->MLMEEvent, 0, FALSE);	
+	RTUSBUp(pAd, (&(pAd->mlme_semaphore)));
+}
+
+/*
+    ==========================================================================
+    Description:
+        Reassociation timeout procedure. After reassociation timeout, this 
+        function will be called and put a message into the MLME queue
+    Parameters:
+        Standard timer parameters
+
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID  ReassocTimeout(unsigned long data)
+{
+	PRT2570ADAPTER	pAd = (PRT2570ADAPTER)data;
+	DBGPRINT(RT_DEBUG_TRACE,"ASSOC - enqueue MT2_REASSOC_TIMEOUT \n");
+	
+	// Do nothing if the driver is starting halt state.
+	// This might happen when timer already been fired before cancel timer with mlmehalt
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+		return;
+
+	MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_REASSOC_TIMEOUT, 0, NULL);
+	//KeSetEvent(&pAd->MLMEEvent, 0, FALSE);	
+	RTUSBUp(pAd, (&(pAd->mlme_semaphore)));
+}
+
+/*
+    ==========================================================================
+    Description:
+        Disassociation timeout procedure. After disassociation timeout, this 
+        function will be called and put a message into the MLME queue
+    Parameters:
+        Standard timer parameters
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID  DisassocTimeout(unsigned long data)
+{
+	PRT2570ADAPTER	pAd = (PRT2570ADAPTER)data;
+	DBGPRINT(RT_DEBUG_TRACE,"ASSOC - enqueue MT2_DISASSOC_TIMEOUT \n");
+
+	// Do nothing if the driver is starting halt state.
+	// This might happen when timer already been fired before cancel timer with mlmehalt
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+		return;
+
+	MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_DISASSOC_TIMEOUT, 0, NULL);
+	//KeSetEvent(&pAd->MLMEEvent, 0, FALSE);	
+	RTUSBUp(pAd, (&(pAd->mlme_semaphore)));
+}
+
+/*
+    ==========================================================================
+    Description:
+        mlme assoc req handling procedure
+    Parameters:
+        Adapter - Adapter pointer
+        Elem - MLME Queue Element
+    Pre:
+        the station has been authenticated and the following information is stored in the config
+            -# SSID
+            -# supported rates and their length
+            -# listen interval (Adapter->PortCfg.default_listen_count)
+            -# Transmit power  (Adapter->PortCfg.tx_power)
+    Post  :
+        -# An association request frame is generated and sent to the air
+        -# Association timer starts
+        -# Association state -> ASSOC_WAIT_RSP
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID MlmeAssocReqAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+	MACADDR          ApAddr;
+	MACHDR           AssocHdr;
+	UCHAR            SsidIe = IE_SSID, RateIe = IE_SUPP_RATES, ExtRateIe = IE_EXT_SUPP_RATES;
+	UCHAR			 CipherTmp[64];
+	UCHAR			 CipherTmpLen;
+	USHORT           ListenIntv;
+	ULONG            Timeout;
+	USHORT           CapabilityInfo;
+	UCHAR           *OutBuffer = NULL;
+	NDIS_STATUS      NStatus;
+	ULONG            FrameLen = 0;
+	ULONG			 tmp, idx;
+	BOOLEAN			 FoundPMK = FALSE;
+	UCHAR			 VarIesOffset;
+
+	// Block all authentication request durning WPA block period
+	if (pAd->PortCfg.bBlockAssoc == TRUE)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Block Assoc request durning WPA block period!\n");
+		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+		MlmeCntlConfirm(pAd, MT2_ASSOC_CONF, MLME_STATE_MACHINE_REJECT);
+	}	
+	// check sanity first
+	else if (MlmeAssocReqSanity(pAd, Elem->Msg, Elem->MsgLen, &ApAddr, &CapabilityInfo, &Timeout, &ListenIntv)) 
+	{
+        RTMPCancelTimer(&pAd->Mlme.AssocAux.AssocTimer);
+        COPY_MAC_ADDR(&pAd->Mlme.AssocAux.Addr, &ApAddr);
+		// Mask out unnecessary capability information
+		CapabilityInfo &= SUPPORTED_CAPABILITY_INFO; // pAd->PortCfg.SupportedCapabilityInfo;
+        pAd->Mlme.AssocAux.CapabilityInfo = CapabilityInfo;
+        pAd->Mlme.AssocAux.ListenIntv = ListenIntv;
+
+        NStatus = MlmeAllocateMemory(pAd, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+        if (NStatus != NDIS_STATUS_SUCCESS) 
+        {
+            DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeAssocReqAction() allocate memory failed \n");
+            pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+            MlmeCntlConfirm(pAd, MT2_ASSOC_CONF, MLME_FAIL_NO_RESOURCE);
+            return;
+        }
+        
+		// Add by James 03/06/27
+		pAd->PortCfg.AssocInfo.Length = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
+		// Association don't need to report MAC address
+		pAd->PortCfg.AssocInfo.AvailableRequestFixedIEs =
+			NDIS_802_11_AI_REQFI_CAPABILITIES | NDIS_802_11_AI_REQFI_LISTENINTERVAL;
+		pAd->PortCfg.AssocInfo.RequestFixedIEs.Capabilities = CapabilityInfo;
+		pAd->PortCfg.AssocInfo.RequestFixedIEs.ListenInterval = ListenIntv;		
+		// Only reassociate need this
+		// memcpy(pAd->PortCfg.AssocInfo.RequestFixedIEs.CurrentAPAddress, &AssocHdr, sizeof(NDIS_802_11_MAC_ADDRESS));
+		pAd->PortCfg.AssocInfo.OffsetRequestIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);	
+		
+		// First add SSID
+		VarIesOffset = 0;
+		memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, &SsidIe, 1);
+		VarIesOffset += 1;
+		memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, &pAd->PortCfg.SsidLen, 1);
+		VarIesOffset += 1;
+		memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, pAd->PortCfg.Ssid, pAd->PortCfg.SsidLen);
+		VarIesOffset += pAd->PortCfg.SsidLen;
+
+		// Second add Supported rates
+		memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, &RateIe, 1);
+		VarIesOffset += 1;
+		memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, &pAd->PortCfg.SupportedRatesLen, 1);
+		VarIesOffset += 1;
+		memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, pAd->PortCfg.SupportedRates, pAd->PortCfg.SupportedRatesLen);
+		VarIesOffset += pAd->PortCfg.SupportedRatesLen;
+		// End Add by James
+
+        MgtMacHeaderInit(pAd, &AssocHdr, SUBTYPE_ASSOC_REQ, 0, &ApAddr, &ApAddr);
+		
+		// Build basic frame first
+		MakeOutgoingFrame(
+			OutBuffer,					&FrameLen,
+						  sizeof(MACHDR),			&AssocHdr,
+						  2,						&CapabilityInfo,
+						  2,						&ListenIntv,
+						  1,						&SsidIe,
+						  1,						&pAd->PortCfg.SsidLen, 
+						  pAd->PortCfg.SsidLen, 	pAd->PortCfg.Ssid,
+						  1,						&RateIe,
+						  1,						&pAd->PortCfg.SupRateLen,
+						  pAd->PortCfg.SupRateLen,  pAd->PortCfg.SupRate,
+						  END_OF_ARGS);
+		if (pAd->PortCfg.ExtRateLen != 0)
+		{
+			MakeOutgoingFrame(
+				OutBuffer + FrameLen,		&tmp,
+						1,							&ExtRateIe,
+						1,							&pAd->PortCfg.ExtRateLen,
+						pAd->PortCfg.ExtRateLen,	pAd->PortCfg.ExtRate,							
+						END_OF_ARGS);
+			FrameLen += tmp;
+		}
+		
+		// For WPA / WPA-PSK
+		if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
+		{
+			// Copy WPA template to buffer
+			CipherTmpLen = sizeof(CipherWpaTemplate);
+			memcpy(CipherTmp, CipherWpaTemplate, CipherTmpLen);
+			// Modify Group cipher
+			CipherTmp[11] = ((pAd->PortCfg.GroupCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);			
+			// Modify Pairwise cipher
+			CipherTmp[17] = ((pAd->PortCfg.PairCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
+			// Modify AKM
+			CipherTmp[23] = ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) ? 0x1 : 0x2);
+			// Make outgoing frame
+			MakeOutgoingFrame(
+				OutBuffer + FrameLen,	&tmp,
+				CipherTmpLen,			&CipherTmp[0],
+				END_OF_ARGS);
+			FrameLen += tmp;
+			
+			// Append Variable IE
+			memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, CipherTmp, CipherTmpLen);
+			VarIesOffset += CipherTmpLen;
+			
+			// Set Variable IEs Length
+			pAd->PortCfg.ReqVarIELen = VarIesOffset;
+			pAd->PortCfg.AssocInfo.RequestIELength = VarIesOffset;
+			// OffsetResponseIEs follow ReqVarIE
+			pAd->PortCfg.AssocInfo.OffsetResponseIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAd->PortCfg.ReqVarIELen;			
+		}
+		// For WPA2 / WPA2-PSK
+		else if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+		{
+			// Copy WPA2 template to buffer
+			CipherTmpLen = sizeof(CipherWpa2Template);
+			memcpy(CipherTmp, CipherWpa2Template, CipherTmpLen);
+			// Modify Group cipher
+			CipherTmp[7] = ((pAd->PortCfg.GroupCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);			
+			// Modify Pairwise cipher
+			CipherTmp[13] = ((pAd->PortCfg.PairCipher == Ndis802_11Encryption2Enabled) ? 0x2 : 0x4);
+			// Modify AKM
+			CipherTmp[19] = ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) ? 0x1 : 0x2);
+			// Check for WPA PMK cache list
+			if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2)
+			{
+				// Search chched PMKID, append it if existed
+				for (idx = 0; idx < PMKID_NO; idx++)
+				{
+					if (memcmp(&ApAddr, &pAd->PortCfg.SavedPMK[idx], 6) == 0)
+					{
+						FoundPMK = TRUE;
+						break;
+					}
+						
+				}
+				if (FoundPMK)
+				{
+					// Update length within RSN IE
+					CipherTmp[1] += 18;
+					// Set PMK number
+					*(PUSHORT) &CipherTmp[CipherTmpLen] = 1;
+					memcpy(&CipherTmp[CipherTmpLen + 2], &pAd->PortCfg.SavedPMK[idx].PMKID, 16);
+					CipherTmpLen += 18;
+				}
+			}
+			
+			// Make outgoing frame
+			MakeOutgoingFrame(
+				OutBuffer + FrameLen,	&tmp,
+				CipherTmpLen,			&CipherTmp[0],
+				END_OF_ARGS);
+			FrameLen += tmp;
+
+			// Append Variable IE
+			memcpy(pAd->PortCfg.ReqVarIEs + VarIesOffset, CipherTmp, CipherTmpLen);
+			VarIesOffset += CipherTmpLen;
+			
+			// Set Variable IEs Length
+			pAd->PortCfg.ReqVarIELen = VarIesOffset;
+			pAd->PortCfg.AssocInfo.RequestIELength = VarIesOffset;
+			// OffsetResponseIEs follow ReqVarIE
+			pAd->PortCfg.AssocInfo.OffsetResponseIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAd->PortCfg.ReqVarIELen;			
+		}
+		else
+		{
+			// Do nothing
+			;
+		}
+
+        MiniportMMRequest(pAd, OutBuffer, FrameLen);
+            
+        RTMPSetTimer(pAd, &pAd->Mlme.AssocAux.AssocTimer, Timeout); /* in mSec */
+        pAd->Mlme.AssocMachine.CurrState = ASSOC_WAIT_RSP;
+    } 
+    else 
+    {
+        DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeAssocReqAction() sanity check failed. BUG!!!!!! \n");
+        pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+        MlmeCntlConfirm(pAd, MT2_ASSOC_CONF, MLME_INVALID_FORMAT);
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+        mlme reassoc req handling procedure
+    Parameters:
+        Elem - 
+    Pre:
+        -# SSID  (Adapter->PortCfg.ssid[])
+        -# BSSID (AP address, Adapter->PortCfg.bssid)
+        -# Supported rates (Adapter->PortCfg.supported_rates[])
+        -# Supported rates length (Adapter->PortCfg.supported_rates_len)
+        -# Tx power (Adapter->PortCfg.tx_power)
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID MlmeReassocReqAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+	MACADDR              ApAddr;
+	MACHDR               ReassocHdr;
+	UCHAR                SsidIe = IE_SSID, RateIe = IE_SUPP_RATES, ExtRateIe = IE_EXT_SUPP_RATES;
+	USHORT               CapabilityInfo, ListenIntv;
+	ULONG                Timeout;
+	ULONG                FrameLen = 0;
+	NDIS_STATUS          NStatus;
+	ULONG			 	 tmp;
+	UCHAR               *OutBuffer = NULL;
+
+	// Block all authentication request durning WPA block period
+	if (pAd->PortCfg.bBlockAssoc == TRUE)
+	{
+        DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Block ReAssoc request durning WPA block period!\n");
+        pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+        MlmeCntlConfirm(pAd, MT2_ASSOC_CONF, MLME_STATE_MACHINE_REJECT);
+	}	
+    // the parameters are the same as the association
+    else if(MlmeAssocReqSanity(pAd, Elem->Msg, Elem->MsgLen, &ApAddr, &CapabilityInfo, &Timeout, &ListenIntv)) 
+    {
+        RTMPCancelTimer(&pAd->Mlme.AssocAux.ReassocTimer);
+
+        NStatus = MlmeAllocateMemory(pAd, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+        if(NStatus != NDIS_STATUS_SUCCESS) 
+        {
+            DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeReassocReqAction() allocate memory failed \n");
+            pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+            MlmeCntlConfirm(pAd, MT2_REASSOC_CONF, MLME_FAIL_NO_RESOURCE);
+            return;
+        }
+
+		// Mask out unnecessary capability information
+		CapabilityInfo &= SUPPORTED_CAPABILITY_INFO;  // pAd->PortCfg.SupportedCapabilityInfo;
+        pAd->Mlme.AssocAux.CapabilityInfo = CapabilityInfo;
+        COPY_MAC_ADDR(&pAd->Mlme.AssocAux.Addr, &ApAddr);
+        pAd->Mlme.AssocAux.ListenIntv = ListenIntv;
+
+        // make frame, use bssid as the AP address??
+        DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Send RE-ASSOC request...\n");
+        MgtMacHeaderInit(pAd, &ReassocHdr, SUBTYPE_REASSOC_REQ, 0, &ApAddr, &ApAddr);
+        MakeOutgoingFrame(OutBuffer,            &FrameLen,
+                          sizeof(MACHDR),       &ReassocHdr,
+                          2,                    &CapabilityInfo,
+                          2,                    &ListenIntv,
+                          MAC_ADDR_LEN,         &ApAddr,
+                          1,                    &SsidIe,
+                          1,                    &pAd->PortCfg.SsidLen, 
+                          pAd->PortCfg.SsidLen, pAd->PortCfg.Ssid, 
+                          1,                    &RateIe,
+						  1,						&pAd->PortCfg.SupRateLen,
+						  pAd->PortCfg.SupRateLen,  pAd->PortCfg.SupRate,
+                          END_OF_ARGS);
+		if (pAd->PortCfg.ExtRateLen != 0)
+		{
+			MakeOutgoingFrame(OutBuffer + FrameLen, &tmp,
+						1,							&ExtRateIe,
+						1,							&pAd->PortCfg.ExtRateLen,
+						pAd->PortCfg.ExtRateLen,	pAd->PortCfg.ExtRate,							
+						END_OF_ARGS);
+			FrameLen += tmp;
+		}
+        MiniportMMRequest(pAd, OutBuffer, FrameLen);
+            
+        RTMPSetTimer(pAd, &pAd->Mlme.AssocAux.ReassocTimer, Timeout); /* in mSec */
+        pAd->Mlme.AssocMachine.CurrState = REASSOC_WAIT_RSP;
+    } 
+    else 
+    {
+        DBGPRINT(RT_DEBUG_TRACE,"ASSOC - MlmeReassocReqAction() sanity check failed. BUG!!!! \n");
+        pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+        MlmeCntlConfirm(pAd, MT2_REASSOC_CONF, MLME_INVALID_FORMAT);
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+        Upper layer issues disassoc request
+    Parameters:
+        Elem -
+        
+	IRQL = PASSIVE_LEVEL
+
+    ==========================================================================
+ */
+VOID MlmeDisassocReqAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    MLME_DISASSOC_REQ_STRUCT *DisassocReq;
+    MACHDR                DisassocHdr;
+    CHAR                 *OutBuffer = NULL;
+    ULONG                 FrameLen = 0;
+    NDIS_STATUS           NStatus;
+    ULONG                       Timeout = 0;
+
+    // skip sanity check
+    DisassocReq = (MLME_DISASSOC_REQ_STRUCT *)(Elem->Msg);
+
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS) 
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "ASSOC - MlmeDisassocReqAction() allocate memory failed\n");
+        pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+        MlmeCntlConfirm(pAd, MT2_DISASSOC_CONF, MLME_FAIL_NO_RESOURCE);
+        return;
+    }
+    
+    RTMPCancelTimer(&pAd->Mlme.AssocAux.DisassocTimer);
+    
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Send DISASSOC request\n");
+    MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, &pAd->PortCfg.Bssid, &pAd->PortCfg.Bssid);
+    MakeOutgoingFrame(OutBuffer,            &FrameLen, 
+                      sizeof(MACHDR),       &DisassocHdr, 
+                      2,                    &DisassocReq->Reason, 
+                      END_OF_ARGS);
+    MiniportMMRequest(pAd, OutBuffer, FrameLen);
+    memset(&(pAd->PortCfg.Bssid), 0, MAC_ADDR_LEN);
+    
+    pAd->PortCfg.DisassocReason = REASON_DISASSOC_STA_LEAVING;
+    COPY_MAC_ADDR(&pAd->PortCfg.DisassocSta, &DisassocReq->Addr);
+
+    RTMPSetTimer(pAd, &pAd->Mlme.AssocAux.DisassocTimer, Timeout); /* in mSec */
+    pAd->Mlme.AssocMachine.CurrState = DISASSOC_WAIT_RSP;
+}
+
+/*
+    ==========================================================================
+    Description:
+        peer sends assoc rsp back
+    Parameters:
+        Elme - MLME message containing the received frame
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID PeerAssocRspAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    USHORT        CapabilityInfo, Status, Aid;
+    UCHAR         Rates[MAX_LEN_OF_SUPPORTED_RATES], RatesLen;
+    MACADDR       Addr2;
+    BOOLEAN       ExtendedRateIeExist;
+
+    if (PeerAssocRspSanity(pAd, Elem->Msg, Elem->MsgLen, &Addr2, &CapabilityInfo, &Status, &Aid, Rates, &RatesLen, &ExtendedRateIeExist)) 
+    {
+        // The frame is for me ?
+        if(MAC_ADDR_EQUAL(&Addr2, &pAd->Mlme.AssocAux.Addr)) 
+        {
+            DBGPRINT(RT_DEBUG_INFO, "ASSOC - receive ASSOC_RSP to me (status=%d)\n", Status);
+            RTMPCancelTimer(&pAd->Mlme.AssocAux.AssocTimer);
+            if(Status == MLME_SUCCESS) 
+            {
+                // go to procedure listed on page 376
+				// Mask out unnecessary capability information
+				CapabilityInfo &= SUPPORTED_CAPABILITY_INFO;  // pAd->PortCfg.SupportedCapabilityInfo;
+                AssocPostProc(pAd, &Addr2, CapabilityInfo, Aid, Rates, RatesLen, ExtendedRateIeExist);
+            } 
+            pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+            MlmeCntlConfirm(pAd, MT2_ASSOC_CONF, Status);
+        } 
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "ASSOC - PeerAssocRspAction() sanity check fail\n");
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+        peer sends reassoc rsp
+    Parametrs:
+        Elem - MLME message cntaining the received frame
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID PeerReassocRspAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    USHORT      CapabilityInfo;
+    USHORT      Status;
+    USHORT      Aid;
+    UCHAR       Rates[MAX_LEN_OF_SUPPORTED_RATES];
+    UCHAR       RatesLen;
+    MACADDR     Addr2;
+    BOOLEAN     ExtendedRateIeExist;
+
+    if(PeerAssocRspSanity(pAd, Elem->Msg, Elem->MsgLen, &Addr2, &CapabilityInfo, &Status, &Aid, Rates, &RatesLen, &ExtendedRateIeExist)) 
+    {
+        if(MAC_ADDR_EQUAL(&Addr2, &pAd->Mlme.AssocAux.Addr)) // The frame is for me ?
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "ASSOC - receive REASSOC_RSP to me (status=%d)\n", Status);
+            RTMPCancelTimer(&pAd->Mlme.AssocAux.ReassocTimer);
+            
+            if(Status == MLME_SUCCESS) 
+            {
+				// Mask out unnecessary capability information
+				CapabilityInfo &= SUPPORTED_CAPABILITY_INFO;  // pAd->PortCfg.SupportedCapabilityInfo;
+                // go to procedure listed on page 376
+                AssocPostProc(pAd, &Addr2, CapabilityInfo, Aid, Rates, RatesLen, ExtendedRateIeExist);
+            } 
+
+            pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+            MlmeCntlConfirm(pAd, MT2_REASSOC_CONF, Status);
+        } 
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "ASSOC - PeerReassocRspAction() sanity check fail\n");
+    }
+
+}
+
+/*
+    ==========================================================================
+    Description:
+        procedures on IEEE 802.11/1999 p.376 
+    Parametrs:
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID AssocPostProc(
+    IN PRT2570ADAPTER pAd, 
+    IN PMACADDR Addr2, 
+    IN USHORT CapabilityInfo, 
+    IN USHORT Aid, 
+    IN UCHAR Rates[], 
+    IN UCHAR RatesLen,
+    IN BOOLEAN ExtendedRateIeExist) 
+{
+	ULONG Idx;
+    UCHAR RateIe = IE_SUPP_RATES;
+	UCHAR VarIesOffset;
+
+    // 2003/12/11 -  skip the following because experiment show that we can not 
+    // trust the "privacy" bit in AssocRsp. We can only trust "Privacy" bit specified in
+    // BEACON and ProbeRsp.
+    // pAd->PortCfg.PrivacyInvoked = CAP_IS_PRIVACY_ON(CapabilityInfo);
+    
+    pAd->PortCfg.Aid = Aid;
+    memcpy(pAd->PortCfg.SupportedRates, Rates, RatesLen);
+    pAd->PortCfg.SupportedRatesLen = RatesLen;
+    COPY_MAC_ADDR(&pAd->PortCfg.Bssid, Addr2);
+    AsicSetBssid(pAd, &pAd->PortCfg.Bssid);
+
+    // set listen interval
+    pAd->PortCfg.DefaultListenCount = pAd->Mlme.AssocAux.ListenIntv;
+//  pAd->PortCfg.CurrListenCount = pAd->Mlme.AssocAux.ListenIntv;
+
+	// Set New WPA information
+	Idx = BssTableSearch(&pAd->PortCfg.BssTab, Addr2);
+	if (Idx == BSS_NOT_FOUND) 
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "ASSOC - Can't find BSS after receiving Assoc response\n");
+	}
+	else
+	{
+		// Mod by James to fix OID_802_11_ASSOCIATION_INFORMATION
+		pAd->PortCfg.AssocInfo.Length = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION); //+ sizeof(NDIS_802_11_FIXED_IEs); 	// Filled in assoc request
+		pAd->PortCfg.AssocInfo.AvailableResponseFixedIEs =
+			NDIS_802_11_AI_RESFI_CAPABILITIES | NDIS_802_11_AI_RESFI_STATUSCODE | NDIS_802_11_AI_RESFI_ASSOCIATIONID;
+		pAd->PortCfg.AssocInfo.ResponseFixedIEs.Capabilities  = CapabilityInfo;
+		pAd->PortCfg.AssocInfo.ResponseFixedIEs.StatusCode    = MLME_SUCCESS;		// Should be success, add failed later
+		pAd->PortCfg.AssocInfo.ResponseFixedIEs.AssociationId = Aid;
+
+		// Copy BSS VarIEs to PortCfg associnfo structure.
+		// First add Supported rates
+		VarIesOffset = 0;
+		memcpy(pAd->PortCfg.ResVarIEs + VarIesOffset, &RateIe, 1);
+		VarIesOffset += 1;
+		memcpy(pAd->PortCfg.ResVarIEs + VarIesOffset, &RatesLen, 1);
+		VarIesOffset += 1;
+		memcpy(pAd->PortCfg.ResVarIEs + VarIesOffset, Rates, RatesLen);
+		VarIesOffset += RatesLen;
+
+		// Second add RSN
+		memcpy(pAd->PortCfg.ResVarIEs + VarIesOffset, pAd->PortCfg.BssTab.BssEntry[Idx].VarIEs, pAd->PortCfg.BssTab.BssEntry[Idx].VarIELen);
+		VarIesOffset += pAd->PortCfg.BssTab.BssEntry[Idx].VarIELen;
+		
+		// Set Variable IEs Length
+		pAd->PortCfg.ResVarIELen = VarIesOffset;
+		pAd->PortCfg.AssocInfo.ResponseIELength = VarIesOffset;
+	}
+}
+
+/*
+    ==========================================================================
+    Description:
+        left part of IEEE 802.11/1999 p.374 
+    Parameters:
+        Elem - MLME message containing the received frame
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID PeerDisassocAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    MACADDR       Addr2;
+    USHORT        Reason;
+
+    if(PeerDisassocSanity(pAd, Elem->Msg, Elem->MsgLen, &Addr2, &Reason)) 
+    {
+        if (INFRA_ON(pAd) && MAC_ADDR_EQUAL(&pAd->PortCfg.Bssid, &Addr2)) 
+        {
+			DBGPRINT_RAW(RT_DEBUG_TRACE, "LinkDown(PeerDisassocAction(Reason = %d))\n", Reason);//steven:for debug
+            LinkDown(pAd);
+            pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+
+            // 2002/11/21 -
+            // patch RT2430/RT2420 hangup issue. We suspect this AP DIS-ASSOCIATE frame
+            // is caused by PHY hangup, so we reset PHY, then auto recover the connection.
+            // if this attempt fails, then remains in LinkDown and leaves the problem
+            // to MlmePeriodicExec()
+            // NICPatchRT2430Bug(pAd);
+            pAd->RalinkCounters.BeenDisassociatedCount ++;
+			// Remove auto recover effort when disassociate by AP, re-enable for patch 2430 only
+            DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Disassociated by AP, Auto Recovery attempt #%d\n", pAd->RalinkCounters.BeenDisassociatedCount);
+            MlmeAutoReconnectLastSSID(pAd);
+        }
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "ASSOC - PeerDisassocAction() sanity check fail\n");
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+        what the state machine will do after assoc timeout
+    Parameters:
+        Elme -
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID AssocTimeoutAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - AssocTimeoutAction\n");
+    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+    MlmeCntlConfirm(pAd, MT2_ASSOC_CONF, MLME_REJ_TIMEOUT);
+}
+
+/*
+    ==========================================================================
+    Description:
+        what the state machine will do after reassoc timeout
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID ReassocTimeoutAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - ReassocTimeoutAction\n");
+    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+    MlmeCntlConfirm(pAd, MT2_REASSOC_CONF, MLME_REJ_TIMEOUT);
+}
+
+/*
+    ==========================================================================
+    Description:
+        what the state machine will do after disassoc timeout
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID DisassocTimeoutAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - DisassocTimeoutAction\n");
+    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+    MlmeCntlConfirm(pAd, MT2_DISASSOC_CONF, MLME_SUCCESS);
+}
+
+VOID InvalidStateWhenAssoc(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - InvalidStateWhenAssoc(state=%d), reset ASSOC state machine\n", 
+        pAd->Mlme.AssocMachine.CurrState);
+    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+    MlmeCntlConfirm(pAd, MT2_ASSOC_CONF, MLME_STATE_MACHINE_REJECT);
+}
+
+VOID InvalidStateWhenReassoc(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - InvalidStateWhenReassoc(state=%d), reset ASSOC state machine\n", 
+        pAd->Mlme.AssocMachine.CurrState);
+    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+    MlmeCntlConfirm(pAd, MT2_REASSOC_CONF, MLME_STATE_MACHINE_REJECT);
+}
+
+VOID InvalidStateWhenDisassociate(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - InvalidStateWhenDisassoc(state=%d), reset ASSOC state machine\n", 
+        pAd->Mlme.AssocMachine.CurrState);
+    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+    MlmeCntlConfirm(pAd, MT2_DISASSOC_CONF, MLME_STATE_MACHINE_REJECT);
+}
+
+/*
+    ==========================================================================
+    Description:
+        right part of IEEE 802.11/1999 page 374
+    Note: 
+        This event should never cause ASSOC state machine perform state
+        transition, and has no relationship with CNTL machine. So we separate
+        this routine as a service outside of ASSOC state transition table.
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID Cls3errAction(
+    IN PRT2570ADAPTER pAd, 
+    IN PMACADDR      pAddr) 
+{
+    MACHDR                DisassocHdr;
+    CHAR                 *OutBuffer = NULL;
+    ULONG                 FrameLen = 0;
+    NDIS_STATUS           NStatus;
+    USHORT                Reason = REASON_CLS3ERR;
+
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS) 
+        return;
+    
+    DBGPRINT(RT_DEBUG_TRACE, "ASSOC - Class 3 Error, Send DISASSOC frame\n");
+    MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pAddr, &pAd->PortCfg.Bssid);
+    MakeOutgoingFrame(OutBuffer,            &FrameLen, 
+                      sizeof(MACHDR),       &DisassocHdr, 
+                      2,                    &Reason, 
+                      END_OF_ARGS);
+    MiniportMMRequest(pAd, OutBuffer, FrameLen);
+
+    pAd->PortCfg.DisassocReason = REASON_CLS3ERR;
+    COPY_MAC_ADDR(&pAd->PortCfg.DisassocSta, pAddr);
+}
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/auth.c linux-2.4.35.3-mct/drivers/usb/rt2570/auth.c
--- linux-2.4.35.3/drivers/usb/rt2570/auth.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/auth.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,428 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	auth.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+/*
+    ==========================================================================
+    Description:
+        authenticate state machine init, including state transition and timer init
+    Parameters:
+        Sm - pointer to the auth state machine
+    Note:
+        The state machine looks like this
+        
+                        AUTH_REQ_IDLE           AUTH_WAIT_SEQ2                   AUTH_WAIT_SEQ4
+    MT2_MLME_AUTH_REQ   mlme_auth_req_action    invalid_state_when_auth          invalid_state_when_auth
+    MT2_MLME_DEAUTH_REQ mlme_deauth_req_action  mlme_deauth_req_action           mlme_deauth_req_action
+    MT2_CLS2ERR         cls2err_action          cls2err_action                   cls2err_action
+    MT2_PEER_AUTH_EVEN  drop                    peer_auth_even_at_seq2_action    peer_auth_even_at_seq4_action
+    MT2_AUTH_TIMEOUT    Drop                    auth_timeout_action              auth_timeout_action
+        
+	IRQL = PASSIVE_LEVEL
+
+    ==========================================================================
+ */
+
+void AuthStateMachineInit(
+    IN PRT2570ADAPTER pAd, 
+    IN STATE_MACHINE *Sm, 
+    OUT STATE_MACHINE_FUNC Trans[]) 
+{
+    StateMachineInit(Sm, Trans, MAX_AUTH_STATE, MAX_AUTH_MSG, (STATE_MACHINE_FUNC)Drop, AUTH_REQ_IDLE, AUTH_MACHINE_BASE);
+     
+    // the first column
+    StateMachineSetAction(Sm, AUTH_REQ_IDLE, MT2_MLME_AUTH_REQ, (STATE_MACHINE_FUNC)MlmeAuthReqAction);
+//  StateMachineSetAction(Sm, AUTH_REQ_IDLE, MT2_MLME_DEAUTH_REQ, MlmeDeauthReqAction);
+//  StateMachineSetAction(Sm, AUTH_REQ_IDLE, MT2_CLS2ERR, Cls2errAction);
+
+    // the second column
+    StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_MLME_AUTH_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAuth);
+//  StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_MLME_DEAUTH_REQ, MlmeDeauthReqAction);
+//  StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_CLS2ERR, Cls2errAction);
+    StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_PEER_AUTH_EVEN, (STATE_MACHINE_FUNC)PeerAuthRspAtSeq2Action);
+    StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_AUTH_TIMEOUT, (STATE_MACHINE_FUNC)AuthTimeoutAction);
+    
+    // the third column
+    StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_MLME_AUTH_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAuth);
+//  StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_MLME_DEAUTH_REQ, MlmeDeauthReqAction);
+//  StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_CLS2ERR, Cls2errAction);
+    StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_PEER_AUTH_EVEN, (STATE_MACHINE_FUNC)PeerAuthRspAtSeq4Action);
+    StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_AUTH_TIMEOUT, (STATE_MACHINE_FUNC)AuthTimeoutAction);
+    
+    RTMPInitTimer(pAd, &pAd->Mlme.AuthAux.AuthTimer, AuthTimeout);
+}
+
+/*
+    ==========================================================================
+    Description:
+        function to be executed at timer thread when auth timer expires
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID  AuthTimeout(unsigned long data)
+{
+	PRT2570ADAPTER	pAd = (PRT2570ADAPTER)data;
+
+	DBGPRINT(RT_DEBUG_TRACE,"AUTH - AuthTimeout\n");
+
+	// Do nothing if the driver is starting halt state.
+	// This might happen when timer already been fired before cancel timer with mlmehalt
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+		return;
+
+	MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_AUTH_TIMEOUT, 0, NULL);
+	RTUSBUp(pAd, &pAd->mlme_semaphore);
+}
+
+/*
+    ==========================================================================
+    Description:
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID MlmeAuthReqAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+	MACADDR            Addr;
+	USHORT             Alg, Seq, Status;
+	ULONG              Timeout;
+	MACHDR             AuthHdr;
+	NDIS_STATUS        NStatus;
+	UCHAR             *OutBuffer = NULL;
+	ULONG              FrameLen = 0;
+
+	// Block all authentication request durning WPA block period
+	if (pAd->PortCfg.bBlockAssoc == TRUE)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "AUTH - Block Auth request durning WPA block period!\n");
+		pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+		MlmeCntlConfirm(pAd, MT2_AUTH_CONF, MLME_STATE_MACHINE_REJECT);
+	}	
+	else if(MlmeAuthReqSanity(pAd, Elem->Msg, Elem->MsgLen, &Addr, &Timeout, &Alg)) 
+	{
+		// reset timer
+		RTMPCancelTimer(&pAd->Mlme.AuthAux.AuthTimer);
+		pAd->Mlme.AuthAux.Addr = Addr;
+		pAd->Mlme.AuthAux.Alg  = Alg;
+		pAd->PortCfg.Mauth = FALSE;
+		Seq = 1;
+		Status = MLME_SUCCESS;
+
+		NStatus = MlmeAllocateMemory(pAd, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+		if(NStatus != NDIS_STATUS_SUCCESS) 
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "AUTH - MlmeAuthReqAction() allocate memory failed\n");
+			pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+			MlmeCntlConfirm(pAd, MT2_AUTH_CONF, MLME_FAIL_NO_RESOURCE);
+			return;
+		}
+
+		DBGPRINT(RT_DEBUG_INFO, "AUTH - Send AUTH request seq#1 (Alg=%d)...\n", Alg);
+		MgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, &Addr, &pAd->PortCfg.Bssid);
+		MakeOutgoingFrame(OutBuffer,            &FrameLen, 
+		              MAC_HDR_LEN,          &AuthHdr, 
+		              2,                    &Alg, 
+		              2,                    &Seq, 
+		              2,                    &Status, 
+		              END_OF_ARGS);
+		MiniportMMRequest(pAd, OutBuffer, FrameLen);
+
+		RTMPSetTimer(pAd, &pAd->Mlme.AuthAux.AuthTimer, Timeout);
+		pAd->Mlme.AuthMachine.CurrState = AUTH_WAIT_SEQ2;
+	} 
+	else 
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "AUTH - MlmeAuthReqAction() sanity check failed. BUG!!!!!\n");
+		pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+		MlmeCntlConfirm(pAd, MT2_AUTH_CONF, MLME_INVALID_FORMAT);
+	}
+}
+
+/*
+    ==========================================================================
+    Description:
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID PeerAuthRspAtSeq2Action(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    MACADDR       Addr2;
+    USHORT        Seq, Status, RemoteStatus, Alg;
+    UCHAR         ChlgText[CIPHER_TEXT_LEN];
+    UCHAR         CyperChlgText[CIPHER_TEXT_LEN + 8 + 8];
+    UCHAR         Element[2];
+    MACHDR        AuthHdr;
+    UCHAR        *OutBuffer = NULL;
+    NDIS_STATUS   NStatus;
+    ULONG         FrameLen = 0;
+
+    if (PeerAuthSanity(pAd, Elem->Msg, Elem->MsgLen, &Addr2, &Alg, &Seq, &Status, ChlgText)) 
+    {
+        if (MAC_ADDR_EQUAL(&pAd->Mlme.AuthAux.Addr, &Addr2) && Seq == 2) 
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "AUTH - Receive AUTH_RSP seq#2 to me (Alg=%d, Status=%d)\n", Alg, Status);
+            RTMPCancelTimer(&pAd->Mlme.AuthAux.AuthTimer);
+            
+            if (Status == MLME_SUCCESS) 
+            {
+                if (pAd->Mlme.AuthAux.Alg == Ndis802_11AuthModeOpen) 
+                {
+                    pAd->PortCfg.Mauth = TRUE;
+                    pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+                    MlmeCntlConfirm(pAd, MT2_AUTH_CONF, MLME_SUCCESS);
+                } 
+                else 
+                {
+                    // 2. shared key, need to be challenged
+                    Seq++;
+                    RemoteStatus = MLME_SUCCESS;
+                    NStatus = MlmeAllocateMemory(pAd, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+                    if(NStatus != NDIS_STATUS_SUCCESS) 
+                    {
+                        DBGPRINT(RT_DEBUG_TRACE, "AUTH - PeerAuthRspAtSeq2Action() allocate memory fail\n");
+                        pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+                        MlmeCntlConfirm(pAd, MT2_AUTH_CONF, MLME_FAIL_NO_RESOURCE);
+                        return;
+                    }
+                    
+                    DBGPRINT(RT_DEBUG_TRACE, "AUTH - Send AUTH request seq#3...\n");
+                    MgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, &Addr2, &pAd->PortCfg.Bssid);
+                    AuthHdr.Wep = 1;
+                    // Encrypt challenge text & auth information
+                    RTMPInitWepEngine(
+                    	pAd,
+                    	pAd->PortCfg.SharedKey[pAd->PortCfg.DefaultKeyId].Key,
+                    	pAd->PortCfg.DefaultKeyId,
+                    	pAd->PortCfg.SharedKey[pAd->PortCfg.DefaultKeyId].KeyLen,
+                    	CyperChlgText);
+					RTMPEncryptData(pAd, (PUCHAR) &Alg, CyperChlgText + 4, 2);
+					RTMPEncryptData(pAd, (PUCHAR) &Seq, CyperChlgText + 6, 2);
+					RTMPEncryptData(pAd, (PUCHAR) &RemoteStatus, CyperChlgText + 8, 2);
+					Element[0] = 16;
+					Element[1] = 128;
+					RTMPEncryptData(pAd, Element, CyperChlgText + 10, 2);
+					RTMPEncryptData(pAd, ChlgText, CyperChlgText + 12, 128);
+					RTMPSetICV(pAd, CyperChlgText + 140);
+                    MakeOutgoingFrame(OutBuffer,            &FrameLen, 
+                                      MAC_HDR_LEN,          &AuthHdr,  
+                                      CIPHER_TEXT_LEN + 16, CyperChlgText, 
+                                      END_OF_ARGS);
+                    MiniportMMRequest(pAd, OutBuffer, FrameLen);
+
+                    RTMPSetTimer(pAd, &pAd->Mlme.AuthAux.AuthTimer, AUTH_TIMEOUT); //AUTH_KEY_TIMEOUT);
+                    pAd->Mlme.AuthMachine.CurrState = AUTH_WAIT_SEQ4;
+                }
+            } 
+            else 
+            {
+                pAd->PortCfg.AuthFailReason = Status;
+                COPY_MAC_ADDR(&pAd->PortCfg.AuthFailSta, &Addr2);
+                pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+                MlmeCntlConfirm(pAd, MT2_AUTH_CONF, Status);
+            }
+        }
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "AUTH - PeerAuthSanity() sanity check fail\n");
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID PeerAuthRspAtSeq4Action(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    MACADDR       Addr2;
+    USHORT        Alg, Seq, Status;
+    CHAR          ChlgText[CIPHER_TEXT_LEN];
+
+    if(PeerAuthSanity(pAd, Elem->Msg, Elem->MsgLen, &Addr2, &Alg, &Seq, &Status, ChlgText)) 
+    {
+        if(MAC_ADDR_EQUAL(&(pAd->Mlme.AuthAux.Addr), &Addr2) && Seq == 4) 
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "AUTH - Receive AUTH_RSP seq#4 to me\n");
+            RTMPCancelTimer(&pAd->Mlme.AuthAux.AuthTimer);
+            
+            if(Status == MLME_SUCCESS) 
+            {
+                pAd->PortCfg.Mauth = TRUE;
+            } 
+            else 
+            {
+                pAd->PortCfg.AuthFailReason = Status;
+                pAd->PortCfg.AuthFailSta = Addr2;
+            }                
+
+            pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+            MlmeCntlConfirm(pAd, MT2_AUTH_CONF, Status);
+        }
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "AUTH - PeerAuthRspAtSeq4Action() sanity check fail\n");
+    }
+}
+
+/*
+    ==========================================================================
+    Description:
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID MlmeDeauthReqAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    MLME_DEAUTH_REQ_STRUCT *Info;
+    MACHDR        Hdr;
+    UCHAR        *OutBuffer = NULL;
+    NDIS_STATUS   NStatus;
+    ULONG         FrameLen = 0;
+
+    Info = (MLME_DEAUTH_REQ_STRUCT *)Elem->Msg;
+
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS) 
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "AUTH - MlmeDeauthReqAction() allocate memory fail\n");
+        pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+        MlmeCntlConfirm(pAd, MT2_DEAUTH_CONF, MLME_FAIL_NO_RESOURCE);
+        return;
+    }
+
+    DBGPRINT(RT_DEBUG_TRACE, "AUTH - Send DE-AUTH request...\n");
+    MgtMacHeaderInit(pAd, &Hdr, SUBTYPE_DEAUTH, 0, &Info->Addr, &pAd->PortCfg.Bssid);
+    MakeOutgoingFrame(OutBuffer,            &FrameLen, 
+                      sizeof(MACHDR),       &Hdr, 
+                      2,                    &Info->Reason, 
+                      END_OF_ARGS);
+    MiniportMMRequest(pAd, OutBuffer, FrameLen);
+    
+    pAd->PortCfg.DeauthReason = Info->Reason;
+    COPY_MAC_ADDR(&pAd->PortCfg.DeauthSta, &Info->Addr);
+    pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+    MlmeCntlConfirm(pAd, MT2_DEAUTH_CONF, MLME_SUCCESS);
+}
+
+/*
+    ==========================================================================
+    Description:
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID AuthTimeoutAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    DBGPRINT(RT_DEBUG_TRACE, "AUTH - AuthTimeoutAction\n");
+    pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+    MlmeCntlConfirm(pAd, MT2_AUTH_CONF, MLME_REJ_TIMEOUT);
+}
+
+/*
+    ==========================================================================
+    Description:
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID InvalidStateWhenAuth(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    DBGPRINT(RT_DEBUG_TRACE, "AUTH - InvalidStateWhenAuth (state=%d), reset AUTH state machine\n", pAd->Mlme.AuthMachine.CurrState);
+    pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+    MlmeCntlConfirm(pAd, MT2_AUTH_CONF, MLME_STATE_MACHINE_REJECT);
+}
+
+/*
+    ==========================================================================
+    Description:
+        Some STA/AP
+    Note:
+        This action should never trigger AUTH state transition, therefore we
+        separate it from AUTH state machine, and make it as a standalone service
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID Cls2errAction(
+    IN PRT2570ADAPTER pAd, 
+    IN PMACADDR pAddr) 
+{
+    MACHDR        Hdr;
+    UCHAR        *OutBuffer = NULL;
+    NDIS_STATUS   NStatus;
+    ULONG         FrameLen = 0;
+    USHORT        Reason = REASON_CLS2ERR;
+    
+    NStatus = MlmeAllocateMemory(pAd, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS) 
+        return;
+
+    DBGPRINT(RT_DEBUG_TRACE, "AUTH - Class 2 error, Send DEAUTH frame...\n");
+    MgtMacHeaderInit(pAd, &Hdr, SUBTYPE_DEAUTH, 0, pAddr, &pAd->PortCfg.Bssid);
+    MakeOutgoingFrame(OutBuffer,            &FrameLen, 
+                      sizeof(MACHDR),       &Hdr, 
+                      2,                    &Reason, 
+                      END_OF_ARGS);
+    MiniportMMRequest(pAd, OutBuffer, FrameLen);
+
+    pAd->PortCfg.DeauthReason = Reason;
+    COPY_MAC_ADDR(&pAd->PortCfg.DeauthSta, pAddr);
+}
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/auth_rsp.c linux-2.4.35.3-mct/drivers/usb/rt2570/auth_rsp.c
--- linux-2.4.35.3/drivers/usb/rt2570/auth_rsp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/auth_rsp.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,156 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *
+ *	Module Name:	auth_rsp.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+/*
+    ==========================================================================
+    Description:
+        authentication state machine init procedure
+    Parameters:
+        Sm - the state machine
+    Note:
+        the state machine looks like the following 
+        
+                                        AUTH_RSP_IDLE                   AUTH_RSP_WAIT_CHAL
+    MT2_AUTH_CHALLENGE_TIMEOUT    auth_rsp_challenge_timeout_action    auth_rsp_challenge_timeout_action
+    MT2_PEER_AUTH_ODD        peer_auth_at_auth_rsp_idle_action peer_auth_at_auth_rsp_wait_action
+    MT2_PEER_DEAUTH                 peer_deauth_action                 peer_deauth_action
+        
+	IRQL = PASSIVE_LEVEL
+
+    ==========================================================================
+ */
+VOID AuthRspStateMachineInit(
+    IN PRT2570ADAPTER pAd, 
+    IN PSTATE_MACHINE Sm, 
+    IN STATE_MACHINE_FUNC Trans[]) 
+{
+	ULONG        NOW;
+
+	StateMachineInit(Sm, Trans, MAX_AUTH_RSP_STATE, MAX_AUTH_RSP_MSG, (STATE_MACHINE_FUNC)Drop, AUTH_RSP_IDLE, AUTH_RSP_MACHINE_BASE);
+
+	// column 1
+	//  StateMachineSetAction(Sm, AUTH_RSP_IDLE, MT2_AUTH_CHALLENGEG_TIMEOUT, AuthRspChallengeTimeoutAction);
+	//  StateMachineSetAction(Sm, AUTH_RSP_IDLE, MT2_PEER_AUTH_ODD, PeerAuthAtAuthRspIdleAction);
+	StateMachineSetAction(Sm, AUTH_RSP_IDLE, MT2_PEER_DEAUTH, (STATE_MACHINE_FUNC)PeerDeauthAction);
+
+	// column 2
+	//  StateMachineSetAction(Sm, AUTH_RSP_WAIT_CHAL, MT2_PEER_AUTH_ODD, PeerAuthAtAuthRspWaitAction);
+	//  StateMachineSetAction(Sm, AUTH_RSP_WAIT_CHAL, MT2_AUTH_CHALLENGE_TIMEOUT, AuthRspChallengeTimeoutAction);
+	StateMachineSetAction(Sm, AUTH_RSP_WAIT_CHAL, MT2_PEER_DEAUTH, (STATE_MACHINE_FUNC)PeerDeauthAction);
+
+	// initialize timer
+	// RTMPInitTimer(pAd, &pAd->Mlme.AuthRspAux.AuthRspTimer, AuthRspChallengeTimeout, FALSE);
+
+	// initialize the random number generator
+	NOW = jiffies;
+	LfsrInit(pAd, NOW);
+}
+
+/*
+    ==========================================================================
+    Description:
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+*/
+VOID PeerAuthSimpleRspGenAndSend(
+    IN PRT2570ADAPTER pAd, 
+    IN PMACHDR Hdr, 
+    IN USHORT Alg, 
+    IN USHORT Seq, 
+    IN USHORT Reason, 
+    IN USHORT Status) 
+{
+	MACHDR            AuthHdr;
+	UINT              FrameLen = 0;
+	UCHAR            *OutBuffer = NULL;
+	NDIS_STATUS       NStatus;
+
+	NStatus = MlmeAllocateMemory(pAd, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+	if (NStatus != NDIS_STATUS_SUCCESS) 
+		return;
+
+	if (Reason == MLME_SUCCESS)
+	{
+		MgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, &Hdr->Addr2, &pAd->PortCfg.Bssid);
+		MakeOutgoingFrame(OutBuffer,            &FrameLen, 
+		                  sizeof(MACHDR),       &AuthHdr, 
+		                  2,                    &Alg, 
+		                  2,                    &Seq, 
+		                  2,                    &Reason, 
+		                  END_OF_ARGS);
+		MiniportMMRequest(pAd, OutBuffer, FrameLen);
+	}
+	else
+	{
+		MlmeFreeMemory(pAd, OutBuffer);
+		DBGPRINT(RT_DEBUG_TRACE, "Peer AUTH fail...\n");
+	}
+}
+
+/*
+    ==========================================================================
+    Description:
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+*/
+VOID PeerDeauthAction(
+    IN PRT2570ADAPTER pAd, 
+    IN PMLME_QUEUE_ELEM Elem) 
+{
+	MACADDR     Addr2;
+	USHORT      Reason;
+
+	if (PeerDeauthSanity(pAd, Elem->Msg, Elem->MsgLen, &Addr2, &Reason)) 
+	{
+		if (INFRA_ON(pAd) && MAC_ADDR_EQUAL(&Addr2, &pAd->PortCfg.Bssid)) 
+		{
+			//RTMPCancelTimer(&pAd->Mlme.AuthRspAux.AuthRspTimer, &TimerCancelled);
+			// DBGPRINT_RAW(RT_DEBUG_TRACE,("AUTH_RSP - receive DE-AUTH from our AP (reason code = %d)\n", Reason));
+			DBGPRINT_RAW(RT_DEBUG_TRACE,"LinkDown(PeerDeauthAction(Reason = %d))\n", Reason);
+			LinkDown(pAd);
+		}
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_TRACE,"AUTH_RSP - PeerDeauthAction() sanity check fail\n");
+	}
+}
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/connect.c linux-2.4.35.3-mct/drivers/usb/rt2570/connect.c
--- linux-2.4.35.3/drivers/usb/rt2570/connect.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/connect.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,1446 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	connect.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+UCHAR	CipherSuiteWpaNoneTkip[] = {
+		0x00, 0x50, 0xf2, 0x01,	// oui
+		0x01, 0x00,				// Version
+		0x00, 0x50, 0xf2, 0x02,	// Multicast
+		0x01, 0x00,				// Number of unicast
+		0x00, 0x50, 0xf2, 0x00,	// unicast
+		0x01, 0x00,				// number of authentication method
+		0x00, 0x50, 0xf2, 0x00	// authentication
+		};
+UCHAR	CipherSuiteWpaNoneTkipLen = (sizeof(CipherSuiteWpaNoneTkip) / sizeof(UCHAR));
+
+UCHAR	CipherSuiteWpaNoneAes[] = {
+		0x00, 0x50, 0xf2, 0x01,	// oui
+		0x01, 0x00,				// Version
+		0x00, 0x50, 0xf2, 0x04,	// Multicast
+		0x01, 0x00,				// Number of unicast
+		0x00, 0x50, 0xf2, 0x00,	// unicast
+		0x01, 0x00,				// number of authentication method
+		0x00, 0x50, 0xf2, 0x00	// authentication
+		};
+UCHAR	CipherSuiteWpaNoneAesLen = (sizeof(CipherSuiteWpaNoneAes) / sizeof(UCHAR));
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID MlmeCntlInit(
+	IN PRT2570ADAPTER pAd, 
+	IN STATE_MACHINE *S, 
+	OUT STATE_MACHINE_FUNC Trans[]) 
+{
+	// Control state machine differs from other state machines, the interface 
+	// follows the standard interface
+	pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID MlmeCntlMachinePerformAction(
+	IN PRT2570ADAPTER pAd, 
+	IN STATE_MACHINE *S, 
+	IN MLME_QUEUE_ELEM *Elem) 
+{
+	switch(pAd->Mlme.CntlMachine.CurrState) 
+	{
+		case CNTL_IDLE:
+			CntlIdleProc(pAd, Elem);
+			break;
+		case CNTL_WAIT_DISASSOC:
+			CntlWaitDisassocProc(pAd, Elem);
+			break;
+		case CNTL_WAIT_JOIN:
+			CntlWaitJoinProc(pAd, Elem);
+			break;
+			
+		// CNTL_WAIT_REASSOC is the only state in CNTL machine that does
+		// not triggered directly or indirectly by "RTMPSetInformation(OID_xxx)". 
+		// Therefore not protected by NDIS's "only one outstanding OID request" 
+		// rule. Which means NDIS may SET OID in the middle of ROAMing attempts.
+		// Current approach is to block new SET request at RTMPSetInformation()
+		// when CntlMachine.CurrState is not CNTL_IDLE
+		case CNTL_WAIT_REASSOC:
+			CntlWaitReassocProc(pAd, Elem);
+			break;
+			
+		case CNTL_WAIT_START:
+			CntlWaitStartProc(pAd, Elem);
+			break;
+		case CNTL_WAIT_AUTH:
+			CntlWaitAuthProc(pAd, Elem);
+			break;
+		case CNTL_WAIT_AUTH2:
+			CntlWaitAuthProc2(pAd, Elem);
+			break;
+		case CNTL_WAIT_ASSOC:
+			CntlWaitAssocProc(pAd, Elem);
+			break;
+
+		case CNTL_WAIT_OID_LIST_SCAN:
+			if(Elem->MsgType == MT2_SCAN_CONF) 
+			{
+				// Resume TxRing after SCANING complete. We hope the out-of-service time
+				// won't be too long to let upper layer time-out the waiting frames
+				RTUSBResumeMsduTransmission(pAd);
+				if (pAd->Mlme.CntlAux.CurrReqIsFromNdis)
+				{
+					NdisMSetInformationComplete(pAd->AdapterHandle, NDIS_STATUS_SUCCESS);
+				}
+				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+			}
+			//
+			// Following line will potentially cause infinite loop
+			//
+			//if (pAd->MediaState == NdisMediaStateDisconnected)
+			//	  MlmeAutoReconnectLastSSID(pAd);
+			break;
+			
+		case CNTL_WAIT_OID_DISASSOC:
+			if (Elem->MsgType == MT2_DISASSOC_CONF) 
+			{
+				DBGPRINT_RAW(RT_DEBUG_TRACE, "LinkDown(MlmeCntlMachinePerformAction)\n");
+				LinkDown(pAd);
+				
+				if (pAd->Mlme.CntlAux.CurrReqIsFromNdis)
+				{
+					NdisMSetInformationComplete(pAd->AdapterHandle, NDIS_STATUS_SUCCESS);
+				}
+				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+			}
+			break;
+
+		default:
+			DBGPRINT(RT_DEBUG_ERROR, "CNTL - Illegal message type(=%d)", Elem->MsgType);
+			break;
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlIdleProc(
+	IN PRT2570ADAPTER pAd, 
+	IN MLME_QUEUE_ELEM *Elem) 
+{
+	MLME_DISASSOC_REQ_STRUCT   DisassocReq;
+		
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
+	{
+		if (pAd->Mlme.CntlAux.CurrReqIsFromNdis)
+		{
+			NdisMSetInformationComplete(pAd->AdapterHandle, NDIS_STATUS_FAILURE);
+			pAd->Mlme.CntlAux.CurrReqIsFromNdis = FALSE;
+		}
+		return;
+	}
+		
+	switch(Elem->MsgType) 
+	{
+		case OID_802_11_SSID:
+			CntlOidSsidProc(pAd, Elem);
+			break;
+
+		case RT_OID_802_11_BSSID:
+			CntlOidRTBssidProc(pAd,Elem);
+			break;
+
+		case OID_802_11_BSSID_LIST_SCAN:
+			CntlOidScanProc(pAd,Elem);
+			break;
+		
+		case OID_802_11_DISASSOCIATE:
+			DisassocParmFill(pAd, &DisassocReq, &pAd->PortCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ, sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_DISASSOC;
+			// Set the control aux SSID to prevent it reconnect to old SSID
+			// Since calling this indicate user don't want to connect to that SSID anymore.
+			pAd->Mlme.CntlAux.SsidLen = 32;
+			memset(pAd->Mlme.CntlAux.Ssid, 0, pAd->Mlme.CntlAux.SsidLen);
+			break;
+
+		case MT2_MLME_ROAMING_REQ:
+			CntlMlmeRoamingProc(pAd, Elem);
+			break;
+			
+		default:
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - Illegal message in CntlIdleProc(MsgType=%d)\n",Elem->MsgType);
+			break;
+	}
+}
+
+VOID CntlOidScanProc(
+	IN PRT2570ADAPTER pAd,
+	IN MLME_QUEUE_ELEM *Elem)
+{
+	MLME_SCAN_REQ_STRUCT	   ScanReq;
+	CHAR					   BroadSsid[MAX_LEN_OF_SSID];
+	ULONG					   BssIdx = BSS_NOT_FOUND;
+	BSS_ENTRY				   CurrBss;
+	ULONG		Now;
+
+	// record current BSS if network is connected. 
+	// 2003-2-13 do not include current IBSS if this is the only STA in this IBSS.
+	if (pAd->MediaState == NdisMediaStateConnected) //	if (INFRA_ON(pAd) || ADHOC_ON(pAd))
+	{
+		BssIdx = BssTableSearch(&pAd->PortCfg.BssTab, &pAd->PortCfg.Bssid);
+		if (BssIdx != BSS_NOT_FOUND)
+		{
+			memcpy(&CurrBss, &pAd->PortCfg.BssTab.BssEntry[BssIdx], sizeof(BSS_ENTRY));
+
+			// 2003-2-20 reset this RSSI to a low value but not zero. In normal case, the coming SCAN
+			//	   should return a correct RSSI to overwrite this. If no BEEACON received after SCAN, 
+			//	   at least we still report a "greater than 0" RSSI since we claim it's CONNECTED.
+			CurrBss.Rssi = 18; // about -82 dB
+		}
+	}
+			
+	// clean up previous SCAN result, add current BSS back to table if any
+	BssTableInit(&pAd->PortCfg.BssTab); 
+	if (BssIdx != BSS_NOT_FOUND)
+	{
+		// DDK Note: If the NIC is associated with a particular BSSID and SSID 
+		//	  that are not contained in the list of BSSIDs generated by this scan, the 
+		//	  BSSID description of the currently associated BSSID and SSID should be 
+		//	  appended to the list of BSSIDs in the NIC's database.
+		// To ensure this, we append this BSS as the first entry in SCAN result
+		memcpy(&pAd->PortCfg.BssTab.BssEntry[0], &CurrBss, sizeof(BSS_ENTRY));
+		pAd->PortCfg.BssTab.BssNr = 1;
+	}
+
+	BroadSsid[0] = '\0';
+	ScanParmFill(pAd, &ScanReq, BroadSsid, 0, BSS_ANY, SCAN_PASSIVE);
+	MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ, 
+		sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
+	pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+	Now = jiffies;
+	pAd->PortCfg.LastScanTime = Now;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlOidSsidProc(
+	IN PRT2570ADAPTER pAd, 
+	IN MLME_QUEUE_ELEM * Elem) 
+{
+	NDIS_802_11_SSID		  *OidSsid = (NDIS_802_11_SSID *)Elem->Msg;
+	MLME_DISASSOC_REQ_STRUCT   DisassocReq;
+	ULONG					   Now;
+
+	// Step 0. 
+	//	  record the desired SSID and all matching BSSes into CntlAux.SsidBssTab for 
+	//	  later-on iteration. Sort by RSSI order
+	if (OidSsid->Ssid[0] == 0)
+	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "empty string SSID\n");
+		pAd->Mlme.CntlAux.SsidLen = 0;
+	}
+	else
+		pAd->Mlme.CntlAux.SsidLen = (UCHAR)OidSsid->SsidLength;
+
+	memcpy(pAd->Mlme.CntlAux.Ssid, OidSsid->Ssid, pAd->Mlme.CntlAux.SsidLen);
+	BssTableSsidSort(pAd, &pAd->Mlme.CntlAux.SsidBssTab, pAd->Mlme.CntlAux.Ssid, pAd->Mlme.CntlAux.SsidLen);
+	pAd->Mlme.CntlAux.BssIdx = 0;
+	DBGPRINT(RT_DEBUG_TRACE,"CNTL - %d BSS match the desire SSID %s\n",pAd->Mlme.CntlAux.SsidBssTab.BssNr, pAd->Mlme.CntlAux.Ssid);
+	Now = jiffies;
+	
+	if ((pAd->MediaState == NdisMediaStateConnected) &&
+		MAC_ADDR_EQUAL(&pAd->PortCfg.Bssid, &pAd->Mlme.CntlAux.SsidBssTab.BssEntry[0].Bssid))
+	{
+		if (((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK)) &&
+			(pAd->PortCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
+		{
+			// For WPA, WPA-PSK, if the 1x port is not secured, we have to redo 
+			// connection process
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - disassociate with current AP...\n");
+			DisassocParmFill(pAd, &DisassocReq, &pAd->PortCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ, 
+						sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+		}
+		else if (pAd->bConfigChanged == TRUE)
+		{
+			// Config has changed, we have to reconnect the same AP
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - disassociate with current AP Because config changed...\n");
+			DisassocParmFill(pAd, &DisassocReq, &pAd->PortCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ, 
+						sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+		}
+		else
+		{
+			// We only check if same to the BSSID with highest RSSI.
+			// If roaming of same SSID required, we still do the reconnection.
+			// same BSSID, go back to idle state directly
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - already with this BSSID. ignore this SET_SSID request\n");
+			if (pAd->Mlme.CntlAux.CurrReqIsFromNdis)
+			{
+				NdisMSetInformationComplete(pAd->AdapterHandle, NDIS_STATUS_SUCCESS);
+			}
+			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+		} 
+	} 
+	else if (INFRA_ON(pAd)) 
+	{
+		// case 1. active association existent
+		//	  roaming is done within miniport driver, nothing to do with configuration
+		//	  utility. so upon a new SET(OID_802_11_SSID) is received, we just 
+		//	  disassociate with the current (or previous) associated AP, if any, 
+		//	  then perform a new association with this new SSID, no matter the 
+		//	  new/old SSID are the same or npt.
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - disassociate with current AP...\n");
+		DisassocParmFill(pAd, &DisassocReq, &pAd->PortCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+		MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ, 
+					sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+	}
+	else
+	{	
+		if (ADHOC_ON(pAd))
+		{
+//			  DBGPRINT(RT_DEBUG_TRACE, ("CNTL - drop current ADHOC\n"));
+			DBGPRINT_RAW(RT_DEBUG_TRACE, "LinkDown(CntlOidSsidProc)\n");
+			LinkDown(pAd);
+			pAd->MediaState = NdisMediaStateDisconnected;
+			NdisMIndicateStatus(pAd->AdapterHandle, NDIS_STATUS_MEDIA_DISCONNECT, (PVOID)NULL, 0);
+			NdisMIndicateStatusComplete(pAd->AdapterHandle);
+			DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_DISCONNECT Event C!\n");
+		}
+
+		if ((pAd->Mlme.CntlAux.SsidBssTab.BssNr == 0) &&
+			(pAd->PortCfg.AutoReconnect == TRUE) &&
+			(pAd->PortCfg.BssType == BSS_INFRA) &&
+			(MlmeValidateSSID(pAd) == TRUE))
+		{
+
+		    MLME_SCAN_REQ_STRUCT       ScanReq;
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - No matching BSS, start a new scan\n");
+			// BroadSsid[0] = '\0';
+			ScanParmFill(pAd, &ScanReq, pAd->Mlme.CntlAux.Ssid, pAd->Mlme.CntlAux.SsidLen, BSS_ANY, SCAN_ACTIVE);
+			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ, sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+			// Reset Missed scan number
+//			pAd->PortCfg.IgnoredScanNumber = 0;
+			pAd->PortCfg.LastScanTime = Now;
+		}
+		else
+		{
+			IterateOnBssTab(pAd);
+		}
+	} 
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlOidRTBssidProc(
+	IN PRT2570ADAPTER pAd, 
+	IN MLME_QUEUE_ELEM * Elem) 
+{
+	ULONG		BssIdx;
+	MACADDR 	*pOidBssid = (MACADDR *)Elem->Msg;
+	MLME_DISASSOC_REQ_STRUCT	DisassocReq;
+	MLME_JOIN_REQ_STRUCT		JoinReq;
+ 
+	COPY_MAC_ADDR(&pAd->Mlme.CntlAux.Bssid, pOidBssid);
+	BssIdx = BssTableSearch(&pAd->PortCfg.BssTab, pOidBssid);
+	   
+	if (BssIdx == BSS_NOT_FOUND) 
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - BSSID not found. reply NDIS_STATUS_NOT_ACCEPTED\n");
+		if (pAd->Mlme.CntlAux.CurrReqIsFromNdis)
+		{
+			//NdisMSetInformationComplete(pAd->AdapterHandle, NDIS_STATUS_NOT_ACCEPTED);
+		}
+		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+		return;
+	}
+
+	// copy the matched BSS entry from PortCfg.BssTab to CntlAux.SsidBssTab
+	pAd->Mlme.CntlAux.BssIdx = 0;
+	pAd->Mlme.CntlAux.SsidBssTab.BssNr = 1;
+	memcpy(&pAd->Mlme.CntlAux.SsidBssTab.BssEntry[0], &pAd->PortCfg.BssTab.BssEntry[BssIdx], sizeof(BSS_ENTRY));
+
+	// Add SSID into Mlme.CntlAux for site surey joining hidden SSID
+	pAd->Mlme.CntlAux.SsidLen = pAd->Mlme.CntlAux.SsidBssTab.BssEntry[0].SsidLen;
+	memcpy(pAd->Mlme.CntlAux.Ssid, pAd->Mlme.CntlAux.SsidBssTab.BssEntry[0].Ssid, pAd->Mlme.CntlAux.SsidLen);
+
+	// 2002-11-26 skip the following checking. i.e. if user wants to re-connect to same AP
+	// we just follow normal procedure. The reason of user doing this may because he/she changed
+	// AP to another channel, but we still received BEACON from it thus don't claim Link Down.
+	// Since user knows he's chnged AP channel, he'll re-connect again. By skipping the following
+	// checking, we'll disassociate then re-do normal association with this AP at the new channel.
+	// 2003-1-6 Re-enable this feature based on microsoft requirement which prefer not to re-do
+	// connection when setting the same BSSID.
+	if ( (pAd->MediaState == NdisMediaStateConnected) && //(INFRA_ON(pAd) || ADHOC_ON(pAd)) &&
+		MAC_ADDR_EQUAL(&pAd->PortCfg.Bssid, pOidBssid))
+	{
+		// same BSSID, go back to idle state directly
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - already in this BSSID. ignore this SET_BSSID request\n");
+		if (pAd->Mlme.CntlAux.CurrReqIsFromNdis)
+		{
+			NdisMSetInformationComplete(pAd->AdapterHandle, NDIS_STATUS_SUCCESS);
+		}
+		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+	} 
+	else 
+	{
+		if (INFRA_ON(pAd))
+		{
+			// disassoc from current AP first
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - disassociate with current AP ...\n");
+			DisassocParmFill(pAd, &DisassocReq, &pAd->PortCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ, 
+						sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+		}
+		else
+		{
+			if (ADHOC_ON(pAd))
+			{
+				DBGPRINT_RAW(RT_DEBUG_TRACE, "LinkDown(CntlOidRTBssidProc)\n");
+				LinkDown(pAd);
+				pAd->MediaState = NdisMediaStateDisconnected;
+				NdisMIndicateStatus(pAd->AdapterHandle, NDIS_STATUS_MEDIA_DISCONNECT, (PVOID)NULL, 0);
+				NdisMIndicateStatusComplete(pAd->AdapterHandle);
+				DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_DISCONNECT Event C!\n");
+			}
+			
+			// No active association, join the BSS immediately
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - joining %02x:%02x:%02x:%02x:%02x:%02x ...\n",
+				pOidBssid->Octet[0],pOidBssid->Octet[1],pOidBssid->Octet[2],
+				pOidBssid->Octet[3],pOidBssid->Octet[4],pOidBssid->Octet[5]);
+			JoinParmFill(pAd, &JoinReq, pAd->Mlme.CntlAux.BssIdx);
+			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_JOIN_REQ, sizeof(MLME_JOIN_REQ_STRUCT), &JoinReq);
+
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_JOIN;
+		}
+	} 
+}
+
+// Roaming is the only external request triggering CNTL state machine
+// despite of other "SET OID" operation. All "SET OID" related oerations 
+// happen in sequence, because no other SET OID will be sent to this device
+// until the the previous SET operation is complete (successful o failed).
+// So, how do we quarantee this ROAMING request won't corrupt other "SET OID"?
+// or been corrupted by other "SET OID"?
+VOID CntlMlmeRoamingProc(
+	IN PRT2570ADAPTER pAd, 
+	IN MLME_QUEUE_ELEM *Elem) 
+{
+	// TODO: 
+	// AP in different channel may show lower RSSI than actual value??
+	// should we add a weighting factor to compensate it?
+	DBGPRINT(RT_DEBUG_TRACE,"CNTL - Roaming in CntlAux.RoamTab...\n");
+	BssTableSortByRssi(&pAd->Mlme.CntlAux.RoamTab);
+	pAd->Mlme.CntlAux.RoamIdx=0;
+	IterateOnBssTab2(pAd);
+	
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlWaitDisassocProc(
+	IN PRT2570ADAPTER pAd, 
+	IN MLME_QUEUE_ELEM *Elem) 
+{
+	MLME_START_REQ_STRUCT	  StartReq;
+	
+	if (Elem->MsgType == MT2_DISASSOC_CONF) 
+	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "LinkDown(CntlWaitDisassocProc)\n");
+		LinkDown(pAd);
+		
+		// case 1. no matching BSS, and user wants ADHOC, so we just start a new one		
+		if ((pAd->Mlme.CntlAux.SsidBssTab.BssNr==0) && (pAd->PortCfg.BssType == BSS_INDEP))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - No matching BSS, start a new ADHOC (Ssid=%s)...\n",pAd->Mlme.CntlAux.Ssid);
+			StartParmFill(pAd, &StartReq, pAd->Mlme.CntlAux.Ssid, pAd->Mlme.CntlAux.SsidLen);
+			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_START_REQ, sizeof(MLME_START_REQ_STRUCT), &StartReq);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
+		}
+		// case 2. try each matched BSS
+		else
+		{
+			IterateOnBssTab(pAd);
+		}
+	}
+}
+			
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlWaitJoinProc(
+	IN PRT2570ADAPTER pAd, 
+	IN MLME_QUEUE_ELEM *Elem) 
+{
+	USHORT						Reason;
+	MLME_AUTH_REQ_STRUCT		AuthReq;
+
+	if (Elem->MsgType == MT2_JOIN_CONF) 
+	{
+		memcpy(&Reason, Elem->Msg, sizeof(USHORT));
+		if (Reason == MLME_SUCCESS) 
+		{
+			// 1. joined an IBSS, we are pretty much done here
+			if (pAd->PortCfg.BssType == BSS_INDEP)
+			{
+				LinkUp(pAd, BSS_INDEP);
+				if (pAd->Mlme.CntlAux.CurrReqIsFromNdis)
+				{
+					NdisMSetInformationComplete(pAd->AdapterHandle, NDIS_STATUS_SUCCESS);
+				}
+				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+
+				RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS);//steven:for test
+			} 
+			// 2. joined a new INFRA network, start from authentication
+			else 
+			{
+//				RTUSBWriteMACRegister(pAd, TXRX_CSR2, 0x67e);//steven:for test
+				// either Ndis802_11AuthModeShared or Ndis802_11AuthModeAutoSwitch, try shared key first
+				if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeShared) ||
+					(pAd->PortCfg.AuthMode == Ndis802_11AuthModeAutoSwitch))
+				{
+					AuthParmFill(pAd, &AuthReq, &pAd->PortCfg.Bssid, Ndis802_11AuthModeShared);
+				}
+				else
+				{
+					AuthParmFill(pAd, &AuthReq, &pAd->PortCfg.Bssid, Ndis802_11AuthModeOpen);
+				}
+				MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_MLME_AUTH_REQ, 
+							sizeof(MLME_AUTH_REQ_STRUCT), &AuthReq);
+
+				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_AUTH;
+			}
+		}
+		else
+		{
+			// 3. failed, try next BSS
+			pAd->Mlme.CntlAux.BssIdx++;
+			IterateOnBssTab(pAd);
+		} 
+	}	 
+}
+			
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlWaitStartProc(
+	IN PRT2570ADAPTER pAd, 
+	IN MLME_QUEUE_ELEM *Elem) 
+{
+	USHORT		Result;
+
+	if (Elem->MsgType == MT2_START_CONF) 
+	{
+		memcpy(&Result, Elem->Msg, sizeof(USHORT));
+		if (Result == MLME_SUCCESS) 
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - We have started a new ADHOC network\n");
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - BSSID %02x:%02x:%02x:%02x:%02x:%02x ...\n", 
+				pAd->PortCfg.Bssid.Octet[0],
+				pAd->PortCfg.Bssid.Octet[1],
+				pAd->PortCfg.Bssid.Octet[2],
+				pAd->PortCfg.Bssid.Octet[3],
+				pAd->PortCfg.Bssid.Octet[4],
+				pAd->PortCfg.Bssid.Octet[5]);
+			LinkUp(pAd, BSS_INDEP);
+			if (pAd->Mlme.CntlAux.CurrReqIsFromNdis)
+			{
+				NdisMSetInformationComplete(pAd->AdapterHandle, NDIS_STATUS_SUCCESS);
+			}
+			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+			
+			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS);//steven:for test
+		}
+		else
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - Start FAIL. BUG!!!!!\n");
+			if (pAd->Mlme.CntlAux.CurrReqIsFromNdis)
+			{
+				NdisMSetInformationComplete(pAd->AdapterHandle, NDIS_STATUS_FAILURE);
+			}
+			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+			
+			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS);//steven:for test
+		}
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlWaitAuthProc(
+	IN PRT2570ADAPTER pAd, 
+	IN MLME_QUEUE_ELEM *Elem) 
+{
+	USHORT						 Reason;
+	MLME_ASSOC_REQ_STRUCT		 AssocReq;
+	MLME_AUTH_REQ_STRUCT		 AuthReq;
+
+	if (Elem->MsgType == MT2_AUTH_CONF) 
+	{
+		memcpy(&Reason, Elem->Msg, sizeof(USHORT));
+		if (Reason == MLME_SUCCESS) 
+		{
+			AssocParmFill(pAd, &AssocReq, &pAd->PortCfg.Bssid, pAd->PortCfg.CapabilityInfo, 
+						  ASSOC_TIMEOUT, pAd->PortCfg.DefaultListenCount);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_ASSOC_REQ, 
+						sizeof(MLME_ASSOC_REQ_STRUCT), &AssocReq);
+
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_ASSOC;
+		} 
+		else
+		{
+			// This fail may because of the AP already keep us in its MAC table without 
+			// ageing-out. The previous authentication attempt must have let it remove us.
+			// so try Authentication again may help. For D-Link DWL-900AP+ compatibility.
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - AUTH FAIL, try again...\n");
+			if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeShared) ||
+				(pAd->PortCfg.AuthMode == Ndis802_11AuthModeAutoSwitch))
+			{
+				// either Ndis802_11AuthModeShared or Ndis802_11AuthModeAutoSwitch, try shared key first
+				AuthParmFill(pAd, &AuthReq, &pAd->PortCfg.Bssid, Ndis802_11AuthModeShared);
+			}
+			else
+			{
+				AuthParmFill(pAd, &AuthReq, &pAd->PortCfg.Bssid, Ndis802_11AuthModeOpen);
+			}
+			
+			MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_MLME_AUTH_REQ, 
+						sizeof(MLME_AUTH_REQ_STRUCT), &AuthReq);
+
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_AUTH2;
+		}
+	}	 
+}
+			
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlWaitAuthProc2(
+	IN PRT2570ADAPTER pAd, 
+	IN MLME_QUEUE_ELEM *Elem) 
+{
+	USHORT						 Reason;
+	MLME_ASSOC_REQ_STRUCT		 AssocReq;
+	MLME_AUTH_REQ_STRUCT		 AuthReq;
+
+	if (Elem->MsgType == MT2_AUTH_CONF) 
+	{
+		memcpy(&Reason, Elem->Msg, sizeof(USHORT));
+		if (Reason == MLME_SUCCESS) 
+		{
+			AssocParmFill(pAd, &AssocReq, &pAd->PortCfg.Bssid, pAd->PortCfg.CapabilityInfo, 
+						  ASSOC_TIMEOUT, pAd->PortCfg.DefaultListenCount);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_ASSOC_REQ, 
+						sizeof(MLME_ASSOC_REQ_STRUCT), &AssocReq);
+
+			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_ASSOC;
+		} 
+		else
+		{
+			if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeAutoSwitch) &&
+				 (pAd->Mlme.AuthAux.Alg == Ndis802_11AuthModeShared))
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "CNTL - AUTH FAIL, try OPEN system...\n");
+				AuthParmFill(pAd, &AuthReq, &pAd->PortCfg.Bssid, Ndis802_11AuthModeOpen);
+				MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_MLME_AUTH_REQ, 
+							sizeof(MLME_AUTH_REQ_STRUCT), &AuthReq);
+
+				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_AUTH2;
+			}
+			else 
+			{
+				// not success, try next BSS
+				DBGPRINT(RT_DEBUG_TRACE, "CNTL - AUTH FAIL, give up; try next BSS\n");
+				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE; //???????
+				pAd->Mlme.CntlAux.BssIdx++;
+//				RTUSBWriteMACRegister(pAd, TXRX_CSR2, 0x7e);//steven:for test
+				IterateOnBssTab(pAd);
+			}
+		}
+	}	 
+}
+			
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlWaitAssocProc(
+	IN PRT2570ADAPTER pAd, 
+	IN MLME_QUEUE_ELEM *Elem) 
+{
+	USHORT		Reason;
+
+	if (Elem->MsgType == MT2_ASSOC_CONF) 
+	{
+		memcpy(&Reason, Elem->Msg, sizeof(USHORT));
+		if (Reason == MLME_SUCCESS) 
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - Association successful on BSS #%d\n",pAd->Mlme.CntlAux.BssIdx);
+//			RTUSBWriteMACRegister(pAd, TXRX_CSR2, 0x7e);//steven:for test
+			LinkUp(pAd, BSS_INFRA);
+			if (pAd->Mlme.CntlAux.CurrReqIsFromNdis)
+			{
+				NdisMSetInformationComplete(pAd->AdapterHandle, NDIS_STATUS_SUCCESS);
+			}
+			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+
+			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS);//steven:for test
+		} 
+		else 
+		{
+			// not success, try next BSS
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - Association fails on BSS #%d\n",pAd->Mlme.CntlAux.BssIdx);
+//			  pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;//steven:for test
+			pAd->Mlme.CntlAux.BssIdx++;
+//			RTUSBWriteMACRegister(pAd, TXRX_CSR2, 0x7e);//steven:for test
+			IterateOnBssTab(pAd);
+		}
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID CntlWaitReassocProc(
+	IN PRT2570ADAPTER pAd, 
+	IN MLME_QUEUE_ELEM *Elem) 
+{
+	USHORT		Result;
+
+	if (Elem->MsgType == MT2_REASSOC_CONF) 
+	{
+		memcpy(&Result, Elem->Msg, sizeof(USHORT));
+		if (Result == MLME_SUCCESS) 
+		{
+			BSS_ENTRY *pBss = &pAd->Mlme.CntlAux.RoamTab.BssEntry[pAd->Mlme.CntlAux.RoamIdx];
+
+			// COPY_MAC_ADDR(&pAd->PortCfg.Bssid, &pBss->Bssid);
+			// AsicSetBssid(pAd, &pAd->PortCfg.Bssid);
+			
+			// The following steps are supposed to be done after JOIN in normal procedure
+			// But since this RE-ASSOC skips the JOIN procedure, we have to do it after
+			// RE-ASSOC succeeds. If RE-ASSOC fails, then stay at original AP without any change
+			pAd->PortCfg.BeaconPeriod = pBss->BeaconPeriod;
+			pAd->PortCfg.Channel = pBss->Channel;
+			// The security setting should always follow upper layer definition, not from frame
+			//pAd->PortCfg.PrivacyInvoked = CAP_IS_PRIVACY_ON(pBss->CapabilityInfo);
+			pAd->PortCfg.SupportedRatesLen = pBss->RatesLen;
+			memcpy(pAd->PortCfg.SupportedRates, pBss->Rates, pBss->RatesLen);
+
+			// Check for 802.11g information, if 802.11 b /g mixed mode.
+			pAd->PortCfg.CapabilityInfo = pBss->CapabilityInfo;
+
+			pAd->PortCfg.CfpPeriod = pBss->CfpPeriod;
+			pAd->PortCfg.CfpMaxDuration = pBss->CfpMaxDuration;
+			pAd->PortCfg.CfpDurRemain = pBss->CfpDurRemaining;
+			pAd->PortCfg.CfpCount = pBss->CfpCount;
+
+			// 
+			// NDIS requires a new Link UP indication but no Link Down for RE-ASSOC
+			//
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - Re-assocition successful on BSS #%d\n", pAd->Mlme.CntlAux.RoamIdx);
+			LinkUp(pAd, BSS_INFRA);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+			
+			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS);//steven:for test
+		} 
+		else 
+		{
+			// reassoc failed, try to pick next BSS in the BSS Table
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - Re-assocition fails on BSS #%d\n", pAd->Mlme.CntlAux.RoamIdx);
+			pAd->Mlme.CntlAux.RoamIdx++;
+			IterateOnBssTab2(pAd);
+		}
+	}
+}
+			
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID LinkUp(
+	IN PRT2570ADAPTER pAd,
+	IN UCHAR BssType) 
+{
+	ULONG	Now;
+	UCHAR			buffer[22];
+	
+	DBGPRINT(RT_DEBUG_TRACE, "CNTL - !!! LINK UP !!!\n");
+	MlmeUpdateTxRates(pAd, TRUE);
+	RTUSBMultiReadMAC(pAd, STA_CSR0, buffer, 22);
+	memcpy(&pAd->Mlme.PrevWlanCounters, &pAd->WlanCounters, sizeof(COUNTER_802_11));
+	memset(&pAd->DrsCounters, 0, sizeof(COUNTER_DRS));
+
+	Now = jiffies;
+	pAd->PortCfg.LastBeaconRxTime = Now;   // last RX timestamp
+	
+	if ((pAd->PortCfg.WindowsTxPreamble != Rt802_11PreambleLong) &&
+		CAP_IS_SHORT_PREAMBLE_ON(pAd->PortCfg.CapabilityInfo))
+	{
+
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - !!! Set to short preamble!!!\n");
+		MlmeSetTxPreamble(pAd, Rt802_11PreambleShort);
+	}
+	
+	pAd->PortCfg.BssType = BssType;
+	if (BssType == BSS_INDEP)
+	{
+//		USHORT SentBeaconsCount, ReceivedBeaconsCount;
+//		RTUSBReadMACRegister(pAd, STA_CSR5, &SentBeaconsCount);
+//		RTUSBReadMACRegister(pAd, STA_CSR10, &ReceivedBeaconsCount);
+		pAd->PortCfg.Mibss = TRUE;
+		pAd->PortCfg.Massoc = FALSE;
+		AsicEnableIbssSync(pAd);
+		
+#ifdef	SINGLE_ADHOC_LINKUP
+		// Although this did not follow microsoft's recommendation.
+		//Change based on customer's request
+		pAd->MediaState = NdisMediaStateConnected;
+		NdisMIndicateStatus(pAd->AdapterHandle, NDIS_STATUS_MEDIA_CONNECT, (PVOID)NULL, 0);
+		NdisMIndicateStatusComplete(pAd->AdapterHandle);
+#endif
+
+	}
+	else // BSS_INFRA
+	{
+            // need to check
+		//InterlockedExchange(&(pAd->PortCfg.DataPacketsFromAP), 0);
+		pAd->PortCfg.Massoc = TRUE;
+		pAd->PortCfg.Mibss = FALSE;
+
+		// NOTE:
+		// the decision of using "short slot time" or not may change dynamically due to
+		// new STA association to the AP. so we have to decide that upon parsing BEACON, not here
+
+		// NOTE:
+		// the decision to use "RTC/CTS" or "CTS-to-self" protection or not may change dynamically
+		// due to new STA association to the AP. so we have to decide that upon parsing BEACON, not here
+		
+		ComposePsPoll(pAd);
+		ComposeNullFrame(pAd);
+		AsicEnableBssSync(pAd);
+		if (pAd->PortCfg.EnableTxBurst)
+		{
+			//Set CWmin/CWmax to 0.
+			RTUSBWriteMACRegister(pAd, MAC_CSR22, 0x100);
+		}
+		else
+		{
+			RTUSBWriteMACRegister(pAd, MAC_CSR22, 0x53);
+		}
+	
+		// only INFRASTRUCTURE mode need to indicate connectivity immediately; ADHOC mode
+		// should wait until at least 2 active nodes in this BSSID.
+		pAd->MediaState = NdisMediaStateConnected;
+		NdisMIndicateStatus(pAd->AdapterHandle, NDIS_STATUS_MEDIA_CONNECT, (PVOID)NULL, 0);
+		NdisMIndicateStatusComplete(pAd->AdapterHandle);
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_CONNECT Event B!\n");
+
+	if ((pAd->PortCfg.LedMode != LED_MODE_SINGLE)&&(pAd->PortCfg.LedMode != LED_MODE_TXRX_ACTIVITY))
+	{
+		ASIC_LED_ACT_ON(pAd);
+	}
+	if (pAd->PortCfg.LedMode == LED_MODE_ALPHA){
+		pAd->PortCfg.LedCntl.fSiteSurvey = FALSE;
+		pAd->PortCfg.LedCntl.fLinkUp = TRUE;
+	}	
+	AsicSetSlotTime(pAd, FALSE);
+	pAd->Mlme.PeriodicRound = 0;
+	// Reset config flag
+	pAd->bConfigChanged = FALSE;
+	// Update extra information to link is up
+	pAd->ExtraInfo = GENERAL_LINK_UP;
+	pAd->PortCfg.WpaState = SS_START;
+
+	RTUSBKickBulkOut(pAd);
+
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID LinkDown(
+	IN PRT2570ADAPTER pAd) 
+{
+	DBGPRINT(RT_DEBUG_TRACE, "CNTL - !!! LINK DOWN !!!\n");
+
+	if (ADHOC_ON(pAd))		// Adhoc mode link down
+	{
+		pAd->PortCfg.Mibss = FALSE;
+
+#ifdef	SINGLE_ADHOC_LINKUP
+		pAd->MediaState = NdisMediaStateDisconnected;
+		NdisMIndicateStatus(pAd->AdapterHandle, NDIS_STATUS_MEDIA_DISCONNECT, (PVOID)NULL, 0);
+		NdisMIndicateStatusComplete(pAd->AdapterHandle);
+		// clean up previous SCAN result, add current BSS back to table if any
+		BssTableDeleteEntry(&pAd->PortCfg.BssTab, &(pAd->PortCfg.Bssid));
+#else
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
+		{
+			pAd->MediaState = NdisMediaStateDisconnected;
+			NdisMIndicateStatus(pAd->AdapterHandle, NDIS_STATUS_MEDIA_DISCONNECT, (PVOID)NULL, 0);
+			NdisMIndicateStatusComplete(pAd->AdapterHandle);
+			// clean up previous SCAN result, add current BSS back to table if any
+			BssTableDeleteEntry(&pAd->PortCfg.BssTab, &(pAd->PortCfg.Bssid));
+		}
+#endif
+		
+	}
+	else					// Infra structure mode
+	{
+		pAd->PortCfg.Massoc = FALSE;
+		pAd->MediaState = NdisMediaStateDisconnected;
+		DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_DISCONNECT Event A!\n");
+		BssTableDeleteEntry(&pAd->PortCfg.BssTab, &(pAd->PortCfg.Bssid));
+
+		// restore back to - 
+		//		1. long slot (20 us) or short slot (9 us) time
+		//		2. turn on/off RTS/CTS and/or CTS-to-self protection
+		//		3. short preamble
+		if (pAd->PortCfg.BGProtectionInUsed == TRUE)
+		{
+			pAd->PortCfg.BGProtectionInUsed = FALSE;
+			DBGPRINT(RT_DEBUG_TRACE, "Link down - turn off B/G protection\n");
+		}
+
+		if (pAd->PortCfg.Pss == PWR_SAVE)
+		{
+			RTUSBWriteMACRegister(pAd, MAC_CSR1, 1);
+			RTUSBWriteMACRegister(pAd, MAC_CSR1, 4);
+			pAd->PortCfg.Pss = PWR_ACTIVE;
+		}
+	}
+	
+	AsicSetSlotTime(pAd, FALSE);
+	RTUSBWriteMACRegister(pAd, MAC_CSR22, 0x53);
+	AsicRestoreBbpSensibility(pAd);
+	
+	if (pAd->PortCfg.WindowsTxPreamble == Rt802_11PreambleShort)
+		MlmeSetTxPreamble(pAd, Rt802_11PreambleShort);
+	else
+		MlmeSetTxPreamble(pAd, Rt802_11PreambleLong);
+
+	if ((pAd->PortCfg.LedMode != LED_MODE_SINGLE) && (pAd->PortCfg.LedMode != LED_MODE_ASUS))
+	{
+		ASIC_LED_ACT_OFF(pAd);
+	}
+	else if ((pAd->PortCfg.LedMode == LED_MODE_ASUS) && (pAd->PortCfg.bRadio == TRUE))
+	{
+		RTUSBWriteMACRegister(pAd, MAC_CSR20, 0x0002);
+	}
+	AsicDisableSync(pAd);
+	pAd->Mlme.PeriodicRound = 0;
+	pAd->ScanAllowed = TRUE;
+
+	// Remove PortCfg Information after link down
+	memset(&(pAd->PortCfg.Bssid), 0, MAC_ADDR_LEN);
+	
+	// Reset WPA-PSK state. Only reset when supplicant enabled
+	if (pAd->PortCfg.WpaState != SS_NOTUSE)
+	{
+		pAd->PortCfg.WpaState = SS_START;
+		// Clear Replay counter
+		memset(pAd->PortCfg.ReplayCounter, 0, 8);
+	}
+	// Remove all WPA keys after link down
+	RTMPWPARemoveAllKeys(pAd);
+	// 802.1x port control
+	pAd->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+	pAd->PortCfg.MicErrCnt = 0;
+	if (pAd->PortCfg.LedMode == LED_MODE_ALPHA)
+		pAd->PortCfg.LedCntl.fLinkUp = FALSE;
+
+	// Update extra information to link is up
+	pAd->ExtraInfo = GENERAL_LINK_DOWN;
+	// Start STA supplicant state machine
+	//pAd->PortCfg.WpaState = SS_NOTUSE;
+
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID MlmeCntlConfirm(
+	IN PRT2570ADAPTER pAd, 
+	IN ULONG MsgType, 
+	IN USHORT Msg) 
+{
+	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MsgType, sizeof(USHORT), &Msg);
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID IterateOnBssTab(
+	IN PRT2570ADAPTER pAd) 
+{
+	MLME_START_REQ_STRUCT	StartReq;
+	MLME_JOIN_REQ_STRUCT	JoinReq;
+	ULONG					BssIdx;
+
+	BssIdx = pAd->Mlme.CntlAux.BssIdx;
+	if (BssIdx < pAd->Mlme.CntlAux.SsidBssTab.BssNr) 
+	{
+		if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS))
+			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS);//steven:for test
+
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - Trying BSSID %02x:%02x:%02x:%02x:%02x:%02x ...\n", 
+			pAd->Mlme.CntlAux.SsidBssTab.BssEntry[BssIdx].Bssid.Octet[0],
+			pAd->Mlme.CntlAux.SsidBssTab.BssEntry[BssIdx].Bssid.Octet[1],
+			pAd->Mlme.CntlAux.SsidBssTab.BssEntry[BssIdx].Bssid.Octet[2],
+			pAd->Mlme.CntlAux.SsidBssTab.BssEntry[BssIdx].Bssid.Octet[3],
+			pAd->Mlme.CntlAux.SsidBssTab.BssEntry[BssIdx].Bssid.Octet[4],
+			pAd->Mlme.CntlAux.SsidBssTab.BssEntry[BssIdx].Bssid.Octet[5]);
+		JoinParmFill(pAd, &JoinReq, BssIdx);
+		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_JOIN_REQ, sizeof(MLME_JOIN_REQ_STRUCT),
+					&JoinReq);
+		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_JOIN;
+	}
+	else if (pAd->PortCfg.BssType == BSS_INDEP)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - All BSS fail; start a new ADHOC (Ssid=%s)...\n",pAd->Mlme.CntlAux.Ssid);
+		StartParmFill(pAd, &StartReq, pAd->Mlme.CntlAux.Ssid, (UCHAR)pAd->Mlme.CntlAux.SsidLen);
+		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_START_REQ, sizeof(MLME_START_REQ_STRUCT), &StartReq);
+		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
+	}
+	else // no more BSS
+	{
+		if (pAd->Mlme.CntlAux.CurrReqIsFromNdis)
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "CNTL - All BSS fail; reply NDIS_STATUS_NOT_ACCEPTED\n");
+			NdisMSetInformationComplete(pAd->AdapterHandle, NDIS_STATUS_SUCCESS);
+		}
+		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS);//steven:for test
+	} 
+}
+
+// for re-association only
+VOID IterateOnBssTab2(
+	IN PRT2570ADAPTER pAd) 
+{
+	MLME_REASSOC_REQ_STRUCT ReassocReq;
+	ULONG					BssIdx;
+	BSS_ENTRY				*pBss;
+	
+	BssIdx = pAd->Mlme.CntlAux.RoamIdx;
+	pBss = &pAd->Mlme.CntlAux.RoamTab.BssEntry[BssIdx];
+
+	if (BssIdx < pAd->Mlme.CntlAux.RoamTab.BssNr)
+	{
+		if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS))
+			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS);//steven:for test
+
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - try BSS #%d %02x:%02x:%02x:%02x:%02x:%02x ...\n", 
+			BssIdx, pBss->Bssid.Octet[0],pBss->Bssid.Octet[1],pBss->Bssid.Octet[2],
+			pBss->Bssid.Octet[3],pBss->Bssid.Octet[4],pBss->Bssid.Octet[5]);
+
+		AsicSwitchChannel(pAd, pBss->Channel);
+		AsicLockChannel(pAd, pBss->Channel);
+		
+		// reassociate message has the same structure as associate message
+		AssocParmFill(pAd, &ReassocReq, &pBss->Bssid, pBss->CapabilityInfo, 
+					  ASSOC_TIMEOUT, pAd->PortCfg.DefaultListenCount);
+		MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_REASSOC_REQ, 
+					sizeof(MLME_REASSOC_REQ_STRUCT), &ReassocReq);
+		
+		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_REASSOC;
+	}
+	else // no more BSS
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "CNTL - All roaming failed, stay with original AP\n");
+		AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
+		AsicLockChannel(pAd, pAd->PortCfg.Channel);
+		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS);//steven:for test
+	} 
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID JoinParmFill(
+	IN PRT2570ADAPTER pAd, 
+	IN OUT MLME_JOIN_REQ_STRUCT *JoinReq, 
+	IN ULONG BssIdx) 
+{
+	JoinReq->BssIdx = BssIdx;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID AssocParmFill(
+	IN PRT2570ADAPTER pAd, 
+	IN OUT MLME_ASSOC_REQ_STRUCT *AssocReq, 
+	IN MACADDR					 *Addr, 
+	IN USHORT					  CapabilityInfo, 
+	IN ULONG					  Timeout, 
+	IN USHORT					  ListenIntv) 
+{
+	COPY_MAC_ADDR(&AssocReq->Addr, Addr);
+	// Add mask to support 802.11b mode only
+	AssocReq->CapabilityInfo = CapabilityInfo & 0xfff3; // not cf-pollable, not cf-poll-request
+	AssocReq->Timeout = Timeout;
+	AssocReq->ListenIntv = ListenIntv;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID ScanParmFill(
+	IN PRT2570ADAPTER pAd, 
+	IN OUT MLME_SCAN_REQ_STRUCT *ScanReq, 
+	IN CHAR Ssid[], 
+	IN UCHAR SsidLen, 
+	IN UCHAR BssType, 
+	IN UCHAR ScanType) 
+{
+	ScanReq->SsidLen = SsidLen;
+	memcpy(ScanReq->Ssid, Ssid, SsidLen);
+	ScanReq->BssType = BssType;
+	ScanReq->ScanType = ScanType;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID DisassocParmFill(
+	IN PRT2570ADAPTER pAd, 
+	IN OUT MLME_DISASSOC_REQ_STRUCT *DisassocReq, 
+	IN MACADDR *Addr, 
+	IN USHORT Reason) 
+{
+	COPY_MAC_ADDR(&DisassocReq->Addr, Addr);
+	DisassocReq->Reason = Reason;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID StartParmFill(
+	IN PRT2570ADAPTER pAd, 
+	IN OUT MLME_START_REQ_STRUCT *StartReq, 
+	IN CHAR Ssid[], 
+	IN UCHAR SsidLen) 
+{
+	memcpy(StartReq->Ssid, Ssid, SsidLen);
+	StartReq->SsidLen = SsidLen;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+*/
+VOID AuthParmFill(
+	IN PRT2570ADAPTER pAd, 
+	IN OUT MLME_AUTH_REQ_STRUCT *AuthReq, 
+	IN MACADDR *Addr, 
+	IN USHORT Alg) 
+{
+	COPY_MAC_ADDR(&AuthReq->Addr, Addr);
+	AuthReq->Alg = Alg;
+	AuthReq->Timeout = AUTH_TIMEOUT;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+ */
+VOID ComposePsPoll(
+	IN PRT2570ADAPTER pAd)
+{
+	PSPOLL_FRAME *pPsPoll = (PSPOLL_FRAME *)&(pAd->PsPollContext.TransferBuffer->WirelessPacket);
+	memset(pPsPoll, 0, sizeof(PSPOLL_FRAME));
+	pPsPoll->Type = BTYPE_CNTL;
+	pPsPoll->SubType = SUBTYPE_PS_POLL;
+	pPsPoll->Aid = pAd->PortCfg.Aid | 0xC000;
+	COPY_MAC_ADDR(&(pPsPoll->Bssid), &pAd->PortCfg.Bssid);
+	COPY_MAC_ADDR(&(pPsPoll->Ta), &(pAd->CurrentAddress));
+}
+
+VOID ComposeNullFrame(
+	IN PRT2570ADAPTER pAd)
+{
+	PHEADER_802_11 pNullFrame = (PHEADER_802_11)&(pAd->NullContext.TransferBuffer->WirelessPacket);
+	MgtMacHeaderInit(pAd, (PMACHDR)pNullFrame, SUBTYPE_NULL_FUNC, 1, &pAd->PortCfg.Bssid, &pAd->PortCfg.Bssid);
+	pNullFrame->Controlhead.Duration = 0;
+	pNullFrame->Controlhead.Frame.Type = BTYPE_DATA;
+}
+
+/*
+	==========================================================================
+	Description:
+		Pre-build a BEACON frame in the shared memory
+	==========================================================================
+*/
+VOID MakeIbssBeacon(
+	IN PRT2570ADAPTER pAd) 
+{
+	UCHAR			SsidIe = IE_SSID, DsIe = IE_DS_PARM, IbssIe = IE_IBSS_PARM, SuppIe = IE_SUPP_RATES, 
+					DsLen = 1, IbssLen = 2;
+	UCHAR			i, ExtRateIe = IE_EXT_SUPP_RATES, ExtRatesLen;
+	UCHAR			ErpIe[3] = {IE_ERP, 1, 0x04};
+	MACHDR			BcnHdr;
+	USHORT			CapabilityInfo;
+	LARGE_INTEGER	FakeTimestamp;
+	ULONG			FrameLen;
+	UCHAR			SupportedRatesLen = 0;
+	UCHAR			SupportedRates[MAX_LEN_OF_SUPPORTED_RATES];
+	BOOLEAN			Privacy;
+	PUCHAR			pBeaconFrame;
+	PTXD_STRUC		pTxD;
+	ULONG			BulkOutLength;
+	PTX_CONTEXT		pBeaconContext = &(pAd->BeaconContext[0]);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if (pAd->MLMEThr_pid <= 0)
+	    return;
+#else
+	if (!pAd->MLMEThr_active)
+	    return;
+#endif
+    // 2003-12-10 802.11g WIFI spec disallow OFDM rates in 802.11g ADHOC mode
+    // make sure 1,2,5.5,11 are the firt 4 rates in PortCfg.SupportedRates[] array
+    if ((pAd->PortCfg.PhyMode == PHY_11BG_MIXED) && (pAd->PortCfg.AdhocMode == 0))
+    {
+	    for (i = 0; i < pAd->PortCfg.SupportedRatesLen; i++)
+	    {
+	        switch (pAd->PortCfg.SupportedRates[i] & 0x7f)
+	        {
+	            case 2:
+	            case 4:
+	            case 11:
+	            case 22:
+	                SupportedRates[SupportedRatesLen] = pAd->PortCfg.SupportedRates[i];
+	                SupportedRatesLen ++;
+	                break;
+	            default:
+	                break;
+	        }
+	    }
+	    // error handling - should never happen
+	    if (SupportedRatesLen != 4)
+	    {
+            SupportedRatesLen = 4;
+            SupportedRates[0] = 0x82;
+            SupportedRates[1] = 0x84;
+            SupportedRates[2] = 0x8b;
+            SupportedRates[3] = 0x96;
+	    }
+    }
+    else
+    {
+        SupportedRatesLen = pAd->PortCfg.SupportedRatesLen;
+        memcpy(SupportedRates, pAd->PortCfg.SupportedRates, SupportedRatesLen);
+    }
+
+	if (pBeaconContext->InUse == TRUE)
+		return;
+	else
+		pBeaconContext->InUse = TRUE;
+
+    pAd->PortCfg.AtimWin = 0;  // ??????
+    
+    // compose IBSS beacon frame
+    MgtMacHeaderInit(pAd, &BcnHdr, SUBTYPE_BEACON, 0, &pAd->PortCfg.Broadcast, &pAd->PortCfg.Bssid);
+    Privacy = (pAd->PortCfg.WepStatus == Ndis802_11Encryption1Enabled) || 
+              (pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) || 
+              (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled);
+    CapabilityInfo = CAP_GENERATE(0, 1, 0, 0, Privacy, (pAd->PortCfg.WindowsTxPreamble == Rt802_11PreambleShort));
+
+	// Prepare beacon frame, this should go to beacon_ring[1] which contains the real body.
+	pBeaconFrame = (PUCHAR) pAd->BeaconContext[1].TransferBuffer->WirelessPacket;
+	
+    if (SupportedRatesLen <= 8)
+    {
+        MakeOutgoingFrame(pBeaconFrame,                &FrameLen,
+                      MAC_HDR_LEN,                     &BcnHdr, 
+                      TIMESTAMP_LEN,                   &FakeTimestamp,
+                      2,                               &pAd->PortCfg.BeaconPeriod,
+                      2,                               &CapabilityInfo,
+                      1,                               &SsidIe, 
+                      1,                               &pAd->PortCfg.SsidLen, 
+                      pAd->PortCfg.SsidLen,             pAd->PortCfg.Ssid,
+                      1,                               &SuppIe, 
+                      1,                               &SupportedRatesLen,
+                      SupportedRatesLen,               SupportedRates, 
+                      1,                               &DsIe, 
+                      1,                               &DsLen, 
+                      1,                               &pAd->PortCfg.Channel,
+                      1,                               &IbssIe, 
+                      1,                               &IbssLen, 
+                      2,                               &pAd->PortCfg.AtimWin,
+                      END_OF_ARGS);
+    }
+    else
+    {
+        ExtRatesLen = SupportedRatesLen - 8;
+        SupportedRatesLen = 8;
+        MakeOutgoingFrame(pBeaconFrame,                &FrameLen,
+                      MAC_HDR_LEN,                     &BcnHdr, 
+                      TIMESTAMP_LEN,                   &FakeTimestamp,
+                      2,                               &pAd->PortCfg.BeaconPeriod,
+                      2,                               &CapabilityInfo,
+                      1,                               &SsidIe, 
+                      1,                               &pAd->PortCfg.SsidLen, 
+                      pAd->PortCfg.SsidLen,             pAd->PortCfg.Ssid,
+                      1,                               &SuppIe, 
+                      1,                               &SupportedRatesLen,
+                      SupportedRatesLen,                SupportedRates, 
+                      1,                               &DsIe, 
+                      1,                               &DsLen, 
+                      1,                               &pAd->PortCfg.Channel,
+                      1,                               &IbssIe, 
+                      1,                               &IbssLen, 
+                      2,                               &pAd->PortCfg.AtimWin,
+                      3,                               ErpIe,
+                      1,                               &ExtRateIe,
+                      1,                               &ExtRatesLen,
+                      ExtRatesLen,                     &SupportedRates[SupportedRatesLen],
+                      END_OF_ARGS);
+    }
+    
+	// If adhoc secruity is set for WPA-None, append the cipher suite IE
+	if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+	{
+		ULONG	tmp = 0;
+		UCHAR	WpaIe = IE_WPA;
+		
+		if (pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled)		// Tkip
+		{
+        	MakeOutgoingFrame(pBeaconFrame + FrameLen,                    &tmp,
+				1,						  &WpaIe,
+				1,						  &CipherSuiteWpaNoneTkipLen,
+				CipherSuiteWpaNoneTkipLen,	  &CipherSuiteWpaNoneTkip[0],
+				END_OF_ARGS);
+			FrameLen += tmp;
+		}
+		else if (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)	// Aes
+		{
+        	MakeOutgoingFrame(pBeaconFrame + FrameLen,                    &tmp,
+				1,						  &WpaIe,
+				1,						  &CipherSuiteWpaNoneAesLen,
+				CipherSuiteWpaNoneAesLen,	  &CipherSuiteWpaNoneAes[0],
+				END_OF_ARGS);
+			FrameLen += tmp;
+		}
+	}
+	
+    BulkOutLength = sizeof(TXD_STRUC) + FrameLen;
+	if ((BulkOutLength % 2) == 1)
+		BulkOutLength ++;
+//	if (BulkOutLength % pAd->BulkOutMaxPacketSize == 0)
+//		BulkOutLength += 2;
+
+    for (i = 0; i < BEACON_RING_SIZE; i++)
+	{
+		pTxD = (PTXD_STRUC) &pAd->BeaconContext[i].TransferBuffer->TxDesc;
+		memset(pTxD, 0, sizeof(TXD_STRUC));
+		pBeaconContext = &(pAd->BeaconContext[i]);;
+
+		// Both TxD need to put in the right descriptor
+    	RTUSBWriteBeaconDescriptor(pTxD, FrameLen, FrameLen + 4, pAd->PortCfg.MlmeRate, 4, pAd->PortCfg.TxPreambleInUsed);
+		if (i == 0)
+			pBeaconContext->BulkOutSize = 1;
+		else
+			pBeaconContext->BulkOutSize = BulkOutLength;			
+    DBGPRINT(RT_DEBUG_TRACE, "  (pBeaconContext->BulkOutSize=%d)\n", pBeaconContext->BulkOutSize);
+	}
+
+	// The flags will always start from beacon 0
+	RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_BEACON_0);
+
+	// Kick bulk out 
+	RTUSBKickBulkOut(pAd);
+
+}
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/iwpriv_usage.txt linux-2.4.35.3-mct/drivers/usb/rt2570/iwpriv_usage.txt
--- linux-2.4.35.3/drivers/usb/rt2570/iwpriv_usage.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/iwpriv_usage.txt	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,70 @@
+iwpriv
+=================
+This is detailed explanation of each parameters for iwpriv.
+Before reading this document, make sure you already read README.
+
+-------------------------------------------------------------------------------------------------------
+USAGE:
+	iwpriv rausb0 set [parameters]=[val]
+
+where
+
+[parameters]          [val] range                          explaination
+-----------------   -----------------------              ---------------------------------------------
+auth			0~2					0:open
+								1:shared
+								2:wpapsk
+								3:wpanone
+								
+keyid			1~4					wep key id
+
+enc			1~3					1:none
+								2:wep
+								3:tkip
+								
+wpapsk			8~63 chars				WPAPSK password
+
+adhocmode		0~2					0: Plain 11Mbps
+								   mode in
+								   Ad-Hoc
+								   (IEEE
+								   802.11g
+								   standard)
+								1: Auto mode
+								   in Ad-Hoc
+								   (violates
+								   IEEE 802.11g
+								   standard)
+								2: 54Mbps only.
+
+Examples
+===================================================================
+-------------------------------------------------------------------------------------------------------
+Example I: Config STA to link with AP which is OPEN/NONE(Authentication/Encryption)
+	1. iwconfig rausb0 mode Managed
+	2. iwconfig rausb0 enc none
+	3. iwconfig rausb0 essid "AP's SSID"
+	
+Example II: Config STA to link with AP which is OPEN/WEP(Authentication/Encryption)
+	1. iwconfig rausb0 enc s:abcde
+	2. iwconfig rausb0 essid "AP's SSID"
+
+	
+Example III: Config STA to link with AP which is WPAPSK/TKIP(Authentication/Encryption)
+	1. iwpriv rausb0 enc 3
+	2. iwconfig rausb0 essid "AP's SSID"
+	3. iwpriv rausb0 wpapsk 12345678
+	4. iwconfig rausb0 essid "AP's SSID"
+	
+p.s Step 2 is part of generating wpapsk password and is necessary.
+
+NOTE:
+
+iwlist
+=================
+This is detailed explanation of each parameters for iwlist.
+
+-------------------------------------------------------------------------------------------------------
+
+iwlist rausb0 scanning		; list the result after scanning(site survey)
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/md5.c linux-2.4.35.3-mct/drivers/usb/rt2570/md5.c
--- linux-2.4.35.3/drivers/usb/rt2570/md5.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/md5.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,1369 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	md5.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ *	Rita    	11-23-04	Modify MD5 and SHA-1
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+/**
+ * md5_mac:
+ * @key: pointer to	the	key	used for MAC generation
+ * @key_len: length	of the key in bytes
+ * @data: pointer to the data area for which the MAC is	generated
+ * @data_len: length of	the	data in	bytes
+ * @mac: pointer to	the	buffer holding space for the MAC; the buffer should
+ * have	space for 128-bit (16 bytes) MD5 hash value
+ *
+ * md5_mac() determines	the	message	authentication code	by using secure	hash
+ * MD5(key | data |	key).
+ */
+void md5_mac(UCHAR *key, ULONG key_len, UCHAR *data, ULONG data_len, UCHAR *mac)
+{
+	MD5_CTX	context;
+
+	MD5Init(&context);
+	MD5Update(&context,	key, key_len);
+	MD5Update(&context,	data, data_len);
+	MD5Update(&context,	key, key_len);
+	MD5Final(mac, &context);
+}
+
+
+/**
+ * hmac_md5:
+ * @key: pointer to	the	key	used for MAC generation
+ * @key_len: length	of the key in bytes
+ * @data: pointer to the data area for which the MAC is	generated
+ * @data_len: length of	the	data in	bytes
+ * @mac: pointer to	the	buffer holding space for the MAC; the buffer should
+ * have	space for 128-bit (16 bytes) MD5 hash value
+ *
+ * hmac_md5() determines the message authentication	code using HMAC-MD5.
+ * This	implementation is based	on the sample code presented in	RFC	2104.
+ */
+void hmac_md5(UCHAR *key, ULONG key_len, UCHAR *data, ULONG data_len, UCHAR *mac)
+{
+	MD5_CTX	context;
+	UCHAR k_ipad[65]; /* inner	padding	- key XORd with	ipad */
+	UCHAR k_opad[65]; /* outer	padding	- key XORd with	opad */
+	UCHAR tk[16];
+	int	i;
+
+	//assert(key != NULL && data != NULL && mac != NULL);
+
+	/* if key is longer	than 64	bytes reset	it to key =	MD5(key) */
+	if (key_len	> 64) {
+		MD5_CTX	ttcontext;
+
+		MD5Init(&ttcontext);
+		MD5Update(&ttcontext, key, key_len);
+		MD5Final(tk, &ttcontext);
+		//key=(PUCHAR)ttcontext.buf;
+		key	= tk;
+		key_len	= 16;
+	}
+
+	/* the HMAC_MD5	transform looks	like:
+	 *
+	 * MD5(K XOR opad, MD5(K XOR ipad, text))
+	 *
+	 * where K is an n byte	key
+	 * ipad	is the byte	0x36 repeated 64 times
+	 * opad	is the byte	0x5c repeated 64 times
+	 * and text	is the data	being protected	*/
+
+	/* start out by	storing	key	in pads	*/
+	memset(k_ipad, 0, sizeof(k_ipad));
+	memset(k_opad, 0, sizeof(k_opad));
+	//assert(key_len < sizeof(k_ipad));
+	memcpy(k_ipad, key, key_len);
+	memcpy(k_opad, key, key_len);
+
+	/* XOR key with	ipad and opad values */
+	for	(i = 0;	i <	64;	i++) {
+		k_ipad[i] ^= 0x36;
+		k_opad[i] ^= 0x5c;
+	}
+
+	/* perform inner MD5 */
+	MD5Init(&context);					 /*	init context for 1st pass */
+	MD5Update(&context,	k_ipad,	64);	 /*	start with inner pad */
+	MD5Update(&context,	data, data_len); /*	then text of datagram */
+	MD5Final(mac, &context);			 /*	finish up 1st pass */
+
+	/* perform outer MD5 */
+	MD5Init(&context);					 /*	init context for 2nd pass */
+	MD5Update(&context,	k_opad,	64);	 /*	start with outer pad */
+	MD5Update(&context,	mac, 16);		 /*	then results of	1st	hash */
+	MD5Final(mac, &context);			 /*	finish up 2nd pass */
+}
+
+//#ifndef WORDS_BIGENDIAN
+#if	1
+#define	byteReverse(buf, len)	/* Nothing */
+#else
+void byteReverse(unsigned char *buf, unsigned longs);
+
+//#ifndef ASM_MD5
+#if	1
+/*
+ * Note: this code is harmless on little-endian	machines.
+ */
+void byteReverse(unsigned char *buf, unsigned longs)
+{
+	u32	t;
+		DBGPRINT(RT_DEBUG_TRACE, ("bbjanbb byte	reversee\n"));
+
+	do {
+		t =	(u32) ((unsigned) buf[3] <<	8 |	buf[2])	<< 16 |	((unsigned)	buf[1] << 8	| buf[0]);
+		*(u32 *) buf = t;
+		buf	+= 4;
+	} while	(--longs);
+}
+#endif
+#endif
+
+
+/* ==========================  MD5 implementation =========================== */ 
+// four base functions for MD5 
+#define MD5_F1(x, y, z) (((x) & (y)) | ((~x) & (z))) 
+#define MD5_F2(x, y, z) (((x) & (z)) | ((y) & (~z))) 
+#define MD5_F3(x, y, z) ((x) ^ (y) ^ (z))
+#define MD5_F4(x, y, z) ((y) ^ ((x) | (~z)))
+#define CYCLIC_LEFT_SHIFT(w, s) (((w) << (s)) | ((w) >> (32-(s))))
+
+#define	MD5Step(f, w, x, y,	z, data, t, s)	\
+	( w	+= f(x,	y, z) +	data + t,  w = (CYCLIC_LEFT_SHIFT(w, s)) & 0xffffffff, w +=	x )
+
+
+/*
+ *  Function Description:
+ *      Initiate MD5 Context satisfied in RFC 1321
+ *
+ *  Arguments:
+ *      pCtx        Pointer	to MD5 context
+ *
+ *  Return Value:
+ *      None	    
+ */
+VOID MD5Init(MD5_CTX *pCtx)
+{
+    pCtx->Buf[0]=0x67452301;
+    pCtx->Buf[1]=0xefcdab89;
+    pCtx->Buf[2]=0x98badcfe;
+    pCtx->Buf[3]=0x10325476;
+
+    pCtx->LenInBitCount[0]=0;
+    pCtx->LenInBitCount[1]=0;
+}
+
+
+/*
+ *  Function Description:
+ *      Update MD5 Context, allow of an arrary of octets as the next portion 
+ *      of the message
+ *      
+ *  Arguments:
+ *      pCtx		Pointer	to MD5 context
+ * 	    pData       Pointer to input data
+ *      LenInBytes  The length of input data (unit: byte)
+ *
+ *  Return Value:
+ *      None
+ *
+ *  Note:
+ *      Called after MD5Init or MD5Update(itself)   
+ */
+VOID MD5Update(MD5_CTX *pCtx, UCHAR *pData, ULONG LenInBytes)
+{
+    
+    ULONG TfTimes;
+    ULONG temp;
+	unsigned int i;
+    
+    temp = pCtx->LenInBitCount[0];
+
+    pCtx->LenInBitCount[0] = (ULONG) (pCtx->LenInBitCount[0] + (LenInBytes << 3));
+ 
+    if (pCtx->LenInBitCount[0] < temp)
+        pCtx->LenInBitCount[1]++;   //carry in
+
+    pCtx->LenInBitCount[1] += LenInBytes >> 29;
+
+    // mod 64 bytes
+    temp = (temp >> 3) & 0x3f;  
+    
+    // process lacks of 64-byte data 
+    if (temp) 
+    {
+        UCHAR *pAds = (UCHAR *) pCtx->Input + temp;
+        
+        if ((temp+LenInBytes) < 64)
+        {
+            memcpy(pAds, (UCHAR *)pData, LenInBytes);
+            return;
+        }
+        
+        memcpy(pAds, (UCHAR *)pData, 64-temp);
+        byteReverse(pCtx->Input, 16);
+        MD5Transform(pCtx->Buf, (ULONG *)pCtx->Input);
+
+        pData += 64-temp;
+        LenInBytes -= 64-temp; 
+    } // end of if (temp)
+    
+     
+    TfTimes = (LenInBytes >> 6);
+
+    for (i=TfTimes; i>0; i--)
+    {
+        memcpy(pCtx->Input, (UCHAR *)pData, 64);
+        byteReverse(pCtx->Input, 16);
+        MD5Transform(pCtx->Buf, (ULONG *)pCtx->Input);
+        pData += 64;
+        LenInBytes -= 64;
+    } // end of for
+
+    // buffering lacks of 64-byte data
+    if(LenInBytes)
+        memcpy(pCtx->Input, (UCHAR *)pData, LenInBytes);
+   
+}
+
+
+/*
+ *  Function Description:
+ *      Append padding bits and length of original message in the tail 
+ *      The message digest has to be completed in the end  
+ *  
+ *  Arguments:
+ *      Digest		Output of Digest-Message for MD5
+ *  	pCtx        Pointer	to MD5 context
+ * 	
+ *  Return Value:
+ *      None
+ *  
+ *  Note:
+ *      Called after MD5Update  
+ */
+VOID MD5Final(UCHAR Digest[16], MD5_CTX *pCtx)
+{
+    UCHAR Remainder;
+    UCHAR PadLenInBytes;
+    UCHAR *pAppend=0;
+    unsigned int i;
+    
+    Remainder = (UCHAR)((pCtx->LenInBitCount[0] >> 3) & 0x3f);
+
+    PadLenInBytes = (Remainder < 56) ? (56-Remainder) : (120-Remainder);
+    
+    pAppend = (UCHAR *)pCtx->Input + Remainder;
+
+    // padding bits without crossing block(64-byte based) boundary
+    if (Remainder < 56)
+    {
+        *pAppend = 0x80;
+        PadLenInBytes --;
+        
+        memset((UCHAR *)pCtx->Input + Remainder+1, 0, PadLenInBytes); 
+		
+		// add data-length field, from low to high
+       	for (i=0; i<4; i++)
+        {
+        	pCtx->Input[56+i] = (UCHAR)((pCtx->LenInBitCount[0] >> (i << 3)) & 0xff);
+        	pCtx->Input[60+i] = (UCHAR)((pCtx->LenInBitCount[1] >> (i << 3)) & 0xff);
+      	}
+      	
+        byteReverse(pCtx->Input, 16);
+        MD5Transform(pCtx->Buf, (ULONG *)pCtx->Input);
+    } // end of if
+    
+    // padding bits with crossing block(64-byte based) boundary
+    else
+    {
+        // the first block ===
+        *pAppend = 0x80;
+        PadLenInBytes --;
+       
+        memset((UCHAR *)pCtx->Input + Remainder+1, 0, (64-Remainder-1));
+        PadLenInBytes -= (64 - Remainder - 1);
+        
+        byteReverse(pCtx->Input, 16);
+        MD5Transform(pCtx->Buf, (ULONG *)pCtx->Input);
+        
+
+        // the second block ===
+        memset((UCHAR *)pCtx->Input, 0, PadLenInBytes);
+
+        // add data-length field
+        for (i=0; i<4; i++)
+        {
+        	pCtx->Input[56+i] = (UCHAR)((pCtx->LenInBitCount[0] >> (i << 3)) & 0xff);
+        	pCtx->Input[60+i] = (UCHAR)((pCtx->LenInBitCount[1] >> (i << 3)) & 0xff);
+      	}
+
+        byteReverse(pCtx->Input, 16);
+        MD5Transform(pCtx->Buf, (ULONG *)pCtx->Input);
+    } // end of else
+
+
+    memcpy((UCHAR *)Digest, (ULONG *)pCtx->Buf, 16); // output
+    byteReverse((UCHAR *)Digest, 4);
+    memset(pCtx, 0, sizeof(pCtx)); // memory free
+}
+
+
+/*
+ *  Function Description:
+ *      The central algorithm of MD5, consists of four rounds and sixteen 
+ *  	steps per round
+ * 
+ *  Arguments:
+ *      Buf     Buffers of four states (output: 16 bytes)		
+ * 	    Mes     Input data (input: 64 bytes) 
+ *  
+ *  Return Value:
+ *      None
+ *  	
+ *  Note:
+ *      Called by MD5Update or MD5Final
+ */
+VOID MD5Transform(ULONG Buf[4], ULONG Mes[16])
+{  
+    ULONG Reg[4], Temp; 
+	unsigned int i;
+    
+    static UCHAR LShiftVal[16] = 
+    { 	
+        7, 12, 17, 22, 	
+		5, 9 , 14, 20, 
+		4, 11, 16, 23, 
+ 		6, 10, 15, 21, 
+ 	};
+
+	
+	// [equal to 4294967296*abs(sin(index))]
+    static ULONG MD5Table[64] = 
+	{ 
+		0xd76aa478,	0xe8c7b756,	0x242070db,	0xc1bdceee,	
+		0xf57c0faf,	0x4787c62a,	0xa8304613, 0xfd469501,	
+		0x698098d8,	0x8b44f7af,	0xffff5bb1,	0x895cd7be,
+    	0x6b901122,	0xfd987193,	0xa679438e,	0x49b40821,
+    	
+    	0xf61e2562,	0xc040b340,	0x265e5a51,	0xe9b6c7aa,
+    	0xd62f105d,	0x02441453,	0xd8a1e681,	0xe7d3fbc8,
+    	0x21e1cde6,	0xc33707d6,	0xf4d50d87,	0x455a14ed,
+    	0xa9e3e905,	0xfcefa3f8,	0x676f02d9,	0x8d2a4c8a,
+    	           
+    	0xfffa3942,	0x8771f681,	0x6d9d6122,	0xfde5380c,
+    	0xa4beea44,	0x4bdecfa9,	0xf6bb4b60,	0xbebfbc70,
+    	0x289b7ec6,	0xeaa127fa,	0xd4ef3085,	0x04881d05,
+    	0xd9d4d039,	0xe6db99e5,	0x1fa27cf8,	0xc4ac5665,
+    	           
+    	0xf4292244,	0x432aff97,	0xab9423a7,	0xfc93a039,
+   		0x655b59c3,	0x8f0ccc92,	0xffeff47d,	0x85845dd1,
+    	0x6fa87e4f,	0xfe2ce6e0,	0xa3014314,	0x4e0811a1,
+    	0xf7537e82,	0xbd3af235,	0x2ad7d2bb,	0xeb86d391
+	};
+ 
+				
+    for (i=0; i<4; i++)
+        Reg[i]=Buf[i];
+			
+				
+    // 64 steps in MD5 algorithm
+    for (i=0; i<16; i++)                    
+    {
+        MD5Step(MD5_F1, Reg[0], Reg[1], Reg[2], Reg[3], Mes[i],               
+                MD5Table[i], LShiftVal[i & 0x3]);
+
+        // one-word right shift
+        Temp   = Reg[3]; 
+        Reg[3] = Reg[2];
+        Reg[2] = Reg[1];
+        Reg[1] = Reg[0];
+        Reg[0] = Temp;            
+    }
+    for (i=16; i<32; i++)                    
+    {
+        MD5Step(MD5_F2, Reg[0], Reg[1], Reg[2], Reg[3], Mes[(5*(i & 0xf)+1) & 0xf], 
+                MD5Table[i], LShiftVal[(0x1 << 2)+(i & 0x3)]);    
+
+        // one-word right shift
+        Temp   = Reg[3]; 
+        Reg[3] = Reg[2];
+        Reg[2] = Reg[1];
+        Reg[1] = Reg[0];
+        Reg[0] = Temp;           
+    }
+    for (i=32; i<48; i++)                    
+    {
+        MD5Step(MD5_F3, Reg[0], Reg[1], Reg[2], Reg[3], Mes[(3*(i & 0xf)+5) & 0xf], 
+                MD5Table[i], LShiftVal[(0x1 << 3)+(i & 0x3)]);        
+
+        // one-word right shift
+        Temp   = Reg[3]; 
+        Reg[3] = Reg[2];
+        Reg[2] = Reg[1];
+        Reg[1] = Reg[0];
+        Reg[0] = Temp;          
+    }
+    for (i=48; i<64; i++)                    
+    {
+        MD5Step(MD5_F4, Reg[0], Reg[1], Reg[2], Reg[3], Mes[(7*(i & 0xf)) & 0xf], 
+                MD5Table[i], LShiftVal[(0x3 << 2)+(i & 0x3)]);   
+
+        // one-word right shift
+        Temp   = Reg[3]; 
+        Reg[3] = Reg[2];
+        Reg[2] = Reg[1];
+        Reg[1] = Reg[0];
+        Reg[0] = Temp;           
+    }
+    
+      
+    // (temporary)output
+    for (i=0; i<4; i++)
+        Buf[i] += Reg[i];
+
+}
+
+
+
+/* =========================  SHA-1 implementation ========================== */
+// four base functions for SHA-1
+#define SHA1_F1(b, c, d)    (((b) & (c)) | ((~b) & (d)))         
+#define SHA1_F2(b, c, d)    ((b) ^ (c) ^ (d)) 
+#define SHA1_F3(b, c, d)    (((b) & (c)) | ((b) & (d)) | ((c) & (d)))
+
+
+#define SHA1Step(f, a, b, c, d, e, w, k)    \
+    ( e	+= ( f(b, c, d) + w + k + CYCLIC_LEFT_SHIFT(a, 5)) & 0xffffffff, \
+      b = CYCLIC_LEFT_SHIFT(b, 30) )
+
+//Initiate SHA-1 Context satisfied in RFC 3174  
+VOID SHAInit(SHA_CTX *pCtx)
+{
+    pCtx->Buf[0]=0x67452301;
+    pCtx->Buf[1]=0xefcdab89;
+    pCtx->Buf[2]=0x98badcfe;
+    pCtx->Buf[3]=0x10325476;
+    pCtx->Buf[4]=0xc3d2e1f0;
+    
+    pCtx->LenInBitCount[0]=0;
+    pCtx->LenInBitCount[1]=0;
+}
+
+/*
+ *  Function Description:
+ *      Update SHA-1 Context, allow of an arrary of octets as the next
+ *      portion of the message
+ *      
+ *  Arguments:
+ *      pCtx		Pointer	to SHA-1 context
+ * 	    pData       Pointer to input data
+ *      LenInBytes  The length of input data (unit: byte)
+ *
+ *  Return Value:
+ *      error       indicate more than pow(2,64) bits of data  
+ *
+ *  Note:
+ *      Called after SHAInit or SHAUpdate(itself)   
+ */
+UCHAR SHAUpdate(SHA_CTX *pCtx, UCHAR *pData, ULONG LenInBytes)
+{
+    ULONG TfTimes;
+    ULONG temp1,temp2;
+	unsigned int i;
+	UCHAR err=1;
+    
+    temp1 = pCtx->LenInBitCount[0];
+    temp2 = pCtx->LenInBitCount[1];
+
+    pCtx->LenInBitCount[0] = (ULONG) (pCtx->LenInBitCount[0] + (LenInBytes << 3));
+    if (pCtx->LenInBitCount[0] < temp1)
+        pCtx->LenInBitCount[1]++;   //carry in
+
+
+    pCtx->LenInBitCount[1] = (ULONG) (pCtx->LenInBitCount[1] +(LenInBytes >> 29));
+    if (pCtx->LenInBitCount[1] < temp2)
+        return (err);   //check total length of original data
+ 
+
+    // mod 64 bytes
+    temp1 = (temp1 >> 3) & 0x3f;  
+    
+    // process lacks of 64-byte data 
+    if (temp1) 
+    {
+        UCHAR *pAds = (UCHAR *) pCtx->Input + temp1;
+        
+        if ((temp1+LenInBytes) < 64)
+        {
+            memcpy(pAds, (UCHAR *)pData, LenInBytes);
+            return (0);
+        }
+        
+        memcpy(pAds, (UCHAR *)pData, 64-temp1);
+        
+        memset((UCHAR *)pCtx->Input + 64, 0, 16);
+        SHATransform(pCtx->Buf, (ULONG *)pCtx->Input);
+
+        pData += 64-temp1;
+        LenInBytes -= 64-temp1; 
+    } // end of if (temp1)
+    
+     
+    TfTimes = (LenInBytes >> 6);
+
+    for (i=TfTimes; i>0; i--)
+    {
+        memcpy(pCtx->Input, (UCHAR *)pData, 64);
+        
+        memset((UCHAR *)pCtx->Input + 64, 0, 16);
+        SHATransform(pCtx->Buf, (ULONG *)pCtx->Input);
+        pData += 64;
+        LenInBytes -= 64;
+    } // end of for
+
+    // buffering lacks of 64-byte data
+    if(LenInBytes)
+        memcpy(pCtx->Input, (UCHAR *)pData, LenInBytes);
+
+	return (0);
+
+}
+
+// Append padding bits and length of original message in the tail 
+// The message digest has to be completed in the end 
+VOID SHAFinal(SHA_CTX *pCtx, UCHAR Digest[20])
+{
+    UCHAR Remainder;
+    UCHAR PadLenInBytes;
+    UCHAR *pAppend=0;
+    unsigned int i;
+
+    Remainder = (UCHAR)((pCtx->LenInBitCount[0] >> 3) & 0x3f);
+
+    pAppend = (UCHAR *)pCtx->Input + Remainder;
+
+    PadLenInBytes = (Remainder < 56) ? (56-Remainder) : (120-Remainder);
+    
+    // padding bits without crossing block(64-byte based) boundary
+    if (Remainder < 56)
+    {       
+        *pAppend = 0x80;
+        PadLenInBytes --;
+        
+        memset((UCHAR *)pCtx->Input + Remainder+1, 0, PadLenInBytes);
+		 
+		// add data-length field, from high to low
+        for (i=0; i<4; i++)
+        {
+        	pCtx->Input[56+i] = (UCHAR)((pCtx->LenInBitCount[1] >> ((3-i) << 3)) & 0xff);
+        	pCtx->Input[60+i] = (UCHAR)((pCtx->LenInBitCount[0] >> ((3-i) << 3)) & 0xff);
+      	}
+      	
+        memset((UCHAR *)pCtx->Input + 64, 0, 14);
+        SHATransform(pCtx->Buf, (ULONG *)pCtx->Input);
+    } // end of if
+    
+    // padding bits with crossing block(64-byte based) boundary
+    else
+    {
+        // the first block ===
+        *pAppend = 0x80;
+        PadLenInBytes --;
+        
+        memset((UCHAR *)pCtx->Input + Remainder+1, 0, (64-Remainder-1));
+        PadLenInBytes -= (64 - Remainder - 1);
+        
+        memset((UCHAR *)pCtx->Input + 64, 0, 16);
+        SHATransform(pCtx->Buf, (ULONG *)pCtx->Input);
+
+
+        // the second block ===
+        memset((UCHAR *)pCtx->Input, 0, PadLenInBytes);
+			
+		// add data-length field
+		for (i=0; i<4; i++)
+        {
+        	pCtx->Input[56+i] = (UCHAR)((pCtx->LenInBitCount[1] >> ((3-i) << 3)) & 0xff);
+        	pCtx->Input[60+i] = (UCHAR)((pCtx->LenInBitCount[0] >> ((3-i) << 3)) & 0xff);
+      	}
+      	
+        memset((UCHAR *)pCtx->Input + 64, 0, 16);
+        SHATransform(pCtx->Buf, (ULONG *)pCtx->Input);
+    } // end of else
+	
+		
+    //Output, bytereverse
+    for (i=0; i<20; i++)
+    {
+        Digest [i] = (UCHAR)(pCtx->Buf[i>>2] >> 8*(3-(i & 0x3)));
+    }
+    
+    memset(pCtx, 0, sizeof(pCtx)); // memory free
+}
+
+
+// The central algorithm of SHA-1, consists of four rounds and 
+// twenty steps per round
+VOID SHATransform(ULONG Buf[5], ULONG Mes[20])
+{
+    ULONG Reg[5],Temp; 
+	unsigned int i;
+    ULONG W[80]; 
+   
+    static ULONG SHA1Table[4] = { 0x5a827999, 0x6ed9eba1, 
+                                  0x8f1bbcdc, 0xca62c1d6 };
+ 
+    Reg[0]=Buf[0];
+	Reg[1]=Buf[1];
+	Reg[2]=Buf[2];
+	Reg[3]=Buf[3];
+	Reg[4]=Buf[4];
+
+    //the first octet of a word is stored in the 0th element, bytereverse
+	for(i = 0; i < 16; i++)
+    { 
+    	W[i]  = (Mes[i] >> 24) & 0xff;
+        W[i] |= (Mes[i] >> 8 ) & 0xff00;
+        W[i] |= (Mes[i] << 8 ) & 0xff0000;
+        W[i] |= (Mes[i] << 24) & 0xff000000;
+    }
+    
+		 
+    for	(i = 0; i < 64; i++)
+	    W[16+i] = CYCLIC_LEFT_SHIFT(W[i] ^ W[2+i] ^ W[8+i] ^ W[13+i], 1);
+	    
+    
+    // 80 steps in SHA-1 algorithm
+    for (i=0; i<80; i++)                    
+    {
+        if (i<20)
+            SHA1Step(SHA1_F1, Reg[0], Reg[1], Reg[2], Reg[3], Reg[4], 
+                     W[i], SHA1Table[0]);
+        
+        else if (i>=20 && i<40)
+            SHA1Step(SHA1_F2, Reg[0], Reg[1], Reg[2], Reg[3], Reg[4], 
+                     W[i], SHA1Table[1]);
+			
+		else if (i>=40 && i<60)
+            SHA1Step(SHA1_F3, Reg[0], Reg[1], Reg[2], Reg[3], Reg[4], 
+                      W[i], SHA1Table[2]);
+			
+        else
+            SHA1Step(SHA1_F2, Reg[0], Reg[1], Reg[2], Reg[3], Reg[4], 
+                     W[i], SHA1Table[3]);
+			
+
+       // one-word right shift
+		Temp   = Reg[4];
+        Reg[4] = Reg[3];
+        Reg[3] = Reg[2];
+        Reg[2] = Reg[1];
+        Reg[1] = Reg[0];
+        Reg[0] = Temp;       
+  
+    } // end of for-loop
+
+
+    // (temporary)output
+    for (i=0; i<5; i++)
+        Buf[i] += Reg[i];
+    
+}
+
+
+/* =========================  AES En/Decryption ========================== */
+
+/* forward S-box */
+static uint32 FSb[256] =
+{
+	0x63, 0x7C,	0x77, 0x7B,	0xF2, 0x6B,	0x6F, 0xC5,
+	0x30, 0x01,	0x67, 0x2B,	0xFE, 0xD7,	0xAB, 0x76,
+	0xCA, 0x82,	0xC9, 0x7D,	0xFA, 0x59,	0x47, 0xF0,
+	0xAD, 0xD4,	0xA2, 0xAF,	0x9C, 0xA4,	0x72, 0xC0,
+	0xB7, 0xFD,	0x93, 0x26,	0x36, 0x3F,	0xF7, 0xCC,
+	0x34, 0xA5,	0xE5, 0xF1,	0x71, 0xD8,	0x31, 0x15,
+	0x04, 0xC7,	0x23, 0xC3,	0x18, 0x96,	0x05, 0x9A,
+	0x07, 0x12,	0x80, 0xE2,	0xEB, 0x27,	0xB2, 0x75,
+	0x09, 0x83,	0x2C, 0x1A,	0x1B, 0x6E,	0x5A, 0xA0,
+	0x52, 0x3B,	0xD6, 0xB3,	0x29, 0xE3,	0x2F, 0x84,
+	0x53, 0xD1,	0x00, 0xED,	0x20, 0xFC,	0xB1, 0x5B,
+	0x6A, 0xCB,	0xBE, 0x39,	0x4A, 0x4C,	0x58, 0xCF,
+	0xD0, 0xEF,	0xAA, 0xFB,	0x43, 0x4D,	0x33, 0x85,
+	0x45, 0xF9,	0x02, 0x7F,	0x50, 0x3C,	0x9F, 0xA8,
+	0x51, 0xA3,	0x40, 0x8F,	0x92, 0x9D,	0x38, 0xF5,
+	0xBC, 0xB6,	0xDA, 0x21,	0x10, 0xFF,	0xF3, 0xD2,
+	0xCD, 0x0C,	0x13, 0xEC,	0x5F, 0x97,	0x44, 0x17,
+	0xC4, 0xA7,	0x7E, 0x3D,	0x64, 0x5D,	0x19, 0x73,
+	0x60, 0x81,	0x4F, 0xDC,	0x22, 0x2A,	0x90, 0x88,
+	0x46, 0xEE,	0xB8, 0x14,	0xDE, 0x5E,	0x0B, 0xDB,
+	0xE0, 0x32,	0x3A, 0x0A,	0x49, 0x06,	0x24, 0x5C,
+	0xC2, 0xD3,	0xAC, 0x62,	0x91, 0x95,	0xE4, 0x79,
+	0xE7, 0xC8,	0x37, 0x6D,	0x8D, 0xD5,	0x4E, 0xA9,
+	0x6C, 0x56,	0xF4, 0xEA,	0x65, 0x7A,	0xAE, 0x08,
+	0xBA, 0x78,	0x25, 0x2E,	0x1C, 0xA6,	0xB4, 0xC6,
+	0xE8, 0xDD,	0x74, 0x1F,	0x4B, 0xBD,	0x8B, 0x8A,
+	0x70, 0x3E,	0xB5, 0x66,	0x48, 0x03,	0xF6, 0x0E,
+	0x61, 0x35,	0x57, 0xB9,	0x86, 0xC1,	0x1D, 0x9E,
+	0xE1, 0xF8,	0x98, 0x11,	0x69, 0xD9,	0x8E, 0x94,
+	0x9B, 0x1E,	0x87, 0xE9,	0xCE, 0x55,	0x28, 0xDF,
+	0x8C, 0xA1,	0x89, 0x0D,	0xBF, 0xE6,	0x42, 0x68,
+	0x41, 0x99,	0x2D, 0x0F,	0xB0, 0x54,	0xBB, 0x16
+};
+
+/* forward table */
+#define	FT \
+\
+	V(C6,63,63,A5),	V(F8,7C,7C,84),	V(EE,77,77,99),	V(F6,7B,7B,8D),	\
+	V(FF,F2,F2,0D),	V(D6,6B,6B,BD),	V(DE,6F,6F,B1),	V(91,C5,C5,54),	\
+	V(60,30,30,50),	V(02,01,01,03),	V(CE,67,67,A9),	V(56,2B,2B,7D),	\
+	V(E7,FE,FE,19),	V(B5,D7,D7,62),	V(4D,AB,AB,E6),	V(EC,76,76,9A),	\
+	V(8F,CA,CA,45),	V(1F,82,82,9D),	V(89,C9,C9,40),	V(FA,7D,7D,87),	\
+	V(EF,FA,FA,15),	V(B2,59,59,EB),	V(8E,47,47,C9),	V(FB,F0,F0,0B),	\
+	V(41,AD,AD,EC),	V(B3,D4,D4,67),	V(5F,A2,A2,FD),	V(45,AF,AF,EA),	\
+	V(23,9C,9C,BF),	V(53,A4,A4,F7),	V(E4,72,72,96),	V(9B,C0,C0,5B),	\
+	V(75,B7,B7,C2),	V(E1,FD,FD,1C),	V(3D,93,93,AE),	V(4C,26,26,6A),	\
+	V(6C,36,36,5A),	V(7E,3F,3F,41),	V(F5,F7,F7,02),	V(83,CC,CC,4F),	\
+	V(68,34,34,5C),	V(51,A5,A5,F4),	V(D1,E5,E5,34),	V(F9,F1,F1,08),	\
+	V(E2,71,71,93),	V(AB,D8,D8,73),	V(62,31,31,53),	V(2A,15,15,3F),	\
+	V(08,04,04,0C),	V(95,C7,C7,52),	V(46,23,23,65),	V(9D,C3,C3,5E),	\
+	V(30,18,18,28),	V(37,96,96,A1),	V(0A,05,05,0F),	V(2F,9A,9A,B5),	\
+	V(0E,07,07,09),	V(24,12,12,36),	V(1B,80,80,9B),	V(DF,E2,E2,3D),	\
+	V(CD,EB,EB,26),	V(4E,27,27,69),	V(7F,B2,B2,CD),	V(EA,75,75,9F),	\
+	V(12,09,09,1B),	V(1D,83,83,9E),	V(58,2C,2C,74),	V(34,1A,1A,2E),	\
+	V(36,1B,1B,2D),	V(DC,6E,6E,B2),	V(B4,5A,5A,EE),	V(5B,A0,A0,FB),	\
+	V(A4,52,52,F6),	V(76,3B,3B,4D),	V(B7,D6,D6,61),	V(7D,B3,B3,CE),	\
+	V(52,29,29,7B),	V(DD,E3,E3,3E),	V(5E,2F,2F,71),	V(13,84,84,97),	\
+	V(A6,53,53,F5),	V(B9,D1,D1,68),	V(00,00,00,00),	V(C1,ED,ED,2C),	\
+	V(40,20,20,60),	V(E3,FC,FC,1F),	V(79,B1,B1,C8),	V(B6,5B,5B,ED),	\
+	V(D4,6A,6A,BE),	V(8D,CB,CB,46),	V(67,BE,BE,D9),	V(72,39,39,4B),	\
+	V(94,4A,4A,DE),	V(98,4C,4C,D4),	V(B0,58,58,E8),	V(85,CF,CF,4A),	\
+	V(BB,D0,D0,6B),	V(C5,EF,EF,2A),	V(4F,AA,AA,E5),	V(ED,FB,FB,16),	\
+	V(86,43,43,C5),	V(9A,4D,4D,D7),	V(66,33,33,55),	V(11,85,85,94),	\
+	V(8A,45,45,CF),	V(E9,F9,F9,10),	V(04,02,02,06),	V(FE,7F,7F,81),	\
+	V(A0,50,50,F0),	V(78,3C,3C,44),	V(25,9F,9F,BA),	V(4B,A8,A8,E3),	\
+	V(A2,51,51,F3),	V(5D,A3,A3,FE),	V(80,40,40,C0),	V(05,8F,8F,8A),	\
+	V(3F,92,92,AD),	V(21,9D,9D,BC),	V(70,38,38,48),	V(F1,F5,F5,04),	\
+	V(63,BC,BC,DF),	V(77,B6,B6,C1),	V(AF,DA,DA,75),	V(42,21,21,63),	\
+	V(20,10,10,30),	V(E5,FF,FF,1A),	V(FD,F3,F3,0E),	V(BF,D2,D2,6D),	\
+	V(81,CD,CD,4C),	V(18,0C,0C,14),	V(26,13,13,35),	V(C3,EC,EC,2F),	\
+	V(BE,5F,5F,E1),	V(35,97,97,A2),	V(88,44,44,CC),	V(2E,17,17,39),	\
+	V(93,C4,C4,57),	V(55,A7,A7,F2),	V(FC,7E,7E,82),	V(7A,3D,3D,47),	\
+	V(C8,64,64,AC),	V(BA,5D,5D,E7),	V(32,19,19,2B),	V(E6,73,73,95),	\
+	V(C0,60,60,A0),	V(19,81,81,98),	V(9E,4F,4F,D1),	V(A3,DC,DC,7F),	\
+	V(44,22,22,66),	V(54,2A,2A,7E),	V(3B,90,90,AB),	V(0B,88,88,83),	\
+	V(8C,46,46,CA),	V(C7,EE,EE,29),	V(6B,B8,B8,D3),	V(28,14,14,3C),	\
+	V(A7,DE,DE,79),	V(BC,5E,5E,E2),	V(16,0B,0B,1D),	V(AD,DB,DB,76),	\
+	V(DB,E0,E0,3B),	V(64,32,32,56),	V(74,3A,3A,4E),	V(14,0A,0A,1E),	\
+	V(92,49,49,DB),	V(0C,06,06,0A),	V(48,24,24,6C),	V(B8,5C,5C,E4),	\
+	V(9F,C2,C2,5D),	V(BD,D3,D3,6E),	V(43,AC,AC,EF),	V(C4,62,62,A6),	\
+	V(39,91,91,A8),	V(31,95,95,A4),	V(D3,E4,E4,37),	V(F2,79,79,8B),	\
+	V(D5,E7,E7,32),	V(8B,C8,C8,43),	V(6E,37,37,59),	V(DA,6D,6D,B7),	\
+	V(01,8D,8D,8C),	V(B1,D5,D5,64),	V(9C,4E,4E,D2),	V(49,A9,A9,E0),	\
+	V(D8,6C,6C,B4),	V(AC,56,56,FA),	V(F3,F4,F4,07),	V(CF,EA,EA,25),	\
+	V(CA,65,65,AF),	V(F4,7A,7A,8E),	V(47,AE,AE,E9),	V(10,08,08,18),	\
+	V(6F,BA,BA,D5),	V(F0,78,78,88),	V(4A,25,25,6F),	V(5C,2E,2E,72),	\
+	V(38,1C,1C,24),	V(57,A6,A6,F1),	V(73,B4,B4,C7),	V(97,C6,C6,51),	\
+	V(CB,E8,E8,23),	V(A1,DD,DD,7C),	V(E8,74,74,9C),	V(3E,1F,1F,21),	\
+	V(96,4B,4B,DD),	V(61,BD,BD,DC),	V(0D,8B,8B,86),	V(0F,8A,8A,85),	\
+	V(E0,70,70,90),	V(7C,3E,3E,42),	V(71,B5,B5,C4),	V(CC,66,66,AA),	\
+	V(90,48,48,D8),	V(06,03,03,05),	V(F7,F6,F6,01),	V(1C,0E,0E,12),	\
+	V(C2,61,61,A3),	V(6A,35,35,5F),	V(AE,57,57,F9),	V(69,B9,B9,D0),	\
+	V(17,86,86,91),	V(99,C1,C1,58),	V(3A,1D,1D,27),	V(27,9E,9E,B9),	\
+	V(D9,E1,E1,38),	V(EB,F8,F8,13),	V(2B,98,98,B3),	V(22,11,11,33),	\
+	V(D2,69,69,BB),	V(A9,D9,D9,70),	V(07,8E,8E,89),	V(33,94,94,A7),	\
+	V(2D,9B,9B,B6),	V(3C,1E,1E,22),	V(15,87,87,92),	V(C9,E9,E9,20),	\
+	V(87,CE,CE,49),	V(AA,55,55,FF),	V(50,28,28,78),	V(A5,DF,DF,7A),	\
+	V(03,8C,8C,8F),	V(59,A1,A1,F8),	V(09,89,89,80),	V(1A,0D,0D,17),	\
+	V(65,BF,BF,DA),	V(D7,E6,E6,31),	V(84,42,42,C6),	V(D0,68,68,B8),	\
+	V(82,41,41,C3),	V(29,99,99,B0),	V(5A,2D,2D,77),	V(1E,0F,0F,11),	\
+	V(7B,B0,B0,CB),	V(A8,54,54,FC),	V(6D,BB,BB,D6),	V(2C,16,16,3A)
+
+#define	V(a,b,c,d) 0x##a##b##c##d
+static uint32 FT0[256] = { FT };
+#undef V
+
+#define	V(a,b,c,d) 0x##d##a##b##c
+static uint32 FT1[256] = { FT };
+#undef V
+
+#define	V(a,b,c,d) 0x##c##d##a##b
+static uint32 FT2[256] = { FT };
+#undef V
+
+#define	V(a,b,c,d) 0x##b##c##d##a
+static uint32 FT3[256] = { FT };
+#undef V
+
+#undef FT
+
+/* reverse S-box */
+
+static uint32 RSb[256] =
+{
+	0x52, 0x09,	0x6A, 0xD5,	0x30, 0x36,	0xA5, 0x38,
+	0xBF, 0x40,	0xA3, 0x9E,	0x81, 0xF3,	0xD7, 0xFB,
+	0x7C, 0xE3,	0x39, 0x82,	0x9B, 0x2F,	0xFF, 0x87,
+	0x34, 0x8E,	0x43, 0x44,	0xC4, 0xDE,	0xE9, 0xCB,
+	0x54, 0x7B,	0x94, 0x32,	0xA6, 0xC2,	0x23, 0x3D,
+	0xEE, 0x4C,	0x95, 0x0B,	0x42, 0xFA,	0xC3, 0x4E,
+	0x08, 0x2E,	0xA1, 0x66,	0x28, 0xD9,	0x24, 0xB2,
+	0x76, 0x5B,	0xA2, 0x49,	0x6D, 0x8B,	0xD1, 0x25,
+	0x72, 0xF8,	0xF6, 0x64,	0x86, 0x68,	0x98, 0x16,
+	0xD4, 0xA4,	0x5C, 0xCC,	0x5D, 0x65,	0xB6, 0x92,
+	0x6C, 0x70,	0x48, 0x50,	0xFD, 0xED,	0xB9, 0xDA,
+	0x5E, 0x15,	0x46, 0x57,	0xA7, 0x8D,	0x9D, 0x84,
+	0x90, 0xD8,	0xAB, 0x00,	0x8C, 0xBC,	0xD3, 0x0A,
+	0xF7, 0xE4,	0x58, 0x05,	0xB8, 0xB3,	0x45, 0x06,
+	0xD0, 0x2C,	0x1E, 0x8F,	0xCA, 0x3F,	0x0F, 0x02,
+	0xC1, 0xAF,	0xBD, 0x03,	0x01, 0x13,	0x8A, 0x6B,
+	0x3A, 0x91,	0x11, 0x41,	0x4F, 0x67,	0xDC, 0xEA,
+	0x97, 0xF2,	0xCF, 0xCE,	0xF0, 0xB4,	0xE6, 0x73,
+	0x96, 0xAC,	0x74, 0x22,	0xE7, 0xAD,	0x35, 0x85,
+	0xE2, 0xF9,	0x37, 0xE8,	0x1C, 0x75,	0xDF, 0x6E,
+	0x47, 0xF1,	0x1A, 0x71,	0x1D, 0x29,	0xC5, 0x89,
+	0x6F, 0xB7,	0x62, 0x0E,	0xAA, 0x18,	0xBE, 0x1B,
+	0xFC, 0x56,	0x3E, 0x4B,	0xC6, 0xD2,	0x79, 0x20,
+	0x9A, 0xDB,	0xC0, 0xFE,	0x78, 0xCD,	0x5A, 0xF4,
+	0x1F, 0xDD,	0xA8, 0x33,	0x88, 0x07,	0xC7, 0x31,
+	0xB1, 0x12,	0x10, 0x59,	0x27, 0x80,	0xEC, 0x5F,
+	0x60, 0x51,	0x7F, 0xA9,	0x19, 0xB5,	0x4A, 0x0D,
+	0x2D, 0xE5,	0x7A, 0x9F,	0x93, 0xC9,	0x9C, 0xEF,
+	0xA0, 0xE0,	0x3B, 0x4D,	0xAE, 0x2A,	0xF5, 0xB0,
+	0xC8, 0xEB,	0xBB, 0x3C,	0x83, 0x53,	0x99, 0x61,
+	0x17, 0x2B,	0x04, 0x7E,	0xBA, 0x77,	0xD6, 0x26,
+	0xE1, 0x69,	0x14, 0x63,	0x55, 0x21,	0x0C, 0x7D
+};
+
+/* reverse table */
+
+#define	RT \
+\
+	V(51,F4,A7,50),	V(7E,41,65,53),	V(1A,17,A4,C3),	V(3A,27,5E,96),	\
+	V(3B,AB,6B,CB),	V(1F,9D,45,F1),	V(AC,FA,58,AB),	V(4B,E3,03,93),	\
+	V(20,30,FA,55),	V(AD,76,6D,F6),	V(88,CC,76,91),	V(F5,02,4C,25),	\
+	V(4F,E5,D7,FC),	V(C5,2A,CB,D7),	V(26,35,44,80),	V(B5,62,A3,8F),	\
+	V(DE,B1,5A,49),	V(25,BA,1B,67),	V(45,EA,0E,98),	V(5D,FE,C0,E1),	\
+	V(C3,2F,75,02),	V(81,4C,F0,12),	V(8D,46,97,A3),	V(6B,D3,F9,C6),	\
+	V(03,8F,5F,E7),	V(15,92,9C,95),	V(BF,6D,7A,EB),	V(95,52,59,DA),	\
+	V(D4,BE,83,2D),	V(58,74,21,D3),	V(49,E0,69,29),	V(8E,C9,C8,44),	\
+	V(75,C2,89,6A),	V(F4,8E,79,78),	V(99,58,3E,6B),	V(27,B9,71,DD),	\
+	V(BE,E1,4F,B6),	V(F0,88,AD,17),	V(C9,20,AC,66),	V(7D,CE,3A,B4),	\
+	V(63,DF,4A,18),	V(E5,1A,31,82),	V(97,51,33,60),	V(62,53,7F,45),	\
+	V(B1,64,77,E0),	V(BB,6B,AE,84),	V(FE,81,A0,1C),	V(F9,08,2B,94),	\
+	V(70,48,68,58),	V(8F,45,FD,19),	V(94,DE,6C,87),	V(52,7B,F8,B7),	\
+	V(AB,73,D3,23),	V(72,4B,02,E2),	V(E3,1F,8F,57),	V(66,55,AB,2A),	\
+	V(B2,EB,28,07),	V(2F,B5,C2,03),	V(86,C5,7B,9A),	V(D3,37,08,A5),	\
+	V(30,28,87,F2),	V(23,BF,A5,B2),	V(02,03,6A,BA),	V(ED,16,82,5C),	\
+	V(8A,CF,1C,2B),	V(A7,79,B4,92),	V(F3,07,F2,F0),	V(4E,69,E2,A1),	\
+	V(65,DA,F4,CD),	V(06,05,BE,D5),	V(D1,34,62,1F),	V(C4,A6,FE,8A),	\
+	V(34,2E,53,9D),	V(A2,F3,55,A0),	V(05,8A,E1,32),	V(A4,F6,EB,75),	\
+	V(0B,83,EC,39),	V(40,60,EF,AA),	V(5E,71,9F,06),	V(BD,6E,10,51),	\
+	V(3E,21,8A,F9),	V(96,DD,06,3D),	V(DD,3E,05,AE),	V(4D,E6,BD,46),	\
+	V(91,54,8D,B5),	V(71,C4,5D,05),	V(04,06,D4,6F),	V(60,50,15,FF),	\
+	V(19,98,FB,24),	V(D6,BD,E9,97),	V(89,40,43,CC),	V(67,D9,9E,77),	\
+	V(B0,E8,42,BD),	V(07,89,8B,88),	V(E7,19,5B,38),	V(79,C8,EE,DB),	\
+	V(A1,7C,0A,47),	V(7C,42,0F,E9),	V(F8,84,1E,C9),	V(00,00,00,00),	\
+	V(09,80,86,83),	V(32,2B,ED,48),	V(1E,11,70,AC),	V(6C,5A,72,4E),	\
+	V(FD,0E,FF,FB),	V(0F,85,38,56),	V(3D,AE,D5,1E),	V(36,2D,39,27),	\
+	V(0A,0F,D9,64),	V(68,5C,A6,21),	V(9B,5B,54,D1),	V(24,36,2E,3A),	\
+	V(0C,0A,67,B1),	V(93,57,E7,0F),	V(B4,EE,96,D2),	V(1B,9B,91,9E),	\
+	V(80,C0,C5,4F),	V(61,DC,20,A2),	V(5A,77,4B,69),	V(1C,12,1A,16),	\
+	V(E2,93,BA,0A),	V(C0,A0,2A,E5),	V(3C,22,E0,43),	V(12,1B,17,1D),	\
+	V(0E,09,0D,0B),	V(F2,8B,C7,AD),	V(2D,B6,A8,B9),	V(14,1E,A9,C8),	\
+	V(57,F1,19,85),	V(AF,75,07,4C),	V(EE,99,DD,BB),	V(A3,7F,60,FD),	\
+	V(F7,01,26,9F),	V(5C,72,F5,BC),	V(44,66,3B,C5),	V(5B,FB,7E,34),	\
+	V(8B,43,29,76),	V(CB,23,C6,DC),	V(B6,ED,FC,68),	V(B8,E4,F1,63),	\
+	V(D7,31,DC,CA),	V(42,63,85,10),	V(13,97,22,40),	V(84,C6,11,20),	\
+	V(85,4A,24,7D),	V(D2,BB,3D,F8),	V(AE,F9,32,11),	V(C7,29,A1,6D),	\
+	V(1D,9E,2F,4B),	V(DC,B2,30,F3),	V(0D,86,52,EC),	V(77,C1,E3,D0),	\
+	V(2B,B3,16,6C),	V(A9,70,B9,99),	V(11,94,48,FA),	V(47,E9,64,22),	\
+	V(A8,FC,8C,C4),	V(A0,F0,3F,1A),	V(56,7D,2C,D8),	V(22,33,90,EF),	\
+	V(87,49,4E,C7),	V(D9,38,D1,C1),	V(8C,CA,A2,FE),	V(98,D4,0B,36),	\
+	V(A6,F5,81,CF),	V(A5,7A,DE,28),	V(DA,B7,8E,26),	V(3F,AD,BF,A4),	\
+	V(2C,3A,9D,E4),	V(50,78,92,0D),	V(6A,5F,CC,9B),	V(54,7E,46,62),	\
+	V(F6,8D,13,C2),	V(90,D8,B8,E8),	V(2E,39,F7,5E),	V(82,C3,AF,F5),	\
+	V(9F,5D,80,BE),	V(69,D0,93,7C),	V(6F,D5,2D,A9),	V(CF,25,12,B3),	\
+	V(C8,AC,99,3B),	V(10,18,7D,A7),	V(E8,9C,63,6E),	V(DB,3B,BB,7B),	\
+	V(CD,26,78,09),	V(6E,59,18,F4),	V(EC,9A,B7,01),	V(83,4F,9A,A8),	\
+	V(E6,95,6E,65),	V(AA,FF,E6,7E),	V(21,BC,CF,08),	V(EF,15,E8,E6),	\
+	V(BA,E7,9B,D9),	V(4A,6F,36,CE),	V(EA,9F,09,D4),	V(29,B0,7C,D6),	\
+	V(31,A4,B2,AF),	V(2A,3F,23,31),	V(C6,A5,94,30),	V(35,A2,66,C0),	\
+	V(74,4E,BC,37),	V(FC,82,CA,A6),	V(E0,90,D0,B0),	V(33,A7,D8,15),	\
+	V(F1,04,98,4A),	V(41,EC,DA,F7),	V(7F,CD,50,0E),	V(17,91,F6,2F),	\
+	V(76,4D,D6,8D),	V(43,EF,B0,4D),	V(CC,AA,4D,54),	V(E4,96,04,DF),	\
+	V(9E,D1,B5,E3),	V(4C,6A,88,1B),	V(C1,2C,1F,B8),	V(46,65,51,7F),	\
+	V(9D,5E,EA,04),	V(01,8C,35,5D),	V(FA,87,74,73),	V(FB,0B,41,2E),	\
+	V(B3,67,1D,5A),	V(92,DB,D2,52),	V(E9,10,56,33),	V(6D,D6,47,13),	\
+	V(9A,D7,61,8C),	V(37,A1,0C,7A),	V(59,F8,14,8E),	V(EB,13,3C,89),	\
+	V(CE,A9,27,EE),	V(B7,61,C9,35),	V(E1,1C,E5,ED),	V(7A,47,B1,3C),	\
+	V(9C,D2,DF,59),	V(55,F2,73,3F),	V(18,14,CE,79),	V(73,C7,37,BF),	\
+	V(53,F7,CD,EA),	V(5F,FD,AA,5B),	V(DF,3D,6F,14),	V(78,44,DB,86),	\
+	V(CA,AF,F3,81),	V(B9,68,C4,3E),	V(38,24,34,2C),	V(C2,A3,40,5F),	\
+	V(16,1D,C3,72),	V(BC,E2,25,0C),	V(28,3C,49,8B),	V(FF,0D,95,41),	\
+	V(39,A8,01,71),	V(08,0C,B3,DE),	V(D8,B4,E4,9C),	V(64,56,C1,90),	\
+	V(7B,CB,84,61),	V(D5,32,B6,70),	V(48,6C,5C,74),	V(D0,B8,57,42)
+
+#define	V(a,b,c,d) 0x##a##b##c##d
+static uint32 RT0[256] = { RT };
+#undef V
+
+#define	V(a,b,c,d) 0x##d##a##b##c
+static uint32 RT1[256] = { RT };
+#undef V
+
+#define	V(a,b,c,d) 0x##c##d##a##b
+static uint32 RT2[256] = { RT };
+#undef V
+
+#define	V(a,b,c,d) 0x##b##c##d##a
+static uint32 RT3[256] = { RT };
+#undef V
+
+#undef RT
+
+/* round constants */
+
+static uint32 RCON[10] =
+{
+	0x01000000,	0x02000000,	0x04000000,	0x08000000,
+	0x10000000,	0x20000000,	0x40000000,	0x80000000,
+	0x1B000000,	0x36000000
+};
+
+/* key schedule	tables */
+
+static int KT_init = 1;
+
+static uint32 KT0[256];
+static uint32 KT1[256];
+static uint32 KT2[256];
+static uint32 KT3[256];
+
+/* platform-independant	32-bit integer manipulation	macros */
+
+#define	GET_UINT32(n,b,i)						\
+{												\
+	(n)	= (	(uint32) (b)[(i)	] << 24	)		\
+		| (	(uint32) (b)[(i) + 1] << 16	)		\
+		| (	(uint32) (b)[(i) + 2] <<  8	)		\
+		| (	(uint32) (b)[(i) + 3]		);		\
+}
+
+#define	PUT_UINT32(n,b,i)						\
+{												\
+	(b)[(i)	   ] = (uint8) ( (n) >>	24 );		\
+	(b)[(i)	+ 1] = (uint8) ( (n) >>	16 );		\
+	(b)[(i)	+ 2] = (uint8) ( (n) >>	 8 );		\
+	(b)[(i)	+ 3] = (uint8) ( (n)	   );		\
+}
+
+/* AES key scheduling routine */
+
+int	aes_set_key( aes_context *ctx, uint8 *key, int nbits )
+{
+	int	i;
+	uint32 *RK,	*SK;
+
+	switch(	nbits )
+	{
+		case 128: ctx->nr =	10;	break;
+		case 192: ctx->nr =	12;	break;
+		case 256: ctx->nr =	14;	break;
+		default	: return( 1	);
+	}
+
+	RK = ctx->erk;
+
+	for( i = 0;	i <	(nbits >> 5); i++ )
+	{
+		GET_UINT32(	RK[i], key,	i *	4 );
+	}
+
+	/* setup encryption	round keys */
+
+	switch(	nbits )
+	{
+	case 128:
+
+		for( i = 0;	i <	10;	i++, RK	+= 4 )
+		{
+			RK[4]  = RK[0] ^ RCON[i] ^
+						( FSb[ (uint8) ( RK[3] >> 16 ) ] <<	24 ) ^
+						( FSb[ (uint8) ( RK[3] >>  8 ) ] <<	16 ) ^
+						( FSb[ (uint8) ( RK[3]		 ) ] <<	 8 ) ^
+						( FSb[ (uint8) ( RK[3] >> 24 ) ]	   );
+
+			RK[5]  = RK[1] ^ RK[4];
+			RK[6]  = RK[2] ^ RK[5];
+			RK[7]  = RK[3] ^ RK[6];
+		}
+		break;
+
+	case 192:
+
+		for( i = 0;	i <	8; i++,	RK += 6	)
+		{
+			RK[6]  = RK[0] ^ RCON[i] ^
+						( FSb[ (uint8) ( RK[5] >> 16 ) ] <<	24 ) ^
+						( FSb[ (uint8) ( RK[5] >>  8 ) ] <<	16 ) ^
+						( FSb[ (uint8) ( RK[5]		 ) ] <<	 8 ) ^
+						( FSb[ (uint8) ( RK[5] >> 24 ) ]	   );
+
+			RK[7]  = RK[1] ^ RK[6];
+			RK[8]  = RK[2] ^ RK[7];
+			RK[9]  = RK[3] ^ RK[8];
+			RK[10] = RK[4] ^ RK[9];
+			RK[11] = RK[5] ^ RK[10];
+		}
+		break;
+
+	case 256:
+
+		for( i = 0;	i <	7; i++,	RK += 8	)
+		{
+			RK[8]  = RK[0] ^ RCON[i] ^
+						( FSb[ (uint8) ( RK[7] >> 16 ) ] <<	24 ) ^
+						( FSb[ (uint8) ( RK[7] >>  8 ) ] <<	16 ) ^
+						( FSb[ (uint8) ( RK[7]		 ) ] <<	 8 ) ^
+						( FSb[ (uint8) ( RK[7] >> 24 ) ]	   );
+
+			RK[9]  = RK[1] ^ RK[8];
+			RK[10] = RK[2] ^ RK[9];
+			RK[11] = RK[3] ^ RK[10];
+
+			RK[12] = RK[4] ^
+						( FSb[ (uint8) ( RK[11]	>> 24 )	] << 24	) ^
+						( FSb[ (uint8) ( RK[11]	>> 16 )	] << 16	) ^
+						( FSb[ (uint8) ( RK[11]	>>	8 )	] <<  8	) ^
+						( FSb[ (uint8) ( RK[11]		  )	]		);
+
+			RK[13] = RK[5] ^ RK[12];
+			RK[14] = RK[6] ^ RK[13];
+			RK[15] = RK[7] ^ RK[14];
+		}
+		break;
+	}
+
+	/* setup decryption	round keys */
+
+	if(	KT_init	)
+	{
+		for( i = 0;	i <	256; i++ )
+		{
+			KT0[i] = RT0[ FSb[i] ];
+			KT1[i] = RT1[ FSb[i] ];
+			KT2[i] = RT2[ FSb[i] ];
+			KT3[i] = RT3[ FSb[i] ];
+		}
+
+		KT_init	= 0;
+	}
+
+	SK = ctx->drk;
+
+	*SK++ =	*RK++;
+	*SK++ =	*RK++;
+	*SK++ =	*RK++;
+	*SK++ =	*RK++;
+
+	for( i = 1;	i <	ctx->nr; i++ )
+	{
+		RK -= 8;
+
+		*SK++ =	KT0[ (uint8) ( *RK >> 24 ) ] ^
+				KT1[ (uint8) ( *RK >> 16 ) ] ^
+				KT2[ (uint8) ( *RK >>  8 ) ] ^
+				KT3[ (uint8) ( *RK		 ) ]; RK++;
+
+		*SK++ =	KT0[ (uint8) ( *RK >> 24 ) ] ^
+				KT1[ (uint8) ( *RK >> 16 ) ] ^
+				KT2[ (uint8) ( *RK >>  8 ) ] ^
+				KT3[ (uint8) ( *RK		 ) ]; RK++;
+
+		*SK++ =	KT0[ (uint8) ( *RK >> 24 ) ] ^
+				KT1[ (uint8) ( *RK >> 16 ) ] ^
+				KT2[ (uint8) ( *RK >>  8 ) ] ^
+				KT3[ (uint8) ( *RK		 ) ]; RK++;
+
+		*SK++ =	KT0[ (uint8) ( *RK >> 24 ) ] ^
+				KT1[ (uint8) ( *RK >> 16 ) ] ^
+				KT2[ (uint8) ( *RK >>  8 ) ] ^
+				KT3[ (uint8) ( *RK		 ) ]; RK++;
+	}
+
+	RK -= 8;
+
+	*SK++ =	*RK++;
+	*SK++ =	*RK++;
+	*SK++ =	*RK++;
+	*SK++ =	*RK++;
+
+	return(	0 );
+}
+
+/* AES 128-bit block encryption	routine	*/
+
+void aes_encrypt(aes_context *ctx, uint8 input[16],	uint8 output[16] )
+{
+	uint32 *RK,	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3;
+
+	RK = ctx->erk;
+	GET_UINT32(	X0,	input,	0 ); X0	^= RK[0];
+	GET_UINT32(	X1,	input,	4 ); X1	^= RK[1];
+	GET_UINT32(	X2,	input,	8 ); X2	^= RK[2];
+	GET_UINT32(	X3,	input, 12 ); X3	^= RK[3];
+
+#define	AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)		\
+{												\
+	RK += 4;									\
+												\
+	X0 = RK[0] ^ FT0[ (uint8) (	Y0 >> 24 ) ] ^	\
+				 FT1[ (uint8) (	Y1 >> 16 ) ] ^	\
+				 FT2[ (uint8) (	Y2 >>  8 ) ] ^	\
+				 FT3[ (uint8) (	Y3		 ) ];	\
+												\
+	X1 = RK[1] ^ FT0[ (uint8) (	Y1 >> 24 ) ] ^	\
+				 FT1[ (uint8) (	Y2 >> 16 ) ] ^	\
+				 FT2[ (uint8) (	Y3 >>  8 ) ] ^	\
+				 FT3[ (uint8) (	Y0		 ) ];	\
+												\
+	X2 = RK[2] ^ FT0[ (uint8) (	Y2 >> 24 ) ] ^	\
+				 FT1[ (uint8) (	Y3 >> 16 ) ] ^	\
+				 FT2[ (uint8) (	Y0 >>  8 ) ] ^	\
+				 FT3[ (uint8) (	Y1		 ) ];	\
+												\
+	X3 = RK[3] ^ FT0[ (uint8) (	Y3 >> 24 ) ] ^	\
+				 FT1[ (uint8) (	Y0 >> 16 ) ] ^	\
+				 FT2[ (uint8) (	Y1 >>  8 ) ] ^	\
+				 FT3[ (uint8) (	Y2		 ) ];	\
+}
+
+	AES_FROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 1 */
+	AES_FROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 2 */
+	AES_FROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 3 */
+	AES_FROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 4 */
+	AES_FROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 5 */
+	AES_FROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 6 */
+	AES_FROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 7 */
+	AES_FROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 8 */
+	AES_FROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 9 */
+
+	if(	ctx->nr	> 10 )
+	{
+		AES_FROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );	/* round 10	*/
+		AES_FROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );	/* round 11	*/
+	}
+
+	if(	ctx->nr	> 12 )
+	{
+		AES_FROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );	/* round 12	*/
+		AES_FROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );	/* round 13	*/
+	}
+
+	/* last	round */
+
+	RK += 4;
+
+	X0 = RK[0] ^ ( FSb[	(uint8)	( Y0 >>	24 ) ] << 24 ) ^
+				 ( FSb[	(uint8)	( Y1 >>	16 ) ] << 16 ) ^
+				 ( FSb[	(uint8)	( Y2 >>	 8 ) ] <<  8 ) ^
+				 ( FSb[	(uint8)	( Y3	   ) ]		 );
+
+	X1 = RK[1] ^ ( FSb[	(uint8)	( Y1 >>	24 ) ] << 24 ) ^
+				 ( FSb[	(uint8)	( Y2 >>	16 ) ] << 16 ) ^
+				 ( FSb[	(uint8)	( Y3 >>	 8 ) ] <<  8 ) ^
+				 ( FSb[	(uint8)	( Y0	   ) ]		 );
+
+	X2 = RK[2] ^ ( FSb[	(uint8)	( Y2 >>	24 ) ] << 24 ) ^
+				 ( FSb[	(uint8)	( Y3 >>	16 ) ] << 16 ) ^
+				 ( FSb[	(uint8)	( Y0 >>	 8 ) ] <<  8 ) ^
+				 ( FSb[	(uint8)	( Y1	   ) ]		 );
+
+	X3 = RK[3] ^ ( FSb[	(uint8)	( Y3 >>	24 ) ] << 24 ) ^
+				 ( FSb[	(uint8)	( Y0 >>	16 ) ] << 16 ) ^
+				 ( FSb[	(uint8)	( Y1 >>	 8 ) ] <<  8 ) ^
+				 ( FSb[	(uint8)	( Y2	   ) ]		 );
+
+	PUT_UINT32(	X0,	output,	 0 );
+	PUT_UINT32(	X1,	output,	 4 );
+	PUT_UINT32(	X2,	output,	 8 );
+	PUT_UINT32(	X3,	output,	12 );
+}
+
+/* AES 128-bit block decryption	routine	*/
+
+void aes_decrypt( aes_context *ctx,	uint8 input[16], uint8 output[16] )
+{
+	uint32 *RK,	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3;
+
+	RK = ctx->drk;
+
+	GET_UINT32(	X0,	input,	0 ); X0	^= RK[0];
+	GET_UINT32(	X1,	input,	4 ); X1	^= RK[1];
+	GET_UINT32(	X2,	input,	8 ); X2	^= RK[2];
+	GET_UINT32(	X3,	input, 12 ); X3	^= RK[3];
+
+#define	AES_RROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)		\
+{												\
+	RK += 4;									\
+												\
+	X0 = RK[0] ^ RT0[ (uint8) (	Y0 >> 24 ) ] ^	\
+				 RT1[ (uint8) (	Y3 >> 16 ) ] ^	\
+				 RT2[ (uint8) (	Y2 >>  8 ) ] ^	\
+				 RT3[ (uint8) (	Y1		 ) ];	\
+												\
+	X1 = RK[1] ^ RT0[ (uint8) (	Y1 >> 24 ) ] ^	\
+				 RT1[ (uint8) (	Y0 >> 16 ) ] ^	\
+				 RT2[ (uint8) (	Y3 >>  8 ) ] ^	\
+				 RT3[ (uint8) (	Y2		 ) ];	\
+												\
+	X2 = RK[2] ^ RT0[ (uint8) (	Y2 >> 24 ) ] ^	\
+				 RT1[ (uint8) (	Y1 >> 16 ) ] ^	\
+				 RT2[ (uint8) (	Y0 >>  8 ) ] ^	\
+				 RT3[ (uint8) (	Y3		 ) ];	\
+												\
+	X3 = RK[3] ^ RT0[ (uint8) (	Y3 >> 24 ) ] ^	\
+				 RT1[ (uint8) (	Y2 >> 16 ) ] ^	\
+				 RT2[ (uint8) (	Y1 >>  8 ) ] ^	\
+				 RT3[ (uint8) (	Y0		 ) ];	\
+}
+
+	AES_RROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 1 */
+	AES_RROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 2 */
+	AES_RROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 3 */
+	AES_RROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 4 */
+	AES_RROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 5 */
+	AES_RROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 6 */
+	AES_RROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 7 */
+	AES_RROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );		/* round 8 */
+	AES_RROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );		/* round 9 */
+
+	if(	ctx->nr	> 10 )
+	{
+		AES_RROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );	/* round 10	*/
+		AES_RROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );	/* round 11	*/
+	}
+
+	if(	ctx->nr	> 12 )
+	{
+		AES_RROUND(	X0,	X1,	X2,	X3,	Y0,	Y1,	Y2,	Y3 );	/* round 12	*/
+		AES_RROUND(	Y0,	Y1,	Y2,	Y3,	X0,	X1,	X2,	X3 );	/* round 13	*/
+	}
+
+	/* last	round */
+
+	RK += 4;
+
+	X0 = RK[0] ^ ( RSb[	(uint8)	( Y0 >>	24 ) ] << 24 ) ^
+				 ( RSb[	(uint8)	( Y3 >>	16 ) ] << 16 ) ^
+				 ( RSb[	(uint8)	( Y2 >>	 8 ) ] <<  8 ) ^
+				 ( RSb[	(uint8)	( Y1	   ) ]		 );
+
+	X1 = RK[1] ^ ( RSb[	(uint8)	( Y1 >>	24 ) ] << 24 ) ^
+				 ( RSb[	(uint8)	( Y0 >>	16 ) ] << 16 ) ^
+				 ( RSb[	(uint8)	( Y3 >>	 8 ) ] <<  8 ) ^
+				 ( RSb[	(uint8)	( Y2	   ) ]		 );
+
+	X2 = RK[2] ^ ( RSb[	(uint8)	( Y2 >>	24 ) ] << 24 ) ^
+				 ( RSb[	(uint8)	( Y1 >>	16 ) ] << 16 ) ^
+				 ( RSb[	(uint8)	( Y0 >>	 8 ) ] <<  8 ) ^
+				 ( RSb[	(uint8)	( Y3	   ) ]		 );
+
+	X3 = RK[3] ^ ( RSb[	(uint8)	( Y3 >>	24 ) ] << 24 ) ^
+				 ( RSb[	(uint8)	( Y2 >>	16 ) ] << 16 ) ^
+				 ( RSb[	(uint8)	( Y1 >>	 8 ) ] <<  8 ) ^
+				 ( RSb[	(uint8)	( Y0	   ) ]		 );
+
+	PUT_UINT32(	X0,	output,	 0 );
+	PUT_UINT32(	X1,	output,	 4 );
+	PUT_UINT32(	X2,	output,	 8 );
+	PUT_UINT32(	X3,	output,	12 );
+}
+
+/*
+* F(P, S, c, i) = U1 xor U2 xor ... Uc 
+* U1 = PRF(P, S || Int(i)) 
+* U2 = PRF(P, U1) 
+* Uc = PRF(P, Uc-1) 
+*/ 
+
+void F(char *password, unsigned char *ssid, int ssidlength, int iterations, int count, unsigned char *output) 
+{ 
+    unsigned char digest[36], digest1[SHA_DIGEST_LEN]; 
+    int i, j; 
+
+    /* U1 = PRF(P, S || int(i)) */ 
+    memcpy(digest, ssid, ssidlength); 
+    digest[ssidlength] = (unsigned char)((count>>24) & 0xff); 
+    digest[ssidlength+1] = (unsigned char)((count>>16) & 0xff); 
+    digest[ssidlength+2] = (unsigned char)((count>>8) & 0xff); 
+    digest[ssidlength+3] = (unsigned char)(count & 0xff); 
+    HMAC_SHA1(digest, ssidlength+4, (unsigned char*) password, (int) strlen(password), digest1); // for WPA update
+
+    /* output = U1 */ 
+    memcpy(output, digest1, SHA_DIGEST_LEN); 
+
+    for (i = 1; i < iterations; i++) 
+    { 
+        /* Un = PRF(P, Un-1) */ 
+        HMAC_SHA1(digest1, SHA_DIGEST_LEN, (unsigned char*) password, (int) strlen(password), digest); // for WPA update
+        memcpy(digest1, digest, SHA_DIGEST_LEN); 
+
+        /* output = output xor Un */ 
+        for (j = 0; j < SHA_DIGEST_LEN; j++) 
+        { 
+            output[j] ^= digest[j]; 
+        } 
+    } 
+}/* 
+* password - ascii string up to 63 characters in length 
+* ssid - octet string up to 32 octets 
+* ssidlength - length of ssid in octets 
+* output must be 40 octets in length and outputs 256 bits of key 
+*/ 
+int PasswordHash(char *password, unsigned char *ssid, int ssidlength, unsigned char *output) 
+{ 
+    if ((strlen(password) > 63) || (ssidlength > 32)) 
+        return 0; 
+
+    F(password, ssid, ssidlength, 4096, 1, output); 
+    F(password, ssid, ssidlength, 4096, 2, &output[SHA_DIGEST_LEN]); 
+    return 1; 
+}
+
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/md5.h linux-2.4.35.3-mct/drivers/usb/rt2570/md5.h
--- linux-2.4.35.3/drivers/usb/rt2570/md5.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/md5.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,83 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	md5.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#ifndef	__MD5_H__
+#define	__MD5_H__
+
+#define MD5_MAC_LEN 16
+
+typedef struct _MD5_CTX {
+    ULONG   Buf[4];             // buffers of four states
+	UCHAR   Input[64];          // input message
+	ULONG   LenInBitCount[2];   // length counter for input message, 0 up to 64 bits	                            
+}   MD5_CTX;
+
+VOID MD5Init(MD5_CTX *pCtx);
+VOID MD5Update(MD5_CTX *pCtx, UCHAR *pData, ULONG LenInBytes);
+VOID MD5Final(UCHAR Digest[16], MD5_CTX *pCtx);
+VOID MD5Transform(ULONG Buf[4], ULONG Mes[16]);
+
+void md5_mac(UCHAR *key, ULONG key_len, UCHAR *data, ULONG data_len, UCHAR *mac);
+void hmac_md5(UCHAR *key, ULONG key_len, UCHAR *data, ULONG data_len, UCHAR *mac);
+VOID SHATransform(ULONG Buf[5], ULONG Mes[20]);
+
+#define SHA_DIGEST_LEN 20
+#endif // __MD5_H__
+
+/******************************************************************************/
+#ifndef	_AES_H
+#define	_AES_H
+
+#ifndef	uint8
+#define	uint8  unsigned	char
+#endif
+
+#ifndef	uint32
+#define	uint32 unsigned	long int
+#endif
+
+typedef	struct
+{
+	uint32 erk[64];		/* encryption round	keys */
+	uint32 drk[64];		/* decryption round	keys */
+	int	nr;				/* number of rounds	*/
+}
+aes_context;
+
+int	 aes_set_key( aes_context *ctx,	uint8 *key,	int	nbits );
+void aes_encrypt( aes_context *ctx,	uint8 input[16], uint8 output[16] );
+void aes_decrypt( aes_context *ctx,	uint8 input[16], uint8 output[16] );
+
+#endif /* aes.h	*/
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/mlme.c linux-2.4.35.3-mct/drivers/usb/rt2570/mlme.c
--- linux-2.4.35.3/drivers/usb/rt2570/mlme.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/mlme.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,4506 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	mlme.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ *	MathiasK	09-07-2005	kmalloc ATOMIC fixes
+ *	RobinC		31-08-2005	Block mlme in MONITOR mode to keep from sending probe requests
+ ***************************************************************************/
+
+#include "rt_config.h"
+                                  //  1  2   5.5   11   6    9    12   18   24   36   48   54   72  100
+CHAR RssiSafeLevelForTxRate[] ={  -92, -91, -90, -87, -88, -86, -85, -83, -81, -78, -72, -71, -40, -40 };
+
+                                  //  1      2       5.5      11  
+UCHAR Phy11BNextRateDownward[] = {RATE_1, RATE_1,   RATE_2,  RATE_5_5};
+UCHAR Phy11BNextRateUpward[]   = {RATE_2, RATE_5_5, RATE_11, RATE_11};
+
+                                  //  1      2       5.5      11        6        9        12      18       24       36       48       54
+UCHAR Phy11BGNextRateDownward[]= {RATE_1, RATE_1,   RATE_2,  RATE_5_5,RATE_11,  RATE_6,  RATE_11, RATE_12, RATE_18, RATE_24, RATE_36, RATE_48};
+UCHAR Phy11BGNextRateUpward[]  = {RATE_2, RATE_5_5, RATE_11, RATE_12, RATE_9,   RATE_12, RATE_18, RATE_24, RATE_36, RATE_48, RATE_54, RATE_54};
+
+                                  //  1      2       5.5      11        6        9        12      18       24       36       48       54
+UCHAR Phy11ANextRateDownward[] = {RATE_6, RATE_6,   RATE_6,  RATE_6,  RATE_6,   RATE_6,  RATE_9,  RATE_12, RATE_18, RATE_24, RATE_36, RATE_48};
+UCHAR Phy11ANextRateUpward[]   = {RATE_9, RATE_9,   RATE_9,  RATE_9,  RATE_9,   RATE_12, RATE_18, RATE_24, RATE_36, RATE_48, RATE_54, RATE_54};
+
+// 2560D and after has implemented ASIC-based OFDM rate switching, but not
+// 2560C and before. thus software use different PER for rate switching
+//                          RATE_1,  2, 5.5, 11,  6,  9, 12, 18, 24, 36, 48, 54
+USHORT NewRateUpPER[]   = {    40,  40,  35, 20, 20, 20, 20, 16, 10, 16, 10,  6 }; // in percentage
+USHORT NewRateDownPER[] = {    50,  50,  45, 45, 35, 35, 35, 35, 25, 25, 25, 13 }; // in percentage
+
+USHORT OldRateUpPER[]   = {    40,  40,  40, 40, 30, 30, 30, 30, 20, 20, 10, 10 }; // in percentage
+USHORT OldRateDownPER[] = {    45,  45,  45, 45, 35, 35, 35, 35, 25, 25, 25, 12 }; // in percentage
+    
+UCHAR RateIdToMbps[] = { 1, 2, 5, 11, 6, 9, 12, 18, 24, 36, 48, 54, 72, 100};
+USHORT RateIdTo500Kbps[] = { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108, 144, 200};
+    
+RTMP_RF_REGS RF2522RegTable[] = {
+//      ch   R1          R2          R3(TX0~4=0) R4
+        {1,  0x94002050, 0x940c1fda, 0x94000101, 0},
+        {2,  0x94002050, 0x940c1fee, 0x94000101, 0},
+        {3,  0x94002050, 0x940c2002, 0x94000101, 0},
+        {4,  0x94002050, 0x940c2016, 0x94000101, 0},
+        {5,  0x94002050, 0x940c202a, 0x94000101, 0},
+        {6,  0x94002050, 0x940c203e, 0x94000101, 0},
+        {7,  0x94002050, 0x940c2052, 0x94000101, 0},
+        {8,  0x94002050, 0x940c2066, 0x94000101, 0},
+        {9,  0x94002050, 0x940c207a, 0x94000101, 0},
+        {10, 0x94002050, 0x940c208e, 0x94000101, 0},
+        {11, 0x94002050, 0x940c20a2, 0x94000101, 0},
+        {12, 0x94002050, 0x940c20b6, 0x94000101, 0},
+        {13, 0x94002050, 0x940c20ca, 0x94000101, 0},
+        {14, 0x94002050, 0x940c20fa, 0x94000101, 0}
+};
+#define	NUM_OF_2522_CHNL	(sizeof(RF2522RegTable) / sizeof(RTMP_RF_REGS))
+
+RTMP_RF_REGS RF2523RegTable[] = {
+//      ch   R1          R2          R3(TX0~4=0) R4
+        {1,  0x94022010, 0x94000c9e, 0x940e0111, 0x94000a1b},
+        {2,  0x94022010, 0x94000ca2, 0x940e0111, 0x94000a1b},
+        {3,  0x94022010, 0x94000ca6, 0x940e0111, 0x94000a1b},
+        {4,  0x94022010, 0x94000caa, 0x940e0111, 0x94000a1b},
+        {5,  0x94022010, 0x94000cae, 0x940e0111, 0x94000a1b},
+        {6,  0x94022010, 0x94000cb2, 0x940e0111, 0x94000a1b},
+        {7,  0x94022010, 0x94000cb6, 0x940e0111, 0x94000a1b},
+        {8,  0x94022010, 0x94000cba, 0x940e0111, 0x94000a1b},
+        {9,  0x94022010, 0x94000cbe, 0x940e0111, 0x94000a1b},
+        {10, 0x94022010, 0x94000d02, 0x940e0111, 0x94000a1b},
+        {11, 0x94022010, 0x94000d06, 0x940e0111, 0x94000a1b},
+        {12, 0x94022010, 0x94000d0a, 0x940e0111, 0x94000a1b},
+        {13, 0x94022010, 0x94000d0e, 0x940e0111, 0x94000a1b},
+        {14, 0x94022010, 0x94000d1a, 0x940e0111, 0x94000a03}
+};
+#define	NUM_OF_2523_CHNL	(sizeof(RF2523RegTable) / sizeof(RTMP_RF_REGS))
+
+RTMP_RF_REGS RF2524RegTable[] = {
+//      ch   R1          R2          R3(TX0~4=0) R4
+        {1,  0x94032020, 0x94000c9e, 0x94000101, 0x94000a1b},
+        {2,  0x94032020, 0x94000ca2, 0x94000101, 0x94000a1b},
+        {3,  0x94032020, 0x94000ca6, 0x94000101, 0x94000a1b},
+        {4,  0x94032020, 0x94000caa, 0x94000101, 0x94000a1b},
+        {5,  0x94032020, 0x94000cae, 0x94000101, 0x94000a1b},
+        {6,  0x94032020, 0x94000cb2, 0x94000101, 0x94000a1b},
+        {7,  0x94032020, 0x94000cb6, 0x94000101, 0x94000a1b},
+        {8,  0x94032020, 0x94000cba, 0x94000101, 0x94000a1b},
+        {9,  0x94032020, 0x94000cbe, 0x94000101, 0x94000a1b},
+        {10, 0x94032020, 0x94000d02, 0x94000101, 0x94000a1b},
+        {11, 0x94032020, 0x94000d06, 0x94000101, 0x94000a1b},
+        {12, 0x94032020, 0x94000d0a, 0x94000101, 0x94000a1b},
+        {13, 0x94032020, 0x94000d0e, 0x94000101, 0x94000a1b},
+        {14, 0x94032020, 0x94000d1a, 0x94000101, 0x94000a03}
+};
+#define	NUM_OF_2524_CHNL	(sizeof(RF2524RegTable) / sizeof(RTMP_RF_REGS))
+            
+RTMP_RF_REGS_1 RF2525RegTable[] = {
+//      ch   TempR2		 R1          R2          R3(TX0~4=0) R4
+        {1,  0x94080cbe, 0x94022020, 0x94080c9e, 0x94060111, 0x94000a1b}, // {1,  0x94022010, 0x9408062e, 0x94060111, 0x94000a23}, 
+        {2,  0x94080d02, 0x94022020, 0x94080ca2, 0x94060111, 0x94000a1b},
+        {3,  0x94080d06, 0x94022020, 0x94080ca6, 0x94060111, 0x94000a1b},
+        {4,  0x94080d0a, 0x94022020, 0x94080caa, 0x94060111, 0x94000a1b},
+        {5,  0x94080d0e, 0x94022020, 0x94080cae, 0x94060111, 0x94000a1b},
+        {6,  0x94080d12, 0x94022020, 0x94080cb2, 0x94060111, 0x94000a1b},
+        {7,  0x94080d16, 0x94022020, 0x94080cb6, 0x94060111, 0x94000a1b},
+        {8,  0x94080d1a, 0x94022020, 0x94080cba, 0x94060111, 0x94000a1b},
+        {9,  0x94080d1e, 0x94022020, 0x94080cbe, 0x94060111, 0x94000a1b},
+        {10, 0x94080d22, 0x94022020, 0x94080d02, 0x94060111, 0x94000a1b},
+        {11, 0x94080d26, 0x94022020, 0x94080d06, 0x94060111, 0x94000a1b}, // {11, 0x94022010, 0x94080682, 0x94060111, 0x94000a23}, 
+        {12, 0x94080d2a, 0x94022020, 0x94080d0a, 0x94060111, 0x94000a1b},
+        {13, 0x94080d2e, 0x94022020, 0x94080d0e, 0x94060111, 0x94000a1b}, // {13, 0x94022010, 0x94080686, 0x94060111, 0x94000a23}, 
+        {14, 0x94080d3a, 0x94022020, 0x94080d1a, 0x94060111, 0x94000a03}
+};
+#define	NUM_OF_2525_CHNL	(sizeof(RF2525RegTable) / sizeof(RTMP_RF_REGS_1))
+
+RTMP_RF_REGS_1 RF2525eRegTable[] = {
+// using 10 Mhz reference clock
+//      ch   TempR2		 R1          R2          R3(TX0~4=0) R4
+        {1,  0x940008aa, 0x94022010, 0x9400089a, 0x94060111, 0x94000e1b},
+        {2,  0x940008ae, 0x94022010, 0x9400089e, 0x94060111, 0x94000e07},
+        {3,  0x940008ae, 0x94022010, 0x9400089e, 0x94060111, 0x94000e1b},
+        {4,  0x940008b2, 0x94022010, 0x940008a2, 0x94060111, 0x94000e07},
+        {5,  0x940008b2, 0x94022010, 0x940008a2, 0x94060111, 0x94000e1b},
+        {6,  0x940008b6, 0x94022010, 0x940008a6, 0x94060111, 0x94000e07},
+        {7,  0x940008b6, 0x94022010, 0x940008a6, 0x94060111, 0x94000e1b},
+        {8,  0x940008ba, 0x94022010, 0x940008aa, 0x94060111, 0x94000e07},
+        {9,  0x940008ba, 0x94022010, 0x940008aa, 0x94060111, 0x94000e1b},
+        {10, 0x940008be, 0x94022010, 0x940008ae, 0x94060111, 0x94000e07},
+        {11, 0x940008b7, 0x94022010, 0x940008ae, 0x94060111, 0x94000e1b}, 
+        {12, 0x94000902, 0x94022010, 0x940008b2, 0x94060111, 0x94000e07},
+        {13, 0x94000902, 0x94022010, 0x940008b2, 0x94060111, 0x94000e1b},
+        {14, 0x94000906, 0x94022010, 0x940008b6, 0x94060111, 0x94000e23}
+};
+#define	NUM_OF_2525E_CHNL	(sizeof(RF2525eRegTable) / sizeof(RTMP_RF_REGS_1))
+
+RTMP_RF_REGS RF5222RegTable[] = {
+//      ch   R1          R2          R3(TX0~4=0) R4
+        {1,  0x94022020, 0x94001136, 0x94000101, 0x94000a0b},
+        {2,  0x94022020, 0x9400113a, 0x94000101, 0x94000a0b},
+        {3,  0x94022020, 0x9400113e, 0x94000101, 0x94000a0b},
+        {4,  0x94022020, 0x94001182, 0x94000101, 0x94000a0b},
+        {5,  0x94022020, 0x94001186, 0x94000101, 0x94000a0b},
+        {6,  0x94022020, 0x9400118a, 0x94000101, 0x94000a0b},
+        {7,  0x94022020, 0x9400118e, 0x94000101, 0x94000a0b},
+        {8,  0x94022020, 0x94001192, 0x94000101, 0x94000a0b},
+        {9,  0x94022020, 0x94001196, 0x94000101, 0x94000a0b},
+        {10, 0x94022020, 0x9400119a, 0x94000101, 0x94000a0b},
+        {11, 0x94022020, 0x9400119e, 0x94000101, 0x94000a0b},
+        {12, 0x94022020, 0x940011a2, 0x94000101, 0x94000a0b},
+        {13, 0x94022020, 0x940011a6, 0x94000101, 0x94000a0b},
+        {14, 0x94022020, 0x940011ae, 0x94000101, 0x94000a1b},
+
+        // still lack of MMAC(Japan) ch 34,38,42,46
+        
+        {36, 0x94022010, 0x94018896, 0x94000101, 0x94000a1f},
+        {40, 0x94022010, 0x9401889a, 0x94000101, 0x94000a1f},
+        {44, 0x94022010, 0x9401889e, 0x94000101, 0x94000a1f},
+        {48, 0x94022010, 0x940188a2, 0x94000101, 0x94000a1f},
+        {52, 0x94022010, 0x940188a6, 0x94000101, 0x94000a1f},
+        {66, 0x94022010, 0x940188aa, 0x94000101, 0x94000a1f},
+        {60, 0x94022010, 0x940188ae, 0x94000101, 0x94000a1f},
+        {64, 0x94022010, 0x940188b2, 0x94000101, 0x94000a1f},
+        
+        {100, 0x94022010, 0x94008802, 0x94000101, 0x94000a0f},
+        {104, 0x94022010, 0x94008806, 0x94000101, 0x94000a0f},
+        {108, 0x94022010, 0x9400880a, 0x94000101, 0x94000a0f},
+        {112, 0x94022010, 0x9400880e, 0x94000101, 0x94000a0f},
+        {116, 0x94022010, 0x94008812, 0x94000101, 0x94000a0f},
+        {120, 0x94022010, 0x94008816, 0x94000101, 0x94000a0f},
+        {124, 0x94022010, 0x9400881a, 0x94000101, 0x94000a0f},
+        {128, 0x94022010, 0x9400881e, 0x94000101, 0x94000a0f},
+        {132, 0x94022010, 0x94008822, 0x94000101, 0x94000a0f},
+        {136, 0x94022010, 0x94008826, 0x94000101, 0x94000a0f},
+        {140, 0x94022010, 0x9400882a, 0x94000101, 0x94000a0f},
+        
+        {149, 0x94022020, 0x940090a6, 0x94000101, 0x94000a07},
+        {153, 0x94022020, 0x940090ae, 0x94000101, 0x94000a07},
+        {157, 0x94022020, 0x940090b6, 0x94000101, 0x94000a07},
+        {161, 0x94022020, 0x940090be, 0x94000101, 0x94000a07}
+};
+#define	NUM_OF_5222_CHNL	(sizeof(RF5222RegTable) / sizeof(RTMP_RF_REGS))
+
+
+/*
+	==========================================================================
+	Description:
+		initialize the MLME task and its data structure (queue, spinlock, 
+		timer, state machines).
+	Return:
+		always return NDIS_STATUS_SUCCESS
+	==========================================================================
+*/
+NDIS_STATUS MlmeInit(
+	IN PRT2570ADAPTER pAd) 
+{
+	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
+
+	DBGPRINT(RT_DEBUG_TRACE,"--> MLME Initialize\n");
+	
+	do 
+	{
+		Status = MlmeQueueInit(&pAd->Mlme.Queue);
+		if(Status != NDIS_STATUS_SUCCESS) 
+		{
+			break;
+		}
+
+		// Initialize Mlme Memory Handler
+		// Allocate 20 nonpaged memory pool which size are MAX_LEN_OF_MLME_BUFFER for use
+		Status = MlmeInitMemoryHandler(pAd, 20, MAX_LEN_OF_MLME_BUFFER);
+
+		if(Status != NDIS_STATUS_SUCCESS) 
+		{
+			break;
+		}
+
+		pAd->Mlme.Running = FALSE;
+		NdisAllocateSpinLock(&pAd->Mlme.TaskLock);
+
+		// initialize the two tables
+		// MacTableInit(pAd);
+		BssTableInit(&pAd->PortCfg.BssTab);
+		// init state machines
+		ASSERT(ASSOC_FUNC_SIZE == MAX_ASSOC_MSG * MAX_ASSOC_STATE);
+		AssocStateMachineInit(pAd, &pAd->Mlme.AssocMachine, pAd->Mlme.AssocFunc);
+		
+		ASSERT(AUTH_FUNC_SIZE == MAX_AUTH_MSG * MAX_AUTH_STATE);
+		AuthStateMachineInit(pAd, &pAd->Mlme.AuthMachine, pAd->Mlme.AuthFunc);
+		
+		ASSERT(AUTH_RSP_FUNC_SIZE == MAX_AUTH_RSP_MSG * MAX_AUTH_RSP_STATE);
+		AuthRspStateMachineInit(pAd, &pAd->Mlme.AuthRspMachine, pAd->Mlme.AuthRspFunc);
+
+		ASSERT(WPA_PSK_FUNC_SIZE == MAX_WPA_PSK_MSG * MAX_WPA_PSK_STATE);
+		WpaPskStateMachineInit(pAd,&pAd->Mlme.WpaPskMachine,pAd->Mlme.WpaPskFunc);
+
+		ASSERT(SYNC_FUNC_SIZE == MAX_SYNC_MSG * MAX_SYNC_STATE);
+		SyncStateMachineInit(pAd, &pAd->Mlme.SyncMachine, pAd->Mlme.SyncFunc);
+
+		// Since we are using switch/case to implement it, the init is different from the above 
+		// state machine init
+		MlmeCntlInit(pAd, &pAd->Mlme.CntlMachine, NULL);
+
+		RTMPInitTimer(pAd, &pAd->Mlme.PeriodicTimer, &MlmePeriodicExec);
+		//pAd->Mlme.PeriodicTimer.data = (unsigned long)pAd;
+		//pAd->Mlme.PeriodicTimer.function = &MlmePeriodicExec;
+		pAd->Mlme.PeriodicTimer.Timer.expires = jiffies + MLME_TASK_EXEC_INTV;
+		// delay first mlme timer
+		RTMPSetTimer(pAd, &pAd->Mlme.PeriodicTimer, 2*MLME_TASK_EXEC_INTV);
+
+		if (pAd->PortCfg.LedMode == LED_MODE_TXRX_ACTIVITY)
+		{
+			RTMPInitTimer(pAd, &pAd->PortCfg.LedCntl.BlinkTimer, &AsicLedPeriodicExec);
+			//pAd->PortCfg.LedCntl.BlinkTimer.data = (unsigned long)pAd;
+			//pAd->PortCfg.LedCntl.BlinkTimer.function = &AsicLedPeriodicExec;
+			pAd->PortCfg.LedCntl.BlinkTimer.Timer.expires = jiffies + (70 * HZ)/1000;
+			RTMPSetTimer(pAd, &pAd->PortCfg.LedCntl.BlinkTimer, 70);
+		}
+	
+	} while (FALSE);
+
+	DBGPRINT(RT_DEBUG_TRACE,"<-- MLME Initialize\n");
+
+	return Status;
+}
+
+
+/*
+    ==========================================================================
+    Description:
+        Destructor of MLME (Destroy queue, state machine, spin lock and timer)
+    Parameters:
+        Adapter - NIC Adapter pointer
+    Post:
+        The MLME task will no longer work properly
+        
+	IRQL = PASSIVE_LEVEL
+
+    ==========================================================================
+ */
+VOID MlmeHalt(
+    IN PRT2570ADAPTER pAd) 
+{
+
+    DBGPRINT(RT_DEBUG_TRACE, "==> MlmeHalt\n");
+
+	// Cancel pending timers
+	RTMPCancelTimer(&pAd->Mlme.AssocAux.AssocTimer);
+	RTMPCancelTimer(&pAd->Mlme.AssocAux.ReassocTimer);
+	RTMPCancelTimer(&pAd->Mlme.AssocAux.DisassocTimer);
+	RTMPCancelTimer(&pAd->Mlme.AuthAux.AuthTimer);
+	RTMPCancelTimer(&pAd->Mlme.SyncAux.BeaconTimer);
+	RTMPCancelTimer(&pAd->Mlme.SyncAux.ScanTimer);
+	RTMPCancelTimer(&pAd->Mlme.PeriodicTimer);
+	if ((pAd->PortCfg.LedMode == LED_MODE_TXRX_ACTIVITY)||(pAd->PortCfg.LedMode == LED_MODE_ALPHA))
+		RTMPCancelTimer(&pAd->PortCfg.LedCntl.BlinkTimer);
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS))
+	{
+		ASIC_LED_ACT_OFF(pAd);
+	}
+
+	// for timer callback routine to finish.
+	NdisMSleep(1000);
+
+	MlmeQueueDestroy(&pAd->Mlme.Queue);
+	StateMachineDestroy(&pAd->Mlme.AssocMachine);
+	StateMachineDestroy(&pAd->Mlme.AuthMachine);
+	StateMachineDestroy(&pAd->Mlme.AuthRspMachine);
+	StateMachineDestroy(&pAd->Mlme.SyncMachine);
+	StateMachineDestroy(&pAd->Mlme.WpaPskMachine);
+	//    StateMachineDestroy(&pAd->Mlme.CntlMachine);
+	// no need free spinlock of pAd->Mlme.TaskLock
+
+	MlmeFreeMemoryHandler(pAd); //Free MLME memory handler
+
+	DBGPRINT(RT_DEBUG_TRACE, "<== MlmeHalt\n");
+}
+
+VOID MlmeHandler(
+    IN PRT2570ADAPTER pAd) 
+{
+	MLME_QUEUE_ELEM        *Elem = NULL;
+	// Only accept MLME and Frame from peer side, no other (control/data) frame should
+	// get into this state machine
+
+	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
+	if(pAd->Mlme.Running) 
+	{
+	    NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
+	    return;
+	} 
+	else 
+	{
+	    pAd->Mlme.Running = TRUE;
+	}
+	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
+
+	while (!MlmeQueueEmpty(&pAd->Mlme.Queue)) 
+	{
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS) ||
+			RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS) ||
+			RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "Device Halted or Removed or MlmeRest, exit MlmeHandler! (queue num = %d)\n", pAd->Mlme.Queue.Num);
+			break;
+		}
+		//From message type, determine which state machine I should drive
+		if (MlmeDequeue(&pAd->Mlme.Queue, &Elem) && pAd->PortCfg.BssType!=BSS_MONITOR) 
+		{
+			// if dequeue success
+			switch (Elem->Machine) 
+			{
+				case ASSOC_STATE_MACHINE:
+				    StateMachinePerformAction(pAd, &pAd->Mlme.AssocMachine, Elem);
+				    break;
+				case AUTH_STATE_MACHINE:
+				    StateMachinePerformAction(pAd, &pAd->Mlme.AuthMachine, Elem);
+				    break;
+				case AUTH_RSP_STATE_MACHINE:
+				    StateMachinePerformAction(pAd, &pAd->Mlme.AuthRspMachine, Elem);
+				    break;
+				case SYNC_STATE_MACHINE:
+				    StateMachinePerformAction(pAd, &pAd->Mlme.SyncMachine, Elem);
+				    break;
+				case MLME_CNTL_STATE_MACHINE:
+				    MlmeCntlMachinePerformAction(pAd, &pAd->Mlme.CntlMachine, Elem);
+				    break;
+				case WPA_PSK_STATE_MACHINE:
+					StateMachinePerformAction(pAd, &pAd->Mlme.WpaPskMachine, Elem);
+					break;
+				default:
+				    DBGPRINT(RT_DEBUG_TRACE, "ERROR: Illegal machine %d in MlmeHandler()\n",Elem->Machine);
+				    break;
+			} // end of switch
+
+			// free MLME element
+			Elem->Occupied = FALSE;
+			Elem->MsgLen = 0;
+            
+		}
+		else
+		{
+			DBGPRINT(RT_DEBUG_ERROR, "ERROR: empty Elem in MlmeQueue\n");
+		}
+	}
+
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS))
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "MlmeHandler, Reset Mlme! (queue num = %d)\n", pAd->Mlme.Queue.Num);
+		MlmeQueueDestroy(&pAd->Mlme.Queue);
+		// Cancel all timer events
+		// Be careful to cancel new added timer
+		RTMPCancelTimer(&pAd->Mlme.AssocAux.AssocTimer);
+		RTMPCancelTimer(&pAd->Mlme.AssocAux.ReassocTimer);
+		RTMPCancelTimer(&pAd->Mlme.AssocAux.DisassocTimer);
+		RTMPCancelTimer(&pAd->Mlme.AuthAux.AuthTimer);
+		//    RTMPCancelTimer(&pAd->Mlme.AuthRspAux.AuthRspTimer, &Cancelled);
+		RTMPCancelTimer(&pAd->Mlme.SyncAux.BeaconTimer);
+		RTMPCancelTimer(&pAd->Mlme.SyncAux.ScanTimer);
+		// Set all state machines back IDLE
+		pAd->Mlme.CntlMachine.CurrState    = CNTL_IDLE;
+		pAd->Mlme.AssocMachine.CurrState   = ASSOC_IDLE;
+		pAd->Mlme.AuthMachine.CurrState    = AUTH_REQ_IDLE;
+		pAd->Mlme.AuthRspMachine.CurrState = AUTH_RSP_IDLE;
+		pAd->Mlme.SyncMachine.CurrState    = SYNC_IDLE;
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS))
+			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS);
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS))
+			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS);
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
+
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS);   
+	}
+
+	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
+	pAd->Mlme.Running = FALSE;
+	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
+
+}
+
+
+VOID MlmeSuspend(
+    IN PRT2570ADAPTER pAd) 
+{
+    MLME_QUEUE_ELEM		*Elem = NULL;
+
+	DBGPRINT(RT_DEBUG_TRACE, "==>MlmeSuspend\n");
+
+	// Cancel pending timers
+	RTMPCancelTimer(&pAd->Mlme.AssocAux.AssocTimer);
+	RTMPCancelTimer(&pAd->Mlme.AssocAux.ReassocTimer);
+	RTMPCancelTimer(&pAd->Mlme.AssocAux.DisassocTimer);
+	RTMPCancelTimer(&pAd->Mlme.AuthAux.AuthTimer);
+	// RTMPCancelTimer(&pAd->Mlme.AuthRspAux.AuthRspTimer, &Cancelled);
+	RTMPCancelTimer(&pAd->Mlme.SyncAux.BeaconTimer);
+	RTMPCancelTimer(&pAd->Mlme.SyncAux.ScanTimer);
+
+	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
+	if(pAd->Mlme.Running) 
+	{
+	    NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
+	    return;
+	} 
+	else 
+	{
+	    pAd->Mlme.Running = TRUE;
+	}
+	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
+
+	// Remove all Mlme queues elements
+	while (!MlmeQueueEmpty(&pAd->Mlme.Queue)) 
+	{
+		//From message type, determine which state machine I should drive
+		if (MlmeDequeue(&pAd->Mlme.Queue, &Elem)) 
+		{
+		    // free MLME element
+		    Elem->Occupied = FALSE;
+		    Elem->MsgLen = 0;
+		    
+		}
+		else 
+		{
+		    DBGPRINT(RT_DEBUG_ERROR, "ERROR: empty Elem in MlmeQueue\n");
+		}
+	}
+	
+	// Remove running state
+	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
+	pAd->Mlme.Running = FALSE;
+	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
+
+	RTUSBCleanUpMLMEWaitQueue(pAd);
+	RTUSBCleanUpMLMEBulkOutQueue(pAd);
+
+	// Set all state machines back IDLE
+	pAd->Mlme.CntlMachine.CurrState    = CNTL_IDLE;
+	pAd->Mlme.AssocMachine.CurrState   = ASSOC_IDLE;
+	pAd->Mlme.AuthMachine.CurrState    = AUTH_REQ_IDLE;
+	pAd->Mlme.AuthRspMachine.CurrState = AUTH_RSP_IDLE;
+	pAd->Mlme.SyncMachine.CurrState    = SYNC_IDLE;
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS);//steven:for test
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS);//steven:for test
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);//steven:for test
+
+	DBGPRINT(RT_DEBUG_TRACE, "<==MlmeSuspend\n");
+}
+
+VOID	MlmeResume(
+    IN	PRT2570ADAPTER	pAd)
+{
+    DBGPRINT(RT_DEBUG_TRACE, "==>MlmeResume\n");
+
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS);//steven:for test
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS);//steven:for test
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);//steven:for test
+	// Set all state machines back IDLE
+	pAd->Mlme.CntlMachine.CurrState    = CNTL_IDLE;
+	pAd->Mlme.AssocMachine.CurrState   = ASSOC_IDLE;
+	pAd->Mlme.AuthMachine.CurrState    = AUTH_REQ_IDLE;
+	pAd->Mlme.AuthRspMachine.CurrState = AUTH_RSP_IDLE;
+	pAd->Mlme.SyncMachine.CurrState    = SYNC_IDLE;
+
+	DBGPRINT(RT_DEBUG_TRACE, "<==MlmeResume\n");
+}
+
+/*
+    ==========================================================================
+    Description:
+        This routine is executed periodically to -
+        1. Decide if it's a right time to turn on PwrMgmt bit of all 
+           outgoiing frames
+        2. Calculate ChannelQuality based on statistics of the last
+           period, so that TX rate won't toggling very frequently between a 
+           successful TX and a failed TX.
+        3. If the calculated ChannelQuality indicated current connection not 
+           healthy, then a ROAMing attempt is tried here.
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+#define ADHOC_BEACON_LOST_TIME      10000  // 10 sec
+VOID MlmePeriodicExec(
+    IN	unsigned long data)
+{
+	PRT2570ADAPTER pAd = (PRT2570ADAPTER)data;
+	ULONG Now32;
+	// Timer need to reset every time, so using do-while loop
+	do
+	{
+		if ((RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) ||
+			(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) ||
+			(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS)) ||
+			(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_TRACE, "<---MlmePeriodicExec\n");
+			break;
+		}
+
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_PENDING))
+		{
+			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_PENDING);
+			NdisMIndicateStatus(pAd->AdapterHandle, NDIS_STATUS_MEDIA_DISCONNECT, (PVOID)NULL, 0);
+			NdisMIndicateStatusComplete(pAd->AdapterHandle);			
+			DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_DISCONNECT Event B!\n");
+		}
+
+		if (pAd->PortCfg.bHardwareRadio == TRUE)
+		{
+			RTUSBEnqueueInternalCmd(pAd, RT_OID_CHECK_GPIO);
+		}
+
+		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
+		{
+			DBGPRINT_RAW(RT_DEBUG_TRACE, "<---RADIO OFF\n");
+			break;
+		}
+		
+		if (pAd->RalinkCounters.MgmtRingFullCount >= 2)
+		{
+			PCmdQElmt	cmdqelmt;
+
+			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS);
+			
+			NdisAcquireSpinLock(&pAd->CmdQLock);
+			while (pAd->CmdQ.size > 0)
+			{
+				RTUSBDequeueCmd(&pAd->CmdQ, &cmdqelmt);
+				if (cmdqelmt->CmdFromNdis == TRUE)
+				{
+					if ((cmdqelmt->command != OID_802_11_BSSID_LIST_SCAN) &&
+						(cmdqelmt->command != RT_OID_802_11_BSSID) &&
+						(cmdqelmt->command != OID_802_11_SSID) &&
+						(cmdqelmt->command != OID_802_11_DISASSOCIATE))
+					{
+#if 0
+						if (cmdqelmt->SetOperation)
+							NdisMSetInformationComplete(pAd->AdapterHandle, NDIS_STATUS_NOT_ACCEPTED);
+						else
+							NdisMQueryInformationComplete(pAd->AdapterHandle, NDIS_STATUS_NOT_ACCEPTED);
+#endif
+					}
+
+					if ((cmdqelmt->command != RT_OID_SINGLE_READ_MAC) &&
+						(cmdqelmt->command != RT_OID_MULTI_READ_MAC) &&
+						(cmdqelmt->command != RT_OID_VENDOR_READ_BBP) &&
+						(cmdqelmt->command != RT_OID_USB_VENDOR_EEPROM_READ))
+					{
+						if (cmdqelmt->buffer != NULL)
+							kfree(cmdqelmt->buffer);
+					}
+
+					kfree(cmdqelmt);
+				}
+				else
+					cmdqelmt->InUse = FALSE;
+			}
+			NdisReleaseSpinLock(&pAd->CmdQLock);
+			
+			RTUSBEnqueueInternalCmd(pAd, RT_OID_RESET_FROM_ERROR);
+
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "<---MlmePeriodicExec (Mgmt Ring Full)\n");
+			break;
+		}
+		pAd->RalinkCounters.MgmtRingFullCount = 0;
+
+		if ((RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS)) || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) || (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS)))
+		{
+			break;//steven:for test
+		}
+		pAd->Mlme.PeriodicRound ++;
+		RTUSBEnqueueInternalCmd(pAd, RT_OID_PERIODIC_EXECUT);
+		Now32 = jiffies;
+		if (INFRA_ON(pAd))
+		{
+			// Check for EAPOL frame sent after MIC countermeasures
+			if (pAd->PortCfg.MicErrCnt >= 3)
+			{
+				MLME_DISASSOC_REQ_STRUCT	DisassocReq;
+				
+				// disassoc from current AP first
+				DBGPRINT(RT_DEBUG_TRACE, "MLME - disassociate with current AP after sending second continuous EAPOL frame\n");
+				DisassocParmFill(pAd, &DisassocReq, &pAd->PortCfg.Bssid, REASON_MIC_FAILURE);
+				MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
+					sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+
+				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+				pAd->PortCfg.bBlockAssoc = TRUE;
+			}
+			else if ((pAd->PortCfg.LastBeaconRxTime + BEACON_LOST_TIME < Now32) )
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "BEACON lost for more than %d msec, let CQI = 0\n", BEACON_LOST_TIME);
+				pAd->Mlme.ChannelQuality = 0;
+				
+				// Lost AP, send disconnect & link down event
+				RTUSBEnqueueInternalCmd(pAd, RT_OID_LINK_DOWN);
+			}
+			else
+			{
+				atomic_set(&(pAd->PortCfg.DataPacketsFromAP), 0);	
+				MlmeCheckForPsmChange(pAd);
+			}
+		}
+		else if (ADHOC_ON(pAd))
+		{
+			// If all peers leave, and this STA becomes the last one in this IBSS, then change MediaState
+			// to DISCONNECTED. But still holding this IBSS (i.e. sending BEACON) so that other STAs can
+			// join later.
+			if ((pAd->PortCfg.LastBeaconRxTime + ADHOC_BEACON_LOST_TIME < Now32) &&
+				(pAd->MediaState == NdisMediaStateConnected))
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "MMCHK - excessive BEACON lost, last STA in this IBSS, MediaState=Disconnected\n");
+				
+				pAd->MediaState = NdisMediaStateDisconnected;
+				NdisMIndicateStatus(pAd->AdapterHandle, NDIS_STATUS_MEDIA_DISCONNECT, (PVOID)NULL, 0);
+				NdisMIndicateStatusComplete(pAd->AdapterHandle);
+				
+				// clean up previous SCAN result, add current BSS back to table if any
+				BssTableDeleteEntry(&pAd->PortCfg.BssTab, &(pAd->PortCfg.Bssid));
+				pAd->PortCfg.LastScanTime = Now32;
+			}
+			else
+			{
+				// if all 11b peers leave this BSS more than 5 seconds, update Tx rate
+				if ((pAd->PortCfg.Channel <= 14)	&&
+					(pAd->PortCfg.MaxTxRate <= RATE_11)	&&
+					(pAd->PortCfg.MaxDesiredRate > RATE_11)	&&
+					((pAd->PortCfg.Last11bBeaconRxTime + 5000) < Now32))
+				{
+					DBGPRINT(RT_DEBUG_TRACE, "last 11B peer left, update Tx rates\n");
+					
+					memcpy(pAd->PortCfg.SupportedRates, pAd->PortCfg.IbssConfig.SupportedRates, MAX_LEN_OF_SUPPORTED_RATES);
+					pAd->PortCfg.SupportedRatesLen = pAd->PortCfg.IbssConfig.SupportedRatesLen;
+					RTUSBEnqueueInternalCmd(pAd, RT_OID_UPDATE_TX_RATE);
+				}
+			}
+		}
+		else
+		{
+			if ((pAd->PortCfg.bBlockAssoc == TRUE) && (pAd->PortCfg.LastMicErrorTime + (60 * 1000) < Now32))
+			{
+				pAd->PortCfg.bBlockAssoc = FALSE;
+			}
+
+			if ((pAd->PortCfg.AutoReconnect == TRUE) &&
+				(pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) &&
+				(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS)) &&
+				(MlmeValidateSSID(pAd) == TRUE))
+			{
+				if (pAd->PortCfg.BssTab.BssNr==0)
+				{
+					MLME_SCAN_REQ_STRUCT	   ScanReq;
+					CHAR					   BroadSsid[MAX_LEN_OF_SSID];
+				
+					if ((pAd->PortCfg.LastScanTime + 10 * 1000) < Now32)
+					{
+						DBGPRINT(RT_DEBUG_TRACE, "CNTL - No matching BSS, start a new scan\n");
+	//					BroadSsid[0] = '\0';
+						ScanParmFill(pAd, &ScanReq, BroadSsid, 0, BSS_ANY, SCAN_ACTIVE);
+						MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ, sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
+						pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+						// Reset Missed scan number
+	//					pAd->PortCfg.IgnoredScanNumber = 0;
+						pAd->PortCfg.LastScanTime = Now32;
+					}
+					else if (pAd->PortCfg.BssType == BSS_INDEP)	// Quit the forever scan when in a very clean room
+						MlmeAutoReconnectLastSSID(pAd);					
+				}
+				else
+				{
+					if ((pAd->Mlme.PeriodicRound % 10) == 7)
+					{
+						if ((pAd->PortCfg.LastScanTime + 10 * 1000) < Now32)
+						{
+							//MlmeAutoScan(pAd);
+							pAd->PortCfg.LastScanTime = Now32;
+						}
+						MlmeAutoReconnectLastSSID(pAd);
+					}
+					else if ((pAd->Mlme.PeriodicRound % 30) == 8)
+					{
+						MlmeEnqueue(pAd, 
+								MLME_CNTL_STATE_MACHINE, 
+								OID_802_11_BSSID_LIST_SCAN, 
+								0, 
+								NULL);
+					}
+					
+				}
+			}
+		}
+
+		RTUSBUp(pAd, (&(pAd->mlme_semaphore)));
+	}while(0);
+
+	if ((!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)))
+	{
+		RTMPSetTimer(pAd, &pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
+	}
+
+}
+
+// IRQL = DISPATCH_LEVEL
+VOID MlmeAutoScan(
+    IN PRT2570ADAPTER pAd)
+{
+    // check CntlMachine.CurrState to avoid collision with NDIS SetOID request
+    if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "MMCHK - Driver auto scan\n");
+
+        // tell CNTL state machine NOT to call NdisMSetInformationComplete() after completing
+        // this request, because this request is initiated by driver itself.
+        pAd->Mlme.CntlAux.CurrReqIsFromNdis = FALSE; 
+        MlmeEnqueue(pAd, 
+                    MLME_CNTL_STATE_MACHINE, 
+                    OID_802_11_BSSID_LIST_SCAN, 
+                    0, 
+                    NULL);
+	RTUSBUp(pAd, &pAd->mlme_semaphore);
+    }
+}
+// IRQL = DISPATCH_LEVEL
+VOID MlmeAutoRecoverNetwork(
+    IN PRT2570ADAPTER pAd)
+{
+    // check CntlMachine.CurrState to avoid collision with NDIS SetOID request
+    if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+    {
+        NDIS_802_11_SSID OidSsid;
+        OidSsid.SsidLength = pAd->PortCfg.SsidLen;
+        memcpy(OidSsid.Ssid, pAd->PortCfg.Ssid, pAd->PortCfg.SsidLen);
+
+        DBGPRINT(RT_DEBUG_TRACE, "MMCHK - Driver auto recovering network - %s\n", pAd->PortCfg.Ssid);
+
+        // tell CNTL state machine NOT to call NdisMSetInformationComplete() after completing
+        // this request, because this request is initiated by driver itself.
+        pAd->Mlme.CntlAux.CurrReqIsFromNdis = FALSE; 
+                    
+        MlmeEnqueue(pAd, 
+                    MLME_CNTL_STATE_MACHINE, 
+                    OID_802_11_SSID, 
+                    sizeof(NDIS_802_11_SSID), 
+                    &OidSsid);
+	RTUSBUp(pAd, (&(pAd->mlme_semaphore)));
+	//KeSetEvent(&pAd->MLMEEvent, 0, FALSE);			
+    }
+}
+
+// IRQL = DISPATCH_LEVEL
+VOID MlmeAutoReconnectLastSSID(
+    IN PRT2570ADAPTER pAd)
+{
+    // check CntlMachine.CurrState to avoid collision with NDIS SetOID request
+    if ((pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) && (MlmeValidateSSID(pAd) == TRUE))
+    {
+        NDIS_802_11_SSID OidSsid;
+        OidSsid.SsidLength = pAd->PortCfg.SsidLen;
+        memcpy(OidSsid.Ssid, pAd->PortCfg.Ssid, pAd->PortCfg.SsidLen);
+
+        DBGPRINT(RT_DEBUG_TRACE, "Driver auto reconnect to last OID_802_11_SSID setting - %s\n", pAd->PortCfg.Ssid);
+
+		// We will only try this attemp once, therefore change the AutoReconnect flag afterwards.
+        pAd->Mlme.CntlAux.CurrReqIsFromNdis = FALSE; 
+                    
+        MlmeEnqueue(pAd, 
+                    MLME_CNTL_STATE_MACHINE, 
+                    OID_802_11_SSID, 
+                    sizeof(NDIS_802_11_SSID), 
+                    &OidSsid);
+
+	RTUSBUp(pAd, &pAd->mlme_semaphore);
+
+    }
+}
+
+// Validate SSID for connection try and rescan purpose
+// Valid SSID will have visible chars only.
+// The valid length is from 0 to 32.
+// IRQL = DISPATCH_LEVEL
+BOOLEAN	MlmeValidateSSID(
+    IN PRT2570ADAPTER pAd)
+{
+	NDIS_802_11_SSID OidSsid;
+	ULONG	index;
+	
+	// Copy the SSID into local buffer
+	OidSsid.SsidLength = pAd->Mlme.CntlAux.SsidLen;
+	memcpy(OidSsid.Ssid, pAd->Mlme.CntlAux.Ssid, pAd->Mlme.CntlAux.SsidLen);
+
+	// First check the zero length "ANY" SSID
+	if (OidSsid.SsidLength == 0)
+		return (TRUE);
+	else if (OidSsid.SsidLength > NDIS_802_11_LENGTH_SSID)
+		return (FALSE);
+
+	// Check each character value
+	for (index = 0; index < OidSsid.SsidLength; index++)
+	{
+		if (OidSsid.Ssid[index] < 0x20)
+			return (FALSE);
+	}
+
+	// All checked
+	return (TRUE);
+}
+
+/*
+    ==========================================================================
+    Description:
+        This routine checks if there're other APs out there capable for
+        roaming. Caller should call this routine only when Massoc=TRUE and
+        channel quality is below CQI_GOOD_THRESHOLD.
+        
+	IRQL = DISPATCH_LEVEL
+
+    Output:
+    ==========================================================================
+ */
+VOID MlmeCheckForRoaming(
+    IN PRT2570ADAPTER pAd,
+    IN ULONG    Now32)
+{
+	USHORT     i;
+	BSS_TABLE  *pBssTab = &pAd->PortCfg.BssTab;
+	BSS_TABLE  *pRoamTab = &pAd->Mlme.CntlAux.RoamTab;
+	BSS_ENTRY  *pBss;
+
+	DBGPRINT(RT_DEBUG_TRACE, "==> MlmeCheckForRoaming\n");
+	// put all roaming candidates into RoamTab, and sort in RSSI order
+	BssTableInit(pRoamTab);
+	for (i = 0; i < pBssTab->BssNr; i++)
+	{
+		pBss = &pBssTab->BssEntry[i];
+
+		if ((pBssTab->BssEntry[i].LastBeaconRxTime + BEACON_LOST_TIME) < Now32) 
+			continue;    // AP disappear
+		if (pBss->Rssi <= RSSI_THRESHOLD_FOR_ROAMING)
+			continue;    // RSSI too weak. forget it.
+		if (MAC_ADDR_EQUAL(&pBssTab->BssEntry[i].Bssid, &pAd->PortCfg.Bssid))
+			continue;    // skip current AP
+		if (CQI_IS_FAIR(pAd->Mlme.ChannelQuality) && (pAd->PortCfg.LastRssi + RSSI_DELTA > pBss->Rssi)) 
+			continue;    // we're still okay, only AP with stronger RSSI is eligible for roaming
+
+		// AP passing all above rules is put into roaming candidate table        
+		memcpy(&pRoamTab->BssEntry[pRoamTab->BssNr], pBss, sizeof(BSS_ENTRY));
+		pRoamTab->BssNr += 1;
+	}
+
+	if (pRoamTab->BssNr > 0)
+	{
+		// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
+		if ((pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS)))
+		{
+		// tell CNTL state machine NOT to call NdisMSetInformationComplete() after completing
+		// this request, because this request is initiated by driver itself, not from NDIS.
+		pAd->Mlme.CntlAux.CurrReqIsFromNdis = FALSE; 
+
+		pAd->RalinkCounters.PoorCQIRoamingCount ++;
+		DBGPRINT(RT_DEBUG_TRACE, "MMCHK - Roaming attempt #%d\n", pAd->RalinkCounters.PoorCQIRoamingCount);
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_MLME_ROAMING_REQ, 0, NULL);
+		RTUSBUp(pAd, (&(pAd->mlme_semaphore)));
+		//KeSetEvent(&pAd->MLMEEvent, 0, FALSE);
+		}
+	}
+	DBGPRINT(RT_DEBUG_TRACE, "<== MlmeCheckForRoaming\n");   
+}
+
+VOID PeriodicExec(
+    IN PRT2570ADAPTER pAd)
+{
+
+    USHORT TxFailCount, TxNoRetryCnt, TxOneRetryCnt, TxMRetryCnt, TxRetryOkCount, TxOkCount, TxTotalCnt, TxPER, TxPRR = 0, TxRealOkCount;
+	USHORT RxFailCnt;
+    ULONG RxOkCnt, RxCnt, RxPER;
+	ULONG Now32;
+	ULONG OldValue;
+	UCHAR UpRate, DownRate, CurrRate;
+
+	if ((RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) ||
+		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) ||
+		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)))
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "PeriodicExec not execute! (pAd->Flags=0x%08x)\n", pAd->Flags);
+		return ;
+	}
+	AsicAdjustTxPower(pAd);
+ 	RTUSBMultiReadMAC(pAd, STA_CSR0, (PUCHAR)pAd->MACCounters, 22);
+	OldValue = pAd->WlanCounters.FCSErrorCount.vv.LowPart;
+	pAd->WlanCounters.FCSErrorCount.vv.LowPart += pAd->MACCounters[0];
+	if (pAd->WlanCounters.FCSErrorCount.vv.LowPart < OldValue)
+	{
+		pAd->WlanCounters.FCSErrorCount.vv.HighPart++;
+	}
+	OldValue = pAd->WlanCounters.NoRetryCount.vv.LowPart;
+	pAd->WlanCounters.NoRetryCount.vv.LowPart += pAd->MACCounters[6];
+	if (pAd->WlanCounters.NoRetryCount.vv.LowPart < OldValue)
+	{
+		pAd->WlanCounters.NoRetryCount.vv.HighPart++;
+	}
+	OldValue = pAd->WlanCounters.RetryCount.vv.LowPart;
+	pAd->WlanCounters.RetryCount.vv.LowPart += pAd->MACCounters[7];
+	if (pAd->WlanCounters.RetryCount.vv.LowPart < OldValue)
+	{
+		pAd->WlanCounters.RetryCount.vv.HighPart++;
+	}
+	OldValue = pAd->WlanCounters.MultipleRetryCount.vv.LowPart;
+	pAd->WlanCounters.MultipleRetryCount.vv.LowPart += pAd->MACCounters[8];
+	if (pAd->WlanCounters.MultipleRetryCount.vv.LowPart < OldValue)
+	{
+		pAd->WlanCounters.MultipleRetryCount.vv.HighPart++;
+	}
+	OldValue = pAd->WlanCounters.FailedCount.vv.LowPart;
+	pAd->WlanCounters.FailedCount.vv.LowPart += pAd->MACCounters[9];
+	if (pAd->WlanCounters.FailedCount.vv.LowPart < OldValue)
+	{
+		pAd->WlanCounters.FailedCount.vv.HighPart++;
+	}
+	OldValue = pAd->QACounters.RXOverFlowCount.vv.LowPart;
+	pAd->QACounters.RXOverFlowCount.vv.LowPart += pAd->MACCounters[4];
+	if (pAd->QACounters.RXOverFlowCount.vv.LowPart < OldValue)
+	{
+		pAd->QACounters.RXOverFlowCount.vv.HighPart++;
+	}
+
+    //
+    // monitor TX counters change for the past period
+    //
+    TxFailCount = pAd->MACCounters[9];
+    TxNoRetryCnt = pAd->MACCounters[6];
+    TxOneRetryCnt = pAd->MACCounters[7];
+    TxMRetryCnt = pAd->MACCounters[8];
+	TxRetryOkCount = TxOneRetryCnt + TxMRetryCnt;
+	TxOkCount = TxNoRetryCnt + TxRetryOkCount;
+	TxTotalCnt = TxOkCount + TxFailCount;
+	if (TxTotalCnt > 100)
+	{
+		pAd->ScanAllowed = FALSE;
+	}
+	else
+	{
+		pAd->ScanAllowed = TRUE;
+	}
+#if 1//steven:exclude CTS
+	if ((pAd->PortCfg.TxRate >= RATE_FIRST_OFDM_RATE) && (pAd->PortCfg.BGProtectionInUsed))
+		TxTotalCnt = TxTotalCnt / 2;
+#endif
+	if (TxTotalCnt > TxFailCount)
+		TxRealOkCount = TxTotalCnt - TxFailCount;
+	else
+		TxRealOkCount = 0;
+	OldValue = pAd->WlanCounters.TransmittedFragmentCount.vv.LowPart;
+	pAd->WlanCounters.TransmittedFragmentCount.vv.LowPart += TxRealOkCount;
+	if (pAd->WlanCounters.TransmittedFragmentCount.vv.LowPart < OldValue)
+	{
+		pAd->WlanCounters.TransmittedFragmentCount.vv.HighPart++;
+	}
+
+	AsicBbpTuning(pAd);
+	if (pAd->MediaState == NdisMediaStateConnected)
+	{
+    if (TxTotalCnt < 5) // if too few TX samples, skip TX related statistics
+    {
+        TxPER = 0;  // don't take TxPER into CQI consideration if too few sample
+        TxPRR = 0;
+    }
+    else 
+    {
+		if (TxFailCount < TxTotalCnt)
+		{
+			USHORT temp = TxOneRetryCnt + TxMRetryCnt + TxFailCount;
+			TxPER = (TxFailCount * 100) / TxTotalCnt;
+			if (temp < TxTotalCnt)
+				TxPRR = (temp * 100) / TxTotalCnt;
+			else
+				TxPRR = 100;
+		}
+		else
+			TxPER = 100;
+    }
+
+    //
+    // calculate RX PER
+    //
+	RxFailCnt = pAd->MACCounters[0];
+    RxOkCnt   = pAd->WlanCounters.ReceivedFragmentCount.vv.LowPart - 
+                pAd->Mlme.PrevWlanCounters.ReceivedFragmentCount.vv.LowPart;
+    RxCnt = RxOkCnt + RxFailCnt;
+
+    if (RxCnt < 5)
+        RxPER = 0;  // don't take RxPER into ChannelQuality consideration if too few sample
+    else
+        RxPER = (RxFailCnt * 100) / RxCnt;
+
+	if ((ADHOC_ON(pAd)) && (pAd->MediaState == NdisMediaStateConnected))
+	{
+		pAd->SentBeaconsCount += pAd->MACCounters[5];
+		pAd->ReceivedBeaconsCount += pAd->MACCounters[10];
+
+		if ((pAd->Mlme.PeriodicRound % 2) == 1)
+		{
+			TXRX_CSR18_STRUC Csr18;
+			USHORT temp;
+
+			DBGPRINT(RT_DEBUG_INFO, "SentBeaconsCount = %d ReceivedBeaconsCount = %d\n", pAd->SentBeaconsCount, pAd->ReceivedBeaconsCount);
+			if (pAd->BeaconIntervalChangeAllowed == TRUE)
+			{
+				if (2 * pAd->SentBeaconsCount > pAd->ReceivedBeaconsCount)
+				{
+					temp = (pAd->PortCfg.BeaconPeriod << 8) + 1;
+					Csr18.field.Offset = (temp & 0x000F);
+					Csr18.field.Interval = (temp >> 6);
+					RTUSBWriteMACRegister(pAd, TXRX_CSR18, Csr18.value);
+					DBGPRINT(RT_DEBUG_INFO, "TXRX_CSR18 = 0x%x\n", Csr18.value);
+					
+					pAd->BeaconIntervalChangeAllowed = FALSE;
+				}
+				else if (pAd->ReceivedBeaconsCount > 9 * pAd->SentBeaconsCount)
+				{
+					temp = (pAd->PortCfg.BeaconPeriod << 8) - 5;
+					Csr18.field.Offset = (temp & 0x000F);
+					Csr18.field.Interval = (temp >> 6);
+					RTUSBWriteMACRegister(pAd, TXRX_CSR18, Csr18.value);
+					DBGPRINT(RT_DEBUG_INFO, "TXRX_CSR18 = 0x%x\n", Csr18.value);
+					
+					pAd->BeaconIntervalChangeAllowed = FALSE;
+				}
+				else if (pAd->ReceivedBeaconsCount > 3 * pAd->SentBeaconsCount)
+				{
+					temp = (pAd->PortCfg.BeaconPeriod << 8) - 1;
+					Csr18.field.Offset = (temp & 0x000F);
+					Csr18.field.Interval = (temp >> 6);
+					RTUSBWriteMACRegister(pAd, TXRX_CSR18, Csr18.value);
+					DBGPRINT(RT_DEBUG_INFO, "TXRX_CSR18 = 0x%x\n", Csr18.value);
+					
+					pAd->BeaconIntervalChangeAllowed = FALSE;
+				}
+#if 0
+				else if (pAd->ReceivedBeaconsCount > 2 * pAd->SentBeaconsCount)
+				{
+					temp = (pAd->PortCfg.BeaconPeriod << 8) - 1;
+					Csr18.field.Offset = (temp & 0x000F);
+					Csr18.field.Interval = (temp >> 6);
+					RTUSBWriteMACRegister(pAd, TXRX_CSR18, Csr18.value);
+					DBGPRINT(RT_DEBUG_TRACE, ("TXRX_CSR18 = 0x%x\n", Csr18.value));
+					
+					pAd->BeaconIntervalChangeAllowed = FALSE;
+				}
+#endif
+			}
+#if 0
+			else if (pAd->ReceivedBeaconsCount > 9 * pAd->SentBeaconsCount)
+			{
+				DBGPRINT(RT_DEBUG_TRACE, ("Do Nothing\n"));
+			}
+#endif
+			else
+			{
+				temp = (pAd->PortCfg.BeaconPeriod << 8);
+				Csr18.field.Offset = (temp & 0x000F);
+				Csr18.field.Interval = (temp >> 6);
+				RTUSBWriteMACRegister(pAd, TXRX_CSR18, Csr18.value);
+				DBGPRINT(RT_DEBUG_INFO, "TXRX_CSR18 = 0x%x\n", Csr18.value);
+				
+				pAd->BeaconIntervalChangeAllowed = TRUE;
+			}
+			
+			pAd->SentBeaconsCount = 0;
+			pAd->ReceivedBeaconsCount = 0;
+		}
+	}
+	Now32 = jiffies;
+
+	{
+	    // ChannelQuality = W1*RSSI + W2*TxPRR + W3*RxPER    (RSSI 0..100), (TxPER 100..0), (RxPER 100..0)
+	    pAd->Mlme.ChannelQuality = (RSSI_WEIGHTING * pAd->PortCfg.LastRssi + 
+	                         TX_WEIGHTING * (100 - TxPRR) + 
+	                         RX_WEIGHTING* (100 - RxPER)) / 100;
+	    if (pAd->Mlme.ChannelQuality >= 100)
+	        pAd->Mlme.ChannelQuality = 100;
+	}
+    
+    DBGPRINT(RT_DEBUG_INFO, "MMCHK - CQI= %d, (Tx Fail=%d/Retry=%d/Total=%d, Rx Fail=%d/Total=%d, RSSI=%d dbm)\n", 
+        pAd->Mlme.ChannelQuality, TxFailCount, TxRetryOkCount, TxTotalCnt, RxFailCnt, RxCnt, pAd->PortCfg.LastRssi - pAd->BBPTuningParameters.RSSIToDbmOffset);
+
+    // latch current WLAN counters for next check-for-roaming usage
+    memcpy(&pAd->Mlme.PrevWlanCounters, &pAd->WlanCounters, sizeof(COUNTER_802_11));
+
+#if 1//steven:move this from MlmePeriodicExec
+	if (INFRA_ON(pAd))
+	{
+		if (CQI_IS_BAD(pAd->Mlme.ChannelQuality))
+		{
+			pAd->RalinkCounters.BadCQIAutoRecoveryCount ++;
+           	DBGPRINT(RT_DEBUG_TRACE, "MMCHK - Bad CQI. Auto Recovery attempt #%d\n", pAd->RalinkCounters.BadCQIAutoRecoveryCount);
+			MlmeAutoRecoverNetwork(pAd);
+		}
+		else if (CQI_IS_FAIR(pAd->Mlme.ChannelQuality) || CQI_IS_POOR(pAd->Mlme.ChannelQuality))
+		{
+			// perform aggresive roaming only when SECURITY OFF or WEP64/128;
+			// WPA and WPA-PSK has no aggresive roaming because re-negotiation
+			// between 802.1x supplicant and authenticator/AAA server is required
+			// but can't be guaranteed.
+			if (pAd->PortCfg.AuthMode < Ndis802_11AuthModeWPA)
+				MlmeCheckForRoaming(pAd, Now32);
+		}
+	}
+#endif
+
+	pAd->PortCfg.CurrTxRateStableTime++;
+	CurrRate = pAd->PortCfg.TxRate;
+    do
+    {
+		USHORT TxErrorRatio;
+		BOOLEAN fUpgradeQuality = FALSE;
+		USHORT  *pRateUpPER, *pRateDownPER;
+
+        if (pAd->PortCfg.EnableAutoRateSwitching == FALSE)
+            break;
+            
+        // do nothing if no traffic in the past period
+        if (TxTotalCnt == 0)
+        {
+            // TxRateUpPenalty maybe too large, we don't want this penalty to affect
+            // next Chariot throughput test too much therefore zero it here.
+            pAd->PortCfg.TxRateUpPenalty = 0;
+            memset(pAd->DrsCounters.TxQuality, 0, MAX_LEN_OF_SUPPORTED_RATES);
+            memset(pAd->DrsCounters.PER, 0, MAX_LEN_OF_SUPPORTED_RATES);
+            break;
+        }
+
+        // decide the next upgrade rate and downgrade rate, if any
+        if (pAd->PortCfg.PhyMode == PHY_11BG_MIXED)
+        {
+            UpRate = Phy11BGNextRateUpward[CurrRate];
+            DownRate = Phy11BGNextRateDownward[CurrRate];
+        }
+        else if (pAd->PortCfg.PhyMode == PHY_11B)
+        {
+            UpRate = Phy11BNextRateUpward[CurrRate];
+            DownRate = Phy11BNextRateDownward[CurrRate];
+        }
+        else if (pAd->PortCfg.PhyMode == PHY_11A)
+        {
+            UpRate = Phy11ANextRateUpward[CurrRate];
+            DownRate = Phy11ANextRateDownward[CurrRate];
+        }
+        else // PHY_11ABG_MIXED
+        {
+            if (pAd->PortCfg.Channel > 14)  
+            {
+                UpRate = Phy11ANextRateUpward[CurrRate];
+                DownRate = Phy11ANextRateDownward[CurrRate];
+            }
+            else
+            {
+                UpRate = Phy11BGNextRateUpward[CurrRate];
+                DownRate = Phy11BGNextRateDownward[CurrRate];
+            }
+        }
+
+        if (UpRate > pAd->PortCfg.MaxTxRate)
+            UpRate = pAd->PortCfg.MaxTxRate;
+    
+        // decide TX quality based on Tx retry ratio when enough samples are available
+        if (TxTotalCnt > 15)
+        {
+			USHORT temp = TxRetryOkCount + TxFailCount;
+			if (temp < TxTotalCnt)
+				TxErrorRatio = (temp *100) / TxTotalCnt;
+			else
+				TxErrorRatio = 100;
+
+			pRateUpPER = &NewRateUpPER[0];
+			pRateDownPER = &NewRateDownPER[0];
+
+            // downgrade TX quality if retry+error ratio reached
+            if (TxErrorRatio >= pRateDownPER[CurrRate])
+            {
+                pAd->DrsCounters.TxQuality[CurrRate] = DRS_TX_QUALITY_WORST_BOUND;
+            }
+            // upgrade TX quality if retry+error ratio reached
+            else if (TxErrorRatio <= pRateUpPER[CurrRate])
+            {
+                fUpgradeQuality = TRUE;
+                if (pAd->DrsCounters.TxQuality[CurrRate])
+                    pAd->DrsCounters.TxQuality[CurrRate] --;  // quality very good in CurrRate
+                    
+                if (pAd->PortCfg.TxRateUpPenalty)
+                    pAd->PortCfg.TxRateUpPenalty --;
+                else if (pAd->DrsCounters.TxQuality[UpRate])
+                    pAd->DrsCounters.TxQuality[UpRate] --;    // may improve next UP rate's quality
+            }
+            
+        }
+        
+        // if not enough TX samples, decide by heuristic rules
+        else
+        {
+            TxErrorRatio = 0;
+            
+            // Downgrade TX quality upon -
+            // 1. any TX failure in the past second
+            // 2. TX retry ratio too high when enough TX samples are available
+            if (TxFailCount)
+            {
+                if ((TxFailCount <= 1) &&
+                    (TxRealOkCount + TxRetryOkCount))
+                {
+                    pAd->DrsCounters.TxQuality[CurrRate] += 2;   // degrade quality
+                    if (pAd->DrsCounters.TxQuality[CurrRate] > DRS_TX_QUALITY_WORST_BOUND)
+                        pAd->DrsCounters.TxQuality[CurrRate] = DRS_TX_QUALITY_WORST_BOUND;
+                }
+                else // more than 2 failure, or no TX ok cases
+                {
+                    pAd->DrsCounters.TxQuality[CurrRate]  = DRS_TX_QUALITY_WORST_BOUND;   // quality bad
+                }
+            }
+            // upgrade TX quality if -
+            // 1. no TX failure but do have TX ok case, and
+            // 2. there's more one-time-ok cases than retry-ok cases in the past second
+            // 3. current rate's Tx retry ratio <= 10%
+            else if ((TxRealOkCount > TxRetryOkCount))
+            {
+                fUpgradeQuality = TRUE;
+                if (pAd->DrsCounters.TxQuality[CurrRate])
+                    pAd->DrsCounters.TxQuality[CurrRate] --;  // quality very good in CurrRate
+
+                if (pAd->PortCfg.TxRateUpPenalty)
+                    pAd->PortCfg.TxRateUpPenalty --;
+                else if (pAd->DrsCounters.TxQuality[UpRate])
+                    pAd->DrsCounters.TxQuality[UpRate] --;    // may improve next UP rate's quality
+            }
+        }
+
+        pAd->DrsCounters.PER[CurrRate] = (UCHAR)TxErrorRatio;
+
+        if (pAd->DrsCounters.fNoisyEnvironment)
+        {
+            DBGPRINT(RT_DEBUG_TRACE,"DRS(noisy): ");
+        }
+        else
+        {
+            DBGPRINT(RT_DEBUG_TRACE,"DRS: ");
+        }
+        DBGPRINT_RAW(RT_DEBUG_TRACE,"Qty[%d]=%d PER=%d%% %d-sec, Qty[%d]=%d, Pty=%d\n", 
+            RateIdToMbps[CurrRate], pAd->DrsCounters.TxQuality[CurrRate],
+            TxErrorRatio,
+            pAd->DrsCounters.CurrTxRateStableTime,
+            RateIdToMbps[UpRate], pAd->DrsCounters.TxQuality[UpRate],
+            pAd->DrsCounters.TxRateUpPenalty);
+        
+        // 2004-3-13 special case: Claim noisy environment
+        //   decide if there was a false "rate down" in the past 2 sec due to noisy 
+        //   environment. if so, we would rather switch back to the higher TX rate. 
+        //   criteria -
+        //     1. there's a higher rate available, AND
+        //     2. there was a rate-down happened, AND
+        //     3. current rate has 75% > PER > 25%, AND
+        //     4. comparing to UpRate, current rate didn't improve PER more than 5 %
+        if ((UpRate != CurrRate)                              &&
+            (pAd->DrsCounters.LastSecTxRateChangeAction == 2) &&
+            (((pAd->DrsCounters.PER[CurrRate] > 20) || (pAd->DrsCounters.fNoisyEnvironment)) && 
+			(pAd->DrsCounters.PER[CurrRate] < 75)) && 
+            ((pAd->DrsCounters.PER[CurrRate]+5) > pAd->DrsCounters.PER[UpRate]))
+        {
+            // we believe this is a noisy environment. better stay at UpRate
+            DBGPRINT(RT_DEBUG_TRACE,"DRS: #### enter Noisy environment ####\n");
+            pAd->DrsCounters.fNoisyEnvironment = TRUE;
+
+            // 2004-3-14 when claiming noisy environment, we're not only switch back
+            //   to UpRate, but can be more aggressive to use one more rate up
+            UpRate++;
+//          if (UpRate>RATE_54) UpRate=RATE_54;
+            if ((UpRate==RATE_6) || (UpRate==RATE_9)) UpRate=RATE_12;
+            if (UpRate > pAd->PortCfg.MaxTxRate)
+                UpRate = pAd->PortCfg.MaxTxRate;
+            pAd->PortCfg.TxRate = UpRate;
+            break;
+        }
+
+        // 2004-3-12 special case: Leave noisy environment
+        //   The interference has gone suddenly. reset TX rate to
+        //   the theoritical value according to RSSI. Criteria -
+        //     1. it's currently in noisy environment
+        //     2. PER drops to be below 12%
+        if ((pAd->DrsCounters.fNoisyEnvironment == TRUE) &&
+            (TxTotalCnt > 15) && (pAd->DrsCounters.PER[CurrRate] <= 12))
+        {
+            UCHAR JumpUpRate;
+
+            pAd->DrsCounters.fNoisyEnvironment = FALSE;
+            for (JumpUpRate = RATE_54; JumpUpRate > RATE_1; JumpUpRate--)
+            {
+                if (pAd->PortCfg.AvgRssi > (RssiSafeLevelForTxRate[JumpUpRate] + pAd->BBPTuningParameters.RSSIToDbmOffset))
+                    break;
+            }
+
+            if (JumpUpRate > pAd->PortCfg.MaxTxRate)
+                JumpUpRate = pAd->PortCfg.MaxTxRate;
+            
+            DBGPRINT(RT_DEBUG_TRACE,"DRS: #### leave Noisy environment ####, RSSI=%d, JumpUpRate=%d\n",
+                pAd->PortCfg.AvgRssi - pAd->BBPTuningParameters.RSSIToDbmOffset, RateIdToMbps[JumpUpRate]);
+            
+            if (JumpUpRate > CurrRate)
+            {
+                pAd->PortCfg.TxRate = JumpUpRate;
+               	break;
+            }
+        }
+        
+        // perform DRS - consider TxRate Down first, then rate up.
+        //     1. rate down, if current TX rate's quality is not good
+        //     2. rate up, if UPRate's quality is very good
+        if ((pAd->DrsCounters.TxQuality[CurrRate] >= DRS_TX_QUALITY_WORST_BOUND) &&
+            (CurrRate != DownRate))
+        {
+
+			pAd->PortCfg.TxRate = DownRate;
+        }
+        else if ((pAd->DrsCounters.TxQuality[CurrRate] <= 0) && 
+            (pAd->DrsCounters.TxQuality[UpRate] <=0)         &&
+            (CurrRate != UpRate))
+        {
+            pAd->PortCfg.TxRate = UpRate;
+        }
+    }while (FALSE);
+
+    // if rate-up happen, clear all bad history of all TX rates
+    if (pAd->PortCfg.TxRate > CurrRate)
+    {
+       	DBGPRINT(RT_DEBUG_TRACE,"DRS: ++TX rate from %d to %d Mbps\n", RateIdToMbps[CurrRate],RateIdToMbps[pAd->PortCfg.TxRate]);
+        pAd->DrsCounters.CurrTxRateStableTime = 0;
+        pAd->DrsCounters.TxRateUpPenalty = 0;
+        pAd->DrsCounters.LastSecTxRateChangeAction = 1; // rate UP
+        memset(pAd->DrsCounters.TxQuality, 0, MAX_LEN_OF_SUPPORTED_RATES);
+        memset(pAd->DrsCounters.PER, 0, MAX_LEN_OF_SUPPORTED_RATES);
+    }
+    // if rate-down happen, only clear DownRate's bad history
+    else if (pAd->PortCfg.TxRate < CurrRate)
+    {
+       	DBGPRINT(RT_DEBUG_TRACE,"DRS: --TX rate from %d to %d Mbps\n", RateIdToMbps[CurrRate],RateIdToMbps[pAd->PortCfg.TxRate]);
+	    // shorter stable time require more penalty in next rate UP criteria
+       	if (pAd->DrsCounters.CurrTxRateStableTime < 4)      // less then 4 sec
+       	    pAd->DrsCounters.TxRateUpPenalty = DRS_PENALTY; // add 8 sec penalty
+       	else if (pAd->DrsCounters.CurrTxRateStableTime < 8) // less then 8 sec
+       	    pAd->DrsCounters.TxRateUpPenalty = 2;           // add 2 sec penalty
+       	else                                                // >= 8 sec
+       	    pAd->DrsCounters.TxRateUpPenalty = 0;           // no penalty
+       	    
+        pAd->DrsCounters.CurrTxRateStableTime = 0;
+        pAd->DrsCounters.LastSecTxRateChangeAction = 2; // rate DOWN
+       	pAd->DrsCounters.TxQuality[pAd->PortCfg.TxRate] = 0;
+       	pAd->DrsCounters.PER[pAd->PortCfg.TxRate] = 0;
+    }
+    else
+        pAd->DrsCounters.LastSecTxRateChangeAction = 0; // rate no change
+	}
+
+
+}
+
+/*
+    ==========================================================================
+    Description:
+        This routine is executed periodically inside MlmePeriodicExec() after 
+        association with an AP.
+        It checks if PortCfg.Psm is consistent with user policy (recorded in
+        PortCfg.WindowsPowerMode). If not, enforce user policy. However, 
+        there're some conditions to consider:
+        1. we don't support power-saving in ADHOC mode, so Psm=PWR_ACTIVE all
+           the time when Mibss==TRUE
+        2. When Massoc==TRUE (INFRA mode), Psm should not be switch to PWR_SAVE
+           if outgoing traffic available in TxRing or PrioRing.
+    Output:
+        1. change pAd->PortCfg.Psm to PWR_SAVE or leave it untouched
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+VOID MlmeCheckForPsmChange(
+    IN PRT2570ADAPTER pAd)
+{
+	ULONG	PowerMode;
+    // condition -
+    // 1. Psm maybe ON only happen in INFRASTRUCTURE mode
+    // 2. user wants either MAX_PSP or FAST_PSP
+    // 3. but current psm is not in PWR_SAVE
+    // 4. CNTL state machine is not doing SCANning
+    // 5. no TX SUCCESS event for the past period
+    	PowerMode = pAd->PortCfg.WindowsPowerMode;
+    
+    if (INFRA_ON(pAd) &&
+        (PowerMode != Ndis802_11PowerModeCAM) &&
+		(pAd->BulkOutPending == FALSE) &&
+		(LOCAL_TX_RING_EMPTY(pAd)) &&
+		(skb_queue_empty(&pAd->SendTxWaitQueue)) &&
+        (pAd->PortCfg.Psm == PWR_ACTIVE) &&
+        (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) &&
+        (pAd->WlanCounters.TransmittedFragmentCount.vv.LowPart == pAd->Mlme.PrevTxCnt))
+    {
+		RTUSBEnqueueInternalCmd(pAd, RT_OID_SET_PSM_BIT_SAVE);
+    }
+    
+    // latch current count for next-time comparison
+    pAd->Mlme.PrevTxCnt = pAd->WlanCounters.TransmittedFragmentCount.vv.LowPart;
+
+}
+
+// IRQL = PASSIVE_LEVEL
+// IRQL = DISPATCH_LEVEL
+VOID MlmeSetPsmBit(
+    IN PRT2570ADAPTER pAd, 
+    IN USHORT psm)
+{
+    pAd->PortCfg.Psm = psm;    
+    
+    DBGPRINT(RT_DEBUG_TEMP, "MMCHK - change PSM bit to %d <<<\n", psm);
+}
+
+// IRQL = DISPATCH_LEVEL
+// IRQL = DISPATCH_LEVEL
+VOID MlmeSetTxPreamble(
+    IN PRT2570ADAPTER pAd, 
+    IN USHORT TxPreamble)
+{
+	USHORT	value;
+
+    RTUSBReadMACRegister(pAd, TXRX_CSR10, &value);
+    if (TxPreamble == Rt802_11PreambleShort)
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "MlmeSetTxPreamble (= SHORT PREAMBLE)\n");
+		value |= 0x0004;
+        pAd->PortCfg.TxPreambleInUsed = Rt802_11PreambleShort;
+    }
+    else
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "MlmeSetTxPreamble (= LONG PREAMBLE)\n");
+		value &= 0xFFFB;
+        pAd->PortCfg.TxPreambleInUsed = Rt802_11PreambleLong;
+    }
+
+    RTUSBWriteMACRegister(pAd, TXRX_CSR10, value);
+}
+    
+// IRQL = PASSIVE_LEVEL
+// IRQL = DISPATCH_LEVEL
+// bLinkUp is to identify the inital link speed.
+// TRUE indicates the rate update at linkup, we should not try to set the rate at 54Mbps.
+VOID MlmeUpdateTxRates(
+    IN PRT2570ADAPTER pAd,
+    IN BOOLEAN		 bLinkUp)
+{
+    int i, num;
+    UCHAR Rate, MaxDesire = RATE_1, MaxSupport = RATE_1;
+    USHORT BasicRateBitmap = 0;
+    UCHAR CurrBasicRate = RATE_1;
+
+    // find max desired rate
+    num = 0;
+    for (i=0; i<MAX_LEN_OF_SUPPORTED_RATES; i++)
+    {
+        switch (pAd->PortCfg.DesiredRates[i] & 0x7f)
+        {
+            case 2:  Rate = RATE_1;   num++;   break;
+            case 4:  Rate = RATE_2;   num++;   break;
+            case 11: Rate = RATE_5_5; num++;   break;
+            case 22: Rate = RATE_11;  num++;   break;
+            case 12: Rate = RATE_6;   num++;   break;
+            case 18: Rate = RATE_9;   num++;   break;
+            case 24: Rate = RATE_12;  num++;   break;
+            case 36: Rate = RATE_18;  num++;   break;
+            case 48: Rate = RATE_24;  num++;   break;
+            case 72: Rate = RATE_36;  num++;   break;
+            case 96: Rate = RATE_48;  num++;   break;
+            case 108: Rate = RATE_54; num++;   break;
+            default: Rate = RATE_1;   break;
+        }
+        if (MaxDesire < Rate)  MaxDesire = Rate;
+
+		// Fixed the Maximum rate of 2426 to b only
+		if (pAd->PortCfg.RfType == RFIC_2426)
+			if (MaxDesire > RATE_11)
+				MaxDesire = RATE_11;
+    }
+
+    // 2003-12-10 802.11g WIFI spec disallow OFDM rates in 802.11g ADHOC mode
+    if ((pAd->PortCfg.BssType == BSS_INDEP)        &&
+        (pAd->PortCfg.PhyMode == PHY_11BG_MIXED)   && 
+        (pAd->PortCfg.AdhocMode == 0) &&
+        (MaxDesire > RATE_11))
+        MaxDesire = RATE_11;
+    
+    pAd->PortCfg.MaxDesiredRate = MaxDesire;
+    
+    // Auto rate switching is enabled only if more than one DESIRED RATES are 
+    // specified; otherwise disabled
+    if (num <= 1)
+        pAd->PortCfg.EnableAutoRateSwitching = FALSE;
+    else
+        pAd->PortCfg.EnableAutoRateSwitching = TRUE;
+
+    // find max supported rate
+    for (i=0; i<pAd->PortCfg.SupportedRatesLen; i++)
+    {
+        switch (pAd->PortCfg.SupportedRates[i] & 0x7f)
+        {
+            case 2: Rate = RATE_1;   
+                    if (pAd->PortCfg.SupportedRates[i] & 0x80) 
+                        BasicRateBitmap |= 0x0001;  
+                    break;
+            case 4: Rate = RATE_2;   
+                    if (pAd->PortCfg.SupportedRates[i] & 0x80) 
+                        BasicRateBitmap |= 0x0002;  
+                    break;
+            case 11: 
+                    Rate = RATE_5_5; 
+                    if (pAd->PortCfg.SupportedRates[i] & 0x80) 
+                        BasicRateBitmap |= 0x0004;  
+                    break;
+            case 22: 
+                    Rate = RATE_11;  
+                    if (pAd->PortCfg.SupportedRates[i] & 0x80) 
+                        BasicRateBitmap |= 0x0008;  
+                    break;
+            case 12: 
+                    Rate = RATE_6;   
+//                    if (pAd->PortCfg.SupportedRates[i] & 0x80) 
+                        BasicRateBitmap |= 0x0010;  
+                    break;
+            case 18: 
+                    Rate = RATE_9;   
+                    if (pAd->PortCfg.SupportedRates[i] & 0x80) 
+                        BasicRateBitmap |= 0x0020;  
+                    break;
+            case 24: 
+                    Rate = RATE_12;  
+//                    if (pAd->PortCfg.SupportedRates[i] & 0x80) 
+                        BasicRateBitmap |= 0x0040;  
+                    break;
+            case 36: 
+                    Rate = RATE_18;  
+                    if (pAd->PortCfg.SupportedRates[i] & 0x80) 
+                        BasicRateBitmap |= 0x0080;  
+                    break;
+            case 48: 
+                    Rate = RATE_24;  
+//                  if (pAd->PortCfg.SupportedRates[i] & 0x80) 
+						BasicRateBitmap |= 0x0100;  
+                    break;
+            case 72: 
+                    Rate = RATE_36;  
+                    if (pAd->PortCfg.SupportedRates[i] & 0x80) 
+                        BasicRateBitmap |= 0x0200;  
+                    break;
+            case 96: 
+                    Rate = RATE_48;  
+                    if (pAd->PortCfg.SupportedRates[i] & 0x80) 
+                        BasicRateBitmap |= 0x0400;  
+                    break;
+            case 108: 
+                    Rate = RATE_54; 
+                    if (pAd->PortCfg.SupportedRates[i] & 0x80) 
+                        BasicRateBitmap |= 0x0800;  
+                    break;
+            default:  
+                    Rate = RATE_1;   
+                    break;
+        }
+        if (MaxSupport < Rate)  MaxSupport = Rate;
+    }
+
+	// Limit the max support rate and basic rate map to 11b only
+	if (pAd->PortCfg.RfType == RFIC_2426)
+	{
+		if (MaxSupport > RATE_11)
+		{
+			MaxSupport = RATE_11;
+			BasicRateBitmap &= 0x000f;
+		}
+	}
+	
+	RTUSBWriteMACRegister(pAd, TXRX_CSR11, BasicRateBitmap);
+
+    // calculate the exptected ACK rate for each TX rate. This info is used to caculate
+    // the DURATION field of outgoing uniicast DATA/MGMT frame
+    for (i=0; i<MAX_LEN_OF_SUPPORTED_RATES; i++)
+    {
+        if (BasicRateBitmap & (0x01 << i))
+            CurrBasicRate = (UCHAR)i;
+        pAd->PortCfg.ExpectedACKRate[i] = CurrBasicRate;
+        DBGPRINT(RT_DEBUG_INFO,"Exptected ACK rate[%d] = %d Mbps\n", RateIdToMbps[i], RateIdToMbps[CurrBasicRate]);
+    }
+
+    // max tx rate = min {max desire rate, max supported rate}
+    if (MaxSupport < MaxDesire)
+        pAd->PortCfg.MaxTxRate = MaxSupport;
+    else
+        pAd->PortCfg.MaxTxRate = MaxDesire;
+
+    // 2003-07-31 john - 2500 doesn't have good sensitivity at high OFDM rates. to increase the success
+    // ratio of initial DHCP packet exchange, TX rate starts from a lower rate
+    if (pAd->PortCfg.EnableAutoRateSwitching)
+    {
+        if (pAd->PortCfg.Channel > 14)
+            pAd->PortCfg.TxRate = RATE_6; // 802.11a
+        else 
+		{
+			int dbm = pAd->PortCfg.AvgRssi - pAd->BBPTuningParameters.RSSIToDbmOffset;
+			if (dbm > -70)
+			{
+				pAd->PortCfg.TxRate = pAd->PortCfg.MaxTxRate;
+			}
+			else if (dbm > -75)
+			{
+				pAd->PortCfg.TxRate = min((INT)(pAd->PortCfg.MaxTxRate), RATE_36);
+			}
+			else
+			{
+				pAd->PortCfg.TxRate = min((INT)(pAd->PortCfg.MaxTxRate), RATE_11);
+			}
+		}
+    }
+    else
+        pAd->PortCfg.TxRate = pAd->PortCfg.MaxTxRate;
+
+    switch (pAd->PortCfg.PhyMode) {
+        case PHY_11BG_MIXED:
+        case PHY_11B:
+            pAd->PortCfg.MlmeRate = RATE_2;
+#ifdef	WIFI_TEST			
+            pAd->PortCfg.RtsRate = RATE_11;
+#else
+            pAd->PortCfg.RtsRate = RATE_2;
+#endif
+            break;
+        case PHY_11A:
+            pAd->PortCfg.MlmeRate = RATE_6;
+            pAd->PortCfg.RtsRate = RATE_6;
+            break;
+        case PHY_11ABG_MIXED:
+            if (pAd->PortCfg.Channel <= 14)
+            {
+                pAd->PortCfg.MlmeRate = RATE_2;
+                pAd->PortCfg.RtsRate = RATE_2;
+            }
+            else
+            {
+                pAd->PortCfg.MlmeRate = RATE_6;
+                pAd->PortCfg.RtsRate = RATE_6;
+            }
+            break;
+        default: // error
+            pAd->PortCfg.MlmeRate = RATE_2;
+            pAd->PortCfg.RtsRate = RATE_2;
+            break;
+    }
+    
+    DBGPRINT(RT_DEBUG_TRACE, " MlmeUpdateTxRates (MaxDesire=%d, MaxSupport=%d, MaxTxRate=%d, Rate Switching =%d)\n", 
+             RateIdToMbps[MaxDesire], RateIdToMbps[MaxSupport], RateIdToMbps[pAd->PortCfg.MaxTxRate], pAd->PortCfg.EnableAutoRateSwitching);
+    DBGPRINT(RT_DEBUG_TRACE, " MlmeUpdateTxRates (TxRate=%d, RtsRate=%d, BasicRateBitmap=0x%04x)\n", 
+             RateIdToMbps[pAd->PortCfg.TxRate], RateIdToMbps[pAd->PortCfg.RtsRate], BasicRateBitmap);
+}
+
+// IRQL = DISPATCH_LEVEL
+VOID MlmeRadioOff(
+    IN PRT2570ADAPTER pAd)
+{
+	MLME_DISASSOC_REQ_STRUCT DisReq;
+	MLME_QUEUE_ELEM          MsgElem;
+	UINT	i = 0;
+
+	//
+	// Since set flag fRTMP_ADAPTER_RADIO_OFF will diable RTUSBKickBulkOut function.
+	// So before set flag fRTMP_ADAPTER_RADIO_OFF, 
+	// we should send a disassoc frame to our AP if neend.
+	//
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS))
+	{
+		if (INFRA_ON(pAd)) 
+		{
+			COPY_MAC_ADDR(&DisReq.Addr, &pAd->PortCfg.Bssid);
+			DisReq.Reason =  REASON_DISASSOC_STA_LEAVING;
+
+			MsgElem.Machine = ASSOC_STATE_MACHINE;
+			MsgElem.MsgType = MT2_MLME_DISASSOC_REQ;
+			MsgElem.MsgLen = sizeof(MLME_DISASSOC_REQ_STRUCT);
+			memcpy(MsgElem.Msg, &DisReq, sizeof(MLME_DISASSOC_REQ_STRUCT));
+
+			MlmeDisassocReqAction(pAd, &MsgElem);
+			NdisMSleep(1);
+		}
+		// Set Radio off flag will turn off RTUSBKickBulkOut function
+		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
+        	DBGPRINT(RT_DEBUG_ERROR, "3Set fRTMP_ADAPTER_RADIO_OFF ");
+	
+		LinkDown(pAd);
+	}
+	else
+	{
+		// Set Radio off flag will turn off RTUSBKickBulkOut function
+		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
+        	DBGPRINT(RT_DEBUG_ERROR, "4Set fRTMP_ADAPTER_RADIO_OFF ");
+	}	
+	DBGPRINT_RAW(RT_DEBUG_TEMP,"MlmeRadioOff \n");
+	RTUSBRejectPendingPackets(pAd);//reject all NDIS packets waiting in TX queue
+	RTUSBCleanUpDataBulkOutQueue(pAd);
+	MlmeSuspend(pAd);
+	DBGPRINT_RAW(RT_DEBUG_TEMP,"2MlmeRadioOff \n");
+	// Abort Tx
+	// Disable Rx
+	RTUSBWriteMACRegister(pAd, TXRX_CSR2, 1);
+	//Ask our device to complete any pending bulk in IRP.
+	while (( atomic_read(&pAd->PendingRx) > 0) || (pAd->BulkOutPending == TRUE))
+	{
+		if (atomic_read(&pAd->PendingRx) > 0)
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "BulkIn IRP Pending!!!\n");
+			RTUSB_VendorRequest(pAd,
+				0,
+				DEVICE_VENDOR_REQUEST_OUT,
+				0x0C,
+				0x0,
+				0x0,
+				NULL,
+				0);
+		}
+		
+		if (pAd->BulkOutPending == TRUE)
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "BulkOut IRP Pending!!!\n");
+			if (i == 0)
+			{
+				RTUSBCancelPendingBulkOutIRP(pAd);
+				i++;
+			}
+		}
+		
+		NdisMSleep(5);
+	}
+#if 1
+
+	// Turn off radio
+	RTUSBWriteMACRegister(pAd, MAC_CSR13, 0x2121);
+	RTUSBWriteMACRegister(pAd, MAC_CSR14, 0x2121);
+
+	if (pAd->PortCfg.LedMode == LED_MODE_ASUS)
+	{
+		RTUSBWriteMACRegister(pAd, MAC_CSR20, 0x0001); 		
+	}
+	
+	// Clean up old bss table
+	BssTableInit(&pAd->PortCfg.BssTab);
+	DBGPRINT(RT_DEBUG_TEMP,"<==MlmeRadioOff \n" );
+#endif
+}
+
+// IRQL = DISPATCH_LEVEL
+VOID MlmeRadioOn(
+    IN PRT2570ADAPTER pAd)
+{	
+	// Turn on radio
+	RTUSBWriteMACRegister(pAd, MAC_CSR13, 0x3100);
+	RTUSBWriteMACRegister(pAd, MAC_CSR14, 0x3f3b);
+
+	// Abort Tx
+	//steven:don't have this	RTMP_IO_WRITE32(pAd, TXCSR0, 0x08);
+	// Disable Rx
+	RTUSBWriteMACRegister(pAd, TXRX_CSR2, 1);
+
+	NICResetFromError(pAd);
+	// Clear Radio off flag
+	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
+	MlmeResume(pAd);
+	RTUSBBulkReceive(pAd);
+	RTUSBWriteMACRegister(pAd, TXRX_CSR2, 0x7e);
+	if (pAd->PortCfg.LedMode == LED_MODE_ASUS)
+	{
+		RTUSBWriteMACRegister(pAd, MAC_CSR20, 0x0003);
+	}
+}
+
+
+// ===========================================================================================
+// bss_table.c
+// ===========================================================================================
+
+
+/*! \brief initialize BSS table
+ *  \param p_tab pointer to the table
+ *  \return none
+ *  \pre
+ *  \post
+
+ IRQL = PASSIVE_LEVEL
+ IRQL = DISPATCH_LEVEL
+  
+ */
+VOID BssTableInit(
+    IN BSS_TABLE *Tab) 
+{
+    int i;
+
+    Tab->BssNr = 0;
+    for (i = 0; i < MAX_LEN_OF_BSS_TABLE; i++) 
+    {
+        memset(&Tab->BssEntry[i], 0, sizeof(BSS_ENTRY));
+    }
+}
+
+/*! \brief search the BSS table by SSID
+ *  \param p_tab pointer to the bss table
+ *  \param ssid SSID string 
+ *  \return index of the table, BSS_NOT_FOUND if not in the table
+ *  \pre
+ *  \post
+ *  \note search by sequential search
+
+ IRQL = DISPATCH_LEVEL
+ 
+ */
+ULONG BssTableSearch(
+    IN BSS_TABLE *Tab, 
+    IN PMACADDR Bssid) 
+{
+    UCHAR i;
+    
+    for (i = 0; i < Tab->BssNr; i++) 
+    {
+        //printf("comparing %s and %s\n", p_tab->bss[i].ssid, ssid);
+        if (MAC_ADDR_EQUAL(&(Tab->BssEntry[i].Bssid), Bssid)) 
+        { 
+            return i;
+        }
+    }
+    return (ULONG)BSS_NOT_FOUND;
+}
+
+// IRQL = DISPATCH_LEVEL
+VOID BssTableDeleteEntry(
+    IN OUT	BSS_TABLE *Tab, 
+    IN		PMACADDR Bssid) 
+{
+    UCHAR i, j;
+    
+    for (i = 0; i < Tab->BssNr; i++) 
+    {
+        //printf("comparing %s and %s\n", p_tab->bss[i].ssid, ssid);
+        if (MAC_ADDR_EQUAL(&(Tab->BssEntry[i].Bssid), Bssid)) 
+        {
+        	for (j = i; j < Tab->BssNr - 1; j++)
+        	{
+        		memcpy(&(Tab->BssEntry[j]), &(Tab->BssEntry[j + 1]), sizeof(BSS_ENTRY));
+        	}
+	        Tab->BssNr -= 1;
+            return;
+        }
+    }
+}
+
+UCHAR	ZeroSsid[32] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+/*! \brief
+ *  \param 
+ *  \return
+ *  \pre
+ *  \post
+	 
+ IRQL = DISPATCH_LEVEL
+ 
+ */
+VOID BssEntrySet(
+    IN	PRT2570ADAPTER	pAd, 
+    OUT BSS_ENTRY *pBss, 
+    IN MACADDR *pBssid, 
+    IN CHAR Ssid[], 
+    IN UCHAR SsidLen, 
+    IN UCHAR BssType, 
+    IN USHORT BeaconPeriod, 
+    IN BOOLEAN CfExist,
+    IN CF_PARM *pCfParm, 
+    IN USHORT AtimWin, 
+    IN USHORT CapabilityInfo, 
+    IN UCHAR Rates[], 
+    IN UCHAR RatesLen,
+    IN BOOLEAN ExtendedRateIeExist,
+    IN UCHAR Channel,
+    IN UCHAR Rssi,
+    IN LARGE_INTEGER TimeStamp,
+    IN UCHAR LengthVIE,
+    IN PNDIS_802_11_VARIABLE_IEs pVIE) 
+{
+    COPY_MAC_ADDR(&pBss->Bssid, pBssid);
+	// Default Hidden SSID to be TRUE, it will be turned to FALSE after coping SSID
+	pBss->Hidden = 1;	
+	if (SsidLen > 0)
+	{
+		// For hidden SSID AP, it might send beacon with SSID len equal to 0
+		// Or send beacon /probe response with SSID len matching real SSID length,
+		// but SSID is all zero. such as "00-00-00-00" with length 4.
+		// We have to prevent this case overwrite correct table
+		if (memcmp(Ssid, ZeroSsid, SsidLen))
+		{
+    		memcpy(pBss->Ssid, Ssid, SsidLen);
+    		pBss->SsidLen = SsidLen;
+			pBss->Hidden = 0;
+		}
+	}
+    pBss->BssType = BssType;
+    pBss->BeaconPeriod = BeaconPeriod;
+    if (BssType == BSS_INFRA) 
+    {
+        if (CfExist) 
+        {
+            pBss->CfpCount = pCfParm->CfpCount;
+            pBss->CfpPeriod = pCfParm->CfpPeriod;
+            pBss->CfpMaxDuration = pCfParm->CfpMaxDuration;
+            pBss->CfpDurRemaining = pCfParm->CfpDurRemaining;
+        }
+    } 
+    else 
+    {
+        pBss->AtimWin = AtimWin;
+    }
+
+    pBss->CapabilityInfo = CapabilityInfo;
+	// The privacy bit indicate security is ON, it maight be WEP, TKIP or AES
+	// Combine with AuthMode, they will decide the connection methods.
+    pBss->Privacy = CAP_IS_PRIVACY_ON(pBss->CapabilityInfo);
+    memcpy(pBss->Rates, Rates, RatesLen);
+    pBss->RatesLen = RatesLen;
+    pBss->ExtendedRateIeExist = ExtendedRateIeExist;
+    pBss->Channel = Channel;
+    pBss->Rssi = Rssi;
+
+	// New for microsoft Fixed IEs
+	memcpy(pBss->FixIEs.Timestamp, &TimeStamp, 8);
+	pBss->FixIEs.BeaconInterval = BeaconPeriod;
+	pBss->FixIEs.Capabilities = CapabilityInfo;
+
+	// New for microsoft Variable IEs
+	if (LengthVIE != 0)
+	{
+		pBss->VarIELen = LengthVIE;
+		memcpy(pBss->VarIEs, pVIE, pBss->VarIELen);
+		BssCipherParse(pBss);
+	}
+	else
+	{
+		pBss->VarIELen = 0;
+		// No SSN ID, if security is on, this is WEP algorithm
+		if  (pBss->Privacy)
+			pBss->WepStatus = Ndis802_11WEPEnabled;
+		// No SSN ID, security is also off.
+		else
+			pBss->WepStatus = Ndis802_11WEPDisabled;
+	}
+}
+
+/*! 
+ *  \brief insert an entry into the bss table
+ *  \param p_tab The BSS table
+ *  \param Bssid BSSID
+ *  \param ssid SSID
+ *  \param ssid_len Length of SSID
+ *  \param bss_type
+ *  \param beacon_period
+ *  \param timestamp
+ *  \param p_cf
+ *  \param atim_win
+ *  \param cap
+ *  \param rates
+ *  \param rates_len
+ *  \param channel_idx
+ *  \return none
+ *  \pre
+ *  \post
+ *  \note If SSID is identical, the old entry will be replaced by the new one
+	 
+ IRQL = DISPATCH_LEVEL
+ 
+ */
+ULONG BssTableSetEntry(
+    IN	PRT2570ADAPTER	pAd, 
+    OUT BSS_TABLE *Tab, 
+    IN MACADDR *Bssid, 
+    IN CHAR Ssid[], 
+    IN UCHAR SsidLen, 
+    IN UCHAR BssType, 
+    IN USHORT BeaconPeriod, 
+    IN BOOLEAN CfExist, 
+    IN CF_PARM *CfParm, 
+    IN USHORT AtimWin, 
+    IN USHORT CapabilityInfo, 
+    IN UCHAR Rates[],
+    IN UCHAR RatesLen,
+    IN BOOLEAN ExtendedRateIeExist,
+    IN UCHAR ChannelNo,
+    IN UCHAR Rssi,
+    IN LARGE_INTEGER TimeStamp,
+    IN UCHAR LengthVIE,
+    IN PNDIS_802_11_VARIABLE_IEs pVIE)
+{
+    ULONG   Idx;
+
+    Idx = BssTableSearch(Tab, Bssid);
+    if (Idx == BSS_NOT_FOUND) 
+    {
+        if (Tab->BssNr >= MAX_LEN_OF_BSS_TABLE)
+            return BSS_NOT_FOUND;
+        Idx = Tab->BssNr;
+        BssEntrySet(pAd, &Tab->BssEntry[Idx], Bssid, Ssid, SsidLen, BssType, BeaconPeriod,
+                    CfExist, CfParm, AtimWin, CapabilityInfo, Rates, RatesLen, ExtendedRateIeExist,
+                    ChannelNo, Rssi, TimeStamp, LengthVIE, pVIE);
+        Tab->BssNr++;
+    } 
+    else
+    {
+        BssEntrySet(pAd, &Tab->BssEntry[Idx], Bssid, Ssid, SsidLen, BssType, BeaconPeriod,
+                    CfExist, CfParm, AtimWin, CapabilityInfo, Rates, RatesLen, ExtendedRateIeExist,
+                    ChannelNo, Rssi, TimeStamp, LengthVIE, pVIE);
+    }
+	//DBGPRINT_RAW(RT_DEBUG_TEMP," %s   Wep %d auth %d \n",Ssid, Tab->BssEntry[Idx].WepStatus, Tab->BssEntry[Idx].AuthMode);
+    
+    return Idx;
+}
+
+
+// IRQL = DISPATCH_LEVEL
+VOID BssTableSsidSort(
+    IN	PRT2570ADAPTER	pAd, 
+    OUT BSS_TABLE *OutTab, 
+    IN  CHAR Ssid[], 
+    IN  UCHAR SsidLen) 
+{
+    INT i;
+    
+    BssTableInit(OutTab);
+
+    for (i = 0; i < pAd->PortCfg.BssTab.BssNr; i++) 
+    {
+        BSS_ENTRY *pInBss = &pAd->PortCfg.BssTab.BssEntry[i];
+        
+        if ((pInBss->BssType == pAd->PortCfg.BssType) && 
+			((pInBss->SsidLen==SsidLen) && (memcmp(pInBss->Ssid, Ssid, (ULONG) SsidLen) == 0)))
+        {
+            BSS_ENTRY *pOutBss = &OutTab->BssEntry[OutTab->BssNr];
+			// New for WPA2
+			// Check the Authmode first
+			if (pAd->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+			{
+				// Check AuthMode and AuthModeAux for matching, in case AP support dual-mode
+				if ((pAd->PortCfg.AuthMode != pInBss->AuthMode) && (pAd->PortCfg.AuthMode != pInBss->AuthModeAux))
+					// None matched
+					continue;
+				
+				// Check cipher suite, AP must have more secured cipher than station setting
+				if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
+				{
+					// If it's not mixed mode, we should only let BSS pass with the same encryption
+					if (pInBss->WPA.bMixMode == FALSE)
+						if (pAd->PortCfg.WepStatus != pInBss->WPA.GroupCipher)
+							continue;						
+				
+					// check group cipher
+					if (pAd->PortCfg.WepStatus < pInBss->WPA.GroupCipher)
+						continue;
+
+					// check pairwise cipher, skip if none matched
+					// If profile set to AES, let it pass without question.
+					// If profile set to TKIP, we must find one mateched
+					if ((pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) && 
+						(pAd->PortCfg.WepStatus != pInBss->WPA.PairCipher) && 
+						(pAd->PortCfg.WepStatus != pInBss->WPA.PairCipherAux))
+						continue;						
+				}
+				else if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+				{
+					// If it's not mixed mode, we should only let BSS pass with the same encryption
+					if (pInBss->WPA2.bMixMode == FALSE)
+						if (pAd->PortCfg.WepStatus != pInBss->WPA2.GroupCipher)
+							continue;						
+				
+					// check group cipher
+					if (pAd->PortCfg.WepStatus < pInBss->WPA2.GroupCipher)
+						continue;
+
+					// check pairwise cipher, skip if none matched
+					// If profile set to AES, let it pass without question.
+					// If profile set to TKIP, we must find one mateched
+					if ((pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) && 
+						(pAd->PortCfg.WepStatus != pInBss->WPA2.PairCipher) && 
+						(pAd->PortCfg.WepStatus != pInBss->WPA2.PairCipherAux))
+						continue;						
+				}
+			}			
+			// Bss Type matched, SSID matched. 
+			// We will check wepstatus for qualification Bss
+			else if (pAd->PortCfg.WepStatus != pInBss->WepStatus)
+					continue;
+			
+			// Since the AP is using hidden SSID, and we are trying to connect to ANY
+			// It definitely will fail. So, skip it.
+			// CCX also require not even try to connect it!!
+			if (SsidLen == 0)
+				continue;
+			
+            // copy matching BSS from InTab to OutTab
+            memcpy(pOutBss, pInBss, sizeof(BSS_ENTRY));
+            
+            OutTab->BssNr++;
+        }
+        else if ((pInBss->BssType == pAd->PortCfg.BssType) && (SsidLen == 0))
+        {
+            BSS_ENTRY *pOutBss = &OutTab->BssEntry[OutTab->BssNr];
+
+			// New for WPA2
+			// Check the Authmode first
+			if (pAd->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+			{
+				// Check AuthMode and AuthModeAux for matching, in case AP support dual-mode
+				if ((pAd->PortCfg.AuthMode != pInBss->AuthMode) && (pAd->PortCfg.AuthMode != pInBss->AuthModeAux))
+					// None matched
+					continue;
+			
+				// Check cipher suite, AP must have more secured cipher than station setting
+				if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
+				{
+					// If it's not mixed mode, we should only let BSS pass with the same encryption
+					if (pInBss->WPA.bMixMode == FALSE)
+						if (pAd->PortCfg.WepStatus != pInBss->WPA.GroupCipher)
+							continue;						
+				
+					// check group cipher
+					if (pAd->PortCfg.WepStatus < pInBss->WPA.GroupCipher)
+						continue;
+            
+					// check pairwise cipher, skip if none matched
+					// If profile set to AES, let it pass without question.
+					// If profile set to TKIP, we must find one mateched
+					if ((pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) && 
+						(pAd->PortCfg.WepStatus != pInBss->WPA.PairCipher) && 
+						(pAd->PortCfg.WepStatus != pInBss->WPA.PairCipherAux))
+						continue;						
+				}
+				else if ((pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2) || (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+				{
+					// If it's not mixed mode, we should only let BSS pass with the same encryption
+					if (pInBss->WPA2.bMixMode == FALSE)
+						if (pAd->PortCfg.WepStatus != pInBss->WPA2.GroupCipher)
+							continue;
+				
+					// check group cipher
+					if (pAd->PortCfg.WepStatus < pInBss->WPA2.GroupCipher)
+						continue;
+
+					// check pairwise cipher, skip if none matched
+					// If profile set to AES, let it pass without question.
+					// If profile set to TKIP, we must find one mateched
+					if ((pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) && 
+						(pAd->PortCfg.WepStatus != pInBss->WPA2.PairCipher) && 
+						(pAd->PortCfg.WepStatus != pInBss->WPA2.PairCipherAux))
+						continue;						
+				}
+			}
+			// Bss Type matched, SSID matched. 
+			// We will check wepstatus for qualification Bss
+			else if (pAd->PortCfg.WepStatus != pInBss->WepStatus)
+					continue;
+			
+            // copy matching BSS from InTab to OutTab
+            memcpy(pOutBss, pInBss, sizeof(BSS_ENTRY));
+            
+            OutTab->BssNr++;
+        }
+		
+		if (OutTab->BssNr >= MAX_LEN_OF_BSS_TABLE)
+			break;
+		
+    }
+    BssTableSortByRssi(OutTab);
+}
+
+
+
+
+// IRQL = DISPATCH_LEVEL
+VOID BssTableSortByRssi(
+    IN OUT BSS_TABLE *OutTab) 
+{
+    INT       i, j;
+    BSS_ENTRY TmpBss;
+
+    for (i = 0; i < OutTab->BssNr - 1; i++) 
+    {
+        for (j = i+1; j < OutTab->BssNr; j++) 
+        {
+            if (OutTab->BssEntry[j].Rssi > OutTab->BssEntry[i].Rssi) 
+            {
+                memcpy(&TmpBss, &OutTab->BssEntry[j], sizeof(BSS_ENTRY));
+                memcpy(&OutTab->BssEntry[j], &OutTab->BssEntry[i], sizeof(BSS_ENTRY));
+                memcpy(&OutTab->BssEntry[i], &TmpBss, sizeof(BSS_ENTRY));
+            }
+        }
+    }
+}
+
+extern	UCHAR	RSN_OUI[];		// in sanity.c
+
+VOID		BssCipherParse(
+	IN OUT	PBSS_ENTRY	pBss)
+{
+#if 1
+	PBEACON_EID_STRUCT				pEid;
+	PUCHAR							pTmp;
+	PRSN_IE_HEADER_STRUCT			pRsnHeader;
+	PCIPHER_SUITE_STRUCT			pCipher;
+	PAKM_SUITE_STRUCT				pAKM;
+	USHORT							Count;
+	INT								Length;
+	NDIS_802_11_ENCRYPTION_STATUS	TmpCipher;
+
+	// Set default to disable & open authentication before parsing variable IE
+	pBss->WepStatus     = Ndis802_11WEPDisabled;
+	pBss->AuthMode      = Ndis802_11AuthModeOpen;
+	pBss->AuthModeAux   = Ndis802_11AuthModeOpen;
+
+	// Init WPA setting
+	pBss->WPA.PairCipher    = Ndis802_11WEPDisabled;
+	pBss->WPA.PairCipherAux = Ndis802_11WEPDisabled;
+	pBss->WPA.GroupCipher   = Ndis802_11WEPDisabled;
+	pBss->WPA.RsnCapability = 0;
+	pBss->WPA.bMixMode      = FALSE;
+
+	// Init WPA2 setting
+	pBss->WPA2.PairCipher    = Ndis802_11WEPDisabled;
+	pBss->WPA2.PairCipherAux = Ndis802_11WEPDisabled;
+	pBss->WPA2.GroupCipher   = Ndis802_11WEPDisabled;
+	pBss->WPA2.RsnCapability = 0;
+	pBss->WPA2.bMixMode      = FALSE;
+	Length = (INT) pBss->VarIELen;
+
+	while (Length > 0)
+	{
+		// Parse cipher suite base on WPA1 & WPA2, they should be parsed differently
+		pTmp = ((PUCHAR) pBss->VarIEs) + pBss->VarIELen - Length;
+		pEid = (PBEACON_EID_STRUCT) pTmp;
+		switch (pEid->Eid)
+		{
+			case IE_WPA:
+				// Skip OUI, version, and multicast suite
+				// This part should be improved in the future when AP supported multiple cipher suite.
+				// For now, it's OK since almost all APs have fixed cipher suite supported.
+				// pTmp = (PUCHAR) pEid->Octet;
+				pTmp   += 11;
+
+				// Cipher Suite Selectors from Spec P802.11i/D3.2 P26.
+				//  Value      Meaning
+				//  0           None 
+				//  1           WEP-40
+				//  2           Tkip
+				//  3           WRAP
+				//  4           AES
+				//  5           WEP-104
+				// Parse group cipher
+				switch (*pTmp)
+				{
+					case 1:
+					case 5:	// Although WEP is not allowed in WPA related auth mode, we parse it anyway
+						pBss->WPA.GroupCipher = Ndis802_11Encryption1Enabled;
+						break;
+					case 2:
+						pBss->WPA.GroupCipher = Ndis802_11Encryption2Enabled;
+						break;
+					case 4:
+						pBss->WPA.GroupCipher = Ndis802_11Encryption3Enabled;
+						break;
+					default:
+						break;
+				}
+				// number of unicast suite
+				pTmp   += 1;
+				
+				// skip all unicast cipher suites
+				Count = *(PUSHORT) pTmp;				
+				pTmp   += sizeof(USHORT);
+
+				// Parsing all unicast cipher suite
+				while (Count > 0)
+				{
+					// Skip OUI
+					pTmp += 3;
+					TmpCipher = Ndis802_11WEPDisabled;
+					switch (*pTmp)
+					{
+						case 1:
+						case 5: // Although WEP is not allowed in WPA related auth mode, we parse it anyway
+							TmpCipher = Ndis802_11Encryption1Enabled;
+							break;
+						case 2:
+							TmpCipher = Ndis802_11Encryption2Enabled;
+							break;
+						case 4:
+							TmpCipher = Ndis802_11Encryption3Enabled;
+							break;
+						default:
+							break;
+					}
+					if (TmpCipher > pBss->WPA.PairCipher)
+					{
+						// Move the lower cipher suite to PairCipherAux
+						pBss->WPA.PairCipherAux = pBss->WPA.PairCipher;
+						pBss->WPA.PairCipher    = TmpCipher;
+					}
+					else
+					{
+						pBss->WPA.PairCipherAux = TmpCipher;
+					}
+					pTmp++;
+					Count--;
+				}
+				
+				// 4. get AKM suite counts
+				Count   = *(PUSHORT) pTmp;
+				pTmp   += sizeof(USHORT);
+				pTmp   += 3;
+				
+				switch (*pTmp)
+				{
+					case 1:
+						// Set AP support WPA mode
+						if (pBss->AuthMode == Ndis802_11AuthModeOpen)
+							pBss->AuthMode = Ndis802_11AuthModeWPA;
+						else
+							pBss->AuthModeAux = Ndis802_11AuthModeWPA;
+						break;
+					case 2:
+						// Set AP support WPA mode
+						if (pBss->AuthMode == Ndis802_11AuthModeOpen)
+							pBss->AuthMode = Ndis802_11AuthModeWPAPSK;
+						else
+							pBss->AuthModeAux = Ndis802_11AuthModeWPAPSK;
+						break;
+					default:
+						break;
+				}
+				pTmp   += 1;
+
+				// Fixed for WPA-None
+				if (pBss->BssType == BSS_INDEP)
+				{
+					pBss->AuthMode    = Ndis802_11AuthModeWPANone;
+					pBss->AuthModeAux = Ndis802_11AuthModeWPANone;
+					pBss->WepStatus   = pBss->WPA.GroupCipher;
+					// Patched bugs for old driver
+					if (pBss->WPA.PairCipherAux == Ndis802_11WEPDisabled)
+						pBss->WPA.PairCipherAux = pBss->WPA.GroupCipher;
+				}
+				else
+					pBss->WepStatus   = pBss->WPA.PairCipher;					
+				
+				// Check the Pair & Group, if different, turn on mixed mode flag
+				if (pBss->WPA.GroupCipher != pBss->WPA.PairCipher)
+					pBss->WPA.bMixMode = TRUE;
+				
+				break;
+
+			case IE_RSN:
+				pRsnHeader = (PRSN_IE_HEADER_STRUCT) pTmp;
+				
+				// 0. Version must be 1
+				if (pRsnHeader->Version != 1)
+					break;
+				pTmp   += sizeof(RSN_IE_HEADER_STRUCT);
+
+				// 1. Check group cipher
+				pCipher = (PCIPHER_SUITE_STRUCT) pTmp;
+				if (memcmp(pTmp, RSN_OUI, 3) != 0)
+					break;
+
+				// Parse group cipher
+				switch (pCipher->Type)
+				{
+					case 1:
+					case 5:	// Although WEP is not allowed in WPA related auth mode, we parse it anyway
+						pBss->WPA2.GroupCipher = Ndis802_11Encryption1Enabled;
+						break;
+					case 2:
+						pBss->WPA2.GroupCipher = Ndis802_11Encryption2Enabled;
+						break;
+					case 4:
+						pBss->WPA2.GroupCipher = Ndis802_11Encryption3Enabled;
+						break;
+					default:
+						break;
+				}
+				// set to correct offset for next parsing
+				pTmp   += sizeof(CIPHER_SUITE_STRUCT);
+
+				// 2. Get pairwise cipher counts
+				Count = *(PUSHORT) pTmp;
+				pTmp   += sizeof(USHORT);
+				
+				// 3. Get pairwise cipher
+				// Parsing all unicast cipher suite
+				while (Count > 0)
+				{
+					// Skip OUI
+					pCipher = (PCIPHER_SUITE_STRUCT) pTmp;
+					TmpCipher = Ndis802_11WEPDisabled;
+					switch (pCipher->Type)
+					{
+						case 1:
+						case 5: // Although WEP is not allowed in WPA related auth mode, we parse it anyway
+							TmpCipher = Ndis802_11Encryption1Enabled;
+							break;
+						case 2:
+							TmpCipher = Ndis802_11Encryption2Enabled;
+							break;
+						case 4:
+							TmpCipher = Ndis802_11Encryption3Enabled;
+							break;
+						default:
+							break;
+					}
+					if (TmpCipher > pBss->WPA2.PairCipher)
+					{
+						// Move the lower cipher suite to PairCipherAux
+						pBss->WPA2.PairCipherAux = pBss->WPA2.PairCipher;
+						pBss->WPA2.PairCipher    = TmpCipher;
+					}
+					else
+					{
+						pBss->WPA2.PairCipherAux = TmpCipher;
+					}
+					pTmp += sizeof(CIPHER_SUITE_STRUCT);
+					Count--;
+				}
+				
+				// 4. get AKM suite counts
+				Count   = *(PUSHORT) pTmp;
+				pTmp   += sizeof(USHORT);
+
+				// 5. Get AKM ciphers
+				pAKM = (PAKM_SUITE_STRUCT) pTmp;
+				if (memcmp(pTmp, RSN_OUI, 3) != 0)
+					break;
+
+				switch (pAKM->Type)
+				{
+					case 1:
+						// Set AP support WPA mode
+						if (pBss->AuthMode == Ndis802_11AuthModeOpen)
+							pBss->AuthMode = Ndis802_11AuthModeWPA2;
+						else
+							pBss->AuthModeAux = Ndis802_11AuthModeWPA2;
+						break;
+					case 2:
+						// Set AP support WPA mode
+						if (pBss->AuthMode == Ndis802_11AuthModeOpen)
+							pBss->AuthMode = Ndis802_11AuthModeWPA2PSK;
+						else
+							pBss->AuthModeAux = Ndis802_11AuthModeWPA2PSK;
+						break;
+					default:
+						break;
+				}
+				pTmp   += (Count * sizeof(AKM_SUITE_STRUCT));
+				
+				// Fixed for WPA-None
+				if (pBss->BssType == BSS_INDEP)
+				{
+					pBss->AuthMode = Ndis802_11AuthModeWPANone;
+					pBss->AuthModeAux = Ndis802_11AuthModeWPANone;
+					pBss->WPA.PairCipherAux = pBss->WPA2.PairCipherAux;
+					pBss->WPA.GroupCipher   = pBss->WPA2.GroupCipher;
+					pBss->WepStatus         = pBss->WPA.GroupCipher;
+					// Patched bugs for old driver
+					if (pBss->WPA.PairCipherAux == Ndis802_11WEPDisabled)
+						pBss->WPA.PairCipherAux = pBss->WPA.GroupCipher;
+				}
+				pBss->WepStatus   = pBss->WPA2.PairCipher;					
+				
+				// 6. Get RSN capability
+				pBss->WPA2.RsnCapability = *(PUSHORT) pTmp;
+				pTmp += sizeof(USHORT);
+				
+				// Check the Pair & Group, if different, turn on mixed mode flag
+				if (pBss->WPA2.GroupCipher != pBss->WPA2.PairCipher)
+					pBss->WPA2.bMixMode = TRUE;
+				
+				break;
+
+			default:
+				break;
+		}
+		Length -= (pEid->Len + 2);
+	}
+#endif
+	return;
+}
+
+// ===========================================================================================
+// mac_table.c
+// ===========================================================================================
+
+/*! \brief generates a random mac address value for IBSS BSSID
+ *  \param Addr the bssid location
+ *  \return none
+ *  \pre
+ *  \post
+ */
+VOID MacAddrRandomBssid(
+    IN PRT2570ADAPTER pAd, 
+    OUT MACADDR *Addr) 
+{
+    INT i;
+
+    for (i = 0; i < MAC_ADDR_LEN; i++) 
+    {
+        Addr->Octet[i] = RandomByte(pAd);
+    }
+    
+    Addr->Octet[0] = (Addr->Octet[0] & 0xfe) | 0x02;  // the first 2 bits must be 01xxxxxxxx
+}
+
+
+/*! \brief init the management mac frame header
+ *  \param p_hdr mac header
+ *  \param subtype subtype of the frame
+ *  \param p_ds destination address, don't care if it is a broadcast address
+ *  \return none
+ *  \pre the station has the following information in the pAd->PortCfg
+ *   - bssid
+ *   - station address
+ *  \post
+ *  \note this function initializes the following field
+
+ IRQL = PASSIVE_LEVEL
+ IRQL = DISPATCH_LEVEL
+  
+ */
+VOID MgtMacHeaderInit(
+    IN	PRT2570ADAPTER	pAd, 
+    IN OUT PMACHDR Hdr, 
+    IN UCHAR Subtype, 
+    IN UCHAR ToDs, 
+    IN PMACADDR Ds, 
+    IN PMACADDR Bssid) 
+{
+    memset(Hdr, 0, sizeof(MACHDR));
+    Hdr->Type = BTYPE_MGMT;
+    Hdr->SubType = Subtype;
+    Hdr->Tods = ToDs;
+    COPY_MAC_ADDR(&Hdr->Addr1, Ds);
+    COPY_MAC_ADDR(&Hdr->Addr2, &pAd->CurrentAddress);
+    COPY_MAC_ADDR(&Hdr->Addr3, Bssid);
+}
+
+
+
+// ===========================================================================================
+// mem_mgmt.c
+// ===========================================================================================
+
+/*!***************************************************************************
+ * This routine build an outgoing frame, and fill all information specified 
+ * in argument list to the frame body. The actual frame size is the summation 
+ * of all arguments.
+ * input params:
+ *      Buffer - pointer to a pre-allocated memory segment
+ *      args - a list of <int arg_size, arg> pairs.
+ *      NOTE NOTE NOTE!!!! the last argument must be NULL, otherwise this
+ *                         function will FAIL!!!
+ * return:
+ *      Size of the buffer
+ * usage:  
+ *      MakeOutgoingFrame(Buffer, output_length, 2, &fc, 2, &dur, 6, p_addr1, 6,p_addr2, END_OF_ARGS);
+
+ IRQL = PASSIVE_LEVEL
+ IRQL = DISPATCH_LEVEL
+  
+ ****************************************************************************/
+ULONG MakeOutgoingFrame(
+    OUT CHAR *Buffer, 
+    OUT ULONG *FrameLen, ...) 
+{
+    CHAR   *p;
+    int     leng;
+    ULONG   TotLeng;
+    va_list Args;
+
+    // calculates the total length
+    TotLeng = 0;
+    va_start(Args, FrameLen);
+    do 
+    {
+        leng = va_arg(Args, int);
+        if (leng == END_OF_ARGS) 
+        {
+            break;
+        }
+        p = va_arg(Args, PVOID);
+        memcpy(&Buffer[TotLeng], p, leng);
+        TotLeng = TotLeng + leng;
+    } while(TRUE);
+
+    va_end(Args); /* clean up */
+    *FrameLen = TotLeng;
+    return TotLeng;
+}
+
+// ===========================================================================================
+// mlme_queue.c
+// ===========================================================================================
+
+/*! \brief	Initialize The MLME Queue, used by MLME Functions
+ *	\param	*Queue	   The MLME Queue
+ *	\return Always	   Return NDIS_STATE_SUCCESS in this implementation
+ *	\pre
+ *	\post
+ *	\note	Because this is done only once (at the init stage), no need to be locked
+ */
+NDIS_STATUS MlmeQueueInit(
+	IN MLME_QUEUE *Queue) 
+{
+	INT i;
+
+	DBGPRINT(RT_DEBUG_INFO,"--> MlmeQueueInit\n");
+
+	NdisAllocateSpinLock(&Queue->Lock);
+	Queue->Num	= 0;
+	Queue->Head = 0;
+	Queue->Tail = 0;
+
+	for (i = 0; i < MAX_LEN_OF_MLME_QUEUE; i++) 
+	{
+		Queue->Entry[i].Occupied = FALSE;
+		Queue->Entry[i].MsgLen = 0;
+		memset(Queue->Entry[i].Msg, 0, MAX_LEN_OF_MLME_BUFFER);
+	}
+
+	DBGPRINT(RT_DEBUG_INFO,"<-- MlmeQueueInit\n");
+	return NDIS_STATUS_SUCCESS;
+}
+
+BOOLEAN MlmeEnqueue(
+    IN PRT2570ADAPTER pAd, 
+	IN ULONG Machine, 
+	IN ULONG MsgType, 
+	IN ULONG MsgLen, 
+	IN VOID *Msg) 
+{
+	INT Tail;
+	MLME_QUEUE	*Queue = (MLME_QUEUE *)&pAd->Mlme.Queue;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if (pAd->MLMEThr_pid > 0)
+#else
+	if (pAd->MLMEThr_active)
+#endif
+	{
+
+		if (MlmeQueueFull(Queue)) 
+		{
+			DBGPRINT(RT_DEBUG_ERROR,"MlmeEnqueue full, msg dropped and may corrupt MLME\n");
+			return FALSE;
+		}
+
+		NdisAcquireSpinLock(&(Queue->Lock));
+		Tail = Queue->Tail;
+		Queue->Tail++;
+		Queue->Num++;
+		if (Queue->Tail == MAX_LEN_OF_MLME_QUEUE) 
+		{
+			Queue->Tail = 0;
+		}
+		NdisReleaseSpinLock(&(Queue->Lock));
+		DBGPRINT(RT_DEBUG_INFO,"MlmeEnqueue, num=%d\n",Queue->Num);
+	 
+		Queue->Entry[Tail].Occupied = TRUE;
+		Queue->Entry[Tail].Machine = Machine;
+		Queue->Entry[Tail].MsgType = MsgType;
+		Queue->Entry[Tail].MsgLen  = MsgLen;
+		memcpy(Queue->Entry[Tail].Msg, Msg, MsgLen);
+	}
+	return TRUE;
+}
+
+
+/*! \brief   This function is used when Recv gets a MLME message
+ *  \param  *Queue           The MLME Queue
+ *  \param   TimeStampHigh   The upper 32 bit of timestamp
+ *  \param   TimeStampLow    The lower 32 bit of timestamp
+ *  \param   Rssi            The receiving RSSI strength
+ *  \param   MsgLen          The length of the message
+ *  \param  *Msg             The message pointer
+ *  \return  TRUE if everything ok, FALSE otherwise (like Queue Full)
+ *  \pre
+ *  \post
+ 
+ IRQL = DISPATCH_LEVEL
+ 
+ */
+BOOLEAN MlmeEnqueueForRecv(
+    IN PRT2570ADAPTER	pAd, 
+    OUT MLME_QUEUE *Queue, 
+    IN UCHAR Rssi, 
+    IN ULONG MsgLen, 
+    IN VOID *Msg) 
+{
+    INT          Tail, Machine;
+    MACFRAME    *Fr = (MACFRAME *)Msg;
+    ULONG        MsgType;
+
+	//DBGPRINT(RT_DEBUG_ERROR,"MlmeEnqueueForRecv ");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if((pAd->MLMEThr_pid <= 0))
+		return FALSE;
+#else
+	if(!pAd->MLMEThr_active)
+		return FALSE;
+#endif
+	// First check the size, it MUST not exceed the mlme queue size
+	if (MsgLen > MAX_LEN_OF_MLME_BUFFER)
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "MlmeEnqueueForRecv mlme frame too large, size = %d \n", MsgLen);
+		return FALSE;
+	}
+	
+	if ((RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)) ||
+		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS)) ||
+		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS)) ||
+		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)))
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "MlmeEnqueueForRecv (not in operation) Flag = 0x%x\n", pAd->Flags);
+		return FALSE;
+	}
+
+    if (MlmeQueueFull(Queue)) 
+    {
+        //DBGPRINT(RT_DEBUG_ERROR, "MlmeEnqueueForRecv (queue full error) \n");
+        return FALSE;
+    }
+
+    if (!MsgTypeSubst(pAd, Fr, &Machine, &MsgType)) 
+    {
+        DBGPRINT(RT_DEBUG_ERROR, "MlmeEnqueueForRecv (drop mgmt->subtype=%d)\n",Fr->Hdr.SubType);
+        return FALSE;
+    }
+    
+    // OK, we got all the informations, it is time to put things into queue
+    NdisAcquireSpinLock(&(Queue->Lock));
+    Tail = Queue->Tail;
+    Queue->Tail++;
+    Queue->Num++;
+    if (Queue->Tail == MAX_LEN_OF_MLME_QUEUE) 
+    {
+        Queue->Tail = 0;
+    }
+    NdisReleaseSpinLock(&(Queue->Lock));
+    DBGPRINT(RT_DEBUG_INFO, "MlmeEnqueueForRecv, num=%d\n",Queue->Num);
+    
+    Queue->Entry[Tail].Occupied = TRUE;
+    Queue->Entry[Tail].Machine = Machine;
+    Queue->Entry[Tail].MsgType = MsgType;
+    Queue->Entry[Tail].MsgLen  = MsgLen;
+
+    Queue->Entry[Tail].Rssi = Rssi;
+    memcpy(Queue->Entry[Tail].Msg, Msg, MsgLen);
+    
+	RTUSBUp(pAd, (&(pAd->mlme_semaphore)));
+
+    return TRUE;
+}
+/*! \brief   Dequeue a message from the MLME Queue
+ *  \param  *Queue    The MLME Queue
+ *  \param  *Elem     The message dequeued from MLME Queue
+ *  \return  TRUE if the Elem contains something, FALSE otherwise
+ *  \pre
+ *  \post
+ 
+ IRQL = DISPATCH_LEVEL
+ 
+ */
+BOOLEAN MlmeDequeue(
+    IN MLME_QUEUE *Queue, 
+    OUT MLME_QUEUE_ELEM **Elem) 
+{
+    NdisAcquireSpinLock(&(Queue->Lock));
+	if (Queue->Num == 0)
+	{
+		NdisReleaseSpinLock(&(Queue->Lock));
+		return FALSE; //Empty
+	}
+
+    *Elem = &(Queue->Entry[Queue->Head]);
+    Queue->Num--;
+    Queue->Head++;
+    if (Queue->Head == MAX_LEN_OF_MLME_QUEUE) 
+    {
+        Queue->Head = 0;
+    }
+    
+    NdisReleaseSpinLock(&(Queue->Lock));
+    DBGPRINT(RT_DEBUG_INFO, "MlmeDequeue, num=%d\n",Queue->Num);
+
+    return TRUE;
+}
+
+// IRQL = DISPATCH_LEVEL
+VOID	MlmeRestartStateMachine(
+    IN	PRT2570ADAPTER	pAd)
+{
+
+	DBGPRINT(RT_DEBUG_TRACE, "==> MlmeRestartStateMachine\n");
+
+	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS);
+
+	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
+	if(pAd->Mlme.Running) 
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "<== MlmeRestartStateMachine, Mlme is Runing[Queue=%d]!\n", pAd->Mlme.Queue.Num);
+		NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
+		return;
+	} 
+	pAd->Mlme.Running = TRUE;
+	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
+
+	MlmeQueueDestroy(&pAd->Mlme.Queue);
+
+	// Cancel all timer events
+	// Be careful to cancel new added timer
+	RTMPCancelTimer(&pAd->Mlme.AssocAux.AssocTimer);
+	RTMPCancelTimer(&pAd->Mlme.AssocAux.ReassocTimer);
+	RTMPCancelTimer(&pAd->Mlme.AssocAux.DisassocTimer);
+	RTMPCancelTimer(&pAd->Mlme.AuthAux.AuthTimer);
+	//    RTMPCancelTimer(&pAd->Mlme.AuthRspAux.AuthRspTimer, &Cancelled);
+	RTMPCancelTimer(&pAd->Mlme.SyncAux.BeaconTimer);
+	RTMPCancelTimer(&pAd->Mlme.SyncAux.ScanTimer);
+
+	// Set all state machines back IDLE
+	pAd->Mlme.CntlMachine.CurrState    = CNTL_IDLE;
+	pAd->Mlme.AssocMachine.CurrState   = ASSOC_IDLE;
+	pAd->Mlme.AuthMachine.CurrState    = AUTH_REQ_IDLE;
+	pAd->Mlme.AuthRspMachine.CurrState = AUTH_RSP_IDLE;
+	pAd->Mlme.SyncMachine.CurrState    = SYNC_IDLE;
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS);//steven:for test
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_REASSOC_IN_PROGRESS);//steven:for test
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);//steven:for test
+
+	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS);
+
+	// Remove running state
+	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
+	pAd->Mlme.Running = FALSE;
+	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<== MlmeRestartStateMachine\n");
+}
+
+VOID	MlmePostRestartStateMachine(
+    IN	PRT2570ADAPTER	pAd)
+{
+	//
+	// Flag fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS will be clear at MlmeHandler
+	// when required to do MLME Reset!
+	// Since MlmeRestartStateMachine will do nothing when Mlme is running.
+	//
+	while (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS))
+		NdisMSleep(100);
+
+	// Change back to original channel in case of doing scan
+	AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
+	AsicLockChannel(pAd, pAd->PortCfg.Channel);
+
+	// Resume MSDU which is turned off durning scan
+	RTUSBResumeMsduTransmission(pAd);
+}
+
+/*! \brief  test if the MLME Queue is empty
+ *  \param  *Queue    The MLME Queue
+ *  \return TRUE if the Queue is empty, FALSE otherwise
+ *  \pre
+ *  \post
+ 
+ IRQL = DISPATCH_LEVEL
+ 
+ */
+BOOLEAN MlmeQueueEmpty(
+    IN MLME_QUEUE *Queue) 
+{
+    BOOLEAN Ans;
+
+    NdisAcquireSpinLock(&(Queue->Lock));
+    Ans = (Queue->Num == 0);
+    NdisReleaseSpinLock(&(Queue->Lock));
+
+    return Ans;
+}
+
+
+/*! \brief   test if the MLME Queue is full
+ *  \param   *Queue      The MLME Queue
+ *  \return  TRUE if the Queue is empty, FALSE otherwise
+ *  \pre
+ *  \post
+
+ IRQL = PASSIVE_LEVEL
+ IRQL = DISPATCH_LEVEL
+  
+ */
+BOOLEAN MlmeQueueFull(
+    IN MLME_QUEUE *Queue) 
+{
+    BOOLEAN Ans;
+
+    NdisAcquireSpinLock(&(Queue->Lock));
+    Ans = (Queue->Num == MAX_LEN_OF_MLME_QUEUE);
+    NdisReleaseSpinLock(&(Queue->Lock));
+
+    return Ans;
+}
+
+/*! \brief   The destructor of MLME Queue
+ *  \param 
+ *  \return
+ *  \pre
+ *  \post
+ *  \note   Clear Mlme Queue, Set Queue->Num to Zero.
+
+ IRQL = PASSIVE_LEVEL
+ 
+ */
+VOID MlmeQueueDestroy(
+    IN MLME_QUEUE *Queue) 
+{
+    NdisAcquireSpinLock(&(Queue->Lock));
+    Queue->Num  = 0;
+    Queue->Head = 0;
+    Queue->Tail = 0;
+    NdisReleaseSpinLock(&(Queue->Lock));
+}
+
+/*! \brief   To substitute the message type if the message is coming from external
+ *  \param  *Fr            The frame received
+ *  \param  *Machine       The state machine
+ *  \param  *MsgType       the message type for the state machine
+ *  \return TRUE if the substitution is successful, FALSE otherwise
+ *  \pre
+ *  \post
+ 
+ IRQL = DISPATCH_LEVEL
+ 
+ */
+BOOLEAN MsgTypeSubst(
+	IN PRT2570ADAPTER pAd,
+	IN MACFRAME *Fr, 
+	OUT INT *Machine, 
+	OUT INT *MsgType) 
+{
+	USHORT Seq;
+	UCHAR	EAPType;
+	PHEADER_802_11 pHeader;
+	
+	// The only data type will pass to this function is EAPOL frame
+	if (Fr->Hdr.Type == BTYPE_DATA) 
+	{	 
+		*Machine = WPA_PSK_STATE_MACHINE;
+
+	 pHeader	= (PHEADER_802_11)Fr;
+		
+	 if( (pAd->PortCfg.CipherAlg == CIPHER_TKIP || pAd->PortCfg.CipherAlg == CIPHER_AES) && pHeader->Controlhead.Frame.Wep)
+		EAPType = *((UCHAR*)Fr + LENGTH_802_11 + 8 + LENGTH_802_1_H + 1);//8 is IV + EIV
+	 else
+			EAPType = *((UCHAR*)Fr + LENGTH_802_11 + LENGTH_802_1_H + 1);
+	 
+	 
+		return(WpaMsgTypeSubst(EAPType, MsgType));
+	}	
+
+
+    switch (Fr->Hdr.SubType) 
+    {
+        case SUBTYPE_ASSOC_REQ:
+            *Machine = ASSOC_STATE_MACHINE;
+            *MsgType = MT2_PEER_ASSOC_REQ;
+            break;
+        case SUBTYPE_ASSOC_RSP:
+            *Machine = ASSOC_STATE_MACHINE;
+            *MsgType = MT2_PEER_ASSOC_RSP;
+            break;
+        case SUBTYPE_REASSOC_REQ:
+            *Machine = ASSOC_STATE_MACHINE;
+            *MsgType = MT2_PEER_REASSOC_REQ;
+            break;
+        case SUBTYPE_REASSOC_RSP:
+            *Machine = ASSOC_STATE_MACHINE;
+            *MsgType = MT2_PEER_REASSOC_RSP;
+            break;
+        case SUBTYPE_PROBE_REQ:
+            *Machine = SYNC_STATE_MACHINE;
+            *MsgType = MT2_PEER_PROBE_REQ;
+            break;
+        case SUBTYPE_PROBE_RSP:
+            *Machine = SYNC_STATE_MACHINE;
+            *MsgType = MT2_PEER_PROBE_RSP;
+            break;
+        case SUBTYPE_BEACON:
+            *Machine = SYNC_STATE_MACHINE;
+            *MsgType = MT2_PEER_BEACON;
+            break;
+        case SUBTYPE_ATIM:
+            *Machine = SYNC_STATE_MACHINE;
+            *MsgType = MT2_PEER_ATIM;
+            break;
+        case SUBTYPE_DISASSOC:
+            *Machine = ASSOC_STATE_MACHINE;
+            *MsgType = MT2_PEER_DISASSOC_REQ;
+            break;
+        case SUBTYPE_AUTH:
+            // get the sequence number from payload 24 Mac Header + 2 bytes algorithm
+            memcpy(&Seq, &Fr->Octet[2], sizeof(USHORT));
+            if (Seq == 1 || Seq == 3) 
+            {
+                *Machine = AUTH_RSP_STATE_MACHINE;
+                *MsgType = MT2_PEER_AUTH_ODD;
+            } 
+            else if (Seq == 2 || Seq == 4) 
+            {
+                *Machine = AUTH_STATE_MACHINE;
+                *MsgType = MT2_PEER_AUTH_EVEN;
+            } 
+            else 
+            {
+                return FALSE;
+            }
+            break;
+        case SUBTYPE_DEAUTH:
+            *Machine = AUTH_RSP_STATE_MACHINE;
+            *MsgType = MT2_PEER_DEAUTH;
+            break;
+        default:
+            return FALSE;
+            break;
+    }
+
+    return TRUE;
+}
+
+// ===========================================================================================
+// state_machine.c
+// ===========================================================================================
+
+/*! \brief Initialize the state machine.
+ *  \param *S           pointer to the state machine 
+ *  \param  Trans       State machine transition function
+ *  \param  StNr        number of states 
+ *  \param  MsgNr       number of messages 
+ *  \param  DefFunc     default function, when there is invalid state/message combination 
+ *  \param  InitState   initial state of the state machine 
+ *  \param  Base        StateMachine base, internal use only
+ *  \pre p_sm should be a legal pointer
+ *  \post
+
+ IRQL = PASSIVE_LEVEL
+ 
+ */
+
+VOID StateMachineInit(
+    IN STATE_MACHINE *S, 
+    IN STATE_MACHINE_FUNC Trans[], 
+    IN ULONG StNr, 
+    IN ULONG MsgNr, 
+    IN STATE_MACHINE_FUNC DefFunc, 
+    IN ULONG InitState, 
+    IN ULONG Base) 
+{
+    ULONG i, j;
+
+    // set number of states and messages
+    S->NrState = StNr;
+    S->NrMsg   = MsgNr;
+    S->Base    = Base;
+
+    S->TransFunc  = Trans;
+    
+    // init all state transition to default function
+    for (i = 0; i < StNr; i++) 
+    {
+        for (j = 0; j < MsgNr; j++) 
+        {
+            S->TransFunc[i * MsgNr + j] = DefFunc;
+        }
+    }
+    
+    // set the starting state
+    S->CurrState = InitState;
+}
+
+
+/*! \brief This function fills in the function pointer into the cell in the state machine 
+ *  \param *S   pointer to the state machine
+ *  \param St   state
+ *  \param Msg  incoming message
+ *  \param f    the function to be executed when (state, message) combination occurs at the state machine
+ *  \pre *S should be a legal pointer to the state machine, st, msg, should be all within the range, Base should be set in the initial state
+ *  \post
+
+ IRQL = PASSIVE_LEVEL
+ 
+ */
+VOID StateMachineSetAction(
+    IN STATE_MACHINE *S, 
+    IN ULONG St, 
+    IN ULONG Msg, 
+    IN STATE_MACHINE_FUNC Func) 
+{
+    ULONG MsgIdx;
+    
+    MsgIdx = Msg - S->Base;
+
+    if (St < S->NrState && MsgIdx < S->NrMsg) 
+    {
+        // boundary checking before setting the action
+        S->TransFunc[St * S->NrMsg + MsgIdx] = Func;
+    } 
+}
+
+/*! \brief   The destructor of the state machine
+ *  \param  *S the statemachine
+ *  \note    doing nothing at this moment, may need to do something if the implementation changed
+
+ IRQL = PASSIVE_LEVEL
+ 
+ */
+VOID
+StateMachineDestroy(IN STATE_MACHINE *S) 
+{
+}
+/*! \brief   This function does the state transition
+ *  \param   *Adapter the NIC adapter pointer
+ *  \param   *S       the state machine
+ *  \param   *Elem    the message to be executed
+ *  \return   None
+ 
+ IRQL = DISPATCH_LEVEL
+ 
+ */
+VOID StateMachinePerformAction(
+    IN	PRT2570ADAPTER	pAd, 
+    IN STATE_MACHINE *S, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    (*(S->TransFunc[S->CurrState * S->NrMsg + Elem->MsgType - S->Base]))(pAd, Elem);
+}
+
+/*
+    ==========================================================================
+    Description:
+        The drop function, when machine executes this, the message is simply 
+        ignored. This function does nothing, the message is freed in 
+        StateMachinePerformAction()
+    ==========================================================================
+ */
+VOID Drop(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+}
+
+/*
+    ==========================================================================
+    Description:
+        
+	IRQL = PASSIVE_LEVEL
+
+    ==========================================================================
+ */
+VOID LfsrInit(
+    IN PRT2570ADAPTER pAd, 
+    IN ULONG Seed) 
+{
+    if (Seed == 0) 
+        pAd->Mlme.ShiftReg = 1;
+    else 
+        pAd->Mlme.ShiftReg = Seed;
+}
+
+
+/*
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+UCHAR RandomByte(
+    IN PRT2570ADAPTER pAd) 
+{
+    ULONG i;
+    UCHAR R, Result;
+
+    R = 0;
+
+    for (i = 0; i < 8; i++) 
+    {
+        if (pAd->Mlme.ShiftReg & 0x00000001) 
+        {
+            pAd->Mlme.ShiftReg = ((pAd->Mlme.ShiftReg ^ LFSR_MASK) >> 1) | 0x80000000;
+            Result = 1;
+        } 
+        else 
+        {
+            pAd->Mlme.ShiftReg = pAd->Mlme.ShiftReg >> 1;
+            Result = 0;
+        }
+        R = (R << 1) | Result;
+    }
+
+    return R;
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+ */
+VOID AsicSwitchChannel(
+	IN PRT2570ADAPTER pAd, 
+	IN UCHAR Channel) 
+{
+	ULONG R3;
+	UCHAR index;
+
+	// TODO: need to update E2PROM format to add 802.11a channel's TX power calibration values
+	if (Channel <= 14)	  
+	R3 = pAd->PortCfg.ChannelTxPower[Channel - 1];
+	else 
+		R3 = pAd->PortCfg.ChannelTxPower[0];
+
+	if (R3 > 31)  R3 = 31;
+
+	// E2PROM setting is calibrated for maximum TX power (i.e. 100%)
+	// We lower TX power here according to the percentage specified from UI
+	if (pAd->PortCfg.TxPowerPercentage > 90)	   // 91 ~ 100%, treat as 100% in terms of mW
+		;
+	else if (pAd->PortCfg.TxPowerPercentage > 60)  // 61 ~ 90%, treat as 75% in terms of mW
+		R3 -= 1;
+	else if (pAd->PortCfg.TxPowerPercentage > 30)  // 31 ~ 60%, treat as 50% in terms of mW
+		R3 -= 3;
+	else if (pAd->PortCfg.TxPowerPercentage > 15)  // 16 ~ 30%, treat as 25% in terms of mW
+		R3 -= 6;
+	else if (pAd->PortCfg.TxPowerPercentage > 9)   // 10 ~ 15%, treat as 12.5% in terms of mW
+		R3 -= 9;
+	else										   // 0 ~ 9 %, treat as 6.25% in terms of mW
+		R3 -= 12;
+
+	R3 = R3 << 9; // shift TX power control to correct RF R3 bit position
+	switch (pAd->PortCfg.RfType)
+	{
+		case RFIC_2522:
+			for (index = 0; index < NUM_OF_2522_CHNL; index++)
+			{
+				if (Channel == RF2522RegTable[index].Channel)
+				{
+					R3 = R3 | RF2522RegTable[index].R3; // set TX power
+					RTUSBWriteRFRegister(pAd, RF2522RegTable[index].R1);
+					RTUSBWriteRFRegister(pAd, RF2522RegTable[index].R2);
+					RTUSBWriteRFRegister(pAd, R3);
+					pAd->PortCfg.LatchRfRegs.Channel = Channel;
+					pAd->PortCfg.LatchRfRegs.R1 = RF2522RegTable[index].R1;
+					pAd->PortCfg.LatchRfRegs.R2 = RF2522RegTable[index].R2;
+					pAd->PortCfg.LatchRfRegs.R3 = R3;
+					pAd->PortCfg.LatchRfRegs.R4 = RF2522RegTable[index].R4;
+					break;
+				}
+			}
+			break;
+
+		case RFIC_2523:
+			for (index = 0; index < NUM_OF_2523_CHNL; index++)
+			{
+				if (Channel == RF2523RegTable[index].Channel)
+				{
+					R3 = R3 | RF2523RegTable[index].R3; // set TX power
+					RTUSBWriteRFRegister(pAd, RF2523RegTable[index].R1);
+					RTUSBWriteRFRegister(pAd, RF2523RegTable[index].R2);
+					RTUSBWriteRFRegister(pAd, R3);
+					RTUSBWriteRFRegister(pAd, RF2523RegTable[index].R4);
+					pAd->PortCfg.LatchRfRegs.Channel = Channel;
+					pAd->PortCfg.LatchRfRegs.R1 = RF2523RegTable[index].R1;
+					pAd->PortCfg.LatchRfRegs.R2 = RF2523RegTable[index].R2;
+					pAd->PortCfg.LatchRfRegs.R3 = R3;
+					pAd->PortCfg.LatchRfRegs.R4 = RF2523RegTable[index].R4;
+					break;
+				}
+			}
+			break;
+
+		case RFIC_2524:
+			for (index = 0; index < NUM_OF_2524_CHNL; index++)
+			{
+				if (Channel == RF2524RegTable[index].Channel)
+				{
+					R3 = R3 | RF2524RegTable[index].R3; // set TX power
+					RTUSBWriteRFRegister(pAd, RF2524RegTable[index].R1);
+					RTUSBWriteRFRegister(pAd, RF2524RegTable[index].R2);
+					RTUSBWriteRFRegister(pAd, R3);
+					RTUSBWriteRFRegister(pAd, RF2524RegTable[index].R4);
+					pAd->PortCfg.LatchRfRegs.Channel = Channel;
+					pAd->PortCfg.LatchRfRegs.R1 = RF2524RegTable[index].R1;
+					pAd->PortCfg.LatchRfRegs.R2 = RF2524RegTable[index].R2;
+					pAd->PortCfg.LatchRfRegs.R3 = R3;
+					pAd->PortCfg.LatchRfRegs.R4 = RF2524RegTable[index].R4;
+					break;
+				}
+			}
+			break;
+			
+		case RFIC_2525:
+			for (index = 0; index < NUM_OF_2525_CHNL; index++)
+			{
+				if (Channel == RF2525RegTable[index].Channel)
+				{
+					R3 = R3 | RF2525RegTable[index].R3; // set TX power
+					RTUSBWriteRFRegister(pAd, RF2525RegTable[index].R1);
+
+					RTUSBWriteRFRegister(pAd, RF2525RegTable[index].R2);
+
+					RTUSBWriteRFRegister(pAd, R3);
+
+					RTUSBWriteRFRegister(pAd, RF2525RegTable[index].R4);
+
+					pAd->PortCfg.LatchRfRegs.Channel = Channel;
+					pAd->PortCfg.LatchRfRegs.R1 = RF2525RegTable[index].R1;
+					pAd->PortCfg.LatchRfRegs.R2 = RF2525RegTable[index].R2;
+					pAd->PortCfg.LatchRfRegs.R3 = R3;
+					pAd->PortCfg.LatchRfRegs.R4 = RF2525RegTable[index].R4;
+					break;
+				}
+			}
+			break;
+			
+		case RFIC_2525E:
+			for (index = 0; index < NUM_OF_2525E_CHNL; index++)
+			{
+				if (Channel == RF2525eRegTable[index].Channel)
+				{
+					RTUSBWriteRFRegister(pAd, RF2525eRegTable[index].TempR2);
+					RTUSBWriteRFRegister(pAd, RF2525eRegTable[index].R4);
+					R3 = R3 | RF2525eRegTable[index].R3; // set TX power
+					RTUSBWriteRFRegister(pAd, RF2525eRegTable[index].R1);
+					RTUSBWriteRFRegister(pAd, RF2525eRegTable[index].R2);
+					RTUSBWriteRFRegister(pAd, R3);
+					RTUSBWriteRFRegister(pAd, RF2525eRegTable[index].R4);
+					pAd->PortCfg.LatchRfRegs.Channel = Channel;
+					pAd->PortCfg.LatchRfRegs.R1 = RF2525eRegTable[index].R1;
+					pAd->PortCfg.LatchRfRegs.R2 = RF2525eRegTable[index].R2;
+					pAd->PortCfg.LatchRfRegs.R3 = R3;
+					pAd->PortCfg.LatchRfRegs.R4 = RF2525eRegTable[index].R4;
+					break;
+				}
+			}
+			break;
+			
+		case RFIC_5222:
+			for (index = 0; index < NUM_OF_5222_CHNL; index++)
+			{
+				if (Channel == RF5222RegTable[index].Channel)
+				{
+					R3 = R3 | RF5222RegTable[index].R3; // set TX power
+					RTUSBWriteRFRegister(pAd, RF5222RegTable[index].R1);
+					RTUSBWriteRFRegister(pAd, RF5222RegTable[index].R2);
+					RTUSBWriteRFRegister(pAd, R3);
+					RTUSBWriteRFRegister(pAd, RF5222RegTable[index].R4);
+					pAd->PortCfg.LatchRfRegs.Channel = Channel;
+					pAd->PortCfg.LatchRfRegs.R1 = RF5222RegTable[index].R1;
+					pAd->PortCfg.LatchRfRegs.R2 = RF5222RegTable[index].R2;
+					pAd->PortCfg.LatchRfRegs.R3 = R3;
+					pAd->PortCfg.LatchRfRegs.R4 = RF5222RegTable[index].R4;
+					break;
+				}
+			}
+			break;
+
+		default:
+			break;
+	}
+
+	DBGPRINT(RT_DEBUG_INFO, "AsicSwitchChannel(RF=%d) to #%d, TXPwr=%x%% = %x, R1=0x%08x, R2=0x%08x, R3=0x%08x, R4=0x%08x\n",
+		pAd->PortCfg.RfType, 
+		pAd->PortCfg.LatchRfRegs.Channel, 
+		pAd->PortCfg.TxPowerPercentage,
+		pAd->PortCfg.ChannelTxPower[Channel - 1],
+		pAd->PortCfg.LatchRfRegs.R1, 
+		pAd->PortCfg.LatchRfRegs.R2, 
+		pAd->PortCfg.LatchRfRegs.R3, 
+		pAd->PortCfg.LatchRfRegs.R4);
+	
+}
+
+
+
+/*
+	==========================================================================
+	Description:
+		This function is required for 2421 only, and should not be used during
+		site survey. It's only required after NIC decided to stay at a channel
+		for a longer period.
+		When this function is called, it's always after AsicSwitchChannel().
+	==========================================================================
+ */
+VOID AsicLockChannel(
+	IN PRT2570ADAPTER pAd, 
+	IN ULONG Channel) 
+{
+	UCHAR	r70;
+	USHORT	RxFailCnt;
+
+	return;
+	RTUSBReadBBPRegister(pAd, 70, &r70);
+	if (Channel == 14)
+		r70 |= 0x08;	// turn on Japan filter bit
+	else
+		r70 &= 0xf7;	// turn off Japan filter bit
+	RTUSBWriteBBPRegister(pAd, 70, r70);
+
+	// Clear false CRC durning switch channel
+	RTUSBReadMACRegister(pAd, STA_CSR0, &RxFailCnt);
+
+
+	NdisMSleep(10); 
+ 
+	switch (pAd->PortCfg.RfType)
+	{
+		case RFIC_2522:
+		case RFIC_2524:
+		case RFIC_2525:
+		case RFIC_5222:
+		case RFIC_2525E:
+			pAd->PortCfg.LatchRfRegs.R1 &= 0xfffdffff;	// RF R1.bit17 "tune_en1" OFF
+			pAd->PortCfg.LatchRfRegs.R3 &= 0xfffffeff;	 // RF R3.bit8 "tune_en2" OFF
+			RTUSBWriteRFRegister(pAd, pAd->PortCfg.LatchRfRegs.R1); 
+			RTUSBWriteRFRegister(pAd, pAd->PortCfg.LatchRfRegs.R3); 
+			DBGPRINT(RT_DEBUG_INFO, "AsicRfTuningExec(R1=0x%x,R3=0x%x)\n",pAd->PortCfg.LatchRfRegs.R1,pAd->PortCfg.LatchRfRegs.R3);
+			break;
+			
+		case RFIC_2523:
+			pAd->PortCfg.LatchRfRegs.R3 &= 0xfffffeff;	 // RF R3.bit8 "tune_en2" OFF
+			RTUSBWriteRFRegister(pAd, pAd->PortCfg.LatchRfRegs.R3); 
+			DBGPRINT(RT_DEBUG_INFO, "AsicRfTuningExec(R3=0x%x)\n",pAd->PortCfg.LatchRfRegs.R3);
+			break;
+
+		default:
+			break;
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+		Gives CCK TX rate 2 more dB TX power.
+		This routine works only in LINK UP in INFRASTRUCTURE mode.
+
+		calculate desired Tx power in RF R3.Tx0~5,	should consider -
+		1. TxPowerPercentage
+		2. auto calibration based on TSSI feedback
+		3. extra 2 db for CCK
+		4. -10 db upon very-short distance (AvgRSSI >= -40db) to AP
+	==========================================================================
+ */
+VOID AsicAdjustTxPower(
+	IN PRT2570ADAPTER pAd) 
+{
+	ULONG R3, Channel, CurrTxPwr;
+
+	if ((pAd->PortCfg.Channel >= 1) && (pAd->PortCfg.Channel <= 14))
+		Channel = pAd->PortCfg.Channel;
+	else 
+		Channel = 1;  // don't have calibration info for 11A, temporarily use Channel 1
+	
+	// get TX Power base from E2PROM
+	R3 = pAd->PortCfg.ChannelTxPower[Channel - 1];
+	if (R3 > 31)  R3 = 31;
+
+	// E2PROM setting is calibrated for maximum TX power (i.e. 100%)
+	// We lower TX power here according to the percentage specified from UI
+	if (pAd->PortCfg.TxPowerPercentage == 0xffffffff)       // AUTO TX POWER control
+	{
+		// only INFRASTRUCTURE mode and 100% TX power need furthur calibration
+		if (pAd->MediaState == NdisMediaStateConnected)
+		{
+			// low TX power upon very-short distance to AP to solve some vendor's AP RX problem
+			// in this case, no TSSI compensation is required.
+			if ((pAd->DrsCounters.fNoisyEnvironment == FALSE) && 
+			    (pAd->PortCfg.AvgRssi > (pAd->BBPTuningParameters.RSSIToDbmOffset - RSSI_FOR_LOWEST_TX_POWER)))
+				R3 -= LOWEST_TX_POWER_DELTA;
+			else if ((pAd->DrsCounters.fNoisyEnvironment == FALSE) && 
+			    (pAd->PortCfg.AvgRssi > (pAd->BBPTuningParameters.RSSIToDbmOffset - RSSI_FOR_LOW_TX_POWER)))
+				R3 -= LOW_TX_POWER_DELTA;
+			// 2004-03-16 give OFDM rates lower than 48 mbps 2 more DB
+			else if ((pAd->PortCfg.TxRate <= RATE_36) && (pAd->PortCfg.TxRate > RATE_11))
+			{
+			    R3 +=2;
+			    if (R3 > 31) R3 = 31;
+			}
+            
+
+			// 2 exclusive rules applied on CCK rates only -
+			//	  1. always plus 2 db for CCK
+			//	  2. adjust TX Power based on TSSI
+			else 
+			if (pAd->PortCfg.TxRate <= RATE_11)
+			{
+				// if "auto calibration based on TSSI" is not required, then
+				// always give CCK 2 more db
+				if (pAd->PortCfg.bAutoTxAgc == FALSE)
+				{
+					// do not give RATE_11 2 more db to avoid the case that
+					// the outgoing NULL frame (for rate upgrade evaluation) 
+					// using 12 Mbps OFDM rate is over-powered
+					if (pAd->PortCfg.TxRate <= RATE_5_5)
+					{
+						R3 += 2;  // plus 2 db
+						if (R3 > 31) R3 = 31;
+					}
+				}
+				
+				// Auto calibrate Tx AGC if bAutoTxAgc is TRUE and TX rate is CCK, 
+				// because E2PROM's TSSI reference is valid only in CCK range.
+				else
+				{
+					UCHAR	R1,TxPowerRef, TssiRef;
+
+					R3 = (pAd->PortCfg.LatchRfRegs.R3 >> 9) & 0x0000001f;
+					if (pAd->Mlme.PeriodicRound % 4 == 0) // every 4 second
+					{
+					TxPowerRef = pAd->PortCfg.ChannelTxPower[Channel - 1];
+					TssiRef    = pAd->PortCfg.ChannelTssiRef[Channel - 1];
+					RTUSBReadBBPRegister(pAd, BBP_Tx_Tssi,	&R1);
+					if ((TssiRef >= (R1 + pAd->PortCfg.ChannelTssiDelta)) ||
+						(TssiRef <= (R1 - pAd->PortCfg.ChannelTssiDelta)))
+					{
+						// Need R3 adjustment. However, we have to make sure there is only
+						// plus / minus 5 variation allowed
+						if (TssiRef > R1)
+						{				
+							R3 = (R3 < (ULONG) (TxPowerRef + 5)) ? (R3 + 1) : R3;
+							if (R3 > 31)
+								R3 = 31;
+								DBGPRINT(RT_DEBUG_TRACE,"TSSI(R1)=%d, ++TxPwr=%d\n", R1, R3);
+							}
+							else
+							{
+								R3 = (R3 > (ULONG) (TxPowerRef - 5)) ? (R3 - 1) : R3;
+								DBGPRINT(RT_DEBUG_TRACE,"TSSI(R1)=%d, --TxPwr=%d\n", R1, R3);
+							}
+						}
+					}
+				}
+			}
+			
+		}
+	}
+	else // fixed AUTO TX power
+	{
+		if (pAd->PortCfg.TxPowerPercentage > 90)  // 91 ~ 100%, treat as 100% in terms of mW
+		    ;
+		else if (pAd->PortCfg.TxPowerPercentage > 60)  // 61 ~ 90%, treat as 75% in terms of mW
+		    R3 -= 1;
+		else if (pAd->PortCfg.TxPowerPercentage > 30)  // 31 ~ 60%, treat as 50% in terms of mW
+		    R3 -= 3;
+		else if (pAd->PortCfg.TxPowerPercentage > 15)  // 16 ~ 30%, treat as 25% in terms of mW
+		    R3 -= 6;
+		else if (pAd->PortCfg.TxPowerPercentage > 9)   // 10 ~ 15%, treat as 12.5% in terms of mW
+		    R3 -= 9;
+		else                                           // 0 ~ 9 %, treat as MIN(~3%) in terms of mW
+		    R3 -= 12;
+		if (R3 > 31)  R3 = 0;   // negative value, set as minimum 0
+
+		// 2004-03-16 give TX rates <= 36 mbps 2 more DB
+		if (pAd->PortCfg.TxRate <= RATE_36)
+		{
+		    R3 +=2;
+		    if (R3 > 31) R3 = 31;
+		}
+	}
+
+	
+	// compare the desired R3.TxPwr value with current R3, if not equal
+	// set new R3.TxPwr
+	CurrTxPwr = (pAd->PortCfg.LatchRfRegs.R3 >> 9) & 0x0000001f;
+	if (CurrTxPwr != R3)
+	{
+		CurrTxPwr = R3;
+		R3 = (pAd->PortCfg.LatchRfRegs.R3 & 0xffffc1ff) | (R3 << 9);
+		RTUSBWriteRFRegister(pAd, R3);
+		pAd->PortCfg.LatchRfRegs.R3 = R3;
+	}
+    DBGPRINT(RT_DEBUG_INFO, "AsicAdjustTxPower = %d, AvgRssi = %d\n",
+        CurrTxPwr, pAd->PortCfg.AvgRssi - pAd->BBPTuningParameters.RSSIToDbmOffset);
+	
+}
+
+
+
+/*
+	==========================================================================
+	Description:
+		put PHY to sleep here, and set next wakeup timer
+	==========================================================================
+ */
+VOID AsicSleepThenAutoWakeup(
+	IN PRT2570ADAPTER pAd, 
+	IN USHORT TbttNumToNextWakeUp) 
+{
+	MAC_CSR18_STRUC Csr20;
+	MAC_CSR17_STRUC Pwrcsr1;
+
+	// we have decided to SLEEP, so at least do it for a BEACON period.
+	if (TbttNumToNextWakeUp==0)
+		TbttNumToNextWakeUp=1;
+	
+	// PWRCSR0 remains untouched
+	
+	// set CSR20 for next wakeup
+	Csr20.value = 0;
+	Csr20.field.NumBcnBeforeWakeup = TbttNumToNextWakeUp - 1;
+	Csr20.field.DelayAfterBcn = (pAd->PortCfg.BeaconPeriod - 20); // 20 TU ahead of desired TBTT
+	Csr20.field.AutoWake = 1;
+	RTUSBWriteMACRegister(pAd, MAC_CSR18, Csr20.value);
+
+	// set PWRCSR1 to put PHY into SLEEP state
+	Pwrcsr1.value = 0;
+	Pwrcsr1.field.PutToSleep = 1;
+	Pwrcsr1.field.BbpDesireState = 1; // 01:SLEEP
+	Pwrcsr1.field.RfDesireState = 1;  // 01:SLEEP
+	RTUSBWriteMACRegister(pAd, MAC_CSR17, Pwrcsr1.value);
+	Pwrcsr1.field.PutToSleep = 1;
+	RTUSBWriteMACRegister(pAd, MAC_CSR17, Pwrcsr1.value);
+	DBGPRINT(RT_DEBUG_TRACE,"MAC_CSR17 = 0x%x (AsicSleepThenAutoWakeup)\n", Pwrcsr1.value);
+	pAd->PortCfg.Pss = PWR_SAVE;
+}
+
+/*
+	==========================================================================
+	Description:
+		AsicForceWakeup() is used whenever manual wakeup is required
+		AsicForceSleep() should only be used when Massoc==FALSE. When
+		Massoc==TRUE, we should use AsicSleepThenAutoWakeup() instead.
+	==========================================================================
+ */
+VOID AsicForceSleep(
+	IN PRT2570ADAPTER pAd)
+{
+	MAC_CSR17_STRUC Pwrcsr1;
+
+	if (pAd->PortCfg.Pss == PWR_ACTIVE)
+	{
+		DBGPRINT(RT_DEBUG_TRACE,">>>AsicForceSleep<<<\n");
+		Pwrcsr1.value = 0;
+		Pwrcsr1.field.RfDesireState = 1; // 01:SLEEP state
+		Pwrcsr1.field.BbpDesireState = 1; // 01:SLEEP state
+		Pwrcsr1.field.SetState = 1;
+		RTUSBWriteMACRegister(pAd, MAC_CSR17, Pwrcsr1.value);
+		pAd->PortCfg.Pss = PWR_SAVE;
+	}
+}
+
+VOID AsicForceWakeup(
+	IN PRT2570ADAPTER pAd)
+{
+	MAC_CSR17_STRUC Pwrcsr1;
+
+	if (pAd->PortCfg.Pss == PWR_SAVE)
+	{
+		UINT i, j;
+		USHORT temp;
+		DBGPRINT(RT_DEBUG_TRACE,"--->AsicForceWakeup\n");
+
+		// 2003-12-19 turn OFF auto wakeup first
+		RTUSBWriteMACRegister(pAd, MAC_CSR18, 0);
+		Pwrcsr1.value = 0;
+		Pwrcsr1.field.RfDesireState = 3; // 11:AWAKE state
+		Pwrcsr1.field.BbpDesireState = 3; // 11:AWAKE state
+		RTUSBWriteMACRegister(pAd, MAC_CSR17, Pwrcsr1.value);
+		Pwrcsr1.field.SetState = 1;
+		RTUSBWriteMACRegister(pAd, MAC_CSR17, Pwrcsr1.value);
+		//RTMPusecDelay(30000);
+		NdisMSleep(30);
+		RTUSBReadMACRegister(pAd, MAC_CSR17, &temp);
+		if ((temp & 0x01E0) == 0x01E0)
+		{
+			DBGPRINT_RAW(RT_DEBUG_TRACE, "ASIC awaken!!!\n");
+			i = 0;
+		}
+		else
+		{
+			DBGPRINT_RAW(RT_DEBUG_TRACE, "ASIC not awaken yet!!!\n");
+		        Pwrcsr1.value = 0;
+		        Pwrcsr1.field.RfDesireState = 3; // 11:AWAKE state
+		        Pwrcsr1.field.BbpDesireState = 3; // 11:AWAKE state
+		        Pwrcsr1.field.SetState = 1;
+			i = 5;
+		}
+		for (j = 0; j < 3; j++)
+		{
+			if (i == 5)
+			{
+				RTUSBWriteMACRegister(pAd, MAC_CSR17, Pwrcsr1.value);
+				DBGPRINT(RT_DEBUG_TRACE,"MAC_CSR17 = 0x%x (AsicForceWakeup)\n", Pwrcsr1.value);
+			}
+			else
+				break;
+
+			for (i = 0; i < 5; i++)
+			{
+				//RTMPusecDelay(5000);
+				NdisMSleep(5);
+				RTUSBReadMACRegister(pAd, MAC_CSR17, &temp);
+				if ((temp & 0x01E0) == 0x01E0)
+				{
+					DBGPRINT_RAW(RT_DEBUG_TRACE, "ASIC awaken!!!\n");
+					break;
+				}
+				else
+				{
+					DBGPRINT_RAW(RT_DEBUG_TRACE, "ASIC not awaken yet!!!\n");
+				}
+			}
+		}
+	
+		pAd->PortCfg.Pss = PWR_ACTIVE;
+		DBGPRINT(RT_DEBUG_TRACE,"<---AsicForceWakeup\n");
+	}
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+ */
+VOID AsicSetBssid(
+	IN PRT2570ADAPTER pAd, 
+	IN MACADDR *Bssid) 
+{
+	USHORT		   Addr4;
+
+	Addr4 = (USHORT)(Bssid->Octet[0]) | (USHORT)(Bssid->Octet[1] << 8);
+	RTUSBWriteMACRegister(pAd, MAC_CSR5, Addr4);
+
+	Addr4 = (USHORT)(Bssid->Octet[2]) | (USHORT)(Bssid->Octet[3] << 8);
+	RTUSBWriteMACRegister(pAd, MAC_CSR6, Addr4);
+
+	Addr4 = (USHORT)(Bssid->Octet[4]) | (USHORT)(Bssid->Octet[5] << 8);
+	RTUSBWriteMACRegister(pAd, MAC_CSR7, Addr4);
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+ */
+VOID AsicDisableSync(
+	IN PRT2570ADAPTER pAd) 
+{
+	DBGPRINT(RT_DEBUG_TRACE,"--->Disable TSF synchronization\n");
+	//per jerry's request   	RTUSBReadMACRegister(pAd, TXRX_CSR19, 9);
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+ */
+VOID AsicEnableBssSync(
+	IN PRT2570ADAPTER pAd) 
+{
+	USHORT temp;
+	TXRX_CSR18_STRUC Csr18;
+	TXRX_CSR19_STRUC Csr14;
+	TXRX_CSR20_STRUC Bcncsr1;
+
+	DBGPRINT(RT_DEBUG_TRACE,"--->AsicEnableBssSync(INFRA mode)\n");
+	
+	RTUSBWriteMACRegister(pAd, TXRX_CSR19, 0);
+	
+	temp = (pAd->PortCfg.BeaconPeriod << 8);
+	Csr18.field.Offset = (temp & 0x000F);
+	Csr18.field.Interval = (temp >> 6);
+	RTUSBWriteMACRegister(pAd, TXRX_CSR18, Csr18.value);
+	
+	Bcncsr1.value = 0;
+	Bcncsr1.field.BeaconExpectWindow = 2;
+	Bcncsr1.field.Offset = TBTT_PRELOAD_TIME >> 6; // we guess TBTT is 2 TU ahead of BEACON-RxEnd time
+	RTUSBWriteMACRegister(pAd, TXRX_CSR20, Bcncsr1.value);
+
+	
+	Csr14.value = 0;
+	Csr14.field.TsfCount = 1;
+	Csr14.field.TsfSync = 1; // sync TSF in INFRASTRUCTURE mode
+	Csr14.field.BeaconGen = 0;
+//	Csr14.field.TbcnPreload = (pAd->PortCfg.BeaconPeriod - 30) << 4; // TODO: ???? 1 TU ???
+	Csr14.field.Tbcn = 1;
+	RTUSBWriteMACRegister(pAd, TXRX_CSR19, Csr14.value);
+}
+
+/*
+	==========================================================================
+	Description:
+	Note: 
+		BEACON frame in shared memory should be built ok before this routine
+		can be called. Otherwise, a garbage frame maybe transmitted out every
+		Beacon period.
+	==========================================================================
+ */
+VOID AsicEnableIbssSync(
+	IN PRT2570ADAPTER pAd)
+{
+	USHORT temp;
+	TXRX_CSR18_STRUC Csr18;
+	TXRX_CSR19_STRUC Csr14;
+	TXRX_CSR20_STRUC Bcncsr1;
+	
+	DBGPRINT(RT_DEBUG_TRACE,"--->AsicEnableIbssSync(ADHOC mode)\n");
+
+	RTUSBWriteMACRegister(pAd, TXRX_CSR19, 0);
+	MakeIbssBeacon(pAd);
+
+	temp = (pAd->PortCfg.BeaconPeriod << 8);
+	Csr18.field.Offset = (temp & 0x000F);
+	Csr18.field.Interval = (temp >> 6);
+	RTUSBWriteMACRegister(pAd, TXRX_CSR18, Csr18.value);
+
+	Bcncsr1.value = 0;
+	Bcncsr1.field.Offset = 0x140;
+	RTUSBWriteMACRegister(pAd, TXRX_CSR20, Bcncsr1.value);
+	
+	Csr14.value = 0;
+	Csr14.field.TsfCount = 1;
+	Csr14.field.TsfSync = 2; // sync TSF in IBSS mode
+	Csr14.field.Tbcn = 1;
+	Csr14.field.BeaconGen = 1;
+	RTUSBWriteMACRegister(pAd, TXRX_CSR19, Csr14.value);
+	RTUSBWriteMACRegister(pAd, TXRX_CSR19, 0);
+	Csr14.value = 0;
+	Csr14.field.TsfCount = 1;
+	Csr14.field.TsfSync = 2; // sync TSF in IBSS mode
+	Csr14.field.Tbcn = 1;
+	Csr14.field.BeaconGen = 1;
+	RTUSBWriteMACRegister(pAd, TXRX_CSR19, Csr14.value);
+	//
+	// Snice ADHOC Beacon Generation will get failed.
+	// To prevent that, program the Register TXRX_CSR19 again.
+	//    
+	RTUSBWriteMACRegister(pAd, TXRX_CSR19, 0);
+
+	Csr14.value = 0;
+	Csr14.field.TsfCount = 1;
+	Csr14.field.TsfSync = 2; // sync TSF in IBSS mode
+	Csr14.field.Tbcn = 1;
+	Csr14.field.BeaconGen = 1;
+	RTUSBWriteMACRegister(pAd, TXRX_CSR19, Csr14.value);
+}
+
+/* Flash the S/W LED periodically. - Paul Chen */
+VOID AsicLedPeriodicExec(
+	IN	unsigned long data) 
+{
+}
+
+/*
+	==========================================================================
+	Description:
+	==========================================================================
+ */
+VOID AsicSetSlotTime(
+	IN PRT2570ADAPTER pAd,
+	IN BOOLEAN UseShortSlotTime) 
+{
+	USHORT		slottime=20;
+	UCHAR PhyMode;
+	pAd->PortCfg.ShortSlotInUsed = UseShortSlotTime;
+	
+	PhyMode = pAd->PortCfg.PhyMode;
+	if (PhyMode == PHY_11ABG_MIXED)
+	{
+		if (pAd->PortCfg.Channel <=14)
+			PhyMode = PHY_11BG_MIXED;
+		else
+			PhyMode = PHY_11A;
+	}
+
+	if ((INFRA_ON(pAd)) && (pAd->PortCfg.EnableTxBurst) && (pAd->PortCfg.WepStatus != Ndis802_11EncryptionDisabled))
+		//Extend slot time if any encryption method is used to give ASIC more time to do encryption/decryption during Tx burst mode.
+		RTUSBWriteMACRegister(pAd, MAC_CSR10, 0x20);
+	else
+	{
+		if (PhyMode == PHY_11A)
+			slottime = 9;
+		else
+			slottime = (UseShortSlotTime)? 9 : 20;
+	
+		RTUSBWriteMACRegister(pAd, MAC_CSR10, slottime);
+	}
+	//set IFS values
+	if (PhyMode == PHY_11B)
+	{
+		RTUSBWriteMACRegister(pAd, MAC_CSR11, 16 - PHY_TR_SWITCH_TIME);
+		RTUSBWriteMACRegister(pAd, MAC_CSR12, 64);
+	}
+	else
+	{
+		RTUSBWriteMACRegister(pAd, MAC_CSR11, 10 - PHY_TR_SWITCH_TIME);
+		RTUSBWriteMACRegister(pAd, MAC_CSR12, 364);
+	}
+}
+VOID AsicBbpTuning(
+    IN PRT2570ADAPTER pAd)
+{
+	UCHAR R17;
+	ULONG FalseCcaUpperThreshold = pAd->PortCfg.BbpTuning.FalseCcaUpperThreshold << 7;
+	int dbm = pAd->PortCfg.AvgRssi - pAd->BBPTuningParameters.RSSIToDbmOffset;
+	if ((! pAd->PortCfg.BbpTuningEnable) || (pAd->PortCfg.BbpTuning.VgcDelta==0))
+	    return;
+
+	R17 = pAd->PortCfg.BbpWriteLatch[17];
+	DBGPRINT(RT_DEBUG_INFO, "RSSI = %d dbm, False CCA = %d BBPTuningThreshold = %x\n", dbm, pAd->MACCounters[3], pAd->BBPTuningParameters.BBPTuningThreshold);
+	if (pAd->MediaState == NdisMediaStateConnected)
+	{
+		if ((dbm + (INT)(pAd->BBPTuningParameters.BBPTuningThreshold)) > 0)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO, "RSSI > -%ddbm\n", pAd->BBPTuningParameters.BBPTuningThreshold);
+			if (pAd->BBPTuningParameters.LargeCurrentRSSI == FALSE)
+			{
+				RTUSBWriteBBPRegister(pAd, 24, pAd->BBPTuningParameters.R24HigherValue);
+				RTUSBWriteBBPRegister(pAd, 25, pAd->BBPTuningParameters.R25HigherValue);
+				RTUSBWriteBBPRegister(pAd, 61, pAd->BBPTuningParameters.R61HigherValue);
+				pAd->BBPTuningParameters.LargeCurrentRSSI = TRUE;
+			}
+		}
+		else
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO, "RSSI <= -%ddbm\n", pAd->BBPTuningParameters.BBPTuningThreshold);
+			if (pAd->BBPTuningParameters.LargeCurrentRSSI == TRUE)
+			{
+				RTUSBWriteBBPRegister(pAd, 24, pAd->BBPTuningParameters.R24LowerValue);
+				RTUSBWriteBBPRegister(pAd, 25, pAd->BBPTuningParameters.R25LowerValue);
+				RTUSBWriteBBPRegister(pAd, 61, pAd->BBPTuningParameters.R61LowerValue);
+				pAd->BBPTuningParameters.LargeCurrentRSSI = FALSE;
+			}
+		}
+		// Rule 0.
+		// when RSSI is too weak, many signals will become false CCA thus affect R17 tuning.
+		// so in this case, just stop R17 tuning (be sure R17 remains in <E2PROM-6, BBP_R17_DYNAMIC_UP_BOUND> range)
+#if 1
+		if ((dbm >= -40) && 
+			(pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE))
+		{
+			if (R17 != 0x60)
+			{
+				R17 = 0x60;
+				RTUSBWriteBBPRegister(pAd, 17, R17);
+			}
+			DBGPRINT(RT_DEBUG_INFO, "RSSI = %d dbm, fixed R17 at 0x%x\n", dbm, R17);
+			return;
+		}
+
+#else
+		if ((dbm < -80) && (pAd->Mlme.PeriodicRound > 20))
+		{
+		    if (R17 >= pAd->BBPTuningParameters.BBPR17MidSensitivity)
+		    {
+		        R17 = pAd->PortCfg.LastR17Value;
+			    RTUSBWriteBBPRegister(pAd, 17, R17);
+		    }
+		    DBGPRINT(RT_DEBUG_TRACE, "RSSI = %d dbm, stop R17 at 0x%x\n", dbm, R17);
+		    return;
+		}
+#endif
+		// Rule 1. "special big-R17 for short-distance" when not SCANNING
+		else if ((dbm >= RSSI_FOR_LOW_SENSIBILITY) && 
+		    (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE))
+		{
+		    if (R17 != pAd->BBPTuningParameters.BBPR17LowSensitivity)
+		    {
+		        R17 = pAd->BBPTuningParameters.BBPR17LowSensitivity;
+		        RTUSBWriteBBPRegister(pAd, 17, R17);
+		    }
+		    DBGPRINT(RT_DEBUG_INFO, "RSSI = %d dbm, fixed R17 at Low 0x%x\n", dbm, R17);
+		    return;
+		}
+		// Rule 2. "special mid-R17 for mid-distance" when not SCANNING
+		else if ((dbm >= RSSI_FOR_MID_SENSIBILITY) && 
+		    (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE))
+		{
+		    if (R17 != pAd->BBPTuningParameters.BBPR17MidSensitivity)
+		    {
+		        R17 = pAd->BBPTuningParameters.BBPR17MidSensitivity;
+		        RTUSBWriteBBPRegister(pAd, 17, R17);
+		    }
+		    DBGPRINT(RT_DEBUG_INFO, "RSSI = %d dbm, fixed R17 at Mid 0x%x\n", dbm, R17);
+		    return;
+		}
+		// Rule 3. leave "short or mid-distance" condition, restore R17 to the 
+		//    dynamic tuning range <E2PROM-6, BBP_R17_DYNAMIC_UP_BOUND>
+#if 1
+		else if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+		{
+			UCHAR UpperBond;
+			UCHAR LowerBond;
+
+			LowerBond = pAd->BBPR17InitValue;
+			if (dbm >= -77)
+				UpperBond = pAd->PortCfg.BbpTuning.VgcUpperBound;
+			else
+				UpperBond = pAd->PortCfg.BbpTuning.VgcUpperBound - (-77 - dbm);
+
+			if (UpperBond < LowerBond)
+				UpperBond = LowerBond;
+
+			DBGPRINT(RT_DEBUG_INFO, "R17 = %x , upper = %x, lower = %x\n", R17, UpperBond, LowerBond);
+
+			if (R17 > UpperBond)
+			{
+				pAd->PortCfg.LastR17Value = R17 = UpperBond;
+				RTUSBWriteBBPRegister(pAd, 17, R17);
+				DBGPRINT(RT_DEBUG_INFO, "RSSI = %d dbm, restore R17 to 0x%x\n", dbm, R17);
+				return;
+			}
+			if ((pAd->MACCounters[3] > FalseCcaUpperThreshold) &&
+				(R17 < UpperBond))
+			{
+				R17 += pAd->PortCfg.BbpTuning.VgcDelta;
+				pAd->PortCfg.LastR17Value = R17;
+				RTUSBWriteBBPRegister(pAd, 17, R17);
+				DBGPRINT(RT_DEBUG_INFO, "++R17= 0x%x\n", R17);
+			}
+			else if ((pAd->MACCounters[3] < pAd->PortCfg.BbpTuning.FalseCcaLowerThreshold) &&
+					(R17 > LowerBond))
+			{
+				R17 -= pAd->PortCfg.BbpTuning.VgcDelta;
+				pAd->PortCfg.LastR17Value = R17;
+				RTUSBWriteBBPRegister(pAd, 17, R17);
+				DBGPRINT(RT_DEBUG_INFO, "--R17= 0x%x\n", R17);
+			}
+			return;
+		}
+#else
+		else if (R17 >= pAd->BBPTuningParameters.BBPR17MidSensitivity)
+		{
+		    R17 = pAd->PortCfg.LastR17Value;
+		    RTUSBWriteBBPRegister(pAd, 17, R17);
+		    DBGPRINT(RT_DEBUG_TRACE, "RSSI = %d dbm, restore R17 to 0x%x\n", dbm, R17);
+		    return;
+		}
+#endif
+
+	}
+
+	// Rule 3. otherwise, R17 is currenly in dyanmic tuning range: <E2PROM-6, BBP_R17_DYNAMIC_UP_BOUND>.
+	//    Keep dynamic tuning based on False CCA conter
+
+	DBGPRINT(RT_DEBUG_INFO, "CCA flase alarm = %d, Avg RSSI= %d dbm\n", pAd->MACCounters[3], dbm);
+	if ((pAd->MACCounters[3] > FalseCcaUpperThreshold) &&
+	    (R17 < pAd->PortCfg.BbpTuning.VgcUpperBound))
+	{
+		R17 += pAd->PortCfg.BbpTuning.VgcDelta;
+		pAd->PortCfg.LastR17Value = R17;
+		RTUSBWriteBBPRegister(pAd, 17, R17);
+		DBGPRINT(RT_DEBUG_INFO, "++R17= 0x%x\n", R17);
+	}
+	else if ((pAd->MACCounters[3] < pAd->PortCfg.BbpTuning.FalseCcaLowerThreshold) &&
+	    (R17 > pAd->PortCfg.VgcLowerBound))
+	{
+		R17 -= pAd->PortCfg.BbpTuning.VgcDelta;
+		pAd->PortCfg.LastR17Value = R17;
+		RTUSBWriteBBPRegister(pAd, 17, R17);
+		DBGPRINT(RT_DEBUG_INFO, "--R17= 0x%x\n", R17);
+	}
+
+}
+
+// stop and restore R17 value upon SITE-SURVEY and LINK-DOWN
+VOID AsicRestoreBbpSensibility(
+	IN PRT2570ADAPTER pAd)
+{
+	UCHAR R17;
+		DBGPRINT(RT_DEBUG_TRACE, "AsicRestoreBbpSensibility\n");
+
+	R17 = pAd->PortCfg.BbpWriteLatch[17];
+	if (R17 >= pAd->BBPTuningParameters.BBPR17MidSensitivity)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "1AsicRestoreBbpSensibility\n");
+		R17 = pAd->PortCfg.LastR17Value;
+		RTUSBWriteBBPRegister(pAd, 17, R17);
+		DBGPRINT(RT_DEBUG_ERROR, "AsicRestoreBbpSensibility(set R17= 0x%x)\n", R17);
+	}
+
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		Mlme free the in-used nonpaged memory,
+		move it to the unused memory link list
+
+	Arguments:
+		pAd 				Pointer to our adapter
+		AllocVa 			Pointer to the base virtual address for free
+
+	Return Value:
+		None
+
+	Note:
+
+	========================================================================
+*/
+VOID	MlmeFreeMemory(
+	IN PRT2570ADAPTER pAd,
+	IN PVOID		 AllocVa)
+{
+	PMLME_MEMORY_STRUCT 			pPrevious;
+	PMLME_MEMORY_STRUCT 			pMlmeMemoryStruct;
+	BOOLEAN 						bIsFound;
+
+	if (AllocVa == NULL)
+		return;
+
+ 	bIsFound = FALSE;
+	pPrevious = NULL;
+	pMlmeMemoryStruct = pAd->Mlme.MemHandler.pInUseHead;
+	while (pMlmeMemoryStruct)
+	{
+//		DBGPRINT(RT_DEBUG_TRACE,"pMlmeMemoryStruct->AllocVa=%x\n",(int)pMlmeMemoryStruct->AllocVa);
+		if (pMlmeMemoryStruct->AllocVa == AllocVa)
+		{ 
+			//Found virtual address in the in-used link list
+			//Remove it from the memory in-used link list, and move it to the unused link list
+			if (pPrevious == NULL)
+				pAd->Mlme.MemHandler.pInUseHead = pMlmeMemoryStruct->Next;
+			else
+				pPrevious->Next = pMlmeMemoryStruct->Next;
+			pAd->Mlme.MemHandler.InUseCount--;
+
+			//append it to the tail of unused list
+			pMlmeMemoryStruct->Next = NULL;
+ 			if ((pAd->Mlme.MemHandler.pUnUseHead == NULL))
+			{ //No head, add it as head
+				pAd->Mlme.MemHandler.pUnUseHead = pMlmeMemoryStruct;
+				pAd->Mlme.MemHandler.pUnUseTail = pMlmeMemoryStruct;
+			}
+			else
+			{
+				//Append it to the tail in pAd->Mlme.MemHandler.pUnUseTail
+				pAd->Mlme.MemHandler.pUnUseTail->Next = pMlmeMemoryStruct;
+				pAd->Mlme.MemHandler.pUnUseTail = pAd->Mlme.MemHandler.pUnUseTail->Next;
+			}
+			pAd->Mlme.MemHandler.UnUseCount++;
+ 
+			bIsFound = TRUE;
+			break;
+		}
+		else
+		{
+			pPrevious = pMlmeMemoryStruct;
+			pMlmeMemoryStruct = pMlmeMemoryStruct->Next;
+		}
+	}
+ }
+
+/*
+	========================================================================
+
+	Routine Description:
+		Get an unused nonpaged system-space memory for use
+
+	Arguments:
+		pAd 				Pointer to our adapter
+		AllocVa 			Pointer to the base virtual address for later use
+
+	Return Value:
+		NDIS_STATUS_SUCCESS
+		NDIS_STATUS_FAILURE
+		NDIS_STATUS_RESOURCES
+
+	Note:
+
+	========================================================================
+*/
+
+NDIS_STATUS MlmeAllocateMemory(
+	IN PRT2570ADAPTER pAd,
+	OUT PVOID		 *AllocVa)
+{
+	PMLME_MEMORY_STRUCT 			pMlmeMemoryStruct = NULL;
+
+	DBGPRINT(RT_DEBUG_INFO,"==> MlmeAllocateMemory\n");
+
+
+ 	if (pAd->Mlme.MemHandler.pUnUseHead == NULL)
+	{ //There are no available memory for caller use
+ 		DBGPRINT(RT_DEBUG_ERROR,"MlmeAllocateMemory, failed!! (There are no available memory in list)\n");
+		DBGPRINT(RT_DEBUG_ERROR,"<== MlmeAllocateMemory\n");
+		return (NDIS_STATUS_RESOURCES);
+	}
+	pMlmeMemoryStruct = pAd->Mlme.MemHandler.pUnUseHead;
+	//Unused memory point to next available
+	pAd->Mlme.MemHandler.pUnUseHead = pAd->Mlme.MemHandler.pUnUseHead->Next;
+	if (pAd->Mlme.MemHandler.pUnUseHead == NULL)
+		pAd->Mlme.MemHandler.pUnUseTail = NULL;
+	pAd->Mlme.MemHandler.UnUseCount--;
+ 
+	*AllocVa = pMlmeMemoryStruct->AllocVa;			//Saved porint to Pointer the base virtual address of the nonpaged memory for caller use.
+
+	pMlmeMemoryStruct->Next = NULL;
+	//Append the unused memory link list to the in-used link list tail
+	if (pAd->Mlme.MemHandler.pInUseHead == NULL)
+	{//no head, so current Item assign to In-use Head.
+		pAd->Mlme.MemHandler.pInUseHead = pMlmeMemoryStruct;
+		pAd->Mlme.MemHandler.pInUseTail = pMlmeMemoryStruct;
+	}
+	else
+	{
+		pAd->Mlme.MemHandler.pInUseTail->Next = pMlmeMemoryStruct;
+		pAd->Mlme.MemHandler.pInUseTail = pAd->Mlme.MemHandler.pInUseTail->Next;
+	}
+	pAd->Mlme.MemHandler.InUseCount++;
+ 
+
+
+	DBGPRINT(RT_DEBUG_INFO, "MlmeAllocateMemory [pMlmeMemoryStruct=0x%lx][VA=0x%lx]\n", (unsigned long)pMlmeMemoryStruct, (unsigned long)pMlmeMemoryStruct->AllocVa);
+	DBGPRINT(RT_DEBUG_INFO, "<== MlmeAllocateMemory[IN:%d][UN:%d]\n",
+				pAd->Mlme.MemHandler.InUseCount, pAd->Mlme.MemHandler.UnUseCount);
+	return (NDIS_STATUS_SUCCESS);
+}
+
+
+/*
+	========================================================================
+
+	Routine Description:
+		Allocates resident (nonpaged) system-space memory for MLME send frames
+
+	Arguments:
+		pAd 				Pointer to our adapter
+		Number				Total nonpaged memory for use
+		Size				Each nonpaged memory size
+
+	Return Value:
+		NDIS_STATUS_SUCCESS
+		NDIS_STATUS_RESOURCES
+
+	Note:
+
+	========================================================================
+*/
+NDIS_STATUS MlmeInitMemoryHandler(
+	IN PRT2570ADAPTER pAd,
+	IN UINT  Number,
+	IN UINT  Size)
+{
+	PMLME_MEMORY_STRUCT 		Current = NULL;
+	NDIS_STATUS 				Status = NDIS_STATUS_SUCCESS;
+	UINT						i;
+
+	DBGPRINT(RT_DEBUG_INFO,"==> MlmeInitMemory\n");
+	pAd->Mlme.MemHandler.MemoryCount = 0;
+	pAd->Mlme.MemHandler.pInUseHead = NULL;
+	pAd->Mlme.MemHandler.pInUseTail = NULL;
+	pAd->Mlme.MemHandler.pUnUseHead = NULL;
+	pAd->Mlme.MemHandler.pUnUseTail = NULL;
+	pAd->Mlme.MemHandler.MemRunning = FALSE;
+
+ 	//initial the memory free-pending array all to NULL;
+	for (i = 0; i < MAX_MLME_HANDLER_MEMORY; i++)
+		pAd->Mlme.MemHandler.MemFreePending[i] = NULL;
+
+ 	//
+	// Available nonpaged memory counts MAX_MLME_HANDLER_MEMORY
+	//
+	if (Number > MAX_MLME_HANDLER_MEMORY)
+		Number = MAX_MLME_HANDLER_MEMORY;
+        
+	for (i = 0; i < Number; i++)
+	{
+		//Allocate a nonpaged memory for link list use.
+		//Status = NdisAllocateMemoryWithTag((VOID *)&Current, sizeof(MLME_MEMORY_STRUCT), NIC_TAG);
+		 Current= (PMLME_MEMORY_STRUCT) kmalloc(sizeof(MLME_MEMORY_STRUCT), GFP_ATOMIC);
+		 if (!Current) {
+				DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+				Status = NDIS_STATUS_RESOURCES;
+				break;
+		 }	
+		
+
+		Current->AllocVa= (VOID *) kmalloc(Size, GFP_ATOMIC);
+		 if (!Current->AllocVa) {
+				DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+				kfree((VOID *)Current);
+				Status = NDIS_STATUS_RESOURCES;
+				break;
+		 }
+
+		memset(Current->AllocVa, 0, Size);
+
+		pAd->Mlme.MemHandler.MemoryCount++;
+
+		//build up the link list
+		if (pAd->Mlme.MemHandler.pUnUseHead != NULL)
+		{
+			Current->Next = pAd->Mlme.MemHandler.pUnUseHead;
+			pAd->Mlme.MemHandler.pUnUseHead = Current;
+		}
+		else
+		{
+			Current->Next = NULL;
+			pAd->Mlme.MemHandler.pUnUseHead = Current;
+		}
+
+		if (pAd->Mlme.MemHandler.pUnUseTail == NULL)
+			pAd->Mlme.MemHandler.pUnUseTail = Current;
+
+	}
+	
+	if (pAd->Mlme.MemHandler.MemoryCount < Number)
+	{
+		Status = NDIS_STATUS_RESOURCES;
+		DBGPRINT(RT_DEBUG_TRACE,"MlmeInitMemory Initial failed [Require=%d, available=%d]\n", Number, pAd->Mlme.MemHandler.MemoryCount);
+	}
+
+	pAd->Mlme.MemHandler.InUseCount = 0;
+	pAd->Mlme.MemHandler.UnUseCount = Number;
+	pAd->Mlme.MemHandler.PendingCount = 0;
+ 	DBGPRINT(RT_DEBUG_INFO,"<== MlmeInitMemory\n");
+	
+	return (Status);
+}
+
+
+VOID DeleteTimer(
+	IN PRT2570ADAPTER	 pAd)
+{
+}
+
+
+/*
+    ========================================================================
+
+    Routine Description:
+        Free Mlme memory handler (link list, nonpaged memory, spin lock)
+
+    Arguments:
+        pAd                 Pointer to our adapter
+
+    Return Value:
+        None
+    ========================================================================
+*/
+VOID MlmeFreeMemoryHandler(
+    IN PRT2570ADAPTER pAd)
+{
+	PMLME_MEMORY_STRUCT      pMlmeMemoryStruct = NULL;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->MlmeFreeMemoryHandler\n");
+
+	while (pAd->Mlme.MemHandler.pInUseHead != NULL)
+	{
+	    pMlmeMemoryStruct = pAd->Mlme.MemHandler.pInUseHead;
+	    pAd->Mlme.MemHandler.pInUseHead = pAd->Mlme.MemHandler.pInUseHead->Next;
+	    //Free the virtual address in AllocVa which size is MAX_LEN_OF_MLME_BUFFER
+	    kfree(pMlmeMemoryStruct->AllocVa);
+	    //Free the link list item self
+	    kfree(pMlmeMemoryStruct);
+	}
+
+	//Free nonpaged memory, free it in the *Unused* link list.
+	while (pAd->Mlme.MemHandler.pUnUseHead != NULL)
+	{
+	    pMlmeMemoryStruct = pAd->Mlme.MemHandler.pUnUseHead;
+	    pAd->Mlme.MemHandler.pUnUseHead = pAd->Mlme.MemHandler.pUnUseHead->Next;
+	    //Free the virtual address in AllocVa which size is MAX_LEN_OF_MLME_BUFFER
+	    kfree(pMlmeMemoryStruct->AllocVa);
+	    //Free the link list item self
+	    kfree(pMlmeMemoryStruct);
+	}
+	
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---MlmeFreeMemoryHandler\n");
+}
+/*
+    ========================================================================
+
+    Routine Description:
+        Verify the support rate for different PHY type
+
+    Arguments:
+        pAd                 Pointer to our adapter
+
+    Return Value:
+        None
+        
+	IRQL = PASSIVE_LEVEL
+
+    ========================================================================
+*/
+VOID	RTMPCheckRates(
+	IN		PRT2570ADAPTER	pAd,
+	IN OUT	UCHAR			SupRate[],
+	IN OUT	UCHAR			*SupRateLen)
+{
+	UCHAR	RateIdx, i, j;
+	UCHAR	NewRate[12], NewRateLen;
+	
+	NewRateLen = 0;
+	
+	if (pAd->PortCfg.PhyMode == PHY_11B)
+		RateIdx = 4;
+	else
+		RateIdx = 12;
+
+	// Check for support rates exclude basic rate bit	
+	for (i = 0; i < *SupRateLen; i++)
+		for (j = 0; j < RateIdx; j++)
+			if ((SupRate[i] & 0x7f) == RateIdTo500Kbps[j])
+				NewRate[NewRateLen++] = SupRate[i];
+			
+	*SupRateLen = NewRateLen;
+	memcpy(SupRate, NewRate, NewRateLen);
+}
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/mlme.h linux-2.4.35.3-mct/drivers/usb/rt2570/mlme.h
--- linux-2.4.35.3/drivers/usb/rt2570/mlme.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/mlme.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,498 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	mlme.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#ifndef __MLME_H__
+#define __MLME_H__
+
+// maximum supported capability information - 
+// ESS, IBSS, Privacy, Short Preamble, Short Slot
+#define SUPPORTED_CAPABILITY_INFO 0x0433
+
+#define END_OF_ARGS             -1
+#define LFSR_MASK               0x80000057
+#define TBTT_PRELOAD_TIME       384        // usec. LomgPreamble + 24-byte at 1Mbps
+#define MLME_TASK_EXEC_INTV     (1000)		// 1 sec
+
+#define BEACON_LOST_TIME        (4*HZ)
+
+//#define AUTH_KEY_TIMEOUT        500     // unit: msec
+//#define AUTH_OPEN_TIMEOUT       200     // unit: msec
+#define AUTH_TIMEOUT            300     // unit: msec
+#define ASSOC_TIMEOUT           300     // unit: msec
+#define JOIN_TIMEOUT            2000     // unit: msec
+#define MIN_CHANNEL_TIME        110        // unit: msec, for dual band scan
+#define MAX_CHANNEL_TIME        140       // unit: msec, for single band scan
+#define	ACTIVE_SCAN_TIME		40			// Active scan waiting for probe response time
+
+#define CW_MIN_IN_BITS          3       // actual CwMin = 2^CW_MIN_IN_BITS - 1 = 31
+#define CW_MAX_IN_BITS          5       // actual CwMax = 2^CW_MAX_IN_BITS - 1 = 1023
+
+#define BEACON_CW_IN_BITS          5
+
+//blue,#define RSSI_TO_DBM_OFFSET      110       // for RT2530 RSSI-110 = dBm
+#define RSSI_TO_DBM_OFFSET          120 // for RT2530 RSSI-115 = dBm
+#define RSSI_FOR_MID_TX_POWER       55  // -55 db is considered mid-distance
+#define RSSI_FOR_LOW_TX_POWER       45  // -45 db is considered very short distance and 
+                                        // eligible to use a lower TX power
+#define RSSI_FOR_LOWEST_TX_POWER    30
+#define MID_TX_POWER_DELTA          0   // -3 db from full TX power upon mid-distance to AP
+#define LOW_TX_POWER_DELTA          3   // -8 db from full TX power upon very short distance
+#define LOWEST_TX_POWER_DELTA       6   // -12 db from full TX power upon shortest distance
+
+#define RSSI_TRIGGERED_UPON_BELOW_THRESHOLD     0
+#define RSSI_TRIGGERED_UPON_EXCCEED_THRESHOLD   1
+#define RSSI_THRESHOLD_FOR_ROAMING              25
+#define RSSI_DELTA                              5
+
+// Channel Quality Indication
+//#define CQI_GOOD_THRESHOLD      70  // >= this threshold means channel quality GOOD
+//#define CQI_FAIR_THRESHOLD      50  // >= this threshold means channel quality FAIR
+//#define CQI_POOR_THRESHOLD      30  // >= this threshold means channel quality POOR
+                                    // < this threshold means channel quality really BAD, link down
+#define CQI_IS_GOOD(cqi)        ((cqi) >= 50)
+#define CQI_IS_FAIR(cqi)        (((cqi) >= 20) && ((cqi) < 50)) // (((cqi) >= 50) && ((cqi) < 70))
+#define CQI_IS_POOR(cqi)        (((cqi) >= 5) && ((cqi) < 20))  // (((cqi) >= 25) && ((cqi) < 50))
+#define CQI_IS_BAD(cqi)         ((cqi) < 5)                     // ((cqi) < 25)
+
+// weighting factor to calculate Channel quality, total should be 100%
+#define RSSI_WEIGHTING          40
+#define TX_WEIGHTING            40
+#define RX_WEIGHTING            20
+
+// prime number closest to 256
+//#define HASH_TABLE_SIZE                  191 //191 is another prime
+// Only allows 32 entries in the table
+#define MAC_TABLE_MAX_CAPACITY           32
+
+#define MAC_ENTRY_NOT_USED               0xff
+#define CONTENT_NOT_AVAIL                0xaa
+
+// 10 minute of age out
+#define MAC_TABLE_AGE_OUT_TIME           0xffffff
+
+#define MAC_ADDR_HASH_ERROR              0xfffffffe
+#define MAC_TABLE_UNKNOWN_INDEX          0xff
+#define MAC_TABLE_ADDR_NOT_IN            0xfffffffd
+
+#define PEER_KEY_NOT_USED                0
+#define PEER_KEY_64_BIT                  64
+#define PEER_KEY_128_BIT                 128
+
+#define PEER_KEY_64BIT_LEN               8
+#define PEER_KEY_128BIT_LEN              16
+
+#define MAX_LEN_OF_BSS_TABLE             64
+#define BSS_NOT_FOUND                    0xFFFFFFFF
+
+#define MAX_LEN_OF_MLME_QUEUE            100
+#define MAX_LEN_OF_MLME_QUEUE_MSG        512
+
+//! assoc state-machine states
+#define ASSOC_IDLE                       0
+#define ASSOC_WAIT_RSP                   1
+#define REASSOC_WAIT_RSP                 2
+#define DISASSOC_WAIT_RSP                3
+#define MAX_ASSOC_STATE                  4
+
+#define ASSOC_FUNC_SIZE                  44 // 4-state * 12-event
+
+//authentication state machine
+#define AUTH_REQ_IDLE                    0
+#define AUTH_WAIT_SEQ2                   1
+#define AUTH_WAIT_SEQ4                   2
+#define MAX_AUTH_STATE                   3
+
+#define AUTH_FUNC_SIZE                   15 // 3-state * 5-event
+
+#define AUTH_RSP_IDLE                    0
+#define AUTH_RSP_WAIT_CHAL               1
+#define MAX_AUTH_RSP_STATE               2
+
+#define AUTH_RSP_FUNC_SIZE               6 // 2-state * 3-event
+
+// SYNC state machine
+#define SYNC_IDLE                        0 // merge NO_BSS,IBSS_IDLE,IBSS_ACTIVE and BSS in to 1 state
+#define JOIN_WAIT_BEACON                 1
+#define SCAN_LISTEN                      2
+#define MAX_SYNC_STATE                   3
+
+#define SYNC_FUNC_SIZE                   30  // 3-state * 10-event
+
+#define SCAN_PASSIVE                     18
+#define SCAN_ACTIVE                      19
+
+//WPA State machine
+#define WPA_PSK_IDLE                    0
+#define MAX_WPA_PSK_STATE               1
+#define WPA_PSK_FUNC_SIZE               5
+
+
+// Control state machine
+#define CNTL_IDLE                        100
+#define CNTL_WAIT_DISASSOC               101
+#define CNTL_WAIT_JOIN                   102
+#define CNTL_WAIT_REASSOC                103
+#define CNTL_WAIT_START                  104
+#define CNTL_WAIT_AUTH                   105
+#define CNTL_WAIT_ASSOC                  106
+#define CNTL_WAIT_AUTH2                  107
+#define CNTL_WAIT_OID_LIST_SCAN          108
+#define CNTL_WAIT_OID_DISASSOC           109
+
+//#define BSS_TABLE_EMPTY(x)               ((x).BssNr == 0)
+#define CapabilityInfoGen(Ess,Ibss,Cfp,CfpReq,Priv) ((Ess) ? 0x0001 : 0x0000) | ((Ibss) ? 0x0002 : 0x0000) | ((Cfp) ? 0x0004 : 0x0000) | ((CfpReq) ? 0x0008 : 0x0000) | ((Priv) ? 0x0010: 0x0000)
+
+
+#define MAC_ADDR_IS_GROUP(Addr)       ((((Addr).Octet[0]) & 0x01) != 0)
+#define MAC_ADDR_HASH(Addr)           ((Addr).Octet[0] ^ (Addr).Octet[1] ^ (Addr).Octet[2] ^ (Addr).Octet[3] ^ (Addr).Octet[4] ^ (Addr).Octet[5])
+#define MAC_ADDR_HASH_INDEX(Addr)     (MAC_ADDR_HASH(Addr) % HASH_TABLE_SIZE)
+#define MAC_ADDR_EQUAL(pAddr1,pAddr2) (memcmp((PVOID)(pAddr1), (PVOID)(pAddr2), MAC_ADDR_LEN) == 0)
+#define COPY_MAC_ADDR(Addr1, Addr2)   memcpy((Addr1), (Addr2), ETH_LENGTH_OF_ADDRESS)
+//#define MAKE_BROADCAST_ADDR(Addr)     memset(&Addr, 0xff,MAC_ADDR_LEN)
+
+// LED Control
+// assoiation ON. one LED ON. another blinking when TX, OFF when idle
+#define ASIC_LED_ACT_ON(pAdapter)         RTUSBWriteMACRegister(pAdapter, MAC_CSR20, 0x0003)
+// no association, both LED off
+#define ASIC_LED_ACT_OFF(pAdapter)        RTUSBWriteMACRegister(pAdapter, MAC_CSR20, 0x0000)
+//#define ASIC_LED_LINK_UP(pAdapter)        RTMP_IO_WRITE32(pAdapter, LEDCSR, 0x00011E46)
+//#define ASIC_LED_LINK_DOWN(pAdapter)      RTMP_IO_WRITE32(pAdapter, LEDCSR, 0x00001E46)
+
+#define CAP_IS_ESS_ON(x)                     (((x) & 0x0001) != 0)
+#define CAP_IS_IBSS_ON(x)                    (((x) & 0x0002) != 0)
+#define CAP_IS_CF_POLLABLE_ON(x)             (((x) & 0x0004) != 0)
+#define CAP_IS_CF_POLL_REQ_ON(x)             (((x) & 0x0008) != 0)
+#define CAP_IS_PRIVACY_ON(x)                 (((x) & 0x0010) != 0)
+
+// 802.11G capability features
+#define CAP_IS_SHORT_PREAMBLE_ON(x)          (((x) & 0x0020) != 0)
+#define CAP_IS_PBCC_ON(x)                    (((x) & 0x0040) != 0)
+#define CAP_IS_AGILITY_ON(x)                 (((x) & 0x0080) != 0)
+#define CAP_IS_EXT_RATE_PBCC_ON(x)           (((x) & 0x0100) != 0)
+//#define CAP_IS_CCK_OFDM_ON(x)                (((x) & 0x0200) != 0)
+#define CAP_IS_QOS(x)                        (((x) & 0x0200) != 0)  // defined in 802.11e d4.3
+#define CAP_IS_SHORT_SLOT_TIME(x)            (((x) & 0x0400) != 0)
+#define CAP_IS_APSD(x)                       (((x) & 0x0800) != 0)  // defined in 802.11e d4.3
+#define CAP_IS_Q_ACK(x)                      (((x) & 0x1000) != 0)  // defined in 802.11e d4.3
+#define CAP_IS_DSSS_OFDM(x)                  (((x) & 0x2000) != 0)
+#define CAP_IS_BLOCK_ACK(x)                  (((x) & 0x4000) != 0)  // defined in 802.11e d4.3
+
+#define CAP_GENERATE(ess,ibss,cfp,cfpreq,priv,prea) ((ess) ? 0x0001 : 0x0000) | ((ibss) ? 0x0002 : 0x0000) | ((cfp) ? 0x0004 : 0x0000) | ((cfpreq) ? 0x0008 : 0x0000) | ((priv) ? 0x0010 : 0x0000) | ((prea) ? 0x0020 : 0x0000)
+
+#define ERP_IS_NON_ERP_PRESENT(x)            (((x) & 0x01) != 0)    // define in 802.11g
+#define ERP_IS_USE_PROTECTION(x)             (((x) & 0x02) != 0)    // define in 802.11g
+#define ERP_IS_USE_BARKER_PREAMBLE(x)        (((x) & 0x04) != 0)    // define in 802.11g
+
+#define TX_FER_TOO_HIGH(TxFER)     ((TxFER) > 15)   // consider rate down if FER>15%
+#define TX_FER_VERY_LOW(TxFER)     ((TxFER) < 7)    // consider rate up if FER<7%
+#define FAIR_FER                   10               // any value between TOO_HIGH and VERY_LOW
+//blue,#define DRS_TX_QUALITY_WORST_BOUND      4 
+#if 1
+#define DRS_TX_QUALITY_WORST_BOUND      4
+#else
+#define DRS_TX_QUALITY_WORST_BOUND      6
+#endif
+#define DRS_PENALTY                     8
+
+// Mac Address data structure
+typedef struct _MACADDR {
+    UCHAR     Octet[MAC_ADDR_LEN];
+} MACADDR, *PMACADDR;
+
+// Mac Frame Header
+typedef struct _MACHDR {
+    // 2-byte Frame Control. NOTE: bit field assigned from LSB first
+    USHORT    Ver:2;
+    USHORT    Type:2;
+    USHORT    SubType:4;
+    USHORT    Tods:1;
+    USHORT    Frds:1;
+    USHORT    MoreFrag:1;
+    USHORT    Retry:1;
+    USHORT    PwrMgmt:1;
+    USHORT    MoreData:1;
+    USHORT    Wep:1;
+    USHORT    Order:1;
+    
+    USHORT    Duration;
+    MACADDR   Addr1;
+    MACADDR   Addr2;
+    MACADDR   Addr3;
+    
+    USHORT    Frag:4;
+    USHORT    Seq:12;
+} MACHDR, *PMACHDR;
+
+typedef struct _MACFRAME {
+    MACHDR    Hdr;
+    CHAR      Octet[1];
+} MACFRAME, *PMACFRAME;
+
+typedef struct _PSPOLL_FRAME {
+    USHORT    Ver:2;
+    USHORT    Type:2;
+    USHORT    SubType:4;
+    USHORT    Tods:1;
+    USHORT    Frds:1;
+    USHORT    MoreFrag:1;
+    USHORT    Retry:1;
+    USHORT    PwrMgmt:1;
+    USHORT    MoreData:1;
+    USHORT    Wep:1;
+    USHORT    Order:1;
+    
+    USHORT    Aid;
+    MACADDR   Bssid;
+    MACADDR   Ta;
+} PSPOLL_FRAME;
+
+//
+// Contention-free parameter (without ID and Length)
+//
+typedef struct _CF_PARM {
+    UCHAR        CfpCount;
+    UCHAR        CfpPeriod;
+    USHORT       CfpMaxDuration;
+    USHORT       CfpDurRemaining;
+} CF_PARM, *PCF_PARM;
+
+
+typedef	struct	_CIPHER_SUITE	{
+	NDIS_802_11_ENCRYPTION_STATUS	PairCipher;		// Unicast cipher 1, this one has more secured cipher suite
+	NDIS_802_11_ENCRYPTION_STATUS	PairCipherAux;	// Unicast cipher 2 if AP announce two unicast cipher suite
+	NDIS_802_11_ENCRYPTION_STATUS	GroupCipher;	// Group cipher
+	USHORT							RsnCapability;	// RSN capability from beacon
+	BOOLEAN							bMixMode;		// Indicate Pair & Group cipher might be different
+}	CIPHER_SUITE, *PCIPHER_SUITE;	
+
+typedef struct {
+    MACADDR Bssid;
+    UCHAR   Channel;
+    UCHAR   BssType;
+    USHORT  AtimWin;
+    USHORT  BeaconPeriod;
+
+    UCHAR   Rates[MAX_LEN_OF_SUPPORTED_RATES];
+    UCHAR   RatesLen;
+    BOOLEAN ExtendedRateIeExist; // records if this AP use EXTENDED_SUPPORTED_RATES IE
+    UCHAR   Rssi;
+    UCHAR   Privacy;			// Indicate security function ON/OFF. Don't mess up with auth mode.
+	UCHAR	Hidden;
+
+    USHORT  DtimPeriod;
+    USHORT  CapabilityInfo;
+
+    USHORT  CfpCount;
+    USHORT  CfpPeriod;
+    USHORT  CfpMaxDuration;
+    USHORT  CfpDurRemaining;
+    UCHAR   SsidLen;
+    CHAR    Ssid[MAX_LEN_OF_SSID];
+    
+    ULONG   LastBeaconRxTime; // OS's timestamp
+
+	// New for WPA2
+	CIPHER_SUITE					WPA;			// AP announced WPA cipher suite
+	CIPHER_SUITE					WPA2;			// AP announced WPA2 cipher suite
+
+	// New for microsoft WPA support
+	NDIS_802_11_FIXED_IEs	FixIEs;
+	NDIS_802_11_AUTHENTICATION_MODE	AuthModeAux;	// Addition mode for WPA2 / WPA capable AP
+	NDIS_802_11_AUTHENTICATION_MODE	AuthMode;
+	NDIS_802_11_WEP_STATUS	WepStatus;				// Unicast Encryption Algorithm extract from VAR_IE
+	UCHAR					VarIELen;				// Length of next VIE include EID & Length
+	UCHAR					VarIEs[MAX_VIE_LEN];
+} BSS_ENTRY, *PBSS_ENTRY;
+
+typedef struct {
+    UCHAR           BssNr;
+    BSS_ENTRY       BssEntry[MAX_LEN_OF_BSS_TABLE];
+} BSS_TABLE, *PBSS_TABLE;
+
+
+typedef struct _MLME_QUEUE_ELEM {
+    ULONG             Machine;
+    ULONG             MsgType;
+    ULONG             MsgLen;
+    UCHAR             Rssi;
+    BOOLEAN           Occupied;
+    UCHAR             Msg[MAX_LEN_OF_MLME_BUFFER];
+} MLME_QUEUE_ELEM, *PMLME_QUEUE_ELEM;
+
+typedef struct _MLME_QUEUE {
+    ULONG             Num;
+    ULONG             Head;
+    ULONG             Tail;
+    spinlock_t   Lock;
+    MLME_QUEUE_ELEM  Entry[MAX_LEN_OF_MLME_QUEUE];
+} MLME_QUEUE, *PMLME_QUEUE;
+
+typedef VOID (*STATE_MACHINE_FUNC)(VOID *Adaptor, MLME_QUEUE_ELEM *Elem);
+
+typedef struct _STATE_MACHINE {
+    ULONG                           Base;
+    ULONG                           NrState;
+    ULONG                           NrMsg;
+    ULONG                           CurrState;
+    STATE_MACHINE_FUNC             *TransFunc;
+} STATE_MACHINE, *PSTATE_MACHINE;
+
+// CNTL State Machine Aux data structure
+typedef struct _CNTL_AUX {
+    UCHAR               Ssid[MAX_LEN_OF_SSID];
+    UCHAR               SsidLen;
+    MACADDR             Bssid;
+    BSS_TABLE           SsidBssTab;     // AP list for the same SSID
+    BSS_TABLE           RoamTab;        // AP list eligible for roaming
+    ULONG               BssIdx;
+    ULONG               RoamIdx;
+    BOOLEAN             CurrReqIsFromNdis; // TRUE - then we should call NdisMSetInformationComplete()
+                                           // FALSE - req is from driver itself. 
+                                           // no NdisMSetInformationComplete() is required
+} CNTL_AUX, *PCNTL_AUX;
+
+// ASSOC State Machine Aux data structure
+typedef struct _ASSOC_AUX {
+    MACADDR             Addr;
+    USHORT              CapabilityInfo;
+    USHORT              ListenIntv;
+    CHAR                Ssid[MAX_LEN_OF_SSID];
+    UCHAR               SsidLen;    
+    RALINK_TIMER_STRUCT	 AssocTimer, ReassocTimer, DisassocTimer;
+} ASSOC_AUX, *PASSOC_AUX;
+
+// AUTH State Machine Aux data structure
+typedef struct _AUTH_AUX {
+    MACADDR             Addr;
+    USHORT              Alg;
+     RALINK_TIMER_STRUCT	AuthTimer;
+} AUTH_AUX, *PAUTH_AUX;
+
+// AUTH-RSP State Machine Aux data structure
+typedef struct _AUTH_RSP_AUX {
+    MACADDR             Addr;
+    USHORT              Alg;
+    CHAR                Challenge[CIPHER_TEXT_LEN];
+     RALINK_TIMER_STRUCT	AuthRspTimer;
+} AUTH_RSP_AUX, *PAUTH_RSP_AUX;
+
+// SYNC State Machine Aux data structure
+typedef struct _SYNC_AUX {
+    MACADDR             Addr;
+    MACADDR             Bssid;
+    UCHAR               BssType;
+    UCHAR               SsidLen;
+    CHAR                Ssid[MAX_LEN_OF_SSID];
+    UCHAR               ScanType;
+    UCHAR               Channel;
+     RALINK_TIMER_STRUCT	BeaconTimer, ScanTimer;
+} SYNC_AUX;
+
+ // assoc struct is equal to reassoc
+typedef struct _MLME_ASSOC_REQ_STRUCT{
+    MACADDR   Addr;
+    USHORT    CapabilityInfo;
+    USHORT    ListenIntv;
+    ULONG     Timeout;
+} MLME_ASSOC_REQ_STRUCT, *PMLME_ASSOC_REQ_STRUCT, MLME_REASSOC_REQ_STRUCT, *PMLME_REASSOC_REQ_STRUCT;
+
+typedef struct _MLME_DISASSOC_REQ_STRUCT{
+    MACADDR   Addr;
+    USHORT    Reason;
+} MLME_DISASSOC_REQ_STRUCT, *PMLME_DISASSOC_REQ_STRUCT;
+
+typedef struct _MLME_AUTH_REQ_STRUCT {
+    MACADDR      Addr;
+    USHORT       Alg;
+    ULONG        Timeout;
+} MLME_AUTH_REQ_STRUCT, *PMLME_AUTH_REQ_STRUCT;
+
+typedef struct _MLME_DEAUTH_REQ_STRUCT {
+    MACADDR      Addr;
+    USHORT       Reason;
+} MLME_DEAUTH_REQ_STRUCT, *PMLME_DEAUTH_REQ_STRUCT;
+
+//typedef struct _MLME_AUTH_IND_STRUCT {
+//    MACADDR      Addr;
+//    USHORT       Alg;
+//} MLME_AUTH_IND_STRUCT, *PMLME_AUTH_IND_STRUCT;
+
+//typedef struct _CLS2ERR_STRUCT {
+//    MACADDR      Addr;
+//} CLS2ERR_STRUCT, *PCLS2ERR_STRUCT;
+
+typedef struct {
+    ULONG      BssIdx;
+} MLME_JOIN_REQ_STRUCT;
+
+typedef struct _MLME_SCAN_REQ_STRUCT {
+    MACADDR    Bssid;
+    UCHAR      BssType;
+    UCHAR      ScanType;
+    UCHAR      SsidLen;
+    CHAR       Ssid[MAX_LEN_OF_SSID];
+} MLME_SCAN_REQ_STRUCT, *PMLME_SCAN_REQ_STRUCT;
+
+typedef struct _MLME_START_REQ_STRUCT {
+    CHAR        Ssid[MAX_LEN_OF_SSID];
+    UCHAR       SsidLen;
+} MLME_START_REQ_STRUCT, *PMLME_START_REQ_STRUCT;
+
+typedef struct _ARC4_CONTEXT {
+    UCHAR x, y, State[256], Key[16];     // 128 bits key
+} ARC4_CONTEXT, *PARC4_CONTEXT;
+
+typedef struct _BEACON_EID_STRUCT {
+    UCHAR   Eid;
+    UCHAR   Len;
+    CHAR   Octet[1];
+} BEACON_EID_STRUCT,*PBEACON_EID_STRUCT;
+
+// New for WPA cipher suite 
+typedef	struct	_RSN_EID_STRUCT	{
+	UCHAR	Eid;
+	UCHAR	Length;
+	UCHAR	Oui[4];
+	USHORT	Version;
+	UCHAR	Multicast[4];
+	USHORT	Count;
+	struct	{
+		UCHAR	Oui[4];
+	}	Unicast[1];
+}	RSN_EID_STRUCT, *PRSN_EID_STRUCT;
+
+extern UCHAR  RateIdToMbps[];
+extern USHORT RateIdTo500Kbps[];
+
+#endif	// MLME_H__
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/oid.h linux-2.4.35.3-mct/drivers/usb/rt2570/oid.h
--- linux-2.4.35.3/drivers/usb/rt2570/oid.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/oid.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,750 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	oid.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+
+#ifndef _OID_H_
+#define _OID_H_
+
+
+#if WIRELESS_EXT <= 11
+#ifndef SIOCDEVPRIVATE
+#define SIOCDEVPRIVATE                              0x8BE0
+#endif
+#define SIOCIWFIRSTPRIV                             SIOCDEVPRIVATE
+#endif
+
+#define RTPRIV_IOCTL_AUTH                           (SIOCIWFIRSTPRIV + 0)
+#define RTPRIV_IOCTL_WEPSTATUS                      (SIOCIWFIRSTPRIV + 1)
+#define RTPRIV_IOCTL_WPAPSK                         (SIOCIWFIRSTPRIV + 2)
+#define RTPRIV_IOCTL_PSM                            (SIOCIWFIRSTPRIV + 3)
+#define RTPRIV_IOCTL_ADHOCMODE			    (SIOCIWFIRSTPRIV + 4)
+#define RTPRIV_IOCTL_RFMONTX			    (SIOCIWFIRSTPRIV + 5)
+#define RTPRIV_IOCTL_FORCEPRISMHEADER		    (SIOCIWFIRSTPRIV + 6)
+
+
+//
+// IEEE 802.11 OIDs
+//
+
+
+#ifdef RT2500_DBG
+#define RTPRIV_IOCTL_BBP                            SIOCIWFIRSTPRIV + 0x06
+#define RTPRIV_IOCTL_MAC                            SIOCIWFIRSTPRIV + 0x07
+#endif
+
+
+// OID definition, since NDIS 5.0 didn't define these, we need to define for our own
+#ifndef NDIS51_MINIPORT
+
+#define OID_GEN_MACHINE_NAME               0x0001021A
+
+//RaConfig2500 (SetInformation)-->
+#define RT_OID_802_11_COUNTRY_REGION                0x0507
+#define OID_802_11_BSSID_LIST_SCAN              	 0x0508
+#define OID_802_11_SSID                    			0x0509//also in get
+#define OID_802_11_BSSID                   			0x050A//also in get
+#define RT_OID_802_11_RADIO                         		 0x050B//also in get
+#define RT_OID_802_11_PHY_MODE                      	 0x050C//also in get
+#define RT_OID_802_11_STA_CONFIG                    	 0x050D//also in get
+#define OID_802_11_DESIRED_RATES           		 0x050E
+#define RT_OID_802_11_PREAMBLE                      	 0x050F//also in get
+#define OID_802_11_WEP_STATUS                   		 0x0510//also in get
+#define OID_802_11_AUTHENTICATION_MODE           0x0511//also in get
+#define OID_802_11_INFRASTRUCTURE_MODE           0x0512//also in get
+#define RT_OID_802_11_RESET_COUNTERS                0x0513
+#define OID_802_11_RTS_THRESHOLD           		 0x0514//also in get
+#define OID_802_11_FRAGMENTATION_THRESHOLD   0x0515//also in get
+#define OID_802_11_POWER_MODE              		 0x0516//also in get
+#define OID_802_11_TX_POWER_LEVEL                      0x0517
+#define RT_OID_802_11_ADD_WPA                       	 0x0518
+#define OID_802_11_REMOVE_KEY                   		 0x0519
+#define OID_802_11_ADD_KEY                      		 0x0520
+#define RT_OID_REMOVE_ALLKEYS						0x0D730220
+#define OID_802_11_CONFIGURATION           		 0x0521//also in get
+#define OID_802_11_TX_PACKET_BURST			0x522  // NEWNEW
+#define RT_OID_802_11_QUERY_NOISE_LEVEL       0x523
+#define RT_OID_802_11_EXTRA_INFO	          0x524
+
+#define RT_OID_DEVICE_NAME                          		 0x0607
+#define RT_OID_VERSION_INFO                         		 0x0608
+#define OID_802_11_BSSID_LIST              			 0x0609
+#define OID_802_3_CURRENT_ADDRESS                      0x060A
+#define OID_GEN_MEDIA_CONNECT_STATUS               0x060B
+#define RT_OID_802_11_QUERY_LINK_STATUS                       0x060C
+#define OID_802_11_RSSI                    				 0x060D
+#define OID_802_11_STATISTICS                   		 0x060E
+#define OID_GEN_RCV_OK                           		        0x060F
+#define OID_GEN_RCV_NO_BUFFER                       	 0x0610
+
+//<-- RaConfig2500 (SetInformation)
+
+//
+// IEEE 802.11 OIDs
+//
+#define OID_802_11_NETWORK_TYPES_SUPPORTED              0x0103
+#define OID_802_11_NETWORK_TYPE_IN_USE                  0x0104
+#define OID_802_11_RSSI_TRIGGER                         		0x0107
+#define OID_802_11_NUMBER_OF_ANTENNAS                   0x010B
+#define OID_802_11_RX_ANTENNA_SELECTED                  0x010C
+#define OID_802_11_TX_ANTENNA_SELECTED                  0x010D
+#define OID_802_11_SUPPORTED_RATES                      0x010E
+#define OID_802_11_ADD_WEP                              	0x0112
+#define OID_802_11_REMOVE_WEP                           0x0113
+#define OID_802_11_DISASSOCIATE                         0x0114
+#define OID_802_11_PRIVACY_FILTER                       0x0118
+#define OID_802_11_ASSOCIATION_INFORMATION              0x011E
+#define OID_802_11_TEST                                 		0x011F
+
+// Renamed to reflect better the extended set of encryption status
+#define OID_802_11_ENCRYPTION_STATUS            OID_802_11_WEP_STATUS
+#define OID_802_11_RELOAD_DEFAULTS              0x0D01011C
+// Added to allow key mapping and default keys
+
+//
+// IEEE 802.11 Structures and definitions
+//
+// new types for Media Specific Indications
+
+#define NDIS_802_11_LENGTH_SSID         32
+#define NDIS_802_11_LENGTH_RATES        8
+#define NDIS_802_11_LENGTH_RATES_EX     16
+
+typedef enum _NDIS_802_11_STATUS_TYPE
+{
+    Ndis802_11StatusType_Authentication,
+    Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
+} NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;
+
+typedef UCHAR   NDIS_802_11_MAC_ADDRESS[6];
+
+typedef struct _NDIS_802_11_STATUS_INDICATION
+{
+    NDIS_802_11_STATUS_TYPE StatusType;
+} NDIS_802_11_STATUS_INDICATION, *PNDIS_802_11_STATUS_INDICATION;
+
+// mask for authentication/integrity fields
+#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS        0x0f
+
+#define NDIS_802_11_AUTH_REQUEST_REAUTH             0x01
+#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE          0x02
+#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR     0x06
+#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR        0x0E
+
+typedef struct _NDIS_802_11_AUTHENTICATION_REQUEST
+{
+    ULONG Length;            // Length of structure
+    NDIS_802_11_MAC_ADDRESS Bssid;
+    ULONG Flags;
+} NDIS_802_11_AUTHENTICATION_REQUEST, *PNDIS_802_11_AUTHENTICATION_REQUEST;
+
+// Added new types for OFDM 5G and 2.4G
+typedef enum _NDIS_802_11_NETWORK_TYPE
+{
+   Ndis802_11FH, 
+   Ndis802_11DS, 
+    Ndis802_11OFDM5,
+    Ndis802_11OFDM24,
+    Ndis802_11NetworkTypeMax    // not a real type, defined as an upper bound
+} NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;
+
+typedef struct _NDIS_802_11_NETWORK_TYPE_LIST
+{
+    ULONG                       NumberOfItems;  // in list below, at least 1
+   NDIS_802_11_NETWORK_TYPE    NetworkType [1];
+} NDIS_802_11_NETWORK_TYPE_LIST, *PNDIS_802_11_NETWORK_TYPE_LIST;
+
+typedef enum _NDIS_802_11_POWER_MODE
+{
+   Ndis802_11PowerModeCAM,
+   Ndis802_11PowerModeMAX_PSP,
+   Ndis802_11PowerModeFast_PSP,
+    Ndis802_11PowerModeMax      // not a real mode, defined as an upper bound
+} NDIS_802_11_POWER_MODE, *PNDIS_802_11_POWER_MODE;
+
+typedef ULONG   NDIS_802_11_TX_POWER_LEVEL; // in milliwatts
+
+//
+// Received Signal Strength Indication
+//
+typedef LONG    NDIS_802_11_RSSI;           // in dBm
+
+typedef struct _NDIS_802_11_CONFIGURATION_FH
+{
+   ULONG           Length;            // Length of structure
+   ULONG           HopPattern;        // As defined by 802.11, MSB set 
+   ULONG           HopSet;            // to one if non-802.11
+   ULONG           DwellTime;         // units are Kusec
+} NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;
+
+typedef struct _NDIS_802_11_CONFIGURATION
+{
+   ULONG                           Length;             // Length of structure
+   ULONG                           BeaconPeriod;       // units are Kusec
+   ULONG                           ATIMWindow;         // units are Kusec
+   ULONG                           DSConfig;           // Frequency, units are kHz
+   NDIS_802_11_CONFIGURATION_FH    FHConfig;
+} NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;
+
+typedef struct _NDIS_802_11_STATISTICS
+{
+   ULONG           Length;             // Length of structure
+   LARGE_INTEGER   TransmittedFragmentCount;
+   LARGE_INTEGER   MulticastTransmittedFrameCount;
+   LARGE_INTEGER   FailedCount;
+   LARGE_INTEGER   RetryCount;
+   LARGE_INTEGER   MultipleRetryCount;
+   LARGE_INTEGER   RTSSuccessCount;
+   LARGE_INTEGER   RTSFailureCount;
+   LARGE_INTEGER   ACKFailureCount;
+   LARGE_INTEGER   FrameDuplicateCount;
+   LARGE_INTEGER   ReceivedFragmentCount;
+   LARGE_INTEGER   MulticastReceivedFrameCount;
+   LARGE_INTEGER   FCSErrorCount;
+} NDIS_802_11_STATISTICS, *PNDIS_802_11_STATISTICS;
+
+typedef  ULONG  NDIS_802_11_KEY_INDEX;
+typedef ULONGLONG   NDIS_802_11_KEY_RSC;
+
+// Key mapping keys require a BSSID
+typedef struct _NDIS_802_11_KEY
+{
+    ULONG           Length;             // Length of this structure
+    ULONG           KeyIndex;           
+    ULONG           KeyLength;          // length of key in bytes
+    NDIS_802_11_MAC_ADDRESS BSSID;
+    NDIS_802_11_KEY_RSC KeyRSC;
+    UCHAR           KeyMaterial[64];     // variable length depending on above field
+} NDIS_802_11_KEY, *PNDIS_802_11_KEY;
+
+typedef struct _NDIS_802_11_REMOVE_KEY
+{
+    ULONG           Length;             // Length of this structure
+    ULONG           KeyIndex;           
+    NDIS_802_11_MAC_ADDRESS BSSID;      
+} NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;
+
+typedef struct _NDIS_802_11_WEP
+{
+   ULONG     Length;        // Length of this structure
+    ULONG           KeyIndex;           // 0 is the per-client key, 1-N are the
+                                        // global keys
+   ULONG     KeyLength;     // length of key in bytes
+   UCHAR     KeyMaterial[13];// variable length depending on above field
+} NDIS_802_11_WEP, *PNDIS_802_11_WEP;
+
+
+typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE
+{
+   Ndis802_11IBSS,
+   Ndis802_11Infrastructure,
+   Ndis802_11AutoUnknown,
+   Ndis802_11InfrastructureMax     // Not a real value, defined as upper bound
+} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;
+
+// Add new authentication modes
+typedef enum _NDIS_802_11_AUTHENTICATION_MODE
+{
+   Ndis802_11AuthModeOpen,
+   Ndis802_11AuthModeShared,
+   Ndis802_11AuthModeAutoSwitch,
+    Ndis802_11AuthModeWPA,
+    Ndis802_11AuthModeWPAPSK,
+    Ndis802_11AuthModeWPANone,
+   Ndis802_11AuthModeMax           // Not a real mode, defined as upper bound
+} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;
+
+typedef enum _RTPRIV_802_11_AUTHENTICATION_MODE
+{
+   RTPRIV802_11AuthModeOpen,
+   RTPRIV802_11AuthModeShared,
+    RTPRIV802_11AuthModeWPAPSK,
+   RTPRIV802_11AuthModeMax           // Not a real mode, defined as upper bound
+} RTPRIV_802_11_AUTHENTICATION_MODE, *PRTPRIV_802_11_AUTHENTICATION_MODE;
+typedef UCHAR   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        // Set of 8 data rates
+typedef UCHAR   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  // Set of 16 data rates
+
+typedef struct _NDIS_802_11_SSID
+{
+    ULONG   SsidLength;         // length of SSID field below, in bytes;
+                                // this can be zero.
+    UCHAR   Ssid[NDIS_802_11_LENGTH_SSID];           // SSID information field
+} NDIS_802_11_SSID, *PNDIS_802_11_SSID;
+
+
+typedef struct _NDIS_WLAN_BSSID
+{
+   ULONG                               Length;     // Length of this structure
+   NDIS_802_11_MAC_ADDRESS             MacAddress; // BSSID
+   UCHAR                               Reserved[2];
+   NDIS_802_11_SSID                    Ssid;       // SSID
+   ULONG                               Privacy;    // WEP encryption requirement
+    NDIS_802_11_RSSI                    Rssi;               // receive signal
+                                                            // strength in dBm
+   NDIS_802_11_NETWORK_TYPE            NetworkTypeInUse;
+   NDIS_802_11_CONFIGURATION           Configuration;
+   NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+   NDIS_802_11_RATES                   SupportedRates;
+} NDIS_WLAN_BSSID, *PNDIS_WLAN_BSSID;
+
+typedef struct _NDIS_802_11_BSSID_LIST
+{
+   ULONG           NumberOfItems;      // in list below, at least 1
+   NDIS_WLAN_BSSID Bssid[1];
+} NDIS_802_11_BSSID_LIST, *PNDIS_802_11_BSSID_LIST;
+
+// Added Capabilities, IELength and IEs for each BSSID
+typedef struct _NDIS_WLAN_BSSID_EX
+{
+    ULONG                               Length;             // Length of this structure
+    NDIS_802_11_MAC_ADDRESS             MacAddress;         // BSSID
+    UCHAR                               Reserved[2];
+    NDIS_802_11_SSID                    Ssid;               // SSID
+    ULONG                               Privacy;            // WEP encryption requirement
+    NDIS_802_11_RSSI                    Rssi;               // receive signal
+                                                            // strength in dBm
+    NDIS_802_11_NETWORK_TYPE            NetworkTypeInUse;
+    NDIS_802_11_CONFIGURATION           Configuration;
+    NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+    NDIS_802_11_RATES_EX                SupportedRates;
+    ULONG                               IELength;
+    UCHAR                               IEs[1];
+} NDIS_WLAN_BSSID_EX, *PNDIS_WLAN_BSSID_EX;
+
+typedef struct _NDIS_802_11_BSSID_LIST_EX
+{
+    ULONG                   NumberOfItems;      // in list below, at least 1
+    NDIS_WLAN_BSSID_EX      Bssid[1];
+} NDIS_802_11_BSSID_LIST_EX, *PNDIS_802_11_BSSID_LIST_EX;
+
+typedef struct _NDIS_802_11_FIXED_IEs 
+{
+    UCHAR Timestamp[8];
+    USHORT BeaconInterval;
+    USHORT Capabilities;
+} NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;
+
+typedef struct _NDIS_802_11_VARIABLE_IEs 
+{
+    UCHAR ElementID;
+    UCHAR Length;    // Number of bytes in data field
+    UCHAR data[1];
+} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;
+
+typedef  ULONG   NDIS_802_11_FRAGMENTATION_THRESHOLD;
+
+typedef  ULONG   NDIS_802_11_RTS_THRESHOLD;
+
+typedef  ULONG   NDIS_802_11_ANTENNA;
+
+typedef enum _NDIS_802_11_PRIVACY_FILTER
+{
+   Ndis802_11PrivFilterAcceptAll,
+   Ndis802_11PrivFilter8021xWEP
+} NDIS_802_11_PRIVACY_FILTER, *PNDIS_802_11_PRIVACY_FILTER;
+
+// Added new encryption types
+// Also aliased typedef to new name
+typedef enum _NDIS_802_11_WEP_STATUS
+{
+   Ndis802_11WEPEnabled,
+    Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
+   Ndis802_11WEPDisabled,
+    Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
+   Ndis802_11WEPKeyAbsent,
+    Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
+   Ndis802_11WEPNotSupported,
+    Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
+    Ndis802_11Encryption2Enabled,
+    Ndis802_11Encryption2KeyAbsent,
+    Ndis802_11Encryption3Enabled,
+    Ndis802_11Encryption3KeyAbsent
+} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
+  NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;
+
+typedef enum _NDIS_802_11_RELOAD_DEFAULTS
+{
+   Ndis802_11ReloadWEPKeys
+} NDIS_802_11_RELOAD_DEFAULTS, *PNDIS_802_11_RELOAD_DEFAULTS;
+
+#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
+#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
+#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4
+
+#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
+#define NDIS_802_11_AI_RESFI_STATUSCODE        2
+#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4
+
+typedef struct _NDIS_802_11_AI_REQFI
+{
+    USHORT Capabilities;
+    USHORT ListenInterval;
+    NDIS_802_11_MAC_ADDRESS  CurrentAPAddress;
+} NDIS_802_11_AI_REQFI, *PNDIS_802_11_AI_REQFI;
+
+typedef struct _NDIS_802_11_AI_RESFI
+{
+    USHORT Capabilities;
+    USHORT StatusCode;
+    USHORT AssociationId;
+} NDIS_802_11_AI_RESFI, *PNDIS_802_11_AI_RESFI;
+
+typedef struct _NDIS_802_11_ASSOCIATION_INFORMATION
+{
+    ULONG                   Length;
+    USHORT                  AvailableRequestFixedIEs;
+    NDIS_802_11_AI_REQFI    RequestFixedIEs;
+    ULONG                   RequestIELength;
+    ULONG                   OffsetRequestIEs;
+    USHORT                  AvailableResponseFixedIEs;
+    NDIS_802_11_AI_RESFI    ResponseFixedIEs;
+    ULONG                   ResponseIELength;
+    ULONG                   OffsetResponseIEs;
+} NDIS_802_11_ASSOCIATION_INFORMATION, *PNDIS_802_11_ASSOCIATION_INFORMATION;
+
+typedef struct _NDIS_802_11_AUTHENTICATION_EVENT
+{
+    NDIS_802_11_STATUS_INDICATION       Status;
+    NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
+} NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;
+        
+typedef struct _NDIS_802_11_TEST
+{
+    ULONG Length;
+    ULONG Type;
+    union
+    {
+        NDIS_802_11_AUTHENTICATION_EVENT AuthenticationEvent;
+        NDIS_802_11_RSSI RssiTrigger;
+    }bb;
+} NDIS_802_11_TEST, *PNDIS_802_11_TEST;
+
+
+typedef struct _RT_VERSION_INFO{
+    UCHAR       DriverMajorVersion;
+    UCHAR       DriverMinorVersion;
+    UCHAR       DriverSubVersion;   
+    UCHAR       DriverTestVersion;
+    UINT        DriverBuildYear;
+    UINT        DriverBuildMonth;
+    UINT        DriverBuildDay;
+} RT_VERSION_INFO, *PRT_VERSION_INFO;
+
+
+#endif //of WIN 2k
+
+#define RT_OID_VENDOR_GET_COUNTERS					0x0D73011B
+
+
+#ifdef TEST_MODE_SUPPORT
+#define RT_OID_ENTER_TEST_MODE						0x0D720101
+#define RT_OID_EXIT_TEST_MODE						0x0D720102
+
+#define RT_OID_START_BULK_OUT						0x0D73010E
+#define RT_OID_STOP_BULK_OUT						0x0D730115
+
+#define RT_OID_VENDOR_SELECT_CHANNEL				0x0D730112
+#define RT_OID_VENDOR_SET_TX_POWER					0x0D730113
+
+#if 0
+#define RT_OID_START_BULK_IN						0x0D720108
+#define RT_OID_STOP_BULK_IN							0x0D730116
+#else
+#define RT_OID_START_RX								0x0D720108
+#define RT_OID_STOP_RX								0x0D730116
+#endif
+
+#define RT_OID_START_CONT_TX						0x0D730120
+#define RT_OID_START_CARRIER_TX						0x0D730122
+#define RT_OID_STOP_TX								0x0D730121//stop BBP test mode continuous/carrier Tx.
+#define RT_OID_VENDOR_GET_COUNTERS					0x0D73011B
+#define RT_OID_VENDOR_GET_TX_FRAGMENTS_COUNT		0x0D73011C
+#endif
+
+#define RT_OID_USB_VENDOR_RESET						0x0D730101
+#define RT_OID_USB_VENDOR_UNPLUG					0x0D730102
+#define RT_OID_USB_VENDOR_SWITCH_FUNCTION			0x0D730103
+
+
+#define RT_OID_SINGLE_WRITE_MAC				0x0D730104
+#define RT_OID_SINGLE_READ_MAC					0x0D730106
+#define RT_OID_MULTI_WRITE_MAC				0x0D730107
+#define RT_OID_MULTI_READ_MAC				0x0D730108
+#define RT_OID_USB_VENDOR_EEPROM_WRITE				0x0D73010A
+#define RT_OID_USB_VENDOR_EEPROM_READ				0x0D73010B
+
+#define RT_OID_USB_VENDOR_ENTER_TESTMODE			0x0D73010C
+#define RT_OID_USB_VENDOR_EXIT_TESTMODE				0x0D73010D
+
+#define RT_OID_VENDOR_WRITE_BBP						0x0D730119
+#define RT_OID_VENDOR_READ_BBP						0x0D730118
+#define RT_OID_VENDOR_WRITE_RF						0x0D73011A
+
+#define RT_OID_VENDOR_FLIP_IQ						0x0D73011D
+
+#define RT_OID_USB_GET_DEVICE_DESC					0x0D730110
+
+#define RT_OID_SET_PER_RATE_TX_RATE_SWITCHING_STRUC	0x0D730123
+#define RT_OID_GET_BBP_R17_TUNING_MODE				0x0D730124
+#define RT_OID_SET_BBP_R17_TUNING_MODE				(OID_GET_SET_TOGGLE | RT_OID_GET_BBP_R17_TUNING_MODE)
+#define RT_OID_GET_TEST_MODE_BBP_TUNING_MODE		0x0D730125
+#define RT_OID_SET_TEST_MODE_BBP_TUNING_MODE		(OID_GET_SET_TOGGLE | RT_OID_GET_TEST_MODE_BBP_TUNING_MODE)
+//#define RT_OID_SET_GENERAL_TX_RATE_SWITCHING_STRUC	0x0D730124
+//#define RT_OID_GET_TX_RATE_SWITCHING_COUNTERS		0x0D730125
+//used by driver internally
+#define RT_OID_USB_RESET_BULK_OUT					0x0D730210
+#define RT_OID_USB_RESET_BULK_IN					0x0D730211
+#define RT_OID_SET_PSM_BIT_SAVE						0x0D730212
+#define RT_OID_SET_PSM_BIT_ACTIVE					0x0D730213
+#define RT_OID_SET_RADIO							0x0D730214
+#define RT_OID_UPDATE_TX_RATE						0x0D730216
+#define OID_802_11_ADD_KEY_WEP						0x0D730218
+#define RT_OID_RESET_FROM_ERROR						0x0D73021A
+#define RT_OID_LINK_DOWN							0x0D73021B
+
+#define RT_OID_RESET_FROM_NDIS						0x0D73021C
+#define RT_OID_PERIODIC_EXECUT						0x0D73021D
+#define RT_OID_TEST_PERIODIC_EXECUT					0x0D73021E
+#define RT_OID_ASICLED_EXECUT						0x0D73021F
+#define RT_OID_CHECK_GPIO							0x0D730215
+
+
+// Ralink defined OIDs
+#define OID_GET_SET_TOGGLE                          0x8000
+
+#define RT_OID_802_11_BSSID                   (OID_GET_SET_TOGGLE | OID_802_11_BSSID)
+#define RT_OID_802_11_SSID                    (OID_GET_SET_TOGGLE | OID_802_11_SSID)
+#define RT_OID_802_11_INFRASTRUCTURE_MODE     (OID_GET_SET_TOGGLE | OID_802_11_INFRASTRUCTURE_MODE)
+#define RT_OID_802_11_ADD_WEP                 (OID_GET_SET_TOGGLE | OID_802_11_ADD_WEP)
+#define RT_OID_802_11_ADD_KEY                 (OID_GET_SET_TOGGLE | OID_802_11_ADD_KEY)
+#define RT_OID_802_11_REMOVE_WEP              (OID_GET_SET_TOGGLE | OID_802_11_REMOVE_WEP)
+#define RT_OID_802_11_REMOVE_KEY              (OID_GET_SET_TOGGLE | OID_802_11_REMOVE_KEY)
+#define RT_OID_802_11_DISASSOCIATE            (OID_GET_SET_TOGGLE | OID_802_11_DISASSOCIATE)
+#define RT_OID_802_11_AUTHENTICATION_MODE     (OID_GET_SET_TOGGLE | OID_802_11_AUTHENTICATION_MODE)
+#define RT_OID_802_11_PRIVACY_FILTER          (OID_GET_SET_TOGGLE | OID_802_11_PRIVACY_FILTER)
+#define RT_OID_802_11_BSSID_LIST_SCAN         (OID_GET_SET_TOGGLE | OID_802_11_BSSID_LIST_SCAN)
+#define RT_OID_802_11_WEP_STATUS              (OID_GET_SET_TOGGLE | OID_802_11_WEP_STATUS)
+#define RT_OID_802_11_RELOAD_DEFAULTS         (OID_GET_SET_TOGGLE | OID_802_11_RELOAD_DEFAULTS)
+#define RT_OID_802_11_NETWORK_TYPE_IN_USE     (OID_GET_SET_TOGGLE | OID_802_11_NETWORK_TYPE_IN_USE)
+#define RT_OID_802_11_TX_POWER_LEVEL          (OID_GET_SET_TOGGLE | OID_802_11_TX_POWER_LEVEL)
+#define RT_OID_802_11_RSSI_TRIGGER            (OID_GET_SET_TOGGLE | OID_802_11_RSSI_TRIGGER)
+#define RT_OID_802_11_FRAGMENTATION_THRESHOLD (OID_GET_SET_TOGGLE | OID_802_11_FRAGMENTATION_THRESHOLD)
+#define RT_OID_802_11_RTS_THRESHOLD           (OID_GET_SET_TOGGLE | OID_802_11_RTS_THRESHOLD)
+#define RT_OID_802_11_RX_ANTENNA_SELECTED     (OID_GET_SET_TOGGLE | OID_802_11_RX_ANTENNA_SELECTED)
+#define RT_OID_802_11_TX_ANTENNA_SELECTED     (OID_GET_SET_TOGGLE | OID_802_11_TX_ANTENNA_SELECTED)
+#define RT_OID_802_11_DESIRED_RATES           (OID_GET_SET_TOGGLE | OID_802_11_DESIRED_RATES)
+//#define RT_OID_802_11_CONFIGURATION           (OID_GET_SET_TOGGLE | OID_802_11_CONFIGURATION)
+#define RT_OID_802_11_POWER_MODE              (OID_GET_SET_TOGGLE | OID_802_11_POWER_MODE)
+#define RT_OID_802_11_STATISTICS              (OID_GET_SET_TOGGLE | OID_802_11_STATISTICS)
+
+#ifdef DBG
+#define RT_OID_802_11_QUERY_HARDWARE_REGISTER 0x0D710105
+#define RT_OID_802_11_SET_HARDWARE_REGISTER   (OID_GET_SET_TOGGLE | RT_OID_802_11_QUERY_HARDWARE_REGISTER)
+#endif
+#define RT_OID_802_11_QUERY_CURRENT_CHANNEL_ID 0x0D710117
+
+//Add Paul Chen for Accton
+#define RT_OID_TX_POWER_LEVEL                 0xFF020010
+#define RT_OID_SET_TX_POWER_LEVEL	          (OID_GET_SET_TOGGLE | RT_OID_TX_POWER_LEVEL)
+
+#ifdef RALINK_ATE
+#define RT_OID_802_11_READ_EEPROM				0x0D720103
+#define RT_OID_802_11_WRITE_EEPROM				0x0D720104
+#define RT_OID_802_11_IDLE						0x0D720105
+#define RT_OID_802_11_START_TX_CARRIER			0x0D720106
+#define RT_OID_802_11_START_TX_FRAMES			0x0D720107
+#define RT_OID_802_11_START_RX					0x0D720108
+#define RT_OID_802_11_EEPROM_TYPE				0x0D720109
+#define RT_OID_802_11_START_TX_FRAMES_1			0x0D72010A
+#define RT_OID_802_11_START_CONT_TX				0x0D72010B
+#define RT_OID_802_11_START_CONT_TX_1			0x0D72010C
+#define RT_OID_802_11_SET_RETRY_COUNT			0x0D72010D
+#define RT_OID_802_11_START_CONT_TX_2			0x0D72010E
+#define RT_OID_802_11_START_TX_CARRIER_1		0x0D72010F
+#endif
+
+// Addition definition for WPA2
+// ==========================================================================
+#define	OID_802_11_CAPABILITY					0x0D010122
+#define	OID_802_11_PMKID						0x0D010123
+
+// Addon enum for WPA2
+#define	Ndis802_11AuthModeWPA2			((NDIS_802_11_AUTHENTICATION_MODE) 6)
+#define	Ndis802_11AuthModeWPA2PSK		((NDIS_802_11_AUTHENTICATION_MODE) 7)
+#define	Ndis802_11AuthModeMax			((NDIS_802_11_AUTHENTICATION_MODE) 8)		// Redefine to accomadate new enum value
+
+#define	Ndis802_11StatusType_PMKID_CandidateList	((NDIS_802_11_STATUS_TYPE) 2)
+
+typedef	struct	_PMKID_CANDIDATE
+{
+	NDIS_802_11_MAC_ADDRESS	BSSID;
+	ULONG	Flags;
+}	PMKID_CANDIDATE, *PPMKID_CANDIDATE;
+
+typedef	struct	_NDIS_802_11_PMKID_CANDIDATE_LIST
+{
+	ULONG	Version;
+	ULONG	NumCandidates;
+	PMKID_CANDIDATE	CandidateList[1];
+}	NDIS_802_11_PMKID_CANDIDATE_LIST, *PNDIS_802_11_PMKID_CANDIDATE_LIST;
+
+#define	NDIS_802_11_PMKID_CANDIDATE_PREAUTH_ENABLED		0x01
+
+typedef	UCHAR	NDIS_802_11_PMKID_VALUE[16];
+
+typedef	struct	_BSSID_INFO
+{
+	NDIS_802_11_MAC_ADDRESS		BSSID;
+	NDIS_802_11_PMKID_VALUE		PMKID;
+}	BSSID_INFO, *PBSSID_INFO;
+
+typedef	struct	_NDIS_802_11_PMKID
+{
+	ULONG		Length;
+	ULONG		BSSIDInfoCount;
+	BSSID_INFO	BSSIDInfo[1];
+}	NDIS_802_11_PMKID, *PNDIS_802_11_PMKID;
+
+typedef	struct	_NDIS_802_11_AUTHENTICATION_ENCRYPTION
+{
+	NDIS_802_11_AUTHENTICATION_MODE	AuthModeSupported;
+	NDIS_802_11_ENCRYPTION_STATUS	EncryptStatusSuppoted;
+}	NDIS_802_11_AUTHENTICATION_ENCRYPTION, *PNDIS_802_11_AUTHENTICATION_ENCRYPTION;
+
+typedef	struct	_NDIS_802_11_CAPABILITY
+{
+	ULONG	Length;
+	ULONG	Version;
+	ULONG	NoOfPMKIDs;
+	ULONG	NoOfAuthEncryptPairsSupported;
+	NDIS_802_11_AUTHENTICATION_ENCRYPTION	AuthenticationEncryptionSupported[1];
+}	NDIS_802_11_CAPABILITY, *PNDIS_802_11_CAPABILITY;
+
+// End of WPA2 addition
+// ===========================================================================
+typedef enum _RT_802_11_PREAMBLE {
+    Rt802_11PreambleLong,
+    Rt802_11PreambleShort,
+    Rt802_11PreambleAuto
+} RT_802_11_PREAMBLE, *PRT_802_11_PREAMBLE;
+
+typedef enum _RT_802_11_PHY_MODE {
+    PHY_11BG_MIXED,
+    PHY_11B,
+    PHY_11A,
+    PHY_11ABG_MIXED
+} RT_802_11_PHY_MODE, *PRT_802_11_PHY_MODE;
+
+// put all proprietery for-query objects here to reduce # of Query_OID
+typedef struct _RT_802_11_LINK_STATUS {
+    ULONG   CurrTxRate;         // in units of 0.5Mbps
+    ULONG   ChannelQuality;     // 0..100 %
+    ULONG   TxByteCount;        // both ok and fail
+    ULONG   RxByteCount;        // both ok and fail
+} RT_802_11_LINK_STATUS, *PRT_802_11_LINK_STATUS;
+
+// structure for query/set hardware register - MAC, BBP, RF register
+typedef struct _RT_802_11_HARDWARE_REGISTER {
+    ULONG   HardwareType;       // 0:MAC, 1:BBP, 2:RF register
+    ULONG   Offset;             // Q/S register offset addr
+    ULONG   Data;               // R/W data buffer
+} RT_802_11_HARDWARE_REGISTER, *PRT_802_11_HARDWARE_REGISTER;
+
+// structure to tune BBP R13 "RX AGC VGC init"
+//typedef struct _RT_802_11_RX_AGC_VGC_TUNING {
+//    UCHAR   Duration;           // unit: sec
+//    UCHAR   FlaseCcaThreshold;  // delta of flase CCA happen in the latest "Duration"
+//    UCHAR   RxAgcVgcDelta;      // R13 += RxAgcVgcDelta whenever flase CCA >= threshold
+//    UCHAR   MaxRxAgcVgc;        // max value of R13
+//} RT_802_11_RX_AGC_VGC_TUNING, *PRT_802_11_RX_AGC_VGC_TUNING;
+
+//blue
+// structure to tune BBP R17 "RX AGC VGC init"
+typedef struct _RT_802_11_RX_AGC_VGC_TUNING {
+    UCHAR   FalseCcaLowerThreshold;  // 0-255, def 10
+    UCHAR   FalseCcaUpperThreshold;  // 0-255, def 100
+    UCHAR   VgcDelta;                // R17 +-= VgcDelta whenever flase CCA over UpprThreshold
+                                     // or lower than LowerThresholdupper threshold
+    UCHAR   VgcUpperBound;           // max value of R17
+} RT_802_11_RX_AGC_VGC_TUNING, *PRT_802_11_RX_AGC_VGC_TUNING;
+
+// structure to query/set STA_CONFIG
+typedef struct _RT_802_11_STA_CONFIG {
+    ULONG   EnableTxBurst;      // 0-disable, 1-enable
+    ULONG   EnableTurboRate;    // 0-disable, 1-enable 72/100mbps turbo rate
+    ULONG   UseBGProtection;    // 0-AUTO, 1-always ON, 2-always OFF
+    ULONG   UseShortSlotTime;   // 0-no use, 1-use 9-us short slot time when applicable
+    ULONG   AdhocMode; 			// 0-11b rates only (WIFI spec), 1 - b/g mixed, 2 - g only
+    ULONG   HwRadioStatus;      // 0-OFF, 1-ON, default is 1, Read-Only
+    ULONG   Rsv1;        		// must be 0
+    ULONG   SystemErrorBitmap;  // ignore upon SET, return system error upon QUERY
+} RT_802_11_STA_CONFIG, *PRT_802_11_STA_CONFIG;
+
+// RT2500USB internal usage
+#define	RESET_BULKOUT		0
+#define	RESET_BULKIN		1
+#define	RESET_FROM_ERROR	2
+#define	LINK_DOWN			3
+#define	UPDATE_TX_RATE		4
+#define	SET_PSM_SAVE		5
+#define	RESET_FROM_NDIS		6
+#define	PERIODIC_EXECUT		7
+#define ASICLED_EXECUT      8
+#define CHECK_GPIO          9
+#define Remove_AllKeys		10
+
+#ifdef TEST_MODE_SUPPORT
+#if 0
+#define	STOP_BULKIN			10
+#else
+#define	START_RX			10
+#define	TEST_PERIODIC_EXECUT			11
+#endif
+#endif
+
+// Definition of extra information code
+#define	GENERAL_LINK_UP			0x0			// Link is Up
+#define	GENERAL_LINK_DOWN		0x1			// Link is Down
+#define	HW_RADIO_OFF			0x2			// Hardware radio off
+#define	SW_RADIO_OFF			0x3			// Software radio off
+#define	AUTH_FAIL				0x4			// Open authentication fail
+#define	AUTH_FAIL_KEYS			0x5			// Shared authentication fail
+#define	ASSOC_FAIL				0x6			// Association failed
+#define	EAP_MIC_FAILURE			0x7			// Deauthencation because MIC failure
+#define	EAP_4WAY_TIMEOUT		0x8			// Deauthencation on 4-way handshake timeout
+#define	EAP_GROUP_KEY_TIMEOUT	0x9			// Deauthencation on group key handshake timeout
+#define	EAP_SUCCESS				0xa			// EAP succeed
+
+#define EXTRA_INFO_CLEAR		0xffffffff
+
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rt2570.h linux-2.4.35.3-mct/drivers/usb/rt2570/rt2570.h
--- linux-2.4.35.3/drivers/usb/rt2570/rt2570.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rt2570.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,1061 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	rt2570.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-----------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#ifndef	__RT2570_H__
+#define	__RT2570_H__
+
+//
+// Control/Status Registers	(CSR)
+//
+#define	MAC_CSR0		0x00	// ASIC	version
+#define	MAC_CSR1		0x02	// system control
+#define	MAC_CSR2		0x04	// MAC addr0
+#define	MAC_CSR3		0x06	// MAC addr1
+#define	MAC_CSR4		0x08	// MAC addr2
+#define	MAC_CSR5		0x0A	// BSSID0
+#define	MAC_CSR6		0x0C	// BSSID1
+#define	MAC_CSR7		0x0E	// BSSID2
+#define	MAC_CSR8		0x10	// max frame length
+#define	MAC_CSR9		0x12	// timer control
+#define	MAC_CSR10		0x14	// slot time
+#define	MAC_CSR11		0x16	// IFS
+#define	MAC_CSR12		0x18	// EIFS
+#define	MAC_CSR13		0x1A	// power mode0
+#define	MAC_CSR14		0x1C	// power mode1
+#define	MAC_CSR15		0x1E	// power saving transition0
+#define	MAC_CSR16		0x20	// power saving transition1
+#define	MAC_CSR17		0x22	// power state control
+#define	MAC_CSR18		0x24	// auto wake-up control
+#define	MAC_CSR19		0x26	// GPIO control
+#define	MAC_CSR20		0x28	// LED control0
+#define	MAC_CSR21		0x2A	// LED control1
+#define	MAC_CSR22		0x2C	// LED control1
+
+#define	TXRX_CSR0		0x40		// security control
+#define	TXRX_CSR1		0x42		// TX configuration
+#define	TXRX_CSR2		0x44		// RX control
+#define	TXRX_CSR3		0x46		// CCK RX BBP ID
+#define	TXRX_CSR4		0x48		// OFDM RX BBP ID
+#define	TXRX_CSR5		0x4A		// CCK TX BBP ID0
+#define	TXRX_CSR6		0x4C		// CCK TX BBP ID1
+#define	TXRX_CSR7		0x4E		// OFDM TX BBP ID0
+#define	TXRX_CSR8		0x50		// OFDM TX BBP ID1
+#define	TXRX_CSR9		0x52		// TX ACK time-out
+#define	TXRX_CSR10		0x54		// auto responder control
+#define	TXRX_CSR11		0x56		// auto responder basic rate
+#define	TXRX_CSR12		0x58		// ACK/CTS time0
+#define	TXRX_CSR13		0x5A		// ACK/CTS time1
+#define	TXRX_CSR14		0x5C		// ACK/CTS time2
+#define	TXRX_CSR15		0x5E		// ACK/CTS time3
+#define	TXRX_CSR16		0x60		// ACK/CTS time4
+#define	TXRX_CSR17		0x62		// ACK/CTS time5
+#define	TXRX_CSR18		0x64		// Beacon interval
+#define	TXRX_CSR19		0x66		// Beacon/sync control
+#define	TXRX_CSR20		0x68		// Beacon alignment
+#define	TXRX_CSR21		0x6A		// blue
+
+//WEP key registers
+#define	SEC_CSR0		0x80	// shared key 0, word 0
+#define	SEC_CSR1		0x82	// shared key 0, word 1
+#define	SEC_CSR2		0x84	// shared key 0, word 2
+#define	SEC_CSR3		0x86	// shared key 0, word 3
+#define	SEC_CSR4		0x88	// shared key 0, word 4
+#define	SEC_CSR5		0x8A	// shared key 0, word 5
+#define	SEC_CSR6		0x8C	// shared key 0, word 6
+#define	SEC_CSR7		0x8E	// shared key 0, word 7
+#define	SEC_CSR8		0x90	// shared key 1, word 0
+#define	SEC_CSR9		0x92	// shared key 1, word 1
+#define	SEC_CSR10		0x94	// shared key 1, word 2
+#define	SEC_CSR11		0x96	// shared key 1, word 3
+#define	SEC_CSR12		0x98	// shared key 1, word 4
+#define	SEC_CSR13		0x9A	// shared key 1, word 5
+#define	SEC_CSR14		0x9C	// shared key 1, word 6
+#define	SEC_CSR15		0x9E	// shared key 1, word 7
+#define	SEC_CSR16		0xA0	// shared key 2, word 0
+#define	SEC_CSR17		0xA2	// shared key 2, word 1
+#define	SEC_CSR18		0xA4	// shared key 2, word 2
+#define	SEC_CSR19		0xA6	// shared key 2, word 3
+#define	SEC_CSR20		0xA8	// shared key 2, word 4
+#define	SEC_CSR21		0xAA	// shared key 2, word 5
+#define	SEC_CSR22		0xAC	// shared key 2, word 6
+#define	SEC_CSR23		0xAE	// shared key 2, word 7
+#define	SEC_CSR24		0xB0	// shared key 3, word 0
+#define	SEC_CSR25		0xB2	// shared key 3, word 1
+#define	SEC_CSR26		0xB4	// shared key 3, word 2
+#define	SEC_CSR27		0xB6	// shared key 3, word 3
+#define	SEC_CSR28		0xB8	// shared key 3, word 4
+#define	SEC_CSR29		0xBA	// shared key 3, word 5
+#define	SEC_CSR30		0xBC	// shared key 3, word 6
+#define	SEC_CSR31		0xBE	// shared key 3, word 7
+
+//PHY control registers
+#define	PHY_CSR0		0xC0	// RF switching timing control
+#define	PHY_CSR1		0xC2	// TX PA configuration
+#define	PHY_CSR2		0xC4	// TX MAC configuration
+#define	PHY_CSR3		0xC6	// RX MAC configuration
+#define	PHY_CSR4		0xC8	// interface configuration
+#define	PHY_CSR5		0xCA	// BBP pre-TX CCK
+#define	PHY_CSR6		0xCC	// BBP pre-TX OFDM
+#define	PHY_CSR7		0xCE	// BBP serial control
+#define	PHY_CSR8		0xD0	// BBP serial status
+#define	PHY_CSR9		0xD2	// RF serial control0
+#define	PHY_CSR10		0xD4	// RF serial control1
+
+
+// Statistic Register
+#define	STA_CSR0		0xE0		// FCS error
+#define	STA_CSR1		0xE2		// PLCP error
+#define	STA_CSR2		0xE4		// LONG error
+#define	STA_CSR3		0xE6		// CCA false alarm
+#define	STA_CSR4		0xE8		// RX FIFO overflow
+#define	STA_CSR5		0xEA		// Beacon sent counter
+#define	STA_CSR6		0xEC
+#define	STA_CSR7		0xEE
+#define	STA_CSR8		0xF0
+#define	STA_CSR9		0xF2
+#define	STA_CSR10		0xF4
+
+//
+// BBP & RF	definition
+//
+#define	BUSY		1
+#define	IDLE		0
+
+#define	BBP_Version					0x00
+#define	BBP_Tx_Configure			2  // R2
+#define	BBP_Tx_Tssi					1  // R1,blue
+#define	BBP_Rx_Configure			14 // R14
+
+#define PHY_TR_SWITCH_TIME          5  // usec
+
+#define BBP_R17_LOW_SENSIBILITY     0x48
+#define BBP_R17_MID_SENSIBILITY     0x41
+#define BBP_R17_DYNAMIC_UP_BOUND    0x40
+#define RSSI_FOR_LOW_SENSIBILITY    -58
+#define RSSI_FOR_MID_SENSIBILITY    -74
+//#define RSSI_HIGH_WATERMARK         -53
+//#define RSSI_LOW_WATERMARK          -58
+
+//-------------------------------------------------------------------------
+// EEPROM definition
+//-------------------------------------------------------------------------
+#define EEDO        0x10
+#define EEDI        0x08
+#define EECS        0x04
+#define EESK        0x02
+#define EERL        0x01
+
+#define EEPROM_WRITE_OPCODE     0x05
+#define EEPROM_READ_OPCODE      0x06
+#define EEPROM_EWDS_OPCODE      0x10
+#define EEPROM_EWEN_OPCODE      0x13
+
+
+
+#define	NUM_EEPROM_BBP_PARMS		19
+#define	NUM_EEPROM_TX_PARMS			7
+#define	NUM_EEPROM_BBP_TUNING_PARMS	7
+#define EEPROM_VERSION_OFFSET       0x2
+#define	EEPROM_MAC_ADDRESS_BASE_OFFSET		0x4
+#define	EEPROM_BBP_BASE_OFFSET		0x16
+#define	EEPROM_TX_PWR_OFFSET		0x3C
+#define	EEPROM_TSSI_REF_OFFSET		0x4A
+#define	EEPROM_TSSI_DELTA_OFFSET	0x1A
+#define	EEPROM_BBP_TUNING_OFFSET	0x60
+#define	EEPROM_MAC_STATUS_OFFSET	0x7E
+
+
+// =================================================================================
+// TX / RX ring descriptor format
+// =================================================================================
+
+//
+// TX descriptor format
+//
+typedef	struct	_TXD_STRUC
+{
+	// Word    0
+	ULONG				PacketID:4;// PacketID - write by MAC about Frame translate status
+	ULONG				RetryLimit:4;// Retry limit
+	ULONG				MoreFrag:1;// More     fragment following this       tx ring
+	ULONG				ACK:1;// ACK
+	ULONG				Timestamp:1;// ins_TSF
+	ULONG				Ofdm:1;// OFDM
+	ULONG				newseq:1;// new_seq
+	ULONG				IFS:2;// IFS
+	ULONG				Rsv0:1;// Rev0
+	
+	ULONG				DataByteCnt:12;// Data byte count
+	ULONG				Rsv1:1;// Rev1
+	ULONG				Cipher:1;// cliper
+	ULONG				KeyID:2;// KeyID
+	
+	
+	
+	// Word    1
+	ULONG				IvOffset:6;// IV offset
+	ULONG				Aifs:2;// AIFS
+	ULONG				CWmin:4;// CWmin
+	ULONG				CWmax:4;// CWmax
+	ULONG				Rsv2:16;// Rev2
+	
+	
+	
+	// Word    2
+	ULONG				PlcpSignal:8;// BBP R0 - PLCP Singal
+	ULONG				PlcpService:8;// BBP R1 - PLCP Service
+	ULONG				PlcpLengthLow:8;// BBP R2 - PLCP length_Low
+	ULONG				PlcpLengthHigh:8;// BBP R3 - PLCP length_high
+	
+	
+	
+	// Word    3
+	ULONG				Iv;// IV
+	
+	
+	
+	// Word    4
+	ULONG				Eiv;// EIV
+}
+TXD_STRUC, *PTXD_STRUC;
+
+//
+// Rx descriptor format
+//
+typedef	struct	_RXD_STRUC
+{
+	// Word    0
+	ULONG				Rev0:1;// Rev0
+	ULONG				U2M:1;// u2me
+	ULONG				Mcast:1;// mcast
+	ULONG				Bcast:1;// bcast
+	ULONG				MyBss:1;// my bss
+	ULONG				Crc:1;// crc error
+	ULONG				Ofdm:1;// OFDM
+	ULONG				PhyErr:1;// phy err
+	ULONG				Cipher:1;// cipher
+	ULONG				CiErr:1;// ci error
+	ULONG				Rsv1:6;// Rev1
+	
+	ULONG				DataByteCnt:12;// data byte count
+	ULONG				Rsv2:4;// Rev2
+	
+	
+	
+	// Word    1
+	UCHAR				BBR1;// BBP R0 - SIGNAL / rate
+	UCHAR				BBR0;// BBP R1 - RSSI
+	UCHAR				Rev3[2];// Rev3
+	
+	
+	
+	// Word    2
+	ULONG				Iv;// IV
+	
+	
+	
+	// Word 3
+	ULONG				Eiv;// EIV
+}
+RXD_STRUC, *PRXD_STRUC;
+
+
+// =================================================================================
+// CSR Registers
+// =================================================================================
+
+//
+// CSR1: System control register
+//
+typedef	union	_CSR1_STRUC	{
+	struct	{
+		ULONG		SoftReset:1;		// Software reset bit, 1: reset, 0: normal
+		ULONG		Rsvd0:1;
+		ULONG		HostReady:1;		// Host is ready after initialization, 1: ready
+		ULONG		Rsvd1:29;
+	}	field;
+	ULONG			word;
+}	CSR1_STRUC, *PCSR1_STRUC;
+
+// MAC_CSR2: STA MAC register 0
+typedef	union	_MAC_CSR2_STRUC	{
+	struct	{
+		UCHAR		Byte0;		// MAC address byte 0
+		UCHAR		Byte1;		// MAC address byte 1
+	}				field;
+	USHORT			value;
+}	MAC_CSR2_STRUC, *PMAC_CSR2_STRUC;
+
+// MAC_CSR3: STA MAC register 1
+typedef	union	_MAC_CSR3_STRUC	{
+	struct	{
+		UCHAR		Byte2;		// MAC address byte 2
+		UCHAR		Byte3;		// MAC address byte 3
+	}				field;
+	USHORT			value;
+}	MAC_CSR3_STRUC, *PMAC_CSR3_STRUC;
+
+// MAC_CSR4: STA MAC register 2
+typedef	union	_MAC_CSR4_STRUC	{
+	struct	{
+		UCHAR		Byte4;		// MAC address byte 4
+		UCHAR		Byte5;		// MAC address byte 5
+	}				field;
+	USHORT			value;
+}	MAC_CSR4_STRUC, *PMAC_CSR4_STRUC;
+#if 0//rt2460
+//
+// CSR3: STA MAC register 0
+//
+typedef	union	_CSR3_STRUC	{
+	struct	{
+		UCHAR		Byte0;		// MAC address byte 0
+		UCHAR		Byte1;		// MAC address byte 1
+		UCHAR		Byte2;		// MAC address byte 2
+		UCHAR		Byte3;		// MAC address byte 3
+	}	field;
+	ULONG			word;
+}	CSR3_STRUC, *PCSR3_STRUC;
+
+//
+// CSR4: STA MAC register 1
+//
+typedef	union	_CSR4_STRUC	{
+	struct	{
+		UCHAR		Byte4;		// MAC address byte 4
+		UCHAR		Byte5;		// MAC address byte 5
+		UCHAR		Rsvd0;
+		UCHAR		Rsvd1;
+	}	field;
+	ULONG			word;
+}	CSR4_STRUC, *PCSR4_STRUC;
+#endif
+
+//
+// CSR5: BSSID register 0
+//
+typedef	union	_CSR5_STRUC	{
+	struct	{
+		UCHAR		Byte0;		// BSSID byte 0
+		UCHAR		Byte1;		// BSSID byte 1
+		UCHAR		Byte2;		// BSSID byte 2
+		UCHAR		Byte3;		// BSSID byte 3
+	}	field;
+	ULONG			word;
+}	CSR5_STRUC, *PCSR5_STRUC;
+
+//
+// CSR6: BSSID register 1
+//
+typedef	union	_CSR6_STRUC	{
+	struct	{
+		UCHAR		Byte4;		// BSSID byte 4
+		UCHAR		Byte5;		// BSSID byte 5
+		UCHAR		Rsvd0;
+		UCHAR		Rsvd1;
+	}	field;
+	ULONG			word;
+}	CSR6_STRUC, *PCSR6_STRUC;
+
+//
+// CSR7: Interrupt source register
+// Write one to clear corresponding bit
+//
+typedef	union	_CSR7_STRUC	{
+	struct	{
+		ULONG		TbcnExpire:1;		// Beacon timer expired interrupt
+		ULONG		TwakeExpire:1;		// Wakeup timer expired interrupt
+		ULONG		TatimwExpire:1;		// Timer of atim window expired interrupt
+		ULONG		TxRingTxDone:1;		// Tx ring transmit done interrupt
+		ULONG		AtimRingTxDone:1;	// Atim ring transmit done interrupt
+		ULONG		PrioRingTxDone:1;	// Priority ring transmit done interrupt
+		ULONG		RxDone:1;			// Receive done interrupt
+		ULONG		Rsvd:25;
+	}	field;
+	ULONG			word;
+}	CSR7_STRUC, *PCSR7_STRUC, INTSRC_STRUC, *PINTSRC_STRUC;
+
+//
+// CSR8: Interrupt Mask register
+// Write one to mask off interrupt
+//
+typedef	union	_CSR8_STRUC	{
+	struct	{
+		ULONG		TbcnExpire:1;		// Beacon timer expired interrupt mask
+		ULONG		TwakeExpire:1;		// Wakeup timer expired interrupt mask
+		ULONG		TatimwExpire:1;		// Timer of atim window expired interrupt mask
+		ULONG		TxRingTxDone:1;		// Tx ring transmit done interrupt mask
+		ULONG		AtimRingTxDone:1;	// Atim ring transmit done interrupt mask
+		ULONG		PrioRingTxDone:1;	// Priority ring transmit done interrupt mask
+		ULONG		RxDone:1;			// Receive done interrupt mask
+		ULONG		Rsvd:25;
+	}	field;
+	ULONG			word;
+}	CSR8_STRUC, *PCSR8_STRUC, INTMSK_STRUC, *PINTMSK_STRUC;
+
+//
+// CSR9: Maximum frame length register
+//
+typedef	union	_CSR9_STRUC	{
+	struct	{
+		ULONG		Rsvd0:7;
+		ULONG		MaxFrameUnit:5;		// Maximum frame legth in 128B unit, default is 12 = 0xC.
+		ULONG		Rsvd1:20;
+	}	field;
+	ULONG			word;
+}	CSR9_STRUC, *PCSR9_STRUC;
+
+//
+// CSR11: Back-Off control register
+//
+typedef	union	_CSR11_STRUC	{
+	struct {
+		ULONG		CWMin:4;		// Bit for Cwmin. default Cwmin is 31 (2^5 - 1).
+		ULONG		CWMax:4;		// Bit for Cwmax, default Cwmax is 1023 (2^10 - 1).
+		ULONG		SlotTime:5;		// Slot time, default is 20us for 802.11B
+		ULONG		Rsvd:3;
+		ULONG		LongRetry:8;	// Long retry count
+		ULONG		ShortRetry:8;	// Short retry count
+	}	field;
+	ULONG			word;
+}	CSR11_STRUC, *PCSR11_STRUC; 
+
+#if 0
+//
+// CSR12: Synchronization configuration register 0
+// All uint in 1/16 TU
+//
+typedef	union	_CSR12_STRUC	{
+	struct	{
+		ULONG		BeaconInterval:16;	// CFP maximum duration, default is 100 TU
+		ULONG		CfpMaxDuration:16;	// Beacon interval, default is 100 TU
+	}	field;
+	ULONG			word;
+}	CSR12_STRUC, *PCSR12_STRUC;
+
+//
+// CSR13: Synchronization configuration register 1
+// All uint in 1/16 TU
+//
+typedef	union	_CSR13_STRUC	{
+	struct	{
+		ULONG		AtimwDuration:16;	// ATIM window duration, default is 10 TU
+		ULONG		CfpPeriod:8;		// CFP period, default is 0 TU
+		ULONG		Rsvd:8;
+	}	field;
+	ULONG			word;
+}	CSR13_STRUC, *PCSR13_STRUC;
+#endif
+
+//
+// TXRX_CSR18: Synchronization control register
+//
+typedef	union	_TXRX_CSR18_STRUC	{
+	struct	{
+		USHORT		Offset:4;			// Enable TSF auto counting
+		USHORT		Interval:12;			// Enable TSF sync, 00: disable, 01: infra mode, 10: ad-hoc mode
+	}	field;
+	USHORT			value;
+}	TXRX_CSR18_STRUC, *PTXRX_CSR18_STRUC;
+
+//
+// TXRX_CSR19: Synchronization control register
+//
+typedef	union	_TXRX_CSR19_STRUC	{
+	struct	{
+		USHORT		TsfCount:1;			// Enable TSF auto counting
+		USHORT		TsfSync:2;			// Enable TSF sync, 00: disable, 01: infra mode, 10: ad-hoc mode
+		USHORT		Tbcn:1;				// Enable Tbcn with reload value
+//		ULONG		Tcfp:1;				// Enable Tcfp & CFP / CP switching
+//		ULONG		Tatimw:1;			// Enable Tatimw & ATIM window switching
+		USHORT		BeaconGen:1;		// Enable beacon generator
+		USHORT		Rsvd:11;
+//		ULONG		CfpCntPreload:8;	// Cfp count preload value
+//		ULONG		TbcnPreload:16;		// Tbcn preload value
+	}	field;
+	USHORT			value;
+}	TXRX_CSR19_STRUC, *PTXRX_CSR19_STRUC;
+#if 0
+//
+// CSR14: Synchronization control register
+//
+typedef	union	_CSR14_STRUC	{
+	struct	{
+		ULONG		TsfCount:1;			// Enable TSF auto counting
+		ULONG		TsfSync:2;			// Enable TSF sync, 00: disable, 01: infra mode, 10: ad-hoc mode
+		ULONG		Tbcn:1;				// Enable Tbcn with reload value
+		ULONG		Tcfp:1;				// Enable Tcfp & CFP / CP switching
+		ULONG		Tatimw:1;			// Enable Tatimw & ATIM window switching
+		ULONG		BeaconGen:1;		// Enable beacon generator
+		ULONG		Rsvd:1;
+		ULONG		CfpCntPreload:8;	// Cfp count preload value
+		ULONG		TbcnPreload:16;		// Tbcn preload value
+	}	field;
+	ULONG			word;
+}	CSR14_STRUC, *PCSR14_STRUC;
+#endif
+
+//
+// CSR15: Synchronization status register
+//
+typedef	union	_CSR15_STRUC	{
+	struct	{
+		ULONG		Cfp:1;			// CFP period
+		ULONG		Atimw:1;		// Atim window period
+		ULONG		BeaconSent:1;	// Beacon sent
+		ULONG		Rsvd:29;
+	}	field;
+	ULONG			word;
+}	CSR15_STRUC, *PCSR15_STRUC;
+
+//
+// CSR18: IFS Timer register 0
+//
+typedef	union	_CSR18_STRUC	{
+	struct	{
+		ULONG		SIFS:16;	// SIFS, default is 10 TU
+		ULONG		PIFS:16;	// PIFS, default is 30 TU
+	}	field;
+	ULONG			word;
+}	CSR18_STRUC, *PCSR18_STRUC;
+
+//
+// CSR19: IFS Timer register 1
+//
+typedef	union	_CSR19_STRUC	{
+	struct	{
+		ULONG		DIFS:16;	// DIFS, default is 50 TU
+		ULONG		EIFS:16;	// EIFS, default is 364 TU
+	}	field;
+	ULONG			word;
+}	CSR19_STRUC, *PCSR19_STRUC;
+
+//
+// MAC_CSR18: Wakeup timer register
+//
+typedef	union	_MAC_CSR18_STRUC	{
+	struct	{
+		USHORT		DelayAfterBcn:8;		// Delay after Tbcn expired in units of 1/16 TU
+		USHORT		NumBcnBeforeWakeup:7;	// Number of beacon before wakeup
+		USHORT		AutoWake:1;				// Enable auto wakeup / sleep mechanism
+	}	field;
+	USHORT			value;
+}	MAC_CSR18_STRUC, *PMAC_CSR18_STRUC;
+#if 0//RT2560
+//
+// CSR20: Wakeup timer register
+//
+typedef	union	_CSR20_STRUC	{
+	struct	{
+		ULONG		DelayAfterBcn:16;		// Delay after Tbcn expired in units of 1/16 TU
+		ULONG		NumBcnBeforeWakeup:8;	// Number of beacon before wakeup
+		ULONG		AutoWake:1;				// Enable auto wakeup / sleep mechanism
+		ULONG		Rsvd:7;
+	}	field;
+	ULONG			word;
+}	CSR20_STRUC, *PCSR20_STRUC;
+#endif
+
+//
+// CSR21: EEPROM control register
+//
+typedef	union	_CSR21_STRUC	{
+	struct	{
+		ULONG		Reload:1;		// Reload EEPROM content, write one to reload, self-cleared.
+		ULONG		EepromSK:1;
+		ULONG		EepromCS:1;
+		ULONG		EepromDI:1;
+		ULONG		EepromDO:1;
+		ULONG		Type:1;			// 1: 93C46, 0:93C66
+		ULONG		Rsvd:26;
+	}	field;
+	ULONG			word;
+}	CSR21_STRUC, *PCSR21_STRUC;
+
+//
+// CSR22: CFP control register
+//
+typedef	union	_CSR22_STRUC	{
+	struct	{
+		ULONG		CfpDurRemain:16;		// CFP duration remain, in units of TU
+		ULONG		ReloadCfpDurRemain:1;	// Reload CFP duration remain, write one to reload, self-cleared
+		ULONG		Rsvd:15;
+	}	field;
+	ULONG			word;
+}	CSR22_STRUC, *PCSR22_STRUC;
+
+// =================================================================================
+// TX / RX Registers
+// =================================================================================
+
+//
+// TXCSR0 <0x0060> : TX	Control	Register 
+//
+typedef	union	_TXCSR0_STRUC	{
+	struct	{
+		ULONG		KickTx:1;		// Kick Tx ring 
+		ULONG		KickAtim:1;		// Kick ATIM ring
+		ULONG		KickPrio:1;		// Kick priority ring
+		ULONG		Abort:1;		// Abort all transmit related ring operation
+		ULONG		Rsvd:28;
+	}	field;	
+	ULONG			word;
+}	TXCSR0_STRUC, *PTXCSR0_STRUC;
+
+
+//
+// TXRX_CSR0: Security control register
+//
+typedef union _TXRX_CSR0_STRUC {
+	struct {
+		USHORT		Algorithm:3;
+		USHORT		IVOffset:6;
+		USHORT		KeyID:4;
+		USHORT		Rsvd:3;
+	} field;
+	USHORT			value;
+} TXRX_CSR0_STRUC, *PTXRX_CSR0_STRUC;
+//
+// TXCSR1 <0x0064> : TX	Configuration Register
+//
+typedef	union	_TXCSR1_STRUC	{
+	struct	{
+		ULONG		AckTimeOut:9;		// Ack timeout, default = SIFS + 2*SLOT_ACKtime @ 1Mbps
+		ULONG		AckConsumeTime:9;	// ACK consume time, default = SIFS + ACKtime @ 1Mbps
+		ULONG		TsFOffset:6;		// Insert Tsf offset
+		ULONG		AutoResponder:1;	// enable auto responder which include ACK & CTS
+		ULONG		Reserved:7;
+	}	field;
+	ULONG			word;
+}	TXCSR1_STRUC, *PTXCSR1_STRUC;
+
+//
+// TXCSR2: Tx descriptor configuration register
+//
+typedef	union	_TXCSR2_STRUC	{
+	struct	{
+		ULONG		TxDSize:8;		// Tx descriptor size, default is 32
+		ULONG		NumTxD:8;		// Number of TxD in ring
+		ULONG		NumAtimD:8;		// Number of AtimD in ring
+		ULONG		NumPrioD:8;		// Number of PriorityD in ring
+	}	field;
+	ULONG			word;
+}	TXCSR2_STRUC, *PTXCSR2_STRUC;
+
+//
+// TXCSR7: Auto responder control register
+//
+typedef	union	_TXCSR7_STRUC	{
+	struct	{
+		ULONG		ARPowerManage:1;	// Auto responder power management bit
+		ULONG		Rsvd:31;
+	}	field;
+	ULONG		word;
+}	TXCSR7_STRUC, *PTXCSR7_STRUC;
+
+//
+// RXCSR0 <0x0080> : RX	Control	Register
+//
+typedef	union	_RXCSR0_STRUC	{
+	struct	{
+		ULONG		DisableRx:1;		// Disable Rx engine
+		ULONG		DropCRC:1;			// Drop CRC error
+		ULONG		DropPhysical:1;		// Drop physical error
+		ULONG		DropControl:1;		// Drop control frame
+		ULONG		DropNotToMe:1;		// Drop not to me unicast frame
+		ULONG		DropToDs:1;			// Drop fram ToDs bit is true
+		ULONG		DropVersionErr:1;	// Drop version error frame
+		ULONG		PassCRC:1;			// Pass all receive packet to host with CRC attached
+		ULONG		Reserved:24;
+	}	field;
+	ULONG			word;
+}	RXCSR0_STRUC, *PRXCSR0_STRUC;
+
+//
+// RXCSR1: RX descriptor configuration register
+//
+typedef	union	_RXCSR1_STRUC	{
+	struct	{
+		ULONG		RxDSize:8;		// Rx descriptor size, default is 32B.
+		ULONG		NumRxD:8;		// Number of RxD in ring.
+		ULONG		Rsvd:16;
+	}	field;
+	ULONG			word;
+}	RXCSR1_STRUC, *PRXCSR1_STRUC;
+
+//
+// RXCSR3: BBP ID register for Rx operation
+//
+typedef	union	_RXCSR3_STRUC	{
+	struct	{
+		ULONG		IdBbp0:7;			// BBP register 0 ID
+		ULONG		ValidBbp0:1;		// BBP register 0 ID is valid or not
+		ULONG		IdBbp1:7;			// BBP register 1 ID
+		ULONG		ValidBbp1:1;		// BBP register 1 ID is valid or not
+		ULONG		IdBbp2:7;			// BBP register 2 ID
+		ULONG		ValidBbp2:1;		// BBP register 2 ID is valid or not
+		ULONG		IdBbp3:7;			// BBP register 3 ID
+		ULONG		ValidBbp3:1;		// BBP register 3 ID is valid or not
+	}	field;
+	ULONG			word;
+}	RXCSR3_STRUC, *PRXCSR3_STRUC;
+
+//
+// RXCSR4: BBP ID register for Rx operation
+//
+typedef	union	_RXCSR4_STRUC	{
+	struct	{
+		ULONG		IdBbp4:7;			// BBP register 4 ID
+		ULONG		ValidBbp4:1;		// BBP register 4 ID is valid or not
+		ULONG		IdBbp5:7;			// BBP register 5 ID
+		ULONG		ValidBbp5:1;		// BBP register 5 ID is valid or not
+		ULONG		Rsvd:16;
+	}	field;
+	ULONG			word;
+}	RXCSR4_STRUC, *PRXCSR4_STRUC;
+
+//
+// ARCSR0: Auto Responder PLCP value register 0
+//
+typedef	union	_ARCSR0_STRUC	{
+	struct	{
+		ULONG		ArBbpData0:8;		// Auto responder BBP register 0 data
+		ULONG		ArBbpId0:8;			// Auto responder BBP register 0 Id
+		ULONG		ArBbpData1:8;		// Auto responder BBP register 1 data
+		ULONG		ArBbpId1:8;			// Auto responder BBP register 1 Id
+	}	field;
+	ULONG			word;
+}	ARCSR0_STRUC, *PARCSR0_STRUC;
+
+//
+// ARCSR0: Auto Responder PLCP value register 1
+//
+typedef	union	_ARCSR1_STRUC	{
+	struct	{
+		ULONG		ArBbpData2:8;		// Auto responder BBP register 2 data
+		ULONG		ArBbpId2:8;			// Auto responder BBP register 2 Id
+		ULONG		ArBbpData3:8;		// Auto responder BBP register 3 data
+		ULONG		ArBbpId3:8;			// Auto responder BBP register 3 Id
+	}	field;
+	ULONG			word;
+}	ARCSR1_STRUC, *PARCSR1_STRUC;
+
+// =================================================================================
+// Miscellaneous Registers
+// =================================================================================
+
+//
+// PCISR: PCI control register
+//
+typedef	union	_PCICSR_STRUC	{
+	struct	{
+		ULONG		BigEndian:1;		// 1: big endian, 0: little endian
+		ULONG		RxThreshold:2;		// Rx threshold in DW to start PCI access
+										// 01: 8DW, 10: 4DW, 11: 32DW, default 00: 16DW
+		ULONG		TxThreshold:2;		// Tx threshold in DW to start PCI access
+										// 01: 1DW, 10: 4DW, 11: store & forward, default 00: 0DW
+		ULONG		BurstLength:2;		// PCI burst length
+										// 01: 8DW, 10: 16DW, 11:32DW, default 00: 4DW
+		ULONG		EnableClk:1;		// Enable CLK_RUN, PCI clock can't going down to non-operational
+		ULONG		Rsvd:24;
+	}	field;
+	ULONG			word;
+}	PCICSR_STRUC, *PPCICSR_STRUC;
+
+//
+// PWRCSR0: Power mode configuration register
+//
+
+//
+// PSCSR0: Power saving delay time register 0
+//
+
+//
+// PSCSR1: Power saving delay time register 1
+//
+
+//
+// PSCSR2: Power saving delay time register 2
+//
+
+//
+// PSCSR3: Power saving delay time register 3
+//
+
+//
+// MAC_CSR17: Manual power control / status register
+//
+typedef	union	_MAC_CSR17_STRUC	{
+	struct	{
+		USHORT		SetState:1;	
+		USHORT		BbpDesireState:2;
+		USHORT		RfDesireState:2;
+		USHORT		BbpCurrState:2;
+		USHORT       RfCurrState:2;
+		USHORT       PutToSleep:1;
+		USHORT       Rsvd:6;
+	}	field;
+	USHORT			value;
+}	MAC_CSR17_STRUC, *PMAC_CSR17_STRUC;
+#if 0//RT2560
+//
+// PWRCSR1: Manual power control / status register
+//
+typedef	union	_PWRCSR1_STRUC	{
+	struct	{
+		ULONG		SetState:1;	
+		ULONG		BbpDesireState:2;
+		ULONG		RfDesireState:2;
+		ULONG		BbpCurrState:2;
+		ULONG       RfCurrState:2;
+		ULONG       PutToSleep:1;
+		ULONG       Rsvd:22;
+	}	field;
+	ULONG			word;
+}	PWRCSR1_STRUC, *PPWRCSR1_STRUC;
+#endif
+
+//
+// TIMECSR: Timer control register
+//
+
+//
+// MACCSR0: MAC configuration register 0
+//
+
+//
+// MACCSR1: MAC configuration register 1
+//
+typedef	union	_MACCSR1_STRUC	{
+	struct	{
+		ULONG		KickRx:1;			// Kick one-shot Rx in one-shot Rx mode
+		ULONG		OneShotRxMode:1;	// Enable one-shot Rx mode for debugging
+		ULONG		BbpRxResetMode:1;	// Ralink BBP RX reset mode
+		ULONG		AutoTxBbp:1;		// Auto Tx logic access BBP control register
+		ULONG		AutoRxBbp:1;		// Auto Rx logic access BBP control register
+		ULONG		LoopBack:2;			// Loopback mode. 00: normal, 01: internal, 10: external, 11:rsvd.
+		ULONG		IntersilIF:1;		// Intersil IF calibration pin
+		ULONG		Rsvd:24;
+	}	field;
+	ULONG			word;
+}	MACCSR1_STRUC, *PMACCSR1_STRUC;
+
+//
+// RALINKCSR: Ralink Rx auto-reset BBCR
+//
+typedef	union	_RALINKCSR_STRUC	{
+	struct	{
+		ULONG		ArBbpData0:8;		// Auto reset BBP register 0 data
+		ULONG		ArBbpId0:7;			// Auto reset BBP register 0 Id
+		ULONG		ArBbpValid0:1;		// Auto reset BBP register 0 is valid
+		ULONG		ArBbpData1:8;		// Auto reset BBP register 1 data
+		ULONG		ArBbpId1:7;			// Auto reset BBP register 1 Id
+		ULONG		ArBbpValid1:1;		// Auto reset BBP register 1 is valid
+	}	field;
+	ULONG			word;
+}	RALINKCSR_STRUC, *PRALINKCSR_STRUC;
+
+//
+// BCNCSR: Beacon interval control register
+//
+typedef	union	_BCNCSR_STRUC	{
+	struct	{
+		ULONG		Change:1;		// Write one to change beacon interval
+		ULONG		DeltaTime:4;	// The delta time value
+		ULONG		NumBcn:8;		// Delta time value or number of beacon according to mode
+		ULONG		Mode:2;			// please refer to ASIC specs.
+		ULONG		Plus:1;			// plus or minus delta time value
+		ULONG		Rsvd:16;
+	}	field;
+	ULONG			word;
+}	BCNCSR_STRUC, *PBCNCSR_STRUC;
+
+typedef	union	_PHY_CSR7_STRUC	{
+	struct	{
+		USHORT		Data:8;				// BBP data
+		USHORT		RegID:7;			// BBP register ID
+		USHORT		WriteControl:1;		// 1: Write, 0:	Read	
+	}				field;
+	USHORT			value;
+}	PHY_CSR7_STRUC, *PPHY_CSR7_STRUC;
+
+typedef	union	_PHY_CSR8_STRUC	{
+	struct	{
+		USHORT		Busy:1;				// 1: ASIC is busy execute BBP programming.	
+		USHORT		Rsvd:15;
+	}				field;
+	USHORT			value;
+}	PHY_CSR8_STRUC, *PPHY_CSR8_STRUC;
+
+typedef	union	_PHY_CSR10_STRUC	{
+	struct	{
+		USHORT		RFRegValue:8;		// Register	value (include register	id)	serial out to RF/IF	chip.
+		USHORT		NumberOfBits:5;		// Number of bits used in RFRegValue (I:20,	RFMD:22)
+		USHORT		IFSelect:1;			// 1: select IF	to program,	0: select RF to	program
+		USHORT		PLL_LD:1;			// RF PLL_LD status
+		USHORT		Busy:1;				// 1: ASIC is busy execute RF programming.
+	}	field;
+	USHORT			value;
+}	PHY_CSR10_STRUC, *PPHY_CSR10_STRUC;
+#if 0//rt2460
+//
+// BBPCSR: BBP serial control register
+//
+typedef	union	_BBPCSR_STRUC	{
+	struct	{
+		ULONG		Value:8;			// Register	value to program into BBP
+		ULONG		RegNum:7;			// Selected	BBP	register
+		ULONG		Busy:1;				// 1: ASIC is busy execute BBP programming.	
+		ULONG		WriteControl:1;		// 1: Write	BBP, 0:	Read BBP
+		ULONG		Rsvd:15;
+	}	field;
+	ULONG			word;
+}	BBPCSR_STRUC, *PBBPCSR_STRUC;
+
+//
+// RFCSR: RF serial control register
+//
+typedef	union	_RFCSR_STRUC	{
+	struct	{
+		ULONG		RFRegValue:24;		// Register	value (include register	id)	serial out to RF/IF	chip.
+		ULONG		NumberOfBits:5;		// Number of bits used in RFRegValue (I:20,	RFMD:22)
+		ULONG		IFSelect:1;			// 1: select IF	to program,	0: select RF to	program
+		ULONG		PLL_LD:1;			// RF PLL_LD status
+		ULONG		Busy:1;				// 1: ASIC is busy execute RF programming.
+	}	field;
+	ULONG			word;
+}	RFCSR_STRUC, *PRFCSR_STRUC;
+#endif
+
+//
+// LEDCSR: LED control register
+//
+typedef	union	_LEDCSR_STRUC	{
+	struct	{
+		ULONG		OnPeriod:8;			// On period, default 70ms
+		ULONG		OffPeriod:8;		// Off period, default 30ms
+		ULONG		Link:1;				// 1: linkup, 0: linkoff
+		ULONG		Activity:1;			// 1: active, 0: idle
+		ULONG		Rsvd:14;
+	}	field;
+	ULONG			word;
+}	LEDCSR_STRUC, *PLEDCSR_STRUC;
+
+//
+// GPIOCSR: GPIO control register
+//
+typedef	union	_GPIOCSR_STRUC	{
+	struct	{
+		ULONG		Bit0:1;
+		ULONG		Bit1:1;
+		ULONG		Bit2:1;
+		ULONG		Bit3:1;
+		ULONG		Bit4:1;
+		ULONG		Bit5:1;
+		ULONG		Bit6:1;
+		ULONG		Bit7:1;
+		ULONG		Rsvd:24;
+	}	field;
+	ULONG			word;
+}	GPIOCSR_STRUC, *PGPIOCSR_STRUC;
+
+//
+// TXRX_CSR20: Tx BEACON offset time control register
+//
+typedef	union	_TXRX_CSR20_STRUC	{
+	struct	{
+		USHORT       Offset:13;      // in units of usec
+		USHORT       BeaconExpectWindow:3;   // 2^CwMin
+	}	field;
+	USHORT			value;
+}	TXRX_CSR20_STRUC, *PTXRX_CSR20_STRUC;
+#if 0
+//
+// BCNCSR1: Tx BEACON offset time control register
+//
+typedef	union	_BCNCSR1_STRUC	{
+	struct	{
+		USHORT      Preload;    // in units of usec
+		USHORT  	Rsvd;
+	}	field;
+	ULONG			word;
+}	BCNCSR1_STRUC, *PBCNCSR1_STRUC;
+#endif
+
+//
+// MACCSR2: TX_PE to RX_PE turn-around time control register
+//
+typedef	union	_MACCSR2_STRUC	{
+	struct	{
+		ULONG       Delay:8;    // in units of PCI clock cycle
+		ULONG       Rsvd:24;
+	}	field;
+	ULONG			word;
+}	MACCSR2_STRUC, *PMACCSR2_STRUC;
+
+//
+// EEPROM antenna select format
+//
+typedef	union	_EEPROM_ANTENNA_STRUC	{
+	struct	{
+		USHORT		NumOfAntenna:2;			// Number of antenna
+		USHORT		TxDefaultAntenna:2;		// default of antenna, 0: diversity, 1:antenna-A, 2:antenna-B reserved (default = 0)
+		USHORT		RxDefaultAntenna:2;		// default of antenna, 0: diversity, 1:antenna-A, 2:antenna-B reserved (default = 0)
+		USHORT      LedMode:3;              // 0-default mode, 1:TX/RX activity mode, 2: Single LED (didn't care about link), 3: reserved
+		USHORT      DynamicTxAgcControl:1;	
+		USHORT		HardwareRadioControl:1;	// 1: Hardware controlled radio enabled, Read GPIO0 required.
+		USHORT      RfType:5;               // see E2PROM document
+	}	field;
+	USHORT			word;
+}	EEPROM_ANTENNA_STRUC, *PEEPROM_ANTENNA_STRUC;
+
+typedef	union	_EEPROM_NIC_CINFIG2_STRUC	{
+	struct	{
+		USHORT		CardbusAcceleration:1;	// !!! NOTE: 0 - enable, 1 - disable
+		USHORT		DynamicBbpTuning:1;		// !!! NOTE: 0 - enable, 1 - disable
+		USHORT		CckTxPower:2;			// CCK TX power compensation
+		USHORT      Rsv:12;                 // must be 0
+	}	field;
+	USHORT			word;
+}	EEPROM_NIC_CONFIG2_STRUC, *PEEPROM_NIC_CONFIG2_STRUC;
+
+typedef	union	_EEPROM_TX_PWR_STRUC	{
+	struct	{
+		UCHAR	Byte0;				// Low Byte
+		UCHAR	Byte1;				// High Byte
+	}	field;
+	USHORT	word;
+}	EEPROM_TX_PWR_STRUC, *PEEPROM_TX_PWR_STRUC;
+
+#endif	// __RT2570_H__
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rt2570sw.h linux-2.4.35.3-mct/drivers/usb/rt2570/rt2570sw.h
--- linux-2.4.35.3/drivers/usb/rt2570/rt2570sw.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rt2570sw.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,3783 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	rt2570sw.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	------------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ *	Ivo		02-06-2005	Debug flag fix
+ *	FelipeaA	02-06-2005	Added Conceptronic C54RU
+ *	MathiasK	02-06-2005	Added F5D7050,UB801R
+ *	MarkW		02-08-2005	Added MSI 6861
+ *	PeterF		27-06-2005	Added GN-WBKG
+ *	zak		03-07-2005	Added second GN-WBKG
+ *	PedroP          04-07-2005      Added EMINENT 3035
+ *      MarkW		06-12-2005	Added Linksys@Home  
+ ***************************************************************************/
+
+
+#ifndef __vnetsw_h_OK__
+#define __vnetsw_h_OK__
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0)
+#include <linux/kthread.h>
+#endif
+
+//red,extern	unsigned long	NIC_VENDOR_DRIVER_VERSION;//blue
+////////////////////////////////////////////////////////////////////////////
+// Frame Sizes
+////////////////////////////////////////////////////////////////////////////
+
+#define MAC_ADDRESS_LENGTH                  6
+
+#define HEADER_SIZE                     14
+#define MAXIMUM_PACKET_SIZE             1500
+
+#define MAX_QUEUE_SIZE                  100
+
+#define USB_TX_HEADER_SIZE              8//WLength+TxRate+PaddingBytes+Reserved
+#define USB_RX_HEADER_SIZE              12
+
+#define WIRELESS_HEADER_OVERHEAD        18
+#define MAX_TX_PADDING_BYTES            50
+#define MAX_RX_PADDING_BYTES            66
+#define CRC32_BYTES                     4
+
+#define MAX_WIRELESS_SIZE               WIRELESS_HEADER_OVERHEAD + HEADER_SIZE + MAXIMUM_PACKET_SIZE + CRC32_BYTES
+extern unsigned long flagg;
+
+
+typedef UCHAR ADDRESS[MAC_ADDRESS_LENGTH];
+
+////////////////////////////////////////////////////////////////////////////
+// NDIS related definitions
+////////////////////////////////////////////////////////////////////////////
+#define MAX_MULTICAST_ADDRESSES         32
+#define MAX_LOOKAHEAD_SIZE              MAXIMUM_PACKET_SIZE + HEADER_SIZE
+#define TRANSMIT_BUFFER_SPACE           0x3000
+#define RECEIVE_BUFFER_SPACE            0x4000
+#define MAXIMUM_SEND_PACKETS            8
+
+#define OPER_RATE_SIZE                  4
+
+#define SUPPORTED_RATES_SET_1           0
+#define SUPPORTED_RATES_SET_2           1
+
+
+////////////////////////////////////////////////////////////////////////////
+// Memory Macros
+////////////////////////////////////////////////////////////////////////////
+#define FreeMemory(_buffer) kfree(_buffer)
+
+////////////////////////////////////////////////////////////////////////////
+// 802,11 related definitions
+////////////////////////////////////////////////////////////////////////////
+#define ESS_ID_SIZE                             32
+#define AD_HOC_MODE                             1
+#define INFRASTRUCTURE_MODE                     2
+#define WEP_KEY_SIZE                            13 //128-bit encryption
+#define PREAMBLE_TYPE_LONG                      0
+#define PREAMBLE_TYPE_SHORT                     1
+
+////////////////////////////////////////////////////////////////////////////
+// used to track information on usb pipes in use
+////////////////////////////////////////////////////////////////////////////
+typedef struct __BULKUSB_PIPEINFO {
+    BOOLEAN fPipeOpened;
+} BULKUSB_PIPEINFO, *PBULKUSB_PIPEINFO;
+
+
+//#pragma pack (push, 1)
+
+
+#define RTUSB_DEVICES { \
+	{ USB_DEVICE(0x0411, 0x0066)},	/* Melco */		\
+	{ USB_DEVICE(0x0411, 0x0067)},	/* Melco */		\
+	{ USB_DEVICE(0x050d, 0x7050)},	/* Belkin */		\
+	{ USB_DEVICE(0x050d, 0x7051)},	/* Belkin */		\
+	{ USB_DEVICE(0x050d, 0x705a)},  /* Belkin */		\
+	{ USB_DEVICE(0x06f8, 0xe000)}, /* GUILLEMOT */		\
+	{ USB_DEVICE(0x0707, 0xee13)},	/* SMC */		\
+	{ USB_DEVICE(0x0b05, 0x1706)},	/* ASUS */		\
+	{ USB_DEVICE(0x0b05, 0x1707)},	/* ASUS */		\
+	{ USB_DEVICE(0x0db0, 0x6861)},	/* MSI */		\
+	{ USB_DEVICE(0x0db0, 0x6865)},	/* MSI */		\
+	{ USB_DEVICE(0x0db0, 0x6869)},	/* MSI */		\
+	{ USB_DEVICE(0x1044, 0x8001)},	/* Gigabyte */		\
+	{ USB_DEVICE(0x1044, 0x8007)},	/* Gigabyte */		\
+	{ USB_DEVICE(0x114b, 0x0110)},	/* Spairon */		\
+	{ USB_DEVICE(0x13b1, 0x000d)},	/* Cisco Systems */	\
+	{ USB_DEVICE(0x13b1, 0x0011)},	/* Cisco Systems */	\
+	{ USB_DEVICE(0x13b1, 0x001a)},  /* Cisco Systems */	\
+	{ USB_DEVICE(0x148f, 0x1706)},	/* Ralink */		\
+	{ USB_DEVICE(0x148f, 0x2570)},	/* Ralink */		\
+	{ USB_DEVICE(0x148f, 0x2573)},	/* CNET CWD-854 */	\
+	{ USB_DEVICE(0x148f, 0x9020)},	/* Ralink */		\
+	{ USB_DEVICE(0x14b2, 0x3c02)},	/* Conceptronic */	\
+	{ USB_DEVICE(0x14f8, 0x2570)},	/* Eminent */		\
+	{ USB_DEVICE(0x2001, 0x3c00)},	/* D-LINK */		\
+	{ USB_DEVICE(0x07d1, 0x3c03)},	/* D-LINK */		\
+	{ USB_DEVICE(0x0411, 0x008b)},	/* Nintendo */		\
+	{0,}							\
+}
+
+
+typedef struct urb *purbb_t;
+typedef struct usb_ctrlrequest devctrlrequest;
+// for vendor-specific control operations
+#define CONTROL_TIMEOUT_MS	(500)			/* msec */
+#define CONTROL_TIMEOUT_JIFFIES ((CONTROL_TIMEOUT_MS * HZ)/1000)
+/* map devrequest fields onto usb_ctrlrequest's */
+#define DEVREQ_REQUEST(x) ((x)->bRequest)
+#define DEVREQ_REQUESTTYPE(x) ((x)->bRequestType)
+#define DEVREQ_VALUE(x) ((x)->wValue)
+#define DEVREQ_INDEX(x) ((x)->wIndex)
+#define DEVREQ_LENGTH(x) ((x)->wLength)
+#define PURB	purbb_t
+#define PIRP	PVOID
+#define PMDL PVOID
+
+#define NDIS_OID UINT       
+
+//
+//  MACRO for debugging information
+//
+#ifdef RT2500_DBG
+extern ULONG    debug;
+
+#define DBGPRINT(Level, fmt, args...) 					\
+{									\
+	if (Level <= debug)						\
+	{								\
+		printk(KERN_DEBUG NIC_DBG_STRING fmt, ## args);		\
+	}								\
+}
+
+#define DBGPRINT_RAW(Level, fmt, args...)				\
+  {									\
+	if (Level <= debug)						\
+	{								\
+		printk(fmt, ## args);					\
+	}								\
+}
+
+#else /* RT2500_DBG */
+#define DBGPRINT(Level, fmt, args...)
+#define DBGPRINT_RAW(Level, fmt, args...)
+#endif /* RT2500_DBG */
+
+
+#  define assert(expr) \
+        if(unlikely(!(expr))) {				        \
+        printk(KERN_ERR "Assertion failed! %s,%s,%s,line=%d\n",	\
+        #expr,__FILE__,__FUNCTION__,__LINE__);		        \
+        }
+
+
+//
+// Defines the state of the LAN media
+//
+typedef enum _NDIS_MEDIA_STATE
+{
+    NdisMediaStateConnected,
+    NdisMediaStateDisconnected
+} NDIS_MEDIA_STATE, *PNDIS_MEDIA_STATE;
+
+
+#define NdisMSetInformationComplete(handle, status)		\
+{					\
+}
+
+#define NdisMIndicateStatusComplete(handle)		\
+{					\
+}
+
+#define NdisMIndicateStatus(_M, _G, _SB, _BS)		\
+{						\
+}
+
+
+
+//
+//	The following structure defines the device power states.
+//
+typedef enum _NDIS_DEVICE_POWER_STATE
+{
+	NdisDeviceStateUnspecified = 0,
+	NdisDeviceStateD0,
+	NdisDeviceStateD1,
+	NdisDeviceStateD2,
+	NdisDeviceStateD3,
+	NdisDeviceStateMaximum
+} NDIS_DEVICE_POWER_STATE, *PNDIS_DEVICE_POWER_STATE;
+
+
+#define ETH_LENGTH_OF_ADDRESS	6
+
+
+#define STATUS_SUCCESS	0x00
+#define STATUS_UNSUCCESSFUL 0x01
+
+typedef LONG NTSTATUS;
+typedef NTSTATUS *PNTSTATUS;
+
+//
+//	spin_lock enhanced for Nested spin lock
+//
+#define	NdisAllocateSpinLock(lock)		\
+{									\
+	spin_lock_init(lock);				\
+}
+
+#define NdisReleaseSpinLock(lock)						\
+{										\
+	if (in_interrupt())				\
+{										\
+		spin_unlock_irqrestore(lock, flagg);			\
+}	\
+	else						\
+{										\
+		spin_unlock(lock);			\
+}	\
+}
+
+#define NdisAcquireSpinLock(lock)			\
+{							\
+	if (in_interrupt())				\
+		spin_lock_irqsave(lock, flagg);			\
+	else						\
+		spin_lock(lock);			\
+}
+
+
+#define RTUSBFreeSkbBuffer(skb)				\
+{											\
+	dev_kfree_skb_any(skb);					\
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+#define RTUSBUp(pAd, semaphore)	\
+{				\
+	if(pAd->MLMEThr_pid>0)	\
+	up(semaphore);		\
+}
+
+#define RTUSBCMDUp(pAd, semaphore)	\
+{	\
+	if(pAd->RTUSBCmdThr_pid>0)	\
+	up(semaphore);	\
+}
+#else
+#define RTUSBUp(pAd, semaphore)	\
+{				\
+	if(pAd->MLMEThr_active)	\
+	up(semaphore);		\
+}
+
+#define RTUSBCMDUp(pAd, semaphore)	\
+{	\
+	if(pAd->RTUSBCmdThr_active)	\
+	up(semaphore);	\
+}
+#endif
+
+//Setup Packet used in Ctrl urb's filler....
+
+#define FILL_REQUEST(a,aa,ab,ac,ad,ae)\
+  do {\
+      (a)->devreq->request = aa;\
+      (a)->devreq->requesttype = ab;\
+      (a)->devreq->value = cpu_to_le16(ac);\
+      (a)->devreq->index = cpu_to_le16(ad);\
+      (a)->devreq->length = cpu_to_le16(ae);\
+  }while(0);
+
+
+
+// direction is specified in TransferFlags
+
+#define URB_FUNCTION_RESERVED0                      0x0016
+
+//
+// These are for sending vendor and class commands
+// on the default pipe
+//
+// direction is specified in TransferFlags
+//
+
+#define URB_FUNCTION_VENDOR_DEVICE                   0x0017
+#define URB_FUNCTION_VENDOR_INTERFACE                0x0018
+#define URB_FUNCTION_VENDOR_ENDPOINT                 0x0019
+#define URB_FUNCTION_VENDOR_OTHER                    0x0020
+
+#define URB_FUNCTION_CLASS_DEVICE                    0x001A
+#define URB_FUNCTION_CLASS_INTERFACE                 0x001B
+#define URB_FUNCTION_CLASS_ENDPOINT                  0x001C
+#define URB_FUNCTION_CLASS_OTHER                     0x001F
+
+//
+// Reserved function codes
+//                                                                                                        
+#define URB_FUNCTION_RESERVED                        0x001D
+
+#define URB_FUNCTION_GET_CONFIGURATION               0x0026
+#define URB_FUNCTION_GET_INTERFACE                   0x0027
+                    
+#define URB_FUNCTION_LAST                            0x0029
+
+
+//define Vendor Command Constant
+#define CMD_VendorReset	0x01
+#define CMD_Disconnect	0x02
+#define CMD_FunctionSwitch 0x03
+#define CMD_SetTestMode	0x04
+#define CMD_ClearTestMode 0x05
+#define CMD_WriteMacRegister 0x06
+#define CMD_ReadMacRegister 0x07
+#define CMD_EEPROMWrite 0x08
+#define CMD_EEPROMRead 0x09
+#define CMD_MultipleRead 0x0A
+#define CMD_MultipleWrite 0x0B
+#define CMD_SingleRead 0x0C
+#define CMD_SingleWrite 0x0D
+
+#define NdisMSleep	mdelay
+
+
+//  Assert MACRO to make sure program running
+//
+#undef  ASSERT
+#define ASSERT(x)                                                                       \
+{                                                                                       \
+    if (!(x))                                                                           \
+    {                                                                                   \
+        printk(KERN_WARNING __FILE__ ":%d assert " #x "failed\n", __LINE__);		\
+    }                                                                                   \
+}
+
+#if 0
+#undef MOD_INC_USE_COUNT
+#define MOD_INC_USE_COUNT	do { } while (0)
+
+#undef MOD_DEC_USE_COUNT
+#define MOD_DEC_USE_COUNT	do { } while (0)
+#endif
+
+
+//add by james
+
+////////////////////////////////////////////////////////////////////////////
+// VERSION_INFO exchanged between driver/application
+////////////////////////////////////////////////////////////////////////////
+typedef struct __VERSION_INFO{
+    UCHAR   DriverMajorVersion;
+    UCHAR   DriverMinorVersion;
+    UCHAR   DriverSubVersion;
+    USHORT  DriverBuild;
+
+    USHORT  FwMajorVersion;
+    USHORT  FwMinorVersion;
+    USHORT  FwSubVersion;
+    USHORT  FwBuild;
+}VERSION_INFO, *PVERSION_INFO;
+
+#if 0
+////////////////////////////////////////////////////////////////////////////
+// The RX_BUFFER structure forms the Received USB packet from the device
+////////////////////////////////////////////////////////////////////////////
+typedef struct __RX_BUFFER{
+    USHORT      WLength;
+    UCHAR       RxRate;       //This field is not used in this version of Drv/FW
+    UCHAR       ChangeBSSID;
+    UCHAR       Fragmentation;//This field is not used in this version of Drv/FW
+    UCHAR       RSSI;
+    UCHAR       LinkQuality;
+    UCHAR       NoiseLevel;   //This field is not used in this version of Drv/FW
+    UCHAR       RxTime[4];    //This field is not used in this version of Drv/FW
+    UCHAR       WirelessPacket[MAX_WIRELESS_SIZE];
+} RX_BUFFER, *PRX_BUFFER;
+#endif
+
+
+////////////////////////////////////////////////////////////////////////////
+// The TX_BUFFER structure forms the transmitted USB packet to the device
+////////////////////////////////////////////////////////////////////////////
+typedef struct _TX_BUFFER{
+//	UINT			BulkOutSize;
+    TXD_STRUC		TxDesc;
+    UCHAR			WirelessPacket[2342];
+} TX_BUFFER, *PTX_BUFFER;
+
+
+////////////////////////////////////////////////////////////////////////////
+// The RTS_BUFFER structure forms the transmitted USB packet to the device
+////////////////////////////////////////////////////////////////////////////
+typedef struct __RTS_BUFFER{
+    TXD_STRUC      TxDesc;
+    UCHAR	       RTSPacket[16];
+} RTS_BUFFER, *PRTS_BUFFER;
+
+////////////////////////////////////////////////////////////////////////////
+// The USB_CARD_CONFIG structure is used only during device initialization
+// to pass the initial operationg parameters to device
+////////////////////////////////////////////////////////////////////////////
+typedef struct __USB_CARD_CONFIG{
+    UCHAR       ExcludeUnencrypted;
+    UCHAR       PromiscuousMode;
+    UCHAR       ShortRetryLimit;
+    UCHAR       EncryptionType;
+    USHORT      RtsThreshold;
+    USHORT      FragmentationThreshold;     // 256..2346
+    UCHAR       BasicRateSet[4];
+    BOOLEAN     AutoRateFallBack;           //0,1
+    UCHAR       Channel;
+    BOOLEAN     PrivacyInvoked;
+    UCHAR       WEPDefaultKeyID;            // 0..3
+    UCHAR       CurrentSSID[32];
+    UCHAR       WEPDefaultKeyValue[4][WEP_KEY_SIZE];
+    UCHAR       SSIDLen;
+    UCHAR       ShortPreamble;
+    USHORT      BeaconPeriod;
+} USB_CARD_CONFIG, *PUSB_CARD_CONFIG;
+
+
+////////////////////////////////////////////////////////////////////////////
+// In WEP_INFO are kept all the WEP related parameters. This structure is
+// also exchanged between driver and application.
+////////////////////////////////////////////////////////////////////////////
+typedef struct __WEP_INFO{
+    UCHAR                       WepKeyToUse;
+    UCHAR                       WepMode;
+    USHORT                      AuthenticationType;
+    UCHAR                       EncryptionLevel;
+    UCHAR                       WepKey1[WEP_KEY_SIZE];
+    UCHAR                       WepKey2[WEP_KEY_SIZE];
+    UCHAR                       WepKey3[WEP_KEY_SIZE];
+    UCHAR                       WepKey4[WEP_KEY_SIZE];
+} WEP_INFO, *PWEP_INFO;
+
+
+////////////////////////////////////////////////////////////////////////////
+// In the STATISTICS structure are kept all the device's statitrics.
+// This structure is also exchanged between driver and application.
+////////////////////////////////////////////////////////////////////////////
+typedef struct __STATISTICS{
+    ULONG   TxDataPacketsOk;
+    ULONG   TxDataPacketsError;
+    ULONG   TxMgmtPacketsOk;
+    ULONG   TxMgmtPacketsError;
+
+    ULONG   RxDataPacketsOk;
+    ULONG   RxDataPacketsError;
+    ULONG   RxMgmtPacketsOk;
+    ULONG   RxMgmtPacketsError;
+
+    ULONG   RxLost;
+    ULONG   TxPacketsRejectedNotReady;
+    ULONG   TxPacketsRejectedResources;
+    ULONG   MatchingBeacons;
+}STATISTICS, *PSTATISTICS;
+
+////////////////////////////////////////////////////////////////////////////
+// The BSS_INFO and SITE_SURVEY_INFO structures are used to form a custom
+// list of 12 maximum BSSs and keet there characteristics.
+// This list is the one that application displays in Site Survey Tab.
+////////////////////////////////////////////////////////////////////////////
+typedef struct __BSS_INFO{
+    UCHAR   Channel;
+    UCHAR   SSID[ESS_ID_SIZE];
+    UCHAR   SSIDsize;
+    UCHAR   BSSID[6];
+    UCHAR   RSSI;
+    UCHAR   UsingWEP;
+    UCHAR   PreambleType;
+    USHORT  BeaconPeriod;
+    UCHAR   BSSType;  //11->Ad-Hoc, 2->Infrastructure
+}BSS_INFO, *PBSS_INFO;
+
+#define MAX_AP_ENTRIES  30
+
+typedef struct __SITE_SURVEY_INFO{
+    BSS_INFO        BSSinfo[MAX_AP_ENTRIES];
+    UCHAR           BSSsInList;
+    UCHAR           UserSelectedIndex;
+    UCHAR           SiteSurveyState;
+}SITE_SURVEY_INFO, *PSITE_SURVEY_INFO;
+
+#ifdef WINXP
+typedef struct __XP_BSSID_LIST{
+    ULONG                   NumberOfEntries;
+    NDIS_WLAN_BSSID         NdisBSSIDEntry[MAX_AP_ENTRIES];
+}XP_BSSID_LIST;
+#endif
+
+//#pragma pack(pop)
+
+
+
+////////////////////////////////////////////////////////////////////////////
+// The FRAGMENTED_PACKET structure is used for the reassembly of the
+// fragmented 802.11 packets in the driver
+////////////////////////////////////////////////////////////////////////////
+typedef struct __FRAGMENTED_PACKET{
+    USHORT  Sequence;
+    USHORT  CurrentLen;
+    UCHAR   SourceAddress[6];
+    UCHAR   FragmentNumber;//next fragment expected
+    UCHAR   WirelessPacket[MAX_WIRELESS_SIZE];
+}FRAGMENTED_PACKET, *PFRAGMENTED_PACKET;
+
+////////////////////////////////////////////////////////////////////////////
+// The ASYNC_OID structure is used for holding the context of an OID call
+// that the driver will complete asynchronously
+////////////////////////////////////////////////////////////////////////////
+typedef struct __ASYNC_OID{
+    PVOID   InformationBuffer;
+    ULONG   InformationBufferLength;
+    PULONG  Bytes;
+    PULONG  BytesNeeded;
+}ASYNC_OID, *PASYNC_OID;
+
+#if 1//RT2460
+//
+//  Some utility macros
+//
+#ifndef min
+#define min(_a, _b)     (((_a) < (_b)) ? (_a) : (_b))
+#endif
+
+#ifndef max
+#define max(_a, _b)     (((_a) > (_b)) ? (_a) : (_b))
+#endif
+
+#define INC_COUNTER(Val)    (Val.QuadPart++)
+
+#define	INFRA_ON(_p)		        (((_p)->PortCfg.Massoc) == TRUE)	// Check Massoc
+#define ADHOC_ON(_p)                (((_p)->PortCfg.Mibss) == TRUE)    // check Mibss
+
+#define	RTMP_SET_PACKET_FRAGMENTS(_p, number)	((_p)->cb[10] = number)
+#define RTMP_GET_PACKET_FRAGMENTS(_p)			((_p)->cb[10])
+#define	RTMP_SET_PACKET_RTS(_p, number)			((_p)->cb[11] = number)
+#define RTMP_GET_PACKET_RTS(_p)					((_p)->cb[11])
+#define	RTMP_SET_PACKET_FIRST_CONTEXT(_p, number)	((_p)->cb[12] = number)
+#define RTMP_GET_PACKET_FIRST_CONTEXT(_p)			((_p)->cb[12])
+//blue,#define	RTMP_SET_PACKET_CONTEXTS_REQUIRED(_p, number)	((_p)->cb[13] = number)
+//blue,#define RTMP_GET_PACKET_CONTEXTS_REQUIRED(_p)			((_p)->cb[13])
+#define GET_NEXT_PACKET_IN_BULKOUT_QUEUE(_p)			((struct sk_buff **)&((_p)->cb[14]))
+
+
+#define	MAKE_802_3_HEADER(_p, _pMac1, _pMac2, _pType)								\
+{																					\
+	memcpy(_p, _pMac1, ETH_LENGTH_OF_ADDRESS);								\
+	memcpy((_p + ETH_LENGTH_OF_ADDRESS), _pMac2, ETH_LENGTH_OF_ADDRESS);	\
+	memcpy((_p + ETH_LENGTH_OF_ADDRESS * 2), _pType, LENGTH_802_3_TYPE);	\
+}
+
+//
+// Register set pair for initialzation register set definition
+//
+typedef	struct	_RTMP_REG_PAIR
+{
+	ULONG	Register;
+	ULONG	Value;
+}	RTMP_REG_PAIR, *PRTMP_REG_PAIR;
+
+//
+// Register set pair for initialzation register set definition
+//
+typedef	struct	_RTMP_RF_REGS
+{
+	UCHAR   Channel;
+	ULONG	R1;
+	ULONG   R2;
+	ULONG   R3;
+	ULONG   R4;
+}	RTMP_RF_REGS, *PRTMP_RF_REGS;
+
+typedef	struct	_RTMP_RF_REGS_1
+{
+	UCHAR   Channel;
+	ULONG	TempR2;
+	ULONG	R1;
+	ULONG   R2;
+	ULONG   R3;
+	ULONG   R4;
+}	RTMP_RF_REGS_1, *PRTMP_RF_REGS_1;
+
+//
+//  Macros for flag and ref count operations
+//
+#define RTMP_SET_FLAG(_M, _F)       ((_M)->Flags |= (_F))
+#define RTMP_CLEAR_FLAG(_M, _F)     ((_M)->Flags &= ~(_F))
+#define RTMP_CLEAR_FLAGS(_M)        ((_M)->Flags = 0)
+#define RTMP_TEST_FLAG(_M, _F)      (((_M)->Flags & (_F)) != 0)
+#define RTMP_TEST_FLAGS(_M, _F)     (((_M)->Flags & (_F)) == (_F))
+
+#define RTMP_INC_REF(_A)            NdisInterlockedIncrement(&(_A)->RefCount)
+#define RTMP_DEC_REF(_A)            NdisInterlockedDecrement(&(_A)->RefCount); ASSERT(_A->RefCount >= 0)
+#define RTMP_GET_REF(_A)            ((_A)->RefCount)
+
+#define RTMP_INC_RCV_REF(_A)        ((_A)->RcvRefCount++)
+#define RTMP_DEC_RCV_REF(_A)        ((_A)->RcvRefCount--)
+#define RTMP_GET_RCV_REF(_A)        ((_A)->RcvRefCount)
+
+#define RTMP_INC_SEND_REF(_A)       ((_A)->SendRefCount++)
+#define RTMP_DEC_SEND_REF(_A)       ((_A)->SendRefCount--)
+#define RTMP_GET_SEND_REF(_A)       ((_A)->SendRefCount)
+
+#define RTMP_OFFSET(field)          ((UINT)FIELD_OFFSET(RTMP_ADAPTER, field))
+#define RTMP_SIZE(field)            sizeof(((PRT2570ADAPTER)0)->field)
+#define PORT_OFFSET(field)          ((UINT)FIELD_OFFSET(PORT_CONFIG, field))
+#define PORT_SIZE(field)            sizeof(((PPORT_CONFIG)0)->field)
+
+//blue,#define RTMP_IO_READ32(_A, _R, _pV) RTUSBReadMACRegister((_A), (_R), (_pV))
+//blue,#define RTMP_IO_WRITE32(_A, _R, _V) RTUSBReadMACRegister((_A), (_R), (_V))
+//
+//  Statistic counter structure
+//
+//mandatory counters from general and Ethernet statistics objects
+typedef struct _COUNTER_802_3
+{
+    // General Stats
+	ULONG		GoodTransmits;
+	ULONG		GoodReceives;
+	ULONG		TxErrors;
+	ULONG		RxErrors;
+	ULONG		RxNoBuffer;
+
+    // Ethernet Stats
+	ULONG		RcvAlignmentErrors;
+	ULONG		OneCollision;
+	ULONG		MoreCollisions;
+
+}   COUNTER_802_3, *PCOUNTER_802_3;
+//OID_802_11_STATISTICS
+typedef struct _COUNTER_802_11 {
+    ULONG           Length;
+    LARGE_INTEGER   TransmittedFragmentCount;
+    LARGE_INTEGER   MulticastTransmittedFrameCount;
+    LARGE_INTEGER   FailedCount;
+    LARGE_INTEGER   NoRetryCount;
+    LARGE_INTEGER   RetryCount;
+    LARGE_INTEGER   MultipleRetryCount;
+    LARGE_INTEGER   RTSSuccessCount;
+    LARGE_INTEGER   RTSFailureCount;
+    LARGE_INTEGER   ACKFailureCount;
+    LARGE_INTEGER   FrameDuplicateCount;
+    LARGE_INTEGER   ReceivedFragmentCount;
+    LARGE_INTEGER   MulticastReceivedFrameCount;
+    LARGE_INTEGER   FCSErrorCount;
+} COUNTER_802_11, *PCOUNTER_802_11;
+//proprietary counters
+typedef struct _COUNTER_RALINK {
+    ULONG           TransmittedByteCount;   // both successful and failure, used to calculate TX throughput
+    ULONG           ReceivedByteCount;      // both CRC okay and CRC error, used to calculate RX throughput
+    ULONG           BeenDisassociatedCount;
+    ULONG           BadCQIAutoRecoveryCount;
+    ULONG           PoorCQIRoamingCount;
+    ULONG           MgmtRingFullCount;
+    ULONG           RxCount;
+    ULONG           DecryptCount;
+    ULONG           RxRingErrCount;
+    ULONG           EncryptCount;
+    ULONG           KickTxCount;
+    ULONG           TxRingErrCount;	
+} COUNTER_RALINK, *PCOUNTER_RALINK;
+
+typedef struct _COUNTER_DRS {
+    USHORT          TxQuality[MAX_LEN_OF_SUPPORTED_RATES];
+    UCHAR           PER[MAX_LEN_OF_SUPPORTED_RATES];
+    UCHAR           TxRateUpPenalty;      // extra # of second penalty due to last unstable condition
+    ULONG           CurrTxRateStableTime; // # of second in current TX rate
+    BOOLEAN         fNoisyEnvironment;
+    UCHAR           LastSecTxRateChangeAction; // 0: no change, 1:rate UP, 2:rate down
+} COUNTER_DRS, *PCOUNTER_DRS;
+
+typedef struct _COUNTER_QA {
+	LARGE_INTEGER   CRCErrorCount;
+	LARGE_INTEGER   RXOverFlowCount;
+	LARGE_INTEGER   PHYErrorCount;
+	LARGE_INTEGER   FalseCCACount;
+	LARGE_INTEGER   U2MDataCount;
+	LARGE_INTEGER   OtherDataCount;
+	LARGE_INTEGER   BeaconCount;
+	LARGE_INTEGER   othersCount;	
+} COUNTER_QA, *PCOUNTER_QA;
+
+
+//
+//  Arcfour Structure Added by PaulWu
+//
+typedef struct  _ARCFOUR
+{
+	UINT			X;
+	UINT			Y;
+	UCHAR			STATE[256];
+}   ARCFOURCONTEXT, *PARCFOURCONTEXT;
+
+// Shared key data structure
+typedef	struct	_WEP_KEY {
+	UCHAR	KeyLen;						// Key length for each key, 0: entry is invalid
+	UCHAR	Key[MAX_LEN_OF_KEY];		// right now we implement 4 keys, 128 bits max
+}	WEP_KEY, *PWEP_KEY;
+
+// Shared key data structure
+typedef	struct	_WPA_KEY {
+	UCHAR	KeyLen;				// Key length for each key, 0: entry is invalid
+	UCHAR	Key[16];			// right now we implement 4 keys, 128 bits max
+	UCHAR	RxMic[8];
+	UCHAR	TxMic[8];
+	NDIS_802_11_MAC_ADDRESS	BssId;	// For pairwise key only
+	UCHAR	TxTsc[6];			// 48bit TSC value
+	UCHAR	RxTsc[6];			// 48bit TSC value
+	UCHAR	Type;				// Indicate Pairwise / Group
+}	WPA_KEY, *PWPA_KEY;
+
+// configuration to be used when this STA starts a new ADHOC network
+typedef struct _IBSS_CONFIG {
+    USHORT    BeaconPeriod;
+    USHORT    AtimWin;
+    UCHAR     Channel;
+    UCHAR     SupportedRates[MAX_LEN_OF_SUPPORTED_RATES];    // Supported rates
+    UCHAR     SupportedRatesLen;
+}   IBSS_CONFIG, *PIBSS_CONFIG;
+
+typedef struct _LED_CONTROL {
+    BOOLEAN     fOdd;
+    BOOLEAN     fRxActivity;
+    BOOLEAN     fSiteSurvey;
+    BOOLEAN     fLinkUp;
+     RALINK_TIMER_STRUCT BlinkTimer; // 50 ms periodic timer
+//    ULONG       LastLedCsr;
+    USHORT       LastLedCsr;
+} LED_CONTROL;
+
+
+typedef struct _BBP_TUNING_STRUCT {
+    BOOLEAN     Enable;
+    UCHAR       FalseCcaCountUpperBound;  // 100 per sec
+    UCHAR       FalseCcaCountLowerBound;  // 10 per sec
+    UCHAR       R17LowerBound;            // specified in E2PROM
+    UCHAR       R17UpperBound;            // 0x68 according to David Tung
+    UCHAR       CurrentR17Value;
+} BBP_TUNING, *PBBP_TUNING;
+
+typedef struct _SOFT_RX_ANT_DIVERSITY_STRUCT {
+    BOOLEAN   PrimaryInUsed;
+    UCHAR     PrimaryRxAnt;     // 0:Ant-A, 1:Ant-B
+    UCHAR     SecondaryRxAnt;   // 0:Ant-A, 1:Ant-B
+    USHORT    AvgRssi[2];       // AvgRssi[0]:Ant-A, AvgRssi[1]:Ant-B
+     RALINK_TIMER_STRUCT    RxAntDiversityTimer;
+} SOFT_RX_ANT_DIVERSITY, *PSOFT_RX_ANT_DIVERSITY;
+
+
+
+// PortConfig
+typedef struct _PORT_CONFIG {
+
+    // MIB:ieee802dot11.dot11smt(1).dot11StationConfigTable(1)
+    USHORT    CapabilityInfo;
+    USHORT    Psm;                  // power management mode   (PWR_ACTIVE|PWR_SAVE)
+    USHORT    BeaconPeriod;         // in units of TU
+
+    USHORT    CfpMaxDuration;
+    USHORT    CfpDurRemain;
+    USHORT    CfpCount;
+    USHORT    CfpPeriod;
+
+    USHORT    DisassocReason;
+    MACADDR   DisassocSta;
+    USHORT    DeauthReason;
+    MACADDR   DeauthSta;
+    USHORT    AuthFailReason;
+    MACADDR   AuthFailSta;
+
+	NDIS_802_11_AUTHENTICATION_MODE		AuthMode;//set by OID_802_11_AUTHENTICATION_MODE. This should match to whatever microsoft defined
+	NDIS_802_11_WEP_STATUS				WepStatus;//set by OID_802_11_WEP_STATUS
+	NDIS_802_11_WEP_STATUS				OrigWepStatus;	// Original wep status set from OID
+
+	// Add to support different cipher suite for WPA2/WPA mode
+	NDIS_802_11_ENCRYPTION_STATUS		GroupCipher;		// Multicast cipher suite
+	NDIS_802_11_ENCRYPTION_STATUS		PairCipher;			// Unicast cipher suite
+    BOOLEAN								bMixCipher;			// Indicate current Pair & Group use different cipher suites
+    USHORT								RsnCapability;
+    
+#if 1  
+    // MIB:ieee802dot11.dot11smt(1).dot11WEPDefaultKeysTable(3)
+    WEP_KEY	  SharedKey[SHARE_KEY_NO];//set by OID_802_11_ADD_KEY or OID_802_11_ADD_WEP. Keep for backward compatiable
+	WPA_KEY   PairwiseKey[PAIRWISE_KEY_NO];//set by OID_802_11_ADD_KEY
+	WPA_KEY   GroupKey[GROUP_KEY_NO];//set by OID_802_11_ADD_KEY
+	WPA_KEY   PskKey;                   // WPA PSK mode PMK
+	BSSID_INFO	SavedPMK[PMKID_NO];
+	ULONG		SavedPMKNum;			// Saved PMKID number
+    UCHAR     PTK[64];
+#endif
+	// WPA 802.1x port control, WPA_802_1X_PORT_SECURED, WPA_802_1X_PORT_NOT_SECURED
+	UCHAR     PortSecured;
+
+	// For WPA countermeasures
+	ULONG		LastMicErrorTime;	// record last MIC error time
+	ULONG		MicErrCnt;			// Should be 0, 1, 2, then reset to zero (after disassoiciation).
+	BOOLEAN		bBlockAssoc;		// Block associate attempt for 60 seconds after counter measure occurred.
+
+	// For WPA-PSK supplicant state,red, add for WPA-PSK
+      WPA_STATE   WpaState;           // Default is SS_NOTUSE and handled by microsoft 802.1x
+      UCHAR       ReplayCounter[8];
+      UCHAR       ANonce[32];         // ANonce for WPA-PSK from aurhenticator
+      UCHAR       SNonce[32];         // SNonce for WPA-PSK
+
+    // MIB:ieee802dot11.dot11smt(1).dot11WEPKeyMappingsTable(4)
+    // not implemented yet
+
+    // MIB:ieee802dot11.dot11smt(1).dot11PrivacyTable(5)
+    UCHAR     DefaultKeyId;//set by OID_802_11_ADD_KEY or OID_802_11_ADD_WEP
+	NDIS_802_11_PRIVACY_FILTER	PrivacyFilter;		// PrivacyFilter enum for 802.1X
+
+    // MIB:ieee802dot11.dot11mac(2).dot11OperationTable(1)
+    USHORT    RtsThreshold;       // in units of BYTE
+    USHORT    FragmentThreshold;
+    BOOLEAN   bFragmentZeroDisable;		// Microsoft use 0 as disable 
+    
+    // MIB:ieee802dot11.dot11phy(4).dot11PhyAntennaTable(2)
+    UCHAR     CurrentTxAntenna;
+    UCHAR     CurrentRxAntenna;
+    UCHAR     NumberOfAntenna;
+
+    // MIB:ieee802dot11.dot11phy(4).dot11PhyTxPowerTable(3)
+    UCHAR     CurrentTxPowerLevelIndex; //default&other value=MaxPower,1=MinPower,2=1*MaxPower/4,3=2*MaxPower/4,4=3*MaxPower/4,
+    UCHAR     TxPower;
+    UCHAR     TxRate;       // RATE_1, RATE_2, RATE_5_5, RATE_11, ...
+    BOOLEAN   EnableAutoRateSwitching;  // 1 - enable auto rate switching; 0 - disable
+    ULONG     TxPowerPercentage;        // 0~100 %,blue
+    
+    // MIB:ieee802dot11.dot11phy(4).dot11PhyDSSSTable(5)
+    UCHAR     Channel;        // current (I)BSS channel used in the station
+    UCHAR     CountryRegion;	// Enum of country region, 0:FCC, 1:IC, 2:ETSI, 3:SPAIN, 4:France, 5:MKK, 6:MKK1, 7:Israel
+    
+    // MIB:ieee802dot11.dot11phy(4).dot11AntennasListTable(8)
+    BOOLEAN AntennaSupportTx;
+    BOOLEAN AntennaSupportRx;
+    BOOLEAN AntennaSupportDiversityRx;
+
+	// Use user changed MAC
+    BOOLEAN bLocalAdminMAC;                           
+    
+    // MIB:ieee802dot11.dot11phy(4).dot11SupportedDataRatesTxTable(9)
+    // MIB:ieee802dot11.dot11phy(4).dot11SupportedDataRatesRxTable(10)
+    UCHAR     SupportedRates[MAX_LEN_OF_SUPPORTED_RATES];    // Supported rates
+    UCHAR     SupportedRatesLen;
+    UCHAR     ExpectedACKRate[MAX_LEN_OF_SUPPORTED_RATES];
+
+    //blue
+    // Copy supported rate from desired AP's beacon. We are trying to match
+	// AP's supported and extended rate settings.
+	UCHAR		SupRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR		ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR		SupRateLen;
+	UCHAR		ExtRateLen;
+
+    //
+    // other parameters not defined in standard MIB
+    //
+    UCHAR     DesiredRates[MAX_LEN_OF_SUPPORTED_RATES];      // OID_802_11_DESIRED_RATES
+    UCHAR     MaxDesiredRate;
+    USHORT    RecvDtim;
+    MACADDR   Bssid;
+    MACADDR   Broadcast;            // FF:FF:FF:FF:FF:FF
+    USHORT    Pss;                  // current power saving status (PWR_SAVE|PWR_ACTIVE)
+    UCHAR     RssiTrigger;
+    UCHAR     RssiTriggerMode;      // RSSI_TRIGGERED_UPON_BELOW_THRESHOLD or RSSI_TRIGGERED_UPON_EXCCEED_THRESHOLD
+    UCHAR     LastRssi;             // last received BEACON's RSSI
+    USHORT    AvgRssi;              // last 8 BEACON's average RSSI,blue
+    USHORT    AtimWin;              // in kusec; IBSS parameter set element
+    USHORT    Aid;                  // association ID
+    UCHAR     RtsRate;              // RATE_xxx
+    UCHAR     MlmeRate;               // RATE_xxx, used to send MLME frames
+    UCHAR     MaxTxRate;            // RATE_xxx
+    USHORT    DefaultListenCount;   // default listen count;
+    UCHAR     BssType;              // BSS_INFRA or BSS_INDEP
+
+    UCHAR     SsidLen;               // the actual ssid length in used
+    CHAR      Ssid[MAX_LEN_OF_SSID]; // NOT NULL-terminated
+
+    BSS_TABLE BssTab;     // BSS Table
+
+    // global variables mXXXX used in MAC protocol state machines
+    BOOLEAN   Mibss;
+    BOOLEAN   Massoc;
+    BOOLEAN   Mauth;
+
+    // RFMON logic flags
+    BOOLEAN   MallowRFMONTx;
+    ULONG     ForcePrismHeader;
+
+    // PHY specification
+    UCHAR     PhyMode;    // PHY_11A, PHY_11B, PHY_11BG_MIXED, PHY_ABG_MIXED
+    USHORT    Dsifs;      // in units of usec
+
+    ULONG     WindowsPowerMode;			// Power mode for AC power
+    //ULONG     WindowsBatteryPowerMode;	// Power mode for battery if exists
+    //BOOLEAN   WindowsACCAMEnable;		// Enable CAM power mode when AC on
+    ULONG     PacketFilter;				// Packet filter for receiving
+    BOOLEAN   AutoReconnect;			// Set to TRUE when setting OID_802_11_SSID with no matching BSSID
+#ifdef NDIS51_MINIPORT   
+    ULONG     WindowsPowerProfile;	// Windows power profile, for NDIS5.1 PnP
+#endif
+    ULONG     WindowsTxPreamble; // Rt802_11PreambleLong, Rt802_11PreambleShort, Rt802_11PreambleAuto
+
+	UCHAR	  ChannelTxPower[MAX_LEN_OF_CHANNELS];		// Store Tx power value for all channels.
+
+	//blue
+	UCHAR	  ChannelTssiRef[MAX_LEN_OF_CHANNELS];		// Store Tssi Reference value for all channels.
+	UCHAR	  ChannelTssiDelta;							// Store Tx TSSI delta increment / decrement value
+	BOOLEAN   bAutoTxAgc;
+	
+	UCHAR     ChannelList[MAX_LEN_OF_CHANNELS];         // list all supported channels for site survey
+	UCHAR     ChannelListNum;                           // number of channel in ChannelList[]
+	BOOLEAN   bShowHiddenSSID;//blue
+	
+    // configuration to be used when this STA starts a new ADHOC network
+    IBSS_CONFIG IbssConfig;
+
+    ULONG     LastBeaconRxTime;     // OS's timestamp of the last BEACON RX time
+    atomic_t     DataPacketsFromAP;     // # of data packets received from AP since we receive last Beacon from AP
+    ULONG     Last11bBeaconRxTime;  // OS's timestamp of the last 11B BEACON RX time
+    ULONG     LastScanTime;		// Record last scan time for issue BSSID_SCAN_LIST
+    ULONG     IgnoredScanNumber;	// Ignored BSSID_SCAN_LIST requests
+    BOOLEAN	  bSwRadio;			// Software controlled Radio On/Off, TRUE: On
+    BOOLEAN	  bHwRadio;			// Hardware controlled Radio On/Off, TRUE: On
+    BOOLEAN	  bRadio;			// Radio state, And of Sw & Hw radio state
+    BOOLEAN   bHardwareRadio;	// Hardware-controlled Radio enabled
+
+    LED_CONTROL             LedCntl;
+    UCHAR                   RfType;
+    UCHAR                   LedMode;
+    
+	// New for WPA, windows want us to to keep association information and
+	// Fixed IEs from last association response
+	NDIS_802_11_ASSOCIATION_INFORMATION		AssocInfo;
+//	NDIS_802_11_FIXED_IEs					FixIEs;
+	UCHAR					ReqVarIELen;				// Length of next VIE include EID & Length
+	UCHAR					ReqVarIEs[MAX_VIE_LEN];
+	UCHAR					ResVarIELen;				// Length of next VIE include EID & Length
+	UCHAR					ResVarIEs[MAX_VIE_LEN];
+
+    // the following fields are user setting from UI
+    ULONG     EnableTurboRate;      // 0: disable, 1: enable 72/100 Mbps whenever applicable
+    ULONG     EnableTxBurst;        // 0: disable, 1: enable TX PACKET BURST
+    ULONG     UseBGProtection;      // 0: auto, 1: always use, 2: always not use
+    ULONG     UseShortSlotTime;     // 0: disable, 1: enable 9us short slot time if AP supports
+    //blue,ULONG     UseOfdmRatesIn11gAdhoc; // 0:WIFI mode (11b rates only), 1:allow OFDM rates
+    ULONG     AdhocMode; 			// 0:WIFI mode (11b rates only), 1: b/g mixed, 2: 11g only,blue
+
+    // this flag is the result calculated from UI settings and AP's ERP/Capability
+    ULONG     BGProtectionInUsed;   // 0: not in-used, 1: in-used
+    ULONG     ShortSlotInUsed;      // 0: not in-used, 1: in-used
+    USHORT    TxPreambleInUsed;     // Rt802_11PreambleLong, Rt802_11PreambleShort
+	UCHAR		CipherAlg;
+
+    // latch th latest RF programming value here since RF IC doesn't support READ operation
+    RTMP_RF_REGS    LatchRfRegs;
+
+    //blue
+    BOOLEAN                       BbpTuningEnable;
+    UCHAR                         VgcLowerBound;
+    RT_802_11_RX_AGC_VGC_TUNING   BbpTuning;
+    UCHAR                         LastR17Value;
+
+    ULONG                         SystemErrorBitmap;  // b0: E2PROM version error
+
+    //blue
+    UCHAR                   BbpWriteLatch[100];   // record last BBP register value written via BBP_IO_WRITE
+    ULONG                   CurrTxRateStableTime; // # of second in current TX rate
+    UCHAR                   TxRateUpPenalty;      // extra # of second penalty due to last unstable condition
+
+    // For WPA-PSK supplicant state
+    //red,WPA_STATE   WpaState;           // Default is SS_NOTUSE and handled by microsoft 802.1x
+	
+    
+} PORT_CONFIG, *PPORT_CONFIG;
+
+typedef struct _MLME_MEMORY_STRUCT {
+    PVOID                           AllocVa;    //Pointer to the base virtual address of the allocated memory
+    struct _MLME_MEMORY_STRUCT      *Next;      //Pointer to the next virtual address of the allocated memory
+} MLME_MEMORY_STRUCT, *PMLME_MEMORY_STRUCT;
+
+typedef struct  _MLME_MEMORY_HANDLER {
+    BOOLEAN                 MemRunning;         //The flag of the Mlme memory handler's status
+    UINT                    MemoryCount;        //Total nonpaged system-space memory not size
+    UINT                    InUseCount;         //Nonpaged system-space memory in used counts
+    UINT                    UnUseCount;         //Nonpaged system-space memory available counts
+    UINT                    PendingCount;       //Nonpaged system-space memory for free counts
+    PMLME_MEMORY_STRUCT     pInUseHead;         //Pointer to the first nonpaed memory not used
+    PMLME_MEMORY_STRUCT     pInUseTail;         //Pointer to the last nonpaged memory not used
+    PMLME_MEMORY_STRUCT     pUnUseHead;         //Pointer to the first nonpaged memory in used
+    PMLME_MEMORY_STRUCT     pUnUseTail;         //Pointer to the last nonpaged memory in used
+    PULONG                  MemFreePending[MAX_MLME_HANDLER_MEMORY];   //an array to keep pending free-memory's pointer (32bits)
+} MLME_MEMORY_HANDLER, *PMLME_MEMORY_HANDLER;
+
+typedef struct _MLME_STRUCT {
+    STATE_MACHINE           CntlMachine, AssocMachine, AuthMachine, AuthRspMachine, SyncMachine,WpaPskMachine;
+    STATE_MACHINE_FUNC      CntlFunc[CNTL_FUNC_SIZE], AssocFunc[ASSOC_FUNC_SIZE];
+    STATE_MACHINE_FUNC      AuthFunc[AUTH_FUNC_SIZE], AuthRspFunc[AUTH_RSP_FUNC_SIZE];
+    STATE_MACHINE_FUNC      SyncFunc[SYNC_FUNC_SIZE],WpaPskFunc[WPA_PSK_FUNC_SIZE];
+    
+    ASSOC_AUX               AssocAux;
+    AUTH_AUX                AuthAux;
+    AUTH_RSP_AUX            AuthRspAux;
+    SYNC_AUX                SyncAux;
+    CNTL_AUX                CntlAux;
+    
+    COUNTER_802_11          PrevWlanCounters;
+    ULONG                   ChannelQuality;  // 0..100, Channel Quality Indication for Roaming
+
+    BOOLEAN                 Running;
+    spinlock_t          TaskLock;
+    MLME_QUEUE              Queue;
+
+    UINT                    ShiftReg;
+//    PSPOLL_FRAME            PsFr;
+//    MACHDR                  NullFr;
+    
+    RALINK_TIMER_STRUCT	PeriodicTimer;
+    ULONG                   PeriodicRound;
+    ULONG                   PrevTxCnt;
+
+    MLME_MEMORY_HANDLER     MemHandler;         //The handler of the nonpaged memory inside MLME
+
+} MLME_STRUCT, *PMLME_STRUCT;
+
+//
+// Management ring buffer format
+//
+typedef	struct	_MGMT_STRUC	{
+	BOOLEAN		Valid;
+	PUCHAR		pBuffer;
+	ULONG		Length;
+	UCHAR		FirstIndex;
+	UCHAR		ContextsRequired;
+	struct	_MGMT_STRUC *next;//blue
+}	MGMT_STRUC, *PMGMT_STRUC;
+
+//
+// P802.11 Frame control field, 16 bit
+//
+typedef	struct	_FRAME_CONTROL	{
+	USHORT		Ver:2;				// Protocol version
+	USHORT		Type:2;				// MSDU type
+	USHORT		Subtype:4;			// MSDU subtype
+	USHORT		ToDs:1;				// To DS indication
+	USHORT		FrDs:1;				// From DS indication
+	USHORT		MoreFrag:1;			// More fragment bit
+	USHORT		Retry:1;			// Retry status bit
+	USHORT		PwrMgt:1;			// Power management bit
+	USHORT		MoreData:1;			// More data bit
+	USHORT		Wep:1;				// Wep data
+	USHORT		Order:1;			// Strict order expected
+}	FRAME_CONTROL, *PFRAME_CONTROL;
+
+//
+// P802.11 intermediate header format
+//
+typedef	struct	_CONTROL_HEADER	{
+	FRAME_CONTROL	Frame;				// Frame control structure
+	USHORT			Duration;			// Duration value
+	MACADDR			Addr1;				// Address 1 field
+	MACADDR			Addr2;				// Address 2 field
+}	CONTROL_HEADER, *PCONTROL_HEADER;
+
+typedef	struct	_PS_POLL_BUFFER	{
+    TXD_STRUC		TxDesc;
+	PSPOLL_FRAME	PsPollPacket;
+}	PS_POLL_BUFFER, *PPS_POLL_BUFFER;
+
+//
+// P802.11 header format
+//
+typedef	struct	_HEADER_802_11	{
+	CONTROL_HEADER	Controlhead;
+	MACADDR			Addr3;				// Address 3 field
+	USHORT			Frag:4;				// Fragment number
+	USHORT			Sequence:12;		// Sequence number
+}	HEADER_802_11, *PHEADER_802_11;
+
+typedef	struct	_NULL_FRAME_BUFFER	{
+    TXD_STRUC		TxDesc;
+	HEADER_802_11	NullFrame;
+}	NULL_FRAME_BUFFER, *PNULL_FRAME_BUFFER;
+
+typedef	struct	_WPAPSK_BUFFER	{
+    TXD_STRUC		TxDesc;
+	UCHAR	WpaPskFrame[512];
+}	WPAPSK_BUFFER, *PWPAPSK_BUFFER;
+
+
+
+typedef	struct	_STUFF_BUFFER	{
+	NULL_FRAME_BUFFER	NullFrameBuffer;
+    UCHAR	StuffBuffer[512];
+}	STUFF_BUFFER, *PSTUFF_BUFFER;
+
+//
+// Receive Tuple Cache Format
+//
+typedef	struct	_TUPLE_CACHE	{
+	BOOLEAN			Valid;
+	MACADDR			MAC;
+	USHORT			Sequence; 
+	USHORT			Frag;
+}	TUPLE_CACHE, *PTUPLE_CACHE;
+
+//
+// Fragment Frame structure
+//
+typedef	struct	_FRAGMENT_FRAME	{
+	UCHAR		Header802_3[14];
+	UCHAR		Header_LLC[8];
+	UCHAR		Buffer[MAX_FRAME_SIZE];
+	ULONG		RxSize;
+	USHORT		Sequence;
+	USHORT		LastFrag;
+	ULONG		Flags;			// Some extra frame information. bit 0: LLC presented
+}	FRAGMENT_FRAME, *PFRAGMENT_FRAME;
+
+//
+// Packet information for NdisQueryPacket
+//
+typedef	struct	_PACKET_INFO	{
+	UINT			PhysicalBufferCount;	// Physical breaks of buffer descripor chained
+	UINT			BufferCount ;			// Number of Buffer descriptor chained
+	UINT			TotalPacketLength ;  	// Self explained
+	//PNDIS_BUFFER	pFirstBuffer;			// Pointer to first buffer descriptor
+}	PACKET_INFO, *PPACKET_INFO;
+
+//
+// Tkip Key structure which RC4 key & MIC calculation
+//
+typedef	struct	_TKIP_KEY_INFO	{
+	UINT		nBytesInM;	// # bytes in M for MICKEY
+	ULONG		IV16;
+	ULONG		IV32;	
+	ULONG		K0;			// for MICKEY Low
+	ULONG		K1;			// for MICKEY Hig
+	ULONG		L;			// Current state for MICKEY
+	ULONG		R;			// Current state for MICKEY
+	ULONG		M;			// Message accumulator for MICKEY
+	UCHAR		RC4KEY[16];
+	UCHAR		MIC[8];
+}	TKIP_KEY_INFO, *PTKIP_KEY_INFO;
+
+//
+// Private / Misc data, counters for driver internal use
+//
+typedef	struct	__PRIVATE_STRUC	{
+	ULONG		SystemResetCnt;			// System reset counter
+	ULONG		ResetCountDown;			// Count down before issue reset, patch for RT2430
+//	ULONG		CCAErrCnt;				// CCA error count, for debug purpose, might move to global counter
+	ULONG		PhyRxErrCnt;			// PHY Rx error count, for debug purpose, might move to global counter
+	ULONG		PhyTxErrCnt;			// PHY Tx error count, for debug purpose, might move to global counter
+	// Variables for WEP encryption / decryption in rtmp_wep.c
+	ULONG			FCSCRC32;
+	ULONG			RxSetCnt;
+	ULONG			DecryptCnt;
+	ARCFOURCONTEXT	WEPCONTEXT;
+	// Tkip stuff
+	TKIP_KEY_INFO	Tx;
+	TKIP_KEY_INFO	Rx;
+}	PRIVATE_STRUC, *PPRIVATE_STRUC;
+
+
+
+/////////////////
+//Vendor Commands
+/////////////////
+#define COMMAND_QUEUE_SIZE  11
+
+typedef	struct _CmdQElmt	{
+	UINT				command;
+	PVOID				buffer;
+	ULONG				bufferlength;
+	BOOLEAN				CmdFromNdis;
+	BOOLEAN				SetOperation;
+	BOOLEAN				InUse;//blue
+	struct _CmdQElmt	*next;
+}	CmdQElmt, *PCmdQElmt;
+
+typedef	struct	_CmdQ	{
+	UINT		size;
+	CmdQElmt	*head;
+	CmdQElmt	*tail;
+}	CmdQ, *PCmdQ;
+
+typedef enum _BULK_OUT_TYPE {
+    DATA,
+    MLME,
+	BEACON,
+	PS_POLL,
+    ALL
+} BULK_OUT_TYPE;
+
+#if 0
+typedef	struct _BULK_OUT_QUEUE_ELEMENT	{
+	BULK_OUT_TYPE			BulkOutType;
+	PVOID				buffer;
+	struct _BULK_OUT_QUEUE_ELEMENT	*next;
+}	BULK_OUT_QUEUE_ELEMENT, *PBULK_OUT_QUEUE_ELEMENT;
+
+typedef	struct	_BULK_OUT_QUEUE	{
+	UINT		size;
+	BULK_OUT_QUEUE_ELEMENT	*head;
+	BULK_OUT_QUEUE_ELEMENT	*tail;
+}	BULK_OUT_QUEUE, *PBULK_OUT_QUEUE;
+
+typedef	struct _BULK_OUT_QUEUE_ELEMENT	{
+	PVOID				buffer;
+	struct _BULK_OUT_QUEUE_ELEMENT	*next;
+}	BULK_OUT_QUEUE_ELEMENT, *PBULK_OUT_QUEUE_ELEMENT;
+
+typedef	struct	_BULK_OUT_QUEUE	{
+	UINT		size;
+	BULK_OUT_QUEUE_ELEMENT	*head;
+	BULK_OUT_QUEUE_ELEMENT	*tail;
+}	BULK_OUT_QUEUE, *PBULK_OUT_QUEUE;
+#endif
+
+//blue
+typedef	struct	_DATA_BULKOUT_QUEUE	{
+	UINT		size;
+	struct sk_buff 	*head;
+	struct sk_buff	*tail;
+}	DATA_BULKOUT_QUEUE, *PDATA_BULKOUT_QUEUE;
+
+typedef	struct	_MLME_BULKOUT_QUEUE	{
+	UINT		size;
+	PMGMT_STRUC	head;
+	PMGMT_STRUC	tail;
+}	MLME_BULKOUT_QUEUE, *PMLME_BULKOUT_QUEUE;
+
+#if 0
+typedef enum bufferStates {
+    FREE,
+    USED,
+	COMPLETED,
+    PENDING
+} BufferState;
+#endif
+
+// used to track driver-generated write irps 
+typedef struct _TX_CONTEXT
+{
+
+	PVOID				pAdapter;//Initialized in MiniportInitialize
+	//    struct sk_buff *skb;
+	PURB				pUrb;//Initialized in MiniportInitialize
+	PIRP	            pIrp;//used to cancel pending bulk out.//Initialized in MiniportInitialize
+	PTX_BUFFER          TransferBuffer;//Initialized in MiniportInitialize
+	ULONG			BulkOutSize;
+	BOOLEAN				InUse;
+	BOOLEAN				IRPPending;
+	BOOLEAN				LastOne;
+}
+TX_CONTEXT, *PTX_CONTEXT, **PPTX_CONTEXT;
+
+// used to track driver-generated write irps 
+typedef struct _MLME_CONTEXT
+{
+    PVOID				pAdapter;//Initialized in MiniportInitialize
+    PMGMT_STRUC			pMgmt;
+    PURB				pUrb;//Initialized in MiniportInitialize
+    PIRP	            pIrp;//used to cancel pending bulk out.//Initialized in MiniportInitialize
+    PTX_BUFFER          TransferBuffer;//Initialized in MiniportInitialize
+//    UINT	            TransferBufferLength;//TransferBufferLength
+//    CONTEXT_TYPE    Type;
+//    BufferState	            fInUse; // Declared as ULONG so can use with InterlockedExchange()
+	BOOLEAN				InUse;
+	BOOLEAN				IRPPending;
+	BOOLEAN				LastOne;
+	UCHAR				Index;
+}
+MLME_CONTEXT, *PMLME_CONTEXT, **PPMLME_CONTEXT;
+
+
+typedef struct _NULL_CONTEXT
+{
+    PVOID				pAdapter;//Initialized in MiniportInitialize
+    PURB				pUrb;//Initialized in MiniportInitialize
+    PIRP	            pIrp;//used to cancel pending bulk out.
+    PNULL_FRAME_BUFFER          TransferBuffer;//Initialized in MiniportInitialize
+//    UINT	            TransferBufferLength;//TransferBufferLength
+//    BufferState	            fInUse; // Declared as ULONG so can use with InterlockedExchange()
+	BOOLEAN				InUse;
+	BOOLEAN				IRPPending;
+}
+NULL_CONTEXT, *PNULL_CONTEXT;
+
+
+typedef struct _WPAPSK_CONTEXT
+{
+    PVOID				pAdapter;//Initialized in MiniportInitialize
+    PURB				pUrb;//Initialized in MiniportInitialize
+    PIRP	            pIrp;//used to cancel pending bulk out.
+    PWPAPSK_BUFFER          TransferBuffer;//Initialized in MiniportInitialize
+//    UINT	            TransferBufferLength;//TransferBufferLength
+//    BufferState	            fInUse; // Declared as ULONG so can use with InterlockedExchange()
+	BOOLEAN				InUse;
+	BOOLEAN				Ready;
+	BOOLEAN				IRPPending;
+}
+WPAPSK_CONTEXT, *PWPAPSK_CONTEXT;
+
+typedef struct _PS_POLL_CONTEXT
+{
+    PVOID				pAdapter;//Initialized in MiniportInitialize
+    PURB				pUrb;//Initialized in MiniportInitialize
+    PIRP	            pIrp;//used to cancel pending bulk out.
+    PPS_POLL_BUFFER          TransferBuffer;//Initialized in MiniportInitialize
+//    UINT	            TransferBufferLength;//TransferBufferLength
+//    BufferState	            fInUse; // Declared as ULONG so can use with InterlockedExchange()
+	BOOLEAN				InUse;
+	BOOLEAN				Ready;
+	BOOLEAN				IRPPending;
+}
+PS_POLL_CONTEXT, *PPS_POLL_CONTEXT;
+
+typedef struct _STUFF_CONTEXT
+{
+    PVOID				pAdapter;//Initialized in MiniportInitialize
+    PURB				pUrb;//Initialized in MiniportInitialize
+    PIRP	            pIrp;//used to cancel pending bulk out.
+    PSTUFF_BUFFER          TransferBuffer;//Initialized in MiniportInitialize
+//    UINT	            TransferBufferLength;//TransferBufferLength
+//    BufferState	            fInUse; // Declared as ULONG so can use with InterlockedExchange()
+	BOOLEAN				InUse;
+	BOOLEAN				Ready;
+	BOOLEAN				IRPPending;
+}
+STUFF_CONTEXT, *PSTUFF_CONTEXT;
+
+//
+// Structure to keep track of receive packets and buffers to indicate
+// receive data to the protocol.
+//
+#define   IRPLOCK_COMPLETED     0
+#define   IRPLOCK_CANCELABLE    1
+#define   IRPLOCK_CANCE_START   2
+#define   IRPLOCK_CANCE_COMPLETE    3
+
+typedef struct _RX_CONTEXT
+{
+	PVOID				pAdapter;
+	PIRP					pIrp; //used to cancel pending bulk in.
+	PURB				pUrb;
+	BOOLEAN				InUse;
+	atomic_t				IrpLock;
+	PUCHAR				TransferBuffer; 
+}
+RX_CONTEXT, *PRX_CONTEXT;
+#if 0
+// NDIS
+typedef struct _RX_CONTEXT
+{
+    PUCHAR				TransferBuffer; 
+    PVOID				pAdapter;
+    PIRP				pIrp;//used to cancel pending bulk in.
+    PURB				pUrb;
+	BOOLEAN				InUse;
+	IRPLOCK				IrpLock;
+}	RX_CONTEXT, *PRX_CONTEXT;
+#endif
+typedef struct _VENDOR_REQUEST_URB
+{
+    PURB				pUrb;
+//    BOOLEAN	            InUse;
+    PIRP				pIrp;//used to cancel pending IRP
+	BOOLEAN				IRPPending;
+}
+VENDOR_REQUEST_URB;
+
+
+typedef struct _TX_RATE_SWITCHING_STRUC
+{
+	ULONG			LastStableTime;
+	UCHAR			DownRate1Ratio;
+	UCHAR			DownRate2Ratio;
+	UCHAR			UpRateRatio;
+	UCHAR			StableTimeRequired;
+	UCHAR			PenaltyPeriod;
+	UCHAR			DownWaitingTime;
+}
+TX_RATE_SWITCHING_STRUC, *PTX_RATE_SWITCHING_STRUC;
+
+typedef struct _TX_RATE_SWITCHING_COUNTERS
+{
+	USHORT			NoRetryOKCnt;
+	USHORT			OneRetryOKCnt;
+	USHORT			MRetryOKCnt;
+	USHORT			FailCnt;
+}
+TX_RATE_SWITCHING_COUNTERS, *PTX_RATE_SWITCHING_COUNTERS;
+
+typedef struct _BBP_TUNING_PARAMETERS_STRUC
+{
+	UCHAR			BBPTuningThreshold;
+	UCHAR			R24LowerValue;
+	UCHAR			R24HigherValue;
+	UCHAR			R25LowerValue;
+	UCHAR			R25HigherValue;
+	UCHAR			R61LowerValue;
+	UCHAR			R61HigherValue;
+	UCHAR			BBPR17LowSensitivity;
+	UCHAR			BBPR17MidSensitivity;
+	UCHAR			RSSIToDbmOffset;
+	BOOLEAN			LargeCurrentRSSI;
+}
+BBP_TUNING_PARAMETERS_STRUC, *PBBP_TUNING_PARAMETERS_STRUC;
+
+#define	IEEE80211_NWID_LEN			32
+
+
+#define UNLINK_TIMEOUT_MS		3
+//
+//  The miniport adapter structure
+//
+typedef struct _RT2570_ADAPTER
+{
+	int			nicknamelen;
+	char nickn[IEEE80211_NWID_LEN+1]; // nickname, only used in the iwconfig i/f 
+	struct tasklet_struct	rx_bh;		
+	struct usb_device *usb;
+	//KERNEL266
+	struct usb_config_descriptor *config;
+	//struct usb_host_config *config;
+	devctrlrequest *devreq;
+	/* The device we're working with
+	 * It's important to note:
+	 *    (o) you must hold dev_semaphore to change pusb_dev
+	 */
+	struct semaphore	usbdev_semaphore;	 /* protect  usb */
+	// Thread
+	struct semaphore	mlme_semaphore;	 /* to sleep thread on   */
+	struct semaphore	RTUSBCmd_semaphore;	 /* to sleep thread on   */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+		struct completion	notify;		/* thread begin/end */
+		pid_t			MLMEThr_pid;
+		pid_t			RTUSBCmdThr_pid;
+#else
+	struct task_struct *	MLMEThr;
+	volatile int MLMEThr_active;
+	struct task_struct *	RTUSBCmdThr;
+	volatile int RTUSBCmdThr_active;
+#endif
+	wait_queue_head_t	*wait;
+	
+	spinlock_t *lock;
+#if 1
+	UINT					SET_R17_FLAG;
+	UCHAR					BBPR17InitValue;
+	UCHAR					ResetRequest;
+	UCHAR					BulkAction;
+#endif
+
+	struct net_device *net;
+	BOOLEAN                 bNetDeviceStopQueue;
+
+#if WIRELESS_EXT >= 12
+    struct iw_statistics iw_stats;
+#endif
+	
+	struct net_device_stats netstats;
+
+	// configuration
+	UCHAR                   PermanentAddress[ETH_LENGTH_OF_ADDRESS];    // Factory default MAC address
+	UCHAR                   CurrentAddress[ETH_LENGTH_OF_ADDRESS];      // User changed MAC address
+
+	USHORT			EEPROMDefaultValue[NUM_EEPROM_BBP_PARMS];
+	USHORT			EEPROMBBPTuningParameters[NUM_EEPROM_BBP_TUNING_PARMS];
+
+    //
+    // Handle given by NDIS when the Adapter registered itself.
+    // Various NDIS handle function
+    //
+
+	MGMT_STRUC				MgmtRing[MGMT_RING_SIZE];	// management ring size
+	
+	UCHAR					NextTxIndex;					// Next TxD write pointer
+	UCHAR					NextMLMEIndex;				// Next PrioD write pointer
+	UCHAR					PushMgmtIndex;				// Next SW management ring index
+	UCHAR					PopMgmtIndex;				// Next SW management ring index
+	atomic_t					MgmtQueueSize;				// Number of Mgmt request stored in MgmtRing
+	UCHAR					NextRxBulkInIndex;
+	UCHAR					NextBulkOutIndex;
+	BOOLEAN					BulkOutPending;
+	BOOLEAN					ControlPending;
+	ULONG					PrioRingTxCnt;
+	UCHAR					PrioRingFirstIndex;
+
+ 	// 802.3 multicast support
+	ULONG					NumberOfMcAddresses;		// Number of mcast entry exists
+	UCHAR					McastTable[MAX_MCAST_LIST_SIZE][ETH_LENGTH_OF_ADDRESS];		// Mcast list
+	ULONG                   Flags;                      // Represent current device status
+
+	// Flags for bulk out data priority
+	ULONG					BulkFlags;
+	/////////////////////
+	// Transmit Path
+	/////////////////////
+	atomic_t								TxCount;		// Number of Bulkout waiting to be send.
+	TX_CONTEXT							TxContext[TX_RING_SIZE];
+	TX_CONTEXT							MLMEContext[PRIO_RING_SIZE];
+	TX_CONTEXT							BeaconContext[BEACON_RING_SIZE];
+	TX_CONTEXT							NullContext;
+	TX_CONTEXT							PsPollContext;
+	RTS_BUFFER							RTSBuffer;
+
+	WPAPSK_CONTEXT					       WpaPskContext;
+	PUCHAR								TxBuffer;
+	TX_BUFFER                           TxMgmtBuf;
+
+	/////////////////////
+	// Receive Path
+	/////////////////////
+	RX_CONTEXT							RxContext[RX_RING_SIZE];
+	PURB                                pRxUrb;//red: test mode only
+	PIRP                                pRxIrp;
+	PUCHAR								RxBuffer;
+    // SEND queue list
+	struct sk_buff_head            SendTxWaitQueue;
+
+	USHORT					Sequence;					// Current sequence number
+
+	TUPLE_CACHE				TupleCache[MAX_CLIENT];		// Maximum number of tuple caches, only useful in Ad-Hoc
+	UCHAR                   TupleCacheLastUpdateIndex;  // 0..MAX_CLIENT-1
+	FRAGMENT_FRAME			FragFrame;					// Frame storage for fragment frame
+	
+	// For MiniportTransferData
+	PUCHAR					pRxData;					// Pointer to current RxRing offset / fragment frame offset
+	
+	// Counters for 802.3 & generic.
+	// Add 802.11 specific counters later
+	COUNTER_802_3           Counters;                   // 802.3 counters
+	COUNTER_802_11          WlanCounters;				// 802.11 MIB counters
+	COUNTER_RALINK          RalinkCounters;				// Ralink propriety counters
+	COUNTER_DRS             DrsCounters;                // counters for Dynamic Rate Switching
+	COUNTER_QA				QACounters;				// Ralink propriety counters
+
+	NDIS_MEDIA_STATE        MediaState;
+	UCHAR                               StationState;
+
+	NDIS_DEVICE_POWER_STATE CurrentPowerState;          // Current device power state
+	NDIS_DEVICE_POWER_STATE NextPowerState;             // Next device power state
+
+	PRIVATE_STRUC			PrivateInfo;				// Private information & counters
+
+	// SpinLocks
+	spinlock_t			SendTxWaitQueueLock;		// SendTxWaitQueue spinlock
+	spinlock_t			MLMEWaitQueueLock;		// SendTxWaitQueue spinlock
+	spinlock_t			CmdQLock;		// SendTxWaitQueue spinlock
+	spinlock_t			BulkOutLock;		// SendTxWaitQueue spinlock
+	spinlock_t			ControlLock;		// SendTxWaitQueue spinlock
+	spinlock_t			MLMEQLock;		// SendTxWaitQueue spinlock
+	spinlock_t			GenericLock;		// SendTxWaitQueue spinlock
+	spinlock_t                  MemLock;            // need to check
+
+	// Reference count
+	LONG                    RefCount;           // Keep adapter refer count for checkforhang & halt
+	ULONG                   SendRefCount;       // number of packet that have not been confirmed
+	ULONG                   RcvRefCount;        // number of packets that have not been returned back
+
+	// Various NDIS Event
+	int              ExitEvent;
+	
+
+	NDIS_MEDIA_STATE                    LinkIsActive;
+	ULONG                               CurrentLookAhead;
+	CmdQ								CmdQ;
+	DATA_BULKOUT_QUEUE								DataQ;
+	MLME_BULKOUT_QUEUE								MLMEQ;
+
+	// Boolean control for packet filter
+	BOOLEAN					bAcceptDirect;
+	BOOLEAN					bAcceptMulticast;
+	BOOLEAN					bAcceptBroadcast;
+	BOOLEAN					bAcceptAllMulticast;
+
+	// Control to check Tx hang
+	BOOLEAN					bTxBusy;
+	
+	// Control disconnect / connect event generation
+	ULONG					LinkDownTime;
+	UCHAR					LastSsidLen;               // the actual ssid length in used
+	CHAR					LastSsid[MAX_LEN_OF_SSID]; // NOT NULL-terminated
+	MACADDR					LastBssid;
+	BOOLEAN					bConfigChanged;				// Config Change flag for the same SSID setting
+	
+	PORT_CONFIG             PortCfg;
+	MLME_STRUCT             Mlme;
+	/////////////////////
+	// USB
+	/////////////////////
+	USHORT                              BulkOutMaxPacketSize;   // 64 in XP
+	USHORT                              BulkInMaxPacketSize;
+
+	/////////////////////
+	//  Control Flags
+	/////////////////////
+	LONG                                PendingTx;
+	atomic_t                                PendingRx;
+	LONG                                PendingReset;
+	LONG                                BulkOutFailed;
+	LONG                                BulkInFailed;
+	LONG                                DeviceFailed;
+	UCHAR                               DeviceMode;
+	BOOLEAN                             UnplugDevice;
+	atomic_t                                TerminateThreads;
+	atomic_t                                PendingIoCount;
+	BOOLEAN                             BSSSelected;
+	BOOLEAN                             StationWasAssociated;
+	BOOLEAN                             StationIsAssociated;
+	BOOLEAN                             StationIsAuthenticated;
+	UCHAR                               WepLevel;
+	BOOLEAN                             OutOfRangeDetected;
+	BOOLEAN                             AddressOverrided;
+	BOOLEAN                             AutoAuthentication;
+	BOOLEAN                             AutoPreamble;
+	BOOLEAN                             AutoJoin;
+	BOOLEAN                             UseInternalFWImage;
+	BOOLEAN                             AnyAP;
+	
+	PVOID								pInformationBuffer;
+	ULONG								InformationBufferLength;
+	PULONG								pBytesWritten;
+	PULONG								pBytesNeeded;
+	BOOLEAN								SendDelimitingPacket;
+	ULONG								DelimitingPacketSent;
+	UINT								FragmentsSent;
+	USHORT								BulkOutLength;
+	USHORT								BulkOutRemained;
+	BOOLEAN								ContinBulkOut;
+	USHORT								BulkInRemained;
+	BOOLEAN								ContinBulkIn;
+	BOOLEAN								BeaconIntervalChangeAllowed;
+	USHORT								SentBeaconsCount;
+	USHORT								ReceivedBeaconsCount;
+	LARGE_INTEGER						TransmittedFragmentCount;
+#ifdef TEST_MODE_SUPPORT
+	CmdQElmt							CmdQElements[12];
+#else
+	CmdQElmt							CmdQElements[COMMAND_QUEUE_SIZE];
+#endif
+
+	USHORT								MACCounters[11];
+	TX_RATE_SWITCHING_STRUC			TxRateSwitchingStruc[12];
+	ULONG			CurrRateGoodTime;
+	UCHAR			CurrRateBadTime;
+	UCHAR			TxQuality;
+	BBP_TUNING_PARAMETERS_STRUC			BBPTuningParameters;
+	ULONG					LastRxRate;
+	ULONG					PacketsSentBetweenTBTTs;
+	BOOLEAN					ScanAllowed;
+	// Alpha can't link up problem
+	ULONG					ExtraInfo;				// Extra information for displaying status
+	struct net_device_stats	net_device_stats;	/* interface statistics */
+	
+}   RT2570ADAPTER, *PRT2570ADAPTER;
+
+
+
+#endif
+
+
+
+
+
+
+////////////////////////////////////////////////////////////////////////////
+//
+//  inline FUNCTIONS
+//
+//   IncrementIoCount and DecrementIoCount
+//
+//  DESCRIPTION
+//
+//   We keep a pending IO count. This count is initialized to one.
+//   Subsequently, the count is incremented for each new IRP received or
+//   created and is decremented when each IRP is completed.
+//   Transition to 'one' therefore indicates no IO is pending and signals
+//   Adapter->RemoveEvent. Transition to 'zero' signals an event
+//   (Adapter->RemoveEvent) to enable device removal.
+//
+//  INPUT
+//
+//    Adapter                       Ptr to the adapter object
+//
+//  OUTPUT
+//
+//    -
+//
+////////////////////////////////////////////////////////////////////////////
+inline VOID IncrementIoCount(PRT2570ADAPTER Adapter);
+inline VOID DecrementIoCount(IN PRT2570ADAPTER pAdapter);
+
+
+
+////////////////////////////////////////////////////////////////////////////
+// __inline VOID EnQTxPacket(PRT2570ADAPTER Adapter, PNDIS_PACKET Packet)
+// {
+//     PTX_QUEUE tempTxQnode;
+//
+//
+//     if (AllocateMemory(&tempTxQnode, sizeof(TX_QUEUE))!=NDIS_STATUS_SUCCESS)
+//     {
+//         NdisMSendComplete(Adapter->AdapterHandle, Packet, NDIS_STATUS_SUCCESS);
+//         return;
+//     }
+//
+//     tempTxQnode->pNdisPacket = Packet;
+//     tempTxQnode->next = NULL;
+//
+//     if (Adapter->TxQHead==NULL)
+//     {
+//         Adapter->TxQHead = tempTxQnode;
+//     }
+//
+//     if (Adapter->TxQTail!=NULL)
+//     {
+//         Adapter->TxQTail->next = tempTxQnode;
+//     }
+//
+//     Adapter->TxQTail = tempTxQnode;
+// }
+
+
+
+////////////////////////////////////////////////////////////////////////////
+// __inline VOID DeQTxPacket(PRT2570ADAPTER Adapter)
+// {
+//     PTX_QUEUE tempTxQnode;
+//
+//     tempTxQnode = Adapter->TxQHead;
+//     Adapter->TxQHead = tempTxQnode->next;
+//
+//     if (Adapter->TxQHead==NULL)
+//     {
+//         Adapter->TxQTail=NULL;
+//     }
+//
+//     FreeMemory(tempTxQnode, sizeof(TX_QUEUE));
+// }
+
+
+
+#define DEVICE_VENDOR_REQUEST_OUT       (USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE) // 0x40
+#define DEVICE_VENDOR_REQUEST_IN        (USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE )  //0xc0
+#define INTERFACE_VENDOR_REQUEST_OUT    0x41
+#define INTERFACE_VENDOR_REQUEST_IN     0xc1
+#define	PL_RESET_IN	(1<<3)		/* reset input pipe */
+
+////////////////////////////////////////////////////////////////////////////
+// Misc definitions
+////////////////////////////////////////////////////////////////////////////
+#define OS_IS_WIN_2000              0   
+#define OS_IS_WIN_ME                1
+#define OS_IS_WIN_98                2
+#define OS_IS_WIN_XP                3
+
+
+////////////////////////////////////////////////////////////////////////////
+// Station States definitions
+////////////////////////////////////////////////////////////////////////////
+#define STATION_STATE_INITIALIZING          0x00
+#define STATION_STATE_SCANNING              0x01
+#define STATION_STATE_JOINNING              0x02
+#define STATION_STATE_AUTHENTICATING        0x03
+#define STATION_STATE_ASSOCIATING           0x04
+#define STATION_STATE_READY                 0x05
+#define STATION_STATE_OUT_OF_RANGE          0x06
+#define STATION_STATE_DISASSOCIATING        0x07
+#define STATION_STATE_DIAUTHENTICATING      0x08
+#define STATION_STATE_REASSOCIATING         0x09
+#define STATION_STATE_FORCED_JOINNING       0x0a
+#define STATION_STATE_RECONFIGURING         0x0b
+#define STATION_STATE_FW_UPGRADE            0x0c
+#define STATION_STATE_FORCED_JOIN_FAILURE   0x0d 
+#define STATION_STATE_RESETTING             0x0e 
+#define STATION_STATE_RESET_PENDING         0x0f 
+#define STATION_STATE_NOT_NET_MODE          0x10
+#define STATION_STATE_WAIT_ACTION           0x11 //under XP we need this state to allow XP to take control
+#define STATION_STATE_REJECTING_PACKETS     0x99 
+#define STATION_STATE_NO_CARD               0xf0 
+#define STATION_STATE_MGMT_ERROR            0xf1 
+#define STATION_STATE_GENERAL_ERROR         0xf2 
+#define STATION_STATE_POWER_DOWN            0xff
+
+
+////////////////////////////////////////////////////////////////////////////
+// SCAN Type Definitions
+////////////////////////////////////////////////////////////////////////////
+#define SCAN_TYPE_ACTIVE                    0
+#define SCAN_TYPE_PASSIVE                   1
+
+
+////////////////////////////////////////////////////////////////////////////
+// Operating Modes definitions
+////////////////////////////////////////////////////////////////////////////
+#define BSS_TYPE_AD_HOC                     1
+#define BSS_TYPE_INFRASTRUCTURE             2
+
+//
+//  Miniport routines in rtmp_main.c
+//
+
+
+VOID	RTUSBHalt(	IN	PRT2570ADAPTER	pAdapter, BOOLEAN IsFree);
+
+
+//
+//  Private routines in rtmp_init.c
+//
+
+PUCHAR  RTMPFindSection(
+    IN  PCHAR   buffer,
+    IN  PCHAR   section);
+
+INT RTMPIsFindSection(
+    IN  PUCHAR  ptr,
+    IN  PUCHAR  buffer);
+
+
+INT RTMPGetKeyParameter(
+    IN  PUCHAR  section,
+    IN  PCHAR   key,
+    OUT PCHAR   dest,   
+    IN  INT     destsize,
+    IN  PCHAR   buffer);
+VOID RTMPReadParametersFromFile(
+	IN	PRT2570ADAPTER pAdapter);
+
+
+
+VOID	NICReadEEPROMParameters(
+    IN  PRT2570ADAPTER       pAdapter);
+
+VOID	NICInitAsicFromEEPROM(
+	IN  PRT2570ADAPTER       pAdapter);
+
+
+NDIS_STATUS NICInitRecv(
+    IN  PRT2570ADAPTER   pAdapter);
+
+#if 0
+NDIS_STATUS	NICReadAdapterInfo(
+	IN	PRT2570ADAPTER		pAdapter);
+
+
+VOID	NICInitializeAdapter(
+    IN  PRT2570ADAPTER   pAdapter);
+#endif//blue
+
+VOID	RT2570InitializeAsic(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID	NICIssueReset(
+	IN	PRT2570ADAPTER	pAdapter);
+
+#if 0
+VOID	RTMPRingCleanUp(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	UCHAR			RingType);
+#endif
+
+VOID	RxTest(
+	IN	PRT2570ADAPTER	pAdapter);
+
+//
+#if 0
+NDIS_STATUS	DbgSendPacket(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PNDIS_PACKET	pPacket);
+#endif
+
+VOID	PortCfgInit(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID	NICResetFromError(
+	IN	PRT2570ADAPTER	pAdapter);
+
+BOOLEAN	NICCheckForHang(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID CreateThreads( struct net_device *net_dev);
+
+#if 0
+NDIS_STATUS	RT2570ReadHWMACAddress(
+	IN	PRT2570ADAPTER		pAdapter);
+#endif
+NDIS_STATUS	RTUSBWriteHWMACAddress(
+	IN	PRT2570ADAPTER		pAdapter);
+
+void AtoH(char * src, UCHAR * dest, int destlen);
+UCHAR BtoH(char ch);
+
+VOID	RTMPInitTimer(
+	IN	PRT2570ADAPTER			pAdapter,
+	IN	PRALINK_TIMER_STRUCT	pTimer,
+	IN	PVOID					pTimerFunc);
+
+VOID	RTMPSetTimer(
+	IN	PRT2570ADAPTER			pAdapter,	
+	IN	PRALINK_TIMER_STRUCT	pTimer,
+	IN	ULONG					Value);
+
+VOID	RTMPCancelTimer(
+	IN	PRALINK_TIMER_STRUCT	pTimer);
+
+
+//
+// Private routines in rtmp_data.c
+//
+#if 0
+VOID	RTMPHandleRxDoneInterrupt(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID	RTMPHandleTxRingTxDoneInterrupt(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID	RTMPHandlePrioRingTxDoneInterrupt(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID	RTMPHandleAtimRingTxDoneInterrupt(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID	RTMPHandleTbcnInterrupt(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID	RTMPHandleTwakeupInterrupt(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID	RTMPHardTransmitDone(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PTXD_STRUC		pTxD,
+	IN	UCHAR			FrameType);
+
+NDIS_STATUS	RTMPSendPacket(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PNDIS_PACKET	pPacket);
+	
+VOID	RTMPDeQueuePacket(
+    IN	PRT2570ADAPTER	pAdapter,
+    IN	PQUEUE_HEADER	pQueue);
+
+NDIS_STATUS	RTMPHardTransmit(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PNDIS_PACKET	pPacket,
+	IN	UCHAR			NumberRequired);
+
+NDIS_STATUS	RTMPFreeDescriptorRequest(
+	IN		PRT2570ADAPTER	pAdapter,
+	IN		UCHAR			RingType,
+	IN		UCHAR			NumberRequired);
+#endif//red
+
+
+VOID	MlmeHardTransmit(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PMGMT_STRUC		pMgmt);
+
+VOID
+BulkOutMLMEPacket
+(
+ PRT2570ADAPTER	pAdapter,
+ UCHAR	Index);
+
+
+void BulkOutMLMEPacketComplete(purbb_t purb,struct pt_regs *pt_regs);
+
+USHORT	RTMPCalcDuration(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	UCHAR			Rate,
+	IN	ULONG			Size);
+
+
+VOID	RTMPWriteBeaconDescriptor(
+	IN	PTXD_STRUC	pTxD,
+	IN	UINT		Length,
+	IN	UINT		PLCPLength,
+	IN	UINT		Rate,
+	IN	UCHAR		Service,
+	IN  USHORT      TxPreamble);
+
+
+VOID    RTUSBSuspendMsduTransmission(
+   	IN	PRT2570ADAPTER	pAdapter);
+
+VOID    RTUSBResumeMsduTransmission(
+   	IN	PRT2570ADAPTER	pAdapter);
+
+VOID
+DequeueMLMEPacket(
+	IN	PRT2570ADAPTER	pAdapter);
+
+
+VOID
+MiniportMMRequest(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PVOID			pBuffer,
+	IN	ULONG			Length);
+
+BOOLEAN	RTMPSearchTupleCache(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PHEADER_802_11	pHeader);
+
+VOID	RTMPUpdateTupleCache(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PHEADER_802_11	pHeader);
+
+NDIS_STATUS	RTMPApplyPacketFilter(
+	IN	PRT2570ADAPTER	pAdapter, 
+	IN	PRXD_STRUC		pRxD, 
+	IN	PHEADER_802_11	pHeader);
+
+NDIS_STATUS	RTMPCheckRxDescriptor(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PRXD_STRUC	pRxD);
+
+VOID	RTMPReportMicError(
+	IN	PRT2570ADAPTER	pAdapter, 
+	IN	PWPA_KEY		pWpaKey);
+
+VOID	RTUSBMlmeHardTransmit(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PMGMT_STRUC		pMgmt);
+
+
+//
+// Private routines in rtmp_wep.c
+//
+VOID	RTMPInitWepEngine(
+	IN	PRT2570ADAPTER	pAdapter,	
+	IN	PUCHAR			pKey,
+	IN	UCHAR			KeyId,
+	IN	UCHAR			KeyLen, 
+	IN	PUCHAR			pDest);
+
+VOID	RTMPEncryptData(
+	IN	PRT2570ADAPTER	pAdapter,	
+	IN	PUCHAR			pSrc,
+	IN	PUCHAR			pDest,
+	IN	UINT			Len);
+
+BOOLEAN	RTMPDecryptData(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PUCHAR	pSrc,
+	IN	UINT	Len);
+
+VOID	RTMPSetICV(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PUCHAR			pDest);
+
+VOID	ARCFOUR_INIT(
+	IN	PARCFOURCONTEXT	Ctx,
+	IN	PUCHAR			pKey,
+	IN	UINT			KeyLen);
+
+UCHAR	ARCFOUR_BYTE(
+	IN	PARCFOURCONTEXT		Ctx);
+
+VOID	ARCFOUR_DECRYPT(
+	IN	PARCFOURCONTEXT	Ctx,
+	IN	PUCHAR			pDest, 
+	IN	PUCHAR			pSrc,
+	IN	UINT			Len);
+
+VOID	ARCFOUR_ENCRYPT(
+	IN	PARCFOURCONTEXT	Ctx,
+	IN	PUCHAR			pDest,
+	IN	PUCHAR			pSrc,
+	IN	UINT			Len);
+
+ULONG	RTMP_CALC_FCS32(
+	IN	ULONG	Fcs,
+	IN	PUCHAR	Cp,
+	IN	INT		Len);
+
+//
+// MLME routines
+//
+//VOID    Arc4Init(ARC4_CONTEXT *Ctx, UCHAR *Key, ULONG KeyLen);
+//UCHAR   Arc4Byte(ARC4_CONTEXT *Ctx);
+//VOID    Arc4Cipher(ARC4_CONTEXT *Ctx, UCHAR *Dest, UCHAR *Src, ULONG Len);
+
+// Asic/RF/BBP related functions
+
+VOID AsicAdjustTxPower(
+    IN PRT2570ADAPTER pAd);
+    
+VOID    AsicSwitchChannel(
+    IN	PRT2570ADAPTER	pAdapter, 
+    UCHAR Channel);
+
+VOID    AsicLockChannel(
+    IN PRT2570ADAPTER pAd, 
+    IN ULONG Channel) ;
+
+#if 0
+VOID AsicRfTuningExec(
+    IN PVOID SystemSpecific1, 
+    IN PVOID FunctionContext, 
+    IN PVOID SystemSpecific2, 
+    IN PVOID SystemSpecific3);
+#endif
+
+#ifdef RALINK_ATE
+VOID    AsicSwitchChannel_ATE(
+    IN	PRT2570ADAPTER	pAdapter, 
+    ULONG Channel);
+#endif
+
+VOID    AsicSleepThenAutoWakeup(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  USHORT TbttNumToNextWakeUp);
+
+VOID    AsicForceSleep(
+    IN PRT2570ADAPTER pAdapter);
+
+VOID    AsicForceWakeup(
+    IN PRT2570ADAPTER pAdapter);
+
+VOID    AsicSetBssid(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MACADDR *Bssid);
+
+VOID    AsicDisableSync(
+    IN	PRT2570ADAPTER	pAdapter);
+
+VOID    AsicEnableBssSync(
+    IN	PRT2570ADAPTER	pAdapter);
+
+VOID    AsicEnableIbssSync(
+    IN	PRT2570ADAPTER	pAdapter);
+
+VOID    AsicLedPeriodicExec(
+    IN unsigned long data);
+
+VOID AsicSetSlotTime(
+    IN PRT2570ADAPTER pAd,
+    IN BOOLEAN UseShortSlotTime);
+
+//blue
+VOID AsicBbpTuning(
+    IN PRT2570ADAPTER pAd);
+
+VOID AsicRestoreBbpSensibility(
+    IN PRT2570ADAPTER pAd);
+
+
+VOID    MacAddrRandomBssid(
+    IN	PRT2570ADAPTER	pAdapter, 
+    OUT PMACADDR Addr);
+
+VOID    MgtMacHeaderInit(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN OUT PMACHDR Hdr, 
+    IN UCHAR Subtype, 
+    IN UCHAR ToDs, 
+//  IN UCHAR AddrType, 
+    IN PMACADDR Ds, 
+    IN PMACADDR Bssid);
+
+VOID MlmeRadioOff(
+    IN PRT2570ADAPTER pAd);
+
+VOID MlmeRadioOn(
+    IN PRT2570ADAPTER pAd);
+
+VOID  BssTableInit(
+    IN BSS_TABLE *Tab);
+
+ULONG BssTableSearch(
+    IN BSS_TABLE *Tab, 
+    IN PMACADDR Bssid);
+
+VOID BssTableDeleteEntry(
+    IN OUT	BSS_TABLE *Tab, 
+    IN		PMACADDR Bssid);
+
+VOID  BssEntrySet(
+    IN	PRT2570ADAPTER	pAdapter, 
+    OUT BSS_ENTRY *Bss, 
+    IN MACADDR *Bssid, 
+    IN CHAR Ssid[], 
+    IN UCHAR SsidLen, 
+    IN UCHAR BssType, 
+    IN USHORT BeaconPeriod,
+    IN BOOLEAN CfExist, 
+    IN CF_PARM *CfParm, 
+    IN USHORT AtimWin, 
+    IN USHORT CapabilityInfo, 
+    IN UCHAR Rates[], 
+    IN UCHAR RatesLen,
+    IN BOOLEAN ExtendedRateIeExist,
+    IN UCHAR Channel,
+    IN UCHAR Rssi,
+    IN LARGE_INTEGER TimeStamp,
+    IN UCHAR LengthVIE,
+    IN PNDIS_802_11_VARIABLE_IEs pVIE);
+
+ULONG  BssTableSetEntry(
+    IN	PRT2570ADAPTER	pAdapter, 
+    OUT BSS_TABLE *Tab, 
+    IN MACADDR *Bssid, 
+    IN CHAR Ssid[], 
+    IN UCHAR SsidLen, 
+    IN UCHAR BssType, 
+    IN USHORT BeaconPeriod, 
+    IN BOOLEAN CfExist, 
+    IN CF_PARM *CfParm, 
+    IN USHORT AtimWin, 
+    IN USHORT CapabilityInfo, 
+    IN UCHAR Rates[], 
+    IN UCHAR RatesLen,
+    IN BOOLEAN ExtendedRateIeExist,
+    IN UCHAR Channel,
+    IN UCHAR Rssi,
+    IN LARGE_INTEGER TimeStamp,
+    IN UCHAR LengthVIE,
+    IN PNDIS_802_11_VARIABLE_IEs pVIE);
+
+VOID  BssTableSsidSort(
+    IN	PRT2570ADAPTER	pAd, 
+    OUT BSS_TABLE *OutTab, 
+    IN  CHAR Ssid[], 
+    IN  UCHAR SsidLen);
+
+VOID  BssTableSortByRssi(
+    IN OUT BSS_TABLE *OutTab);
+
+VOID	BssCipherParse(
+	IN OUT	PBSS_ENTRY	pBss);
+
+NDIS_STATUS  MlmeQueueInit(
+    IN MLME_QUEUE *Queue);
+
+VOID  MlmeQueueDestroy(
+    IN MLME_QUEUE *Queue);
+
+BOOLEAN MlmeEnqueue(
+    IN PRT2570ADAPTER pAd, 
+	IN ULONG Machine, 
+    IN ULONG MsgType, 
+    IN ULONG MsgLen, 
+    IN VOID *Msg);
+
+BOOLEAN MlmeEnqueueForRecv(
+    IN	PRT2570ADAPTER	pAdapter, 
+    OUT MLME_QUEUE *Queue, 
+    IN UCHAR Rssi, 
+    IN ULONG MsgLen, 
+    IN PVOID Msg);
+
+BOOLEAN MlmeDequeue(
+    IN MLME_QUEUE *Queue, 
+    OUT MLME_QUEUE_ELEM **Elem);
+
+#if 1
+VOID	MlmeRestartStateMachine(
+    IN	PRT2570ADAPTER	pAd);
+#endif
+
+//blue
+VOID	MlmePostRestartStateMachine(
+    IN	PRT2570ADAPTER	pAd);
+
+BOOLEAN  MlmeQueueEmpty(
+    IN MLME_QUEUE *Queue);
+
+BOOLEAN  MlmeQueueFull(
+    IN MLME_QUEUE *Queue);
+
+BOOLEAN  MsgTypeSubst(
+	IN PRT2570ADAPTER pAd,
+    IN MACFRAME *Fr, 
+    OUT INT *Machine, 
+    OUT INT *MsgType);
+
+VOID StateMachineInit(
+    IN STATE_MACHINE *Sm, 
+    IN STATE_MACHINE_FUNC Trans[], 
+    IN ULONG StNr, 
+    IN ULONG MsgNr, 
+    IN STATE_MACHINE_FUNC DefFunc, 
+    IN ULONG InitState, 
+    IN ULONG Base);
+
+VOID StateMachineSetAction(
+    IN STATE_MACHINE *S, 
+    IN ULONG St, 
+    ULONG Msg, 
+    IN STATE_MACHINE_FUNC F);
+
+VOID StateMachinePerformAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN STATE_MACHINE *S, 
+    IN MLME_QUEUE_ELEM *Elem);
+
+VOID Drop(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN MLME_QUEUE_ELEM *Elem);
+
+VOID StateMachineDestroy(
+    IN STATE_MACHINE *Sm);
+
+VOID  AssocStateMachineInit(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  STATE_MACHINE *Sm, 
+    OUT STATE_MACHINE_FUNC Trans[]);
+
+VOID  ReassocTimeout(
+    IN	unsigned long data);
+
+VOID  AssocTimeout(
+    IN	unsigned long data);
+
+VOID  DisassocTimeout(
+    IN	unsigned long data);
+
+//----------------------------------------------
+VOID  MlmeDisassocReqAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID  MlmeAssocReqAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID  MlmeReassocReqAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID  MlmeDisassocReqAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID  PeerAssocRspAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID  PeerReassocRspAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID  PeerDisassocAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID  DisassocTimeoutAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID  AssocTimeoutAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID  ReassocTimeoutAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID  Cls3errAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  PMACADDR pAddr);
+
+VOID  InvalidStateWhenAssoc(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID  InvalidStateWhenReassoc(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID InvalidStateWhenDisassociate(
+    IN  PRT2570ADAPTER pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID  ComposePsPoll(
+    IN	PRT2570ADAPTER	pAdapter);
+
+VOID  ComposeNullFrame(
+    IN  PRT2570ADAPTER pAdapter);
+
+VOID  ComposeStuffFrame(
+    IN  PRT2570ADAPTER pAdapter);
+
+VOID  AssocPostProc(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MACADDR *Addr2, 
+    IN  USHORT CapabilityInfo, 
+    IN  USHORT Aid, 
+    IN  UCHAR Rates[], 
+    IN  UCHAR RatesLen,
+    IN  BOOLEAN ExtendedRateIeExist);
+
+VOID AuthStateMachineInit(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN PSTATE_MACHINE sm, 
+    OUT STATE_MACHINE_FUNC Trans[]);
+
+VOID AuthTimeout(
+    IN	unsigned long data);
+
+
+VOID MlmeAuthReqAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID PeerAuthRspAtSeq2Action(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID PeerAuthRspAtSeq4Action(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID AuthTimeoutAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID Cls2errAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  PMACADDR pAddr);
+
+VOID MlmeDeauthReqAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID InvalidStateWhenAuth(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+//VOID MlmeDeauthReqProc(
+//    IN	PRT2570ADAPTER	pAdapter, 
+//    IN  MACADDR *Addr, 
+//    IN  USHORT Reason);
+
+//=============================================
+
+VOID AuthRspStateMachineInit(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  PSTATE_MACHINE Sm, 
+    IN  STATE_MACHINE_FUNC Trans[]);
+
+
+VOID AuthRspChallengeTimeout(
+    IN	unsigned long data);
+
+VOID AuthRspChallengeTimeoutAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID PeerAuthAtAuthRspIdleAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID PeerAuthAtAuthRspWaitAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID PeerDeauthAction(
+    IN PRT2570ADAPTER pAdaptor, 
+    IN MLME_QUEUE_ELEM *Elem);
+
+VOID PeerAuthSimpleRspGenAndSend(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  PMACHDR Hdr, 
+    IN  USHORT Alg, 
+    IN  USHORT Seq, 
+    IN  USHORT Reason, 
+    IN  USHORT Status);
+
+//========================================
+
+VOID SyncStateMachineInit(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  STATE_MACHINE *Sm, 
+    OUT STATE_MACHINE_FUNC Trans[]);
+
+VOID BeaconTimeout(
+    IN	unsigned long data);
+
+VOID AtimTimeout(
+    IN	unsigned long data); 
+
+VOID ScanTimeout(
+    IN	unsigned long data);
+
+VOID MlmeScanReqAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID InvalidStateWhenScan(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID InvalidStateWhenJoin(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID InvalidStateWhenStart(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID PeerBeacon(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+//=========================================
+
+VOID MlmeCntlInit(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  STATE_MACHINE *S, 
+    OUT STATE_MACHINE_FUNC Trans[]);
+
+VOID MlmeCntlMachinePerformAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  STATE_MACHINE *S, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID CntlIdleProc(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID CntlOidScanProc(
+    IN  PRT2570ADAPTER pAdapter,
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID CntlOidSsidProc(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM * Elem);
+
+VOID CntlOidRTBssidProc(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM * Elem);
+
+VOID CntlMlmeRoamingProc(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM * Elem);
+
+VOID CntlWaitDisassocProc(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID CntlWaitJoinProc(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID CntlWaitReassocProc(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID CntlWaitStartProc(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID CntlWaitAuthProc(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID CntlWaitAuthProc2(
+    IN  PRT2570ADAPTER pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID CntlWaitAssocProc(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID LinkUp(
+    IN	PRT2570ADAPTER	pAdapter,
+    IN  UCHAR BssType);
+
+VOID LinkDown(
+    IN	PRT2570ADAPTER	pAdapter);
+
+VOID MlmeCntlConfirm(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  ULONG MsgType, 
+    IN  USHORT Msg);
+
+VOID IterateOnBssTab(
+    IN	PRT2570ADAPTER	pAdapter);
+
+VOID IterateOnBssTab2(
+    IN  PRT2570ADAPTER   pAdapter);;
+
+VOID JoinParmFill(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  OUT MLME_JOIN_REQ_STRUCT *JoinReq, 
+    IN  ULONG BssIdx);
+
+VOID AssocParmFill(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN OUT MLME_ASSOC_REQ_STRUCT *AssocReq, 
+    IN  MACADDR *Addr, 
+    IN  USHORT CapabilityInfo, 
+    IN  ULONG Timeout, 
+    IN  USHORT ListenIntv);
+
+VOID ScanParmFill(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  OUT MLME_SCAN_REQ_STRUCT *ScanReq, 
+    IN  CHAR Ssid[], 
+    IN  UCHAR SsidLen, 
+    IN  UCHAR BssType, 
+    IN  UCHAR ScanType); 
+
+VOID DisassocParmFill(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  OUT MLME_DISASSOC_REQ_STRUCT *DisassocReq, 
+    IN  MACADDR *Addr, 
+    IN  USHORT Reason);
+
+VOID StartParmFill(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  OUT MLME_START_REQ_STRUCT *StartReq, 
+    IN  CHAR Ssid[], 
+    IN  UCHAR SsidLen);
+
+VOID AuthParmFill(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  OUT MLME_AUTH_REQ_STRUCT *AuthReq, 
+    IN  MACADDR *Addr, 
+    IN  USHORT Alg);
+
+VOID EnqueuePsPoll(
+    IN	PRT2570ADAPTER	pAdapter);
+
+VOID EnqueueBeaconFrame(
+    IN  PRT2570ADAPTER   pAdapter); 
+
+void USB_SendNullFrameComplete(purbb_t purb,struct pt_regs *pt_regs);
+
+VOID EnqueueNullFrame(
+    IN  PRT2570ADAPTER pAdapter,
+    IN  UCHAR         TxRate);
+
+VOID MlmeJoinReqAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+
+
+VOID MlmeStartReqAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID ScanTimeoutAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID BeaconTimeoutAtJoinAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID PeerBeaconAtScanAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID PeerBeaconAtJoinAction(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID PeerBeacon(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID PeerProbeReqAction(
+    IN  PRT2570ADAPTER pAd, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID ScanNextChannel(
+    IN	PRT2570ADAPTER	pAdapter);
+
+VOID MakeIbssBeacon(
+    IN	PRT2570ADAPTER	pAdapter);
+
+BOOLEAN MlmeScanReqSanity(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  VOID *Msg, 
+    IN  ULONG MsgLen, 
+    OUT UCHAR *BssType, 
+    OUT CHAR ssid[], 
+    OUT UCHAR *SsidLen, 
+    OUT UCHAR *ScanType);
+
+BOOLEAN PeerBeaconAndProbeRspSanity(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  VOID *Msg, 
+    IN  ULONG MsgLen, 
+    OUT MACADDR *Addr2, 
+    OUT MACADDR *Bssid, 
+    OUT CHAR Ssid[], 
+    OUT UCHAR *SsidLen, 
+    OUT UCHAR *BssType, 
+    OUT USHORT *BeaconPeriod, 
+    OUT UCHAR *Channel, 
+    OUT LARGE_INTEGER *Timestamp, 
+    OUT BOOLEAN *CfExist, 
+    OUT CF_PARM *Cf, 
+    OUT USHORT *AtimWin, 
+    OUT USHORT *CapabilityInfo, 
+    OUT UCHAR Rate[], 
+    OUT UCHAR *RateLen,
+    OUT BOOLEAN *ExtendedRateIeExist,
+    OUT UCHAR *Erp,
+    OUT UCHAR *DtimCount, 
+    OUT UCHAR *DtimPeriod, 
+    OUT UCHAR *BcastFlag, 
+    OUT UCHAR *MessageToMe, 
+    OUT UCHAR *Legacy,
+    OUT UCHAR SupRate[],
+    OUT UCHAR *SupRateLen,
+    OUT UCHAR ExtRate[],
+    OUT UCHAR *ExtRateLen,
+    OUT UCHAR *LengthVIE,
+    OUT	PNDIS_802_11_VARIABLE_IEs pVIE);
+
+//BOOLEAN JoinParmSanity(
+//    IN	PRT2570ADAPTER	pAdapter, 
+//    IN  VOID *Msg, 
+//    IN  ULONG MsgLen, 
+//    OUT ULONG *BssIdx,
+//    OUT UCHAR SupportedRates[], 
+//    OUT UCHAR *SupportedRatesLen);
+
+BOOLEAN MlmeAssocReqSanity(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  VOID *Msg, 
+    IN  ULONG MsgLen, 
+    OUT MACADDR *ApAddr, 
+    OUT USHORT *CapabilityInfo, 
+    OUT ULONG *Timeout, 
+    OUT USHORT *ListenIntv);
+
+BOOLEAN MlmeAuthReqSanity(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  VOID *Msg, 
+    IN  ULONG MsgLen, 
+    OUT MACADDR *Addr, 
+    OUT ULONG *Timeout, 
+    OUT USHORT *Alg);
+
+BOOLEAN MlmeStartReqSanity(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  VOID *Msg, 
+    IN  ULONG MsgLen, 
+    OUT CHAR Ssid[], 
+    OUT UCHAR *Ssidlen);
+
+BOOLEAN PeerAuthSanity(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  VOID *Msg, 
+    IN  ULONG MsgLen, 
+    OUT MACADDR *Addr, 
+    OUT USHORT *Alg, 
+    OUT USHORT *Seq, 
+    OUT USHORT *Status, 
+    OUT CHAR ChlgText[]);
+
+BOOLEAN PeerAssocRspSanity(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  VOID *Msg, 
+    IN  ULONG MsgLen, 
+    OUT MACADDR *Addr2, 
+    OUT USHORT *CapabilityInfo, 
+    OUT USHORT *Status, 
+    OUT USHORT *Aid, 
+    OUT UCHAR Rates[], 
+    OUT UCHAR *RatesLen,
+    OUT BOOLEAN *ExtendedRateIeExist);
+
+BOOLEAN PeerDisassocSanity(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  VOID *Msg, 
+    IN  ULONG MsgLen, 
+    OUT MACADDR *Addr2, 
+    OUT USHORT *Reason);
+
+BOOLEAN PeerDeauthSanity(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  VOID *Msg, 
+    IN  ULONG MsgLen, 
+    OUT MACADDR *Addr2, 
+    OUT USHORT *Reason);
+
+BOOLEAN PeerProbeReqSanity(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  VOID *Msg, 
+    IN  ULONG MsgLen, 
+    OUT MACADDR *Addr2,
+    OUT CHAR Ssid[], 
+    OUT UCHAR *SsidLen); 
+//    OUT UCHAR Rates[], 
+//    OUT UCHAR *RatesLen);
+NDIS_STATUS	RTMPWPAWepKeySanity(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PVOID			pBuf);
+
+BOOLEAN GetTimBit(
+    IN  CHAR *Ptr, 
+    IN  USHORT Aid, 
+    OUT UCHAR *TimLen, 
+    OUT UCHAR *BcastFlag, 
+    OUT UCHAR *DtimCount, 
+    OUT UCHAR *DtimPeriod, 
+    OUT UCHAR *MessageToMe);
+
+BOOLEAN GetLegacy(
+    IN  CHAR *Ptr, 
+    OUT UCHAR *Legacy);
+
+ULONG MakeOutgoingFrame(
+    OUT CHAR *Buffer, 
+    OUT ULONG *Length, ...);
+
+VOID  LfsrInit(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  ULONG Seed);
+
+UCHAR RandomByte(
+    IN	PRT2570ADAPTER	pAdapter);
+
+VOID  MlmePeriodicExec(
+    IN	unsigned long data);
+
+#if 1
+VOID  RxPeriodicExec(
+    IN PVOID SystemSpecific1, 
+    IN PVOID FunctionContext, 
+    IN PVOID SystemSpecific2, 
+    IN PVOID SystemSpecific3);
+
+#endif
+
+VOID MlmeAutoScan(
+    IN PRT2570ADAPTER pAdapter);
+
+VOID MlmeAutoRecoverNetwork(
+    IN PRT2570ADAPTER pAdapter);
+
+VOID MlmeAutoReconnectLastSSID(
+    IN PRT2570ADAPTER pAdapter);
+
+BOOLEAN	MlmeValidateSSID(
+    IN PRT2570ADAPTER pAd);
+
+VOID MlmeCheckForRoaming(
+    IN PRT2570ADAPTER pAdapter,
+    IN ULONG    Now32);
+
+//blue,VOID MlmeCheckChannelQuality(
+VOID PeriodicExec(
+    IN PRT2570ADAPTER pAdapter);
+
+VOID MlmeCheckForPsmChange(
+    IN PRT2570ADAPTER pAd);
+
+VOID MlmeSetPsmBit(
+    IN PRT2570ADAPTER pAdapter, 
+    IN USHORT psm);
+
+VOID MlmeSetTxPreamble(
+    IN PRT2570ADAPTER pAdapter, 
+    IN USHORT TxPreamble);
+
+VOID MlmeUpdateTxRates(
+    IN PRT2570ADAPTER pAd,
+    IN BOOLEAN		 bLinkUp);
+
+VOID	RTMPCheckRates(
+	IN		PRT2570ADAPTER	pAd,
+	IN OUT	UCHAR			SupRate[],
+	IN OUT	UCHAR			*SupRateLen);
+
+NDIS_STATUS MlmeInit(
+    IN	PRT2570ADAPTER	pAdapter);
+
+struct net_device_stats *
+rt_getstats(struct net_device *dev);
+
+struct iw_statistics *RTUSB_get_wireless_stats(
+    IN  struct net_device *net_dev);
+
+VOID MlmeHalt(
+    IN	PRT2570ADAPTER	pAdapter);
+
+VOID MlmeHandler(
+    IN PRT2570ADAPTER pAd);
+
+VOID MlmeSuspend(
+    IN PRT2570ADAPTER pAd);
+
+int MlmeThread(void * Context);
+VOID CMDHandler(
+    IN PRT2570ADAPTER pAdapter);
+
+int RTUSBCmdThread(void * Context);
+NDIS_STATUS MlmeInitMemoryHandler(
+    IN PRT2570ADAPTER    pAd,
+    IN UINT             Number,
+    IN UINT             Size);
+
+NDIS_STATUS MlmeAllocateMemory(
+    IN PRT2570ADAPTER    pAd,
+    OUT PVOID           *AllocVa);
+
+VOID MlmeFreeMemory(
+    IN PRT2570ADAPTER    pAd,
+    IN PVOID            AllocVa);
+
+VOID MlmeFreeMemoryHandler(
+    IN PRT2570ADAPTER    pAd);
+
+
+VOID DeleteTimer(
+    IN PRT2570ADAPTER    pAd);
+
+NTSTATUS
+RTUSBSingleRead
+(
+ IN	PRT2570ADAPTER	pAdapter,
+ USHORT				Offset,
+ PUSHORT			pValue
+ );
+
+NTSTATUS
+RTUSBSingleWrite
+(
+ IN	PRT2570ADAPTER	pAdapter,
+ USHORT				Offset,
+ USHORT				Value
+ );
+
+NTSTATUS
+RTUSBReadMACRegister
+(
+ IN	PRT2570ADAPTER	pAdapter,
+ USHORT				Offset,
+ PUSHORT			pValue
+ );
+
+NTSTATUS
+RTUSBWriteMACRegister
+(
+ IN	PRT2570ADAPTER	pAdapter,
+ USHORT				Offset,
+ USHORT				Value
+ );
+
+NTSTATUS
+RTUSBMultiRead
+(
+ IN	PRT2570ADAPTER	pAdapter,
+ USHORT				Offset,
+ PUCHAR				pData,
+ USHORT				length
+ );
+
+NTSTATUS
+RTUSBMultiWrite
+(
+ IN	PRT2570ADAPTER	pAdapter,
+ USHORT				Offset,
+ PUCHAR				pData,
+ USHORT				length
+ );
+
+#define	RETRY_LIMIT	3
+NTSTATUS
+RTUSBReadBBPRegister
+(
+ IN	PRT2570ADAPTER	pAdapter,
+ IN	UCHAR			Id,
+ IN	PUCHAR			pValue
+ );
+
+
+NTSTATUS
+RTUSBWriteBBPRegister
+(
+ IN	PRT2570ADAPTER	pAdapter,
+ IN	UCHAR			Id,
+ IN	UCHAR			Value
+ );
+
+NTSTATUS
+RTUSBWriteRFRegister
+(
+ IN	PRT2570ADAPTER	pAdapter,
+ IN	ULONG			Value
+ );
+
+NTSTATUS
+RTUSBReadEEPROM
+(
+ IN	PRT2570ADAPTER	pAdapter,
+ USHORT				Offset,
+ PUCHAR				pData,
+ USHORT				length
+ );
+
+NTSTATUS
+RT2570WriteEEPROM
+(
+ IN	PRT2570ADAPTER	pAdapter,
+ USHORT				Offset,
+ PUCHAR				pData,
+ USHORT				length
+ );
+
+
+VOID
+  UsbBuildVendorRequest(
+    IN PRT2570ADAPTER	pAdapter,
+    IN PURB	Urb,
+    IN USHORT  Function,
+    IN USHORT  Length,
+    IN ULONG  TransferFlags,
+    IN UCHAR  ReservedBits,
+    IN UCHAR  Request,
+    IN USHORT  Value,
+    IN USHORT  Index,
+    IN PVOID  TransferBuffer ,
+    IN PMDL  TransferBufferMDL ,
+    IN ULONG  TransferBufferLength,
+    IN PURB  Link
+    );
+
+
+void mod_use(UCHAR a, PRT2570ADAPTER pAdapter);
+
+
+
+
+#if 0
+VOID
+EnqueueCmd
+(
+ PCmdQ	cmdq,
+ PCmdQElmt	cmdelmt
+ );
+#else
+#define EnqueueCmd(cmdq, cmdqelmt) \
+{ \
+	if (cmdq->size == 0) \
+		cmdq->head = cmdqelmt; \
+	else \
+		cmdq->tail->next = cmdqelmt; \
+	cmdq->tail = cmdqelmt; \
+	cmdqelmt->next = NULL; \
+	cmdq->size++; \
+}
+#endif
+
+
+VOID
+EnqueueInternalCmd
+(
+ PRT2570ADAPTER	pAdapter,
+ NDIS_OID		Oid
+ );
+
+VOID
+DequeueCmd
+(
+ PCmdQ	cmdq,
+ PCmdQElmt	*pcmdelmt
+ );
+
+
+//blue
+#if 0
+VOID
+InitializeBulkOutQueue
+(
+ PBULK_OUT_QUEUE	cmdq
+ );
+
+
+VOID
+EnqueueBulkOut
+(
+ PBULK_OUT_QUEUE	cmdq,
+ PBULK_OUT_QUEUE_ELEMENT	cmdelmt
+ );
+
+VOID
+DequeueBulkOut
+(
+ PBULK_OUT_QUEUE	cmdq,
+ PBULK_OUT_QUEUE_ELEMENT	*pcmdelmt
+ );
+#endif
+
+VOID
+InitializeDataBulkOutQueue
+(
+ PRT2570ADAPTER	pAdapter
+ );
+
+#if 0
+VOID
+EnqueueDataBulkOut
+(
+ PRT2570ADAPTER	pAdapter,
+ PNDIS_PACKET	cmdelmt
+ );
+
+VOID
+DequeueDataBulkOut
+(
+ PRT2570ADAPTER	pAdapter,
+ PNDIS_PACKET	*pcmdelmt
+ );
+#else
+
+#define EnqueueDataBulkOut(pAdapter, cmdqelmt) \
+{ \
+	PDATA_BULKOUT_QUEUE	cmdq = &(pAdapter->DataQ); \
+	if (cmdq->size == 0) \
+		cmdq->head = cmdqelmt; \
+	else \
+		*(GET_NEXT_PACKET_IN_BULKOUT_QUEUE(cmdq->tail)) = cmdqelmt; \
+	cmdq->tail = cmdqelmt; \
+	cmdq->size++; \
+	*(GET_NEXT_PACKET_IN_BULKOUT_QUEUE(cmdqelmt)) = NULL; \
+}
+
+#define DequeueDataBulkOut(pAdapter, pcmdqelmt) \
+{ \
+	PDATA_BULKOUT_QUEUE	cmdq = &(pAdapter->DataQ); \
+	*pcmdqelmt = cmdq->head; \
+	cmdq->head = *(GET_NEXT_PACKET_IN_BULKOUT_QUEUE(*pcmdqelmt)); \
+	cmdq->size--; \
+	if (cmdq->size == 0) \
+		cmdq->tail = NULL; \
+}
+
+
+#endif
+
+VOID
+InitializeMLMEBulkOutQueue
+(
+ PRT2570ADAPTER	pAdapter
+ );
+
+#if 0
+VOID
+EnqueueMLMEBulkOut
+(
+ PRT2570ADAPTER	pAdapter,
+ PMGMT_STRUC	cmdelmt
+ );
+
+VOID
+DequeueMLMEBulkOut
+(
+ PRT2570ADAPTER	pAdapter,
+ PMGMT_STRUC	*pcmdelmt
+ );
+#else
+#define EnqueueMLMEBulkOut(pAdapter, cmdqelmt) \
+{ \
+	PMLME_BULKOUT_QUEUE	cmdq = &(pAdapter->MLMEQ); \
+	if (cmdq->size == 0) \
+		cmdq->head = cmdqelmt; \
+	else \
+ 		cmdq->tail->next = cmdqelmt; \
+ 	cmdq->tail = cmdqelmt; \
+	cmdq->size++; \
+	cmdqelmt->next = NULL; \
+}
+
+#define DequeueMLMEBulkOut(pAdapter, pcmdqelmt) \
+{ \
+	PMLME_BULKOUT_QUEUE	cmdq = &(pAdapter->MLMEQ); \
+	*pcmdqelmt = cmdq->head; \
+	cmdq->head = (*pcmdqelmt)->next; \
+	cmdq->size--; \
+	if (cmdq->size == 0) \
+		cmdq->tail = NULL; \
+}
+#endif
+
+NDIS_STATUS RTMPFreeDescriptorRequest(
+	IN		PRT2570ADAPTER	pAdapter,
+	IN		UCHAR			RingType,
+	IN		UCHAR			NumberRequired);
+
+
+VOID MlmeSuspend(
+    IN	PRT2570ADAPTER	pAdapter);
+
+VOID MlmeResume(
+    IN	PRT2570ADAPTER	pAdapter);
+
+#ifdef TEST_MODE_SUPPORT
+NTSTATUS
+USB_BulkOut
+(
+ PRT2570ADAPTER pAdapter,
+ USHORT	length,
+ PVOID buffer
+ );
+
+//blue
+#if 0
+VOID
+BulkInOnePacket
+(
+ PRT2570ADAPTER Adapter
+ );
+#endif
+
+VOID
+BulkInPackets
+(
+ PRT2570ADAPTER Adapter
+ );
+
+VOID
+BulkOutPackets
+(
+ PRT2570ADAPTER pAdapter,
+ USHORT length, PVOID buffer
+ );
+#endif
+
+#ifdef RALINK_ATE
+VOID DisableMlme(
+    IN PRT2570ADAPTER pAd); 
+
+VOID ReenableMlme(
+    IN PRT2570ADAPTER pAd); 
+#endif
+
+VOID BuildChannelList(
+    IN PRT2570ADAPTER pAdapter);
+
+UCHAR FirstChannel(
+    IN	PRT2570ADAPTER	pAdapter);
+
+UCHAR NextChannel(
+    IN	PRT2570ADAPTER	pAdapter, 
+    IN  UCHAR channel);
+
+VOID RaiseClock(
+    IN	PRT2570ADAPTER	pAd,
+    IN  ULONG *x);
+
+VOID LowerClock(
+    IN	PRT2570ADAPTER	pAd,
+    IN  ULONG *x);
+
+USHORT ShiftInBits(
+    IN	PRT2570ADAPTER	pAd);
+
+VOID ShiftOutBits(
+    IN	PRT2570ADAPTER	pAd,
+    IN  USHORT data,
+    IN  USHORT count);
+
+VOID EEpromCleanup(
+    IN	PRT2570ADAPTER	pAd);
+
+VOID EWDS(
+	IN	PRT2570ADAPTER	pAd);
+
+VOID EWEN(
+	IN	PRT2570ADAPTER	pAd);
+    
+USHORT RTMP_EEPROM_READ16(
+    IN	PRT2570ADAPTER	pAd,
+    IN  USHORT Offset);
+
+VOID RTMP_EEPROM_WRITE16(
+    IN	PRT2570ADAPTER	pAd,
+    IN  USHORT Offset,
+    IN  USHORT Data);
+
+UCHAR ChannelSanity(
+    IN PRT2570ADAPTER pAd, 
+    IN UCHAR channel);
+    
+//
+// Prototypes of function definition in rtmp_tkip.c
+//
+VOID	RTMPInitTkipEngine(
+	IN	PRT2570ADAPTER	pAdapter,	
+	IN	PUCHAR			pTKey,
+	IN	UCHAR			KeyId,
+	IN	PUCHAR			pTA,
+	IN	PUCHAR			pMICKey,
+	IN	PUCHAR			pTSC,
+	IN	INT				DoEncrypt,
+	OUT PULONG			pIV16,
+	OUT PULONG			pIV32,
+	IN	PUCHAR			pDest);
+
+BOOLEAN	RTMPTkipCompareMICValue(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PUCHAR			pSrc,
+	IN	PUCHAR			pDA,
+	IN	PUCHAR			pSA,
+	IN	PUCHAR			pMICKey,
+	IN	UINT			Len);
+
+VOID	RTMPCalculateMICValue(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	struct sk_buff 	*pPacket,
+	IN	PUCHAR			pEncap,
+	IN	INT				LenEncap,
+	IN	PWPA_KEY		pWpaKey);
+
+VOID RTMPTkipMixTKey(
+	IN	PTKIP_KEY_INFO	pTkip,
+	IN	PUCHAR			pTKey,
+	IN	PUCHAR			pTA	);
+
+BOOLEAN	RTMPTkipCompareMICValueWithLLC(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PUCHAR			pLLC,
+	IN	PUCHAR			pSrc,
+	IN	PUCHAR			pDA,
+	IN	PUCHAR			pSA,
+	IN	PUCHAR			pMICKey,
+	IN	UINT			Len);
+
+BOOLEAN RTMPSoftDecryptTKIP(
+	IN PRT2570ADAPTER pAdapter,
+	IN PUCHAR	pData,
+	IN ULONG	DataByteCnt, 
+	IN PWPA_KEY	pWpaKey);
+
+NDIS_STATUS	RTMPWPAAddKeyProc(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PVOID			pBuf);
+
+NDIS_STATUS	RTMPWPARemoveKeyProc(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PVOID			pBuf);
+
+VOID	RTMPWPARemoveAllKeys(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID	RTMPSetPhyMode(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN  ULONG phymode);
+
+VOID    RT2570SetDesiredRates(
+    IN  PRT2570ADAPTER	pAdapter,
+    IN  LONG            Rates);
+INT Set_R17_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg);
+
+INT Read_R17_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg);
+
+int usb_rt2570_ioctl(struct net_device *net_dev, struct ifreq *rq, int cmd);
+
+VOID
+KickBulkOut
+(
+ PRT2570ADAPTER pAdapter,
+ BOOLEAN	InBurst
+ );
+
+VOID
+BulkOutBeacon0
+(
+ PRT2570ADAPTER	pAdapter
+ );
+
+VOID
+RejectPendingPackets
+(
+ PRT2570ADAPTER pAdapter
+ );
+
+VOID
+CleanUpMLMEWaitQueue
+(
+ IN	PRT2570ADAPTER	pAdapter
+ );
+
+#if 0
+VOID
+CleanUpBulkOutQueues
+(
+ PRT2570ADAPTER pAdapter,
+ BULK_OUT_TYPE	type
+ );
+#endif
+
+VOID
+CleanUpDataBulkOutQueue
+(
+ PRT2570ADAPTER pAdapter
+ );
+
+VOID
+CleanUpMLMEBulkOutQueue
+(
+ PRT2570ADAPTER pAdapter
+ );
+
+VOID
+CancelPendingIRPs
+(
+ IN PRT2570ADAPTER pAdapter
+ );
+
+VOID
+CancelPendingBulkOutIRP
+(
+ PRT2570ADAPTER pAdapter
+ );
+
+VOID
+CancelPendingBulkInIRP_bh
+(
+ PRT2570ADAPTER pAdapter
+ );
+
+
+
+//
+// Prototypes of function definition for *iwpriv* in rtmp_info.c
+//
+INT Set_CountryRegion_Proc(
+    IN  PRT2570ADAPTER	pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_SSID_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_WirelessMode_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_TxRate_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_Channel_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR  
+    arg);
+
+INT Set_BGProtection_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_TxPreamble_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_RTSThreshold_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_FragThreshold_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_TxBurst_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_TurboRate_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_AuthMode_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_EncrypType_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_DefaultKeyID_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_Key1_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_Key2_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_Key3_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_Key4_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+INT Set_WPAPSK_Proc(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  PUCHAR          arg);
+
+#ifdef RT2500_DBG
+VOID RTMPIoctlBBP(
+    IN  PRT2570ADAPTER   pAdapter,
+    IN  struct iwreq    *wrq);
+
+VOID RTMPIoctlMAC(
+    IN  PRT2570ADAPTER   pAdapter,
+    IN  struct iwreq    *wrq);
+#endif
+
+
+
+//
+// prototype in wpa.c
+//
+BOOLEAN WpaMsgTypeSubst(
+    IN  UCHAR   EAPType,
+    OUT ULONG   *MsgType);
+
+VOID WpaPskStateMachineInit(
+    IN  PRT2570ADAPTER       pAd, 
+    IN  STATE_MACHINE       *S, 
+    OUT STATE_MACHINE_FUNC Trans[]);
+
+VOID WpaEAPOLKeyAction(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID    WpaPairMsg1Action(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID    WpaPairMsg3Action(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem); 
+
+VOID    WpaGroupMsg1Action(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem);
+
+VOID    WpaMacHeaderInit(
+    IN      PRT2570ADAPTER   pAd, 
+    IN OUT  PHEADER_802_11  Hdr, 
+    IN      UCHAR           wep, 
+    IN      PMACADDR        pAddr1); 
+
+VOID    WpaHardEncrypt(
+    IN  PRT2570ADAPTER   pAdapter,
+    IN  PUCHAR          pPacket,
+    IN  ULONG           Len);
+
+VOID    HMAC_SHA1(
+    IN  UCHAR   *text,
+    IN  UINT    text_len,
+    IN  UCHAR   *key,
+    IN  UINT    key_len,
+    IN  UCHAR   *digest);
+ void hmac_sha1(unsigned char *text, int text_len, unsigned char *key, int key_len, unsigned char *digest);
+
+VOID    PRF(
+    IN  UCHAR   *key,
+    IN  INT     key_len,
+    IN  UCHAR   *prefix,
+    IN  INT     prefix_len,
+    IN  UCHAR   *data,
+    IN  INT     data_len,
+    OUT UCHAR   *output,
+    IN  INT     len);
+
+VOID WpaCountPTK(
+    IN  UCHAR   *PMK,
+    IN  UCHAR   *ANonce,
+    IN  UCHAR   *AA,
+    IN  UCHAR   *SNonce,
+    IN  UCHAR   *SA,
+    OUT UCHAR   *output,
+    IN  UINT    len);
+
+VOID    GenRandom(
+    IN  PRT2570ADAPTER   pAd, 
+    OUT UCHAR           *random);
+
+VOID    AES_GTK_KEY_UNWRAP( 
+    IN  UCHAR   *key,
+    OUT UCHAR   *plaintext,
+    IN  UCHAR   *ciphertext);
+
+
+//
+// SHA context
+//
+typedef	struct _SHA_CTX
+{
+    ULONG   Buf[5];             // buffers of five states
+	UCHAR   Input[80];          // input message
+	ULONG   LenInBitCount[2];   // length counter for input message, 0 up to 64 bits
+	
+}	SHA_CTX;
+    
+    
+VOID BulkOutWpaPskFrame( PRT2570ADAPTER	pAd);
+
+VOID	RTMPTkipEncryptData(
+	IN	PRT2570ADAPTER	pAdapter,	
+	IN	PUCHAR			pSrc,
+	IN	PUCHAR			pDest,
+	IN	UINT			Len);
+
+VOID    RTMPInitMICEngine(
+    IN  PRT2570ADAPTER pAdapter,   
+    IN  PUCHAR          pKey,
+    IN  PUCHAR          pDA,
+    IN  PUCHAR          pSA,
+    IN  PUCHAR          pMICKey);
+
+
+VOID    RTMPTkipAppend( 
+    IN  PTKIP_KEY_INFO  pTkip,  
+    IN  PUCHAR          pSrc,
+    IN  UINT            nBytes);
+
+VOID    RTMPTkipGetMIC( 
+    IN  PTKIP_KEY_INFO  pTkip);
+
+void USB_SendWpaPskComplete(purbb_t pUrb,struct pt_regs *pt_regs);
+//void USB_SendWpaPskComplete(purbb_t pUrb);
+
+//
+// extra prototype in md5.c
+//
+VOID    SHAInit(SHA_CTX *ctx);
+
+  VOID    SHAHashBlock(SHA_CTX *ctx);
+
+UCHAR SHAUpdate(SHA_CTX *pCtx, UCHAR *pData, ULONG LenInBytes);
+
+VOID    SHAFinal(SHA_CTX *ctx, unsigned char hashout[20]);
+#endif 
+#ifndef _stdincl_h_OK__
+#define _stdincl_h_OK__
+
+
+
+
+//=============================================
+// functions in usbrx.c
+//=============================================
+
+int USB_RxPacket(PRT2570ADAPTER Adapter);
+
+//=============================================
+// functions in rt2570_main.c
+//=============================================
+
+VOID ReleaseAdapter(PRT2570ADAPTER   Adapter, BOOLEAN IsFree);
+
+
+VOID RejectPendingPackets(PRT2570ADAPTER Adapter);
+
+int ControlThread(IN OUT PVOID Context);
+
+
+int TXThread(IN OUT PVOID  Context);
+
+
+BOOLEAN RT2570UsbReset(PRT2570ADAPTER    Adapter);
+
+NTSTATUS USB_ResetPipe(PRT2570ADAPTER    Adapter, 
+                       UINT BulkPipe);
+
+int USB_CallUSBD(PRT2570ADAPTER Adapter, 
+                      IN PURB       Urb);
+
+#endif
+
+#ifndef _PRISMHEADER
+#define _PRISMHEADER
+
+enum {
+	DIDmsg_lnxind_wlansniffrm		= 0x00000044,
+	DIDmsg_lnxind_wlansniffrm_hosttime	= 0x00010044,
+	DIDmsg_lnxind_wlansniffrm_mactime	= 0x00020044,
+	DIDmsg_lnxind_wlansniffrm_channel	= 0x00030044,
+	DIDmsg_lnxind_wlansniffrm_rssi		= 0x00040044,
+	DIDmsg_lnxind_wlansniffrm_sq		= 0x00050044,
+	DIDmsg_lnxind_wlansniffrm_signal	= 0x00060044,
+	DIDmsg_lnxind_wlansniffrm_noise		= 0x00070044,
+	DIDmsg_lnxind_wlansniffrm_rate		= 0x00080044,
+	DIDmsg_lnxind_wlansniffrm_istx		= 0x00090044,
+	DIDmsg_lnxind_wlansniffrm_frmlen	= 0x000A0044
+};
+enum {
+	P80211ENUM_msgitem_status_no_value	= 0x00
+};
+enum {
+	P80211ENUM_truth_false			= 0x00,
+	P80211ENUM_truth_true			= 0x01
+};
+
+typedef struct {
+	u_int32_t did;
+	u_int16_t status;
+	u_int16_t len;
+	u_int32_t data;
+} p80211item_uint32_t;
+
+typedef struct {
+	u_int32_t msgcode;
+	u_int32_t msglen;
+#define WLAN_DEVNAMELEN_MAX 16
+	u_int8_t devname[WLAN_DEVNAMELEN_MAX];
+	p80211item_uint32_t hosttime;
+	p80211item_uint32_t mactime;
+	p80211item_uint32_t channel;
+	p80211item_uint32_t rssi;
+	p80211item_uint32_t sq;
+	p80211item_uint32_t signal;
+	p80211item_uint32_t noise;
+	p80211item_uint32_t rate;
+	p80211item_uint32_t istx;
+	p80211item_uint32_t frmlen;
+} wlan_ng_prism2_header;
+
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rt_config.h linux-2.4.35.3-mct/drivers/usb/rt2570/rt_config.h
--- linux-2.4.35.3/drivers/usb/rt2570/rt_config.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rt_config.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,197 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	rt_config.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ *	RobinC		02-06-2005	usb_kill_urb fixes for kernels =>2.6.7
+ *	MathiasK	04-07-2005	endian fix
+ ***************************************************************************/
+
+#ifndef	__RT_CONFIG_H__
+#define	__RT_CONFIG_H__
+
+#define PROFILE_PATH            "/etc/Wireless/RT2570STA/RT2570STA.dat"
+#define NIC_DEVICE_NAME         "RT2500USBSTA"
+#define DRV_MAJORVERSION	1
+#define DRV_MINORVERSION	0
+#define DRV_SUBVERSION		0
+#define DRV_TESTVERSION		0
+#define DRV_YEAR		2005
+#define DRV_MONTH		6
+#define DRV_DAY			1
+
+#define DRV_NAME		"rt2570"
+#define DRV_VERSION		"1.0.0 - CVS"
+#define DRV_RELDATE		"2005/06/01"
+
+
+/* Operational parameters that are set at compile time. */
+#if !defined(__OPTIMIZE__)  ||  !defined(__KERNEL__)
+#warning  You must compile this file with the correct options!
+#warning  See the last lines of the source file.
+#error  You must compile this driver with "-O".
+#endif
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+//#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/ethtool.h>
+#include <linux/wireless.h>
+#include <linux/proc_fs.h>
+#include <linux/delay.h>
+#include <linux/if_arp.h>
+#include <linux/ctype.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/kmod.h>
+#include <linux/slab.h>
+
+//usb header files
+#include <linux/usb.h>
+
+#if LINUX_VERSION_CODE >= 0x20407
+#include <linux/mii.h>
+#endif
+#include <asm/processor.h>      /* Processor type for cache alignment. */
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+
+// The type definition has to be placed before including rt2460.h
+#ifndef ULONG
+#define CHAR            char
+#define INT             int
+#define UINT            u32
+#define ULONG           u32
+#define USHORT          u16
+#define UCHAR           u8
+
+#define BOOLEAN         u8
+//#define LARGE_INTEGER s64
+#define VOID            void
+#define LONG            int
+#define ULONGLONG       u64
+typedef VOID            *PVOID;
+typedef CHAR            *PCHAR;
+typedef UCHAR           *PUCHAR;
+typedef USHORT		*PUSHORT;
+typedef LONG            *PLONG;
+typedef ULONG           *PULONG;
+
+typedef union _LARGE_INTEGER {
+    struct {
+        ULONG LowPart;
+        LONG HighPart;
+    }vv;
+    struct {
+        ULONG LowPart;
+        LONG HighPart;
+    } u;
+    s64 QuadPart;
+} LARGE_INTEGER;
+
+#endif
+
+#define IN
+#define OUT
+
+#define TRUE        1
+#define FALSE       0
+
+#define ETH_LENGTH_OF_ADDRESS   6
+
+#define NDIS_STATUS                             INT
+#define NDIS_STATUS_SUCCESS                     0x00
+#define NDIS_STATUS_FAILURE                     0x01
+#define NDIS_STATUS_RESOURCES                   0x03
+#define NDIS_STATUS_MEDIA_DISCONNECT            0x04
+#define NDIS_STATUS_MEDIA_CONNECT               0x05
+#define NDIS_STATUS_RESET                     0x06
+
+
+//
+//	Hardware related header files
+//
+#include	"rt2570.h"
+#ifdef __BIG_ENDIAN
+#warning Compiling for big endian machine.
+#define BIG_ENDIAN
+#endif /* __BIG_ENDIAN */
+
+//
+//	Miniport defined header files
+//
+#include	"rtmp_type.h"
+#include	"rtmp_def.h"
+#include  "oid.h"
+#include	"mlme.h"
+#include  "md5.h"
+#include  "wpa.h"
+#include  "sha1.h"
+#include	"rt2570sw.h"
+//#include  "Stdincl.h"
+#include  "rtusb.h"
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#define rtusb_submit_urb(purb) usb_submit_urb(purb, GFP_ATOMIC) 
+#else
+#define rtusb_submit_urb(purb) usb_submit_urb(purb) 
+#endif
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,7))
+	#define usb_kill_urb  usb_unlink_urb
+#endif
+
+
+#define __BH
+#define RHEL
+ #ifndef KERNEL_VERSION
+#define KERNEL_VERSION(a,b,c) ((a)*65536+(b)*256+(c))
+#endif	// __RT_CONFIG_H__
+#ifndef USB_ST_NOERROR
+#define  USB_ST_NOERROR 0
+#endif
+#define INIT_FROM_EEPROM
+#define RT2570_DBG	1
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rtmp_ckipmic.h linux-2.4.35.3-mct/drivers/usb/rt2570/rtmp_ckipmic.h
--- linux-2.4.35.3/drivers/usb/rt2570/rtmp_ckipmic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rtmp_ckipmic.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,111 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	rtmp_tkipmic.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#ifndef	__RTMP_CKIPMIC_H__
+#define	__RTMP_CKIPMIC_H__
+
+typedef	struct	_MIC_CONTEXT	{
+	/* --- MMH context                            */
+	UCHAR		CK[16];				/* the key                                    */
+	UCHAR		coefficient[16];	/* current aes counter mode coefficients      */
+	ULONGLONG	accum;				/* accumulated mic, reduced to u32 in final() */
+	UINT		position;			/* current position (byte offset) in message  */
+	UCHAR		part[4];			/* for conversion of message to u32 for mmh   */
+}	MIC_CONTEXT, *PMIC_CONTEXT;
+
+VOID	CKIP_key_permute(
+	OUT	UCHAR	*PK,			/* output permuted key */
+	IN	UCHAR	*CK,			/* input CKIP key */
+	IN	UCHAR	toDsFromDs,		/* input toDs/FromDs bits */
+	IN	UCHAR	*piv);			/* input pointer to IV */
+
+VOID	RTMPCkipMicInit(    
+	IN	PMIC_CONTEXT		pContext,
+	IN	PUCHAR				CK);
+
+VOID RTMPMicUpdate(
+    IN  PMIC_CONTEXT        pContext, 
+    IN  PUCHAR              pOctets, 
+    IN  INT                 len);
+
+ULONG RTMPMicGetCoefficient(
+    IN  PMIC_CONTEXT         pContext);
+
+VOID xor_128(
+    IN  PUCHAR              a,
+    IN  PUCHAR              b,
+    OUT PUCHAR              out);
+
+UCHAR RTMPCkipSbox(
+    IN  UCHAR               a);
+
+VOID xor_32(
+    IN  PUCHAR              a,
+    IN  PUCHAR              b,
+    OUT PUCHAR              out);
+
+VOID next_key(
+    IN  PUCHAR              key,
+    IN  INT                 round);
+
+VOID byte_sub(
+    IN  PUCHAR              in,
+    OUT PUCHAR              out);
+
+VOID shift_row(
+    IN  PUCHAR              in,
+    OUT PUCHAR              out);
+
+VOID mix_column(
+    IN  PUCHAR              in,
+    OUT PUCHAR              out);
+
+VOID RTMPAesEncrypt(
+    IN  PUCHAR              key,
+    IN  PUCHAR              data,
+    IN  PUCHAR              ciphertext);
+
+VOID RTMPMicFinal(
+    IN  PMIC_CONTEXT        pContext,
+    OUT UCHAR               digest[4]);
+
+VOID RTMPCkipInsertMIC(
+    IN  PRT2570ADAPTER   pAdapter,
+    IN  PUCHAR          ptr,
+    IN  PUCHAR          ckip_pk,
+    IN  PUCHAR          mic_snap,
+    IN  INT             mic_snap_len,
+    IN  UINT            TxSize);
+
+#endif //__RTMP_CKIPMIC_H__
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rtmp_def.h linux-2.4.35.3-mct/drivers/usb/rt2570/rtmp_def.h
--- linux-2.4.35.3/drivers/usb/rt2570/rtmp_def.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rtmp_def.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,598 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	rtmp_def.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#ifndef __RTMP_DEF_H__
+#define __RTMP_DEF_H__
+
+//
+//  Debug information verbosity: lower values indicate higher urgency
+//
+#define RT_DEBUG_OFF        0
+#define RT_DEBUG_ERROR      1
+#define RT_DEBUG_WARN       2
+#define RT_DEBUG_TRACE      3
+#define RT_DEBUG_INFO       4
+#define RT_DEBUG_LOUD       5
+#define RT_DEBUG_TEMP       3
+#define RT_DEBUG_CNTL       1
+#define RT_DEBUG_ADHOC       3
+
+#define NIC_TAG             ((ULONG)'0752')
+#define NIC_DBG_STRING      "RTUSB  "
+
+//
+// update the driver version number every time you release a new driver
+// The high word is the major version. The low word is the minor version.
+//
+#define NIC_VENDOR_DRIVER_VERSION   0x00010001
+
+//
+// NDIS version in use by the NIC driver.
+// The high byte is the major version. The low byte is the minor version.
+//
+#ifdef  NDIS51_MINIPORT
+#define NIC_DRIVER_VERSION      0x0501
+#else
+#define NIC_DRIVER_VERSION      0x0500
+#endif
+
+//
+// NDIS media type, current is ethernet, change if native wireless supported
+//
+#define NIC_MEDIA_TYPE          NdisMedium802_3
+#define NIC_PCI_HDR_LENGTH      0xe2
+#define NIC_MAX_PACKET_SIZE     2304
+#define NIC_HEADER_SIZE         14
+
+
+
+//
+// Entry number for each DMA descriptor ring
+//
+//blue,#define TX_RING_SIZE            16
+#define TX_RING_SIZE            32
+//blue,#define ATIM_RING_SIZE          4
+#define PRIO_RING_SIZE          32   
+//#define RX_RING_SIZE            1
+#define RX_RING_SIZE            8
+#define	BEACON_RING_SIZE		2
+//blue,#define DESCRIPTOR_REQUIRED     ((TX_RING_SIZE) + (ATIM_RING_SIZE) + (PRIO_RING_SIZE) + (RX_RING_SIZE) + (BEACON_RING_SIZE))
+#define	MGMT_RING_SIZE			32
+//blue,#define RING_DESCRIPTOR_SIZE    48
+//steven:for test#define TX_BUFFER_SIZE          2048
+#define PRIO_BUFFER_SIZE        1024  // 2048
+//steven:for test#define RX_BUFFER_SIZE          2064	//2048
+//blue,#define BUFFER_SIZE				2064	//2048
+#define BUFFER_SIZE				2400	//2048
+//blue,#define ATIM_BUFFER_SIZE        2048
+//blue,#define BEACON_BUFFER_SIZE      2048
+#define	MAX_FRAME_SIZE			2346					// Maximum 802.11 frame size
+#define ALLOC_RX_PACKET_POOL    (RX_RING_SIZE)
+#define ALLOC_RX_BUFFER_POOL    (ALLOC_RX_PACKET_POOL)
+#define	TX_RING					0xa
+#define	ATIM_RING				0xb
+#define	PRIO_RING				0xc
+#define	RX_RING					0xd
+#define	BEACON_RING				0xe
+#define	NULL_RING				0xf
+#define	MAX_TX_PROCESS			2
+#define	MAX_RX_PROCESS			4
+#define	MAX_CLIENT				4
+#define	MAX_MCAST_LIST_SIZE		32
+
+//  RTMP_ADAPTER flags
+//#define fRTMP_ADAPTER_MAP_REGISTER          0x00000001
+//#define fRTMP_ADAPTER_INTERRUPT_IN_USE      0x00000002
+#define	fRTMP_ADAPTER_TEST_MODE				0x00000001//blue
+#define fRTMP_ADAPTER_MLME_RESET_IN_PROGRESS     0x00000002 //blue
+#define fRTMP_ADAPTER_HARDWARE_ERROR        0x00000004
+#define fRTMP_ADAPTER_SEND_PACKET_ERROR     0x00000010
+#define fRTMP_ADAPTER_RECEIVE_PACKET_ERROR  0x00000020
+#define fRTMP_ADAPTER_HALT_IN_PROGRESS      0x00000040
+#define fRTMP_ADAPTER_RESET_IN_PROGRESS     0x00000080
+#define fRTMP_ADAPTER_REMOVE_IN_PROGRESS    0x00000100
+#define fRTMP_ADAPTER_TX_RING_ALLOCATED     0x00000200
+#define fRTMP_ADAPTER_ATIM_RING_ALLOCATED   0x00000400
+#define fRTMP_ADAPTER_PRIO_RING_ALLOCATED   0x00000800
+#define fRTMP_ADAPTER_RX_RING_ALLOCATED     0x00001000
+#define fRTMP_ADAPTER_BSS_JOIN_IN_PROGRESS  0x00002000
+#define fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS  0x00004000
+#define	fRTMP_ADAPTER_REASSOC_IN_PROGRESS	0x00008000
+#define	fRTMP_ADAPTER_MEDIA_STATE_PENDING	0x00010000
+#define	fRTMP_ADAPTER_RADIO_OFF				0x00020000
+#define	fRTMP_ADAPTER_BULKOUT_RESET			0x00100000
+#define	fRTMP_ADAPTER_BULKIN_RESET			0x00200000
+#define fRTMP_ADAPTER_RESET_DATA_SW_QUEUE   0x00400000
+#define fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS    0x00800000
+#define fRTMP_ADAPTER_SCAN_CHANNEL_IN_PROGRESS 0x01000000
+#ifdef RALINK_ATE
+#define	fRTMP_ADAPTER_ATE_START_TX			0x01000000
+#define	fRTMP_ADAPTER_ATE_START_TX_CARRIER	0x02000000
+#define	fRTMP_ADAPTER_ATE_START_RX			0x04000000
+#endif
+
+// Lock bit for accessing different ring buffers
+#define fRTMP_ADAPTER_TX_RING_BUSY      	0x80000000
+#define fRTMP_ADAPTER_PRIO_RING_BUSY      	0x40000000
+#define fRTMP_ADAPTER_ATIM_RING_BUSY      	0x20000000
+#define fRTMP_ADAPTER_RX_RING_BUSY      	0x10000000
+
+// Lock bit for accessing different queue
+#define	fRTMP_ADAPTER_TX_QUEUE_BUSY      	0x08000000
+#define	fRTMP_ADAPTER_PRIO_QUEUE_BUSY      	0x04000000
+
+//
+// Flags for Bulkflags control for bulk out data
+//
+#define	fRTUSB_BULK_OUT_DATA_NULL			0x00000001
+#define	fRTUSB_BULK_OUT_DATA_NORMAL			0x00000002
+#define	fRTUSB_BULK_OUT_MLME				0x00000004
+#define	fRTUSB_BULK_OUT_BEACON_1			0x00000008
+#define	fRTUSB_BULK_OUT_BEACON_0			0x00000010
+#define	fRTUSB_BULK_OUT_PSPOLL				0x00000020
+#define	fRTUSB_BULK_OUT_DATA_FRAG			0x00000040
+
+//
+// Error code section
+//
+// NDIS_ERROR_CODE_ADAPTER_NOT_FOUND
+#define ERRLOG_READ_PCI_SLOT_FAILED     0x00000101L
+#define ERRLOG_WRITE_PCI_SLOT_FAILED    0x00000102L
+#define ERRLOG_VENDOR_DEVICE_NOMATCH    0x00000103L
+
+// NDIS_ERROR_CODE_ADAPTER_DISABLED
+#define ERRLOG_BUS_MASTER_DISABLED      0x00000201L
+
+// NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION
+#define ERRLOG_INVALID_SPEED_DUPLEX     0x00000301L
+#define ERRLOG_SET_SECONDARY_FAILED     0x00000302L
+
+// NDIS_ERROR_CODE_OUT_OF_RESOURCES
+#define ERRLOG_OUT_OF_MEMORY            0x00000401L
+#define ERRLOG_OUT_OF_SHARED_MEMORY     0x00000402L
+#define ERRLOG_OUT_OF_MAP_REGISTERS     0x00000403L
+#define ERRLOG_OUT_OF_BUFFER_POOL       0x00000404L
+#define ERRLOG_OUT_OF_NDIS_BUFFER       0x00000405L
+#define ERRLOG_OUT_OF_PACKET_POOL       0x00000406L
+#define ERRLOG_OUT_OF_NDIS_PACKET       0x00000407L
+#define ERRLOG_OUT_OF_LOOKASIDE_MEMORY  0x00000408L
+
+// NDIS_ERROR_CODE_HARDWARE_FAILURE
+#define ERRLOG_SELFTEST_FAILED          0x00000501L
+#define ERRLOG_INITIALIZE_ADAPTER       0x00000502L
+#define ERRLOG_REMOVE_MINIPORT          0x00000503L
+
+// NDIS_ERROR_CODE_RESOURCE_CONFLICT
+#define ERRLOG_MAP_IO_SPACE             0x00000601L
+#define ERRLOG_QUERY_ADAPTER_RESOURCES  0x00000602L
+#define ERRLOG_NO_IO_RESOURCE           0x00000603L
+#define ERRLOG_NO_INTERRUPT_RESOURCE    0x00000604L
+#define ERRLOG_NO_MEMORY_RESOURCE       0x00000605L
+
+
+
+//============================================================
+// Length definitions
+#define PEER_KEY_NO                       2
+#define CRC_LEN                           4
+#define MAC_ADDR_LEN                      6
+#define TIMESTAMP_LEN                     8
+#define MAX_LEN_OF_SUPPORTED_RATES        12    // 1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54
+#define MAX_NUM_OF_POWER_LEVEL            8
+#define MAX_NUM_OF_DOMAIN                 8
+#define MAX_LEN_OF_KEY                    32      // 32 octets == 256 bits, Redefine for WPA
+#define MAX_LEN_OF_CHANNELS               42      // 14 channels @2.4G +  12@UNII + 4 @MMAC + 11 @HiperLAN2 + 1 as NULL termination
+#define MAX_LEN_OF_PEER_KEY               16
+#define MAC_HDR_LEN                       24
+#define MAX_LEN_OF_MANUFACTURE_ID         32
+#define MAX_LEN_OF_PRODUCT_ID             32
+#define MAX_LEN_OF_MAC_TABLE              32
+#define MAX_LEN_OF_SSID                   32
+#define CIPHER_TEXT_LEN                   128
+#define HASH_TABLE_SIZE                   256
+#define MAX_LEN_OF_MLME_BUFFER            512
+#define MAX_FRAME_LEN                     2338
+#define	MAX_VIE_LEN                       128	// New for WPA cipher suite variable IE sizes.
+#define MAX_MLME_HANDLER_MEMORY           20    //each them cantains  MAX_LEN_OF_MLME_BUFFER size 
+#define MAX_INI_BUFFER_SIZE               4096
+
+#define MAX_TX_POWER_LEVEL                100   /* mW */
+#define MAX_RSSI_TRIGGER                 -10    /* dBm */
+#define MIN_RSSI_TRIGGER                 -200   /* dBm */
+#define MAX_FRAG_THRESHOLD                2346  /* byte count */
+#define MIN_FRAG_THRESHOLD                256   /* byte count */
+#define MAX_RTS_THRESHOLD                 2347  /* byte count */
+
+// key related definitions
+#define SHARE_KEY_NO                      4
+#define MAX_LEN_OF_SHARE_KEY              16
+#define PAIRWISE_KEY_NO                   4
+#define GROUP_KEY_NO                      4
+#define	PMKID_NO							4	// Number of PMKID saved supported
+
+// power status related definitions
+#define PWR_ACTIVE                        0
+#define PWR_SAVE                          1
+#define PWR_UNKNOWN                       2
+
+// Auth and Assoc mode related definitions
+#define AUTH_MODE                         0x10
+#define ASSOC_MODE                        0x20
+
+#define AUTH_MODE_OPEN                    0x00
+#define AUTH_MODE_SHARED                  0x01
+#define AUTH_MODE_AUTO_SWITCH             0x03
+#define AUTH_MODE_DEAUTH                  0x04
+#define AUTH_MODE_UPLAYER                 0x05 // reserved for 802.11i use
+
+#define ASSOC_MODE_DISASSOC               0x04
+#define ASSOC_MODE_ASSOC                  0x05
+
+// BSS Type definitions
+#define BSS_INDEP                         0  // = Ndis802_11IBSS
+#define BSS_INFRA                         1  // = Ndis802_11Infrastructure
+#define BSS_ANY                           2  // = Ndis802_11AutoUnknown
+#define BSS_MONITOR                       3  // = RMFON MODE
+
+// #define BSS_UNKNOWN                       0xff
+
+
+// WEP related definitions
+// #define WEP_DISABLE                       0
+// #define WEP_ENABLE                        1
+// #define WEP_KEY_ABSENT                    2
+// #define WEP_NOT_SUPPORTED                 3
+
+// value of FrameDesc.priority
+// #define PRIO_CONTENTION                   0
+// #define PRIO_CONTENTION_FREE              1
+
+// value of auth_algorithm in Authentication frame body
+
+// Reason code definitions
+#define REASON_RESERVED                   0
+#define REASON_UNSPECIFY                  1
+#define REASON_NO_LONGER_VALID            2
+#define REASON_DEAUTH_STA_LEAVING         3
+#define REASON_DISASSOC_INACTIVE          4
+#define REASON_DISASSPC_AP_UNABLE         5
+#define REASON_CLS2ERR                    6
+#define REASON_CLS3ERR                    7
+#define REASON_DISASSOC_STA_LEAVING       8
+#define REASON_STA_REQ_ASSOC_NOT_AUTH     9
+#define	REASON_INVALID_IE                 13
+#define	REASON_MIC_FAILURE                14
+#define	REASON_4_WAY_HANDSHAKE_TIMEOUT    15
+#define	REASON_GROUP_KEY_UPDATE_TIMEOUT   16
+
+// Status code definitions
+#define MLME_SUCCESS                      0
+#define MLME_UNSPECIFY_FAIL               1
+#define MLME_CANNOT_SUPPORT_CAP           10
+#define MLME_REASSOC_DENY_ASSOC_EXIST     11 
+#define MLME_ASSOC_DENY_OUT_SCOPE         12
+#define MLME_ALG_NOT_SUPPORT              13
+#define MLME_SEQ_NR_OUT_OF_SEQUENCE       14
+#define MLME_REJ_CHALLENGE_FAILURE        15
+#define MLME_REJ_TIMEOUT                  16
+#define MLME_ASSOC_REJ_UNABLE_HANDLE_STA  17
+#define MLME_ASSOC_REJ_DATA_RATE          18
+
+#define MLME_ASSOC_REJ_NO_EXT_RATE        22
+#define MLME_ASSOC_REJ_NO_EXT_RATE_PBCC   23
+#define MLME_ASSOC_REJ_NO_CCK_OFDM        24
+
+#define MLME_INVALID_FORMAT               0x51
+#define MLME_FAIL_NO_RESOURCE             0x52
+#define MLME_STATE_MACHINE_REJECT         0x53
+#define MLME_MAC_TABLE_FAIL               0x54
+
+//IE code
+#define IE_SSID                           0
+#define IE_SUPP_RATES                     1
+#define IE_FH_PARM                        2
+#define IE_DS_PARM                        3
+#define IE_CF_PARM                        4
+#define IE_TIM                            5
+#define IE_IBSS_PARM                      6
+#define IE_COUNTRY                        7     // 802.11d
+#define IE_802_11D_REQUEST                10    // 802.11d
+#define IE_CHALLENGE_TEXT                 16
+#define IE_POWER_CONSTRAINT               32    // 802.11h d3.3
+#define IE_POWER_CAPABILITY               33    // 802.11h d3.3
+#define IE_TPC_REQUEST                    34    // 802.11h d3.3
+#define IE_TPC_REPORT                     35    // 802.11h d3.3
+#define IE_SUPP_CHANNELS                  36    // 802.11h d3.3
+#define IE_CHANNEL_SWITCH_ANNOUNCEMENT    37    // 802.11h d3.3
+#define IE_MEASUREMENT_REQUEST            38    // 802.11h d3.3
+#define IE_MEASUREMENT_REPORT             39    // 802.11h d3.3
+#define IE_QUIET                          40    // 802.11h d3.3
+#define IE_IBSS_DFS                       41    // 802.11h d3.3
+#define IE_ERP                            42    // 802.11g
+#define IE_EXT_SUPP_RATES                 50    // 802.11g
+#define IE_WPA                            221   // WPA
+#define IE_RSN                            48    // 802.11i d3.0
+
+#define CNTL_FUNC_SIZE                    1
+
+// Message type for the MLME state machine
+// Messages for Associate state machine
+#define ASSOC_MACHINE_BASE          0
+
+#define MT2_MLME_ASSOC_REQ          0
+#define MT2_MLME_REASSOC_REQ        1
+#define MT2_MLME_DISASSOC_REQ       2  
+#define MT2_PEER_DISASSOC_REQ       3
+#define MT2_PEER_ASSOC_REQ          4
+#define MT2_PEER_ASSOC_RSP          5
+#define MT2_PEER_REASSOC_REQ        6
+#define MT2_PEER_REASSOC_RSP        7
+//#define MT2_CLS3ERR                 8
+#define MT2_DISASSOC_TIMEOUT        8
+#define MT2_ASSOC_TIMEOUT           9
+#define MT2_REASSOC_TIMEOUT         10
+
+#define MAX_ASSOC_MSG               11
+
+// Messages for Authentication state machine
+#define AUTH_MACHINE_BASE           11
+
+#define MT2_MLME_AUTH_REQ           11
+//#define MT2_MLME_DEAUTH_REQ         12
+//#define MT2_CLS2ERR                 13
+#define MT2_PEER_AUTH_EVEN          14
+#define MT2_AUTH_TIMEOUT            15
+
+#define MAX_AUTH_MSG                 5
+
+// Messages for authentication response state machine
+#define AUTH_RSP_MACHINE_BASE       16
+
+#define MT2_AUTH_CHALLENGE_TIMEOUT  16
+#define MT2_PEER_AUTH_ODD           17
+#define MT2_PEER_DEAUTH             18
+
+#define MAX_AUTH_RSP_MSG             3
+
+// Messages for the sync state machine
+#define SYNC_MACHINE_BASE           19
+
+#define MT2_MLME_SCAN_REQ           19
+#define MT2_MLME_JOIN_REQ           20
+#define MT2_MLME_START_REQ          21
+#define MT2_PEER_BEACON             22
+#define MT2_PEER_PROBE_RSP          23
+#define MT2_PEER_ATIM               24
+#define MT2_SCAN_TIMEOUT            25
+#define MT2_BEACON_TIMEOUT          26
+#define MT2_ATIM_TIMEOUT            27
+#define MT2_PEER_PROBE_REQ          28
+
+#define MAX_SYNC_MSG                10
+
+// MIB access
+#define MT2_GET_REQ                 31
+#define MT2_SET_REQ                 32
+#define MT2_RESET_REQ               33
+
+// Confirm message
+#define MT2_ASSOC_CONF              34
+#define MT2_AUTH_CONF               35
+#define MT2_DEAUTH_CONF             36
+#define MT2_DISASSOC_CONF           37
+#define MT2_REASSOC_CONF            38
+#define MT2_PWR_MGMT_CONF           39
+#define MT2_JOIN_CONF               40
+#define MT2_SCAN_CONF               41
+#define MT2_START_CONF              42
+#define MT2_GET_CONF                43
+#define MT2_SET_CONF                44
+#define MT2_RESET_CONF              45
+
+// Indication message
+#define MT2_DEAUTH_IND              46
+#define MT2_ASSOC_IND               47
+#define MT2_DISASSOC_IND            48
+#define MT2_REASSOC_IND             49
+#define MT2_AUTH_IND                50
+
+#define MT2_SCAN_END_CONF           51  // For scan end
+#define MT2_MLME_ROAMING_REQ        52
+
+/* #define TXSTATUS_SUCCESS                0 */
+/* #define TXSTATUS_FAIL_RETRY_LIMIT       1 */
+/* #define TXSTATUS_EXCESSIVE_LENGTH       2 */
+/* #define TXSTATUS_NON_NULL_SOURCE_ROUTE  3 */
+/* #define TXSTATUS_UNSUPPORTED_PRIORITY   4 */
+/* #define TXSTATUS_UNSUPPORTED_SERVICE    5 */
+/* #define TXSTATUS_UNAVAILABLE_PRIORITY   6   // CF with no PC available; down-grade to contention */
+/* #define TXSTATUS_UNAVAILABLE_SERVICE    7   // strictly-ordered but STA isn't active */
+/* #define TXSTATUS_FAIL_LIFE_TIME         8 */
+/* #define TXSTATUS_FAIL_NOBSS             9 */
+/* #define TXSTATUS_FAIL_NULL_KEY          10 */
+
+// value domain of MacHdr.tyte, which is b3..b2 of the 1st-byte of MAC header
+#define BTYPE_MGMT              0   // 00
+#define BTYPE_CNTL              1   // 01
+#define BTYPE_DATA              2   // 10
+
+// value domain of MacHdr.subtype, which is b7..4 of the 1st-byte of MAC header
+// Management frame
+#define SUBTYPE_ASSOC_REQ       0
+#define SUBTYPE_ASSOC_RSP       1
+#define SUBTYPE_REASSOC_REQ     2
+#define SUBTYPE_REASSOC_RSP     3
+#define SUBTYPE_PROBE_REQ       4
+#define SUBTYPE_PROBE_RSP       5
+#define SUBTYPE_BEACON          8
+#define SUBTYPE_ATIM            9
+#define SUBTYPE_DISASSOC        10
+#define SUBTYPE_AUTH            11
+#define SUBTYPE_DEAUTH          12
+#define SUBTYPE_ACTION          13
+
+// Control Frame
+#define SUBTYPE_BLOCK_ACK_REQ   8
+#define SUBTYPE_BLOCK_ACK       9
+#define SUBTYPE_PS_POLL         10
+#define SUBTYPE_RTS             11  // 1011
+#define SUBTYPE_CTS             12  // 1100
+#define SUBTYPE_ACK             13  // 1101
+#define SUBTYPE_CFEND           14
+#define SUBTYPE_CFEND_CFACK     15
+
+// Data Frame
+#define SUBTYPE_DATA                0
+#define SUBTYPE_DATA_CFACK          1
+#define SUBTYPE_DATA_CFPOLL         2
+#define SUBTYPE_DATA_CFACK_CFPOLL   3
+#define SUBTYPE_NULL_FUNC           4
+#define SUBTYPE_CFACK               5  // 0101
+#define SUBTYPE_CFPOLL              6
+#define SUBTYPE_CFACK_CFPOLL        7
+#define SUBTYPE_QDATA               8
+#define SUBTYPE_QDATA_CFACK         9
+#define SUBTYPE_QDATA_CFPOLL        10
+#define SUBTYPE_QDATA_CFACK_CFPOLL  11
+#define SUBTYPE_QOS_NULL            12
+#define SUBTYPE_QOS_CFACK           13
+#define SUBTYPE_QOS_CFPOLL          14
+#define SUBTYPE_QOS_CFACK_CFPOLL    15
+
+#define ASSOC_STATE_MACHINE        1
+#define AUTH_STATE_MACHINE         2
+#define AUTH_RSP_STATE_MACHINE     3
+#define SYNC_STATE_MACHINE         4
+#define MLME_CNTL_STATE_MACHINE    5
+#define WPA_PSK_STATE_MACHINE       6 //red, add for WPA-PSK
+
+//
+// rtmp_data.c use these definition
+//
+#define	LENGTH_802_11			24
+#define	LENGTH_802_11_AND_H		30
+#define	LENGTH_802_11_CRC_H		34
+#define	LENGTH_802_11_CRC		28
+#define	LENGTH_802_3			14
+#define LENGTH_802_3_TYPE		2
+#define LENGTH_802_1_H			8
+#define LENGTH_EAPOL_H          	4
+#define	LENGTH_CRC				4
+#define	MAX_SEQ_NUMBER			0x0fff
+
+#define	SUCCESS_WITHOUT_RETRY	0
+#define	SUCCESS_WITH_RETRY		1
+#define	FAIL_RETRY_LIMIT		2
+#define	FAIL_INVALID			3
+#define	FAIL_OTHER				4
+
+#define	RATE_1					0
+#define	RATE_2					1
+#define	RATE_5_5				2
+#define	RATE_11					3
+#define RATE_6                  4   // OFDM
+#define RATE_9                  5   // OFDM
+#define RATE_12                 6   // OFDM
+#define RATE_18                 7   // OFDM
+#define RATE_24                 8   // OFDM
+#define RATE_36                 9   // OFDM
+#define RATE_48                 10  // OFDM
+#define RATE_54                 11  // OFDM
+#define RATE_72                 12
+#define RATE_100                13
+#define RATE_FIRST_OFDM_RATE    RATE_6
+#define RATE_AUTO_SWITCH        255 // for PortCfg.FixedTxRate only
+
+#define	IFS_BACKOFF				0
+#define	IFS_SIFS				1
+#define	IFS_NEW_BACKOFF			2
+#define	IFS_NONE				3
+
+#define	LONG_RETRY				1
+#define	SHORT_RETRY				0
+
+// Country Region definition
+#define REGION_MIN              0
+#define	REGION_FCC				0		// 1-11
+#define	REGION_IC				1		// 1-11
+#define	REGION_ETSI				2		// 1-13
+#define	REGION_SPAIN			3		// 10-11
+#define	REGION_FRANCE			4		// 10-13
+#define	REGION_MKK				5		// 14
+#define	REGION_MKK1				6		// 1-14
+#define	REGION_ISRAEL			7		// 3-9
+#define REGION_MAX              REGION_ISRAEL
+
+#define	CIPHER_NONE				0
+#define	CIPHER_WEP64			1
+#define	CIPHER_WEP128			2
+#define	CIPHER_TKIP				3
+#define	CIPHER_AES				4
+
+// Stall execution time for ndisdpracquires[inlock in miniportReset function
+#define	WAIT_TIME_FOR_SPINLOCK	10		// usec
+
+// value domain for pAdapter->PortCfg.RfType
+#define RFIC_2522               0
+#define RFIC_2523               1
+#define RFIC_2524               2
+#define RFIC_2525               3
+#if 0//steven:modified by brand,blue
+#define RFIC_2525E              4
+#else
+#define RFIC_2525E              5
+#endif
+#define RFIC_5222               16
+// This chip is same as RT2526, it's for 11b only purpose
+#define	RFIC_2426				6
+
+// value domain for pAdapter->PortCfg.LedMode and E2PROM
+#define LED_MODE_DEFAULT        0
+#define LED_MODE_TXRX_ACTIVITY  1
+#define	LED_MODE_SINGLE			2		// Single LED mode, driver lid the LED as soon as driver up & enable tx activity right away
+#define	LED_MODE_ASUS			3		// Two LED modes, bit 16 acts as LED_MODE_SINGLE, bit 17 acts as RADIO status.
+#define	LED_MODE_ALPHA			4		// Two LED modes, bit 16 acts as LED_MODE_SINGLE, bit 17 acts as RADIO status.
+
+// RC4 init value, used fro WEP & TKIP
+#define PPPINITFCS32  0xffffffff   /* Initial FCS value */
+
+// 802.1X controlled port definition
+#define	WPA_802_1X_PORT_SECURED			1
+#define	WPA_802_1X_PORT_NOT_SECURED		2
+
+#define	PAIRWISE_KEY			1
+#define	GROUP_KEY				2
+
+#define MAX_PACKETS_IN_QUEUE        100
+#endif  // __RTMP_DEF_H__
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rtmp_tkip.c linux-2.4.35.3-mct/drivers/usb/rt2570/rtmp_tkip.c
--- linux-2.4.35.3/drivers/usb/rt2570/rtmp_tkip.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rtmp_tkip.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,1127 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	rtmp_tkip.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#include	"rt_config.h"
+
+// Rotation functions on 32 bit values 
+#define ROL32( A, n ) \
+	( ((A) << (n)) | ( ((A)>>(32-(n))) & ( (1UL << (n)) - 1 ) ) ) 
+#define ROR32( A, n ) ROL32( (A), 32-(n) ) 
+
+UINT Tkip_Sbox_Lower[256] = 
+{ 
+	0xA5,0x84,0x99,0x8D,0x0D,0xBD,0xB1,0x54, 
+	0x50,0x03,0xA9,0x7D,0x19,0x62,0xE6,0x9A, 
+	0x45,0x9D,0x40,0x87,0x15,0xEB,0xC9,0x0B, 
+	0xEC,0x67,0xFD,0xEA,0xBF,0xF7,0x96,0x5B, 
+	0xC2,0x1C,0xAE,0x6A,0x5A,0x41,0x02,0x4F, 
+	0x5C,0xF4,0x34,0x08,0x93,0x73,0x53,0x3F, 
+	0x0C,0x52,0x65,0x5E,0x28,0xA1,0x0F,0xB5, 
+	0x09,0x36,0x9B,0x3D,0x26,0x69,0xCD,0x9F, 
+	0x1B,0x9E,0x74,0x2E,0x2D,0xB2,0xEE,0xFB, 
+	0xF6,0x4D,0x61,0xCE,0x7B,0x3E,0x71,0x97, 
+	0xF5,0x68,0x00,0x2C,0x60,0x1F,0xC8,0xED, 
+	0xBE,0x46,0xD9,0x4B,0xDE,0xD4,0xE8,0x4A, 
+	0x6B,0x2A,0xE5,0x16,0xC5,0xD7,0x55,0x94, 
+	0xCF,0x10,0x06,0x81,0xF0,0x44,0xBA,0xE3, 
+	0xF3,0xFE,0xC0,0x8A,0xAD,0xBC,0x48,0x04, 
+	0xDF,0xC1,0x75,0x63,0x30,0x1A,0x0E,0x6D, 
+	0x4C,0x14,0x35,0x2F,0xE1,0xA2,0xCC,0x39, 
+	0x57,0xF2,0x82,0x47,0xAC,0xE7,0x2B,0x95, 
+	0xA0,0x98,0xD1,0x7F,0x66,0x7E,0xAB,0x83, 
+	0xCA,0x29,0xD3,0x3C,0x79,0xE2,0x1D,0x76, 
+	0x3B,0x56,0x4E,0x1E,0xDB,0x0A,0x6C,0xE4, 
+	0x5D,0x6E,0xEF,0xA6,0xA8,0xA4,0x37,0x8B, 
+	0x32,0x43,0x59,0xB7,0x8C,0x64,0xD2,0xE0, 
+	0xB4,0xFA,0x07,0x25,0xAF,0x8E,0xE9,0x18, 
+	0xD5,0x88,0x6F,0x72,0x24,0xF1,0xC7,0x51, 
+	0x23,0x7C,0x9C,0x21,0xDD,0xDC,0x86,0x85, 
+	0x90,0x42,0xC4,0xAA,0xD8,0x05,0x01,0x12, 
+	0xA3,0x5F,0xF9,0xD0,0x91,0x58,0x27,0xB9, 
+	0x38,0x13,0xB3,0x33,0xBB,0x70,0x89,0xA7, 
+	0xB6,0x22,0x92,0x20,0x49,0xFF,0x78,0x7A, 
+	0x8F,0xF8,0x80,0x17,0xDA,0x31,0xC6,0xB8, 
+	0xC3,0xB0,0x77,0x11,0xCB,0xFC,0xD6,0x3A 
+};
+
+UINT Tkip_Sbox_Upper[256] = 
+{ 
+	0xC6,0xF8,0xEE,0xF6,0xFF,0xD6,0xDE,0x91, 
+	0x60,0x02,0xCE,0x56,0xE7,0xB5,0x4D,0xEC, 
+	0x8F,0x1F,0x89,0xFA,0xEF,0xB2,0x8E,0xFB, 
+	0x41,0xB3,0x5F,0x45,0x23,0x53,0xE4,0x9B, 
+	0x75,0xE1,0x3D,0x4C,0x6C,0x7E,0xF5,0x83, 
+	0x68,0x51,0xD1,0xF9,0xE2,0xAB,0x62,0x2A, 
+	0x08,0x95,0x46,0x9D,0x30,0x37,0x0A,0x2F, 
+	0x0E,0x24,0x1B,0xDF,0xCD,0x4E,0x7F,0xEA, 
+	0x12,0x1D,0x58,0x34,0x36,0xDC,0xB4,0x5B, 
+	0xA4,0x76,0xB7,0x7D,0x52,0xDD,0x5E,0x13, 
+	0xA6,0xB9,0x00,0xC1,0x40,0xE3,0x79,0xB6, 
+	0xD4,0x8D,0x67,0x72,0x94,0x98,0xB0,0x85, 
+	0xBB,0xC5,0x4F,0xED,0x86,0x9A,0x66,0x11, 
+	0x8A,0xE9,0x04,0xFE,0xA0,0x78,0x25,0x4B, 
+	0xA2,0x5D,0x80,0x05,0x3F,0x21,0x70,0xF1, 
+	0x63,0x77,0xAF,0x42,0x20,0xE5,0xFD,0xBF, 
+	0x81,0x18,0x26,0xC3,0xBE,0x35,0x88,0x2E, 
+	0x93,0x55,0xFC,0x7A,0xC8,0xBA,0x32,0xE6, 
+	0xC0,0x19,0x9E,0xA3,0x44,0x54,0x3B,0x0B, 
+	0x8C,0xC7,0x6B,0x28,0xA7,0xBC,0x16,0xAD, 
+	0xDB,0x64,0x74,0x14,0x92,0x0C,0x48,0xB8, 
+	0x9F,0xBD,0x43,0xC4,0x39,0x31,0xD3,0xF2, 
+	0xD5,0x8B,0x6E,0xDA,0x01,0xB1,0x9C,0x49, 
+	0xD8,0xAC,0xF3,0xCF,0xCA,0xF4,0x47,0x10, 
+	0x6F,0xF0,0x4A,0x5C,0x38,0x57,0x73,0x97, 
+	0xCB,0xA1,0xE8,0x3E,0x96,0x61,0x0D,0x0F, 
+	0xE0,0x7C,0x71,0xCC,0x90,0x06,0xF7,0x1C, 
+	0xC2,0x6A,0xAE,0x69,0x17,0x99,0x3A,0x27, 
+	0xD9,0xEB,0x2B,0x22,0xD2,0xA9,0x07,0x33, 
+	0x2D,0x3C,0x15,0xC9,0x87,0xAA,0x50,0xA5, 
+	0x03,0x59,0x09,0x1A,0x65,0xD7,0x84,0xD0, 
+	0x82,0x29,0x5A,0x1E,0x7B,0xA8,0x6D,0x2C 
+}; 
+
+//
+// Expanded IV for TKIP function.
+//
+
+typedef	struct	_IV_CONTROL_
+{
+	union
+	{
+		struct 
+		{
+			UCHAR		rc0;
+			UCHAR		rc1;
+			UCHAR		rc2;
+
+			union
+			{
+				struct
+				{
+					UCHAR	Rsvd:5;
+					UCHAR	ExtIV:1;
+					UCHAR	KeyID:2;
+				}	field;
+				UCHAR		Byte;
+			}	CONTROL;
+		}	field;
+		
+		ULONG	word;
+	}	IV16;
+	
+	ULONG	IV32;
+}	TKIP_IV, *PTKIP_IV;
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Convert from UCHAR[] to ULONG in a portable way 
+		
+	Arguments:
+      pMICKey		pointer to MIC Key
+		
+	Return Value:
+		None
+
+	Note:
+		
+	========================================================================
+*/
+ULONG	RTMPTkipGetUInt32( 	
+	IN	PUCHAR	pMICKey)
+{  	
+	ULONG	res = 0; 
+	int		i;
+	
+	for (i = 0; i < 4; i++) 
+	{ 
+		res |= (*pMICKey++) << (8 * i); 
+	}
+
+	return res; 
+} 
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Convert from ULONG to UCHAR[] in a portable way 
+		
+	Arguments:
+      pDst			pointer to destination for convert ULONG to UCHAR[]
+      val			the value for convert
+		
+	Return Value:
+		None
+
+	IRQL = DISPATCH_LEVEL
+	
+	Note:
+		
+	========================================================================
+*/
+VOID	RTMPTkipPutUInt32(
+	IN OUT	PUCHAR		pDst,
+	IN		ULONG		val)					  
+{ 	
+	int i;
+	
+	for(i = 0; i < 4; i++) 
+	{ 
+		*pDst++ = (UCHAR) (val & 0xff); 
+		val >>= 8; 
+	} 
+} 
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Set the MIC Key.
+		
+	Arguments:
+      pAdapter		Pointer to our adapter
+      pMICKey		pointer to MIC Key
+		
+	Return Value:
+		None
+
+	IRQL = DISPATCH_LEVEL
+	
+	Note:
+		
+	========================================================================
+*/
+VOID RTMPTkipSetMICKey(  
+	IN	PTKIP_KEY_INFO	pTkip,	
+	IN	PUCHAR			pMICKey)
+{ 
+	// Set the key 
+	pTkip->K0 = RTMPTkipGetUInt32(pMICKey); 
+	pTkip->K1 = RTMPTkipGetUInt32(pMICKey + 4); 
+	// and reset the message 
+	pTkip->L = pTkip->K0;
+	pTkip->R = pTkip->K1;
+	pTkip->nBytesInM = 0;
+	pTkip->M = 0;
+} 
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Calculate the MIC Value.
+		
+	Arguments:
+      pAdapter		Pointer to our adapter
+      uChar			Append this uChar
+		
+	Return Value:
+		None
+
+	IRQL = DISPATCH_LEVEL
+	
+	Note:
+		
+	========================================================================
+*/
+VOID	RTMPTkipAppendByte( 
+	IN	PTKIP_KEY_INFO	pTkip,	
+	IN	UCHAR 			uChar)
+{ 
+	// Append the byte to our word-sized buffer 
+	pTkip->M |= (uChar << (8* pTkip->nBytesInM)); 
+	pTkip->nBytesInM++; 
+	// Process the word if it is full. 
+	if( pTkip->nBytesInM >= 4 ) 
+	{ 
+		pTkip->L ^= pTkip->M; 
+		pTkip->R ^= ROL32( pTkip->L, 17 ); 
+		pTkip->L += pTkip->R; 
+		pTkip->R ^= ((pTkip->L & 0xff00ff00) >> 8) | ((pTkip->L & 0x00ff00ff) << 8); 
+		pTkip->L += pTkip->R; 
+		pTkip->R ^= ROL32( pTkip->L, 3 ); 
+		pTkip->L += pTkip->R; 
+		pTkip->R ^= ROR32( pTkip->L, 2 ); 
+		pTkip->L += pTkip->R; 
+		// Clear the buffer 
+		pTkip->M = 0; 
+		pTkip->nBytesInM = 0; 
+	} 
+} 
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Calculate the MIC Value.
+		
+	Arguments:
+      pAdapter		Pointer to our adapter
+      pSrc			Pointer to source data for Calculate MIC Value
+      Len			Indicate the length of the source data
+		
+	Return Value:
+		None
+
+	IRQL = DISPATCH_LEVEL
+	
+	Note:
+		
+	========================================================================
+*/
+VOID	RTMPTkipAppend( 
+	IN	PTKIP_KEY_INFO	pTkip,	
+	IN	PUCHAR			pSrc,
+	IN	UINT			nBytes)						  
+{ 
+	// This is simple 
+	while(nBytes > 0) 
+	{ 
+		RTMPTkipAppendByte(pTkip, *pSrc++); 
+		nBytes--; 
+	} 
+} 
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Get the MIC Value.
+		
+	Arguments:
+      pAdapter		Pointer to our adapter
+		
+	Return Value:
+		None
+
+	IRQL = DISPATCH_LEVEL
+	
+	Note:
+		the MIC Value is store in pAdapter->PrivateInfo.MIC
+	========================================================================
+*/
+VOID	RTMPTkipGetMIC( 
+	IN	PTKIP_KEY_INFO	pTkip)
+{ 
+	// Append the minimum padding
+	RTMPTkipAppendByte(pTkip, 0x5a );	
+	RTMPTkipAppendByte(pTkip, 0 ); 
+	RTMPTkipAppendByte(pTkip, 0 ); 
+	RTMPTkipAppendByte(pTkip, 0 ); 
+	RTMPTkipAppendByte(pTkip, 0 ); 
+	// and then zeroes until the length is a multiple of 4 
+	while( pTkip->nBytesInM != 0 ) 
+	{ 
+		RTMPTkipAppendByte(pTkip, 0 ); 
+	} 
+	// The appendByte function has already computed the result. 
+	RTMPTkipPutUInt32(pTkip->MIC, pTkip->L);
+	RTMPTkipPutUInt32(pTkip->MIC + 4, pTkip->R);
+} 
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Init Tkip function.	
+		
+	Arguments:
+      pAdapter		Pointer to our adapter
+		pTKey       Pointer to the Temporal Key (TK), TK shall be 128bits.
+		KeyId		TK Key ID
+		pTA			Pointer to transmitter address
+		pMICKey		pointer to MIC Key
+		
+	Return Value:
+		None
+
+	IRQL = DISPATCH_LEVEL
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTMPInitTkipEngine(
+	IN	PRT2570ADAPTER	pAdapter,	
+	IN	PUCHAR			pKey,
+	IN	UCHAR			KeyId,
+	IN	PUCHAR			pTA,
+	IN	PUCHAR			pMICKey,
+	IN	PUCHAR			pTSC,
+	IN	INT				DoEncrypt,
+	OUT	PULONG			pIV16,
+	OUT	PULONG			pIV32,
+	IN	PUCHAR			pDest)
+{
+    TKIP_IV	tkipIv;
+    if (DoEncrypt == 0)
+    {
+        // Prepare 8 bytes TKIP encapsulation for MPDU
+        memset(&tkipIv, 0, sizeof(TKIP_IV));
+	tkipIv.IV16.word = 0;
+        tkipIv.IV16.field.rc0 = *(pTSC + 1);	
+        tkipIv.IV16.field.rc1 = (tkipIv.IV16.field.rc0 | 0x20) & 0x7f;	
+        tkipIv.IV16.field.rc2 = *pTSC;	
+        tkipIv.IV16.field.CONTROL.field.ExtIV = 1;  // 0: non-extended IV, 1: an extended IV
+        tkipIv.IV16.field.CONTROL.field.KeyID = KeyId;
+        tkipIv.IV32 = *(PULONG)(pTSC + 2);
+
+        *pIV16 = tkipIv.IV16.word;
+        *pIV32 = tkipIv.IV32;
+    }
+    else
+    {
+        pAdapter->PrivateInfo.FCSCRC32 = PPPINITFCS32;   //Init crc32.
+
+        // Set IV16, IV32 from TSC value
+        pAdapter->PrivateInfo.Tx.IV16 = (ULONG) *(pTSC) + (((ULONG) *(pTSC + 1)) << 8);	//TSC[0]:TSC[1]
+        pAdapter->PrivateInfo.Tx.IV32 = *(PULONG)(pTSC + 2);
+
+        // Init RC4 Key
+        RTMPTkipMixTKey(&pAdapter->PrivateInfo.Tx, pKey, pTA);
+
+        // Prepare 8 bytes TKIP encapsulation for MPDU
+        memset(&tkipIv, 0, sizeof(TKIP_IV));
+        tkipIv.IV16.field.rc2 = (UCHAR) (pAdapter->PrivateInfo.Tx.IV16 & 0xFF);	
+        tkipIv.IV16.field.rc1 = (UCHAR) pAdapter->PrivateInfo.Tx.RC4KEY[1];	
+        tkipIv.IV16.field.rc0 = (UCHAR) ((pAdapter->PrivateInfo.Tx.IV16 >> 8) & 0xFF);	
+        tkipIv.IV32 = pAdapter->PrivateInfo.Tx.IV32;
+        tkipIv.IV16.field.CONTROL.field.ExtIV = 1;  // 0: non-extended IV, 1: an extended IV
+        tkipIv.IV16.field.CONTROL.field.KeyID = KeyId;
+
+        *pIV16 = tkipIv.IV16.word;
+        *pIV32 = tkipIv.IV32;
+
+
+        // Copy 8 bytes encapsulation into Tx ring
+        memcpy(pDest, &tkipIv, sizeof(TKIP_IV));
+
+        // Init RC4 encyption engine
+        ARCFOUR_INIT(&pAdapter->PrivateInfo.WEPCONTEXT, pAdapter->PrivateInfo.Tx.RC4KEY, 16);
+    }
+
+
+    // Prepare 8 bytes TKIP encapsulation for MPDU
+    memset(&tkipIv, 0, sizeof(TKIP_IV));
+    tkipIv.IV16.field.rc0 = *(pTSC + 1);	
+    tkipIv.IV16.field.rc1 = (tkipIv.IV16.field.rc0 | 0x20) & 0x7f;	
+    tkipIv.IV16.field.rc2 = *pTSC;	
+    tkipIv.IV16.field.CONTROL.field.ExtIV = 1;  // 0: non-extended IV, 1: an extended IV
+    tkipIv.IV16.field.CONTROL.field.KeyID = KeyId;
+    tkipIv.IV32 = *(PULONG)(pTSC + 2);
+
+    *pIV16 = tkipIv.IV16.word;
+    *pIV32 = tkipIv.IV32;
+
+}
+
+
+VOID	RTMPTkipEncryptData(
+	IN	PRT2570ADAPTER	pAdapter,	
+	IN	PUCHAR			pSrc,
+	IN	PUCHAR			pDest,
+	IN	UINT			Len)
+{
+	pAdapter->PrivateInfo.FCSCRC32 = RTMP_CALC_FCS32(pAdapter->PrivateInfo.FCSCRC32, pSrc, Len);
+	ARCFOUR_ENCRYPT(&pAdapter->PrivateInfo.WEPCONTEXT, pDest, pSrc, Len);
+
+
+}
+/*
+	========================================================================
+
+	Routine	Description:
+		Init MIC Value calculation function which include set MIC key & 
+		calculate first 16 bytes (DA + SA + priority +  0)
+		
+	Arguments:
+      pAdapter		Pointer to our adapter
+		pTKey       Pointer to the Temporal Key (TK), TK shall be 128bits.
+		pDA			Pointer to DA address
+		pSA			Pointer to SA address
+		pMICKey		pointer to MIC Key
+		
+	Return Value:
+		None
+
+	Note:
+	
+	========================================================================
+*/
+VOID	RTMPInitMICEngine(
+	IN	PRT2570ADAPTER	pAdapter,	
+	IN	PUCHAR			pKey,
+	IN	PUCHAR			pDA,
+	IN	PUCHAR			pSA,
+	IN	PUCHAR			pMICKey)
+{
+	UCHAR	Priority[4];
+
+	// Zero priority value. Can change to input parameter if required
+	memset(Priority, 0, 4);
+	// Init MIC value calculation
+	RTMPTkipSetMICKey(&pAdapter->PrivateInfo.Tx, pMICKey);
+	// DA
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, pDA, 6);
+	// SA
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, pSA, 6);
+	// Priority + 3 bytes of 0
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, Priority, 4);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Compare MIC value of received MSDU
+		
+	Arguments:
+		pAdapter	Pointer to our adapter
+		pSrc        Pointer to the received Plain text data
+		pDA			Pointer to DA address
+		pSA			Pointer to SA address
+		pMICKey		pointer to MIC Key
+		Len         the length of the received plain text data exclude MIC value
+		
+	Return Value:
+		TRUE        MIC value matched
+		FALSE       MIC value mismatched
+		
+	IRQL = DISPATCH_LEVEL
+	
+	Note:
+	
+	========================================================================
+*/
+BOOLEAN	RTMPTkipCompareMICValue(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PUCHAR			pSrc,
+	IN	PUCHAR			pDA,
+	IN	PUCHAR			pSA,
+	IN	PUCHAR			pMICKey,
+	IN	UINT			Len)
+{
+	UCHAR	OldMic[8];
+	UCHAR	Priority[4];
+	INT		i;
+
+	// Zero priority value. Can change to input parameter if required
+	memset(Priority, 0, 4);
+	// Init MIC value calculation
+	RTMPTkipSetMICKey(&pAdapter->PrivateInfo.Rx, pMICKey);
+	// DA
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, pDA, 6);
+	// SA
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, pSA, 6);
+	// Priority + 3 bytes of 0
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, Priority, 4);
+	
+	// Calculate MIC value from plain text data
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, pSrc, Len);
+
+	// Get MIC valude from received frame
+	memcpy(OldMic, pSrc + Len, 8);
+	
+	// Get MIC value from decrypted plain data
+	RTMPTkipGetMIC(&pAdapter->PrivateInfo.Rx);
+		
+	// Move MIC value from MSDU, this steps should move to data path.
+	// Since the MIC value might cross MPDUs.
+	if(memcmp(pAdapter->PrivateInfo.Rx.MIC, OldMic, 8) != 0)
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "! TKIP MIC Error Len=%d!\n", Len);  //MIC error.
+		DBGPRINT(RT_DEBUG_INFO, "Orig MIC value = ");  //MIC error.
+		for (i = 0; i < 8; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", OldMic[i]);  //MIC error.
+		}
+		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");  //MIC error.
+		DBGPRINT(RT_DEBUG_INFO, "Calculated MIC value = ");  //MIC error.
+		for (i = 0; i < 8; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", pAdapter->PrivateInfo.Rx.MIC[i]);  //MIC error.
+		}
+		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");  //MIC error.
+		return (FALSE);
+	}
+	return (TRUE);
+}
+
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Compare MIC value of received MSDU
+		
+	Arguments:
+		pAdapter	Pointer to our adapter
+		pLLC		LLC header
+		pSrc        Pointer to the received Plain text data
+		pDA			Pointer to DA address
+		pSA			Pointer to SA address
+		pMICKey		pointer to MIC Key
+		Len         the length of the received plain text data exclude MIC value
+		
+	Return Value:
+		TRUE        MIC value matched
+		FALSE       MIC value mismatched
+		
+	IRQL = DISPATCH_LEVEL
+	
+	Note:
+	
+	========================================================================
+*/
+BOOLEAN	RTMPTkipCompareMICValueWithLLC(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PUCHAR			pLLC,
+	IN	PUCHAR			pSrc,
+	IN	PUCHAR			pDA,
+	IN	PUCHAR			pSA,
+	IN	PUCHAR			pMICKey,
+	IN	UINT			Len)
+{
+	UCHAR	OldMic[8];
+	UCHAR	Priority[4];
+	INT		i;
+
+	// Zero priority value. Can change to input parameter if required
+	memset(Priority, 0, 4);
+	// Init MIC value calculation
+	RTMPTkipSetMICKey(&pAdapter->PrivateInfo.Rx, pMICKey);
+	// DA
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, pDA, 6);
+	// SA
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, pSA, 6);
+	// Priority + 3 bytes of 0
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, Priority, 4);
+	
+	// Start with LLC header
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, pLLC, 8);
+
+	// Calculate MIC value from plain text data
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Rx, pSrc, Len);
+
+	// Get MIC valude from received frame
+	memcpy(OldMic, pSrc + Len, 8);
+	
+	// Get MIC value from decrypted plain data
+	RTMPTkipGetMIC(&pAdapter->PrivateInfo.Rx);
+		
+	// Move MIC value from MSDU, this steps should move to data path.
+	// Since the MIC value might cross MPDUs.
+	if(memcmp(pAdapter->PrivateInfo.Rx.MIC, OldMic, 8) != 0)
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "! TKIP MIC Error !\n");  //MIC error.
+		DBGPRINT(RT_DEBUG_INFO, "Orig MIC value = ");  //MIC error.
+		for (i = 0; i < 8; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", OldMic[i]);  //MIC error.
+		}
+		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");  //MIC error.
+		DBGPRINT(RT_DEBUG_INFO, "Calculated MIC value = ");  //MIC error.
+		for (i = 0; i < 8; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", pAdapter->PrivateInfo.Rx.MIC[i]);  //MIC error.
+		}
+		DBGPRINT_RAW(RT_DEBUG_INFO, "\n");  //MIC error.
+		return (FALSE);
+	}
+	return (TRUE);
+}
+/*
+	========================================================================
+
+	Routine	Description:
+		Copy frame from waiting queue into relative ring buffer and set 
+	appropriate ASIC register to kick hardware transmit function
+		
+	Arguments:
+		pAdapter		Pointer	to our adapter
+		PNDIS_PACKET	Pointer to Ndis Packet for MIC calculation
+		pEncap			Pointer to LLC encap data
+		LenEncap		Total encap length, might be 0 which indicates no encap
+		
+	Return Value:
+		None
+
+	IRQL = DISPATCH_LEVEL
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTMPCalculateMICValue(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN  struct sk_buff  *skb,
+	IN	PUCHAR			pEncap,
+	IN	INT				LenEncap,
+	IN	PWPA_KEY		pWpaKey)
+{
+    PUCHAR          pSrc;
+    static UCHAR    Priority[4] = {"\x00\x00\x00\x00"};
+   
+    pSrc = (PUCHAR) skb->data;
+    
+    // Init MIC value calculation and reset the message
+    pAdapter->PrivateInfo.Tx.L = RTMPTkipGetUInt32(pWpaKey->TxMic);
+    pAdapter->PrivateInfo.Tx.R = RTMPTkipGetUInt32(pWpaKey->TxMic + 4);
+    pAdapter->PrivateInfo.Tx.nBytesInM = 0;
+    pAdapter->PrivateInfo.Tx.M = 0;
+	
+    // DA & SA field
+    RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, pSrc, 12);
+    
+    // Priority + 3 bytes of 0
+    RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, Priority, 4);
+    
+    if (LenEncap > 0)
+    {
+        // LLC encapsulation
+        RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, pEncap, LenEncap);
+        // Protocol Type
+        RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, pSrc + 12, skb->len - 12);
+    }
+    else
+        RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, pSrc + 14, skb->len - 14);
+    
+    // Compute the final MIC Value
+    RTMPTkipGetMIC(&pAdapter->PrivateInfo.Tx);
+
+}
+
+/************************************************************/ 
+/* tkip_sbox()																*/ 
+/* Returns a 16 bit value from a 64K entry table. The Table */ 
+/* is synthesized from two 256 entry byte wide tables.		*/ 
+/************************************************************/ 
+
+UINT tkip_sbox(UINT index) 
+{ 
+	UINT index_low; 
+	UINT index_high; 
+	UINT left, right; 
+
+	index_low = (index % 256); 
+	index_high = ((index >> 8) % 256); 
+
+	left = Tkip_Sbox_Lower[index_low] + (Tkip_Sbox_Upper[index_low] * 256); 
+	right = Tkip_Sbox_Upper[index_high] + (Tkip_Sbox_Lower[index_high] * 256); 
+
+	return (left ^ right); 
+}
+
+UINT rotr1(UINT a) 
+{ 
+	unsigned int b; 
+
+	if ((a & 0x01) == 0x01) 
+	{ 
+		b = (a >> 1) | 0x8000; 
+	} 
+	else 
+	{ 
+		b = (a >> 1) & 0x7fff; 
+	} 
+	b = b % 65536; 
+	return b; 
+} 
+/*
+	========================================================================
+
+	Routine	Description:
+		Key Mixing function.
+		
+	Arguments:
+      pAdapter		Pointer to our adapter
+		pTKey       Pointer to the Temporal Key (TK), TK shall be 128bits.		
+		pTA			Pointer to transmitter address
+		nl			Least significant 16 bits of IV16
+		nh			Most significant 32 bits of IV32 
+		
+	Return Value:
+		None
+
+	Note:
+		Calculates an RC4 key.
+	========================================================================
+*/
+VOID	RTMPTkipMixTKey( 
+	IN	PTKIP_KEY_INFO	pTkip,
+	IN	PUCHAR			pTKey,
+	IN	PUCHAR			pTA)
+{ 
+	UINT	tsc0; 
+	UINT	tsc1;
+	UINT	tsc2; 
+
+	UINT	ppk0; 
+	UINT	ppk1; 
+	UINT	ppk2; 
+	UINT	ppk3; 
+	UINT	ppk4; 
+	UINT	ppk5; 
+	UINT	p1k[5];
+
+	int i; 
+	int j; 
+
+	tsc0 = (UINT)((pTkip->IV32 >> 16) % 65536); /* msb */ 
+	tsc1 = (UINT)(pTkip->IV32 % 65536); 
+	tsc2 = (UINT)(pTkip->IV16 % 65536); /* lsb */ 
+
+	/* Phase 1, step 1 */ 
+	p1k[0] = tsc1; 
+	p1k[1] = tsc0; 
+	p1k[2] = (unsigned int)(pTA[0] + (pTA[1]*256)); 
+	p1k[3] = (unsigned int)(pTA[2] + (pTA[3]*256)); 
+	p1k[4] = (unsigned int)(pTA[4] + (pTA[5]*256)); 
+
+	/* Phase 1, step 2 */ 
+	for (i=0; i<8; i++) 
+	{ 
+		j = 2*(i & 1); 
+		p1k[0] = (p1k[0] + tkip_sbox( (p1k[4] ^ ((256*pTKey[1+j]) + pTKey[j])) % 65536 )) % 65536; 
+		p1k[1] = (p1k[1] + tkip_sbox( (p1k[0] ^ ((256*pTKey[5+j]) + pTKey[4+j])) % 65536 )) % 65536; 
+		p1k[2] = (p1k[2] + tkip_sbox( (p1k[1] ^ ((256*pTKey[9+j]) + pTKey[8+j])) % 65536 )) % 65536; 
+		p1k[3] = (p1k[3] + tkip_sbox( (p1k[2] ^ ((256*pTKey[13+j]) + pTKey[12+j])) % 65536 )) % 65536; 
+		p1k[4] = (p1k[4] + tkip_sbox( (p1k[3] ^ (((256*pTKey[1+j]) + pTKey[j]))) % 65536 )) % 65536; 
+		p1k[4] = (p1k[4] + i) % 65536; 
+	} 
+
+	/* Phase 2, Step 1 */ 
+	ppk0 = p1k[0]; 
+	ppk1 = p1k[1]; 
+	ppk2 = p1k[2]; 
+	ppk3 = p1k[3]; 
+	ppk4 = p1k[4]; 
+	ppk5 = (p1k[4] + tsc2) % 65536; 
+
+	/* Phase2, Step 2 */ 
+	ppk0 = ppk0 + tkip_sbox( (ppk5 ^ ((256*pTKey[1]) + pTKey[0])) % 65536); 
+	ppk1 = ppk1 + tkip_sbox( (ppk0 ^ ((256*pTKey[3]) + pTKey[2])) % 65536); 
+	ppk2 = ppk2 + tkip_sbox( (ppk1 ^ ((256*pTKey[5]) + pTKey[4])) % 65536); 
+	ppk3 = ppk3 + tkip_sbox( (ppk2 ^ ((256*pTKey[7]) + pTKey[6])) % 65536); 
+	ppk4 = ppk4 + tkip_sbox( (ppk3 ^ ((256*pTKey[9]) + pTKey[8])) % 65536); 
+	ppk5 = ppk5 + tkip_sbox( (ppk4 ^ ((256*pTKey[11]) + pTKey[10])) % 65536); 
+
+	ppk0 = ppk0 + rotr1(ppk5 ^ ((256*pTKey[13]) + pTKey[12])); 
+	ppk1 = ppk1 + rotr1(ppk0 ^ ((256*pTKey[15]) + pTKey[14])); 
+	ppk2 = ppk2 + rotr1(ppk1); 
+	ppk3 = ppk3 + rotr1(ppk2); 
+	ppk4 = ppk4 + rotr1(ppk3); 
+	ppk5 = ppk5 + rotr1(ppk4); 
+
+	/* Phase 2, Step 3 */ 
+	pTkip->RC4KEY[0] = (tsc2 >> 8) % 256; 
+	pTkip->RC4KEY[1] = (((tsc2 >> 8) % 256) | 0x20) & 0x7f; 
+	pTkip->RC4KEY[2] = tsc2 % 256; 
+	pTkip->RC4KEY[3] = ((ppk5 ^ ((256*pTKey[1]) + pTKey[0])) >> 1) % 256; 
+
+	pTkip->RC4KEY[4] = ppk0 % 256; 
+	pTkip->RC4KEY[5] = (ppk0 >> 8) % 256; 
+
+	pTkip->RC4KEY[6] = ppk1 % 256; 
+	pTkip->RC4KEY[7] = (ppk1 >> 8) % 256; 
+
+	pTkip->RC4KEY[8] = ppk2 % 256; 
+	pTkip->RC4KEY[9] = (ppk2 >> 8) % 256; 
+
+	pTkip->RC4KEY[10] = ppk3 % 256; 
+	pTkip->RC4KEY[11] = (ppk3 >> 8) % 256; 
+
+	pTkip->RC4KEY[12] = ppk4 % 256; 
+	pTkip->RC4KEY[13] = (ppk4 >> 8) % 256; 
+
+	pTkip->RC4KEY[14] = ppk5 % 256; 
+	pTkip->RC4KEY[15] = (ppk5 >> 8) % 256; 	
+} 
+
+
+VOID RTMPTkipMixKey(
+	UCHAR *key, 
+	UCHAR *ta, 
+	ULONG pnl, /* Least significant 16 bits of PN */
+	ULONG pnh, /* Most significant 32 bits of PN */ 
+	UCHAR *rc4key, 
+	UINT *p1k)
+{
+
+	UINT tsc0; 
+	UINT tsc1;
+	UINT tsc2; 
+
+	UINT ppk0; 
+	UINT ppk1; 
+	UINT ppk2; 
+	UINT ppk3; 
+	UINT ppk4; 
+	UINT ppk5; 
+
+	INT i; 
+	INT j; 
+
+	tsc0 = (unsigned int)((pnh >> 16) % 65536); /* msb */ 
+	tsc1 = (unsigned int)(pnh % 65536); 
+	tsc2 = (unsigned int)(pnl % 65536); /* lsb */ 
+
+	/* Phase 1, step 1 */ 
+	p1k[0] = tsc1; 
+	p1k[1] = tsc0; 
+	p1k[2] = (UINT)(ta[0] + (ta[1]*256)); 
+	p1k[3] = (UINT)(ta[2] + (ta[3]*256)); 
+	p1k[4] = (UINT)(ta[4] + (ta[5]*256)); 
+
+	/* Phase 1, step 2 */ 
+	for (i=0; i<8; i++) 
+	{ 
+		j = 2*(i & 1); 
+		p1k[0] = (p1k[0] + tkip_sbox( (p1k[4] ^ ((256*key[1+j]) + key[j])) % 65536 )) % 65536; 
+		p1k[1] = (p1k[1] + tkip_sbox( (p1k[0] ^ ((256*key[5+j]) + key[4+j])) % 65536 )) % 65536; 
+		p1k[2] = (p1k[2] + tkip_sbox( (p1k[1] ^ ((256*key[9+j]) + key[8+j])) % 65536 )) % 65536; 
+		p1k[3] = (p1k[3] + tkip_sbox( (p1k[2] ^ ((256*key[13+j]) + key[12+j])) % 65536 )) % 65536; 
+		p1k[4] = (p1k[4] + tkip_sbox( (p1k[3] ^ (((256*key[1+j]) + key[j]))) % 65536 )) % 65536; 
+		p1k[4] = (p1k[4] + i) % 65536; 
+	} 
+
+	/* Phase 2, Step 1 */ 
+	ppk0 = p1k[0]; 
+	ppk1 = p1k[1]; 
+	ppk2 = p1k[2]; 
+	ppk3 = p1k[3]; 
+	ppk4 = p1k[4]; 
+	ppk5 = (p1k[4] + tsc2) % 65536; 
+
+	/* Phase2, Step 2 */ 
+	ppk0 = ppk0 + tkip_sbox( (ppk5 ^ ((256*key[1]) + key[0])) % 65536); 
+	ppk1 = ppk1 + tkip_sbox( (ppk0 ^ ((256*key[3]) + key[2])) % 65536); 
+	ppk2 = ppk2 + tkip_sbox( (ppk1 ^ ((256*key[5]) + key[4])) % 65536); 
+	ppk3 = ppk3 + tkip_sbox( (ppk2 ^ ((256*key[7]) + key[6])) % 65536); 
+	ppk4 = ppk4 + tkip_sbox( (ppk3 ^ ((256*key[9]) + key[8])) % 65536); 
+	ppk5 = ppk5 + tkip_sbox( (ppk4 ^ ((256*key[11]) + key[10])) % 65536); 
+
+	ppk0 = ppk0 + rotr1(ppk5 ^ ((256*key[13]) + key[12])); 
+	ppk1 = ppk1 + rotr1(ppk0 ^ ((256*key[15]) + key[14])); 
+	ppk2 = ppk2 + rotr1(ppk1); 
+	ppk3 = ppk3 + rotr1(ppk2); 
+	ppk4 = ppk4 + rotr1(ppk3); 
+	ppk5 = ppk5 + rotr1(ppk4); 
+
+	/* Phase 2, Step 3 */ 
+    /* Phase 2, Step 3 */
+
+	tsc0 = (unsigned int)((pnh >> 16) % 65536); /* msb */ 
+	tsc1 = (unsigned int)(pnh % 65536); 
+	tsc2 = (unsigned int)(pnl % 65536); /* lsb */ 
+
+	rc4key[0] = (tsc2 >> 8) % 256; 
+	rc4key[1] = (((tsc2 >> 8) % 256) | 0x20) & 0x7f; 
+	rc4key[2] = tsc2 % 256; 
+	rc4key[3] = ((ppk5 ^ ((256*key[1]) + key[0])) >> 1) % 256; 
+
+	rc4key[4] = ppk0 % 256; 
+	rc4key[5] = (ppk0 >> 8) % 256; 
+
+	rc4key[6] = ppk1 % 256; 
+	rc4key[7] = (ppk1 >> 8) % 256; 
+
+	rc4key[8] = ppk2 % 256; 
+	rc4key[9] = (ppk2 >> 8) % 256; 
+
+	rc4key[10] = ppk3 % 256; 
+	rc4key[11] = (ppk3 >> 8) % 256; 
+
+	rc4key[12] = ppk4 % 256; 
+	rc4key[13] = (ppk4 >> 8) % 256; 
+
+	rc4key[14] = ppk5 % 256; 
+	rc4key[15] = (ppk5 >> 8) % 256; 
+
+}
+
+	
+//
+// TRUE: Success!
+// FALSE: Decrypt Error!
+//
+BOOLEAN RTMPSoftDecryptTKIP(
+	IN PRT2570ADAPTER pAdapter,
+	IN PUCHAR	pData,
+	IN ULONG	DataByteCnt, 
+	IN PWPA_KEY	pWpaKey)
+{
+	PHEADER_802_11	pHeader;
+	UCHAR			KeyID;
+	UINT			HeaderLen;
+    UCHAR			fc0;
+	UCHAR			fc1;
+	USHORT			fc;
+	UINT			frame_type;
+	UINT			frame_subtype;
+    UINT			from_ds;
+    UINT			to_ds;
+	INT				a4_exists;
+	INT				qc_exists;
+	USHORT			duration;
+	USHORT			seq_control;
+	USHORT			qos_control;
+	UCHAR			TA[MAC_ADDR_LEN];
+	UCHAR			DA[MAC_ADDR_LEN];
+	UCHAR			SA[MAC_ADDR_LEN];
+	UCHAR			RC4Key[16];
+	UINT			p1k[5]; //for mix_key;
+	ULONG			pnl;/* Least significant 16 bits of PN */
+	ULONG			pnh;/* Most significant 32 bits of PN */ 
+	UINT			num_blocks;
+	UINT			payload_remainder;
+	ARCFOURCONTEXT 	ArcFourContext;
+	ULONG			crc32 = 0;
+	ULONG			trailfcs = 0;
+	UCHAR			MIC[8];
+	UCHAR			TrailMIC[8];
+
+	fc0 = *pData;
+	fc1 = *(pData + 1);
+
+	fc = *((PUSHORT)pData);	
+	
+	frame_type = ((fc0 >> 2) & 0x03);
+	frame_subtype = ((fc0 >> 4) & 0x0f);	
+
+    from_ds = (fc1 & 0x2) >> 1;
+    to_ds = (fc1 & 0x1);
+
+    a4_exists = (from_ds & to_ds);
+    qc_exists = ((frame_subtype == 0x08) ||    /* Assumed QoS subtypes */
+                  (frame_subtype == 0x09) ||   /* Likely to change.    */
+                  (frame_subtype == 0x0a) || 
+                  (frame_subtype == 0x0b)
+                 );
+
+	HeaderLen = 24;
+	if (a4_exists)
+		HeaderLen += 6;
+
+	KeyID = *((PUCHAR)(pData+ HeaderLen + 3));	
+	KeyID = KeyID >> 6;
+
+	if (pWpaKey[KeyID].KeyLen == 0)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "RTMPSoftDecryptTKIP failed!(KeyID[%d] Length can not be 0)\n", KeyID);
+		return FALSE;
+	}
+	duration = *((PUSHORT)(pData+2));	
+
+	seq_control = *((PUSHORT)(pData+22));
+	
+	if (qc_exists)
+	{
+		if (a4_exists)
+		{
+			qos_control = *((PUSHORT)(pData+30));
+		}
+		else
+		{
+			qos_control = *((PUSHORT)(pData+24));
+		}
+	}
+	
+	if (to_ds == 0 && from_ds == 1)
+	{
+		memcpy(&DA, pData+4, MAC_ADDR_LEN);
+		memcpy(&SA, pData+16, MAC_ADDR_LEN);
+		memcpy(&TA, pData+10, MAC_ADDR_LEN);  //BSSID
+	}	
+	else if (to_ds == 0 && from_ds == 0 )
+	{
+		memcpy(&TA, pData+10, MAC_ADDR_LEN);
+		memcpy(&DA, pData+4, MAC_ADDR_LEN);
+		memcpy(&SA, pData+10, MAC_ADDR_LEN);
+	}
+	else if (to_ds == 1 && from_ds == 0)
+	{
+		memcpy(&SA, pData+10, MAC_ADDR_LEN);
+		memcpy(&TA, pData+10, MAC_ADDR_LEN);
+		memcpy(&DA, pData+16, MAC_ADDR_LEN);
+	}
+	else if (to_ds == 1 && from_ds == 1)
+	{
+		memcpy(&TA, pData+10, MAC_ADDR_LEN);
+		memcpy(&DA, pData+16, MAC_ADDR_LEN);
+		memcpy(&SA, pData+22, MAC_ADDR_LEN);
+	}
+
+	num_blocks = (DataByteCnt - 16) / 16;
+	payload_remainder = (DataByteCnt - 16) % 16;
+
+	pnl = (*(pData + HeaderLen)) * 256 + *(pData + HeaderLen + 2);	
+	pnh = *((PULONG)(pData + HeaderLen + 4));
+	RTMPTkipMixKey(pWpaKey[KeyID].Key, TA, pnl, pnh, RC4Key, p1k);
+
+	ARCFOUR_INIT(&ArcFourContext, RC4Key, 16); 
+	ARCFOUR_DECRYPT(&ArcFourContext, pData + HeaderLen, pData + HeaderLen + 8, DataByteCnt - HeaderLen - 8);
+	memcpy(&trailfcs, pData + DataByteCnt - 8 - 4, 4);
+	crc32 = RTMP_CALC_FCS32(PPPINITFCS32, pData + HeaderLen, DataByteCnt - HeaderLen - 8 - 4);  //Skip IV+EIV 8 bytes & Skip last 4 bytes(FCS).
+	crc32 ^= 0xffffffff;             /* complement */
+	if(crc32 != trailfcs)
+	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "RTMPSoftDecryptTKIP, WEP Data ICV Error !\n");	 //ICV error.
+
+		return (FALSE);
+	}
+
+	memcpy(TrailMIC, pData + DataByteCnt - 8 - 8 - 4, 8);
+	RTMPInitMICEngine(pAdapter, pWpaKey[KeyID].Key, DA, SA, pWpaKey[KeyID].RxMic);
+	RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, pData + HeaderLen, DataByteCnt - HeaderLen - 8 - 12);
+	RTMPTkipGetMIC(&pAdapter->PrivateInfo.Tx);
+	memcpy(MIC, pAdapter->PrivateInfo.Tx.MIC, 8);
+
+	if (memcmp(MIC, TrailMIC, 8) != 0)
+	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "RTMPSoftDecryptTKIP, WEP Data MIC Error !\n");	 //MIC error.
+		RTMPReportMicError(pAdapter, &pWpaKey[KeyID]);
+		return (FALSE);		
+	}
+
+	pHeader	= (PHEADER_802_11)pData;
+	pHeader->Controlhead.Frame.Wep = 0; //None WEP
+	
+	DBGPRINT(RT_DEBUG_TRACE, "RTMPSoftDecryptTKIP Decript done!!\n");
+	return TRUE;
+}
+
+	
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rtmp_type.h linux-2.4.35.3-mct/drivers/usb/rt2570/rtmp_type.h
--- linux-2.4.35.3/drivers/usb/rt2570/rtmp_type.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rtmp_type.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,133 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	rtmp_type.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ *	MathiasK	04-07-2005	Endian fix
+ ***************************************************************************/
+
+#ifndef __RTMP_TYPE_H__
+#define __RTMP_TYPE_H__
+
+typedef unsigned short      UINT16;
+typedef unsigned long       UINT32;
+typedef unsigned long long  UINT64;
+
+// Endian byte swapping codes
+#define SWAP16(x) \
+    ((UINT16)( \
+    (((UINT16)(x) & (UINT16) 0x00ffU) << 8) | \
+    (((UINT16)(x) & (UINT16) 0xff00U) >> 8) ))
+
+#define SWAP32(x) \
+    ((UINT32)( \
+    (((UINT32)(x) & (UINT32) 0x000000ffUL) << 24) | \
+    (((UINT32)(x) & (UINT32) 0x0000ff00UL) <<  8) | \
+    (((UINT32)(x) & (UINT32) 0x00ff0000UL) >>  8) | \
+    (((UINT32)(x) & (UINT32) 0xff000000UL) >> 24) ))
+
+#define SWAP64(x) \
+    ((UINT64)( \
+    (UINT64)(((UINT64)(x) & (UINT64) 0x00000000000000ffULL) << 56) | \
+    (UINT64)(((UINT64)(x) & (UINT64) 0x000000000000ff00ULL) << 40) | \
+    (UINT64)(((UINT64)(x) & (UINT64) 0x0000000000ff0000ULL) << 24) | \
+    (UINT64)(((UINT64)(x) & (UINT64) 0x00000000ff000000ULL) <<  8) | \
+    (UINT64)(((UINT64)(x) & (UINT64) 0x000000ff00000000ULL) >>  8) | \
+    (UINT64)(((UINT64)(x) & (UINT64) 0x0000ff0000000000ULL) >> 24) | \
+    (UINT64)(((UINT64)(x) & (UINT64) 0x00ff000000000000ULL) >> 40) | \
+    (UINT64)(((UINT64)(x) & (UINT64) 0xff00000000000000ULL) >> 56) ))
+
+#ifdef BIG_ENDIAN
+
+#define cpu2le64(x) SWAP64((x))
+#define le2cpu64(x) SWAP64((x))
+#define cpu2le32(x) SWAP32((x))
+#define le2cpu32(x) SWAP32((x))
+#define cpu2le16(x) SWAP16((x))
+#define le2cpu16(x) SWAP16((x))
+#define cpu2be64(x) ((UINT64)(x))
+#define be2cpu64(x) ((UINT64)(x))
+#define cpu2be32(x) ((UINT32)(x))
+#define be2cpu32(x) ((UINT32)(x))
+#define cpu2be16(x) ((UINT16)(x))
+#define be2cpu16(x) ((UINT16)(x))
+
+#else   // Little_Endian
+
+#define cpu2le64(x) ((UINT64)(x))
+#define le2cpu64(x) ((UINT64)(x))
+#define cpu2le32(x) ((UINT32)(x))
+#define le2cpu32(x) ((UINT32)(x))
+#define cpu2le16(x) ((UINT16)(x))
+#define le2cpu16(x) ((UINT16)(x))
+#define cpu2be64(x) SWAP64((x))
+#define be2cpu64(x) SWAP64((x))
+#define cpu2be32(x) SWAP32((x))
+#define be2cpu32(x) SWAP32((x))
+#define cpu2be16(x) SWAP16((x))
+#define be2cpu16(x) SWAP16((x))
+
+#endif  // BIG_ENDIAN
+
+// Ralink timer control block
+typedef struct  _RALINK_TIMER_STRUCT    {
+	struct timer_list	 Timer;
+	ULONG				TimerValue;		// Timer value in milliseconds
+	BOOLEAN				State;			// True if timer cancelled
+}   RALINK_TIMER_STRUCT, *PRALINK_TIMER_STRUCT;
+
+typedef struct	_RSN_IE_HEADER_STRUCT	{
+	UCHAR		Eid;
+	UCHAR		Length;
+	USHORT		Version;	// Little endian format
+}	RSN_IE_HEADER_STRUCT, *PRSN_IE_HEADER_STRUCT;
+
+// Cipher suite selector types
+typedef struct _CIPHER_SUITE_STRUCT	{
+	UCHAR		Oui[3];
+	UCHAR		Type;
+}	CIPHER_SUITE_STRUCT, *PCIPHER_SUITE_STRUCT;
+
+// Authentication and Key Management suite selector
+typedef struct _AKM_SUITE_STRUCT	{
+	UCHAR		Oui[3];
+	UCHAR		Type;
+}	AKM_SUITE_STRUCT, *PAKM_SUITE_STRUCT;
+
+// RSN capability
+typedef struct	_RSN_CAPABILITY	{
+	USHORT		Rsv:10;
+	USHORT		GTKSAReplayCnt:2;
+	USHORT		PTKSAReplayCnt:2;
+	USHORT		NoPairwise:1;
+	USHORT		PreAuth:1;
+}	RSN_CAPABILITY, *PRSN_CAPABILITY;
+
+#endif	// __RTMP_TYPE_H__
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rtmp_wep.c linux-2.4.35.3-mct/drivers/usb/rt2570/rtmp_wep.c
--- linux-2.4.35.3/drivers/usb/rt2570/rtmp_wep.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rtmp_wep.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,444 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	rtmp_wep.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#include	"rt_config.h"
+
+ULONG FCSTAB_32[256] = 
+{
+	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
+	0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
+	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
+	0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
+	0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
+	0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
+	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
+	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
+	0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
+	0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
+	0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
+	0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
+	0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
+	0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
+	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 
+	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 
+	0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 
+	0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 
+	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 
+	0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 
+	0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 
+	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 
+	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 
+	0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 
+	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 
+	0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 
+	0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 
+	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 
+	0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 
+	0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 
+	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 
+	0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 
+	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 
+	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 
+	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 
+	0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 
+	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 
+	0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 
+	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 
+	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 
+	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 
+	0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 
+	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 
+	0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 
+	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 
+	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 
+	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 
+	0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 
+	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 
+	0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 
+	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 
+	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 
+	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 
+	0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 
+	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 
+	0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 
+	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 
+	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d 
+}; 
+
+UCHAR   WEPKEY[] = {
+		//IV
+		0x00, 0x11, 0x22, 
+		//WEP KEY
+		0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC 
+	};
+
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Init WEP function.	
+		
+	Arguments:
+      pAdapter		Pointer to our adapter
+		pKey        Pointer to the WEP KEY
+		KeyId		   WEP Key ID
+		KeyLen      the length of WEP KEY
+		pDest       Pointer to the destination which Encryption data will store in.
+		
+	Return Value:
+		None
+
+	IRQL = DISPATCH_LEVEL
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTMPInitWepEngine(
+	IN	PRT2570ADAPTER	pAdapter,	
+	IN	PUCHAR			pKey,
+	IN	UCHAR			KeyId,
+	IN	UCHAR			KeyLen, 
+	IN OUT	PUCHAR		pDest)
+{
+	UINT i;
+
+	pAdapter->PrivateInfo.FCSCRC32 = PPPINITFCS32;   //Init crc32.
+	memcpy(WEPKEY + 3, pKey, KeyLen);
+
+	for(i = 0; i < 3; i++) {
+		WEPKEY[i] = RandomByte(pAdapter);   //Call mlme RandomByte() function.
+	}
+	ARCFOUR_INIT(&pAdapter->PrivateInfo.WEPCONTEXT, WEPKEY, KeyLen + 3);  //INIT SBOX, KEYLEN+3(IV)
+
+	memcpy(pDest, WEPKEY, 3);  //Append Init Vector
+	*(pDest+3) = (KeyId << 6);       //Append KEYID 
+	
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Encrypt transimitted data		
+		
+	Arguments:
+      pAdapter		Pointer to our adapter
+      pSrc        Pointer to the transimitted source data that will be encrypt
+      pDest       Pointer to the destination where entryption data will be store in.
+      Len			Indicate the length of the source data
+		
+	Return Value:
+      None
+		
+	IRQL = DISPATCH_LEVEL
+
+	Note:
+	
+	========================================================================
+*/
+VOID	RTMPEncryptData(
+	IN	PRT2570ADAPTER	pAdapter,	
+	IN	PUCHAR			pSrc,
+	IN	PUCHAR			pDest,
+	IN	UINT			Len)
+{
+	pAdapter->PrivateInfo.FCSCRC32 = RTMP_CALC_FCS32(pAdapter->PrivateInfo.FCSCRC32, pSrc, Len);
+	ARCFOUR_ENCRYPT(&pAdapter->PrivateInfo.WEPCONTEXT, pDest, pSrc, Len);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Decrypt received data	
+		
+	Arguments:
+		pAdapter		Pointer to our adapter
+		pSrc        Pointer to the received data
+		Len         the length of the received data
+		
+	Return Value:
+		TRUE        Decrypt WEP data success
+		FALSE       Decrypt WEP data failed
+		
+	Note:
+	
+	========================================================================
+*/
+BOOLEAN	RTMPDecryptData(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PUCHAR			pSrc,
+	IN	UINT			Len)
+{
+	ULONG	trailfcs;
+	ULONG   crc32;
+	UCHAR	KeyIdx;
+
+	memcpy(WEPKEY, pSrc, 3);    //Get WEP IV
+	
+	KeyIdx = (*(pSrc + 3) & 0xc0) >> 6;
+	if (pAdapter->PortCfg.SharedKey[KeyIdx].KeyLen == 0)
+		return (FALSE);
+		
+	memcpy(WEPKEY + 3, pAdapter->PortCfg.SharedKey[KeyIdx].Key, pAdapter->PortCfg.SharedKey[KeyIdx].KeyLen);
+	ARCFOUR_INIT(&pAdapter->PrivateInfo.WEPCONTEXT, WEPKEY, pAdapter->PortCfg.SharedKey[KeyIdx].KeyLen + 3);
+	ARCFOUR_DECRYPT(&pAdapter->PrivateInfo.WEPCONTEXT, pSrc, pSrc + 4, Len - 4);
+	memcpy(&trailfcs, pSrc + Len - 8, 4);
+	crc32 = RTMP_CALC_FCS32(PPPINITFCS32, pSrc, Len - 8);  //Skip last 4 bytes(FCS).
+	crc32 ^= 0xffffffff;             /* complement */
+	if(crc32 != trailfcs)
+	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "! WEP Data CRC Error !\n");	 //CRC error.
+		return (FALSE);
+	}
+	return (TRUE);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		The Stream Cipher Encryption Algorithm "ARCFOUR" initialize		
+		
+	Arguments:
+	   Ctx         Pointer to ARCFOUR CONTEXT (SBOX)
+		pKey        Pointer to the WEP KEY
+		KeyLen      Indicate the length fo the WEP KEY
+		
+	Return Value:
+	   None
+		
+	IRQL = DISPATCH_LEVEL
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	ARCFOUR_INIT(
+	IN	PARCFOURCONTEXT	Ctx,
+	IN	PUCHAR			pKey,
+	IN	UINT			KeyLen)
+{
+	UCHAR	t, u;
+	UINT	keyindex;
+	UINT	stateindex;
+	PUCHAR	state;
+	UINT	counter;
+	
+	state = Ctx->STATE;
+	Ctx->X = 0;
+	Ctx->Y = 0;
+	for (counter = 0; counter < 256; counter++)
+		state[counter] = (UCHAR)counter;
+	keyindex = 0;
+	stateindex = 0;
+	for (counter = 0; counter < 256; counter++)
+	{
+		t = state[counter];
+		stateindex = (stateindex + pKey[keyindex] + t) & 0xff;
+		u = state[stateindex];
+		state[stateindex] = t;
+		state[counter] = u;
+		if (++keyindex >= KeyLen)
+			keyindex = 0;
+	}
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Get bytes from ARCFOUR CONTEXT (S-BOX)				
+		
+	Arguments:
+	   Ctx         Pointer to ARCFOUR CONTEXT (SBOX)
+		
+	Return Value:
+	   UCHAR  - the value of the ARCFOUR CONTEXT (S-BOX)		
+		
+	Note:
+	
+	========================================================================
+*/
+UCHAR	ARCFOUR_BYTE(
+	IN	PARCFOURCONTEXT		Ctx)
+{
+  UINT x;
+  UINT y;
+  UCHAR sx, sy;
+  PUCHAR state;
+  
+  state = Ctx->STATE;
+  x = (Ctx->X + 1) & 0xff;
+  sx = state[x];
+  y = (sx + Ctx->Y) & 0xff;
+  sy = state[y];
+  Ctx->X = x;
+  Ctx->Y = y;
+  state[y] = sx;
+  state[x] = sy;
+
+  return(state[(sx + sy) & 0xff]);
+  
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		The Stream Cipher Decryption Algorithm 		
+		
+	Arguments:
+		Ctx         Pointer to ARCFOUR CONTEXT (SBOX)
+		pDest			Pointer to the Destination 
+		pSrc        Pointer to the Source data
+		Len         Indicate the length of the Source data
+		
+	Return Value:
+		None
+		
+	Note:
+	
+	========================================================================
+*/
+VOID	ARCFOUR_DECRYPT(
+	IN	PARCFOURCONTEXT	Ctx,
+	IN	PUCHAR			pDest, 
+	IN	PUCHAR			pSrc,
+	IN	UINT			Len)
+{
+	UINT i;
+
+	for (i = 0; i < Len; i++)
+		pDest[i] = pSrc[i] ^ ARCFOUR_BYTE(Ctx);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		The Stream Cipher Encryption Algorithm 		
+		
+	Arguments:
+		Ctx         Pointer to ARCFOUR CONTEXT (SBOX)
+		pDest			Pointer to the Destination 
+		pSrc        Pointer to the Source data
+		Len         Indicate the length of the Source dta
+		
+	Return Value:
+		None
+		
+	IRQL = DISPATCH_LEVEL
+
+	Note:
+	
+	========================================================================
+*/
+VOID	ARCFOUR_ENCRYPT(
+	IN	PARCFOURCONTEXT	Ctx,
+	IN	PUCHAR			pDest,
+	IN	PUCHAR			pSrc,
+	IN	UINT			Len)
+{
+	UINT i;
+
+	for (i = 0; i < Len; i++)
+		pDest[i] = pSrc[i] ^ ARCFOUR_BYTE(Ctx);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Calculate a new FCS given the current FCS and the new data.
+		
+	Arguments:
+		Fcs	      the original FCS value
+		Cp          pointer to the data which will be calculate the FCS
+		Len         the length of the data
+		
+	Return Value:
+		ULONG - FCS 32 bits
+		
+	IRQL = DISPATCH_LEVEL
+
+	Note:
+	
+	========================================================================
+*/
+ULONG	RTMP_CALC_FCS32(
+	IN	ULONG	Fcs,
+	IN	PUCHAR	Cp,
+	IN	INT		Len)
+{
+	while (Len--)
+	   Fcs = (((Fcs) >> 8) ^ FCSTAB_32[((Fcs) ^ (*Cp++)) & 0xff]);
+
+	return (Fcs); 
+} 
+
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Get last FCS and encrypt it to the destination				
+		
+	Arguments:
+		pDest			Pointer to the Destination 
+		
+	Return Value:
+		None
+		
+	Note:
+	
+	========================================================================
+*/
+VOID	RTMPSetICV(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PUCHAR	pDest)
+{
+	pAdapter->PrivateInfo.FCSCRC32 ^= 0xffffffff;             /* complement */
+	
+	ARCFOUR_ENCRYPT(&pAdapter->PrivateInfo.WEPCONTEXT, pDest, (PUCHAR) &pAdapter->PrivateInfo.FCSCRC32, 4);
+}
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rtusb.h linux-2.4.35.3-mct/drivers/usb/rt2570/rtusb.h
--- linux-2.4.35.3/drivers/usb/rt2570/rtusb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rtusb.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,349 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	rtusb.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#ifndef	__RTUSB_H__
+#define	__RTUSB_H__
+
+//
+// MACRO definitions
+//
+#if defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0501)
+#define	NDIS_QUERY_BUFFER(_NdisBuf, _ppVA, _pBufLen)                    \
+    NdisQueryBufferSafe(_NdisBuf, _ppVA, _pBufLen, NormalPagePriority)
+#else
+#define	NDIS_QUERY_BUFFER(_NdisBuf, _ppVA, _pBufLen)                    \
+    NdisQueryBuffer(_NdisBuf, _ppVA, _pBufLen)
+#endif
+
+// MACRO for Ndis packet extra information
+#define	RTUSB_GET_PACKET_MR(_p)						(&(_p)->MiniportReservedEx[0]) 
+#define RTUSB_SET_PACKET_FRAGMENTS(_p, number)   ((_p)->cb[10] = number)
+#define RTUSB_GET_PACKET_FRAGMENTS(_p)           ((_p)->cb[10])
+#define RTUSB_SET_PACKET_RTS(_p, number)         ((_p)->cb[11] = number)
+#define RTUSB_GET_PACKET_RTS(_p)                 ((_p)->cb[11])
+
+// Flags control for RT2500 USB bulk out frame type
+#define RTUSB_SET_BULK_FLAG(_M, _F)				((_M)->BulkFlags |= (_F))
+#define RTUSB_CLEAR_BULK_FLAG(_M, _F)			((_M)->BulkFlags &= ~(_F))
+#define RTUSB_TEST_BULK_FLAG(_M, _F)			(((_M)->BulkFlags & (_F)) != 0)
+
+#define EnqueueCmd(cmdq, cmdqelmt)		\
+{										\
+	if (cmdq->size == 0)				\
+		cmdq->head = cmdqelmt;			\
+	else								\
+		cmdq->tail->next = cmdqelmt;	\
+	cmdq->tail = cmdqelmt;				\
+	cmdqelmt->next = NULL;				\
+	cmdq->size++;						\
+}
+
+// Free Tx ring descriptor MACRO
+// This can only called from complete function since it will change the IO counters
+#define	FREE_TX_RING(_p, _t)			\
+{										\
+	(_t)->InUse      = FALSE;			\
+	(_t)->LastOne    = FALSE;			\
+	(_t)->IRPPending = FALSE;			\
+	(_t)->BulkOutSize= 0;				\
+	(_p)->NextBulkOutIndex = (((_p)->NextBulkOutIndex + 1) % TX_RING_SIZE);	\
+	atomic_dec(&(_p)->TxCount); \
+}
+
+#define	LOCAL_TX_RING_EMPTY(_p)		(((_p)->TxContext[(_p)->NextBulkOutIndex].InUse) == FALSE)
+
+//
+//  Miniport routines in rtusb_main.c
+//
+
+
+//
+// Function Prototype in rtusb_data.c
+//
+
+int RTUSBSendPackets(struct sk_buff *skb, struct net_device *dev);
+
+NDIS_STATUS	RTUSBSendPacket(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN  struct sk_buff  *skb);
+
+VOID	RTUSBDeQueuePacket(
+	IN	PRT2570ADAPTER	pAdapter);
+
+NDIS_STATUS	RTUSBFreeDescriptorRequest(
+	IN		PRT2570ADAPTER	pAdapter,
+	IN		UCHAR			RingType,
+	IN		UCHAR			NumberRequired);
+
+VOID	RTUSBRejectPendingPackets(
+	IN	PRT2570ADAPTER	pAdapter);
+
+NDIS_STATUS	RTUSBHardEncrypt(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN  struct sk_buff  *skb,
+	IN	UCHAR			NumberRequired,
+	IN	ULONG			EnableTxBurst);
+
+VOID RTUSBRxPacket(unsigned long data);
+//VOID RTUSBRxPacket(purbb_t pUrb);
+
+VOID	RTUSBDequeueMLMEPacket(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID	RTUSBCleanUpMLMEWaitQueue(
+	IN	PRT2570ADAPTER	pAdapter);
+USHORT	RTUSBCalcDuration(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	UCHAR			Rate,
+	IN	ULONG			Size);
+
+VOID	RTUSBWriteTxDescriptor(
+	IN	PTXD_STRUC	pTxD,
+	IN	BOOLEAN		Fragment,
+	IN	UCHAR		RetryLimit,
+	IN	BOOLEAN		Ack,
+	IN  BOOLEAN     InsTimestamp,
+	IN  BOOLEAN     new_seq,
+	IN	UCHAR		Ifs,
+	IN	UINT		Length,
+	IN	BOOLEAN		Cipher,
+	IN	UCHAR		KeyID,
+	IN	UCHAR		CWMin,
+	IN	UCHAR		CWMax,
+	IN	UINT		PLCPLength,
+	IN	UINT		Rate,
+	IN	UCHAR		Service,
+	IN  USHORT      TxPreamble);
+
+VOID	RTUSBWriteBeaconDescriptor(
+	IN	PTXD_STRUC	pTxD,
+	IN	UINT		Length,
+	IN	UINT		PLCPLength,
+	IN	UINT		Rate,
+	IN	UCHAR		Service,
+	IN  USHORT      TxPreamble);
+//
+// Function Prototype in rtusb_init.c
+//
+NDIS_STATUS RTMPAllocAdapterBlock( PRT2570ADAPTER	*ppAdapter);
+NDIS_STATUS NICInitTransmit( PRT2570ADAPTER pAdapter );
+NDIS_STATUS NICInitRecv( PRT2570ADAPTER pAdapter);
+NDIS_STATUS RT2570InitAdapterBlock(	PRT2570ADAPTER	pAdapter);
+//
+// Function Prototype in rtusb_io.c
+//
+NTSTATUS	RTUSBSingleRead(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	OUT	PUSHORT			pValue);
+
+NTSTATUS	RTUSBSingleWrite(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	IN	USHORT			Value);
+
+NTSTATUS	RTUSBMultiRead(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	OUT	PUCHAR			pData,
+	IN	USHORT			length);
+
+NTSTATUS	RTUSBMultiWrite(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	IN	PUCHAR			pData,
+	IN	USHORT			length);
+
+NTSTATUS	RTUSBReadMACRegister(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	OUT	PUSHORT			pValue);
+
+NTSTATUS	RTUSBWriteMACRegister(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	IN	USHORT			Value);
+
+NTSTATUS	RTUSBMultiReadMAC(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	OUT	PUCHAR			pData,
+	IN	USHORT			length);
+
+NTSTATUS	RTUSBMultiWriteMAC(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	IN	PUCHAR			pData,
+	IN	USHORT			length);
+
+NTSTATUS	RTUSBReadBBPRegister(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	UCHAR			Id,
+	IN	PUCHAR			pValue);
+
+NTSTATUS	RTUSBWriteBBPRegister(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	UCHAR			Id,
+	IN	UCHAR			Value);
+
+NTSTATUS	RTUSBWriteRFRegister(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	ULONG			Value);
+
+NTSTATUS	RTUSB_CallUSBD(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PURB			Urb);
+
+INT	RTUSB_VendorRequest(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	ULONG			TransferFlags,
+	IN	UCHAR			ReservedBits,
+	IN	UCHAR			Request,
+	IN	USHORT			Value,
+	IN	USHORT			Index,
+	IN	PVOID			TransferBuffer,
+	IN	ULONG			TransferBufferLength);
+
+NTSTATUS	RTUSB_ConfigureDevice(
+	IN	PRT2570ADAPTER	Adapter);
+
+NTSTATUS	RTUSB_GetDeviceDescriptor(
+	IN	PRT2570ADAPTER	Adapter);
+
+VOID	RTUSB_FreeDeviceDescriptor(
+	IN	PRT2570ADAPTER	pAdapter);
+
+
+VOID	RTUSB_FreeConfigUrb(
+	IN	PURB	pUrb);
+
+
+NTSTATUS	RTUSB_ResetDevice(
+	IN	PRT2570ADAPTER	Adapter);
+
+BOOLEAN	RTUSB_InterfaceStart(
+	IN	PRT2570ADAPTER	Adapter);
+
+VOID	RTUSB_InterfaceStop(
+	IN	PRT2570ADAPTER	Adapter);
+
+NTSTATUS	RTUSB_ResetPipe(
+	IN	PRT2570ADAPTER	pAdapter, 
+	IN	UINT			BulkPipe);
+
+NTSTATUS	RTUSBReadEEPROM(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	OUT	PUCHAR			pData,
+	IN	USHORT			length);
+
+NTSTATUS	RTUSBWriteEEPROM(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	IN	PUCHAR			pData,
+	IN	USHORT			length);
+
+VOID	RTUSBInitializeCmdQ(
+	IN	PCmdQ	cmdq);
+
+NDIS_STATUS	RTUSBEnqueueCmdFromNdis(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	NDIS_OID		Oid,
+	IN	BOOLEAN			SetInformation,
+	IN	PVOID			pInformationBuffer,
+	IN	ULONG			InformationBufferLength);
+
+VOID	RTUSBEnqueueInternalCmd(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	NDIS_OID		Oid);
+
+VOID	RTUSBDequeueCmd(
+	IN	PCmdQ		cmdq,
+	OUT	PCmdQElmt	*pcmdqelmt);
+
+
+//
+// Function Prototype in rtusb_bulk.c
+//
+VOID	RTUSBBulkReceive(
+	IN	PRT2570ADAPTER	pAdapter);
+
+
+VOID	RTUSBBulkOutDataPacket(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	UCHAR	Index);
+
+
+VOID	RTUSBBulkOutNullFrame(
+	IN	PRT2570ADAPTER	pAdapter);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+VOID RTUSBBulkOutDataPacketComplete(purbb_t purb,struct pt_regs *pt_regs);
+VOID RTUSBBulkOutNullFrameComplete(purbb_t pUrb,struct pt_regs *pt_regs);
+VOID RTUSBBulkOutMLMEPacketComplete(purbb_t pUrb,struct pt_regs *pt_regs);
+VOID RTUSBBulkRxComplete(purbb_t pUrb,struct pt_regs *pt_regs);
+VOID RTUSBBulkOutBeaconComplete(purbb_t pUrb,struct pt_regs *pt_regs);
+#else
+VOID RTUSBBulkOutDataPacketComplete(purbb_t pUrb);
+VOID RTUSBBulkOutNullFrameComplete(purbb_t pUrb);
+VOID RTUSBBulkOutMLMEPacketComplete(purbb_t pUrb);
+VOID RTUSBBulkRxComplete(purbb_t pUrb);
+VOID RTUSBBulkOutBeaconComplete(purbb_t pUrb);
+#endif
+
+VOID	RTUSBBulkOutMLMEPacket(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	UCHAR			Index);
+
+
+VOID	RTUSBKickBulkOut(
+	IN	PRT2570ADAPTER pAdapter);
+
+VOID	RTUSBCleanUpDataBulkOutQueue(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID	RTUSBCleanUpMLMEBulkOutQueue(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID	RTUSBCancelPendingIRPs(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID	RTUSBCancelPendingBulkInIRP(
+	IN	PRT2570ADAPTER	pAdapter);
+
+VOID	RTUSBCancelPendingBulkOutIRP(
+	IN	PRT2570ADAPTER	pAdapter);
+
+
+#endif	// __RTUSB_H__
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rtusb_bulk.c linux-2.4.35.3-mct/drivers/usb/rt2570/rtusb_bulk.c
--- linux-2.4.35.3/drivers/usb/rt2570/rtusb_bulk.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rtusb_bulk.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,1457 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	rtusb_bulk.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ *	RobinC		02-06-2005	usb_kill_urb fixes for kernels =>2.6.7
+ ***************************************************************************/
+
+#include	"rt_config.h"
+#ifndef URB_ASYNC_UNLINK
+#define URB_ASYNC_UNLINK	0
+#endif
+//typedef VOID (*STATE_MACHINE_FUNC)(VOID *Adaptor, MLME_QUEUE_ELEM *Elem);
+
+void RTusb_fill_bulk_urb (struct urb *pUrb,
+	struct usb_device *usb,
+	unsigned int bulkpipe,
+	void *TransferBuf,
+	int BufSize,
+	usb_complete_t Complete,
+	void *Context)
+{
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+usb_fill_bulk_urb(pUrb, usb, bulkpipe, TransferBuf, BufSize, Complete, Context);	
+
+
+#else
+FILL_BULK_URB(pUrb, usb, bulkpipe, TransferBuf, BufSize, Complete, Context);	
+#endif
+
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBBulkOutDataPacket(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	UCHAR	Index)
+{
+	PTX_CONTEXT pTxContext;
+	PURB			pUrb;
+	int ret = 0;
+					
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	if (pAdapter->BulkOutPending == TRUE)
+	{
+		NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+		return;
+	}
+	pAdapter->BulkOutPending = TRUE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+	pTxContext = &(pAdapter->TxContext[Index]);
+
+	// Increase Total transmit byte counter
+	pAdapter->RalinkCounters.TransmittedByteCount +=  pTxContext->BulkOutSize;
+
+	// Clear Data flag
+	RTUSB_CLEAR_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_DATA_FRAG);
+	//The Data Bulk out protection is to Test InUse flag, temporarily not CLEAR DATA_NORMAL flag to test
+	//RTUSB_CLEAR_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_DATA_NORMAL);
+	pUrb = pTxContext->pUrb;
+	if (pTxContext->InUse != TRUE)
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "RTUSBBulkOutDataPacket failed, pTxContext->InUse != TRUE, Index %d, NextBulkOutIndex %d\n", Index, pAdapter->NextBulkOutIndex);
+		NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+		pAdapter->BulkOutPending = FALSE;
+		NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+		return;
+	}
+	else if (pAdapter->MediaState == NdisMediaStateDisconnected &&
+		  !( pAdapter->PortCfg.BssType == BSS_MONITOR && pAdapter->PortCfg.MallowRFMONTx == TRUE   )
+		)
+	{
+		//
+		// Since there is no connection, so we need to empty the Tx Bulk out Ring.
+		//
+		while (atomic_read(&pAdapter->TxCount) > 0)
+		{
+			DBGPRINT(RT_DEBUG_ERROR, "RTUSBBulkOutDataPacket failed, snice NdisMediaStateDisconnected discard NextBulkOutIndex %d, NextIndex = %d\n", pAdapter->NextBulkOutIndex, pAdapter->NextTxIndex);
+			FREE_TX_RING(pAdapter, pTxContext);			
+			pTxContext = &(pAdapter->TxContext[pAdapter->NextBulkOutIndex]);
+		}
+
+		NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+		pAdapter->BulkOutPending = FALSE;
+		NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+		
+		return;
+	}
+		
+	pTxContext->IRPPending = TRUE;
+
+	RTusb_fill_bulk_urb(pUrb,
+		pAdapter->usb,
+		usb_sndbulkpipe(pAdapter->usb, 1),
+		pTxContext->TransferBuffer,
+		pTxContext->BulkOutSize,
+		RTUSBBulkOutDataPacketComplete,
+		pTxContext);
+
+	if((ret = rtusb_submit_urb(pUrb))!=0)
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Submit Tx URB failed %d\n", ret);
+		return;
+	}
+	DBGPRINT(RT_DEBUG_INFO,"<==RTUSBBulkOutDataPacket BulkOutSize = %d\n", pTxContext->BulkOutSize);
+
+	return;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBBulkOutNullFrame(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	PTX_CONTEXT	pNullContext = &(pAdapter->NullContext);
+	PURB			pUrb;
+	int ret = 0;
+
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	if (pAdapter->BulkOutPending == TRUE)
+	{
+		NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+		return;
+	}
+	pAdapter->BulkOutPending = TRUE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+	// Increase Total transmit byte counter
+	pAdapter->RalinkCounters.TransmittedByteCount +=  pNullContext->BulkOutSize;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutNullFrame \n");
+	
+	pUrb = pNullContext->pUrb;
+	RTusb_fill_bulk_urb(pUrb,
+		pAdapter->usb,
+		usb_sndbulkpipe(pAdapter->usb, 1),
+		pNullContext->TransferBuffer,
+		pNullContext->BulkOutSize,
+		RTUSBBulkOutNullFrameComplete,
+		pNullContext);
+
+	if((ret = rtusb_submit_urb(pUrb))!=0)
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Submit Tx URB failed %d\n", ret);
+		return;
+	}
+	DBGPRINT(RT_DEBUG_INFO,"<==RTUSBBulkOutDataPacket\n");
+
+	return;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBBulkOutMLMEPacket(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	UCHAR			Index)
+{
+	PTX_CONTEXT		pMLMEContext;
+	PURB			pUrb;
+	int ret = 0;
+					
+	pMLMEContext = &pAdapter->MLMEContext[Index];
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	if (pAdapter->BulkOutPending == TRUE)
+	{
+		NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+		return;
+	}
+	pAdapter->BulkOutPending = TRUE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+
+	// Increase Total transmit byte counter
+	pAdapter->RalinkCounters.TransmittedByteCount +=  pMLMEContext->BulkOutSize;
+
+	// Clear MLME bulk flag
+	RTUSB_CLEAR_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_MLME);
+
+	DBGPRINT(RT_DEBUG_INFO, "RTUSBBulkOutMLMEPacket::PrioRingFirstIndex = %d, PrioRingTxCnt = %d, PopMgmtIndex = %d, PushMgmtIndex = %d, NextMLMEIndex = %d\n", 
+			pAdapter->PrioRingFirstIndex, 
+			pAdapter->PrioRingTxCnt, pAdapter->PopMgmtIndex, pAdapter->PushMgmtIndex, pAdapter->NextMLMEIndex);
+
+	pMLMEContext->IRPPending = TRUE;
+
+	pUrb = pMLMEContext->pUrb;
+		
+	RTusb_fill_bulk_urb(pUrb,
+		pAdapter->usb,
+		usb_sndbulkpipe(pAdapter->usb, 1),
+		pMLMEContext->TransferBuffer,
+		pMLMEContext->BulkOutSize,
+		RTUSBBulkOutMLMEPacketComplete,
+		pMLMEContext);
+	
+	if((ret = rtusb_submit_urb(pUrb))!=0)
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Submit MLME URB failed %d\n", ret);
+		return;
+	}
+	DBGPRINT(RT_DEBUG_INFO,"<==RTUSBBulkOutMLMEPacket\n");
+
+	return;
+}
+
+
+
+
+
+
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+
+VOID RTUSBBulkOutDataPacketComplete(purbb_t pUrb,struct pt_regs *pt_regs)
+{
+	PTX_CONTEXT 	pTxContext;
+	PRT2570ADAPTER	pAdapter;
+	NTSTATUS		status;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutDataPacketComplete\n");
+	pTxContext= (PTX_CONTEXT)pUrb->context;
+	pAdapter = pTxContext->pAdapter;
+	status = pUrb->status;
+	if (status == USB_ST_NOERROR)
+ 	{
+		if (pTxContext->LastOne == TRUE)
+		{
+			pAdapter->Counters.GoodTransmits++;
+			FREE_TX_RING(pAdapter, pTxContext);
+
+			if (!skb_queue_empty(&pAdapter->SendTxWaitQueue))
+			{
+				RTUSBDeQueuePacket(pAdapter);
+			}
+		}
+		else
+		{
+			if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET)))
+			{
+				FREE_TX_RING(pAdapter, pTxContext);
+				// Indicate next one is frag data which has highest priority
+				RTUSB_SET_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_DATA_FRAG);
+			}
+			else
+			{
+				while (pTxContext->LastOne != TRUE)
+				{
+					FREE_TX_RING(pAdapter, pTxContext);
+					pTxContext = &(pAdapter->TxContext[pAdapter->NextBulkOutIndex]);
+				}
+				
+				FREE_TX_RING(pAdapter, pTxContext);
+			}
+		}
+ 	}
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	pAdapter->BulkOutPending = FALSE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAdapter);
+
+	
+}
+
+VOID  RTUSBBulkOutNullFrameComplete(purbb_t pUrb,struct pt_regs *pt_regs)
+{
+	PRT2570ADAPTER	pAdapter;
+	PTX_CONTEXT	pNullContext;
+	NTSTATUS		status;
+	
+	pNullContext= (PTX_CONTEXT)pUrb->context;
+	pAdapter = pNullContext->pAdapter;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutNullFrameComplete\n");
+
+	// Reset Null frame context flags
+	pNullContext->IRPPending = FALSE;
+	pNullContext->InUse = FALSE;
+	// Clear Null frame bulk flag
+	RTUSB_CLEAR_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_DATA_NULL);
+
+	status = pUrb->status;
+	if (status == USB_ST_NOERROR)
+	{
+		// Don't worry about the queue is empty or not, this function will check itself
+		RTUSBDeQueuePacket(pAdapter);
+	}
+	else
+	{
+		if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out Null Frame Failed\n");
+			RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET);
+			RTUSBEnqueueInternalCmd(pAdapter, RT_OID_USB_RESET_BULK_OUT);
+		}
+	}
+
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	pAdapter->BulkOutPending = FALSE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAdapter);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutNullFrameComplete\n");
+
+}
+
+VOID	RTUSBBulkOutMLMEPacketComplete(purbb_t pUrb,struct pt_regs *pt_regs)
+{
+	PTX_CONTEXT			pMLMEContext;
+	PRT2570ADAPTER		pAdapter;
+	NTSTATUS		status;
+
+	pMLMEContext= (PTX_CONTEXT)pUrb->context;
+	pAdapter = pMLMEContext->pAdapter;
+	status = pUrb->status;
+
+	pAdapter->PrioRingTxCnt--;
+	pAdapter->PrioRingFirstIndex++;
+	if (pAdapter->PrioRingFirstIndex >= PRIO_RING_SIZE)
+	{
+		pAdapter->PrioRingFirstIndex = 0;
+	}	
+
+	DBGPRINT(RT_DEBUG_TRACE, ":: = %d,  = %d,   = %d,   = %d,   = %d\n", 
+			pAdapter->PrioRingFirstIndex, 
+			pAdapter->PrioRingTxCnt, pAdapter->PopMgmtIndex, pAdapter->PushMgmtIndex, pAdapter->NextMLMEIndex);
+	
+	// Reset MLME context flags
+	pMLMEContext->IRPPending 	= FALSE;
+	pMLMEContext->InUse 		= FALSE;
+	
+	if (status == STATUS_SUCCESS)
+	{
+		// Don't worry about the queue is empty or not, this function will check itself
+		RTUSBDequeueMLMEPacket(pAdapter);
+	}
+#if 0
+	else if (status != STATUS_CANCELLED)
+	{
+		if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out MLME Failed\n");
+			RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET);
+			RTUSBEnqueueInternalCmd(pAdapter, RT_OID_USB_RESET_BULK_OUT);
+		}
+	}
+#endif
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	pAdapter->BulkOutPending = FALSE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAdapter);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutMLMEPacketComplete\n");
+
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		This routine process Rx Irp and call rx complete function.
+		
+	Arguments:
+		DeviceObject	Pointer to the device object for next lower
+						device. DeviceObject passed in here belongs to
+						the next lower driver in the stack because we
+						were invoked via IoCallDriver in USB_RxPacket
+						AND it is not OUR device object
+	  Irp				Ptr to completed IRP
+	  Context			Ptr to our Adapter object (context specified
+						in IoSetCompletionRoutine
+		
+	Return Value:
+		Always returns STATUS_MORE_PROCESSING_REQUIRED
+
+	Note:
+		Always returns STATUS_MORE_PROCESSING_REQUIRED
+	========================================================================
+*/
+VOID	RTUSBBulkRxComplete(purbb_t pUrb,struct pt_regs *pt_regs)
+{
+
+	PRX_CONTEXT 	pRxContext;
+	PRT2570ADAPTER	pAdapter;
+	NTSTATUS		status;
+	
+	pRxContext= (PRX_CONTEXT)pUrb->context;
+	pAdapter = pRxContext->pAdapter;
+
+	//
+	// We have a number of cases:
+	//		1) The USB read timed out and we received no data.
+	//		2) The USB read timed out and we received some data.
+	//		3) The USB read was successful and fully filled our irp buffer.
+	//		4) The irp was cancelled.
+	//		5) Some other failure from the USB device object.
+	//
+	
+	//
+	// Free the IRP  and its mdl because they were	alloced by us
+	//
+#if 0
+	if ( (atomread = (atomic_read(&pRxContext->IrpLock))) == IRPLOCK_CANCE_START)
+	{
+		atomic_dec(&pAdapter->PendingRx);
+		atomic_set(&pRxContext->IrpLock, IRPLOCK_CANCE_COMPLETE);	
+	}
+#endif
+	status = pUrb->status;
+	atomic_set(&pRxContext->IrpLock, IRPLOCK_COMPLETED);
+	atomic_dec(&pAdapter->PendingRx);
+	
+	switch (status)
+	{
+		case 0:
+			 if ((status == USB_ST_NOERROR) && (atomic_read(&pRxContext->IrpLock) != IRPLOCK_CANCE_START))
+			{
+				//RTUSBRxPacket(pUrb);
+				pAdapter->rx_bh.data = (unsigned long)pUrb;
+				tasklet_schedule(&pAdapter->rx_bh);
+				break;
+				
+			}// STATUS_SUCCESS
+		DBGPRINT(RT_DEBUG_TEMP,"==> RTUSBBulkRxComplete  (IrpLock) = %d\n", atomic_read(&pRxContext->IrpLock));
+				break;
+		
+		case -ECONNRESET:		// async unlink
+		case -ESHUTDOWN:		// hardware gone = -108
+			pUrb = NULL;
+		DBGPRINT(RT_DEBUG_TEMP,"==> RTUSBBulkRxComplete Error code = %d\n", status);
+			//tasklet_schedule(&pAdapter->rx_bh);
+			break;
+
+	}
+#if 0
+	 if ((status == USB_ST_NOERROR) && (atomic_read(&pRxContext->IrpLock) != IRPLOCK_CANCE_START))
+	{
+		RTUSBRxPacket(pUrb);
+		//tasklet_schedule(&pAdapter->rx_bh);
+		
+	}// STATUS_SUCCESS
+	else
+	{
+		DBGPRINT(RT_DEBUG_TEMP,"==> RTUSBBulkRxComplete Error code = %d\n", status);
+		pRxContext->InUse = FALSE;
+
+		if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKIN_RESET)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk In Failed\n");
+			RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_BULKIN_RESET);
+			RTUSBEnqueueInternalCmd(pAdapter, RT_OID_USB_RESET_BULK_IN);
+		}
+	}
+
+#endif
+}
+
+VOID	RTUSBBulkOutPsPollComplete(purbb_t pUrb, struct pt_regs *pt_regs)
+{
+	PTX_CONTEXT	pPsPollContext;
+	PRT2570ADAPTER	pAdapter;
+	NTSTATUS		status;
+	
+	pPsPollContext= (PTX_CONTEXT)pUrb->context;
+	pAdapter = pPsPollContext->pAdapter;
+	pPsPollContext->IRPPending 	= FALSE;
+	pPsPollContext->InUse 		= FALSE;
+	status = pUrb->status;
+	if (status == USB_ST_NOERROR)
+	{
+		// Don't worry about the queue is empty or not, this function will check itself
+		RTUSBDeQueuePacket(pAdapter);
+	}
+	else
+	{
+		if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out Null Frame Failed\n");
+			RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET);
+			RTUSBEnqueueInternalCmd(pAdapter, RT_OID_USB_RESET_BULK_OUT);
+		}
+	}
+
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	pAdapter->BulkOutPending = FALSE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAdapter);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutNullFrameComplete\n");
+
+}
+VOID RTUSBBulkOutBeaconComplete(purbb_t pUrb,struct pt_regs *pt_regs)
+{
+	PRT2570ADAPTER	pAdapter;
+	PTX_CONTEXT	pBeaconContext;
+	
+	pBeaconContext= (PTX_CONTEXT)pUrb->context;
+	pAdapter = pBeaconContext->pAdapter;
+
+	DBGPRINT_RAW(RT_DEBUG_TEMP, "--->RTUSBBulkOutBeaconComplete\n");
+
+	// Reset Null frame context flags
+	pBeaconContext->IRPPending = FALSE;
+	pBeaconContext->InUse = FALSE;
+
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	pAdapter->BulkOutPending = FALSE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAdapter);
+
+}
+
+#else
+
+VOID RTUSBBulkOutDataPacketComplete(purbb_t pUrb)
+{
+	PTX_CONTEXT 	pTxContext;
+	PRT2570ADAPTER	pAdapter;
+	NTSTATUS		status;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutDataPacketComplete\n");
+	pTxContext= (PTX_CONTEXT)pUrb->context;
+	pAdapter = pTxContext->pAdapter;
+	status = pUrb->status;
+	if (status == USB_ST_NOERROR)
+ 	{
+		if (pTxContext->LastOne == TRUE)
+		{
+			pAdapter->Counters.GoodTransmits++;
+			FREE_TX_RING(pAdapter, pTxContext);
+
+			if (!skb_queue_empty(&pAdapter->SendTxWaitQueue))
+			{
+				RTUSBDeQueuePacket(pAdapter);
+			}
+		}
+		else
+		{
+			if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET)))
+			{
+				FREE_TX_RING(pAdapter, pTxContext);
+				// Indicate next one is frag data which has highest priority
+				RTUSB_SET_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_DATA_FRAG);
+			}
+			else
+			{
+				while (pTxContext->LastOne != TRUE)
+				{
+					FREE_TX_RING(pAdapter, pTxContext);
+					pTxContext = &(pAdapter->TxContext[pAdapter->NextBulkOutIndex]);
+				}
+				
+				FREE_TX_RING(pAdapter, pTxContext);
+			}
+		}
+ 	}
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	pAdapter->BulkOutPending = FALSE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAdapter);
+
+	
+}
+
+
+VOID  RTUSBBulkOutNullFrameComplete(purbb_t pUrb)
+{
+	PRT2570ADAPTER	pAdapter;
+	PTX_CONTEXT	pNullContext;
+	NTSTATUS		status;
+	
+	pNullContext= (PTX_CONTEXT)pUrb->context;
+	pAdapter = pNullContext->pAdapter;
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutNullFrameComplete\n");
+
+	// Reset Null frame context flags
+	pNullContext->IRPPending = FALSE;
+	pNullContext->InUse = FALSE;
+	// Clear Null frame bulk flag
+	RTUSB_CLEAR_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_DATA_NULL);
+
+	status = pUrb->status;
+	if (status == USB_ST_NOERROR)
+	{
+		// Don't worry about the queue is empty or not, this function will check itself
+		RTUSBDeQueuePacket(pAdapter);
+	}
+	else
+	{
+		if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out Null Frame Failed\n");
+			RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET);
+			RTUSBEnqueueInternalCmd(pAdapter, RT_OID_USB_RESET_BULK_OUT);
+		}
+	}
+
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	pAdapter->BulkOutPending = FALSE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAdapter);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutNullFrameComplete\n");
+
+}
+
+VOID  RTUSBBulkOutMLMEPacketComplete(purbb_t pUrb)
+{
+	PTX_CONTEXT			pMLMEContext;
+	PRT2570ADAPTER		pAdapter;
+	NTSTATUS		status;
+
+	pMLMEContext= (PTX_CONTEXT)pUrb->context;
+	pAdapter = pMLMEContext->pAdapter;
+	status = pUrb->status;
+
+	pAdapter->PrioRingTxCnt--;
+	pAdapter->PrioRingFirstIndex++;
+	if (pAdapter->PrioRingFirstIndex >= PRIO_RING_SIZE)
+	{
+		pAdapter->PrioRingFirstIndex = 0;
+	}	
+
+	DBGPRINT(RT_DEBUG_INFO, "RTUSBBulkOutMLMEPacketComplete::PrioRingFirstIndex = %d, PrioRingTxCnt = %d, PopMgmtIndex = %d, PushMgmtIndex = %d, NextMLMEIndex = %d\n", 
+			pAdapter->PrioRingFirstIndex, 
+			pAdapter->PrioRingTxCnt, pAdapter->PopMgmtIndex, pAdapter->PushMgmtIndex, pAdapter->NextMLMEIndex);
+
+	
+	// Reset MLME context flags
+	pMLMEContext->IRPPending 	= FALSE;
+	pMLMEContext->InUse 		= FALSE;
+	
+	if (status == STATUS_SUCCESS)
+	{
+		// Don't worry about the queue is empty or not, this function will check itself
+		RTUSBDequeueMLMEPacket(pAdapter);
+	}
+#if 0
+	else if (status != STATUS_CANCELLED)
+	{
+		if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out MLME Failed\n");
+			RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET);
+			RTUSBEnqueueInternalCmd(pAdapter, RT_OID_USB_RESET_BULK_OUT);
+		}
+	}
+#endif
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	pAdapter->BulkOutPending = FALSE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAdapter);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutMLMEPacketComplete\n");
+
+}
+
+/*
+	========================================================================
+
+	Routine Description:
+		This routine process Rx Irp and call rx complete function.
+		
+	Arguments:
+		DeviceObject	Pointer to the device object for next lower
+						device. DeviceObject passed in here belongs to
+						the next lower driver in the stack because we
+						were invoked via IoCallDriver in USB_RxPacket
+						AND it is not OUR device object
+	  Irp				Ptr to completed IRP
+	  Context			Ptr to our Adapter object (context specified
+						in IoSetCompletionRoutine
+		
+	Return Value:
+		Always returns STATUS_MORE_PROCESSING_REQUIRED
+
+	Note:
+		Always returns STATUS_MORE_PROCESSING_REQUIRED
+	========================================================================
+*/
+VOID	RTUSBBulkRxComplete(purbb_t pUrb)
+{
+
+	PRX_CONTEXT 	pRxContext;
+	PRT2570ADAPTER	pAdapter;
+	NTSTATUS		status;
+	
+	pRxContext= (PRX_CONTEXT)pUrb->context;
+	pAdapter = pRxContext->pAdapter;
+
+	//
+	// We have a number of cases:
+	//		1) The USB read timed out and we received no data.
+	//		2) The USB read timed out and we received some data.
+	//		3) The USB read was successful and fully filled our irp buffer.
+	//		4) The irp was cancelled.
+	//		5) Some other failure from the USB device object.
+	//
+	
+	//
+	// Free the IRP  and its mdl because they were	alloced by us
+	//
+#if 0
+	if ( (atomread = (atomic_read(&pRxContext->IrpLock))) == IRPLOCK_CANCE_START)
+	{
+		atomic_dec(&pAdapter->PendingRx);
+		atomic_set(&pRxContext->IrpLock, IRPLOCK_CANCE_COMPLETE);	
+	}
+#endif
+	status = pUrb->status;
+	atomic_set(&pRxContext->IrpLock, IRPLOCK_COMPLETED);
+	atomic_dec(&pAdapter->PendingRx);
+	
+	switch (status)
+	{
+		case 0:
+			 if ((status == USB_ST_NOERROR) && (atomic_read(&pRxContext->IrpLock) != IRPLOCK_CANCE_START))
+			{
+				//RTUSBRxPacket(pUrb);
+				pAdapter->rx_bh.data = (unsigned long)pUrb;
+				tasklet_schedule(&pAdapter->rx_bh);
+				break;
+				
+			}// STATUS_SUCCESS
+		DBGPRINT(RT_DEBUG_TEMP,"==> RTUSBBulkRxComplete  (IrpLock) = %d\n", atomic_read(&pRxContext->IrpLock));
+				break;
+		
+		case -ECONNRESET:		// async unlink
+		case -ESHUTDOWN:		// hardware gone = -108
+			pUrb = NULL;
+		DBGPRINT(RT_DEBUG_ERROR,"==> RTUSBBulkRxComplete Error code = %d\n", status);
+			//tasklet_schedule(&pAdapter->rx_bh);
+			break;
+
+	}
+#if 0
+	 if ((status == USB_ST_NOERROR) && (atomic_read(&pRxContext->IrpLock) != IRPLOCK_CANCE_START))
+	{
+		RTUSBRxPacket(pUrb);
+		//tasklet_schedule(&pAdapter->rx_bh);
+		
+	}// STATUS_SUCCESS
+	else
+	{
+		DBGPRINT(RT_DEBUG_TEMP,"==> RTUSBBulkRxComplete Error code = %d\n", status);
+		pRxContext->InUse = FALSE;
+
+		if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKIN_RESET)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk In Failed\n");
+			RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_BULKIN_RESET);
+			RTUSBEnqueueInternalCmd(pAdapter, RT_OID_USB_RESET_BULK_IN);
+		}
+	}
+
+#endif
+}
+VOID	RTUSBBulkOutPsPollComplete(purbb_t pUrb)
+{
+	PTX_CONTEXT	pPsPollContext;
+	PRT2570ADAPTER	pAdapter;
+	NTSTATUS		status;
+	
+	pPsPollContext= (PTX_CONTEXT)pUrb->context;
+	pAdapter = pPsPollContext->pAdapter;
+	pPsPollContext->IRPPending 	= FALSE;
+	pPsPollContext->InUse 		= FALSE;
+	status = pUrb->status;
+	if (status == USB_ST_NOERROR)
+	{
+		// Don't worry about the queue is empty or not, this function will check itself
+		RTUSBDeQueuePacket(pAdapter);
+	}
+	else
+	{
+		if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out Null Frame Failed\n");
+			RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET);
+			RTUSBEnqueueInternalCmd(pAdapter, RT_OID_USB_RESET_BULK_OUT);
+		}
+	}
+
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	pAdapter->BulkOutPending = FALSE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAdapter);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutNullFrameComplete\n");
+
+}
+VOID RTUSBBulkOutBeaconComplete(purbb_t pUrb)
+{
+
+	PTX_CONTEXT		pBeaconContext;
+	PRT2570ADAPTER	pAdapter;
+	NTSTATUS		status;
+	
+	pBeaconContext= (PTX_CONTEXT)pUrb->context;
+	pAdapter = pBeaconContext->pAdapter;
+	pBeaconContext->IRPPending 	= FALSE;
+	pBeaconContext->InUse 		= FALSE;
+	status = pUrb->status;
+
+	if (status != USB_ST_NOERROR)
+	{
+		if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)) &&
+			(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET)))
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR, "Bulk Out Beacon Frame Failed\n");
+			RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET);
+			RTUSBEnqueueInternalCmd(pAdapter, RT_OID_USB_RESET_BULK_OUT);
+		}
+	}
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	pAdapter->BulkOutPending = FALSE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+
+	// Always call Bulk routine, even reset bulk.
+	// The protectioon of rest bulk should be in BulkOut routine
+	RTUSBKickBulkOut(pAdapter);
+
+}
+
+#endif
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID RTUSBBulkOutBeacon(
+	IN PRT2570ADAPTER	pAdapter,
+	IN INT 			BeaconIndex)
+{
+	PTX_CONTEXT pBeaconContext;
+	PURB			pUrb;
+	int ret = 0;
+	
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	if (pAdapter->BulkOutPending == TRUE)
+	{
+		NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+		return;
+	}
+	pAdapter->BulkOutPending = TRUE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+
+	
+	// Clear Beacon 0, 1 flag and set beacon 1 flag if required
+	if (RTUSB_TEST_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_BEACON_0))
+	{
+		// Clear beacon 0 flag
+		RTUSB_CLEAR_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_BEACON_0);
+		// Set beacon 1 flag
+		RTUSB_SET_BULK_FLAG (pAdapter, fRTUSB_BULK_OUT_BEACON_1);
+	}
+	else
+	{
+		// Clear beacon 1 flag
+		RTUSB_CLEAR_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_BEACON_1);
+	}
+	
+	pBeaconContext  = &pAdapter->BeaconContext[BeaconIndex];
+	DBGPRINT_RAW(RT_DEBUG_TEMP, "--->RTUSBBulkOutBeacon BulkOutSize %d\n",pBeaconContext->BulkOutSize);
+	pUrb = pBeaconContext->pUrb;
+	RTusb_fill_bulk_urb(pUrb,
+		pAdapter->usb,
+		usb_sndbulkpipe(pAdapter->usb, 1),
+		pBeaconContext->TransferBuffer,
+		pBeaconContext->BulkOutSize,
+		RTUSBBulkOutBeaconComplete,
+		pBeaconContext);
+
+	if((ret = rtusb_submit_urb(pUrb))!=0)
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Submit Tx URB failed %d\n", ret);
+		return;
+	}
+	
+	DBGPRINT_RAW(RT_DEBUG_INFO, "<---RTUSBBulkOutBeacon \n");
+}
+
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBBulkOutPsPoll(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	PTX_CONTEXT	pPsPollContext = &(pAdapter->PsPollContext);
+	PURB			pUrb;
+	int ret = 0;
+
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	if (pAdapter->BulkOutPending == TRUE)
+	{
+		NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+		return;
+	}
+	pAdapter->BulkOutPending = TRUE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+
+	// Clear PS-Poll bulk flag
+	RTUSB_CLEAR_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_PSPOLL);
+
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->RTUSBBulkOutPsPollFrame \n");
+	
+	pUrb = pPsPollContext->pUrb;
+	RTusb_fill_bulk_urb(pUrb,
+		pAdapter->usb,
+		usb_sndbulkpipe(pAdapter->usb, 1),
+		pPsPollContext->TransferBuffer,
+		pPsPollContext->BulkOutSize,
+		RTUSBBulkOutPsPollComplete,
+		pPsPollContext);
+
+	if((ret = rtusb_submit_urb(pUrb))!=0)
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Submit Tx URB failed %d\n", ret);
+		return;
+	}
+	DBGPRINT(RT_DEBUG_INFO,"<==RTUSBBulkOutPsPollPacket\n");
+
+	return;
+
+
+}
+
+
+/*
+	========================================================================
+
+	Routine Description:
+	USB_RxPacket initializes a URB and uses the Rx IRP to submit it
+	to USB. It checks if an Rx Descriptor is available and passes the
+	the coresponding buffer to be filled. If no descriptor is available
+	fails the request. When setting the completion routine we pass our
+	Adapter Object as Context.
+		
+	Arguments:
+		
+	Return Value:
+		TRUE			found matched tuple cache
+		FALSE			no matched found
+
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBBulkReceive(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	
+	PRX_CONTEXT pRxContext;
+	PURB			pUrb;
+	int ret = 0;
+
+	if ((RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS))||
+		(RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RADIO_OFF))||
+		(RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS)))
+		{
+	DBGPRINT(RT_DEBUG_TEMP,"==>RTUSBBulkReceive, pAdapter->NextRxBulkInIndex = %d\n",pAdapter->NextRxBulkInIndex);
+		return;
+		}
+	//DBGPRINT(RT_DEBUG_TEMP,"==>RTUSBBulkReceive, pAdapter->NextRxBulkInIndex = %d\n",pAdapter->NextRxBulkInIndex);
+	pRxContext = &(pAdapter->RxContext[pAdapter->NextRxBulkInIndex]);
+	pRxContext->InUse = TRUE;
+	pAdapter->NextRxBulkInIndex = (pAdapter->NextRxBulkInIndex + 1) % RX_RING_SIZE;
+
+	pUrb = pRxContext->pUrb;
+		
+	atomic_set(&pRxContext->IrpLock, IRPLOCK_CANCELABLE);	
+	atomic_add(1, &pAdapter->PendingRx);
+	memset(pRxContext->TransferBuffer, 0, BUFFER_SIZE);
+	RTusb_fill_bulk_urb(pUrb,
+		pAdapter->usb,
+		usb_rcvbulkpipe(pAdapter->usb, 1),
+		pRxContext->TransferBuffer,
+		BUFFER_SIZE,
+		RTUSBBulkRxComplete,
+		pRxContext);
+	
+	if((ret = rtusb_submit_urb(pUrb))!=0)
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Submit Rx URB failed %d\n", ret);
+		return;
+	}
+
+	return;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBKickBulkOut(
+	IN	PRT2570ADAPTER pAdapter)
+{
+	int	RoundOver = 0;
+	do
+	{
+		// greedy to bulk out. protection are in BulkOut function using InUse parameter
+		if (++RoundOver > 2)
+			break;
+		
+		if (!(RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)) &&
+			!(RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+			!(RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+			!(RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET)) &&
+			!(RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RADIO_OFF)))
+		{
+			// Start aribritrating Bulk out candidates
+
+			// 0. Check if no flags set, we will do a dequeue from MLME and Data
+			//if (pAdapter->BulkFlags == 0x0)
+			//{
+			//	RTUSBDequeueMLMEPacket(pAdapter);
+			//	RTUSBDeQueuePacket(pAdapter);
+			//}
+		
+			// 1. Data Fragment has highest priority
+			if (RTUSB_TEST_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_DATA_FRAG))
+			{
+				RTUSBBulkOutDataPacket(pAdapter, pAdapter->NextBulkOutIndex);
+			}
+			
+			// 2. PS-Poll frame is next
+			else if (RTUSB_TEST_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_PSPOLL))
+			{
+				RTUSBBulkOutPsPoll(pAdapter);
+			}
+			
+			// 3. Beacon 0, guarding beacon frame is next
+			else if (RTUSB_TEST_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_BEACON_0))
+			{
+				RTUSBBulkOutBeacon(pAdapter, 0);
+			}
+
+			// 4. Beacon 1, beacon frame body is next
+			else if (RTUSB_TEST_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_BEACON_1))
+			{
+				RTUSBBulkOutBeacon(pAdapter, 1);
+			}
+
+			// 5. Mlme frame is next
+			else if (RTUSB_TEST_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_MLME))
+			{
+				RTUSBBulkOutMLMEPacket(pAdapter, pAdapter->PrioRingFirstIndex);
+			}
+
+			// 6. Data frame normal is next
+			else if (RTUSB_TEST_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_DATA_NORMAL))
+			{
+				if ((!LOCAL_TX_RING_EMPTY(pAdapter)) && 
+					((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) && 
+					(pAdapter->MediaState == NdisMediaStateConnected)))
+				{
+					RTUSBBulkOutDataPacket(pAdapter, pAdapter->NextBulkOutIndex);
+				}
+			}
+
+			// 7. Null frame is the last
+			else if (RTUSB_TEST_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_DATA_NULL))
+			{
+				if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+				{
+					RTUSBBulkOutNullFrame(pAdapter);
+				}
+			}
+			
+			// 8. No data avaliable
+			else
+			{
+				// Do nothing, or dequeue MLME and Data
+				//RTUSBDequeueMLMEPacket(pAdapter);
+				//RTUSBDeQueuePacket(pAdapter);
+			}
+		}
+	}while(TRUE);
+	DBGPRINT_RAW(RT_DEBUG_INFO,"<---RTUSBKickBulkOut\n");
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBCleanUpDataBulkOutQueue(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	PTX_CONTEXT pTxContext;			
+
+	DBGPRINT(RT_DEBUG_TRACE, "--->CleanUpDataBulkOutQueue\n");
+				
+	while (!LOCAL_TX_RING_EMPTY(pAdapter))
+	{			
+		pTxContext 					= &(pAdapter->TxContext[pAdapter->NextBulkOutIndex]);
+		pTxContext->LastOne 		= FALSE;
+		pTxContext->InUse 			= FALSE;
+		pAdapter->NextBulkOutIndex 	= (pAdapter->NextBulkOutIndex + 1) % TX_RING_SIZE;
+	}
+	
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	pAdapter->BulkOutPending = FALSE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<---CleanUpDataBulkOutQueue\n");
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBCleanUpMLMEBulkOutQueue(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	DBGPRINT(RT_DEBUG_TRACE, "--->CleanUpMLMEBulkOutQueue\n");
+
+	NdisAcquireSpinLock(&pAdapter->MLMEQLock);
+	while (pAdapter->PrioRingTxCnt > 0)
+	{
+		pAdapter->MLMEContext[pAdapter->PrioRingFirstIndex].InUse = FALSE;
+			
+		pAdapter->PrioRingFirstIndex++;
+		if (pAdapter->PrioRingFirstIndex >= PRIO_RING_SIZE)
+		{
+			pAdapter->PrioRingFirstIndex = 0;
+		}
+
+		pAdapter->PrioRingTxCnt--;
+	}
+	NdisReleaseSpinLock(&pAdapter->MLMEQLock);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<---CleanUpMLMEBulkOutQueue\n");
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBCancelPendingIRPs(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	RTUSBCancelPendingBulkInIRP(pAdapter);
+	RTUSBCancelPendingBulkOutIRP(pAdapter);
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBCancelPendingBulkInIRP(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	PRX_CONTEXT	pRxContext;
+	UINT		i;
+
+	DBGPRINT_RAW(RT_DEBUG_TRACE,"--->RTUSBCancelPendingBulkInIRP\n");
+	for ( i = 0; i < RX_RING_SIZE; i++)
+	{
+		pRxContext = &(pAdapter->RxContext[i]);
+		if(atomic_read(&pRxContext->IrpLock) == IRPLOCK_CANCELABLE)
+		{
+			usb_kill_urb(pRxContext->pUrb);
+		}
+		atomic_set(&pRxContext->IrpLock, IRPLOCK_CANCE_START);
+	}
+	DBGPRINT_RAW(RT_DEBUG_TRACE,"<---RTUSBCancelPendingBulkInIRP\n");
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBCancelPendingBulkOutIRP(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	PTX_CONTEXT		pTxContext;
+	PTX_CONTEXT		pMLMEContext;
+	PTX_CONTEXT		pBeaconContext;
+	PTX_CONTEXT		pNullContext;
+	PTX_CONTEXT		pPsPollContext;
+	UINT		i;
+	
+	DBGPRINT_RAW(RT_DEBUG_TRACE,"--->RTUSBCancelPendingBulkOutIRP\n");
+	for ( i = 0; i < TX_RING_SIZE; i++)
+	{
+		pTxContext = &(pAdapter->TxContext[i]);
+		if (pTxContext->IRPPending == TRUE)
+		{
+			usb_kill_urb(pTxContext->pUrb);
+		}
+	}
+
+	for (i = 0; i < PRIO_RING_SIZE; i++)
+	{
+		pMLMEContext = &(pAdapter->MLMEContext[i]);
+
+		if(pMLMEContext->IRPPending == TRUE)
+		{
+
+			// Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself
+			// remove it from the HeadPendingSendList and NULL out HeadPendingSendList
+			//  when the last IRP on the list has been  cancelled; that's how we exit this loop
+			//
+
+			usb_kill_urb(pMLMEContext->pUrb);
+
+			// Sleep 200 microsecs to give cancellation time to work
+			NdisMSleep(200);
+		}
+	}
+
+	for (i = 0; i < BEACON_RING_SIZE; i++)
+	{
+		pBeaconContext = &(pAdapter->BeaconContext[i]);
+
+		if(pBeaconContext->IRPPending == TRUE)
+		{
+
+			// Get the USB_CONTEXT and cancel it's IRP; the completion routine will itself
+			// remove it from the HeadPendingSendList and NULL out HeadPendingSendList
+			//  when the last IRP on the list has been  cancelled; that's how we exit this loop
+			//
+
+			usb_kill_urb(pBeaconContext->pUrb);
+
+			// Sleep 200 microsecs to give cancellation time to work
+			NdisMSleep(200);
+		}
+	}
+
+	pNullContext = &(pAdapter->NullContext);
+	if (pNullContext->IRPPending == TRUE)
+	usb_kill_urb(pNullContext->pUrb);
+
+	pPsPollContext = &(pAdapter->PsPollContext);
+	if (pPsPollContext->IRPPending == TRUE)
+	usb_kill_urb(pPsPollContext->pUrb);
+
+	NdisAcquireSpinLock(&pAdapter->BulkOutLock);
+	pAdapter->BulkOutPending = FALSE;
+	NdisReleaseSpinLock(&pAdapter->BulkOutLock);
+	
+	DBGPRINT_RAW(RT_DEBUG_TRACE,"<---RTUSBCancelPendingBulkOutIRP\n");
+	
+}
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rtusb_data.c linux-2.4.35.3-mct/drivers/usb/rt2570/rtusb_data.c
--- linux-2.4.35.3/drivers/usb/rt2570/rtusb_data.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rtusb_data.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,3216 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	rtusb_data.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ *	RobinC		02-06-2005	RFMON Mode added
+ *	MathiasK	04-07-2005	big endian fix from gglomm
+ ***************************************************************************/
+
+#include	"rt_config.h"
+
+static  UCHAR PlcpSignal[12] = { 
+	 0, /* RATE_1 */    1, /* RATE_2 */     2, /* RATE_5_5 */   3, /* RATE_11 */    // see BBP spec
+	11, /* RATE_6 */   15, /* RATE_9 */    10, /* RATE_12 */   14, /* RATE_18 */    // see IEEE802.11a-1999 p.14
+	 9, /* RATE_24 */  13, /* RATE_36 */    8, /* RATE_48 */    12  /* RATE_54 */ }; // see IEEE802.11a-1999 p.14
+static	UINT	_11G_RATES[12] = { 0, 0, 0, 0, 6, 9, 12, 18, 24, 36, 48, 54 };
+static	UCHAR	SNAP_802_1H[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};
+static	UCHAR	SNAP_BRIDGE_TUNNEL[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8};
+static	UCHAR	EAPOL[] = {0x88, 0x8e};
+static	UCHAR	IPX[] = {0x81, 0x37};
+static	UCHAR	APPLE_TALK[] = {0x80, 0xf3};
+UCHAR	ARP[]={0x08, 0x06};
+////////////////////////////////////////////////////////////////////////////
+//
+//	FUNCTION
+//		RTUSBSendPackets
+//		
+//	DESCRIPTION
+//	  VNETMultipleSend handler is called by NDIS to transmit packets
+//	  through the adapter. If there are packets in the Q and the device
+//	  can accept the Tx requests initiate a transmission and queue the
+//	  rest of the packets (if any...). If we can not transmit or the
+//	  station is not ready we imediatelly complete the request
+//		
+//	INPUT
+//	  MiniportAdapterContext		Context registered with the wrapper
+//									(Ptr to to the Adapter object)
+//	  PacketArray					Array of Ptrs to NDIS_PACKET structs
+//	  NumberOfPackets				Number of packets in PacketArray
+//		
+//	OUTPUT
+//		-
+//		
+////////////////////////////////////////////////////////////////////////////
+int RTUSBSendPackets(struct sk_buff *skb, struct net_device *net_dev)
+{
+
+	NDIS_STATUS 	Status = NDIS_STATUS_SUCCESS;
+	PRT2570ADAPTER	pAdapter = net_dev->priv;
+	
+	skb->data_len = skb->len;
+	if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS) ||
+		RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS) ||
+		RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RADIO_OFF) ||
+		RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+	{
+		RTUSBFreeSkbBuffer(skb);
+		return 0;
+	}
+	// Drop packets if no associations
+	else if (!INFRA_ON(pAdapter) && !ADHOC_ON(pAdapter) && 
+		   !( pAdapter->PortCfg.BssType == BSS_MONITOR && pAdapter->PortCfg.MallowRFMONTx == TRUE )
+		 )
+	{
+		RTUSBFreeSkbBuffer(skb);
+		return 0;
+	}
+	else
+	{
+		Status = RTUSBSendPacket(pAdapter, skb);
+	        if (Status != NDIS_STATUS_SUCCESS)
+	        {
+			// Errors before enqueue stage
+			RTUSBFreeSkbBuffer(skb);
+			DBGPRINT(RT_DEBUG_TRACE,"<---RTUSBSendPackets not dequeue\n");
+			return 0;
+	        }
+	}
+	// Dequeue one frame from SendTxWait queue and process it
+	// There are two place calling dequeue for TX ring.
+	// 1. Here, right after queueing the frame.
+	// 2. At the end of TxRingTxDone service routine.
+	if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) && 
+		(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RADIO_OFF)) &&
+		(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)))
+	{
+	    //RTMPDeQueuePacket(pAdapter, &pAdapter->TxSwQueue0);
+	    // Call dequeue without selected queue, let the subroutine select the right priority
+	    // Tx software queue
+	    RTUSBDeQueuePacket(pAdapter);
+	}
+
+	// Kick bulk out
+	RTUSBKickBulkOut(pAdapter);
+	return 0;
+}
+
+NDIS_STATUS	RTUSBSendPacket(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN  struct sk_buff  *skb)
+{
+
+
+	PVOID			pVirtualAddress;
+	struct sk_buff_head     *pTxQueue;
+	ULONG					Priority;
+	UCHAR			NumberOfFrag;
+	UCHAR			RTSRequired;
+	UINT			AllowFragSize;
+	UCHAR                   AccessCategory;
+	NDIS_STATUS		Status = NDIS_STATUS_FAILURE;
+	UCHAR			PsMode;
+
+	// Init priority value
+	Priority = 0;
+	AccessCategory = 0;
+
+	if (skb && pAdapter->PortCfg.BssType == BSS_MONITOR &&
+		   pAdapter->PortCfg.MallowRFMONTx == TRUE)
+	{
+		NdisAcquireSpinLock(&pAdapter->SendTxWaitQueueLock);
+		skb_queue_tail(&pAdapter->SendTxWaitQueue, skb);
+		NdisReleaseSpinLock(&pAdapter->SendTxWaitQueueLock);
+		return (NDIS_STATUS_SUCCESS);
+	}
+	
+	if (skb)
+	{
+		Priority = skb->priority;
+		// 802.11e/d4.4 June, 2003
+		if (Priority <=2)
+		    AccessCategory = 0;
+		else if (Priority == 3)
+		    AccessCategory = 1;
+		else if (Priority <= 5)
+		    AccessCategory = 2;
+		else
+		    AccessCategory = 3;
+		DBGPRINT(RT_DEBUG_INFO, "Priority = %d, AC = %d\n", Priority, AccessCategory);
+	}
+	// For TKIP, MIC value is treated as payload, it might be fragmented through
+	// different MPDUs.
+	if (pAdapter->PortCfg.WepStatus == Ndis802_11Encryption2Enabled)
+	{
+		skb->data_len += 8;
+	}
+
+	pVirtualAddress = (PVOID)skb->data;
+	// Check for virtual address allocation, it might fail !!!
+	if (pVirtualAddress == NULL)
+	{
+		DBGPRINT(RT_DEBUG_TRACE,"<---RTUSBSendPacket NULL pVirtualAddress\n");
+		// Resourece is low, system did not allocation virtual address
+		// return NDIS_STATUS_FAILURE directly to upper layer
+		return (Status);
+	}
+
+	//
+	// Check for multicast or broadcast (First byte of DA)
+	//
+	if ((*((PUCHAR) pVirtualAddress) & 0x01) != 0)
+	{
+		// For multicast & broadcast, there is no fragment allowed
+		NumberOfFrag = 1;
+	}
+	else
+	{
+		// Check for payload allowed for each fragment
+		AllowFragSize = (pAdapter->PortCfg.FragmentThreshold) - LENGTH_802_11 - LENGTH_CRC;
+
+		// Calculate fragments required
+		NumberOfFrag = ((skb->data_len - LENGTH_802_3 + LENGTH_802_1_H) / AllowFragSize) + 1;
+		// Minus 1 if the size just match to allowable fragment size
+		if (((skb->data_len - LENGTH_802_3 + LENGTH_802_1_H) % AllowFragSize) == 0)
+		{
+			NumberOfFrag--;
+		}
+	}
+	
+	// Check for requirement of RTS 
+	if (NumberOfFrag > 1)
+	{
+		// If multiple fragment required, RTS is required only for the first fragment
+		// if the fragment size large than RTS threshold
+		RTSRequired = (pAdapter->PortCfg.FragmentThreshold > pAdapter->PortCfg.RtsThreshold) ? 1 : 0;
+	}
+	else
+	{
+		RTSRequired = (skb->data_len > pAdapter->PortCfg.RtsThreshold) ? 1 : 0;
+	}
+
+	// RTS/CTS may also be required in order to protect OFDM frame
+	if ((pAdapter->PortCfg.TxRate >= RATE_FIRST_OFDM_RATE) && pAdapter->PortCfg.BGProtectionInUsed)
+		RTSRequired = 1;
+	//DBGPRINT(RT_DEBUG_TEMP, "Number of fragments :%d , include RTS :%d\n", NumberOfFrag, NumberOfFrag + RTSRequired);
+        
+	// Save framnet number to Ndis packet reserved field
+	RTMP_SET_PACKET_FRAGMENTS(skb, NumberOfFrag);	     
+
+	// Save RTS requirement to Ndis packet reserved field
+	RTMP_SET_PACKET_RTS(skb, RTSRequired);
+
+	// Make sure SendTxWait queue resource won't be used by other threads
+	NdisAcquireSpinLock(&pAdapter->SendTxWaitQueueLock);
+
+	pTxQueue = &pAdapter->SendTxWaitQueue;
+	if (INFRA_ON(pAdapter))
+	{
+		// In infrastructure mode, simply enqueue the packet into Tx waiting queue.
+		DBGPRINT(RT_DEBUG_INFO, "Infrastructure -> Enqueue one frame\n");
+
+		// Enqueue Ndis packet to end of Tx wait queue
+		skb_queue_tail(pTxQueue, skb);
+		Status = NDIS_STATUS_SUCCESS;
+	}
+	else
+	{
+		// In IBSS mode, power state of destination should be considered.
+		PsMode = PWR_ACTIVE;		// Faked
+		if (PsMode == PWR_ACTIVE)
+		{
+			// Enqueue Ndis packet to end of Tx wait queue
+			skb_queue_tail(pTxQueue, skb);
+			Status = NDIS_STATUS_SUCCESS;
+		}
+	}
+	
+	NdisReleaseSpinLock(&pAdapter->SendTxWaitQueueLock);
+	return Status;
+}
+
+VOID	RTUSBDeQueuePacket(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+
+	UCHAR			FragmentRequired;
+	NDIS_STATUS		Status = NDIS_STATUS_SUCCESS;
+	struct sk_buff  	*skb;
+	struct sk_buff_head     *pQueue;
+	UCHAR			Count = 0;
+	// Make sure SendTxWait queue resource won't be used by other threads
+	NdisAcquireSpinLock(&pAdapter->SendTxWaitQueueLock);
+
+	// Select Queue
+	pQueue = &pAdapter->SendTxWaitQueue;
+
+	// Check queue before dequeue
+	while (!skb_queue_empty(pQueue) && (Count < MAX_TX_PROCESS))
+	{
+		// Reset is in progress, stop immediately
+		if ( RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS) ||
+			 RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS) ||
+		     RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+		{
+			break;
+		}
+			
+		// Dequeue the first entry from head of queue list
+		skb = skb_dequeue(pQueue);
+
+
+		// RTS or CTS-to-self for B/G protection mode has been set already.
+		// There is no need to re-do it here. 
+		// Total fragment required = number of fragment + RST if required
+		FragmentRequired = RTMP_GET_PACKET_FRAGMENTS(skb) + RTMP_GET_PACKET_RTS(skb);
+		
+		if (RTUSBFreeDescriptorRequest(pAdapter, TX_RING, FragmentRequired) == NDIS_STATUS_SUCCESS)
+		{
+			// Avaliable ring descriptors are enough for this frame
+			// Call hard transmit
+			// Nitro mode / Normal mode selection
+			NdisReleaseSpinLock(&pAdapter->SendTxWaitQueueLock);
+			if (pAdapter->PortCfg.EnableTxBurst == 1)
+				Status = RTUSBHardEncrypt(pAdapter, skb, FragmentRequired, TRUE);
+			else				
+				Status = RTUSBHardEncrypt(pAdapter, skb, FragmentRequired, FALSE);
+			//
+			// Acquire the resource again, snice we may need to process it in this while-loop.
+			//
+			NdisAcquireSpinLock(&pAdapter->SendTxWaitQueueLock);
+			if (Status == NDIS_STATUS_FAILURE)
+			{
+				// Packet failed due to various Ndis Packet error
+				RTUSBFreeSkbBuffer(skb);
+				break;
+			}
+			else if (Status == NDIS_STATUS_RESOURCES)
+			{
+				// Not enough free tx ring, it might happen due to free descriptor inquery might be not correct
+				// It also might change to NDIS_STATUS_FAILURE to simply drop the frame
+				// Put the frame back into head of queue
+				skb_queue_head(pQueue, skb);
+				break;
+			}			
+			Count++;
+		}	
+		else
+		{
+			skb_queue_head(pQueue, skb);
+			break;
+		}
+	}
+	
+	NdisReleaseSpinLock(&pAdapter->SendTxWaitQueueLock);
+	return;
+	
+}
+
+NDIS_STATUS	RTUSBFreeDescriptorRequest(
+	IN		PRT2570ADAPTER	pAdapter,
+	IN		UCHAR			RingType,
+	IN		UCHAR			NumberRequired)
+{
+	UCHAR			FreeNumber = 0;
+	UINT			Index;
+	NDIS_STATUS		Status = NDIS_STATUS_FAILURE;
+
+	switch (RingType)
+	{
+		case TX_RING:
+			Index = pAdapter->NextTxIndex;
+			do
+			{
+				PTX_CONTEXT	pTxD  = &pAdapter->TxContext[Index];
+				
+				// While Owner bit is NIC, obviously ASIC still need it.
+				// If valid bit is TRUE, indicate that TxDone has not process yet
+				// We should not use it until TxDone finish cleanup job
+				if (pTxD->InUse == FALSE)
+				{
+					// This one is free
+					FreeNumber++;
+				}
+				else
+				{
+					break;
+				}					
+				Index = (Index + 1) % TX_RING_SIZE;				
+			}	while (FreeNumber < NumberRequired);	// Quit here ! Free number is enough !
+			
+			if (FreeNumber >= NumberRequired)
+			{
+				Status = NDIS_STATUS_SUCCESS;
+			}
+			
+			break;
+			
+		case PRIO_RING:
+			Index = pAdapter->NextMLMEIndex;
+			do
+			{
+				PTX_CONTEXT	pTxD  = &pAdapter->MLMEContext[Index];
+				
+				// While Owner bit is NIC, obviously ASIC still need it.
+				// If valid bit is TRUE, indicate that TxDone has not process yet
+				// We should not use it until TxDone finish cleanup job
+				if (pTxD->InUse == FALSE)
+				{
+					// This one is free
+					FreeNumber++;
+				}
+				else
+				{
+					break;
+				}
+					
+				Index = (Index + 1) % PRIO_RING_SIZE;				
+			}	while (FreeNumber < NumberRequired);	// Quit here ! Free number is enough !
+			
+			if (FreeNumber >= NumberRequired)
+			{
+				Status = NDIS_STATUS_SUCCESS;
+			}
+			break;
+
+		default:
+			break;
+
+
+	
+	}
+
+	return (Status);
+
+}
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBRejectPendingPackets(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "--->RejectPendingPackets\n");
+
+	NdisAcquireSpinLock(&pAdapter->SendTxWaitQueueLock);
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "Purge SendTxWaitQueue\n");
+	skb_queue_purge(&pAdapter->SendTxWaitQueue);
+	NdisReleaseSpinLock(&pAdapter->SendTxWaitQueueLock);
+
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "<---RejectPendingPackets\n");
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Suspend MSDU transmission
+		
+	Arguments:
+		pAdapter		Pointer	to our adapter
+		
+	Return Value:
+		None
+		
+	Note:
+	
+	========================================================================
+*/
+VOID    RTUSBSuspendMsduTransmission(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	DBGPRINT(RT_DEBUG_TRACE,"SCANNING, suspend MSDU transmission ...\n");
+	RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Resume MSDU transmission
+		
+	Arguments:
+		pAdapter		Pointer	to our adapter
+		
+	Return Value:
+		None
+		
+	Note:
+	
+	========================================================================
+*/
+VOID    RTUSBResumeMsduTransmission(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	DBGPRINT(RT_DEBUG_TRACE,"SCANNING, resume MSDU transmission ...\n");
+	RTMP_CLEAR_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
+	if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RADIO_OFF)))
+	{
+		// Call dequeue without selected queue, let the subroutine select the right priority
+		// Tx software queue
+		RTUSBDeQueuePacket(pAdapter);
+	}
+
+	// Kick bulk out
+	RTUSBKickBulkOut(pAdapter);
+
+}
+/*
+	========================================================================
+
+	Routine	Description:
+		
+	Arguments:
+		
+	Return Value:
+		
+	Note:
+	
+	========================================================================
+*/
+USHORT	RTUSBCalcDuration(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	UCHAR			Rate,
+	IN	ULONG			Size)
+{
+	ULONG	Duration = 0;
+
+	if (Rate < RATE_FIRST_OFDM_RATE) // CCK
+	{
+	    if ((Rate > RATE_1) && (pAdapter->PortCfg.TxPreambleInUsed == Rt802_11PreambleShort))
+		Duration = 96;  // 72+24 preamble+plcp
+		else
+	    Duration = 192; // 144+48 preamble+plcp
+		
+		Duration += (USHORT)((Size << 4) / RateIdTo500Kbps[Rate]);
+		if ((Size << 4) % RateIdTo500Kbps[Rate])
+			Duration ++;
+	}
+	else // OFDM rates
+	{
+		Duration = 20 + 6;      // 16+4 preamble+plcp + Signal Extension
+		Duration += 4 * (USHORT)((11 + Size * 4) / RateIdTo500Kbps[Rate]);
+		if ((11 + Size * 4) % RateIdTo500Kbps[Rate])
+			Duration += 4;
+	}
+	
+	return (USHORT)Duration;	
+}
+
+/*
+	========================================================================
+	
+	Routine	Description:
+		Calculates the duration which is required to transmit out frames 
+	with given size and specified rate.
+		
+	Arguments:
+		pTxD		Pointer to transmit descriptor
+		Ack			Setting for Ack requirement bit
+		Fragment	Setting for Fragment bit
+		RetryMode	Setting for retry mode
+		Ifs			Setting for IFS gap
+		Rate		Setting for transmit rate
+		Service		Setting for service
+		Length		Frame length
+		
+	Return Value:
+		None
+		
+	========================================================================
+*/
+VOID	RTUSBWriteTxDescriptor(
+	IN	PTXD_STRUC	pTxD,
+	IN	BOOLEAN		Fragment,
+	IN	UCHAR		RetryLimit,
+	IN	BOOLEAN		Ack,
+	IN  BOOLEAN     InsTimestamp,
+	IN  BOOLEAN     new_seq,
+	IN	UCHAR		Ifs,
+	IN	UINT		Length,
+	IN	BOOLEAN		Cipher,
+	IN	UCHAR		KeyID,
+	IN	UCHAR		CWMin,
+	IN	UCHAR		CWMax,
+	IN	UINT		PLCPLength,
+	IN	UINT		Rate,
+	IN	UCHAR		Service,
+	IN  USHORT      TxPreamble)
+{
+	UINT	Residual;
+
+	pTxD->RetryLimit  = RetryLimit;
+	pTxD->MoreFrag    = Fragment;
+	pTxD->ACK         = Ack;
+	pTxD->Timestamp   = InsTimestamp;
+	pTxD->newseq      = new_seq;
+	pTxD->IFS         = Ifs;
+	pTxD->DataByteCnt = Length;
+	pTxD->Cipher	  = Cipher;
+	pTxD->KeyID		  = KeyID;
+	pTxD->CWmin       = CWMin;   // 2^5-1 = 31
+	pTxD->CWmax       = CWMax;  // 2^10 -1 = 1023
+	pTxD->Aifs        = 2;   // TC0: SIFS + 2*Slot + Random(CWmin,CWmax)*Slot
+		
+	if (Rate < RATE_FIRST_OFDM_RATE)
+		pTxD->Ofdm = 0;
+	else
+		pTxD->Ofdm = 1;
+
+	// fill up PLCP SIGNAL field
+	pTxD->PlcpSignal = PlcpSignal[Rate];
+	if (((Rate == RATE_2) || (Rate == RATE_5_5) || (Rate == RATE_11)) && (TxPreamble == Rt802_11PreambleShort)) // no short preamble for RATE_1
+	{
+		pTxD->PlcpSignal |= 0x0008;
+	}
+
+	// fill up PLCP SERVICE field, not used for OFDM rates
+	pTxD->PlcpService = Service;
+
+	// file up PLCP LENGTH_LOW and LENGTH_HIGH fields
+	if (Rate < RATE_FIRST_OFDM_RATE)    // 11b - RATE_1, RATE_2, RATE_5_5, RATE_11
+	{
+		if ((Rate == RATE_1) || ( Rate == RATE_2))
+		{
+			PLCPLength = PLCPLength * 8 / (Rate + 1);
+		}
+		else
+		{
+			Residual = ((PLCPLength * 16) % (11 * (1 + Rate - RATE_5_5)));
+			PLCPLength = PLCPLength * 16 / (11 * (1 + Rate - RATE_5_5));
+			if (Residual != 0)
+			{
+				PLCPLength++;
+			}
+			if (Rate == RATE_11)
+			{
+			if ((Residual <= (3 * (1 + Rate - RATE_5_5))) && (Residual != 0))
+			{
+				pTxD->PlcpService |= 0x80; // 11b's PLCP Length extension bit
+			}
+			}
+		}
+
+		pTxD->PlcpLengthHigh = PLCPLength / 256;
+		pTxD->PlcpLengthLow = PLCPLength % 256;
+	}
+	else    // OFDM - RATE_6, RATE_9, RATE_12, RATE_18, RATE_24, RATE_36, RATE_48, RATE_54
+	{
+		pTxD->PlcpLengthHigh = PLCPLength / 64;  // high 6-bit of total byte count
+		pTxD->PlcpLengthLow = PLCPLength % 64;   // low 6-bit of total byte count
+	}
+}
+
+/*
+	========================================================================
+	
+	Routine	Description:
+		Calculates the duration which is required to transmit out frames 
+	with given size and specified rate.
+		
+	Arguments:
+		pTxD		Pointer to transmit descriptor
+		Ack			Setting for Ack requirement bit
+		Fragment	Setting for Fragment bit
+		RetryMode	Setting for retry mode
+		Ifs			Setting for IFS gap
+		Rate		Setting for transmit rate
+		Service		Setting for service
+		Length		Frame length
+		
+	Return Value:
+		None
+		
+	========================================================================
+*/
+VOID	RTUSBWriteBeaconDescriptor(
+	IN	PTXD_STRUC	pTxD,
+	IN	UINT		Length,
+	IN	UINT		PLCPLength,
+	IN	UINT		Rate,
+	IN	UCHAR		Service,
+	IN  USHORT      TxPreamble)
+{
+	UINT	Residual;
+
+	pTxD->RetryLimit	= 0;
+	pTxD->MoreFrag    = 0;
+	pTxD->ACK         = 0;
+	pTxD->Timestamp   = 1;
+	pTxD->newseq      = 1;
+	pTxD->IFS         = IFS_NEW_BACKOFF;
+	pTxD->DataByteCnt = Length;
+	pTxD->Cipher	  = 0;
+	pTxD->KeyID		  = 0;
+	pTxD->CWmin       = BEACON_CW_IN_BITS;   // 2^5-1 = 31
+	pTxD->CWmax       = BEACON_CW_IN_BITS;  // 2^10 -1 = 1023
+	pTxD->Aifs        = 2;   // TC0: SIFS + 2*Slot + Random(CWmin,CWmax)*Slot
+		
+	if (Rate < RATE_FIRST_OFDM_RATE)
+		pTxD->Ofdm = 0;
+	else
+		pTxD->Ofdm = 1;
+
+	// fill up PLCP SIGNAL field
+	pTxD->PlcpSignal = PlcpSignal[Rate];
+	if (((Rate == RATE_2) || (Rate == RATE_5_5) || (Rate == RATE_11)) && (TxPreamble == Rt802_11PreambleShort)) // no short preamble for RATE_1
+	{
+		pTxD->PlcpSignal |= 0x0008;
+	}
+
+	// fill up PLCP SERVICE field, not used for OFDM rates
+	pTxD->PlcpService = Service;
+
+	// file up PLCP LENGTH_LOW and LENGTH_HIGH fields
+	if (Rate < RATE_FIRST_OFDM_RATE)    // 11b - RATE_1, RATE_2, RATE_5_5, RATE_11
+	{
+		if ((Rate == RATE_1) || ( Rate == RATE_2))
+		{
+			PLCPLength = PLCPLength * 8 / (Rate + 1);
+		}
+		else
+		{
+			Residual = ((PLCPLength * 16) % (11 * (1 + Rate - RATE_5_5)));
+			PLCPLength = PLCPLength * 16 / (11 * (1 + Rate - RATE_5_5));
+			if (Residual != 0)
+			{
+				PLCPLength++;
+			}
+			if ((Residual <= (3 * (1 + Rate - RATE_5_5))) && (Residual != 0))
+			{
+				pTxD->PlcpService |= 0x80; // 11b's PLCP Length extension bit
+			}
+		}
+
+		pTxD->PlcpLengthHigh = PLCPLength / 256;
+		pTxD->PlcpLengthLow = PLCPLength % 256;
+	}
+	else    // OFDM - RATE_6, RATE_9, RATE_12, RATE_18, RATE_24, RATE_36, RATE_48, RATE_54
+	{
+		pTxD->PlcpLengthHigh = PLCPLength / 64;  // high 6-bit of total byte count
+		pTxD->PlcpLengthLow = PLCPLength % 64;   // low 6-bit of total byte count
+	}
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Copy frame from waiting queue into relative ring buffer and set 
+	appropriate ASIC register to kick hardware encryption before really
+	sent out to air.
+		
+	Arguments:
+		pAdapter		Pointer	to our adapter
+		PNDIS_PACKET	Pointer to outgoing Ndis frame
+		NumberOfFrag	Number of fragment required
+		
+	Return Value:
+		None
+
+	IRQL = DISPATCH_LEVEL
+	
+	Note:
+	
+	========================================================================
+*/
+NDIS_STATUS	RTUSBHardEncrypt(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN  struct sk_buff  *skb,
+	IN	UCHAR			NumberRequired,
+	IN	ULONG			EnableTxBurst)
+{
+	PVOID			pVirtualAddress;
+	UINT			NdisBufferLength;
+	UINT			BytesCopied;
+	UINT			TxSize, PLCPLength;
+	UINT			FreeFragSize;
+	UINT			RemainSize;
+	USHORT			Protocol;
+	UCHAR			FrameGap;
+	HEADER_802_11	Header_802_11;
+	PUCHAR			pDest;
+	PUCHAR			pSrc;
+	PUCHAR			pEncap = NULL;
+	PTX_CONTEXT		pTxContext;
+	PTXD_STRUC		pTxD;
+	BOOLEAN			StartOfFrame;
+	BOOLEAN			EAPOLFrame;
+	BOOLEAN			Encapped;
+	ULONG			Iv16;
+	ULONG			Iv32;
+	BOOLEAN			MICFrag;
+	PWPA_KEY		pWpaKey = (PWPA_KEY) NULL;
+	BOOLEAN			Cipher;
+	UCHAR			KeyID = 0;
+	ULONG			TransferBufferLength;
+	BOOLEAN			MoreFragment;
+    UCHAR           AckRate = RATE_2;
+    USHORT          AckDuration = 0;
+    USHORT          EncryptionOverhead = 0;
+	BOOLEAN			Bcast_8023;
+	BOOLEAN			SingleFrag;
+//for re-calculating the number of Fragment required.
+	UINT			AllowFragSize;
+	UCHAR			NumberOfFrag;
+	UINT			TotalPacketLength; 
+	// To indicate cipher used for this packet
+	NDIS_802_11_ENCRYPTION_STATUS	CipherSuite;
+	
+	CipherSuite = pAdapter->PortCfg.WepStatus;
+	if (EnableTxBurst == 1)
+		FrameGap = IFS_SIFS;
+	else
+		FrameGap = IFS_BACKOFF;		// Default frame gap mode
+	// Sequence Number is identical for all fragments belonged to the same frame
+	// Sequence is 0 - 4095
+	pAdapter->Sequence = ((pAdapter->Sequence) + 1) & (MAX_SEQ_NUMBER);
+	AckRate = pAdapter->PortCfg.ExpectedACKRate[pAdapter->PortCfg.TxRate];
+	AckDuration = RTUSBCalcDuration(pAdapter, AckRate, 14);
+
+	pVirtualAddress = skb->data;
+	NdisBufferLength = skb->len;
+	if(pVirtualAddress == NULL)
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "Error, Null skb data buffer!!!\n");
+		return (NDIS_STATUS_FAILURE);
+	}
+
+	if (pAdapter->PortCfg.BssType == BSS_MONITOR && pAdapter->PortCfg.MallowRFMONTx == TRUE)
+	{
+		pTxContext  = &pAdapter->TxContext[pAdapter->NextTxIndex];
+		pTxContext->InUse   = TRUE;
+		pTxContext->LastOne = TRUE;
+		
+		pAdapter->NextTxIndex++;
+		if (pAdapter->NextTxIndex >= TX_RING_SIZE)
+			pAdapter->NextTxIndex = 0;
+
+		pTxD  = &(pTxContext->TransferBuffer->TxDesc);
+		memset(pTxD, 0, sizeof(TXD_STRUC));
+		pDest = pTxContext->TransferBuffer->WirelessPacket;
+
+		memcpy( pDest, skb->data, skb->len );
+
+		RTUSBWriteTxDescriptor(pTxD, FALSE, 0, FALSE, FALSE, TRUE, IFS_BACKOFF, skb->len, FALSE, 0, CW_MIN_IN_BITS, CW_MAX_IN_BITS, skb->len + 4, pAdapter->PortCfg.TxRate, 4, pAdapter->PortCfg.TxPreambleInUsed);
+
+		TransferBufferLength = skb->len + sizeof(TXD_STRUC);
+		if ((TransferBufferLength % 2) == 1)
+			TransferBufferLength++;
+
+		pTxContext->BulkOutSize = TransferBufferLength;
+		atomic_inc(&pAdapter->TxCount);
+		RTUSB_SET_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_DATA_FRAG);
+		RTUSBFreeSkbBuffer(skb);
+		return (NDIS_STATUS_SUCCESS);
+	}
+
+	if (NdisBufferLength < 14)
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "RTUSBHardEncrypt --> Ndis Packet buffer error !!!\n");
+		return (NDIS_STATUS_FAILURE);
+	}
+	if ((*((PUCHAR) pVirtualAddress) & 0x01) != 0)	// Multicast or Broadcast
+	{
+		INC_COUNTER(pAdapter->WlanCounters.MulticastTransmittedFrameCount);
+		Bcast_8023 = TRUE;
+	}
+	else
+	{
+		Bcast_8023 = FALSE;
+	}
+
+	// New control flag for sending DHCP & BOOTP usinf 1MB rate
+	if ((NumberRequired - RTUSB_GET_PACKET_RTS(skb)) == 1)
+	{
+		SingleFrag = TRUE;
+	}
+	else
+	{
+		SingleFrag = FALSE;
+	}
+
+	// Add 802.11x protocol check.
+	// For non-WPA network, 802.11x message should not encrypt even
+	// the privacy is on.
+	if ((memcmp(EAPOL, ((PUCHAR) pVirtualAddress) + 12, 2) == 0))
+	{
+		EAPOLFrame = TRUE;
+		if (pAdapter->PortCfg.MicErrCnt >= 2)//steven:???
+			pAdapter->PortCfg.MicErrCnt++;
+	}
+	else
+	{
+		EAPOLFrame = FALSE;
+	}	// Initialize 802.11 header for each frame
+
+	// WPA 802.1x secured port control
+	if (((pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA) || 
+		 (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK)) &&
+		((pAdapter->PortCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED) || 
+		 (pAdapter->PortCfg.MicErrCnt >= 2)) &&
+		(EAPOLFrame == FALSE))
+	{
+		DBGPRINT_RAW(RT_DEBUG_INFO, "RTUSBHardEncrypt --> Drop packet before port secured !!!\n");
+		return (NDIS_STATUS_FAILURE);
+	}		
+	
+	memset(&Header_802_11, 0, sizeof(HEADER_802_11));
+	//
+	// Start making 802.11 frame header
+	//
+	if (INFRA_ON(pAdapter))
+	{
+		// In BSS mode, AP's address(BSSID) is the destination address of all outgoing packets
+		// Address 1 - BSSID
+		memcpy(&Header_802_11.Controlhead.Addr1, &pAdapter->PortCfg.Bssid, ETH_LENGTH_OF_ADDRESS);
+		// Address 3 - DA
+		memcpy(&Header_802_11.Addr3, (PUCHAR) pVirtualAddress, ETH_LENGTH_OF_ADDRESS);
+		Header_802_11.Controlhead.Frame.ToDs = 1;
+	}
+	else 
+	{
+		// Address 1 - DA
+		memcpy(&Header_802_11.Controlhead.Addr1, (PUCHAR) pVirtualAddress, ETH_LENGTH_OF_ADDRESS);
+		// Address 3 - BSSID
+		memcpy(&Header_802_11.Addr3, &pAdapter->PortCfg.Bssid, ETH_LENGTH_OF_ADDRESS);
+	}
+	// Address 2 - SA in both infrastructure & ad-hoc modes
+	memcpy(&Header_802_11.Controlhead.Addr2, pAdapter->CurrentAddress, ETH_LENGTH_OF_ADDRESS);
+	
+//	Header_802_11.Sequence = pAdapter->Sequence;		// Sequence number
+	Header_802_11.Controlhead.Frame.Type = BTYPE_DATA;	// Frame type
+	Header_802_11.Controlhead.Frame.PwrMgt = (pAdapter->PortCfg.Psm == PWR_SAVE);
+	
+	// For the purpose to calculate duration for the second last fragment
+	RemainSize = skb->data_len - LENGTH_802_3 + LENGTH_CRC;
+
+	MICFrag = FALSE;	// Flag to indicate MIC shall spread into two MPDUs
+	Encapped = FALSE;
+	pEncap = NULL;
+	pSrc = (PUCHAR)pVirtualAddress;
+	Protocol = *(pSrc + 12) * 256 + *(pSrc + 13);
+
+	if (Protocol > 1500)	// CHeck for LLC encaped
+	{
+		//
+		// Large than 1500 means it's a type field, and thus a D/I/X packet.
+		//
+		pEncap = SNAP_802_1H;
+		Encapped = TRUE;
+		if ((memcmp(IPX, pSrc + 12, 2) == 0) || 
+		    (memcmp(APPLE_TALK, pSrc + 12, 2) == 0))
+		{
+			pEncap = SNAP_BRIDGE_TUNNEL;
+		}
+	}
+	else
+	{
+		//
+		//means it's a length field, thus an 802.3 packet
+		//And we need to re-calculate the number of Fragment required.
+		TotalPacketLength = skb->data_len;
+		//
+		//means it's a length field, thus an 802.3 packet
+		//And we need to re-calculate the number of Fragment required.
+		//
+		// For TKIP, MIC value is treated as payload, it might be fragmented through
+		// different MPDUs.
+		if (pAdapter->PortCfg.GroupCipher == Ndis802_11Encryption2Enabled)
+		{
+			TotalPacketLength = skb->data_len + 8;
+		}
+		
+		// Check for payload allowed for each fragment
+		AllowFragSize = (pAdapter->PortCfg.FragmentThreshold) - LENGTH_802_11 - LENGTH_CRC;
+
+		// Calculate fragments required
+		NumberOfFrag = ((TotalPacketLength - LENGTH_802_3) / AllowFragSize) + 1;
+		// Minus 1 if the size just match to allowable fragment size
+		if (((skb->data_len - LENGTH_802_3) % AllowFragSize) == 0)
+		{
+			NumberOfFrag--;
+		}
+
+		
+		if (NumberOfFrag != RTUSB_GET_PACKET_FRAGMENTS(skb))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "Original fragment required = %d, new fragment required = %d\n",
+						RTUSB_GET_PACKET_FRAGMENTS(skb), NumberOfFrag);	
+			//
+			// Update number of Fragment
+			//
+			RTUSB_SET_PACKET_FRAGMENTS(skb, NumberOfFrag);
+			NumberRequired = RTUSB_GET_PACKET_FRAGMENTS(skb) + RTUSB_GET_PACKET_RTS(skb);	
+		}		
+	}
+
+	//
+    // calcuate the overhead bytes that encryption algorithm may add. This
+    // affects the calculate of "duration" field
+    //
+	if ((CipherSuite == Ndis802_11Encryption1Enabled) && 
+		(pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen != 0))
+		EncryptionOverhead = 8;     // WEP: IV + ICV			
+	else if (CipherSuite == Ndis802_11Encryption2Enabled)
+		EncryptionOverhead = 12;    // TKIP: IV + EIV + ICV, MIC already added to TotalPacketLength
+	else if (CipherSuite == Ndis802_11Encryption3Enabled)
+		EncryptionOverhead = 16;    // AES: IV + EIV + Hardware MIC
+	else
+	    EncryptionOverhead = 0;
+
+	//
+	// Make RTS frame if required
+	//
+	if (RTUSB_GET_PACKET_RTS(skb))
+	{
+		PCONTROL_HEADER		pControlHeader;
+		ULONG				NextFragSize;
+		//UINT				RTSFrameSize; //used only to calculate duration
+		
+		DBGPRINT_RAW(RT_DEBUG_INFO, "Making RTS Frame\n");
+
+		pTxContext  = &pAdapter->TxContext[pAdapter->NextTxIndex];
+		pTxContext->InUse   = TRUE;
+		pTxContext->LastOne = FALSE;
+		
+		// Increase & maintain Tx Ring Index
+		pAdapter->NextTxIndex++;
+		if (pAdapter->NextTxIndex >= TX_RING_SIZE)
+		{
+			pAdapter->NextTxIndex = 0;
+		}
+
+		pTxD  = &(pTxContext->TransferBuffer->TxDesc);
+		memset(pTxD, 0, sizeof(TXD_STRUC));
+		pDest = pTxContext->TransferBuffer->WirelessPacket;              
+				
+		pControlHeader = (PCONTROL_HEADER)pDest;
+		memset(pControlHeader, 0, sizeof(CONTROL_HEADER));
+
+		//FrameControl
+		pControlHeader->Frame.Type    = BTYPE_CNTL;
+		if (pAdapter->PortCfg.BGProtectionInUsed == 1)
+		{
+			pControlHeader->Frame.Subtype = SUBTYPE_CTS;
+			memcpy(&pControlHeader->Addr1, pAdapter->CurrentAddress, ETH_LENGTH_OF_ADDRESS);
+		}
+		else
+		{
+			pControlHeader->Frame.Subtype = SUBTYPE_RTS;
+			// RA
+			if (INFRA_ON(pAdapter))
+			{
+				memcpy(&pControlHeader->Addr1, &pAdapter->PortCfg.Bssid, ETH_LENGTH_OF_ADDRESS);
+			}
+			else
+			{
+				memcpy(&pControlHeader->Addr1, (PUCHAR) pVirtualAddress, ETH_LENGTH_OF_ADDRESS);
+			}
+			// TA
+			memcpy(&pControlHeader->Addr2, pAdapter->CurrentAddress, ETH_LENGTH_OF_ADDRESS);
+		}
+
+		// Calculate duration = 2 SIFS + CTS + Data Frame size
+		if (RTUSB_GET_PACKET_FRAGMENTS(skb) > 1)
+		{
+			// If fragment required, size is maximum fragment size
+			NextFragSize = pAdapter->PortCfg.FragmentThreshold;
+		}
+		else
+		{
+			// Size should be frame with 802.11 header & CRC
+			NextFragSize = skb->data_len + LENGTH_802_11 + LENGTH_CRC - LENGTH_802_3;
+
+			if (Encapped)
+				NextFragSize += LENGTH_802_1_H;
+		}
+		pControlHeader->Duration = 2 * (pAdapter->PortCfg.Dsifs)
+			+ RTUSBCalcDuration(pAdapter, pAdapter->PortCfg.TxRate, NextFragSize + EncryptionOverhead)
+			+ AckDuration; 
+
+		// Write Tx descriptor
+		// Don't kick tx start until all frames are prepared
+		// RTS has to set more fragment bit for fragment burst
+		// RTS did not encrypt		
+		if (pAdapter->PortCfg.BGProtectionInUsed == 1)
+		{
+			RTUSBWriteTxDescriptor(pTxD, FALSE, 7, FALSE, FALSE, FALSE, FrameGap, 10, FALSE, 0, CW_MIN_IN_BITS, CW_MAX_IN_BITS, 14, pAdapter->PortCfg.RtsRate, 4, pAdapter->PortCfg.TxPreambleInUsed);
+		}
+		else
+		{
+			RTUSBWriteTxDescriptor(pTxD, FALSE, 7, TRUE, FALSE, FALSE, FrameGap, sizeof(CONTROL_HEADER), FALSE, 0, CW_MIN_IN_BITS, CW_MAX_IN_BITS, sizeof(CONTROL_HEADER) + 4, pAdapter->PortCfg.RtsRate, 4, pAdapter->PortCfg.TxPreambleInUsed);
+//steven:should we need this?			pTxD->RTS = 1;
+		}
+
+		TransferBufferLength = sizeof(CONTROL_HEADER) + sizeof(TXD_STRUC);
+		if ((TransferBufferLength % 2) == 1)
+			TransferBufferLength++;
+
+		pTxContext->BulkOutSize = TransferBufferLength;
+
+		NumberRequired--;
+		//
+		// Increase BulkOut stanby count.
+		//
+		atomic_inc(&pAdapter->TxCount);
+
+		RTUSB_SET_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_DATA_NORMAL);
+	}
+	// Find the WPA key, either Group or Pairwise Key//steven:according to Controlhead.Addr1 (only when AuthMode >= Ndis802_11AuthModeWPA)
+	if (pAdapter->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+	{
+		INT 	idx;
+			
+		pWpaKey = (PWPA_KEY) NULL;
+		// First lokup the DA, if it's a group address, use GROUP key
+		if (Header_802_11.Controlhead.Addr1.Octet[0] & 0x01)
+		{
+			if (pAdapter->PortCfg.GroupKey[pAdapter->PortCfg.DefaultKeyId].KeyLen != 0)
+			{
+				pWpaKey = (PWPA_KEY) &pAdapter->PortCfg.GroupKey[pAdapter->PortCfg.DefaultKeyId];
+				pWpaKey->Type = GROUP_KEY;
+				KeyID = pAdapter->PortCfg.DefaultKeyId;//for Tx descriptor
+				DBGPRINT(RT_DEBUG_INFO, "Tx Use Group Key\n");
+			}
+		}
+		// Try to find the Pairwise Key
+		else
+		{
+			for (idx = 0; idx < PAIRWISE_KEY_NO; idx++)
+			{
+				if (((memcmp(&Header_802_11.Controlhead.Addr1, pAdapter->PortCfg.PairwiseKey[idx].BssId, 6)== 0)) &&
+					(pAdapter->PortCfg.PairwiseKey[idx].KeyLen != 0))
+				{
+					pWpaKey = (PWPA_KEY) &pAdapter->PortCfg.PairwiseKey[idx];
+					pWpaKey->Type = PAIRWISE_KEY;
+					KeyID = (UCHAR)idx;
+					DBGPRINT(RT_DEBUG_INFO, "Tx Use Pairwise Key\n");
+					break;
+				}
+			}
+			// Use default Group Key if there is no Pairwise key present
+			if ((pAdapter->PortCfg.GroupKey[pAdapter->PortCfg.DefaultKeyId].KeyLen != 0) && (pWpaKey == NULL))
+			{
+				pWpaKey = (PWPA_KEY) &pAdapter->PortCfg.GroupKey[pAdapter->PortCfg.DefaultKeyId];
+				pWpaKey->Type = GROUP_KEY;
+				KeyID = pAdapter->PortCfg.DefaultKeyId;//for Tx descriptor
+				DBGPRINT(RT_DEBUG_INFO, "Tx Use Group Key\n");
+			}
+		}
+	}
+
+		if (pWpaKey != NULL)
+		{
+			INT i;
+				
+			DBGPRINT(RT_DEBUG_INFO, "RTMPHardEncrypt TKIP Key = ");
+			for (i = 0; i < 16; i++)
+			{
+				DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", pWpaKey->Key[i]);
+			}
+			DBGPRINT_RAW(RT_DEBUG_INFO, "\n");						
+			DBGPRINT(RT_DEBUG_INFO, "RTMPHardEncrypt TKIP TxMic = ");
+			for (i = 0; i < 8; i++)
+			{
+				DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", pWpaKey->TxMic[i]);
+			}
+			DBGPRINT_RAW(RT_DEBUG_INFO, "\n");						
+			DBGPRINT(RT_DEBUG_INFO, "RTMPHardEncrypt TKIP TxTsc = ");
+			for (i = 0; i < 6; i++)
+			{
+				DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", pWpaKey->TxTsc[i]);
+			}
+			DBGPRINT_RAW(RT_DEBUG_INFO, "\n");						
+		}
+
+	StartOfFrame = TRUE;
+	// Start Copy Ndis Packet into Ring buffer.
+	// For frame required more than one ring buffer (fragment), all ring buffers
+	// have to be filled before kicking start tx bit.
+	do
+	{
+//		NdisAcquireSpinLock(&pAdapter->TxRingLock);
+		// Get the Tx Ring descriptor & Dma Buffer address
+		pTxContext  = &pAdapter->TxContext[pAdapter->NextTxIndex];
+		pTxContext->InUse   = TRUE;
+		pTxContext->LastOne = FALSE;
+		
+		// Increase & maintain Tx Ring Index
+		pAdapter->NextTxIndex++;
+		if (pAdapter->NextTxIndex >= TX_RING_SIZE)
+		{
+			pAdapter->NextTxIndex = 0;
+		}
+//		NdisReleaseSpinLock(&pAdapter->TxRingLock);
+
+		pTxD  = &(pTxContext->TransferBuffer->TxDesc);
+		memset(pTxD, 0, sizeof(TXD_STRUC));
+		pDest = pTxContext->TransferBuffer->WirelessPacket;              
+		// Maximum allowable payload with one ring buffer, bound by fragment size
+		FreeFragSize = pAdapter->PortCfg.FragmentThreshold - LENGTH_CRC;
+		
+		// Make fragment number & more fragment bit of 802.11 header
+		if (StartOfFrame == TRUE)
+		{
+			Header_802_11.Frag = 0;			// Start of fragment burst / Single Frame
+		}
+		else
+		{
+			Header_802_11.Frag++;			// Rest of fragmented frames.
+		}
+		
+		// Turn on with no frames after this one
+		if (NumberRequired > 1)
+		{
+		    ULONG NextFragSize;
+//		    ULONG FragSize;
+		    
+			Header_802_11.Controlhead.Frame.MoreFrag = 1;
+			MoreFragment = TRUE;
+			
+			if (NumberRequired == 2)
+			NextFragSize = RemainSize - pAdapter->PortCfg.FragmentThreshold + LENGTH_802_11 + LENGTH_802_11 + LENGTH_CRC;
+			else
+			    NextFragSize = pAdapter->PortCfg.FragmentThreshold;
+			
+			Header_802_11.Controlhead.Duration = 3 * pAdapter->PortCfg.Dsifs
+				+ 2 * AckDuration
+				+ RTUSBCalcDuration(pAdapter, pAdapter->PortCfg.TxRate, NextFragSize + EncryptionOverhead);
+		}
+		else
+		{
+			Header_802_11.Controlhead.Frame.MoreFrag = 0;
+			MoreFragment = FALSE;
+			
+			if (Header_802_11.Controlhead.Addr1.Octet[0] & 0x01)
+			{
+				// No ACK expected for multicast frame		
+				Header_802_11.Controlhead.Duration = 0;
+			}
+			else
+			{
+				// ACK size is 14 include CRC, and its rate is 2Mb
+				Header_802_11.Controlhead.Duration = pAdapter->PortCfg.Dsifs + AckDuration;
+			}
+		}
+
+		// Check for WEP enable bit and prepare for software WEP
+		if ((CipherSuite == Ndis802_11Encryption1Enabled) && (EAPOLFrame == FALSE) &&
+			(pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen != 0))
+		{
+			Header_802_11.Controlhead.Frame.Wep = 1;
+			Cipher = TRUE;
+		}
+		else if ((CipherSuite == Ndis802_11Encryption2Enabled) && (pWpaKey != NULL))
+		{
+			Header_802_11.Controlhead.Frame.Wep = 1;
+			Cipher = TRUE;
+		}
+		else if ((CipherSuite == Ndis802_11Encryption3Enabled) && (pWpaKey != NULL))
+		{
+			Header_802_11.Controlhead.Frame.Wep = 1;
+			Cipher = TRUE;
+		}
+		else
+		{
+			Header_802_11.Controlhead.Frame.Wep = 0;
+			Cipher = FALSE;
+		}
+		
+		// Copy 802.11 header to Tx ring buffer
+		memcpy(pDest, &Header_802_11, sizeof(Header_802_11));
+		pDest        += sizeof(Header_802_11);
+		FreeFragSize -= sizeof(Header_802_11);
+
+		if ((CipherSuite == Ndis802_11Encryption1Enabled) && (EAPOLFrame == FALSE) &&
+			(pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen != 0))
+		{
+			// Prepare IV, IV offset, Key for Hardware encryption
+			RTMPInitWepEngine(
+				pAdapter,
+				pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].Key,
+				pAdapter->PortCfg.DefaultKeyId,
+				pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen,
+				(PUCHAR) &pTxD->Iv);
+			KeyID = pAdapter->PortCfg.DefaultKeyId;
+			// Set Iv offset in TxD
+			pTxD->IvOffset = LENGTH_802_11;
+
+			memcpy(pDest, &pTxD->Iv, 4);
+			pDest += 4;
+		}
+		else if ((CipherSuite == Ndis802_11Encryption2Enabled) && (pWpaKey != NULL))
+		{
+			INT		i;
+
+			i = 0;
+			// Prepare IV, EIV, IV offset, Key for hardware encryption
+			RTMPInitTkipEngine(
+				pAdapter,
+				pWpaKey->Key,
+				pAdapter->PortCfg.DefaultKeyId,		// This might cause problem when using peer key
+				Header_802_11.Controlhead.Addr2.Octet,
+				pWpaKey->TxMic,
+				pWpaKey->TxTsc,
+				0,
+				&Iv16,
+				&Iv32,
+				pDest);
+
+			// Increase TxTsc value for next transmission
+			while (++pWpaKey->TxTsc[i] == 0x0)
+			{
+				i++;
+				if (i == 6)
+					break;
+			}
+			if (i == 6)
+			{
+				// TODO: TSC has done one full cycle, do re-keying stuff follow specs
+				// Should send a special event microsoft defined to request re-key
+			}
+			
+			// Copy IV
+			memcpy(&pTxD->Iv, &Iv16, 4);
+			
+			// Copy EIV
+			memcpy(&pTxD->Eiv, &Iv32, 4);
+			
+			// Set IV offset
+			pTxD->IvOffset = LENGTH_802_11;
+
+			memcpy(pDest, &Iv16, 4);
+			pDest += 4;
+			memcpy(pDest, &Iv32, 4);
+			pDest += 4;
+			
+		}
+		else if ((CipherSuite == Ndis802_11Encryption3Enabled) && (pWpaKey != NULL))
+		{
+			INT		i;
+			PUCHAR	pTmp;
+
+			i = 0;
+			pTmp = (PUCHAR) &Iv16;
+			*pTmp       = pWpaKey->TxTsc[0];
+			*(pTmp + 1) = pWpaKey->TxTsc[1];
+			*(pTmp + 2) = 0;
+			*(pTmp + 3) = (pAdapter->PortCfg.DefaultKeyId << 6) | 0x20;
+			
+			Iv32 = *(PULONG)(&pWpaKey->TxTsc[2]);
+			
+			// Increase TxTsc value for next transmission
+			while (++pWpaKey->TxTsc[i] == 0x0)
+			{
+				i++;
+				if (i == 6)
+					break;
+			}
+			if (i == 6)
+			{
+				// TODO: TSC has done one full cycle, do re-keying stuff follow specs
+				// Should send a special event microsoft defined to request re-key
+			}
+			
+			// Copy IV
+			memcpy(&pTxD->Iv, &Iv16, 4);
+			
+			// Copy EIV
+			memcpy(&pTxD->Eiv, &Iv32, 4);
+			
+			// Set IV offset
+			pTxD->IvOffset = LENGTH_802_11;
+
+			memcpy(pDest, &Iv16, 4);
+			pDest += 4;
+			memcpy(pDest, &Iv32, 4);
+			pDest += 4;
+
+		}
+		
+		//
+		// Only the first fragment required LLC-SNAP header !!!
+		//
+		if ((StartOfFrame == TRUE) && (Encapped == TRUE))
+		{
+			// For WEP & no encryption required frame, just copy LLC header into buffer,
+			// Hardware will do the encryption job.
+			// For TKIP, we have to calculate MIC and store it first
+			if ((CipherSuite == Ndis802_11Encryption2Enabled) && (pWpaKey != NULL))
+			{
+				// Calculate MSDU MIC Value
+				RTMPCalculateMICValue(pAdapter, skb, pEncap, 6, pWpaKey);
+			}
+			// For WEP & no encryption required frame, just copy LLC header into buffer,
+			// Hardware will do the encryption job.
+			// For TKIP, we have to calculate MIC and store it first
+			
+			// Copy LLC header
+			memcpy(pDest, pEncap, 6);
+			pDest += 6;
+
+			// Copy protocol type
+			pSrc = (PUCHAR) pVirtualAddress;
+			memcpy(pDest, pSrc + 12, 2);
+			pDest += 2;
+			
+			// Exclude 802.3 header size, we will recalculate the size at
+			// the end of fragment preparation.
+			NdisBufferLength -= LENGTH_802_3;
+			pSrc += LENGTH_802_3;
+			FreeFragSize -= LENGTH_802_1_H;
+		}
+		else if ((StartOfFrame == TRUE) && (Encapped == FALSE))
+		{
+			if ((pAdapter->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) && (pWpaKey != NULL))
+			{
+				// Calculate MSDU MIC Value
+				RTMPCalculateMICValue(pAdapter, skb, pEncap, 0, pWpaKey);
+			}
+			
+   			pSrc = (PUCHAR) pVirtualAddress + LENGTH_802_3;
+	    		NdisBufferLength -= LENGTH_802_3;
+		}
+		
+		// Start copying payload
+		BytesCopied = 0;
+		do
+		{
+			if (NdisBufferLength >= FreeFragSize)
+			{
+				// Copy only the free fragment size, and save the pointer
+				// of current buffer descriptor for next fragment buffer.
+				memcpy(pDest, pSrc, FreeFragSize);
+				BytesCopied += FreeFragSize;
+				pSrc        += FreeFragSize;
+				pDest       += FreeFragSize;
+				NdisBufferLength      -= FreeFragSize;
+				break;
+			}
+			else
+			{
+				// Copy the rest of this buffer descriptor pointed data
+				// into ring buffer.
+				memcpy(pDest, pSrc, NdisBufferLength);
+				BytesCopied  += NdisBufferLength;
+				pDest        += NdisBufferLength;
+				FreeFragSize -= NdisBufferLength;
+			}
+				// No more buffer descriptor
+				// Add MIC value if needed
+				if ((CipherSuite == Ndis802_11Encryption2Enabled) && 
+					(MICFrag == FALSE) &&
+					(pWpaKey != NULL))
+				{
+					INT i;
+
+					NdisBufferLength = 8;		// Set length to MIC length
+					DBGPRINT(RT_DEBUG_INFO, "Calculated TX MIC value = ");  
+					for (i = 0; i < 8; i++)
+					{
+						DBGPRINT_RAW(RT_DEBUG_INFO, "%02x:", pAdapter->PrivateInfo.Tx.MIC[i]);  
+					}
+					DBGPRINT_RAW(RT_DEBUG_INFO, "\n"); 
+								
+					if (FreeFragSize >= NdisBufferLength)
+					{
+						memcpy(pDest, pAdapter->PrivateInfo.Tx.MIC, NdisBufferLength);
+						BytesCopied  += NdisBufferLength;
+						pDest		 += NdisBufferLength;
+						FreeFragSize -= NdisBufferLength;
+						NdisBufferLength = 0;
+						RemainSize   += 8;	// Need to add MIC as payload
+					}
+					else
+					{
+						memcpy(pDest, pAdapter->PrivateInfo.Tx.MIC, FreeFragSize);
+						BytesCopied  += FreeFragSize;
+						pSrc		  = pAdapter->PrivateInfo.Tx.MIC + FreeFragSize;
+						pDest		 += FreeFragSize;
+						NdisBufferLength		 -= FreeFragSize;
+						MICFrag 	  = TRUE;
+						RemainSize   += (8 - FreeFragSize);	// Need to add MIC as payload
+					}
+				}
+		}	while (FALSE);		// End of copying payload
+				
+		// Real packet size, No 802.1H header for fragments except the first one.
+		if ((StartOfFrame == TRUE) && (Encapped == TRUE))
+		{
+			TxSize = BytesCopied + LENGTH_802_11 + LENGTH_802_1_H;
+		}
+		else
+		{
+			TxSize = BytesCopied + LENGTH_802_11;
+		}
+
+		RemainSize = RemainSize - BytesCopied;
+			
+		if ((CipherSuite == Ndis802_11Encryption1Enabled) && (Header_802_11.Controlhead.Frame.Wep == 1))
+		{
+			// IV + ICV which ASIC added after encryption done
+			TxSize += 4;
+			PLCPLength = TxSize + 8;
+		}
+		else if ((CipherSuite == Ndis802_11Encryption2Enabled) && (pWpaKey != NULL))
+		{
+			// IV + EIV + ICV which ASIC added after encryption done
+			TxSize += 8;
+			PLCPLength = TxSize + 8;
+		}
+		else if ((CipherSuite == Ndis802_11Encryption3Enabled) && (pWpaKey != NULL))
+		{
+			// IV + EIV + HW MIC
+			TxSize += 8;
+			PLCPLength = TxSize + 12;
+		}
+		else
+		{
+			PLCPLength = TxSize + 4;
+		}
+		DBGPRINT_RAW(RT_DEBUG_INFO, "TxSize = %d, PLCPLength = %d\n", TxSize, PLCPLength);//steven:for debug
+				
+		// Prepare Tx descriptors before kicking tx.
+		// The BBP register index in Tx descriptor has to be configured too.
+		if (Header_802_11.Controlhead.Addr1.Octet[0] & 0x01)
+		{
+			INC_COUNTER(pAdapter->WlanCounters.MulticastTransmittedFrameCount);
+			// Multicast, retry bit is off
+			if (StartOfFrame == TRUE)
+			{
+				if (RTUSB_GET_PACKET_RTS(skb) != 1)
+					RTUSBWriteTxDescriptor(pTxD, FALSE, 0, FALSE, FALSE, TRUE, FrameGap, TxSize, Cipher, KeyID, CW_MIN_IN_BITS, CW_MAX_IN_BITS, PLCPLength, pAdapter->PortCfg.TxRate, 4, pAdapter->PortCfg.TxPreambleInUsed);
+				else
+					RTUSBWriteTxDescriptor(pTxD, FALSE, 0, FALSE, FALSE, TRUE, FrameGap, TxSize, Cipher, KeyID, 0, 0, PLCPLength, pAdapter->PortCfg.TxRate, 4, pAdapter->PortCfg.TxPreambleInUsed);
+			}
+			else
+				RTUSBWriteTxDescriptor(pTxD, FALSE, 0, FALSE, FALSE, FALSE, FrameGap, TxSize, Cipher, KeyID, 0, 0, PLCPLength, pAdapter->PortCfg.TxRate, 4, pAdapter->PortCfg.TxPreambleInUsed);
+		}
+		else
+		{
+			if (StartOfFrame == TRUE)
+			{
+				if (RTUSB_GET_PACKET_RTS(skb) != 1)
+					RTUSBWriteTxDescriptor(pTxD, MoreFragment, 7, TRUE, FALSE, TRUE, FrameGap, TxSize, Cipher, KeyID, CW_MIN_IN_BITS, CW_MAX_IN_BITS, PLCPLength, pAdapter->PortCfg.TxRate, 4, pAdapter->PortCfg.TxPreambleInUsed);
+				else
+					RTUSBWriteTxDescriptor(pTxD, MoreFragment, 7, TRUE, FALSE, TRUE, FrameGap, TxSize, Cipher, KeyID, 0, 0, PLCPLength, pAdapter->PortCfg.TxRate, 4, pAdapter->PortCfg.TxPreambleInUsed);
+			}
+			else
+				RTUSBWriteTxDescriptor(pTxD, MoreFragment, 7, TRUE, FALSE, FALSE, FrameGap, TxSize, Cipher, KeyID, 0, 0, PLCPLength, pAdapter->PortCfg.TxRate, 4, pAdapter->PortCfg.TxPreambleInUsed);
+		}
+
+		TransferBufferLength = TxSize + sizeof(TXD_STRUC);
+		if ((TransferBufferLength % 2) == 1)//always bulk out even number of bytes
+			TransferBufferLength++;
+		if ((TransferBufferLength % pAdapter->BulkOutMaxPacketSize) == 0)
+			TransferBufferLength += 2;
+
+		pTxContext->BulkOutSize = TransferBufferLength;
+		RTUSB_SET_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_DATA_NORMAL);
+		
+		// Set frame gap for the rest of fragment burst.
+		// It won't matter if there is only one fragment (single fragment frame).
+		StartOfFrame = FALSE;
+		NumberRequired--;
+		if (NumberRequired == 0)
+		{
+			pTxContext->LastOne = TRUE;
+		}
+		else
+		{
+			pTxContext->LastOne = FALSE;
+		}
+//steven:use ASIC counters to derive this count instead		INC_COUNTER(pAdapter->WlanCounters.TransmittedFragmentCount);
+		//
+		// Increase BulkOut stanby count.
+		//		
+		atomic_inc(&pAdapter->TxCount);
+	}	while (NumberRequired > 0);
+
+#if 0
+	// Add duplicate 1mb broadcast frames
+	do
+	{
+		if ((pAdapter->PortCfg.TxRate != RATE_1) && (Bcast_8023 == TRUE) && (SingleFrag == TRUE))
+		{
+			PTX_CONTEXT		pTmpContext;
+			PTXD_STRUC		pTmpTxD;
+			ULONG			DataOffset = 0;
+
+			pSrc = pTxContext->TransferBuffer->WirelessPacket;
+			//
+			// Check the offset of the original 802.3 data packet
+			//
+			if (CipherSuite == Ndis802_11EncryptionDisabled)
+				DataOffset = 0;
+			else if (CipherSuite == Ndis802_11Encryption1Enabled)
+				DataOffset += 4; //Add IV
+			else if (CipherSuite == Ndis802_11Encryption2Enabled)
+				DataOffset += 8; //Add EIV
+			else if (CipherSuite == Ndis802_11Encryption3Enabled)	
+				DataOffset += 8; //Add EIV
+				
+			// Check for DHCP & BOOTP protocol
+			if ((*(pSrc + 0x35 + DataOffset) != 0x44) || (*(pSrc + 0x37 + DataOffset) != 0x43))
+			{
+				// 
+				// 2054 (hex 0806) for ARP datagrams
+				// if this packet is not ARP datagrams, then do nothing
+				// ARP datagrams will also be duplicate at 1mb broadcast frames
+				//
+				if (Protocol != 0x0806 )
+					break;
+			}
+
+			// Get the Tx Ring descriptor & Dma Buffer address
+			pTmpContext = &pAdapter->TxContext[pAdapter->NextTxIndex];
+			pDest = pTmpContext->TransferBuffer->WirelessPacket;
+			
+			if (pTmpContext->InUse == TRUE)
+				break;  //No available Tx Ring for Send 1mb broadcast frames.
+
+			// Increase & maintain Tx Ring Index
+			pAdapter->NextTxIndex++;
+			if (pAdapter->NextTxIndex >= TX_RING_SIZE)
+			{
+				pAdapter->NextTxIndex = 0;
+			}
+			
+			//
+			// Reset LastOne Tx Ring descriptor
+			//
+			pTmpContext->InUse   = TRUE;
+			pTmpContext->LastOne = TRUE;
+
+			pTmpTxD  = &(pTmpContext->TransferBuffer->TxDesc);
+			//
+			// Duplicate TxD descriptor, and we will reset the its value later.
+			//
+			memcpy(pTmpTxD, pTxD, sizeof(TXD_STRUC));
+			// Start coping data to new ring 
+			memcpy(pDest, pSrc, pTxContext->BulkOutSize);
+			pTmpContext->BulkOutSize = pTxContext->BulkOutSize;
+			RTUSBWriteTxDescriptor(pTmpTxD, FALSE, 7, TRUE, FALSE, FALSE, FrameGap, TxSize, Cipher, KeyID, 0, 0, PLCPLength, RATE_1, 4, pAdapter->PortCfg.TxPreambleInUsed);	
+			//
+			// Increase BulkOut stanby count.
+			//			
+			atomic_inc(&pAdapter->TxCount);
+			DBGPRINT(RT_DEBUG_TRACE, "Send 1M broadcast frame!\n");
+		}
+	} while (FALSE);
+#endif
+
+	// Acknowledge protocol send complete of pending packet.
+	RTUSBFreeSkbBuffer(skb);
+	return (NDIS_STATUS_SUCCESS);
+
+}
+
+VOID RTUSBRxPacket(unsigned long data)
+//VOID RTUSBRxPacket(purbb_t pUrb)
+{
+	//PRT2570ADAPTER pAdapter = (PRT2570ADAPTER)data;
+	purbb_t pUrb = (purbb_t)data;
+	PRT2570ADAPTER pAdapter;
+	PRX_CONTEXT pRxContext;
+	PRXD_STRUC		pRxD;
+	NDIS_STATUS		Status;
+	PHEADER_802_11	pHeader;
+	PUCHAR			pData;
+	PUCHAR			pDestMac, pSrcMac;
+	UCHAR			KeyIdx;
+	ULONG			i;
+	UINT			PacketSize = 0;
+	PUCHAR			pEncap;
+	UCHAR			LLC_Len[2];
+	UCHAR			Header802_3[14];
+	PWPA_KEY		pWpaKey = NULL;
+	// To indicate cipher used for this packet
+	NDIS_802_11_ENCRYPTION_STATUS	Cipher;
+	struct sk_buff  *skb;
+	PVOID			pManage;
+	wlan_ng_prism2_header	*ph;
+
+	pRxContext= (PRX_CONTEXT)pUrb->context;
+	pAdapter = pRxContext->pAdapter;
+	
+	if( RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS) )
+		return;
+
+	do
+	{
+		if (pRxContext->pUrb->actual_length >= (sizeof(RXD_STRUC) + LENGTH_802_11))//blue
+		{
+			pData = pRxContext->TransferBuffer;
+			pManage = (PVOID) pData;
+
+			pRxD = (PRXD_STRUC)(pData + pRxContext->pUrb->actual_length - sizeof(RXD_STRUC));
+			pHeader	= (PHEADER_802_11)pData;
+			
+
+			if (pRxD->DataByteCnt < 4)
+				Status = NDIS_STATUS_FAILURE;
+			else
+			{
+				pAdapter->PortCfg.Pss = PWR_ACTIVE;
+
+				// Increase Total receive byte counter after real data received no mater any error or not
+				pAdapter->RalinkCounters.ReceivedByteCount += (pRxD->DataByteCnt - 4);
+
+				// Check for all RxD errors
+				Status = RTMPCheckRxDescriptor(pAdapter, pRxD);
+			}
+
+			/* Only recieve valid packets in to monitor mode */
+			if (pAdapter->PortCfg.BssType == BSS_MONITOR && Status == NDIS_STATUS_SUCCESS)
+         		{
+ 	        		struct sk_buff  *skb;
+ 	       			if ((skb = __dev_alloc_skb(2048, GFP_DMA|GFP_ATOMIC)) != NULL)
+ 	        		{
+					if (pAdapter->PortCfg.MallowRFMONTx == TRUE) {
+						if (pAdapter->PortCfg.ForcePrismHeader != 1)
+							goto rfmontx_80211_receive;
+					} else {
+						if (pAdapter->PortCfg.ForcePrismHeader == 2)
+							goto rfmontx_80211_receive;
+					}
+
+					// setup the wlan-ng prismheader
+
+					if (skb_headroom(skb) < sizeof(wlan_ng_prism2_header))
+						pskb_expand_head(skb, sizeof(wlan_ng_prism2_header), 0, GFP_ATOMIC);
+
+					ph = (wlan_ng_prism2_header *)
+						skb_push(skb, sizeof(wlan_ng_prism2_header));
+					memset(ph, 0, sizeof(wlan_ng_prism2_header));
+
+					ph->msgcode	= DIDmsg_lnxind_wlansniffrm;
+					ph->msglen	= sizeof(wlan_ng_prism2_header);
+					strcpy(ph->devname, pAdapter->net->name);
+
+					ph->hosttime.did	= DIDmsg_lnxind_wlansniffrm_hosttime;
+					ph->mactime.did		= DIDmsg_lnxind_wlansniffrm_mactime;
+					ph->channel.did		= DIDmsg_lnxind_wlansniffrm_channel;
+					ph->rssi.did		= DIDmsg_lnxind_wlansniffrm_rssi;
+					ph->signal.did		= DIDmsg_lnxind_wlansniffrm_signal;
+					ph->noise.did		= DIDmsg_lnxind_wlansniffrm_noise;
+					ph->rate.did		= DIDmsg_lnxind_wlansniffrm_rate;
+					ph->istx.did		= DIDmsg_lnxind_wlansniffrm_istx;
+					ph->frmlen.did		= DIDmsg_lnxind_wlansniffrm_frmlen;
+
+					ph->hosttime.len	= 4;
+					ph->mactime.len		= 4;
+					ph->channel.len		= 4;
+					ph->rssi.len		= 4;
+					ph->signal.len		= 4;
+					ph->noise.len		= 4;
+					ph->rate.len		= 4;
+					ph->istx.len		= 4;
+					ph->frmlen.len		= 4;
+		
+					ph->hosttime.data	= jiffies;
+					ph->channel.data	= pAdapter->PortCfg.IbssConfig.Channel;
+					ph->signal.data		= pRxD->BBR1;
+					ph->noise.data		= pAdapter->PortCfg.LastR17Value;
+					ph->rssi.data		= ph->signal.data - ph->noise.data;
+					ph->frmlen.data		= pRxD->DataByteCnt;
+
+					if (pRxD->Ofdm == 1)
+					{
+						for (i = 4; i < 12; i++)
+							if (pRxD->BBR0 == PlcpSignal[i])
+								ph->rate.data = _11G_RATES[i] * 2;
+					}
+					else
+						ph->rate.data = pRxD->BBR0 / 5;
+
+					// end prismheader setup
+
+				rfmontx_80211_receive:
+
+ 	      				skb->dev = pAdapter->net;
+ 	      				memcpy(skb_put(skb, pRxD->DataByteCnt-4), pData, pRxD->DataByteCnt-4);
+ 	       				skb->mac.raw = skb->data;
+ 	      				skb->pkt_type = PACKET_OTHERHOST;
+ 	     				skb->protocol = htons(ETH_P_802_2);
+ 	        			skb->ip_summed = CHECKSUM_NONE;
+ 	                		netif_rx(skb);
+ 	            		}	
+                   	
+				if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKIN_RESET)) &&
+				(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RADIO_OFF)) &&
+				(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+				(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)))
+				RTUSBBulkReceive(pAdapter);
+         			continue;
+			}
+			
+			if (Status == NDIS_STATUS_SUCCESS)
+			{
+				// Apply packet filtering rule based on microsoft requirements.
+				Status = RTMPApplyPacketFilter(pAdapter, pRxD, pHeader);
+			}	
+		
+			// Add receive counters
+			if (Status == NDIS_STATUS_SUCCESS)
+			{
+				// Increase 802.11 counters & general receive counters
+				INC_COUNTER(pAdapter->WlanCounters.ReceivedFragmentCount);
+			}
+			else
+			{
+				// Increase general counters
+				pAdapter->Counters.RxErrors++;
+			}
+			
+
+			// Check for retry bit, if this bit is on, search the cache with SA & sequence
+			// as index, if matched, discard this frame, otherwise, update cache
+			// This check only apply to unicast data & management frames
+			if ((pRxD->U2M) && (Status == NDIS_STATUS_SUCCESS) && (pHeader->Controlhead.Frame.Type != BTYPE_CNTL))
+			{
+				if (pHeader->Controlhead.Frame.Retry)
+				{
+					if (RTMPSearchTupleCache(pAdapter, pHeader) == TRUE)
+					{
+						// Found retry frame in tuple cache, Discard this frame / fragment
+						// Increase 802.11 counters
+						INC_COUNTER(pAdapter->WlanCounters.FrameDuplicateCount);
+						DBGPRINT_RAW(RT_DEBUG_INFO, "duplicate frame\n");//steven:for debug
+						Status = NDIS_STATUS_FAILURE;
+					}
+					else
+					{
+						RTMPUpdateTupleCache(pAdapter, pHeader);
+					}
+				}
+				else	// Update Tuple Cache
+				{
+					RTMPUpdateTupleCache(pAdapter, pHeader);
+				}
+			}
+			
+			// Check and set the cipher variable
+			if (pRxD->U2M)
+				Cipher = pAdapter->PortCfg.PairCipher;
+			else
+				Cipher = pAdapter->PortCfg.GroupCipher;		
+				Cipher = pAdapter->PortCfg.WepStatus;
+
+			//
+			// Do RxD release operation	for	all	failure	frames
+			//
+			if (Status == NDIS_STATUS_SUCCESS)
+			{
+				//
+				// Start of	main loop to parse receiving frames.
+				// The sequence	will be	Type first,	then subtype...
+				//
+				switch (pHeader->Controlhead.Frame.Type)
+					{
+						// Frame with data type
+						case BTYPE_DATA:
+							// pData : Pointer skip	the	first 24 bytes,	802.11 HEADER
+							pData += LENGTH_802_11;
+
+							PacketSize = pRxD->DataByteCnt - LENGTH_802_11 - 4;	 //Minus FCS[4].  default for NoneWep.
+							// Drop not my BSS frame
+							if (INFRA_ON(pAdapter))
+							{
+								// Infrastructure mode, check address 2 for BSSID
+								if (memcmp(&pHeader->Controlhead.Addr2, &pAdapter->PortCfg.Bssid, 6) != 0)
+									break;	// Receive frame not my BSSID
+								else
+									atomic_inc(&(pAdapter->PortCfg.DataPacketsFromAP));
+							}
+							else	// Ad-Hoc mode or Not associated
+							{
+								// Ad-Hoc mode, check address 3 for BSSID
+								if (memcmp(&pHeader->Addr3, &pAdapter->PortCfg.Bssid, 6) != 0)
+									break;	// Receive frame not my BSSID
+
+								// Drop frame from AP while we are in Ad-hoc mode or not associated
+								if (pHeader->Controlhead.Frame.FrDs)
+									break;
+							}
+
+							// Drop Null data frame, or CF with NULL data frame
+							if ((pHeader->Controlhead.Frame.Subtype == SUBTYPE_NULL_FUNC) ||
+								(pHeader->Controlhead.Frame.Subtype == SUBTYPE_CFACK)     ||
+								(pHeader->Controlhead.Frame.Subtype == SUBTYPE_CFPOLL)    ||
+								(pHeader->Controlhead.Frame.Subtype == SUBTYPE_CFACK_CFPOLL))
+							{
+								break;
+							}
+
+							// Process Broadcast & Multicast data frame
+							if (pRxD->Bcast || pRxD->Mcast)
+							{
+								// Multicast 802.11 Counter
+								INC_COUNTER(pAdapter->WlanCounters.MulticastReceivedFrameCount);
+								DBGPRINT(RT_DEBUG_INFO,"Receiving multicast frame\n");
+								// Drop Mcast / Bcast frame with fragment bit on
+								if (pHeader->Controlhead.Frame.MoreFrag)
+								{
+									DBGPRINT_RAW(RT_DEBUG_ERROR,"Receiving multicast frame with fragment bit on\n");							
+									break;
+								}	
+								
+								// Filter out Bcast frame which AP relayed for us
+								if (((memcmp(&pHeader->Addr3, pAdapter->CurrentAddress, 6) == 0)) && pHeader->Controlhead.Frame.FrDs)
+									break;
+								
+								// WEP encrypted frame
+								if (pHeader->Controlhead.Frame.Wep)
+								{
+									// Check our WEP setting, if no WEP turning on, just drop this frame
+									if (Cipher == Ndis802_11Encryption1Enabled)	// WEP
+									{
+										if (pRxD->CiErr)
+											break;
+										else
+										{
+											pData = pData + 4;  //Offset skip IV[4]
+											pRxD->DataByteCnt = pRxD->DataByteCnt - 8; //Minus ICV[4] & FCS[4].
+										}
+
+										PacketSize = pRxD->DataByteCnt - LENGTH_802_11 - 4;	//Minus IV[4].
+									}
+									else if (Cipher == Ndis802_11Encryption2Enabled)	// TKIP
+									{
+										if (pRxD->CiErr)
+											{
+									DBGPRINT_RAW(RT_DEBUG_ERROR,"pRxD->CiErr\n");							
+											break;
+											}
+										else
+										{
+											pData = pData + 8; //Offset skip IV[8]
+											//
+											// the MIC is stored on the last one no more Fragment.
+											// that is only last MPDU only need to check MIC.
+											//
+											if (pHeader->Controlhead.Frame.MoreFrag == TRUE)
+											{									
+												// No MIC here.
+												pRxD->DataByteCnt = pRxD->DataByteCnt - 8; //ICV[4] &FCS[4].
+											}
+											else
+											{
+												if (pHeader->Frag != 0)
+													pRxD->DataByteCnt = pRxD->DataByteCnt - 8; //MIC been frag ICV[4] & FCS[4]
+												else										
+													pRxD->DataByteCnt = pRxD->DataByteCnt - 16; //Minus MIC[8] & ICV[4] &FCS[4].
+											}								
+										}
+
+										PacketSize = pRxD->DataByteCnt - LENGTH_802_11 - 8;	//Minus IV+EIV[8].
+									}
+									else if (Cipher == Ndis802_11Encryption3Enabled)	// AES
+									{
+										if (pRxD->CiErr)
+											break;
+										else
+										{
+											pData = pData + 8; //Offset skip RSN[8]
+											pRxD->DataByteCnt = pRxD->DataByteCnt - 12;  //Minus MIC[8] & ICV[4]
+										}
+
+										PacketSize = pRxD->DataByteCnt - LENGTH_802_11 - 8;	//Minus RSN[8]
+									}
+									else
+										break;
+								}
+							}//if (pRxD->Bcast || pRxD->Mcast)				
+							// Begin process unicast to	me frame
+							else if	(pRxD->U2M)
+							{					
+								//
+								// Begin frame processing
+								//
+								// DA is always	address	1
+								pDestMac = (PUCHAR)	&(pHeader->Controlhead.Addr1);
+								// Seclect SA by different mode
+								if (INFRA_ON(pAdapter))		// For infrastructure, SA is address 3
+								{
+									pSrcMac	= (PUCHAR) &(pHeader->Addr3);
+								}
+								else									// For IBSS	mode, SA is	address	2
+								{
+									pSrcMac	= (PUCHAR) &(pHeader->Controlhead.Addr2);
+								}
+								// WEP encrypted frame
+								if (Cipher == Ndis802_11Encryption1Enabled)	// WEP
+								{
+									if (pHeader->Controlhead.Frame.Wep)
+									{
+										if (pRxD->CiErr)
+											break;
+										else
+										{
+											pData = pData + 4; //Offset skip IV[4]
+											pRxD->DataByteCnt = pRxD->DataByteCnt - 8; //Minus ICV[4] & FCS[4].
+										}
+
+										PacketSize = pRxD->DataByteCnt - LENGTH_802_11 - 4;	//Minus IV[4].
+									}
+									else if ((pAdapter->PortCfg.PrivacyFilter == Ndis802_11PrivFilter8021xWEP) &&
+											 (pHeader->Frag == 0))
+									{
+										// Check 802.1x frame, if not drop it.
+										if (memcmp(EAPOL, pData + 6, 2))
+										{
+											// Not 802.1X frames
+											// Add error counter
+											break;
+										}							
+									}						
+								}
+								else if (Cipher == Ndis802_11Encryption2Enabled)	// TKIP
+								{
+									if (pHeader->Controlhead.Frame.Wep)
+									{
+										if (pRxD->CiErr)
+											{										
+								DBGPRINT(RT_DEBUG_TEMP,"pRxD->CiErr\n");
+											break;
+
+
+											}
+										else
+										{
+											pData = pData + 8;  //Offset skip IV[8]
+											//
+											// the MIC is stored on the last one no more Fragment.
+											// that is only last MPDU only need to check MIC.
+											//
+											if (pHeader->Controlhead.Frame.MoreFrag == TRUE)
+											{
+												//No MIC here.
+												pRxD->DataByteCnt = pRxD->DataByteCnt - 8; //ICV[4] &FCS[4].
+											}
+											else
+											{
+												if (pHeader->Frag != 0)
+													pRxD->DataByteCnt = pRxD->DataByteCnt - 8; //MIC been frag ICV[4] & FCS[4]
+												else
+													pRxD->DataByteCnt = pRxD->DataByteCnt - 16; //Minus MIC[8] & ICV[4] & FCS[4].
+											}
+										}
+
+										PacketSize = pRxD->DataByteCnt - LENGTH_802_11 - 8;	//Minus IV+EIV[8].
+									}
+									else if ((pAdapter->PortCfg.PrivacyFilter == Ndis802_11PrivFilter8021xWEP) &&
+											 (pHeader->Frag == 0))
+									{
+										// Check 802.1x frame, if not drop it.
+										if (memcmp(EAPOL, pData + 6, 2) != 0)
+										{
+								DBGPRINT(RT_DEBUG_TEMP,"Not 802.1X frames\n");
+											// Not 802.1X frames
+											// Add error counter
+											break;
+										}
+										DBGPRINT(RT_DEBUG_TEMP," 802.1X EAPOL frames\n");
+									}
+								}
+								else if (Cipher == Ndis802_11Encryption3Enabled)	// AES
+								{
+									if (pHeader->Controlhead.Frame.Wep)
+									{
+										if (pRxD->CiErr)
+											break;
+										else
+										{
+											pData = pData + 8; //Offset skip IV[8]
+											pRxD->DataByteCnt = pRxD->DataByteCnt - 12;  //Minus MIC[8] & ICV[4]
+										}
+
+										PacketSize = pRxD->DataByteCnt - LENGTH_802_11 - 8;	//Minus RSN[8]
+									}
+									else if ((pAdapter->PortCfg.PrivacyFilter == Ndis802_11PrivFilter8021xWEP) &&
+											 (pHeader->Frag == 0))
+									{
+										// Check 802.1x frame, if not drop it.
+										if (memcmp(EAPOL, pData + 6, 2) != 0)
+										{
+											// Not 802.1X frames
+											// Add error counter
+											break;
+										}
+									}
+								}
+								else if (pHeader->Controlhead.Frame.Wep)
+								{
+									// Drop WEP frame when PrivacyInvoked is FALSE
+									break;
+								}						
+							}//else if	(pRxD->U2M)
+			
+							// The total available payload should exclude 24-byte 802.11 Header
+							//packetSize = pRxD->DataByteCnt - LENGTH_802_11 - 4;					
+
+							// Find the WPA key, either Group or Pairwise Key
+							// Although the data has been decrypted by ASIC,
+							// driver has to calculate the RxMIC which required the key.
+							// The failed case should not happen. If it did, drop it.
+							if ((pAdapter->PortCfg.CipherAlg == CIPHER_TKIP) && (pHeader->Controlhead.Frame.Wep))
+							{
+								INT 	idx;
+
+								pWpaKey = (PWPA_KEY) NULL;
+								// First lookup the DA, if it's a group address, use GROUP key
+								if (pRxD->Bcast || pRxD->Mcast)
+								{
+#ifdef BIG_ENDIAN
+									idx = (pRxD->Iv & 0xc0000000) >> 30;
+#else
+									idx = (pRxD->Iv & 0x000000c0) >> 6;
+#endif
+									if ((pAdapter->PortCfg.GroupKey[idx].KeyLen != 0) && 
+										((INFRA_ON(pAdapter) && ((memcmp(&pHeader->Controlhead.Addr2, &pAdapter->PortCfg.Bssid, 6) == 0))) ||
+										(ADHOC_ON(pAdapter) && ((memcmp(&pHeader->Addr3, &pAdapter->PortCfg.Bssid, 6) == 0)))))
+									{
+										pWpaKey = (PWPA_KEY) &pAdapter->PortCfg.GroupKey[idx];
+										pWpaKey->Type = GROUP_KEY;
+										DBGPRINT(RT_DEBUG_INFO, "Rx Use Group Key %d\n", idx);
+									}
+								}
+								// Try to find the Pairwise Key
+								else
+								{
+									for (idx = 0; idx < PAIRWISE_KEY_NO; idx++)
+									{
+										if (((memcmp(&pHeader->Controlhead.Addr2, pAdapter->PortCfg.PairwiseKey[idx].BssId, 6) == 0)) &&
+											(pAdapter->PortCfg.PairwiseKey[idx].KeyLen != 0))
+										{
+											pWpaKey = (PWPA_KEY) &pAdapter->PortCfg.PairwiseKey[idx];
+											pWpaKey->Type = PAIRWISE_KEY;
+											DBGPRINT(RT_DEBUG_LOUD, "Rx Use Pairwise Key %d\n",idx);
+											break;
+										}
+									}
+									// Use default Group Key if there is no Pairwise key present
+									if ((pWpaKey == NULL) && (pAdapter->PortCfg.GroupKey[pAdapter->PortCfg.DefaultKeyId].KeyLen != 0))
+									{
+										pWpaKey = (PWPA_KEY) &pAdapter->PortCfg.GroupKey[pAdapter->PortCfg.DefaultKeyId];
+										pWpaKey->Type = GROUP_KEY;
+										DBGPRINT(RT_DEBUG_INFO, "Rx Use Group Key\n");
+									}
+								}
+								
+								if (pWpaKey == NULL)
+									break;
+							}
+
+							// DA is always address 1
+							pDestMac = (PUCHAR) &(pHeader->Controlhead.Addr1);
+							// Seclect SA by different mode
+							if (INFRA_ON(pAdapter))
+							{
+								// For infrastructure, SA is address 3
+								pSrcMac = (PUCHAR) &(pHeader->Addr3);
+							}
+							else
+							{
+								// For IBSS mode, SA is address 2
+								pSrcMac = (PUCHAR) &(pHeader->Controlhead.Addr2);
+							}
+			
+							// Process Broadcast & Multicast data frame
+							if (pRxD->Bcast || pRxD->Mcast)
+							{							
+								// Save encapaturation starting pointer
+								pEncap = pData;
+
+								// For TKIP frame, calculate the MIC value
+								if ((pAdapter->PortCfg.CipherAlg == CIPHER_TKIP) && (pHeader->Controlhead.Frame.Wep))
+								{
+									i = 0;
+
+									if (RTMPTkipCompareMICValue(pAdapter,															
+																pData,
+																pDestMac,
+																pSrcMac,
+																pWpaKey->RxMic,
+																PacketSize) == FALSE)
+									{
+										DBGPRINT_RAW(RT_DEBUG_ERROR,"BroadCast/Multicast Rx MIC Value error\n");
+										RTMPReportMicError(pAdapter, pWpaKey);
+										Status = NDIS_STATUS_FAILURE;
+										break;
+									}
+
+									// Second, increase RxTsc value for next transmission
+									while (++pWpaKey->RxTsc[i] == 0x0)
+									{
+										i++;
+										if (i == 6)
+											break;
+									}
+									// Rx TSC has done one full cycle, since re-key is done by transmitter
+									// We did not do anything for Rx path
+								}
+								// For WPA2 mixer mode PairCipher = AES, GroupCipher = TKIP
+								else if ((pAdapter->PortCfg.PairCipher  == Ndis802_11Encryption3Enabled) && 
+										 (pAdapter->PortCfg.GroupCipher == Ndis802_11Encryption2Enabled) &&
+										 (pHeader->Controlhead.Frame.Wep))
+								{
+									//Use Software to decript TKIP packet.
+									if (RTMPSoftDecryptTKIP(pAdapter, pRxContext->TransferBuffer, pRxD->DataByteCnt + 12, pAdapter->PortCfg.GroupKey))
+									{
+										DBGPRINT(RT_DEBUG_INFO, "WPA2::RTMPSoftDecryptTKIP Complete\n");
+										pData = pRxContext->TransferBuffer + LENGTH_802_11;
+										PacketSize = pRxD->DataByteCnt - 8 - LENGTH_802_11;  //8 bytes MIC, 4 bytes ICV
+										pEncap = pData;								
+									}
+								}
+							
+								// Check for encapsulataion other than RFC1042 & Bridge tunnel
+								if ((memcmp(SNAP_802_1H, pEncap, 6) != 0) && (memcmp(SNAP_BRIDGE_TUNNEL, pEncap, 6) != 0))
+								{
+									LLC_Len[0] = PacketSize / 256;
+									LLC_Len[1] = PacketSize % 256;
+									MAKE_802_3_HEADER(Header802_3, pDestMac, pSrcMac, ((PUCHAR) LLC_Len));
+								}
+								else
+								{
+									// Remove 802.11 H header & reconstruct 802.3 header
+									pData += (LENGTH_802_1_H - LENGTH_802_3_TYPE);
+									// Patch for WHQl only, which did not turn on Netbios but use IPX within its payload
+									if (((memcmp(IPX, pData, 2) == 0) || (memcmp(APPLE_TALK, pData, 2) == 0)) && (memcmp(SNAP_802_1H, pEncap, 6) == 0))
+									{
+										LLC_Len[0] = PacketSize / 256;
+										LLC_Len[1] = PacketSize % 256;
+										pData = pData - LENGTH_802_1_H;
+										MAKE_802_3_HEADER(Header802_3, pDestMac, pSrcMac, ((PUCHAR) LLC_Len));
+									}
+									else
+									{
+										MAKE_802_3_HEADER(Header802_3, pDestMac, pSrcMac, pData);
+										// The total available payload should exclude 24-byte 802.11 Header
+										// and 8-byte 802.2 LLC
+										PacketSize -= LENGTH_802_1_H;
+									}
+								
+									// Point to read 802.3 payload
+									pData += LENGTH_802_3_TYPE;
+								}
+			
+								// For miniportTransferData
+								pAdapter->pRxData = pData;
+
+								pAdapter->PortCfg.LedCntl.fRxActivity = TRUE; // for RX ACTIVITY LED
+
+								// Acknolwdge upper layer the received frame
+								// Copy header to head of data for compatibility with older protocol
+								// eariler than W2K
+								//memcpy(pData - LENGTH_802_3, Header802_3, LENGTH_802_3);
+								// Acknowledge upper layer the received frame
+								if ((skb = dev_alloc_skb(PacketSize + LENGTH_802_3 + 2)) != NULL)
+								{
+								    skb->dev = pAdapter->net;
+								    skb_reserve(skb, 2);    // 16 byte align the IP header
+								    memcpy(skb_put(skb, LENGTH_802_3), Header802_3, LENGTH_802_3);
+								    memcpy(skb_put(skb, PacketSize), pData, PacketSize);
+								    skb->protocol = eth_type_trans(skb, pAdapter->net);
+								    netif_rx(skb);
+								    pAdapter->net->last_rx = jiffies;
+								    pAdapter->netstats.rx_packets++;
+								}
+								//memset(Header802_3, 0, LENGTH_802_3);
+								DBGPRINT_RAW(RT_DEBUG_INFO, "!!! Broadcast Ethernet rx Indicated !!!\n");
+							} //if (pRxD->Bcast || pRxD->Mcast)											
+							// Begin process unicast to me frame
+							else if (pRxD->U2M) 
+							{
+								// Update Rx data rate first.
+								if (pRxD->Ofdm == 1)
+								{
+									for (i = 4; i < 12; i++)
+									{
+										if (pRxD->BBR0 == PlcpSignal[i])
+											break;
+									}
+									if (i < 12)
+										pAdapter->LastRxRate = i;
+								}
+								else	// receive CCK encoding
+								{
+									if (pRxD->BBR0 == 10)
+										pAdapter->LastRxRate = 0;
+									else if (pRxD->BBR0 == 20)
+										pAdapter->LastRxRate = 1;
+									else if (pRxD->BBR0 == 55)
+										pAdapter->LastRxRate = 2;
+									else if (pRxD->BBR0 == 110)
+										pAdapter->LastRxRate = 3;
+								}
+
+								// Send PS-Poll for AP to send next data frame					
+								if ((pHeader->Controlhead.Frame.MoreData) && INFRA_ON(pAdapter) && (pAdapter->PortCfg.Psm == PWR_SAVE))
+								{
+									//Send PS-Poll frame
+									EnqueuePsPoll(pAdapter);
+									DBGPRINT(RT_DEBUG_TRACE, "Sending PS-POLL\n");
+								}
+
+								//
+								// Begin frame processing
+								//
+								if (pHeader->Frag == 0) // First or Only fragment
+								{
+									// For TKIP frame, calculate the MIC value
+									if (pHeader->Controlhead.Frame.MoreFrag == FALSE)
+									{
+										if ((pAdapter->PortCfg.CipherAlg == CIPHER_TKIP) && (pHeader->Controlhead.Frame.Wep))
+										{
+											//
+											// Use Software to descrypt if transmition keyID not 0 on ADHOC mode.
+											// Since ASIC allows hardware descrypt only KeyID=0 as their pairwisekey.
+											//
+											// Check U2M and KeyID not pairwise key, used Software decypt 
+											//
+											KeyIdx= *((PUCHAR)(pRxContext->TransferBuffer + LENGTH_802_11 + 3));
+											KeyIdx = KeyIdx >> 6;
+
+											if(KeyIdx != 0)
+											{
+												//Use Software to decript TKIP packet.
+												if (RTMPSoftDecryptTKIP(pAdapter, pRxContext->TransferBuffer, pRxD->DataByteCnt + 12, pAdapter->PortCfg.GroupKey))
+												{
+													DBGPRINT(RT_DEBUG_TEMP, "U2M Use Groupkey RTMPSoftDecryptTKIP Complete\n");
+													pData = pRxContext->TransferBuffer + LENGTH_802_11;
+													PacketSize = pRxD->DataByteCnt - 8 - LENGTH_802_11;  //8 bytes MIC, 4 bytes ICV
+												}
+												else
+												{
+													DBGPRINT(RT_DEBUG_TEMP, "RTMPSoftDecryptTKIP failed\n");
+													break;
+												}
+											}
+											else
+											{
+												if (RTMPTkipCompareMICValue(pAdapter,																		
+																			pData,
+																			pDestMac,
+																			pSrcMac,
+																			pWpaKey->RxMic,//steven:where is this from in RT2570
+																			PacketSize) == FALSE)
+												{
+													DBGPRINT_RAW(RT_DEBUG_ERROR,"U2M Rx MIC Value error1\n");
+													RTMPReportMicError(pAdapter, pWpaKey);
+													Status = NDIS_STATUS_FAILURE;
+													break;
+												}
+											}
+
+											// TODO:
+											// Getting RxTSC from Rx descriptor
+										}
+									}
+									
+									// Save encapaturation starting pointer
+									pEncap = pData;								
+									pAdapter->FragFrame.Flags &= 0xFFFFFFFE;
+									
+									// Check for encapsulataion other than RFC1042 & Bridge tunnel
+									if ((memcmp(SNAP_802_1H, pEncap, 6) != 0) && (memcmp(SNAP_BRIDGE_TUNNEL, pEncap, 6) != 0))
+									{
+										LLC_Len[0] = PacketSize / 256;
+										LLC_Len[1] = PacketSize % 256;
+										MAKE_802_3_HEADER(Header802_3, pDestMac, pSrcMac, ((PUCHAR) LLC_Len));
+									}
+									else
+									{
+										// Remove 802.11 H header & reconstruct 802.3 header
+										pData += (LENGTH_802_1_H - LENGTH_802_3_TYPE);
+								if ((memcmp(EAPOL, pData, 2) == 0))
+								{
+									PacketSize += LENGTH_802_11;
+							DBGPRINT_RAW(RT_DEBUG_TEMP, "indicated packet EAPOL  PacketSize%d\n", PacketSize);//steven:for debug
+									// Enqueue this frame to MLME engine
+									MlmeEnqueueForRecv(
+										pAdapter,
+										&pAdapter->Mlme.Queue,	
+										(UCHAR)pRxD->BBR1, 
+										PacketSize + LENGTH_802_1_H, 
+										pManage);					
+									break;
+								}
+										// Patch for WHQl only, which did not turn on Netbios but use IPX within its payload
+										if ((((memcmp(IPX, pData, 2) == 0) || (memcmp(APPLE_TALK, pData, 2) == 0)) && memcmp(SNAP_802_1H, pEncap, 6) == 0))
+										{
+											LLC_Len[0] = PacketSize / 256;
+											LLC_Len[1] = PacketSize % 256;
+											pData = pData - LENGTH_802_1_H;
+											MAKE_802_3_HEADER(Header802_3, pDestMac, pSrcMac, ((PUCHAR) LLC_Len));
+										}
+										else
+										{
+												
+											MAKE_802_3_HEADER(Header802_3, pDestMac, pSrcMac, pData);
+											// The total available payload should exclude 24-byte 802.11 Header
+											// and 8-byte 802.2 LLC
+											PacketSize -= LENGTH_802_1_H;
+											memcpy(pAdapter->FragFrame.Header_LLC, pEncap, 8);
+											pAdapter->FragFrame.Flags |= 0x01;
+										}
+										
+										// Point to read 802.3 payload
+										pData += LENGTH_802_3_TYPE;								
+									}
+										
+									// One & The only fragment
+									if (pHeader->Controlhead.Frame.MoreFrag == FALSE)
+									{
+										// For miniportTransferData
+										pAdapter->pRxData = pData;
+
+										pAdapter->PortCfg.LedCntl.fRxActivity = TRUE; // for RX ACTIVITY LED
+
+										DBGPRINT_RAW(RT_DEBUG_INFO, "indicated packet size = %d\n", PacketSize);//steven:for debug
+										// Acknolwdge upper layer the received frame
+										//memcpy((PUCHAR) pData - LENGTH_802_3, Header802_3, LENGTH_802_3);
+
+										if ((skb = dev_alloc_skb(PacketSize + LENGTH_802_3 + 2)) != NULL)
+										{
+										    skb->dev = pAdapter->net;
+										    skb_reserve(skb, 2);    // 16 byte align the IP header
+										    memcpy(skb_put(skb, LENGTH_802_3), Header802_3, LENGTH_802_3);
+										    memcpy(skb_put(skb, PacketSize), pData, PacketSize);
+										    skb->protocol = eth_type_trans(skb, pAdapter->net);
+										    netif_rx(skb);
+										    pAdapter->net->last_rx = jiffies;
+										    pAdapter->netstats.rx_packets++;
+										}
+										// Increase general counters
+										pAdapter->Counters.GoodReceives++;
+
+										DBGPRINT_RAW(RT_DEBUG_INFO, "!!! Frame without Fragment Indicated	!!!\n");
+									}
+									// First fragment of fragmented frames
+									else
+									{
+										memcpy(pAdapter->FragFrame.Buffer,	pData, PacketSize);
+										memcpy(pAdapter->FragFrame.Header802_3, Header802_3, LENGTH_802_3);
+										pAdapter->FragFrame.RxSize	 = PacketSize;
+										pAdapter->FragFrame.Sequence = pHeader->Sequence;
+										pAdapter->FragFrame.LastFrag = pHeader->Frag;		// Should be 0
+									}
+								}
+								// Middle & End of fragment burst fragments
+								else
+								{
+									// No LLC-SNAP header in except the first fragment frame
+
+									if ((pHeader->Sequence != pAdapter->FragFrame.Sequence) ||
+										(pHeader->Frag != (pAdapter->FragFrame.LastFrag + 1)))
+									{
+										// Fragment is not the same sequence or out of fragment number order
+										// Clear Fragment frame contents
+										memset(&pAdapter->FragFrame, 0, sizeof(FRAGMENT_FRAME));
+										Status = NDIS_STATUS_FAILURE;
+										break;
+									}	
+									else if ((pAdapter->FragFrame.RxSize + PacketSize) > MAX_FRAME_SIZE)
+									{
+										// Fragment frame is too large, it exeeds the maximum frame size.
+										// We have to drop it.
+										// Clear Fragment frame contents
+										memset(&pAdapter->FragFrame, 0, sizeof(FRAGMENT_FRAME));
+										Status = NDIS_STATUS_FAILURE;
+										break;
+									}
+
+									memcpy(&pAdapter->FragFrame.Buffer[pAdapter->FragFrame.RxSize], pData, PacketSize);
+									pAdapter->FragFrame.RxSize	+= PacketSize;
+									pData += PacketSize;
+									pAdapter->FragFrame.LastFrag = pHeader->Frag;		// Update fragment number
+										
+									// Last fragment
+									if (pHeader->Controlhead.Frame.MoreFrag == FALSE)
+									{
+										// For miniportTransferData
+										pAdapter->pRxData = pAdapter->FragFrame.Buffer;
+
+										pAdapter->PortCfg.LedCntl.fRxActivity = TRUE; // for RX ACTIVITY LED
+
+										// For TKIP frame, calculate the MIC value
+										if ((pAdapter->PortCfg.CipherAlg == CIPHER_TKIP) && (pHeader->Controlhead.Frame.Wep))
+										{
+											if (pWpaKey == NULL)
+											{
+												DBGPRINT_RAW(RT_DEBUG_ERROR,"No matched TKIP in decryption done calculate MIC routine!!!\n"); 						
+												Status = NDIS_STATUS_FAILURE;
+												break;
+											}
+
+											//
+											// For the last fragment, we also need to copy the MIC 
+											// to the end of pAdapter->FragFrame.Buffer
+											// for RTMPTkipCompareMICValueWithLLC used.
+											//
+											pAdapter->FragFrame.RxSize -= 8; //We need to Minus MIC[8] on Fragment case.
+												
+											if (pAdapter->FragFrame.Flags & 0x00000001)
+											{
+												if (RTMPTkipCompareMICValueWithLLC(pAdapter,																				
+																					pAdapter->FragFrame.Header_LLC,
+																					pAdapter->FragFrame.Buffer,
+																					pDestMac,
+																					pSrcMac,
+																					pWpaKey->RxMic,
+																					pAdapter->FragFrame.RxSize) == FALSE)
+												{
+												DBGPRINT_RAW(RT_DEBUG_ERROR,"Rx MIC Value error 2\n");							
+												RTMPReportMicError(pAdapter, pWpaKey);
+												Status = NDIS_STATUS_FAILURE;
+												break;
+												}
+											}
+											else
+											{
+												if (RTMPTkipCompareMICValue(pAdapter,																		
+																			pAdapter->FragFrame.Buffer,
+																			pDestMac,
+																			pSrcMac,
+																			pWpaKey->RxMic,
+																			pAdapter->FragFrame.RxSize) == FALSE)
+												{
+													DBGPRINT_RAW(RT_DEBUG_ERROR,"Rx MIC Value error 2\n");							
+													RTMPReportMicError(pAdapter, pWpaKey);
+													Status = NDIS_STATUS_FAILURE;
+													break;
+												}
+											}
+										}		
+
+										// Acknolwdge upper layer the received frame
+	                                if ((skb = dev_alloc_skb(pAdapter->FragFrame.RxSize + LENGTH_802_3 + 2)) != NULL)
+	                                {
+
+	                                    skb->dev = pAdapter->net;
+	                                    skb_reserve(skb, 2);    /* 16 byte align the IP header */
+	                                    memcpy(skb_put(skb, LENGTH_802_3), (PVOID) pAdapter->FragFrame.Header802_3, LENGTH_802_3);
+	                                    memcpy(skb_put(skb, pAdapter->FragFrame.RxSize), (PVOID) &pAdapter->FragFrame.Buffer[0], pAdapter->FragFrame.RxSize);
+	                                    skb->protocol = eth_type_trans(skb, pAdapter->net);
+	                                    netif_rx(skb);
+	                                    pAdapter->net->last_rx = jiffies;
+	                                    pAdapter->netstats.rx_packets++;
+	                                }
+										// Increase general counters
+										pAdapter->Counters.GoodReceives++;
+
+										// Clear Fragment frame contents
+										//memset(&pAdapter->FragFrame, 0, sizeof(FRAGMENT_FRAME));
+										DBGPRINT_RAW(RT_DEBUG_INFO, "!!! Frame with Fragment Indicated !!!\n");
+									} //Last fragment //if (pHeader->Controlhead.Frame.MoreFrag == FALSE)
+								} //Middle & End of fragment burst fragments
+							}//else if (pRxD->U2M)
+							break;
+
+						case BTYPE_MGMT:
+							// Enqueue this frame to MLME engine
+							MlmeEnqueueForRecv(pAdapter,
+												&pAdapter->Mlme.Queue,
+												(UCHAR)pRxD->BBR1,
+												pRxD->DataByteCnt - 4,
+												pData);
+							break;
+				
+						case BTYPE_CNTL:
+							// Ignore ???
+							break;
+				
+						default	:
+							break;
+					}//switch (pHeader->Controlhead.Frame.Type)	
+				pAdapter->RalinkCounters.RxCount ++;
+
+			}
+			else if (Status == NDIS_STATUS_RESET)
+			{
+				RTUSBEnqueueInternalCmd(pAdapter, RT_OID_USB_RESET_BULK_IN);
+				return;
+			}
+		}
+
+		pRxContext->InUse = FALSE;
+
+	if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKIN_RESET)) &&
+		(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RADIO_OFF)) &&
+		(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+		(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)))
+			RTUSBBulkReceive(pAdapter);
+	}while(0);
+	
+
+}
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBDequeueMLMEPacket(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	PMGMT_STRUC		pMgmt;
+
+	DBGPRINT(RT_DEBUG_INFO, "RTUSBDequeueMLMEPacket\n");
+	NdisAcquireSpinLock(&pAdapter->MLMEWaitQueueLock);
+	while ((pAdapter->PopMgmtIndex != pAdapter->PushMgmtIndex) || (atomic_read(&pAdapter->MgmtQueueSize) > 0))
+	{
+		pMgmt = &pAdapter->MgmtRing[pAdapter->PopMgmtIndex];
+
+		if (RTUSBFreeDescriptorRequest(pAdapter, PRIO_RING, 1) == NDIS_STATUS_SUCCESS)
+		{
+			atomic_dec(&pAdapter->MgmtQueueSize);
+			pAdapter->PopMgmtIndex = (pAdapter->PopMgmtIndex + 1) % MGMT_RING_SIZE;
+			NdisReleaseSpinLock(&pAdapter->MLMEWaitQueueLock);
+
+			RTUSBMlmeHardTransmit(pAdapter, pMgmt);
+
+			MlmeFreeMemory(pAdapter, pMgmt->pBuffer);
+			pMgmt->pBuffer = NULL;
+			pMgmt->Valid = FALSE;
+
+			NdisAcquireSpinLock(&pAdapter->MLMEWaitQueueLock);
+		}
+		else
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "RTUSBDequeueMLMEPacket::PrioRingFirstIndex = %d, PrioRingTxCnt = %d, PopMgmtIndex = %d, PushMgmtIndex = %d, NextMLMEIndex = %d\n", 
+			pAdapter->PrioRingFirstIndex, pAdapter->PrioRingTxCnt, 
+			pAdapter->PopMgmtIndex, pAdapter->PushMgmtIndex, pAdapter->NextMLMEIndex);	
+			break;
+		}
+	}
+	NdisReleaseSpinLock(&pAdapter->MLMEWaitQueueLock);
+}    
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBCleanUpMLMEWaitQueue(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	PMGMT_STRUC		pMgmt;
+
+	DBGPRINT(RT_DEBUG_TRACE, "--->CleanUpMLMEWaitQueue\n");
+
+	NdisAcquireSpinLock(&pAdapter->MLMEWaitQueueLock);
+	while (pAdapter->PopMgmtIndex != pAdapter->PushMgmtIndex)
+	{
+		pMgmt = (PMGMT_STRUC)&pAdapter->MgmtRing[pAdapter->PopMgmtIndex];
+		MlmeFreeMemory(pAdapter, pMgmt->pBuffer);
+		pMgmt->pBuffer = NULL;
+		pMgmt->Valid = FALSE;
+		atomic_dec(&pAdapter->MgmtQueueSize);
+
+		pAdapter->PopMgmtIndex++;
+		if (pAdapter->PopMgmtIndex >= MGMT_RING_SIZE)
+		{
+			pAdapter->PopMgmtIndex = 0;
+		}
+	}
+	NdisReleaseSpinLock(&pAdapter->MLMEWaitQueueLock);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<---CleanUpMLMEWaitQueue\n");
+}
+
+
+/*
+	========================================================================
+
+	Routine	Description:
+		API for MLME to transmit management frame to AP (BSS Mode)
+	or station (IBSS Mode)
+	
+	Arguments:
+		pAdapter	Pointer	to our adapter
+		Buffer		Pointer to  memory of outgoing frame
+		Length		Size of outgoing management frame
+		
+	Return Value:
+		NDIS_STATUS_FAILURE
+		NDIS_STATUS_PENDING
+		NDIS_STATUS_SUCCESS
+
+	Note:
+	
+	========================================================================
+*/
+VOID	MiniportMMRequest(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PVOID			pBuffer,
+	IN	ULONG			Length)
+{
+
+	if (pBuffer)
+	{
+		PMGMT_STRUC	pMgmt;
+
+		// Check management ring free avaliability
+		NdisAcquireSpinLock(&pAdapter->MLMEWaitQueueLock);
+		pMgmt = (PMGMT_STRUC)&pAdapter->MgmtRing[pAdapter->PushMgmtIndex];
+		// This management cell has been occupied
+		if (pMgmt->Valid == TRUE)
+		{
+			NdisReleaseSpinLock(&pAdapter->MLMEWaitQueueLock);
+			MlmeFreeMemory(pAdapter, pBuffer);
+			pAdapter->RalinkCounters.MgmtRingFullCount++;
+			DBGPRINT_RAW(RT_DEBUG_WARN, "MiniportMMRequest (error:: MgmtRing full)\n");
+		}
+		// Insert this request into software managemnet ring
+		else
+		{
+			pMgmt->pBuffer = pBuffer;
+			pMgmt->Length  = Length;
+			pMgmt->Valid   = TRUE;
+			pAdapter->PushMgmtIndex++;
+			atomic_inc(&pAdapter->MgmtQueueSize);
+			if (pAdapter->PushMgmtIndex >= MGMT_RING_SIZE)
+			{
+				pAdapter->PushMgmtIndex = 0;
+			}
+			NdisReleaseSpinLock(&pAdapter->MLMEWaitQueueLock);
+		}
+	}
+	else
+		DBGPRINT(RT_DEBUG_WARN, "MiniportMMRequest (error:: NULL msg)\n");
+	
+	RTUSBDequeueMLMEPacket(pAdapter);
+	
+	// If pAdapter->PrioRingTxCnt is larger than 0, this means that prio_ring have something to transmit.
+	// Then call KickBulkOut to transmit it
+	if (pAdapter->PrioRingTxCnt > 0)
+	{
+		DBGPRINT(RT_DEBUG_INFO, "MiniportMMRequest::PrioRingFirstIndex = %d, PrioRingTxCnt = %d, PopMgmtIndex = %d, PushMgmtIndex = %d, NextMLMEIndex = %d\n", 
+		pAdapter->PrioRingFirstIndex, pAdapter->PrioRingTxCnt, 
+		pAdapter->PopMgmtIndex, pAdapter->PushMgmtIndex, pAdapter->NextMLMEIndex);	
+
+		AsicForceWakeup(pAdapter);
+		RTUSBKickBulkOut(pAdapter);
+	}
+	
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Search tuple cache for receive duplicate frame from unicast frames.
+		
+	Arguments:
+		pAdapter		Pointer	to our adapter
+		pHeader			802.11 header of receiving frame
+		
+	Return Value:
+		TRUE			found matched tuple cache
+		FALSE			no matched found
+
+	Note:
+	
+	========================================================================
+*/
+BOOLEAN	RTMPSearchTupleCache(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PHEADER_802_11	pHeader)
+{
+	INT	Index;
+
+	for (Index = 0; Index < MAX_CLIENT; Index++)
+	{
+		if (pAdapter->TupleCache[Index].Valid == FALSE)
+		    continue;
+		
+		if ((memcmp(&pAdapter->TupleCache[Index].MAC, &pHeader->Controlhead.Addr2, 6)== 0) &&
+			(pAdapter->TupleCache[Index].Sequence == pHeader->Sequence) &&
+			(pAdapter->TupleCache[Index].Frag == pHeader->Frag))
+		{
+			return (TRUE);
+		}
+	}
+	return (FALSE);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Update tuple cache for new received unicast frames.
+		
+	Arguments:
+		pAdapter		Pointer	to our adapter
+		pHeader			802.11 header of receiving frame
+		
+	Return Value:
+		None
+		
+	Note:
+	
+	========================================================================
+*/
+VOID	RTMPUpdateTupleCache(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PHEADER_802_11	pHeader)
+{
+	UCHAR	Index;
+
+	for (Index = 0; Index < MAX_CLIENT; Index++)
+	{
+		if (pAdapter->TupleCache[Index].Valid == FALSE)
+		{
+			// Add new entry
+			memcpy(&pAdapter->TupleCache[Index].MAC, &pHeader->Controlhead.Addr2, 6);
+			pAdapter->TupleCache[Index].Sequence = pHeader->Sequence;
+			pAdapter->TupleCache[Index].Frag     = pHeader->Frag;
+			pAdapter->TupleCache[Index].Valid    = TRUE;
+			pAdapter->TupleCacheLastUpdateIndex  = Index;
+			DBGPRINT(RT_DEBUG_INFO,"DUPCHECK - Add Entry %d, MAC=%02x:%02x:%02x:%02x:%02x:%02x\n", 
+			    Index, pAdapter->TupleCache[Index].MAC.Octet[0], pAdapter->TupleCache[Index].MAC.Octet[1],
+			    pAdapter->TupleCache[Index].MAC.Octet[2], pAdapter->TupleCache[Index].MAC.Octet[3],
+			    pAdapter->TupleCache[Index].MAC.Octet[4], pAdapter->TupleCache[Index].MAC.Octet[5]);
+			return;
+		}
+		else if ((memcmp(&pAdapter->TupleCache[Index].MAC, &pHeader->Controlhead.Addr2, 6)== 0))
+		{
+			// Update old entry
+			pAdapter->TupleCache[Index].Sequence = pHeader->Sequence;
+			pAdapter->TupleCache[Index].Frag     = pHeader->Frag;
+			return;
+		}
+	}
+
+    // tuple cache full, replace the first inserted one (even though it may not be
+    // least referenced one)
+	if (Index == MAX_CLIENT)
+	{
+	    pAdapter->TupleCacheLastUpdateIndex ++;
+	    if (pAdapter->TupleCacheLastUpdateIndex >= MAX_CLIENT)
+		pAdapter->TupleCacheLastUpdateIndex = 0;
+	    Index = pAdapter->TupleCacheLastUpdateIndex;
+
+		// replace with new entry
+		memcpy(&pAdapter->TupleCache[Index].MAC, &pHeader->Controlhead.Addr2, 6);
+		pAdapter->TupleCache[Index].Sequence = pHeader->Sequence;
+		pAdapter->TupleCache[Index].Frag     = pHeader->Frag;
+		pAdapter->TupleCache[Index].Valid    = TRUE;
+		DBGPRINT(RT_DEBUG_INFO,"DUPCHECK - replace Entry %d, MAC=%02x:%02x:%02x:%02x:%02x:%02x\n", 
+		    Index, pAdapter->TupleCache[Index].MAC.Octet[0], pAdapter->TupleCache[Index].MAC.Octet[1],
+		    pAdapter->TupleCache[Index].MAC.Octet[2], pAdapter->TupleCache[Index].MAC.Octet[3],
+		    pAdapter->TupleCache[Index].MAC.Octet[4], pAdapter->TupleCache[Index].MAC.Octet[5]);
+	}
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Apply packet filter policy, return NDIS_STATUS_FAILURE if this frame
+		should be dropped.
+		
+	Arguments:
+		pAdapter		Pointer	to our adapter
+		pRxD			Pointer	to the Rx descriptor
+		pHeader			Pointer to the 802.11 frame header
+		
+	Return Value:
+		NDIS_STATUS_SUCCESS		Accept frame
+		NDIS_STATUS_FAILURE		Drop Frame
+		
+	Note:
+		Maganement frame should bypass this filtering rule.
+	
+	========================================================================
+*/
+NDIS_STATUS	RTMPApplyPacketFilter(
+	IN	PRT2570ADAPTER	pAdapter, 
+	IN	PRXD_STRUC		pRxD, 
+	IN	PHEADER_802_11	pHeader)
+{
+	UCHAR	i;
+	
+	// 0. Management frame should bypass all these filtering rules.
+	if (pHeader->Controlhead.Frame.Type == BTYPE_MGMT)
+	{
+		if ((pRxD->U2M) || (pRxD->Bcast) || (pRxD->Mcast))//steven:for ASIC Bug Workaround
+		return(NDIS_STATUS_SUCCESS);
+	}
+	
+	// 0.1	Drop all Rx frames if MIC countermeasures kicks in
+	if (pAdapter->PortCfg.MicErrCnt >= 2)
+	{
+		return(NDIS_STATUS_FAILURE);
+	}
+	
+	// 1. Drop unicast to me packet if NDIS_PACKET_TYPE_DIRECTED is FALSE
+	if (pRxD->U2M)
+	{
+		if (pAdapter->bAcceptDirect == FALSE)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO, "unicast not accepted\n");//steven:for debug
+			return(NDIS_STATUS_FAILURE);
+		}
+	}
+		
+	// 2. Drop broadcast packet if NDIS_PACKET_TYPE_BROADCAST is FALSE
+	else if (pRxD->Bcast)
+	{
+		if (pAdapter->bAcceptBroadcast == FALSE)
+		{
+			DBGPRINT(RT_DEBUG_INFO, "broadcast not accepted\n");//steven:for debug
+			return(NDIS_STATUS_FAILURE);
+		}
+	}
+			
+	// 3. Drop multicast packet if NDIS_PACKET_TYPE_ALL_MULTICAST is false
+	//    and NDIS_PACKET_TYPE_MULTICAST is false.
+	//    If NDIS_PACKET_TYPE_MULTICAST is true, but NDIS_PACKET_TYPE_ALL_MULTICAST is false.
+	//    We have to deal with multicast table lookup & drop not matched packets.
+	else if (pRxD->Mcast)
+	{
+		if (pAdapter->bAcceptAllMulticast == FALSE)
+		{
+			if (pAdapter->bAcceptMulticast == FALSE)
+			{
+				DBGPRINT_RAW(RT_DEBUG_INFO, "multicast not accepted\n");//steven:for debug
+				return(NDIS_STATUS_FAILURE);
+			}
+			else
+			{
+				// Selected accept multicast packet based on multicast table
+				for (i = 0; i < pAdapter->NumberOfMcAddresses; i++)
+				{
+					if ((memcmp(&pHeader->Controlhead.Addr1, pAdapter->McastTable[i], ETH_LENGTH_OF_ADDRESS)== 0))
+					{
+						break;		// Matched
+					}
+				}
+
+				// Not matched
+				if (i == pAdapter->NumberOfMcAddresses)
+				{
+					DBGPRINT(RT_DEBUG_INFO,"Drop multicast %02x:%02x:%02x:%02x:%02x:%02x\n",
+						pHeader->Controlhead.Addr1.Octet[0], pHeader->Controlhead.Addr1.Octet[1],
+						pHeader->Controlhead.Addr1.Octet[2], pHeader->Controlhead.Addr1.Octet[3],
+						pHeader->Controlhead.Addr1.Octet[4], pHeader->Controlhead.Addr1.Octet[5]);
+					DBGPRINT(RT_DEBUG_LOUD, "multicast not matched\n");
+					return(NDIS_STATUS_FAILURE);
+				}
+				else
+				{
+					DBGPRINT(RT_DEBUG_INFO,"Accept multicast %02x:%02x:%02x:%02x:%02x:%02x\n",
+						pHeader->Controlhead.Addr1.Octet[0], pHeader->Controlhead.Addr1.Octet[1],
+						pHeader->Controlhead.Addr1.Octet[2], pHeader->Controlhead.Addr1.Octet[3],
+						pHeader->Controlhead.Addr1.Octet[4], pHeader->Controlhead.Addr1.Octet[5]);
+				}
+			}
+		}
+	}
+
+	// 4. Not U2M, not Mcast, not Bcast, must be unicast to other DA.
+	//    Since we did not implement promiscuous mode, just drop this kind of packet for now.
+	else
+	{
+		DBGPRINT_RAW(RT_DEBUG_TRACE, "not-to-me unicast\n");//steven:for debug
+		return(NDIS_STATUS_FAILURE);
+	}
+	
+	return(NDIS_STATUS_SUCCESS);	
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Check Rx descriptor, return NDIS_STATUS_FAILURE if any error dound
+		
+	Arguments:
+		pRxD		Pointer	to the Rx descriptor
+		
+	Return Value:
+		NDIS_STATUS_SUCCESS		No err
+		NDIS_STATUS_FAILURE		Error
+		
+	Note:
+	
+	========================================================================
+*/
+NDIS_STATUS	RTMPCheckRxDescriptor(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PRXD_STRUC	pRxD)
+{
+	// Phy errors
+	if (pRxD->PhyErr)
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "pRxD->PhyErr 0x%x, 0x%x, 0x%x, 0x%x\n", *(ULONG*)pRxD, *((ULONG*)pRxD+1), *((ULONG*)pRxD+2), *((ULONG*)pRxD+3));
+		return(NDIS_STATUS_FAILURE);
+	}
+	
+	// CRC errors
+	if (pRxD->Crc)
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "pRxD->Crc\n");
+		return(NDIS_STATUS_FAILURE);
+	}
+	
+	// Paul 04-03 for OFDM Rx length issue
+	if (pRxD->DataByteCnt > 1604)
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "received too long, DataByteCnt = %d\n", pRxD->DataByteCnt);
+		return NDIS_STATUS_RESET;
+	}
+
+	return(NDIS_STATUS_SUCCESS);
+}
+
+/*
+	========================================================================
+
+	Routine	Description:
+		Process MIC error indication and record MIC error timer.
+		
+	Arguments:
+		pAdapter		Pointer	to our adapter
+		pWpaKey			Pointer	to the WPA key structure
+		
+	Return Value:
+		None
+		
+	Note:
+	
+	========================================================================
+*/
+VOID	RTMPReportMicError(
+	IN	PRT2570ADAPTER	pAdapter, 
+	IN	PWPA_KEY		pWpaKey)
+{
+	ULONG	Now;
+	struct
+	{
+		NDIS_802_11_STATUS_INDICATION		Status;
+		NDIS_802_11_AUTHENTICATION_REQUEST	Request;
+	}	Report;
+
+	// 0. Set Status to indicate auth error
+	Report.Status.StatusType = Ndis802_11StatusType_Authentication;
+	
+	// 1. Check for Group or Pairwise MIC error
+	if (pWpaKey->Type == PAIRWISE_KEY)
+		Report.Request.Flags = NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR;
+	else
+		Report.Request.Flags = NDIS_802_11_AUTH_REQUEST_GROUP_ERROR;
+
+	// 2. Copy AP MAC address
+	memcpy(Report.Request.Bssid, pWpaKey->BssId, 6);
+
+	// 3. Calculate length
+	Report.Request.Length = sizeof(NDIS_802_11_AUTHENTICATION_REQUEST);
+
+	// 4. Indicate to NDIS
+	NdisMIndicateStatus(pAdapter->AdapterHandle, NDIS_STATUS_MEDIA_SPECIFIC_INDICATION, (PVOID) &Report, sizeof(Report));
+	NdisMIndicateStatusComplete(pAdapter->AdapterHandle);
+
+	// 5. Record Last MIC error time and count
+	Now = jiffies;
+	if (pAdapter->PortCfg.MicErrCnt == 0)
+	{
+		pAdapter->PortCfg.MicErrCnt++;
+		pAdapter->PortCfg.LastMicErrorTime = Now;
+	}
+	else if (pAdapter->PortCfg.MicErrCnt == 1)
+	{
+		if ((pAdapter->PortCfg.LastMicErrorTime + (60 * 1000)) < Now)
+		{
+			// Update Last MIC error time, this did not violate two MIC errors within 60 seconds
+			pAdapter->PortCfg.LastMicErrorTime = Now;			
+		}
+		else
+		{
+			pAdapter->PortCfg.LastMicErrorTime = Now;			
+			// Violate MIC error counts, MIC countermeasures kicks in
+			pAdapter->PortCfg.MicErrCnt++;			
+			// We shall block all reception
+			// We shall clean all Tx ring and disassoicate from AP after next EAPOL frame
+			RTUSBRejectPendingPackets(pAdapter);
+			RTUSBCleanUpDataBulkOutQueue(pAdapter);
+		}
+	}
+	else
+	{
+		// MIC error count >= 2
+		// This should not happen
+		;
+	}
+}
+/*
+	========================================================================
+
+	Routine	Description:
+		Copy frame from waiting queue into relative ring buffer and set 
+	appropriate ASIC register to kick hardware transmit function
+	
+	Arguments:
+		pAdapter	Pointer	to our adapter
+		pBuffer		Pointer to  memory of outgoing frame
+		Length		Size of outgoing management frame
+		
+	Return Value:
+		NDIS_STATUS_FAILURE
+		NDIS_STATUS_PENDING
+		NDIS_STATUS_SUCCESS
+
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBMlmeHardTransmit(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PMGMT_STRUC		pMgmt)
+{
+	PTX_CONTEXT		pMLMEContext;
+	PTXD_STRUC		pTxD;
+	PUCHAR			pDest;	
+	PHEADER_802_11	pHeader_802_11;
+	BOOLEAN         AckRequired, InsertTimestamp;
+	ULONG			TransferBufferLength;
+	PVOID			pBuffer = pMgmt->pBuffer;
+	ULONG			Length = pMgmt->Length;
+	
+	DBGPRINT_RAW(RT_DEBUG_INFO, "--->MlmeHardTransmit\n");
+	
+	pAdapter->PrioRingTxCnt++;
+
+	pMLMEContext = &pAdapter->MLMEContext[pAdapter->NextMLMEIndex];
+	pMLMEContext->InUse = TRUE;
+
+	// Increase & maintain Tx Ring Index
+	pAdapter->NextMLMEIndex++;
+	if (pAdapter->NextMLMEIndex >= PRIO_RING_SIZE)
+	{
+		pAdapter->NextMLMEIndex = 0;
+	}
+
+	pDest				= pMLMEContext->TransferBuffer->WirelessPacket;              
+	pTxD				= (PTXD_STRUC)(pMLMEContext->TransferBuffer);
+	memset(pTxD, 0, sizeof(TXD_STRUC));
+	
+	pHeader_802_11 = (PHEADER_802_11) pBuffer;
+	InsertTimestamp = FALSE;
+	if (pHeader_802_11->Controlhead.Frame.Type == BTYPE_CNTL) // must be PS-POLL
+	{
+		AckRequired = FALSE;
+	}
+	else // BTYPE_MGMT or BMGMT_DATA(must be NULL frame)
+	{
+		pAdapter->Sequence       = ((pAdapter->Sequence) + 1) & (MAX_SEQ_NUMBER);
+		pHeader_802_11->Sequence = pAdapter->Sequence;
+
+		if (pHeader_802_11->Controlhead.Addr1.Octet[0] & 0x01) // MULTICAST, BROADCAST
+		{
+			INC_COUNTER(pAdapter->WlanCounters.MulticastTransmittedFrameCount);
+			AckRequired = FALSE;
+			pHeader_802_11->Controlhead.Duration = 0;
+		}
+		else
+		{
+			AckRequired = TRUE;
+			pHeader_802_11->Controlhead.Duration = RTUSBCalcDuration(pAdapter, pAdapter->PortCfg.MlmeRate, 14);
+			if (pHeader_802_11->Controlhead.Frame.Subtype == SUBTYPE_PROBE_RSP)
+			{
+				InsertTimestamp = TRUE;
+			}
+		}
+	}
+	
+	memcpy(pDest, pBuffer, Length);
+   
+	// Initialize Priority Descriptor
+	// For inter-frame gap, the number is for this frame and next frame
+	// For MLME rate, we will fix as 2Mb to match other vendor's implement
+	RTUSBWriteTxDescriptor(pTxD, FALSE, 0, AckRequired, InsertTimestamp,
+		TRUE, IFS_BACKOFF, Length, FALSE, 0, CW_MIN_IN_BITS, CW_MAX_IN_BITS,
+		Length + 4, pAdapter->PortCfg.MlmeRate, 4, pAdapter->PortCfg.TxPreambleInUsed);
+
+	// Build our URB for USBD
+	TransferBufferLength = sizeof(TXD_STRUC) + Length;
+	if ((TransferBufferLength % 2) == 1)
+		TransferBufferLength++;
+	if ((TransferBufferLength % pAdapter->BulkOutMaxPacketSize) == 0)
+		TransferBufferLength += 2;
+	
+	pMLMEContext->BulkOutSize = TransferBufferLength;
+	RTUSB_SET_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_MLME);
+	
+	DBGPRINT(RT_DEBUG_INFO, "<---MlmeHardTransmit\n");
+}   
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rtusb_info.c linux-2.4.35.3-mct/drivers/usb/rt2570/rtusb_info.c
--- linux-2.4.35.3/drivers/usb/rt2570/rtusb_info.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rtusb_info.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,4260 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************
+ *
+ *	Module Name:	rtusb_info.c
+ *
+ *	Abstract:	
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ *	RobinC		02-06-2005	RFMON Mode added
+ *	RobinC		02-06-2005	Fix frequency reporting
+ *      MarkW           13-07-2005      Fix ESSID reporting
+ *************************************************************************/
+
+#include "rt_config.h"
+#include <net/iw_handler.h>
+
+
+#define NR_WEP_KEYS 4
+#define WEP_SMALL_KEY_LEN (40/8)
+#define WEP_LARGE_KEY_LEN (104/8)
+
+
+#define     MAP_CHANNEL_ID_TO_KHZ(ch, khz)  {               \
+                switch (ch)                                 \
+                {                                           \
+                    case 1:     khz = 2412000;   break;     \
+                    case 2:     khz = 2417000;   break;     \
+                    case 3:     khz = 2422000;   break;     \
+                    case 4:     khz = 2427000;   break;     \
+                    case 5:     khz = 2432000;   break;     \
+                    case 6:     khz = 2437000;   break;     \
+                    case 7:     khz = 2442000;   break;     \
+                    case 8:     khz = 2447000;   break;     \
+                    case 9:     khz = 2452000;   break;     \
+                    case 10:    khz = 2457000;   break;     \
+                    case 11:    khz = 2462000;   break;     \
+                    case 12:    khz = 2467000;   break;     \
+                    case 13:    khz = 2472000;   break;     \
+                    case 14:    khz = 2484000;   break;     \
+                    case 36:  /* UNII */  khz = 5180000;   break;     \
+                    case 40:  /* UNII */  khz = 5200000;   break;     \
+                    case 44:  /* UNII */  khz = 5220000;   break;     \
+                    case 48:  /* UNII */  khz = 5240000;   break;     \
+                    case 52:  /* UNII */  khz = 5260000;   break;     \
+                    case 56:  /* UNII */  khz = 5280000;   break;     \
+                    case 60:  /* UNII */  khz = 5300000;   break;     \
+                    case 64:  /* UNII */  khz = 5320000;   break;     \
+                    case 149: /* UNII */  khz = 5745000;   break;     \
+                    case 153: /* UNII */  khz = 5765000;   break;     \
+                    case 157: /* UNII */  khz = 5785000;   break;     \
+                    case 161: /* UNII */  khz = 5805000;   break;     \
+                    case 100: /* HiperLAN2 */  khz = 5500000;   break;     \
+                    case 104: /* HiperLAN2 */  khz = 5520000;   break;     \
+                    case 108: /* HiperLAN2 */  khz = 5540000;   break;     \
+                    case 112: /* HiperLAN2 */  khz = 5560000;   break;     \
+                    case 116: /* HiperLAN2 */  khz = 5580000;   break;     \
+                    case 120: /* HiperLAN2 */  khz = 5600000;   break;     \
+                    case 124: /* HiperLAN2 */  khz = 5620000;   break;     \
+                    case 128: /* HiperLAN2 */  khz = 5640000;   break;     \
+                    case 132: /* HiperLAN2 */  khz = 5660000;   break;     \
+                    case 136: /* HiperLAN2 */  khz = 5680000;   break;     \
+                    case 140: /* HiperLAN2 */  khz = 5700000;   break;     \
+                    case 34:  /* Japan MMAC */   khz = 5170000;   break;   \
+                    case 38:  /* Japan MMAC */   khz = 5190000;   break;   \
+                    case 42:  /* Japan MMAC */   khz = 5210000;   break;   \
+                    case 46:  /* Japan MMAC */   khz = 5230000;   break;   \
+                    default:    khz = 2412000;   break;     \
+                }                                           \
+            }
+
+#define 	MAP_KHZ_TO_CHANNEL_ID(khz, ch)	{				\
+				switch (khz)								\
+				{											\
+					case 2412000:	 ch = 1;	 break; 	\
+					case 2417000:	 ch = 2;	 break; 	\
+					case 2422000:	 ch = 3;	 break; 	\
+					case 2427000:	 ch = 4;	 break; 	\
+					case 2432000:	 ch = 5;	 break; 	\
+					case 2437000:	 ch = 6;	 break; 	\
+					case 2442000:	 ch = 7;	 break; 	\
+					case 2447000:	 ch = 8;	 break; 	\
+					case 2452000:	 ch = 9;	 break; 	\
+					case 2457000:	 ch = 10;	 break; 	\
+					case 2462000:	 ch = 11;	 break; 	\
+					case 2467000:	 ch = 12;	 break; 	\
+					case 2472000:	 ch = 13;	 break; 	\
+					case 2484000:	 ch = 14;	 break; 	\
+					case 5180000:	 ch = 36;  /* UNII */  break;	  \
+					case 5200000:	 ch = 40;  /* UNII */  break;	  \
+					case 5220000:	 ch = 44;  /* UNII */  break;	  \
+					case 5240000:	 ch = 48;  /* UNII */  break;	  \
+					case 5260000:	 ch = 52;  /* UNII */  break;	  \
+					case 5280000:	 ch = 56;  /* UNII */  break;	  \
+					case 5300000:	 ch = 60;  /* UNII */  break;	  \
+					case 5320000:	 ch = 64;  /* UNII */  break;	  \
+					case 5745000:	 ch = 149; /* UNII */  break;	  \
+					case 5765000:	 ch = 153; /* UNII */  break;	  \
+					case 5785000:	 ch = 157; /* UNII */  break;	  \
+					case 5805000:	 ch = 161; /* UNII */  break;	  \
+					case 5500000:	 ch = 100; /* HiperLAN2 */	break;	   \
+					case 5520000:	 ch = 104; /* HiperLAN2 */	break;	   \
+					case 5540000:	 ch = 108; /* HiperLAN2 */	break;	   \
+					case 5560000:	 ch = 112; /* HiperLAN2 */	break;	   \
+					case 5580000:	 ch = 116; /* HiperLAN2 */	break;	   \
+					case 5600000:	 ch = 120; /* HiperLAN2 */	break;	   \
+					case 5620000:	 ch = 124; /* HiperLAN2 */	break;	   \
+					case 5640000:	 ch = 128; /* HiperLAN2 */	break;	   \
+					case 5660000:	 ch = 132; /* HiperLAN2 */	break;	   \
+					case 5680000:	 ch = 136; /* HiperLAN2 */	break;	   \
+					case 5700000:	 ch = 140; /* HiperLAN2 */	break;	   \
+					case 5170000:	 ch = 34;  /* Japan MMAC */   break;   \
+					case 5190000:	 ch = 38;  /* Japan MMAC */   break;   \
+					case 5210000:	 ch = 42;  /* Japan MMAC */   break;   \
+					case 5230000:	 ch = 46;  /* Japan MMAC */   break;   \
+					default:		 ch = 1;	 break; 	\
+				}											\
+			}
+
+
+#if 0
+
+static struct {
+	char *name;
+	int (*set_proc)(PRT2570ADAPTER pAdapter, PUCHAR arg);
+} *PRTMP_PRIVATE_SET_PROC, RTMP_PRIVATE_SUPPORT_PROC[] = {
+	{"CountryRegion", Set_CountryRegion_Proc },
+	{"SSID", Set_SSID_Proc},
+	{"WirelessMode", Set_WirelessMode_Proc},
+	{"TxRate", Set_TxRate_Proc},
+	{"Channel", Set_Channel_Proc},
+	{"BGProtection", Set_BGProtection_Proc},
+	{"TxPreamble", Set_TxPreamble_Proc},
+	{"RTSThreshold", Set_RTSThreshold_Proc},
+	{"FragThreshold", Set_FragThreshold_Proc},
+	{"TxBurst", Set_TxBurst_Proc},
+	{"TurboRate", Set_TurboRate_Proc},
+	{"AuthMode", Set_AuthMode_Proc},
+	{"EncrypType", Set_EncrypType_Proc},
+	{"DefaultKeyID", Set_DefaultKeyID_Proc},
+	{"Key1", Set_Key1_Proc},
+	{"Key2", Set_Key2_Proc},
+	{"Key3", Set_Key3_Proc},
+	{"Key4", Set_Key4_Proc},
+	{"WPAPSK", Set_WPAPSK_Proc},
+	{"bb", Set_R17_Proc},
+	{"rr", Read_R17_Proc},
+	{NULL,}
+};
+
+#endif
+
+int
+rtusb_ioctl_giwname(struct net_device *dev,
+		   struct iw_request_info *info,
+		   char *name, char *extra)
+{
+	strncpy(name, "RT2500USB WLAN", IFNAMSIZ);
+	return 0;
+}
+
+int rtusb_ioctl_siwfreq(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_freq *freq, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	int 	chan = -1;
+
+	if (freq->e > 1)
+		return -EINVAL;
+
+	if((freq->e == 0) && (freq->m <= 1000))
+		chan = freq->m;	// Setting by channel number 
+	else
+		MAP_KHZ_TO_CHANNEL_ID( (freq->m /100) , chan); // Setting by frequency - search the table , like 2.412G, 2.422G, 
+	pAdapter->PortCfg.IbssConfig.Channel = chan;
+	DBGPRINT(RT_DEBUG_ERROR, "<==SIOCSIWFREQ[cmd=0x%x] (Channel=%d)\n", SIOCSIWFREQ, pAdapter->PortCfg.IbssConfig.Channel);
+
+	// CD: setting the channel in Monitor mode is unrelated to RFMONTx
+
+	if (pAdapter->PortCfg.BssType == BSS_MONITOR)
+	{
+		pAdapter->PortCfg.Channel = pAdapter->PortCfg.IbssConfig.Channel;
+		AsicSwitchChannel(pAdapter, pAdapter->PortCfg.Channel);
+		AsicLockChannel(pAdapter, pAdapter->PortCfg.Channel);
+	}
+
+	return 0;
+}
+int rtusb_ioctl_giwfreq(struct net_device *dev,
+		   struct iw_request_info *info,
+		   struct iw_freq *freq, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	DBGPRINT(RT_DEBUG_TRACE,"==>IOCTL::rtusb_ioctl_giwfreq  %d\n",pAdapter->PortCfg.Channel);
+	
+	if (INFRA_ON(pAdapter) || ADHOC_ON(pAdapter))
+	{	 
+	    MAP_CHANNEL_ID_TO_KHZ(pAdapter->PortCfg.Channel, freq->m);
+	}
+	else
+	{
+		 MAP_CHANNEL_ID_TO_KHZ(pAdapter->PortCfg.IbssConfig.Channel, freq->m );
+	}
+	
+	freq->e = 3;
+	freq->i = 0;
+	return 0;
+}
+
+int rtusb_ioctl_siwmode(struct net_device *dev,
+		   struct iw_request_info *info,
+		   __u32 *mode, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+
+	switch (*mode)
+	{
+		case IW_MODE_ADHOC:
+			if (pAdapter->PortCfg.BssType != BSS_INDEP)
+			{
+				// Config has changed
+				if INFRA_ON(pAdapter)
+				{
+					RTUSBEnqueueInternalCmd(pAdapter, RT_OID_LINK_DOWN);
+					// First cancel linkdown timer
+					DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_DISCONNECT Event BB!\n");							
+				}
+				pAdapter->bConfigChanged = TRUE;
+			}
+			pAdapter->net->type = 1;
+			pAdapter->PortCfg.BssType = BSS_INDEP;
+			DBGPRINT(RT_DEBUG_TRACE, "ioctl::SIOCSIWMODE (AD-HOC)\n");
+			break;
+		case IW_MODE_INFRA:
+			if (pAdapter->PortCfg.BssType != BSS_INFRA)
+			{
+				// Config has changed
+				if (pAdapter->PortCfg.BssType != BSS_INFRA)
+				{
+					// Config has changed
+					// pAdapter->bConfigChanged = TRUE;
+					if ADHOC_ON(pAdapter)
+						RTUSBEnqueueInternalCmd(pAdapter, RT_OID_LINK_DOWN);
+				}
+				pAdapter->bConfigChanged = TRUE;
+			}
+		        pAdapter->net->type = 1;
+			pAdapter->PortCfg.BssType = BSS_INFRA;
+			DBGPRINT(RT_DEBUG_TRACE, "ioctl::SIOCSIWMODE (INFRA)\n");
+			break;
+		case IW_MODE_MONITOR:
+			pAdapter->PortCfg.BssType=BSS_MONITOR;
+			RTUSBEnqueueInternalCmd(pAdapter, RT_OID_LINK_DOWN);
+			pAdapter->bConfigChanged = TRUE;
+			if (pAdapter->PortCfg.MallowRFMONTx == TRUE) {
+				if (pAdapter->PortCfg.ForcePrismHeader == 1)
+					pAdapter->net->type = 802; // ARPHRD_IEEE80211_PRISM
+				else
+					pAdapter->net->type = 801; // ARPHRD_IEEE80211
+			} else {
+				if (pAdapter->PortCfg.ForcePrismHeader == 2)
+					pAdapter->net->type = 801; // ARPHRD_IEEE80211
+				else
+					pAdapter->net->type = 802; // ARPHRD_IEEE80211_PRISM
+			}
+			RTUSBWriteMACRegister(pAdapter, TXRX_CSR2, 0x4e);
+			break;	
+		default:
+			DBGPRINT(RT_DEBUG_TRACE, "ioctl::SIOCSIWMODE (unknown)\n");
+			return -EINVAL;
+	}
+	
+	// Reset Ralink supplicant to not use, it will be set to start when UI set PMK key
+	pAdapter->PortCfg.WpaState = SS_NOTUSE;
+
+	return 0;
+}
+
+int rtusb_ioctl_giwmode(struct net_device *dev,
+		   struct iw_request_info *info,
+		   __u32 *mode, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	if (pAdapter->PortCfg.BssType == BSS_MONITOR)
+		*mode = IW_MODE_MONITOR;
+	else
+	{
+		if (ADHOC_ON(pAdapter))
+			*mode = IW_MODE_ADHOC;
+		else
+			*mode = IW_MODE_INFRA;
+	}
+	DBGPRINT(RT_DEBUG_TEMP,"--->rtusb_ioctl_giwmode\n");		
+	return 0;
+}
+
+int rtusb_ioctl_siwsens(struct net_device *dev,
+		   struct iw_request_info *info,
+		   char *name, char *extra)
+{
+	return 0;
+}
+
+int rtusb_ioctl_giwsens(struct net_device *dev,
+		   struct iw_request_info *info,
+		   char *name, char *extra)
+{
+	return 0;
+}
+/*
+This is required for LinEX2004/kernel2.6.7 to provide iwlist scanning function
+*/
+int rtusb_ioctl_giwrange(struct net_device *dev,
+		   struct iw_request_info *info,
+		   struct iw_point *data, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	struct iw_range *range = (struct iw_range *) extra;
+	u16 val;
+	int i;
+	ULONG	m;
+	
+	data->length = sizeof(struct iw_range);
+	memset(range, 0, sizeof(struct iw_range));
+
+	range->txpower_capa = IW_TXPOW_DBM;
+
+	if (INFRA_ON(pAdapter)||ADHOC_ON(pAdapter))
+	{
+		range->min_pmp = 1 * 1024;
+		range->max_pmp = 65535 * 1024;
+		range->min_pmt = 1 * 1024;
+		range->max_pmt = 1000 * 1024;
+		range->pmp_flags = IW_POWER_PERIOD;
+		range->pmt_flags = IW_POWER_TIMEOUT;
+		range->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT |
+			IW_POWER_UNICAST_R | IW_POWER_ALL_R;
+	}
+	
+
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 16;
+
+	range->retry_capa = IW_RETRY_LIMIT;
+	range->retry_flags = IW_RETRY_LIMIT;
+	range->min_retry = 0;
+	range->max_retry = 255;
+
+	range->num_channels =  pAdapter->PortCfg.ChannelListNum;
+
+	val = 0;
+	for (i = 0; i < pAdapter->PortCfg.SupportedRatesLen; i++) {
+			range->freq[val].i =(pAdapter->PortCfg.SupportedRates[i] & 0x7f)/2;
+			range->freq[val].m = (pAdapter->PortCfg.SupportedRates[i] & 0x7f)/2 * 100000;
+			range->freq[val].e = 1;
+			val++;
+		if (val == IW_MAX_FREQUENCIES)
+			break;
+	}
+	
+	range->num_frequency = 0;
+	for (i = 1; i <= range->num_channels; i++)
+	{
+		range->freq[range->num_frequency].i = i;
+		MAP_CHANNEL_ID_TO_KHZ(i, m);
+
+		range->freq[range->num_frequency].m = m;
+		range->freq[range->num_frequency].e = 3;
+		if (++range->num_frequency == IW_MAX_FREQUENCIES)
+		break;
+	}
+
+	range->max_qual.qual = 100; /* percentage */ 
+	range->max_qual.level = 0; /* dB */
+	range->max_qual.noise = 0; /* dB */
+
+	/* What would be suitable values for "average/typical" qual? */
+	range->avg_qual.qual = 20;
+	range->avg_qual.level = -60;
+	range->avg_qual.noise = -95;
+	range->sensitivity = 3;
+
+	range->max_encoding_tokens = NR_WEP_KEYS;
+	range->num_encoding_sizes = 2;
+	range->encoding_size[0] = 5;
+	range->encoding_size[1] = 13;
+
+#if 0
+	over2 = 0;
+	len = prism2_get_datarates(dev, rates);
+	range->num_bitrates = 0;
+	for (i = 0; i < len; i++) {
+		if (range->num_bitrates < IW_MAX_BITRATES) {
+			range->bitrate[range->num_bitrates] =
+				rates[i] * 500000;
+			range->num_bitrates++;
+		}
+		if (rates[i] == 0x0b || rates[i] == 0x16)
+			over2 = 1;
+	}
+	/* estimated maximum TCP throughput values (bps) */
+	range->throughput = over2 ? 5500000 : 1500000;
+    #endif
+	range->min_rts = 0;
+	range->max_rts = 2347;
+	range->min_frag = 256;
+	range->max_frag = 2346;
+
+	return 0;
+}
+
+int rtusb_ioctl_giwap(struct net_device *dev,
+		      struct iw_request_info *info,
+		      struct sockaddr *ap_addr, char *extra)
+{
+
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+
+	if (INFRA_ON(pAdapter) || ADHOC_ON(pAdapter))
+	{
+		ap_addr->sa_family = ARPHRD_ETHER;
+		memcpy(ap_addr->sa_data, &pAdapter->PortCfg.Bssid, ETH_ALEN);
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "ioctl::SIOCGIWAP(=EMPTY)\n");
+		return -ENOTCONN;
+	}
+
+	return 0;
+}
+
+/*
+ * Units are in db above the noise floor. That means the
+ * rssi values reported in the tx/rx descriptors in the
+ * driver are the SNR expressed in db.
+ *
+ * If you assume that the noise floor is -95, which is an
+ * excellent assumption 99.5 % of the time, then you can
+ * derive the absolute signal level (i.e. -95 + rssi). 
+ * There are some other slight factors to take into account
+ * depending on whether the rssi measurement is from 11b,
+ * 11g, or 11a.   These differences are at most 2db and
+ * can be documented.
+ *
+ * NB: various calculations are based on the orinoco/wavelan
+ *     drivers for compatibility
+ */
+static void
+set_quality(struct iw_quality *iq, u_int rssi)
+{
+	iq->qual = rssi;
+	/* NB: max is 94 because noise is hardcoded to 161 */
+	if (iq->qual > 94)
+		iq->qual = 94;
+
+	iq->noise = RSSI_TO_DBM_OFFSET;		/* -95dBm */
+	iq->level = iq->noise + iq->qual;
+	iq->updated = 7;
+}
+int rtusb_ioctl_iwaplist(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *data, char *extra)
+{
+
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	struct sockaddr addr[IW_MAX_AP];
+	struct iw_quality qual[IW_MAX_AP];
+	int i;
+	
+	for (i = 0; i <IW_MAX_AP ; i++)
+	{
+		if (i >=  pAdapter->PortCfg.BssTab.BssNr)
+			break;
+		addr[i].sa_family = ARPHRD_ETHER;
+			memcpy(addr[i].sa_data, &pAdapter->PortCfg.BssTab.BssEntry[i].Bssid, MAC_ADDR_LEN);
+		set_quality(&qual[i], pAdapter->PortCfg.BssTab.BssEntry[i].Rssi);
+	}
+	data->length = i;
+	memcpy(extra, &addr, i*sizeof(addr[0]));
+	data->flags = 1;		/* signal quality present (sort of) */
+	memcpy(extra + i*sizeof(addr[0]), &qual, i*sizeof(qual[i]));
+
+	return 0;
+}
+#ifdef SIOCGIWSCAN
+
+int rtusb_ioctl_siwscan(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *data, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	int Status = STATUS_SUCCESS;
+
+    	do{
+		if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+			return 0;
+		if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RADIO_OFF))
+			return 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+		if ((pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE) && (pAdapter->MLMEThr_pid > 0))
+#else
+		if ((pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE) && (pAdapter->MLMEThr_active))
+#endif
+		{
+			DBGPRINT(RT_DEBUG_ERROR, "!!! MLME busy, reset MLME state machine !!!\n");
+			MlmeRestartStateMachine(pAdapter);
+			MlmePostRestartStateMachine(pAdapter);
+			return (RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_BSSID_LIST_SCAN, TRUE, NULL, 0));
+			
+		}
+		 
+		pAdapter->Mlme.CntlAux.CurrReqIsFromNdis = FALSE;
+		// Reset Missed scan number
+		pAdapter->PortCfg.IgnoredScanNumber = 0;
+
+		MlmeEnqueue(pAdapter, 
+				MLME_CNTL_STATE_MACHINE, 
+				OID_802_11_BSSID_LIST_SCAN, 
+				0, 
+				NULL);
+		RTUSBUp(pAdapter, (&(pAdapter->mlme_semaphore)));
+
+		Status = NDIS_STATUS_SUCCESS;
+	}while(0);
+	return 0;
+}
+int
+rtusb_ioctl_giwscan(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_point *data, char *extra)
+{
+
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	int i=2, j;
+	char *current_ev = extra;
+	char *end_buf = extra + IW_SCAN_MAX_DATA;
+	char *current_val;
+	struct iw_event iwe;
+
+        if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)){
+                /*
+                 * Still scanning, indicate the caller should try again.
+                 */
+                return -EAGAIN;
+        }
+
+	for (i = 0; i < pAdapter->PortCfg.BssTab.BssNr; i++) 
+	{
+		if (current_ev >= end_buf)
+			break;
+
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = SIOCGIWAP;
+		iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+				memcpy(iwe.u.ap_addr.sa_data, &pAdapter->PortCfg.BssTab.BssEntry[i].Bssid, ETH_ALEN);
+			current_ev = iwe_stream_add_event(current_ev,end_buf, &iwe, IW_EV_ADDR_LEN);
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = SIOCGIWMODE;
+		if (pAdapter->PortCfg.BssTab.BssEntry[i].BssType == Ndis802_11IBSS)
+		{
+			iwe.u.mode = IW_MODE_ADHOC;
+		}
+		else if (pAdapter->PortCfg.BssTab.BssEntry[i].BssType == Ndis802_11Infrastructure)
+		{
+			iwe.u.mode = IW_MODE_INFRA;
+		}
+		else
+		{
+			iwe.u.mode = IW_MODE_AUTO;
+		}
+
+		iwe.len = IW_EV_UINT_LEN;
+		current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe,  IW_EV_UINT_LEN);
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = SIOCGIWESSID;
+		iwe.u.data.length = pAdapter->PortCfg.BssTab.BssEntry[i].SsidLen;
+		iwe.u.data.flags = 1;
+		current_ev = iwe_stream_add_point(current_ev,end_buf, &iwe, pAdapter->PortCfg.BssTab.BssEntry[i].Ssid);
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = SIOCGIWENCODE;
+		if (CAP_IS_PRIVACY_ON (pAdapter->PortCfg.BssTab.BssEntry[i].CapabilityInfo ))
+			iwe.u.data.flags =IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+		else
+			iwe.u.data.flags = IW_ENCODE_DISABLED;
+		current_ev = iwe_stream_add_point(current_ev, end_buf,&iwe,  pAdapter->PortCfg.BssTab.BssEntry[i].Ssid);
+
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = SIOCGIWRATE;
+		current_val = current_ev + IW_EV_LCP_LEN;
+		//for (j = 0; j < pAdapter->PortCfg.BssTab.BssEntry[i].RatesLen;j++)
+		for (j = 0; j < 1;j++)
+		{
+			iwe.u.bitrate.value = RateIdToMbps[pAdapter->PortCfg.BssTab.BssEntry[i].Rates[i]/2] * 1000000;
+			iwe.u.bitrate.disabled = 0;
+			current_val = iwe_stream_add_value(current_ev,
+				current_val, end_buf, &iwe,
+				IW_EV_PARAM_LEN);
+		}
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = SIOCGIWFREQ;
+		if (INFRA_ON(pAdapter) || ADHOC_ON(pAdapter))
+			iwe.u.freq.m = pAdapter->PortCfg.BssTab.BssEntry[i].Channel;
+		else
+			iwe.u.freq.m = pAdapter->PortCfg.BssTab.BssEntry[i].Channel;
+		iwe.u.freq.e = 0;
+		iwe.u.freq.i = 0;
+		current_ev = iwe_stream_add_event(current_ev,end_buf, &iwe, IW_EV_FREQ_LEN);
+		//================================
+		memset(&iwe, 0, sizeof(iwe));
+
+	}
+	data->length = current_ev - extra;
+	DBGPRINT(RT_DEBUG_TRACE,"rtusb_ioctl_giwscan. %d BSS returned\n",pAdapter->PortCfg.BssTab.BssNr);						
+	return 0;
+}
+#endif
+int rtusb_ioctl_siwessid(struct net_device *dev,
+			 struct iw_request_info *info,
+			 struct iw_point *data, char *essid)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	NDIS_802_11_SSID					Ssid, *pSsid=NULL;
+
+	memset(&Ssid, 0x00, sizeof(NDIS_802_11_SSID));
+	if (data->flags)
+	{
+		if (data->length > IW_ESSID_MAX_SIZE)
+		{
+			return -E2BIG;
+		}
+
+		memcpy(Ssid.Ssid, essid, (data->length - 1));
+		Ssid.SsidLength = data->length - 1;	//minus null character.
+		memcpy(pAdapter->PortCfg.Ssid, essid, (data->length - 1));
+		pAdapter->PortCfg.SsidLen = data->length - 1;
+	}
+	else
+		Ssid.SsidLength = 0;  // ANY ssid 
+
+	pSsid = &Ssid;
+
+	 // tell CNTL state machine to call NdisMSetInformationComplete() after completing
+	// this request, because this request is initiated by NDIS.
+	pAdapter->Mlme.CntlAux.CurrReqIsFromNdis = FALSE; 
+	DBGPRINT(RT_DEBUG_TRACE,"--->Ssid.SsidLength = %d, %s\n",Ssid.SsidLength, Ssid.Ssid);		
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if (pAdapter->MLMEThr_pid > 0)
+#else
+	if (!IS_ERR(pAdapter->MLMEThr))
+#endif
+		MlmeEnqueue(pAdapter, 
+				MLME_CNTL_STATE_MACHINE, 
+				OID_802_11_SSID,
+				sizeof(NDIS_802_11_SSID),
+				(VOID *)pSsid
+				);
+
+	RTUSBUp(pAdapter, (&(pAdapter->mlme_semaphore)));
+	return 0;
+}
+
+int rtusb_ioctl_giwessid(struct net_device *dev,
+			 struct iw_request_info *info,
+			 struct iw_point *data, char *essid)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+
+	data->flags = 1;		/* active */
+	DBGPRINT(RT_DEBUG_TRACE,"MediaState is connected\n");
+	data->length = pAdapter->PortCfg.SsidLen;
+	memcpy(essid, pAdapter->PortCfg.Ssid, pAdapter->PortCfg.SsidLen);
+	pAdapter->PortCfg.Ssid[pAdapter->PortCfg.SsidLen] = '\0';
+	DBGPRINT(RT_DEBUG_TRACE,"pAdapter->PortCfg.Ssid=%s , Ssidlen = %d\n",pAdapter->PortCfg.Ssid, pAdapter->PortCfg.SsidLen);
+
+	DBGPRINT(RT_DEBUG_TRACE, "<==rtusb_ioctl_giwessid:: (Len=%d, ssid=%s...)\n", pAdapter->PortCfg.SsidLen, pAdapter->PortCfg.Ssid);
+
+	return 0;
+
+}
+
+int rtusb_ioctl_siwnickn(struct net_device *dev,
+			 struct iw_request_info *info,
+			 struct iw_point *data, char *nickname)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+
+	if (data->length > IEEE80211_NWID_LEN)
+		return -EINVAL;
+
+	memset(pAdapter->nickn, 0, IEEE80211_NWID_LEN);
+	memcpy(pAdapter->nickn, nickname, data->length);
+	pAdapter->nicknamelen = data->length;
+
+
+	return 0;
+}
+
+int rtusb_ioctl_giwnickn(struct net_device *dev,
+			 struct iw_request_info *info,
+			 struct iw_point *data, char *nickname)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+
+	if (data->length > pAdapter->nicknamelen + 1)
+		data->length = pAdapter->nicknamelen + 1;
+	if (data->length > 0) {
+		memcpy(nickname, pAdapter->nickn, data->length-1);
+		nickname[data->length-1] = '\0';
+	}
+	return 0;
+}
+
+
+int rtusb_ioctl_siwrts(struct net_device *dev,
+		       struct iw_request_info *info,
+		       struct iw_param *rts, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	u16 val;
+
+	if (rts->disabled)
+		val = MAX_RTS_THRESHOLD;
+	else if (1 > rts->value || rts->value > MAX_RTS_THRESHOLD)
+		return -EINVAL;
+	else
+		val = rts->value;
+	
+	if (val != pAdapter->PortCfg.RtsThreshold)
+		pAdapter->PortCfg.RtsThreshold = val;
+
+	return 0;
+}
+
+int rtusb_ioctl_giwrts(struct net_device *dev,
+		       struct iw_request_info *info,
+		       struct iw_param *rts, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+
+	rts->value = pAdapter->PortCfg.RtsThreshold;
+	rts->disabled = (rts->value == MAX_RTS_THRESHOLD);
+	rts->fixed = 1;
+
+	return 0;
+}
+
+
+int rtusb_ioctl_siwfrag(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_param *rts, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	u16 val;
+
+	if (rts->disabled)
+		val = MAX_FRAG_THRESHOLD;
+	else if (rts->value < 256 || rts->value > MAX_FRAG_THRESHOLD)
+		return -EINVAL;
+	else
+		val = __cpu_to_le16(rts->value & ~0x1); /* even numbers only */
+
+	pAdapter->PortCfg.FragmentThreshold = val;
+	return 0;
+}
+
+int rtusb_ioctl_giwfrag(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_param *rts, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+
+	rts->value = pAdapter->PortCfg.FragmentThreshold;
+	rts->disabled = (rts->value == 2346);
+	rts->fixed = 1;
+
+	return 0;
+}
+
+int rtusb_ioctl_siwencode(struct net_device *dev,
+			  struct iw_request_info *info,
+			  struct iw_point *erq, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	NDIS_802_11_WEP	WepKey;
+	int 	index, len;
+	CHAR	kid = 0;
+	memset(&WepKey, 0, sizeof(NDIS_802_11_WEP));
+
+	if (erq->flags & IW_ENCODE_DISABLED)
+	{
+		pAdapter->PortCfg.PairCipher = Ndis802_11WEPDisabled;
+		pAdapter->PortCfg.GroupCipher = Ndis802_11WEPDisabled;
+		pAdapter->PortCfg.WepStatus = Ndis802_11WEPDisabled;
+	}
+	else
+	{
+		pAdapter->PortCfg.PairCipher = Ndis802_11WEPEnabled;
+		pAdapter->PortCfg.GroupCipher = Ndis802_11WEPEnabled;
+		pAdapter->PortCfg.WepStatus = Ndis802_11WEPEnabled;
+	}
+
+	if (erq->flags & IW_ENCODE_RESTRICTED)
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeShared;
+	else if(erq->flags & IW_ENCODE_OPEN)
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+
+	if(pAdapter->PortCfg.WepStatus == Ndis802_11WEPDisabled)
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+    
+	if ((erq->flags & IW_ENCODE_DISABLED) == 0 && erq->pointer) 
+	{
+		/* Enable crypto. */
+		if (erq->length > IFNAMSIZ)
+			return -EINVAL;
+
+		/* Old solution to take  default key  */
+		index = (erq->flags & IW_ENCODE_INDEX) ;
+		if((index < 0) || (index > NR_WEP_KEYS))
+			return -EINVAL;     
+			DBGPRINT(RT_DEBUG_TRACE," erq->flags = %x\n",erq->flags);
+		
+		if (index != 0)
+		{
+			pAdapter->PortCfg.DefaultKeyId = index -1;
+		}
+		
+		if ((erq->length == 1) && (index == 0))
+		{
+			/* New solution to take  default key  when old way not work, not change KeyMaterial*/
+			memcpy(&kid, erq->pointer, 1 );
+			if((index < 0) || (index >= NR_WEP_KEYS))
+				return -EINVAL;     
+			//WepKey.KeyIndex = 0x80000000 + index;
+			DBGPRINT(RT_DEBUG_TRACE,"kid = %d , erq->length = %d\n",kid, erq->length);
+			if (kid > 0)
+				pAdapter->PortCfg.DefaultKeyId = kid-1;
+			else 
+				pAdapter->PortCfg.DefaultKeyId = 0;
+		}
+		else
+		{
+			DBGPRINT(RT_DEBUG_TRACE,"DefaultKeyId = %d , erq->length = %d, flags 0x%x\n",pAdapter->PortCfg.DefaultKeyId, erq->length,erq->flags);
+			len = erq->length;
+			if(len > WEP_LARGE_KEY_LEN)
+				len = WEP_LARGE_KEY_LEN;
+			// If this instruction default key
+			memset(pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].Key,  0, MAX_LEN_OF_KEY);
+			memcpy(pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].Key, erq->pointer, len);
+			memcpy(WepKey.KeyMaterial, erq->pointer, len);
+			WepKey.KeyIndex = 0x80000000 + pAdapter->PortCfg.DefaultKeyId; 
+			WepKey.KeyLength = len;
+			pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen =(UCHAR) (len <= WEP_SMALL_KEY_LEN ? WEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN);
+			// need to enqueue cmd to thread
+			RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_WEP, TRUE, &WepKey, sizeof(WepKey));
+		}
+		
+	}
+	DBGPRINT(RT_DEBUG_TRACE, "==>AuthMode=%x\n",pAdapter->PortCfg.AuthMode);
+	DBGPRINT(RT_DEBUG_TRACE, "==>DefaultKeyId=%x, KeyLen = %d\n",pAdapter->PortCfg.DefaultKeyId , pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen);
+	DBGPRINT(RT_DEBUG_TRACE, "==>WepStatus=%x\n",pAdapter->PortCfg.WepStatus);
+	return 0;
+}
+
+int
+rtusb_ioctl_giwencode(struct net_device *dev,
+			  struct iw_request_info *info,
+			  struct iw_point *erq, char *key)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	int kid;
+	
+	kid = erq->flags & IW_ENCODE_INDEX;
+	DBGPRINT(RT_DEBUG_TRACE, "===>rtusb_ioctl_giwencode %d\n", erq->flags & IW_ENCODE_INDEX);
+
+	if (pAdapter->PortCfg.WepStatus == Ndis802_11WEPDisabled)
+	{
+		erq->length = 0;
+		erq->flags = IW_ENCODE_DISABLED;
+		return 0;
+	}
+
+	erq->flags = IW_ENCODE_ENABLED;
+
+	if (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeShared)
+		erq->flags |= IW_ENCODE_RESTRICTED;
+	else
+		erq->flags |= IW_ENCODE_OPEN;
+
+	if ((kid > 0) && (kid <=4))
+	{
+		// copy wep key
+		erq->flags |= kid & IW_ENCODE_INDEX;			/* NB: base 1 */
+		if (erq->length > pAdapter->PortCfg.SharedKey[kid-1].KeyLen)
+			erq->length = pAdapter->PortCfg.SharedKey[kid-1].KeyLen;
+		memcpy(key, pAdapter->PortCfg.SharedKey[kid-1].Key, erq->length);
+	}
+	else if (kid == 0)
+	{
+		// copy default key ID
+		erq->flags |= (pAdapter->PortCfg.DefaultKeyId + 1) & IW_ENCODE_INDEX;		/* NB: base 1 */
+		erq->length = pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen;
+		memcpy(key, pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].Key, erq->length);
+	}
+		
+	return 0;
+
+}
+
+static int
+rtusb_ioctl_setauth(struct net_device *dev, struct iw_request_info *info,
+			 void *w, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	int param = *(int *) extra;
+  
+	switch(param)
+	{
+		case 1:
+			pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+			DBGPRINT(RT_DEBUG_TRACE, "===>rtusb_ioctl_setauth RTPRIV802_11AuthModeOpen\n");
+			break;
+		case 2:
+			pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeShared;
+			DBGPRINT(RT_DEBUG_TRACE, "===>rtusb_ioctl_setauth RTPRIV802_11AuthModeShared\n");
+			break;
+		case 3:
+			pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeWPAPSK;
+			pAdapter->PortCfg.WpaState = SS_START;
+			DBGPRINT(RT_DEBUG_TRACE, "===>rtusb_ioctl_setauth RTPRIV802_11AuthModeWPAPSK\n");
+			break;
+		case 4:
+			pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeWPANone;
+			DBGPRINT(RT_DEBUG_TRACE, "===>rtusb_ioctl_setauth Ndis802_11AuthModeWPANone\n");
+			break;
+		default:
+			return -EOPNOTSUPP;
+
+	}
+
+
+	pAdapter->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+
+	return 0;
+}
+#if 0
+static int rtusb_ioctl_setkeyid(struct net_device *dev, struct iw_request_info *info,
+			 void *w, char *extra)
+{
+
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+  	int param = *(int *)extra;
+	USHORT	Value;
+
+	switch(param)
+	{
+		case 1:
+			pAdapter->PortCfg.DefaultKeyId = 0;
+			break;
+		case 2:
+			pAdapter->PortCfg.DefaultKeyId = 1;
+			break;
+		case 3:
+			pAdapter->PortCfg.DefaultKeyId = 2;
+			break;
+		case 4:
+			pAdapter->PortCfg.DefaultKeyId = 3;
+			break;
+		default:
+			return -EOPNOTSUPP;
+
+	}
+
+
+	if (pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen == 5)
+		pAdapter->PortCfg.CipherAlg = CIPHER_WEP64;
+	else
+		pAdapter->PortCfg.CipherAlg = CIPHER_WEP128;
+					
+	RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &Value);
+	Value &= 0xfe00;
+	Value |= ((LENGTH_802_11 << 3) | (pAdapter->PortCfg.CipherAlg));
+	RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, Value);
+        
+	DBGPRINT(RT_DEBUG_TRACE, "===>DefaultKeyId = [%d]\n",pAdapter->PortCfg.DefaultKeyId);
+
+	return 0;
+}
+#endif
+static int
+rtusb_ioctl_setencryp(struct net_device *dev, struct iw_request_info *info,
+			 void *w, char *extra)
+{
+
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	int param = *(int *)extra;
+	NDIS_802_11_WEP_STATUS				WepStatus;//set by OID_802_11_WEP_STATUS
+	DBGPRINT(RT_DEBUG_TRACE, "===>setencryp\n");
+	DBGPRINT(RT_DEBUG_TRACE, "===>info->cmd 0x%x   \n",(info->cmd));
+	DBGPRINT(RT_DEBUG_TRACE, "===>info->flags 0x%x  , param %x , extra %x\n",(info->flags), param,*extra);
+	switch(param)
+	{
+		case 1:
+			pAdapter->PortCfg.WepStatus= Ndis802_11WEPDisabled;
+			pAdapter->PortCfg.PairCipher= Ndis802_11WEPDisabled;
+			pAdapter->PortCfg.GroupCipher= Ndis802_11WEPDisabled;
+			pAdapter->PortCfg.CipherAlg = CIPHER_NONE;
+			WepStatus = Ndis802_11WEPDisabled;
+			break;
+		case 2:
+			pAdapter->PortCfg.WepStatus= Ndis802_11Encryption1Enabled;
+			pAdapter->PortCfg.PairCipher= Ndis802_11Encryption1Enabled;
+			pAdapter->PortCfg.GroupCipher= Ndis802_11Encryption1Enabled;
+			WepStatus = Ndis802_11Encryption1Enabled;
+			break;
+		case 3:
+			pAdapter->PortCfg.WepStatus= Ndis802_11Encryption2Enabled;
+			pAdapter->PortCfg.PairCipher= Ndis802_11Encryption2Enabled;
+			pAdapter->PortCfg.GroupCipher= Ndis802_11Encryption2Enabled;
+			pAdapter->PortCfg.CipherAlg = CIPHER_TKIP;
+			WepStatus = Ndis802_11Encryption2Enabled;
+			break;
+		default:
+			return -EOPNOTSUPP;
+
+	}
+	RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_WEP_STATUS, TRUE, &WepStatus, sizeof(WepStatus));
+
+	return 0;
+}
+static int
+rtusb_ioctl_setwpapsk(struct net_device *dev, struct iw_request_info *info,
+			 void *w, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	NDIS_802_11_KEY                    Key;
+	// rtusb_ioctl_setwpapsk accept > 16 chars, so data is passed through w instead of extra.
+	struct iw_point *iwp = (struct iw_point *)w;
+	UCHAR                               keyMaterial[80];
+	UCHAR                               keyMaterial2[80];
+	INT			Status = NDIS_STATUS_SUCCESS;
+	int	i;
+
+	DBGPRINT(RT_DEBUG_TRACE, "===>\n");
+	DBGPRINT(RT_DEBUG_TRACE, "===>info->cmd 0x%x   \n",(info->cmd));
+	DBGPRINT(RT_DEBUG_TRACE, "===>info->flags 0x%x   \n",(info->flags));
+	memset(Key.KeyMaterial, 0, 64);
+	memset(keyMaterial2, 0, 80);
+	memcpy(Key.BSSID, pAdapter->PortCfg.Bssid.Octet, 6);
+	//memcpy(&Key.KeyRSC, pMsg3->KeyDesc.KeyRsc, LEN_KEY_DESC_RSC);
+	if (iwp->length < 64)
+	{
+		if(copy_from_user(&keyMaterial2, iwp->pointer, iwp->length))
+			Status = -EINVAL;
+
+		PasswordHash(keyMaterial2, pAdapter->Mlme.CntlAux.Ssid, pAdapter->Mlme.CntlAux.SsidLen, keyMaterial);
+
+		Key.Length    = sizeof(Key);
+		Key.KeyIndex  = 0x80000000;           
+		Key.KeyLength = 32;
+		DBGPRINT_RAW(RT_DEBUG_TEMP,"pAdapter->Mlme.CntlAux.Ssid: ");
+		for(i = 0; i < pAdapter->Mlme.CntlAux.SsidLen; i++)
+			DBGPRINT_RAW(RT_DEBUG_TEMP,"%c ", pAdapter->Mlme.CntlAux.Ssid[i]);
+		DBGPRINT_RAW(RT_DEBUG_TEMP,"\n");
+
+		memcpy(pAdapter->PortCfg.PskKey.Key, keyMaterial, 32);
+		memcpy(Key.KeyMaterial, keyMaterial, 32);
+		DBGPRINT_RAW(RT_DEBUG_TEMP,"WPAPSK Key : ");
+		for(i = 0; i < 32; i++)
+			DBGPRINT_RAW(RT_DEBUG_TEMP,"%x ", Key.KeyMaterial[i]);
+		DBGPRINT_RAW(RT_DEBUG_TEMP,"\n");
+
+	}
+	else if (iwp->length == 64)
+	{
+                if(copy_from_user(&keyMaterial2, iwp->pointer, iwp->length))
+			Status = -EINVAL;
+
+		AtoH(Key.KeyMaterial, keyMaterial, 32);
+
+		DBGPRINT_RAW(RT_DEBUG_TEMP,"WPAPSK Key : ");
+		for(i = 0; i < 32; i++)
+			DBGPRINT_RAW(RT_DEBUG_TEMP,"%x ", keyMaterial[i]);
+		DBGPRINT_RAW(RT_DEBUG_TEMP,"\n");
+
+		memcpy(pAdapter->PortCfg.PskKey.Key, keyMaterial, 32);
+		memcpy(Key.KeyMaterial, keyMaterial, 32);
+
+	}
+	
+	else
+		return -EOPNOTSUPP;
+
+
+	RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_KEY, TRUE, &Key, sizeof(Key));
+
+	pAdapter->PortCfg.WepStatus= Ndis802_11Encryption2Enabled;
+	pAdapter->PortCfg.PairCipher= Ndis802_11Encryption2Enabled;
+	pAdapter->PortCfg.GroupCipher= Ndis802_11Encryption2Enabled;
+	pAdapter->PortCfg.CipherAlg= CIPHER_TKIP;
+	// Start STA supplicant state machine
+	
+	return 0;
+
+}
+
+static int rtusb_ioctl_setrfmontx(struct net_device *dev,
+                                  struct iw_request_info *info,
+                                  struct iw_point *data, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	int param;
+	char value;	
+
+        if (extra) { /* Change the state if there's param. */
+           param = *(int *)extra;
+           switch(param)
+           {
+             case 1:
+                pAdapter->PortCfg.MallowRFMONTx = TRUE;
+		if (pAdapter->PortCfg.ForcePrismHeader == 1)
+                	pAdapter->net->type = 802; // ARPHRD_IEEE80211_PRISM
+		else
+			pAdapter->net->type = 801; // ARPHRD_IEEE80211
+                break;
+             case 0:
+                pAdapter->PortCfg.MallowRFMONTx = FALSE;
+		if (pAdapter->PortCfg.ForcePrismHeader == 2)
+			pAdapter->net->type = 801; // ARPHRD_IEEE80211
+		else
+                	pAdapter->net->type = 802; // ARPHRD_IEEE80211_PRISM
+                break;
+             default:
+                return -EOPNOTSUPP;
+           }
+	}
+
+        value = pAdapter->PortCfg.MallowRFMONTx == TRUE ? '1' : '0';
+
+        data->length = sizeof (char);
+        if (data->pointer != NULL && copy_to_user (data->pointer, &value, data->length))
+             DBGPRINT (RT_DEBUG_ERROR, "rtusb_ioctl_setrfmontx - copy to user failure.\n");
+
+	return 0;
+}
+
+static int rtusb_ioctl_setforceprismheader(struct net_device *dev,
+                                  struct iw_request_info *info,
+                                  struct iw_point *data, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	int param = *(int *)extra;
+
+	switch(param)
+	{
+	case 0:
+		pAdapter->PortCfg.ForcePrismHeader = 0;
+		if (pAdapter->PortCfg.MallowRFMONTx == TRUE)
+			pAdapter->net->type = 801; // ARPHRD_IEEE80211
+		else
+                	pAdapter->net->type = 802; // ARPHRD_IEEE80211_PRISM
+		break;
+	case 1:
+		pAdapter->PortCfg.ForcePrismHeader = 1;
+                pAdapter->net->type = 802; // ARPHRD_IEEE80211_PRISM
+		break;
+	case 2:
+		pAdapter->PortCfg.ForcePrismHeader = 2;
+		pAdapter->net->type = 801; // ARPHRD_IEEE80211
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int rtusb_ioctl_setadhocmode(struct net_device *dev,
+                                  struct iw_request_info *info,
+                                  struct iw_point *data, char *extra)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	int param = *(int *)extra;
+
+	switch(param)
+	{
+	case 0:
+			pAdapter->PortCfg.AdhocMode = 0;
+			break;
+		case 1:
+			pAdapter->PortCfg.AdhocMode = 1;
+			break;
+		case 2:
+			pAdapter->PortCfg.AdhocMode = 2;
+		break;
+		default:
+			return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int rtusb_ioctl_setpsm(struct net_device *dev, struct iw_request_info *info,
+			 void *w, char *extra)
+{
+
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) dev->priv;
+	int param = *(int *)extra;
+
+	switch(param)
+	{
+		case 0:
+			// clear PSM bit immediately
+			MlmeSetPsmBit(pAdapter, PWR_ACTIVE);
+			pAdapter->PortCfg.RecvDtim = TRUE;
+			pAdapter->PortCfg.WindowsPowerMode = Ndis802_11PowerModeCAM;
+			break;
+        
+	        case 1:
+			// do NOT turn on PSM bit here, wait until MlmeCheckForPsmChange()
+			// to exclude certain situations.
+			pAdapter->PortCfg.RecvDtim = TRUE;
+			pAdapter->PortCfg.WindowsPowerMode = Ndis802_11PowerModeMAX_PSP;
+			pAdapter->PortCfg.DefaultListenCount = 3;
+			break;
+	        	
+		default:
+			return -EOPNOTSUPP;
+
+    	}
+    
+	return 0;
+
+}
+static const iw_handler rtusb_handler[] =
+{
+	(iw_handler) NULL,				/* SIOCSIWCOMMIT */
+	(iw_handler) rtusb_ioctl_giwname,			/* SIOCGIWNAME	1 */	 
+	(iw_handler) NULL,				/* SIOCSIWNWID */
+	(iw_handler) NULL,				/* SIOCGIWNWID */
+	(iw_handler) rtusb_ioctl_siwfreq,		/* SIOCSIWFREQ */
+	(iw_handler) rtusb_ioctl_giwfreq,		/* SIOCGIWFREQ 5*/
+	(iw_handler) rtusb_ioctl_siwmode,		/* SIOCSIWMODE */
+	(iw_handler) rtusb_ioctl_giwmode,		/* SIOCGIWMODE */
+	(iw_handler) NULL,		/* SIOCSIWSENS */
+	(iw_handler) NULL,		/* SIOCGIWSENS */
+	(iw_handler) NULL /* not used */,		/* SIOCSIWRANGE */
+	(iw_handler) rtusb_ioctl_giwrange,		/* SIOCGIWRANGE 	11 */
+	(iw_handler) NULL /* not used */,		/* SIOCSIWPRIV */
+	(iw_handler) NULL /* kernel code */,		/* SIOCGIWPRIV */
+	(iw_handler) NULL /* not used */,		/* SIOCSIWSTATS */
+	(iw_handler) NULL /* kernel code */,		/* SIOCGIWSTATS 	f*/
+	(iw_handler) NULL,		/* SIOCSIWSPY */
+	(iw_handler) NULL,		/* SIOCGIWSPY */
+	(iw_handler) NULL,				/* -- hole -- */
+	(iw_handler) NULL,				/* -- hole -- */
+	(iw_handler) NULL,		/* SIOCSIWAP */
+	(iw_handler) rtusb_ioctl_giwap,		/* SIOCGIWAP	0x15*/
+	(iw_handler) NULL,				/* -- hole --	0x16 */
+	(iw_handler) rtusb_ioctl_iwaplist,		/* SIOCGIWAPLIST */
+#ifdef SIOCGIWSCAN
+	(iw_handler) rtusb_ioctl_siwscan,		/* SIOCSIWSCAN		0x18*/
+	(iw_handler) rtusb_ioctl_giwscan,		/* SIOCGIWSCAN */
+#else
+	(iw_handler) NULL,				/* SIOCSIWSCAN */
+	(iw_handler) NULL,				/* SIOCGIWSCAN */
+#endif /* SIOCGIWSCAN */
+	(iw_handler) rtusb_ioctl_siwessid,		/* SIOCSIWESSID */
+	(iw_handler) rtusb_ioctl_giwessid,		/* SIOCGIWESSID */
+	(iw_handler) rtusb_ioctl_siwnickn,		/* SIOCSIWNICKN */
+	(iw_handler) rtusb_ioctl_giwnickn,		/* SIOCGIWNICKN 1d*/
+	(iw_handler) NULL,				/* -- hole -- */
+	(iw_handler) NULL,				/* -- hole -- */
+	(iw_handler) NULL,		/* SIOCSIWRATE 20*/
+	(iw_handler) NULL,		/* SIOCGIWRATE */
+	(iw_handler) rtusb_ioctl_siwrts,		/* SIOCSIWRTS */
+	(iw_handler) rtusb_ioctl_giwrts,		/* SIOCGIWRTS */
+	(iw_handler) rtusb_ioctl_siwfrag,		/* SIOCSIWFRAG */
+	(iw_handler) rtusb_ioctl_giwfrag,		/* SIOCGIWFRAG 25*/
+	(iw_handler) NULL,		/* SIOCSIWTXPOW */
+	(iw_handler) NULL,		/* SIOCGIWTXPOW */
+	(iw_handler) NULL,		/* SIOCSIWRETRY */
+	(iw_handler) NULL,		/* SIOCGIWRETRY 29*/
+	(iw_handler) rtusb_ioctl_siwencode,		/* SIOCSIWENCODE 2a*/
+	(iw_handler) rtusb_ioctl_giwencode,		/* SIOCGIWENCODE 2b*/
+	(iw_handler) NULL,		/* SIOCSIWPOWER 2c*/
+	(iw_handler) NULL,		/* SIOCGIWPOWER 2d*/
+};
+static const iw_handler rtusb_priv_handlers[] = {
+	(iw_handler) rtusb_ioctl_setauth,		/* SIOCWFIRSTPRIV+0 */
+	(iw_handler) rtusb_ioctl_setencryp,		/* SIOCWFIRSTPRIV+1 */
+	(iw_handler) rtusb_ioctl_setwpapsk,		/* SIOCWFIRSTPRIV+2 */
+	(iw_handler) rtusb_ioctl_setpsm,		/* SIOCWFIRSTPRIV+3 */
+	(iw_handler) rtusb_ioctl_setadhocmode,		/* SIOCWFIRSTPRIV+4 */
+	(iw_handler) rtusb_ioctl_setrfmontx,		/* SIOCWFIRSTPRIV+5 */
+	(iw_handler) rtusb_ioctl_setforceprismheader,	/* SIOCWFIRSTPRIV+6 */
+};
+
+#define MAX_WPAPSK_STRING 64
+static const struct iw_priv_args privtab[] = {
+	{ RTPRIV_IOCTL_AUTH, 
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,  "auth"},
+	{ RTPRIV_IOCTL_WEPSTATUS, 
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,  "enc"},
+	{ RTPRIV_IOCTL_WPAPSK, 
+	  IW_PRIV_TYPE_CHAR | MAX_WPAPSK_STRING,
+	  0,  "wpapsk"},  // Variable arg count  
+	{ RTPRIV_IOCTL_PSM, 
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,  "psm"},  // Variable arg count  
+	{ RTPRIV_IOCTL_ADHOCMODE,
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,  "adhocmode"},
+	{ RTPRIV_IOCTL_RFMONTX,
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	  IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | sizeof(char), "rfmontx"}, 
+	{ RTPRIV_IOCTL_FORCEPRISMHEADER,
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,  "forceprismheader"},
+#if 0
+	{ RTPRIV_IOCTL_BBP,
+	  IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | 1024,
+	  "bbp"},
+	{ RTPRIV_IOCTL_MAC,
+	  IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | 1024,
+	  "mac"}
+#endif
+};
+
+const struct iw_handler_def rt2500usb_iw_handler_def =
+{
+	.standard		= (iw_handler *) rtusb_handler,
+	.num_standard		= sizeof(rtusb_handler) / sizeof(iw_handler),
+	.private		= (iw_handler *) rtusb_priv_handlers,
+	.num_private		= ARRAY_SIZE(rtusb_handler),
+	.private_args		= (struct iw_priv_args *) privtab,
+	.num_private_args	= ARRAY_SIZE(privtab),
+};
+
+INT RTMPQueryInformation(
+	IN	PRT2570ADAPTER pAdapter,
+	IN	OUT struct ifreq	*rq,
+	IN	INT 				cmd)
+{
+	struct iwreq						*wrq = (struct iwreq *) rq;
+	NDIS_802_11_BSSID_LIST_EX			*pBssidList = NULL;
+	PNDIS_WLAN_BSSID_EX 				pBss;
+	NDIS_802_11_SSID					Ssid;
+	NDIS_802_11_CONFIGURATION			Configuration;
+	RT_802_11_LINK_STATUS				LinkStatus;
+	NDIS_802_11_STATISTICS				Statistics;
+	NDIS_802_11_RTS_THRESHOLD			RtsThresh;
+	NDIS_802_11_FRAGMENTATION_THRESHOLD FragThresh;
+	NDIS_802_11_POWER_MODE				PowerMode;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE	BssType;
+	RT_802_11_PREAMBLE					PreamType;
+	NDIS_802_11_AUTHENTICATION_MODE 	AuthMode;
+	NDIS_802_11_WEP_STATUS				WepStatus;
+	RT_VERSION_INFO 					DriverVersionInfo;
+	ULONG								BssBufSize;
+	ULONG								BssLen;
+	ULONG								ulInfo = 0;
+	PUCHAR								pBuf = NULL;
+	PUCHAR								pPtr;
+	INT 								Status = NDIS_STATUS_SUCCESS;
+	UCHAR								Padding;
+	UINT								i;
+	BOOLEAN 							RadioState;
+	UCHAR                         LastR17Value;
+ 
+	
+	switch(cmd) {
+		case RT_OID_DEVICE_NAME:
+			DBGPRINT(RT_DEBUG_INFO, "Query::RT_OID_DEVICE_NAME\n");
+			wrq->u.data.length = sizeof(NIC_DEVICE_NAME);
+			if(copy_to_user(wrq->u.data.pointer, NIC_DEVICE_NAME, wrq->u.data.length))
+				Status = -EFAULT;
+
+			break;
+		case RT_OID_VERSION_INFO:
+			DBGPRINT(RT_DEBUG_INFO, "Query::RT_OID_VERSION_INFO \n");
+			DriverVersionInfo.DriverMajorVersion = DRV_MAJORVERSION;
+			DriverVersionInfo.DriverMinorVersion = DRV_MINORVERSION;
+			DriverVersionInfo.DriverSubVersion = DRV_SUBVERSION;
+            		DriverVersionInfo.DriverTestVersion = DRV_TESTVERSION;
+			DriverVersionInfo.DriverBuildYear = DRV_YEAR;
+			DriverVersionInfo.DriverBuildMonth = DRV_MONTH;
+			DriverVersionInfo.DriverBuildDay = DRV_DAY;
+			wrq->u.data.length = sizeof(RT_VERSION_INFO);
+			if(copy_to_user(wrq->u.data.pointer, &DriverVersionInfo, wrq->u.data.length))
+				Status = -EFAULT;
+
+			break;
+		case OID_802_11_BSSID_LIST:
+		
+			DBGPRINT(RT_DEBUG_ERROR, "Query::OID_802_11_BSSID_LIST (%d BSS returned)\n",pAdapter->PortCfg.BssTab.BssNr);
+			// Claculate total buffer size required
+			BssBufSize = sizeof(ULONG);
+			
+			for (i = 0; i < pAdapter->PortCfg.BssTab.BssNr; i++) 
+			{
+				// Align pointer to 4 bytes boundary.
+				Padding = 4 - (pAdapter->PortCfg.BssTab.BssEntry[i].VarIELen & 0x0003);
+				if (Padding == 4)
+					Padding = 0;
+				BssBufSize += (sizeof(NDIS_WLAN_BSSID_EX) - 4 + sizeof(NDIS_802_11_FIXED_IEs) + pAdapter->PortCfg.BssTab.BssEntry[i].VarIELen + Padding);
+			}
+
+			// For safety issue, we add 256 bytes just in case
+			BssBufSize += 256;
+			// Allocate the same size as passed from higher layer
+			pBuf = kmalloc(BssBufSize, GFP_KERNEL);
+			if(pBuf == NULL)
+			{
+				Status = -ENOMEM;
+				break;
+			}
+			// Init 802_11_BSSID_LIST_EX structure
+			memset(pBuf, 0, BssBufSize);
+
+			
+			pBssidList = (PNDIS_802_11_BSSID_LIST_EX) pBuf;
+			pBssidList->NumberOfItems = pAdapter->PortCfg.BssTab.BssNr;
+			
+			// Calculate total buffer length
+			BssLen = 4; // Consist of NumberOfItems
+			// Point to start of NDIS_WLAN_BSSID_EX
+			// pPtr = pBuf + sizeof(ULONG);
+			pPtr = (PUCHAR) &pBssidList->Bssid[0];
+			for (i = 0; i < pAdapter->PortCfg.BssTab.BssNr; i++) 
+			{
+				pBss = (PNDIS_WLAN_BSSID_EX) pPtr;
+				memcpy(&pBss->MacAddress, &pAdapter->PortCfg.BssTab.BssEntry[i].Bssid, MAC_ADDR_LEN);
+				if (pAdapter->PortCfg.BssTab.BssEntry[i].Hidden == 1)
+				{
+					pBss->Ssid.SsidLength = 0;
+				}
+				else
+				{
+			pBss->Ssid.SsidLength = pAdapter->PortCfg.BssTab.BssEntry[i].SsidLen;
+					memcpy(pBss->Ssid.Ssid, pAdapter->PortCfg.BssTab.BssEntry[i].Ssid, pAdapter->PortCfg.BssTab.BssEntry[i].SsidLen);
+				}
+				pBss->Privacy = pAdapter->PortCfg.BssTab.BssEntry[i].Privacy;
+		  //DBGPRINT(RT_DEBUG_ERROR,"pBss->Privacy=%x\n",(pBss->Privacy));
+				pBss->Rssi = pAdapter->PortCfg.BssTab.BssEntry[i].Rssi - RSSI_TO_DBM_OFFSET;
+		  //DBGPRINT(RT_DEBUG_ERROR,"pBss->Rssi=%x\n",pBss->Rssi);
+				pBss->NetworkTypeInUse = Ndis802_11DS;
+		  //DBGPRINT(RT_DEBUG_ERROR,"pBss->NetworkTypeInUse=%x\n",(pBss->NetworkTypeInUse));
+				pBss->Configuration.Length = sizeof(NDIS_802_11_CONFIGURATION);
+		  //DBGPRINT(RT_DEBUG_ERROR,"pBss->pBss->Configuration.Length=%d\n",pBss->Configuration.Length);
+				pBss->Configuration.BeaconPeriod = pAdapter->PortCfg.BssTab.BssEntry[i].BeaconPeriod;
+		  //DBGPRINT(RT_DEBUG_ERROR,"pBss->pBss->Configuration.BeaconPeriod=%d\n",pBss->Configuration.BeaconPeriod);
+				pBss->Configuration.ATIMWindow = pAdapter->PortCfg.BssTab.BssEntry[i].AtimWin;
+
+				MAP_CHANNEL_ID_TO_KHZ(pAdapter->PortCfg.BssTab.BssEntry[i].Channel, pBss->Configuration.DSConfig);
+
+				if (pAdapter->PortCfg.BssTab.BssEntry[i].BssType == BSS_INFRA) 
+					pBss->InfrastructureMode = Ndis802_11Infrastructure;
+				else
+					pBss->InfrastructureMode = Ndis802_11IBSS;
+
+				memcpy(pBss->SupportedRates, pAdapter->PortCfg.BssTab.BssEntry[i].Rates, pAdapter->PortCfg.BssTab.BssEntry[i].RatesLen);
+
+				//DBGPRINT(RT_DEBUG_ERROR, "BSS#%d - %s, length of ssid=%d,Ch %d = %d Khz\n",
+				//			i,pBss->Ssid.Ssid,pBss->Ssid.SsidLength,pAdapter->PortCfg.BssTab.BssEntry[i].Channel,pBss->Configuration.DSConfig);
+
+				if (pAdapter->PortCfg.BssTab.BssEntry[i].VarIELen == 0)
+				{
+					pBss->IELength = sizeof(NDIS_802_11_FIXED_IEs);
+					memcpy(pBss->IEs, &pAdapter->PortCfg.BssTab.BssEntry[i].FixIEs, sizeof(NDIS_802_11_FIXED_IEs));
+					pPtr = pPtr + sizeof(NDIS_WLAN_BSSID_EX) - 4 + sizeof(NDIS_802_11_FIXED_IEs);
+				}
+				else
+				{
+					pBss->IELength = sizeof(NDIS_802_11_FIXED_IEs) + pAdapter->PortCfg.BssTab.BssEntry[i].VarIELen;
+					pPtr = pPtr + sizeof(NDIS_WLAN_BSSID_EX) - 4 + sizeof(NDIS_802_11_FIXED_IEs);
+					memcpy(pBss->IEs, &pAdapter->PortCfg.BssTab.BssEntry[i].FixIEs, sizeof(NDIS_802_11_FIXED_IEs));
+					memcpy(pPtr, pAdapter->PortCfg.BssTab.BssEntry[i].VarIEs, pAdapter->PortCfg.BssTab.BssEntry[i].VarIELen);
+					pPtr += pAdapter->PortCfg.BssTab.BssEntry[i].VarIELen;
+				}
+				// Align pointer to 4 bytes boundary.
+				Padding = 4 - (pAdapter->PortCfg.BssTab.BssEntry[i].VarIELen & 0x0003);
+				if (Padding == 4)
+					Padding = 0;
+				pPtr += Padding;
+				pBss->Length = sizeof(NDIS_WLAN_BSSID_EX) - 4 + sizeof(NDIS_802_11_FIXED_IEs) + pAdapter->PortCfg.BssTab.BssEntry[i].VarIELen + Padding;
+				BssLen += pBss->Length;
+			}
+			wrq->u.data.length = BssLen;
+			DBGPRINT(RT_DEBUG_INFO,"copy to user in OID_802_11_BSSID_LIST = %d\n",wrq->u.data.length);
+
+			if(copy_to_user(wrq->u.data.pointer, pBssidList, wrq->u.data.length))
+				Status = -EFAULT;
+
+			kfree(pBssidList);
+			break;
+		case OID_802_11_TX_POWER_LEVEL:
+			wrq->u.data.length = sizeof(ULONG);
+			if(copy_to_user(wrq->u.data.pointer, &pAdapter->PortCfg.TxPower, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_11_TX_POWER_LEVEL %x\n",pAdapter->PortCfg.TxPower);
+			break;
+		case OID_802_3_CURRENT_ADDRESS:
+			wrq->u.data.length = ETH_LENGTH_OF_ADDRESS;
+			if(copy_to_user(wrq->u.data.pointer, &pAdapter->CurrentAddress, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_3_CURRENT_ADDRESS \n");
+			break;
+		case OID_GEN_MEDIA_CONNECT_STATUS:
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_GEN_MEDIA_CONNECT_STATUS \n");
+			wrq->u.data.length = sizeof(NDIS_MEDIA_STATE);
+			if(copy_to_user(wrq->u.data.pointer, &pAdapter->MediaState, wrq->u.data.length))
+				Status = -EFAULT;
+
+			break;
+		case OID_802_11_BSSID:
+			if (INFRA_ON(pAdapter) || ADHOC_ON(pAdapter))
+			{
+				if(copy_to_user(wrq->u.data.pointer, &pAdapter->PortCfg.Bssid, sizeof(MACADDR)))
+					Status = -EFAULT;
+
+				DBGPRINT(RT_DEBUG_INFO, "IOCTL::SIOCGIWAP(=%02x:%02x:%02x:%02x:%02x:%02x)\n",
+						pAdapter->PortCfg.Bssid.Octet[0],pAdapter->PortCfg.Bssid.Octet[1],pAdapter->PortCfg.Bssid.Octet[2],
+						pAdapter->PortCfg.Bssid.Octet[3],pAdapter->PortCfg.Bssid.Octet[4],pAdapter->PortCfg.Bssid.Octet[5]);
+
+			}
+			else
+			{
+				DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_11_BSSID(=EMPTY)\n");
+				Status = -ENOTCONN;
+			}
+			break;
+		case OID_802_11_SSID:
+			Ssid.SsidLength = pAdapter->PortCfg.SsidLen;
+			memset(Ssid.Ssid, 0, MAX_LEN_OF_SSID);
+			memcpy(Ssid.Ssid, pAdapter->PortCfg.Ssid, Ssid.SsidLength);
+			wrq->u.data.length = sizeof(NDIS_802_11_SSID);
+			if(copy_to_user(wrq->u.data.pointer, &Ssid, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_11_SSID (Len=%d, ssid=%s)\n", Ssid.SsidLength,Ssid.Ssid);
+			break;
+		case RT_OID_802_11_QUERY_LINK_STATUS:
+			LinkStatus.CurrTxRate = RateIdTo500Kbps[pAdapter->PortCfg.TxRate];	 // unit : 500 kbps
+			LinkStatus.ChannelQuality = pAdapter->Mlme.ChannelQuality;
+			LinkStatus.RxByteCount = pAdapter->RalinkCounters.ReceivedByteCount;
+			LinkStatus.TxByteCount = pAdapter->RalinkCounters.TransmittedByteCount;
+			wrq->u.data.length = sizeof(RT_802_11_LINK_STATUS);
+			if(copy_to_user(wrq->u.data.pointer, &LinkStatus, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::RT_OID_802_11_LINK_STATUS\n");
+			break;
+		case OID_802_11_CONFIGURATION:
+			Configuration.Length = sizeof(NDIS_802_11_CONFIGURATION);
+			Configuration.BeaconPeriod = pAdapter->PortCfg.BeaconPeriod;
+			Configuration.ATIMWindow = pAdapter->PortCfg.AtimWin;
+			if (ADHOC_ON(pAdapter))
+				{MAP_CHANNEL_ID_TO_KHZ(pAdapter->PortCfg.IbssConfig.Channel, Configuration.DSConfig);}
+			else
+				{MAP_CHANNEL_ID_TO_KHZ(pAdapter->PortCfg.Channel, Configuration.DSConfig);}
+			wrq->u.data.length = sizeof(NDIS_802_11_CONFIGURATION);
+			if(copy_to_user(wrq->u.data.pointer, &Configuration, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_ERROR, "Query::OID_802_11_CONFIGURATION(BeaconPeriod=%d,AtimW=%d,bssidChannel=%d) \n", 
+				Configuration.BeaconPeriod, Configuration.ATIMWindow, pAdapter->PortCfg.IbssConfig.Channel);
+			break;
+		case OID_802_11_RSSI:
+			ulInfo = pAdapter->PortCfg.LastRssi;
+			wrq->u.data.length = sizeof(UCHAR);
+			if(copy_to_user(wrq->u.data.pointer, &ulInfo, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_11_RSSI(=%d)\n", ulInfo);
+			break;
+		case OID_802_11_RSSI_TRIGGER:
+			ulInfo = pAdapter->PortCfg.LastRssi - RSSI_TO_DBM_OFFSET;
+			wrq->u.data.length = sizeof(ulInfo);
+			if(copy_to_user(wrq->u.data.pointer, &ulInfo, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_11_RSSI_TRIGGER(=%d)\n", ulInfo);
+			break;
+		case OID_802_11_STATISTICS:
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_11_STATISTICS \n");
+			// Update FCS counters
+
+			// Sanity check for calculation of sucessful count
+			if (pAdapter->WlanCounters.TransmittedFragmentCount.QuadPart < pAdapter->WlanCounters.RetryCount.QuadPart)
+				pAdapter->WlanCounters.TransmittedFragmentCount.QuadPart = pAdapter->WlanCounters.RetryCount.QuadPart;
+
+			Statistics.TransmittedFragmentCount.QuadPart = pAdapter->WlanCounters.TransmittedFragmentCount.QuadPart;
+			Statistics.MulticastTransmittedFrameCount.QuadPart = pAdapter->WlanCounters.MulticastTransmittedFrameCount.QuadPart;
+			Statistics.FailedCount.QuadPart = pAdapter->WlanCounters.FailedCount.QuadPart;
+			Statistics.RetryCount.QuadPart = pAdapter->WlanCounters.RetryCount.QuadPart;
+			Statistics.MultipleRetryCount.QuadPart = pAdapter->WlanCounters.MultipleRetryCount.QuadPart;
+			Statistics.RTSSuccessCount.QuadPart = pAdapter->WlanCounters.RTSSuccessCount.QuadPart;
+			Statistics.RTSFailureCount.QuadPart = pAdapter->WlanCounters.RTSFailureCount.QuadPart;
+			Statistics.ACKFailureCount.QuadPart = pAdapter->WlanCounters.ACKFailureCount.QuadPart;
+			Statistics.FrameDuplicateCount.QuadPart = pAdapter->WlanCounters.FrameDuplicateCount.QuadPart;
+			Statistics.ReceivedFragmentCount.QuadPart = pAdapter->WlanCounters.ReceivedFragmentCount.QuadPart;
+			Statistics.MulticastReceivedFrameCount.QuadPart = pAdapter->WlanCounters.MulticastReceivedFrameCount.QuadPart;
+			Statistics.FCSErrorCount.QuadPart = pAdapter->WlanCounters.FCSErrorCount.QuadPart;
+			wrq->u.data.length = sizeof(NDIS_802_11_STATISTICS);
+			if(copy_to_user(wrq->u.data.pointer, &Statistics, wrq->u.data.length))
+				Status = -EFAULT;
+
+			break;
+		case OID_GEN_RCV_OK:
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_GEN_RCV_OK \n");
+			ulInfo = pAdapter->Counters.GoodReceives;
+			wrq->u.data.length = sizeof(ulInfo);
+			if(copy_to_user(wrq->u.data.pointer, &ulInfo, wrq->u.data.length))
+				Status = -EFAULT;
+
+			break;
+		case OID_GEN_RCV_NO_BUFFER:
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_GEN_RCV_NO_BUFFER \n");
+			ulInfo = pAdapter->Counters.RxNoBuffer;
+			wrq->u.data.length = sizeof(ulInfo);
+			if(copy_to_user(wrq->u.data.pointer, &ulInfo, wrq->u.data.length))
+				Status = -EFAULT;
+
+			break;
+		case RT_OID_802_11_PHY_MODE:
+			ulInfo = (ULONG)pAdapter->PortCfg.PhyMode;
+			wrq->u.data.length = sizeof(ulInfo);
+			if(copy_to_user(wrq->u.data.pointer, &ulInfo, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::RT_OID_802_11_PHY_MODE (=%d)\n", ulInfo);
+			break;
+		case OID_802_11_RTS_THRESHOLD:
+			RtsThresh = pAdapter->PortCfg.RtsThreshold;
+			wrq->u.data.length = sizeof(RtsThresh);
+			if(copy_to_user(wrq->u.data.pointer, &RtsThresh, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_11_RTS_THRESHOLD(=%d)\n", RtsThresh);
+			break;
+		case OID_802_11_FRAGMENTATION_THRESHOLD:
+			FragThresh = pAdapter->PortCfg.FragmentThreshold;
+			if (pAdapter->PortCfg.bFragmentZeroDisable == TRUE)
+				FragThresh = 0;
+			wrq->u.data.length = sizeof(FragThresh);
+			if(copy_to_user(wrq->u.data.pointer, &FragThresh, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_11_FRAGMENTATION_THRESHOLD(=%d)\n", FragThresh);
+			break;
+		case OID_802_11_POWER_MODE:
+			PowerMode = pAdapter->PortCfg.WindowsPowerMode;
+			wrq->u.data.length = sizeof(PowerMode);
+			if(copy_to_user(wrq->u.data.pointer, &PowerMode, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_11_POWER_MODE(=%d)\n", PowerMode);
+			break;
+		case RT_OID_802_11_RADIO:
+			RadioState = (BOOLEAN) pAdapter->PortCfg.bSwRadio;
+			wrq->u.data.length = sizeof(RadioState);
+			if(copy_to_user(wrq->u.data.pointer, &RadioState, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::RT_OID_802_11_QUERY_RADIO (=%d)\n", RadioState);
+			break;
+		case OID_802_11_INFRASTRUCTURE_MODE:
+			if (ADHOC_ON(pAdapter))
+				BssType = Ndis802_11IBSS;
+			else if (INFRA_ON(pAdapter))
+				BssType = Ndis802_11Infrastructure;
+			else
+				BssType = Ndis802_11AutoUnknown;
+
+			wrq->u.data.length = sizeof(BssType);
+			if(copy_to_user(wrq->u.data.pointer, &BssType, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_11_INFRASTRUCTURE_MODE(=%d)\n", BssType);
+			break;
+		case RT_OID_802_11_PREAMBLE:
+			PreamType = pAdapter->PortCfg.WindowsTxPreamble;
+			wrq->u.data.length = sizeof(PreamType);
+			if(copy_to_user(wrq->u.data.pointer, &PreamType, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::RT_OID_802_11_PREAMBLE(=%d)\n", PreamType);
+			break;
+		case OID_802_11_AUTHENTICATION_MODE:
+			AuthMode = pAdapter->PortCfg.AuthMode;
+			wrq->u.data.length = sizeof(AuthMode);
+			if(copy_to_user(wrq->u.data.pointer, &AuthMode, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_11_AUTHENTICATION_MODE(=%d)\n", AuthMode);
+			break;
+		case OID_802_11_WEP_STATUS:
+			WepStatus = pAdapter->PortCfg.WepStatus;
+			wrq->u.data.length = sizeof(WepStatus);
+			if(copy_to_user(wrq->u.data.pointer, &WepStatus, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::OID_802_11_WEP_STATUS(=%d)\n", WepStatus);
+			break;
+		case RT_OID_802_11_QUERY_NOISE_LEVEL:
+			LastR17Value = (pAdapter->PortCfg.LastR17Value > BBP_R17_DYNAMIC_UP_BOUND) ? BBP_R17_DYNAMIC_UP_BOUND : ((ULONG) pAdapter->PortCfg.LastR17Value);
+			wrq->u.data.length = sizeof(UCHAR);
+			if(copy_to_user(wrq->u.data.pointer, &LastR17Value, wrq->u.data.length))
+				Status = -EFAULT;
+
+			DBGPRINT(RT_DEBUG_INFO, "Query::RT_OID_802_11_QUERY_NOISE_LEVEL (=%d)\n", LastR17Value);
+			break;
+		case RT_OID_802_11_EXTRA_INFO:
+			wrq->u.data.length = sizeof(ULONG);
+			if(copy_to_user(wrq->u.data.pointer, &pAdapter->ExtraInfo, wrq->u.data.length))
+				Status = -EFAULT;
+
+	            DBGPRINT(RT_DEBUG_INFO, "Query::RT_OID_802_11_EXTRA_INFO (=%d)\n", pAdapter->ExtraInfo);
+	            break;
+		default:
+			DBGPRINT(RT_DEBUG_TRACE, "Query::unknown IOCTL's subcmd = 0x%08x\n", cmd);
+			Status = -EOPNOTSUPP;
+			break;
+	}
+
+	return Status;
+}
+
+
+
+INT RTMPSetInformation(
+	IN	PRT2570ADAPTER pAdapter,
+	IN	OUT struct ifreq	*rq,
+	IN	INT 				cmd)
+{
+	struct iwreq						*wrq = (struct iwreq *) rq;
+	NDIS_802_11_SSID					Ssid, *pSsid=NULL;
+	NDIS_802_11_MAC_ADDRESS 			Bssid;
+	RT_802_11_PHY_MODE					PhyMode;
+	NDIS_802_11_RATES					aryRates;
+	RT_802_11_PREAMBLE					Preamble;
+	NDIS_802_11_WEP_STATUS				WepStatus;
+	NDIS_802_11_AUTHENTICATION_MODE 	AuthMode;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE	BssType;
+	NDIS_802_11_RTS_THRESHOLD			RtsThresh;
+	NDIS_802_11_FRAGMENTATION_THRESHOLD FragThresh;
+	NDIS_802_11_POWER_MODE				PowerMode;
+	NDIS_802_11_TX_POWER_LEVEL			TxPowerLevel;
+	NDIS_802_11_KEY					Key;
+	PNDIS_802_11_REMOVE_KEY 			pRemoveKey = NULL;
+	NDIS_802_11_CONFIGURATION			Config, *pConfig = NULL;
+	ULONG								Now;
+	ULONG								KeyIdx;
+	INT 								Status = NDIS_STATUS_SUCCESS;
+	UCHAR								CountryRegion;
+	BOOLEAN 							RadioState;
+	NDIS_802_11_PRIVACY_FILTER           Filter;
+	NDIS_802_11_RSSI                     RssiTrigger;
+	
+	DBGPRINT(RT_DEBUG_INFO, "Set::RTMPSetInformation \n");
+	
+	switch(cmd & 0x7FFF) {
+		case OID_802_11_BSSID:
+		 	DBGPRINT(RT_DEBUG_ERROR,"enter OID_802_11_BSSID in RTMPSetInformation\n");
+			if (wrq->u.data.length != sizeof(NDIS_802_11_MAC_ADDRESS))
+				Status	= -EINVAL;
+			else
+			{
+				if(copy_from_user(&Bssid, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				pAdapter->Mlme.CntlAux.CurrReqIsFromNdis = FALSE;
+				Status = RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_802_11_BSSID, TRUE, &Bssid, wrq->u.data.length);
+									
+			}
+			break;
+		case OID_802_11_SSID:
+			DBGPRINT(RT_DEBUG_ERROR,"enter OID_802_11_SSID in RTMPSetInformation\n");
+			if (wrq->u.data.length != sizeof(NDIS_802_11_SSID))
+				Status = -EINVAL;
+			else
+			{
+				if(copy_from_user(&Ssid, wrq->u.data.pointer, wrq->u.data.length))
+		    			Status = -EINVAL;
+					
+				pSsid = &Ssid;
+
+				if (pSsid->SsidLength > MAX_LEN_OF_SSID)
+					Status = -EINVAL;
+				else
+				{
+					Status =RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_SSID, TRUE, pSsid, sizeof(NDIS_802_11_SSID));
+					DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_SSID (Len=%d,Ssid=%s)\n", pSsid->SsidLength, pSsid->Ssid);
+				}
+			}
+			break;
+		case OID_802_11_INFRASTRUCTURE_MODE:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_NETWORK_INFRASTRUCTURE))
+				Status	= -EINVAL;
+			else
+			{
+				if(copy_from_user(&BssType, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				if (BssType == Ndis802_11IBSS) 
+				{
+					if (pAdapter->PortCfg.BssType != BSS_INDEP)
+					{
+						// Config has changed
+						if INFRA_ON(pAdapter)
+						{
+							RTUSBEnqueueInternalCmd(pAdapter, RT_OID_LINK_DOWN);
+							// First cancel linkdown timer
+							DBGPRINT(RT_DEBUG_TRACE, "NDIS_STATUS_MEDIA_DISCONNECT Event BB!\n");							
+						}
+					}
+					pAdapter->PortCfg.BssType = BSS_INDEP;
+					DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_INFRASTRUCTURE_MODE (AD-HOC)\n");
+				}
+				else if (BssType == Ndis802_11Infrastructure) 
+				{
+					if (pAdapter->PortCfg.BssType != BSS_INFRA)
+					{
+						// Config has changed
+						// pAdapter->bConfigChanged = TRUE;
+						if ADHOC_ON(pAdapter)
+							RTUSBEnqueueInternalCmd(pAdapter, RT_OID_LINK_DOWN);
+					}
+					pAdapter->PortCfg.BssType = BSS_INFRA;
+					DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_INFRASTRUCTURE_MODE (INFRA)\n");
+				}
+				else
+				{
+					Status	= -EINVAL;
+					DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_INFRASTRUCTURE_MODE (unknown)\n");
+				}
+			}
+			// Reset Ralink supplicant to not use, it will be set to start when UI set PMK key
+			pAdapter->PortCfg.WpaState = SS_NOTUSE;
+			break;
+		case OID_802_11_ADD_KEY:
+			DBGPRINT(RT_DEBUG_ERROR, "!!!!!!!!!!!!!!!!!!!!!Set::OID_802_11_ADD_KEY !!\n");
+			if(copy_from_user(&Key, wrq->u.data.pointer, wrq->u.data.length))
+				Status = -EINVAL;
+					
+			if (Key.Length != wrq->u.data.length)
+			{
+				Status	= -EINVAL;
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_ADD_KEY, Failed!!\n");
+			}
+			else
+			{
+				if (pAdapter->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+				{
+					Status = RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_KEY, TRUE, &Key, wrq->u.data.length);
+				}
+				else	// Old WEP stuff
+				{
+					KeyIdx = Key.KeyIndex & 0x0fffffff;
+					Status = RTMPWPAWepKeySanity(pAdapter, &Key);
+					if (Status == NDIS_STATUS_SUCCESS)
+						Status = RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_KEY_WEP, TRUE, &Key, wrq->u.data.length);
+
+				}
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_ADD_KEY (id=0x%x, Len=%d-byte)\n", Key.KeyIndex, Key.KeyLength);
+			}
+			break;
+		case OID_802_11_REMOVE_KEY:
+			DBGPRINT(RT_DEBUG_ERROR, "Set::OID_802_11_REMOVE_KEY!!\n");
+			pRemoveKey = kmalloc(wrq->u.data.length, GFP_KERNEL);
+			if(copy_from_user(pRemoveKey, wrq->u.data.pointer, wrq->u.data.length))
+				Status = -EINVAL;
+					
+			if (pRemoveKey->Length != wrq->u.data.length)
+			{
+				Status	= -EINVAL;
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_REMOVE_KEY, Failed!!\n");
+			}
+			else
+			{
+				if (pAdapter->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+				{
+					Status = RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_REMOVE_KEY, TRUE, pRemoveKey, wrq->u.data.length);
+					DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_REMOVE_KEY, Remove WPA Key!!\n");
+				}
+				else
+				{
+					KeyIdx = pRemoveKey->KeyIndex;
+
+					if (KeyIdx & 0x80000000)
+					{
+						// Should never set default bit when remove key
+						Status	= -EINVAL;
+						DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_REMOVE_KEY, Failed!!(Should never set default bit when remove key)\n");
+					}
+					else
+					{
+						KeyIdx = KeyIdx & 0x0fffffff;
+						if (KeyIdx > 3)
+						{
+							Status	= -EINVAL;
+							DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_REMOVE_KEY, Failed!!(KeyId[%d] out of range)\n", KeyIdx);
+						}
+						else
+						{
+							pAdapter->PortCfg.SharedKey[KeyIdx].KeyLen = 0;
+							DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_REMOVE_KEY (id=0x%x, Len=%d-byte)\n", pRemoveKey->KeyIndex, pRemoveKey->Length);
+						}
+					}
+				}
+			}
+			kfree(pRemoveKey);
+			break;
+		case OID_802_11_AUTHENTICATION_MODE:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_AUTHENTICATION_MODE)) 
+				Status	= -EINVAL;
+			else
+			{
+				if(copy_from_user(&AuthMode, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+					
+				if (AuthMode > Ndis802_11AuthModeMax)
+				{
+					Status	= -EINVAL;
+					break;
+				}
+				else
+				{
+					if (pAdapter->PortCfg.AuthMode != AuthMode)
+					{
+						// Config has changed
+						pAdapter->bConfigChanged = TRUE;
+					}
+					pAdapter->PortCfg.AuthMode = AuthMode;
+				}
+				pAdapter->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_AUTHENTICATION_MODE (=%d) \n",pAdapter->PortCfg.AuthMode);
+			}
+			break;
+		case OID_802_11_PRIVACY_FILTER:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_PRIVACY_FILTER))
+				Status = -EINVAL;
+			else 
+			{
+				if(copy_from_user(&Filter, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+					
+				if ((Filter == Ndis802_11PrivFilterAcceptAll) || (Filter == Ndis802_11PrivFilter8021xWEP))
+					pAdapter->PortCfg.PrivacyFilter = Filter;
+				else
+					Status = -EINVAL;
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_PRIVACY_FILTER (=%d) \n",pAdapter->PortCfg.PrivacyFilter);
+			break;
+		case OID_802_11_BSSID_LIST_SCAN:
+			Now = jiffies;
+			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_BSSID_LIST_SCAN \n");
+
+
+			if (pAdapter->ScanAllowed == FALSE)
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "!!! Link UP, ignore this set::OID_802_11_BSSID_LIST_SCAN\n");
+				pAdapter->PortCfg.IgnoredScanNumber = 99;
+				return NDIS_STATUS_SUCCESS;
+			}
+
+			if ((pAdapter->MediaState == NdisMediaStateConnected) &&
+				((pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA) || 
+				(pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK)) &&
+				(pAdapter->PortCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "!!! Link UP, Port Not Secured! ignore this set::OID_802_11_BSSID_LIST_SCAN\n");
+				Status = NDIS_STATUS_SUCCESS;
+				break;
+			}
+
+			Status =RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_BSSID_LIST_SCAN, TRUE, NULL, 0);
+		 			break;
+		case OID_802_11_WEP_STATUS:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_WEP_STATUS))
+				Status	= -EINVAL;
+			else
+			{
+				if(copy_from_user(&WepStatus, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				// Since TKIP, AES, WEP are all supported. It should not have any invalid setting
+				if (WepStatus <= Ndis802_11Encryption3KeyAbsent)
+				{
+					Status = RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_WEP_STATUS, TRUE, &WepStatus, sizeof(NDIS_802_11_WEP_STATUS));
+					pAdapter->PortCfg.WepStatus = WepStatus;
+					pAdapter->PortCfg.OrigWepStatus = WepStatus;
+					pAdapter->PortCfg.PairCipher = WepStatus;
+					pAdapter->PortCfg.GroupCipher = WepStatus;
+				}
+
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_WEP_STATUS (=%d)\n",WepStatus);
+			}
+			break;
+		case OID_802_11_TX_POWER_LEVEL:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_TX_POWER_LEVEL))
+				Status	= -EINVAL;
+			else
+			{
+				if(copy_from_user(&TxPowerLevel, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				if (TxPowerLevel > MAX_TX_POWER_LEVEL)
+					Status	= -EINVAL;
+				else
+					pAdapter->PortCfg.TxPower = (UCHAR)TxPowerLevel;
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_TX_POWER_LEVEL (=%d) \n",TxPowerLevel);
+			break;
+		case OID_802_11_RSSI_TRIGGER:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_RSSI))
+				Status = -EINVAL;
+			else 
+			{
+				if(copy_from_user(&RssiTrigger, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				if (RssiTrigger > MAX_RSSI_TRIGGER || RssiTrigger < MIN_RSSI_TRIGGER) 
+					Status = -EINVAL;
+				else
+				{
+					pAdapter->PortCfg.RssiTrigger = (UCHAR)RssiTrigger + pAdapter->BBPTuningParameters.RSSIToDbmOffset;
+					if (pAdapter->PortCfg.RssiTrigger > pAdapter->PortCfg.LastRssi)
+						pAdapter->PortCfg.RssiTriggerMode = RSSI_TRIGGERED_UPON_BELOW_THRESHOLD;
+					else
+						pAdapter->PortCfg.RssiTriggerMode = RSSI_TRIGGERED_UPON_EXCCEED_THRESHOLD;
+				}
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_RSSI_TRIGGER (=%d)\n",RssiTrigger);
+			break;
+		case OID_802_11_FRAGMENTATION_THRESHOLD:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_FRAGMENTATION_THRESHOLD))
+				Status	= -EINVAL;
+			else
+			{
+				if(copy_from_user(&FragThresh, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				pAdapter->PortCfg.bFragmentZeroDisable = FALSE;
+				if (FragThresh > MAX_FRAG_THRESHOLD || FragThresh < MIN_FRAG_THRESHOLD)
+				{
+					if (FragThresh == 0)
+					{
+						pAdapter->PortCfg.FragmentThreshold = MAX_FRAG_THRESHOLD;
+						pAdapter->PortCfg.bFragmentZeroDisable = TRUE;
+					}
+					else
+						Status	= -EINVAL;
+				}
+				else
+					pAdapter->PortCfg.FragmentThreshold = (USHORT)FragThresh;
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_FRAGMENTATION_THRESHOLD (=%d) \n",FragThresh);
+			break;
+		case OID_802_11_RTS_THRESHOLD:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_RTS_THRESHOLD))
+				Status	= -EINVAL;
+			else
+			{
+				if(copy_from_user(&RtsThresh, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				if (RtsThresh > MAX_RTS_THRESHOLD)
+					Status	= -EINVAL;
+				else
+					pAdapter->PortCfg.RtsThreshold = (USHORT)RtsThresh;
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_RTS_THRESHOLD (=%d)\n",RtsThresh);
+			break;
+		case OID_802_11_DESIRED_RATES:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_RATES))
+				Status	= -EINVAL;
+			else
+			{
+				if(copy_from_user(&aryRates, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				memset(pAdapter->PortCfg.DesiredRates, 0, MAX_LEN_OF_SUPPORTED_RATES);
+				memcpy(pAdapter->PortCfg.DesiredRates, &aryRates, sizeof(NDIS_802_11_RATES));
+				DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_DESIRED_RATES (%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x)\n",
+					pAdapter->PortCfg.DesiredRates[0],pAdapter->PortCfg.DesiredRates[1],
+					pAdapter->PortCfg.DesiredRates[2],pAdapter->PortCfg.DesiredRates[3],
+					pAdapter->PortCfg.DesiredRates[4],pAdapter->PortCfg.DesiredRates[5],
+					pAdapter->PortCfg.DesiredRates[6],pAdapter->PortCfg.DesiredRates[7] );
+				// Changing DesiredRate may affect the MAX TX rate we used to TX frames out
+				Status = RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_UPDATE_TX_RATE, TRUE, NULL, 0);
+			}
+			break;
+		case OID_802_11_CONFIGURATION:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_CONFIGURATION))
+				Status	= -EINVAL;
+			else
+			{
+				if(copy_from_user(&Config, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				pConfig = &Config;
+				pAdapter->PortCfg.IbssConfig.BeaconPeriod = (USHORT) pConfig->BeaconPeriod;
+				pAdapter->PortCfg.IbssConfig.AtimWin = (USHORT) pConfig->ATIMWindow;
+				MAP_KHZ_TO_CHANNEL_ID(pConfig->DSConfig, pAdapter->PortCfg.IbssConfig.Channel);
+				DBGPRINT(RT_DEBUG_ERROR, "Set::OID_802_11_CONFIGURATION (BeacnPeriod=%d,AtimW=%d,Ch=%d)\n",
+					pConfig->BeaconPeriod, pConfig->ATIMWindow, pAdapter->PortCfg.IbssConfig.Channel);
+				// Config has changed
+				pAdapter->bConfigChanged = TRUE;
+			}
+			break;
+		case OID_802_11_POWER_MODE:
+			if (wrq->u.data.length != sizeof(NDIS_802_11_POWER_MODE))
+				Status = -EINVAL;
+			else
+			{
+				if(copy_from_user(&PowerMode, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				// save user's policy here, but not change PortCfg.Psm immediately
+				if (PowerMode == Ndis802_11PowerModeCAM) 
+				{
+					// clear PSM bit immediately
+					MlmeSetPsmBit(pAdapter, PWR_ACTIVE);
+					pAdapter->PortCfg.RecvDtim = TRUE;
+					pAdapter->PortCfg.WindowsPowerMode = PowerMode;
+				}
+				else if (PowerMode == Ndis802_11PowerModeMAX_PSP) 
+				{
+					// do NOT turn on PSM bit here, wait until MlmeCheckForPsmChange()
+					// to exclude certain situations.
+					//	   MlmeSetPsmBit(pAdapter, PWR_SAVE);
+					pAdapter->PortCfg.WindowsPowerMode = PowerMode;
+					pAdapter->PortCfg.RecvDtim = TRUE;	// FALSE;
+					pAdapter->PortCfg.DefaultListenCount = 5;
+				}
+				else if (PowerMode == Ndis802_11PowerModeFast_PSP) 
+				{
+					// do NOT turn on PSM bit here, wait until MlmeCheckForPsmChange()
+					// to exclude certain situations.
+					//	   MlmeSetPsmBit(pAdapter, PWR_SAVE);
+					pAdapter->PortCfg.RecvDtim = TRUE;
+					pAdapter->PortCfg.WindowsPowerMode = PowerMode;
+					pAdapter->PortCfg.DefaultListenCount = 3;
+				}
+				else
+					Status = -EINVAL;
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_POWER_MODE (=%d)\n",PowerMode);
+			break;
+		case RT_OID_802_11_PREAMBLE:
+			if (wrq->u.data.length != sizeof(RT_802_11_PREAMBLE))
+				Status	= -EINVAL;
+			else
+			{
+				if(copy_from_user(&Preamble, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				if ((Preamble == Rt802_11PreambleShort) || (Preamble == Rt802_11PreambleLong) || (Preamble == Rt802_11PreambleAuto))
+				{
+					Status = RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_802_11_PREAMBLE, TRUE, &Preamble, sizeof(RT_802_11_PREAMBLE));
+				}
+				else
+				{
+					Status = EINVAL;
+					break;
+				}
+				DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_SET_PREAMBLE (=%d)\n", Preamble);
+			}
+			break;
+		case RT_OID_802_11_RADIO:
+			if (wrq->u.data.length != sizeof(BOOLEAN))
+				Status	= -EINVAL;
+			else
+			{
+				Status	= -EINVAL;
+				if(copy_from_user(&RadioState, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_RADIO (=%d)\n", RadioState);
+				if (pAdapter->PortCfg.bSwRadio != RadioState)
+				{
+					pAdapter->PortCfg.bSwRadio = RadioState;
+					if (pAdapter->PortCfg.bRadio != (pAdapter->PortCfg.bHwRadio && pAdapter->PortCfg.bSwRadio))
+					{
+						pAdapter->PortCfg.bRadio = (pAdapter->PortCfg.bHwRadio && pAdapter->PortCfg.bSwRadio);
+						Status = RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_SET_RADIO, TRUE, NULL, 0);
+					}
+				}
+			}
+			break;
+		case RT_OID_802_11_COUNTRY_REGION:
+			if (wrq->u.data.length != sizeof(CountryRegion))
+				Status = -EINVAL;
+			else if (!(pAdapter->PortCfg.CountryRegion & 0x80))	// Only avaliable when EEPROM not programming
+			{
+				ULONG	TmpPhy;
+				
+				if(copy_from_user(&pAdapter->PortCfg.CountryRegion, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				TmpPhy = pAdapter->PortCfg.PhyMode;
+			    	pAdapter->PortCfg.PhyMode = 0xff;
+				// Build all corresponding channel information
+				Status = RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_802_11_PHY_MODE, TRUE, &TmpPhy, sizeof(TmpPhy));
+				DBGPRINT(RT_DEBUG_ERROR, "Set::RT_OID_802_11_COUNTRY_REGION (=%d) \n", pAdapter->PortCfg.CountryRegion);
+			}
+			break;
+		case RT_OID_802_11_PHY_MODE:
+			if (wrq->u.data.length != sizeof(RT_802_11_PHY_MODE))
+				Status	= -EINVAL;
+			else
+			{
+				if(copy_from_user(&PhyMode, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				Status = RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_802_11_PHY_MODE, TRUE, &PhyMode, sizeof(RT_802_11_PHY_MODE));
+				DBGPRINT(RT_DEBUG_ERROR, "Set::RT_OID_802_11_PHY_MODE  (=%d)\n", PhyMode);
+			}
+			break;
+		case RT_OID_802_11_STA_CONFIG:
+			if (wrq->u.data.length  != sizeof(RT_802_11_STA_CONFIG))
+			{
+				Status	= -EINVAL;
+			}
+			else 
+			{
+				Status =  (RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_802_11_STA_CONFIG, TRUE, wrq->u.data.pointer, sizeof(RT_802_11_STA_CONFIG)));
+			}
+			break;
+		case RT_OID_802_11_RESET_COUNTERS:
+			memset(&pAdapter->WlanCounters, 0, sizeof(COUNTER_802_11));
+			memset(&pAdapter->Counters, 0, sizeof(COUNTER_802_3));
+			memset(&pAdapter->RalinkCounters, 0, sizeof(COUNTER_RALINK));
+			memset(&pAdapter->Mlme.PrevWlanCounters, 0, sizeof(COUNTER_802_11));
+			 {
+				return(RTUSBEnqueueCmdFromNdis(pAdapter, RT_OID_802_11_RESET_COUNTERS, TRUE, NULL, 0));
+			 }
+			DBGPRINT(RT_DEBUG_INFO, "Set::RT_OID_802_11_RESET_COUNTERS \n");
+			break;
+#if 1
+		// For WPA PSK PMK key
+		case RT_OID_802_11_ADD_WPA:
+			DBGPRINT(RT_DEBUG_ERROR, "!!!!!!!!!!!!!!!!!!!!!Set::RT_OID_802_11_ADD_WPA \n");	
+			if (wrq->u.data.length > sizeof(Key))  
+				Status = -EINVAL;
+            		else
+                       {
+				if(copy_from_user(&Key, wrq->u.data.pointer, wrq->u.data.length))
+					Status = -EINVAL;
+
+				if (Key.Length != wrq->u.data.length)
+				{
+					Status	= -EINVAL;
+					DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_ADD_WPA, Failed!!\n");
+				}
+				else
+				{
+					if ((pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPAPSK) && (pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPANone))
+					{
+						Status = -EOPNOTSUPP;
+						DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_ADD_WPA, Failed!! [AuthMode != WPAPSK]\n");
+					}
+					else // Only for WPA PSK mode
+					{
+						pAdapter->PortCfg.PskKey.KeyLen = (UCHAR) Key.KeyLength;
+						memcpy(pAdapter->PortCfg.PskKey.Key, Key.KeyMaterial, Key.KeyLength);
+
+						if (pAdapter->PortCfg.AuthMode >= Ndis802_11AuthModeWPA)
+						{
+							RTMPWPAAddKeyProc(pAdapter, &Key);
+						}
+						
+						// Use RaConfig as PSK agent.
+						// Start STA supplicant state machine
+						pAdapter->PortCfg.WpaState = SS_START;
+#ifdef RT2500_DBG
+	{
+						int	i;
+						DBGPRINT(RT_DEBUG_LOUD, "RT_OID_802_11_ADD_WPA Key => \n");
+						DBGPRINT(RT_DEBUG_LOUD, "    ");
+						for (i = 0; i < Key.KeyLength; i++)
+						{
+							DBGPRINT_RAW(RT_DEBUG_LOUD, "%02x:", pAdapter->PortCfg.PskKey.Key[i]);
+							if (i%16 == 15) {
+								DBGPRINT_RAW(RT_DEBUG_LOUD, "\n");
+								DBGPRINT(RT_DEBUG_LOUD, "    ");
+							}
+						}
+						DBGPRINT_RAW(RT_DEBUG_LOUD, "\n");
+	}
+#endif
+						DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_ADD_WPA (id=0x%x, Len=%d-byte)\n", Key.KeyIndex, Key.KeyLength);
+					}
+				}
+
+			}
+		break;
+#endif            
+		default:
+			DBGPRINT(RT_DEBUG_TRACE, "Set::unknown IOCTL's subcmd = 0x%08x\n", cmd);
+			Status = -EOPNOTSUPP;
+			break;
+	}
+
+	return Status;
+}
+
+
+
+UCHAR	BCAST[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+/*
+	========================================================================
+	
+	Routine Description:
+		Add WPA key process
+
+	Arguments:
+		pAdapter						Pointer to our adapter
+		pBuf							Pointer to the where the key stored
+
+	Return Value:
+		NDIS_SUCCESS					Add key successfully
+
+	Note:
+		
+	========================================================================
+*/
+NDIS_STATUS	RTMPWPAAddKeyProc(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PVOID			pBuf)
+{
+	PNDIS_802_11_KEY	pKey;
+	ULONG				KeyIdx;
+	NDIS_STATUS			Status;
+	
+	PUCHAR		pTxMic, pRxMic;
+	BOOLEAN 	bTxKey; 		// Set the key as transmit key
+	BOOLEAN 	bPairwise;		// Indicate the key is pairwise key
+	BOOLEAN 	bKeyRSC;		// indicate the receive  SC set by KeyRSC value.
+								// Otherwise, it will set by the NIC.
+	BOOLEAN 	bAuthenticator; // indicate key is set by authenticator.
+	INT 		i, PairwiseIdx;
+	TXRX_CSR0_STRUC  TxRxCsr0;
+	UCHAR		ZeroKey[4 * 16];
+	
+	DBGPRINT(RT_DEBUG_TEMP,"===>RTMPWPAAddKeyProc\n" );
+	pKey = (PNDIS_802_11_KEY) pBuf;
+	KeyIdx = pKey->KeyIndex & 0xff;
+	DBGPRINT(RT_DEBUG_TEMP,"RTMPWPAAddKeyProc KeyIdx = %x\n", pKey->KeyIndex );
+	// Bit 31 of Add-key, Tx Key
+	bTxKey		   = (pKey->KeyIndex & 0x80000000) ? TRUE : FALSE;
+	// Bit 30 of Add-key PairwiseKey
+	bPairwise	   = (pKey->KeyIndex & 0x40000000) ? TRUE : FALSE;
+	// Bit 29 of Add-key KeyRSC
+	bKeyRSC 	   = (pKey->KeyIndex & 0x20000000) ? TRUE : FALSE;
+	// Bit 28 of Add-key Authenticator
+	bAuthenticator = (pKey->KeyIndex & 0x10000000) ? TRUE : FALSE;
+
+	memset(ZeroKey, 0, 4 * 16);
+	// 1. Check Group / Pairwise Key
+	if (bPairwise)	// Pairwise Key
+	{
+		// 1. KeyIdx must be 0, otherwise, return NDIS_STATUS_INVALID_DATA
+		if (KeyIdx != 0)
+			return(NDIS_STATUS_FAILURE);
+		
+		// 2. Check bTx, it must be true, otherwise, return NDIS_STATUS_INVALID_DATA
+		if (bTxKey == FALSE)
+			return(NDIS_STATUS_FAILURE);
+
+		// 3. If BSSID is not all 0xff, return NDIS_STATUS_INVALID_DATA
+		if ((memcmp(pKey->BSSID, BCAST, 6) == 0))
+			return(NDIS_STATUS_FAILURE);
+			
+		// 4. Selct RxMic / TxMic based on Supp / Authenticator
+		if (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+		{
+			// for WPA-None Tx, Rx MIC is the same
+			pTxMic = (PUCHAR) (&pKey->KeyMaterial) + 16;
+			pRxMic = pTxMic;
+		}
+		else if (bAuthenticator == TRUE)
+		{
+			pTxMic = (PUCHAR) (&pKey->KeyMaterial) + 16;
+			pRxMic = (PUCHAR) (&pKey->KeyMaterial) + 24;
+		}
+		else
+		{
+			pRxMic = (PUCHAR) (&pKey->KeyMaterial) + 16;
+			pTxMic = (PUCHAR) (&pKey->KeyMaterial) + 24;
+		}
+		
+		// 5. Find the old entry to overwrite or find an empty entry.
+		PairwiseIdx = 0;
+		for (i = 0; i < PAIRWISE_KEY_NO; i++)
+		{
+			if (pAdapter->PortCfg.PairwiseKey[i].KeyLen == 0)
+			{
+				PairwiseIdx = i;
+				break;
+			}
+			else if ((memcmp(pAdapter->PortCfg.PairwiseKey[i].BssId, pKey->BSSID, 6) == 0))
+			{
+				// Found the old entry
+				PairwiseIdx = i;
+				break;
+			}
+		}
+		// If there is no match and no empty pairwise key, we have to replace an old one
+		// which will be index 0 in our case.
+
+		// 6. Check RxTsc
+		if (bKeyRSC == TRUE)
+		{
+			memcpy(&pAdapter->PortCfg.PairwiseKey[PairwiseIdx].RxTsc, &pKey->KeyRSC, 6);
+		}
+		else
+		{
+			memset(pAdapter->PortCfg.PairwiseKey[PairwiseIdx].RxTsc, 0, 6);
+		}
+		
+		// 7. Copy information into Pairwise Key structure.
+		// pKey->KeyLength will include TxMic and RxMic, therefore, we use 16 bytes hardcoded.
+		pAdapter->PortCfg.PairwiseKey[PairwiseIdx].KeyLen = 16;		
+		memset(pAdapter->PortCfg.PairwiseKey[PairwiseIdx].Key, 0, 16);
+		memcpy(pAdapter->PortCfg.PairwiseKey[PairwiseIdx].Key, &pKey->KeyMaterial, 16);
+		memcpy(pAdapter->PortCfg.PairwiseKey[PairwiseIdx].RxMic, pRxMic, 8);
+		memcpy(pAdapter->PortCfg.PairwiseKey[PairwiseIdx].TxMic, pTxMic, 8);
+		memcpy(pAdapter->PortCfg.PairwiseKey[PairwiseIdx].BssId, pKey->BSSID, 6);
+		// Init TxTsc to one based on WiFi WPA specs
+		pAdapter->PortCfg.PairwiseKey[PairwiseIdx].TxTsc[0] = 1;
+		pAdapter->PortCfg.PairwiseKey[PairwiseIdx].TxTsc[1] = 0;
+		pAdapter->PortCfg.PairwiseKey[PairwiseIdx].TxTsc[2] = 0;
+		pAdapter->PortCfg.PairwiseKey[PairwiseIdx].TxTsc[3] = 0;
+		pAdapter->PortCfg.PairwiseKey[PairwiseIdx].TxTsc[4] = 0;
+		pAdapter->PortCfg.PairwiseKey[PairwiseIdx].TxTsc[5] = 0;
+
+		RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &TxRxCsr0.value);
+		TxRxCsr0.field.KeyID |= (0x01 << KeyIdx);
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, TxRxCsr0.value);
+		RTUSBMultiWriteMAC(pAdapter, (USHORT)(SEC_CSR0 + KeyIdx * 0x10), pAdapter->PortCfg.PairwiseKey[PairwiseIdx].Key, pAdapter->PortCfg.PairwiseKey[PairwiseIdx].KeyLen);
+
+		Status = NDIS_STATUS_SUCCESS;
+		
+		DBGPRINT(RT_DEBUG_TEMP,"Add Pairwise TKIP Key %d= ",PairwiseIdx);
+		DBGPRINT(RT_DEBUG_TEMP,"Pairwise TKIP Key = ");
+		for (i = 0; i < 16; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO,"%02x:", pAdapter->PortCfg.PairwiseKey[PairwiseIdx].Key[i]);
+		}
+		DBGPRINT_RAW(RT_DEBUG_INFO,"\n");						
+		DBGPRINT(RT_DEBUG_INFO,"TKIP Rx MIC Key = ");
+		for (i = 0; i < 8; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO,"%02x:", pAdapter->PortCfg.PairwiseKey[PairwiseIdx].RxMic[i]);
+		}
+		DBGPRINT_RAW(RT_DEBUG_INFO,"\n");						
+		DBGPRINT(RT_DEBUG_INFO,"TKIP Tx MIC Key = ");
+		for (i = 0; i < 8; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO,"%02x:", pAdapter->PortCfg.PairwiseKey[PairwiseIdx].TxMic[i]);
+		}
+		DBGPRINT_RAW(RT_DEBUG_INFO,"\n");						
+		DBGPRINT(RT_DEBUG_INFO,"TKIP RxTSC = ");
+		for (i = 0; i < 6; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO,"%02x:", pAdapter->PortCfg.PairwiseKey[PairwiseIdx].RxTsc[i]);
+		}
+		DBGPRINT_RAW(RT_DEBUG_INFO,"\n");						
+		DBGPRINT(RT_DEBUG_INFO,"BSSID:%02x:%02x:%02x:%02x:%02x:%02x \n",
+			pKey->BSSID[0],pKey->BSSID[1],pKey->BSSID[2],pKey->BSSID[3],pKey->BSSID[4],pKey->BSSID[5]);
+		
+	}
+	else	// Group Key
+	{
+		// 1. Check BSSID, if not current BSSID or Bcast, return NDIS_STATUS_INVALID_DATA
+		//if ((memcmp(&pKey->BSSID, &BCAST, 6) != 0) &&
+		//	(memcmp(&pKey->BSSID, &pAdapter->PortCfg.Bssid, 6) != 0))
+		//	return(NDIS_STATUS_FAILURE);
+
+		// 2. Check Key index for supported Group Key
+		if (KeyIdx >= GROUP_KEY_NO)
+			return(NDIS_STATUS_FAILURE);
+		
+		// 3. Set as default Tx Key if bTxKey is TRUE
+		if (bTxKey == TRUE)
+			pAdapter->PortCfg.DefaultKeyId = (UCHAR) KeyIdx;
+		
+		// 4. Selct RxMic / TxMic based on Supp / Authenticator
+		if (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+		{
+			// for WPA-None Tx, Rx MIC is the same
+			pTxMic = (PUCHAR) (&pKey->KeyMaterial) + 16;
+			pRxMic = pTxMic;
+		}
+		else if (bAuthenticator == TRUE)
+		{
+			pTxMic = (PUCHAR) (&pKey->KeyMaterial) + 16;
+			pRxMic = (PUCHAR) (&pKey->KeyMaterial) + 24;
+		}
+		else
+		{
+			pRxMic = (PUCHAR) (&pKey->KeyMaterial) + 16;
+			pTxMic = (PUCHAR) (&pKey->KeyMaterial) + 24;
+		}
+		
+		// 5. Check RxTsc
+		if (bKeyRSC == TRUE)
+		{
+			memcpy(pAdapter->PortCfg.GroupKey[KeyIdx].RxTsc, &pKey->KeyRSC, 6);
+		}
+		else
+		{
+			memset(pAdapter->PortCfg.GroupKey[KeyIdx].RxTsc, 0, 6);
+		}
+
+		// 6. Copy information into Group Key structure.
+		// pKey->KeyLength will include TxMic and RxMic, therefore, we use 16 bytes hardcoded.
+		pAdapter->PortCfg.GroupKey[KeyIdx].KeyLen = 16;		
+		memset(pAdapter->PortCfg.GroupKey[KeyIdx].Key, 0, 16);
+		memcpy(pAdapter->PortCfg.GroupKey[KeyIdx].Key, &pKey->KeyMaterial, 16);
+		memcpy(pAdapter->PortCfg.GroupKey[KeyIdx].RxMic, pRxMic, 8);
+		memcpy(pAdapter->PortCfg.GroupKey[KeyIdx].TxMic, pTxMic, 8);
+		memcpy(pAdapter->PortCfg.GroupKey[KeyIdx].BssId, pKey->BSSID, 6);
+		// Init TxTsc to one based on WiFi WPA specs
+		pAdapter->PortCfg.GroupKey[KeyIdx].TxTsc[0] = 1;
+		pAdapter->PortCfg.GroupKey[KeyIdx].TxTsc[1] = 0;
+		pAdapter->PortCfg.GroupKey[KeyIdx].TxTsc[2] = 0;
+		pAdapter->PortCfg.GroupKey[KeyIdx].TxTsc[3] = 0;
+		pAdapter->PortCfg.GroupKey[KeyIdx].TxTsc[4] = 0;
+		pAdapter->PortCfg.GroupKey[KeyIdx].TxTsc[5] = 0;
+		// 802.1x port control
+		pAdapter->PortCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+
+		RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &TxRxCsr0.value);
+		// a. If BSSID is broadcast, remove all group keys indexed
+		TxRxCsr0.field.KeyID |= (0x01 << KeyIdx);
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, TxRxCsr0.value);
+		if (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+		{
+			RTUSBMultiWriteMAC(pAdapter, (USHORT)(SEC_CSR0 + KeyIdx * 0x10), pAdapter->PortCfg.GroupKey[KeyIdx].Key, 16);
+		}
+		else
+		{
+			RTUSBMultiWriteMAC(pAdapter, (USHORT)(SEC_CSR0 + KeyIdx * 0x10), pAdapter->PortCfg.GroupKey[KeyIdx].Key, 16);
+		}
+		DBGPRINT(RT_DEBUG_TRACE, "AddGroupKey::Use Hardware to decript broadcast/Mulitcast packet.\n");
+
+		Status = NDIS_STATUS_SUCCESS;
+		// c. For WEP compatibility
+		if (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+		{
+			pAdapter->PortCfg.SharedKey[KeyIdx].KeyLen = 0;
+		}
+
+		DBGPRINT(RT_DEBUG_ERROR,"Group TKIP Key =\n ");
+		for (i = 0; i < 16; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_ERROR,"%02x:", pAdapter->PortCfg.GroupKey[KeyIdx].Key[i]);
+		}
+		DBGPRINT_RAW(RT_DEBUG_ERROR,"\n");						
+		DBGPRINT(RT_DEBUG_TRACE,"TKIP Rx MIC Key = \n");
+		for (i = 0; i < 8; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_TRACE,"%02x:", pAdapter->PortCfg.GroupKey[KeyIdx].RxMic[i]);
+		}
+		DBGPRINT_RAW(RT_DEBUG_TRACE,"\n");						
+		DBGPRINT(RT_DEBUG_TRACE,"TKIP Tx MIC Key = \n");
+		for (i = 0; i < 8; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_TRACE,"%02x:", pAdapter->PortCfg.GroupKey[KeyIdx].TxMic[i]);
+		}
+		DBGPRINT_RAW(RT_DEBUG_TRACE,"\n");						
+		DBGPRINT(RT_DEBUG_TRACE,"TKIP RxTSC =\n ");
+		for (i = 0; i < 6; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_TRACE,"%02x:", pAdapter->PortCfg.GroupKey[KeyIdx].RxTsc[i]);
+		}
+		DBGPRINT_RAW(RT_DEBUG_TRACE,"\n");						
+		DBGPRINT(RT_DEBUG_INFO,"BSSID:%02x:%02x:%02x:%02x:%02x:%02x \n",
+			pKey->BSSID[0],pKey->BSSID[1],pKey->BSSID[2],pKey->BSSID[3],pKey->BSSID[4],pKey->BSSID[5]);
+	
+		// For WEP compatibility, in case it use OID_ADD_KEY, not OID_ADD_WEP
+		if (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+		{
+			pAdapter->PortCfg.SharedKey[KeyIdx].KeyLen = (UCHAR) pKey->KeyLength;
+			memcpy(pAdapter->PortCfg.SharedKey[KeyIdx].Key, &pKey->KeyMaterial, pKey->KeyLength);
+		}
+	}
+	return (Status);
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+		Remove WPA Key process
+
+	Arguments:
+		pAdapter						Pointer to our adapter
+		pBuf							Pointer to the where the key stored
+
+	Return Value:
+		NDIS_SUCCESS					Add key successfully
+
+	Note:
+		
+	========================================================================
+*/
+NDIS_STATUS	RTMPWPARemoveKeyProc(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PVOID			pBuf)
+{
+	PNDIS_802_11_REMOVE_KEY	pKey;
+	ULONG					KeyIdx;
+	NDIS_STATUS				Status = NDIS_STATUS_FAILURE;
+	
+	BOOLEAN 	bTxKey; 		// Set the key as transmit key
+	BOOLEAN 	bPairwise;		// Indicate the key is pairwise key
+	BOOLEAN 	bKeyRSC;		// indicate the receive  SC set by KeyRSC value.
+								// Otherwise, it will set by the NIC.
+	BOOLEAN 	bAuthenticator; // indicate key is set by authenticator.
+	INT 		i;
+	USHORT		temp;
+	
+	pKey = (PNDIS_802_11_REMOVE_KEY) pBuf;
+	KeyIdx = pKey->KeyIndex & 0xff;
+	// Bit 31 of Add-key, Tx Key
+	bTxKey		   = (pKey->KeyIndex & 0x80000000) ? TRUE : FALSE;
+	// Bit 30 of Add-key PairwiseKey
+	bPairwise	   = (pKey->KeyIndex & 0x40000000) ? TRUE : FALSE;
+	// Bit 29 of Add-key KeyRSC
+	bKeyRSC 	   = (pKey->KeyIndex & 0x20000000) ? TRUE : FALSE;
+	// Bit 28 of Add-key Authenticator
+	bAuthenticator = (pKey->KeyIndex & 0x10000000) ? TRUE : FALSE;
+
+	// 1. If bTx is TRUE, return failure information
+	if (bTxKey == TRUE)
+		return(NDIS_STATUS_FAILURE);
+
+	// 2. Check Pairwise Key
+	if (bPairwise)
+	{
+		// a. If BSSID is broadcast, remove all pairwise keys.
+		if ((memcmp(&pKey->BSSID, &BCAST, 6) == 0))
+		{
+			for (i = 0; i < PAIRWISE_KEY_NO; i++)
+			{
+				pAdapter->PortCfg.PairwiseKey[i].KeyLen = 0;
+			}
+			Status = NDIS_STATUS_SUCCESS;
+//			RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &temp);
+//			RTUSBReadMACRegister(pAdapter, TXRX_CSR0, temp & 0xfdff);
+		}
+
+		// b. If not broadcast, remove the pairwise specified by BSSID
+		else
+		{
+			for (i = 0; i < PAIRWISE_KEY_NO; i++)
+			{
+				if ((memcmp(pAdapter->PortCfg.PairwiseKey[i].BssId, pKey->BSSID, 6) == 0))
+				{
+					pAdapter->PortCfg.PairwiseKey[i].KeyLen = 0;
+//					RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &temp);
+//					RTUSBReadMACRegister(pAdapter, TXRX_CSR0, temp & 0xfdff);
+					Status = NDIS_STATUS_SUCCESS;
+					break;
+				}
+			}
+			
+		}
+		// c. If no pairwise supported, delete Group Key 0.
+		//	  The will be false since we do support pairwise keys.
+	}
+	// 3. Group Key
+	else
+	{
+		// a. If BSSID is broadcast, remove all group keys indexed
+		if ((memcmp(&pKey->BSSID, &BCAST, 6) == 0))
+		{
+			pAdapter->PortCfg.GroupKey[KeyIdx].KeyLen = 0;
+			RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &temp);
+			RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, temp & (~(0x200 << KeyIdx)));
+			Status = NDIS_STATUS_SUCCESS;
+		}
+
+		// b. If BSSID matched, delte the group key indexed.
+		else if ((memcmp(pAdapter->PortCfg.GroupKey[KeyIdx].BssId, pKey->BSSID, 6) == 0))
+		{
+			pAdapter->PortCfg.GroupKey[KeyIdx].KeyLen = 0;
+			RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &temp);
+			RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, temp & (~(0x200 << KeyIdx)));
+			Status = NDIS_STATUS_SUCCESS;
+		}
+	}
+	
+	return (Status);
+}
+
+
+/*
+	========================================================================
+	
+	Routine Description:
+		Remove All WPA Keys
+
+	Arguments:
+		pAdapter						Pointer to our adapter
+
+	Return Value:
+		None
+
+	Note:
+		
+	========================================================================
+*/
+VOID	RTMPWPARemoveAllKeys(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	INT i;
+	USHORT	temp;
+
+	// For WPA-None, there is no need to remove it, since WinXP won't set it again after
+	// Link up. And it will be replaced if user changed it.
+	if (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+		return;
+	
+	for (i = 0; i < PAIRWISE_KEY_NO; i++)
+	{
+		pAdapter->PortCfg.PairwiseKey[i].KeyLen = 0;
+	}
+	
+	for (i = 0; i < GROUP_KEY_NO; i++)
+	{
+		pAdapter->PortCfg.GroupKey[i].KeyLen = 0;
+	}
+
+	RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &temp);
+	RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, temp & 0xe1ff);
+}
+
+/*
+	========================================================================
+	Routine Description:
+		Change NIC PHY mode. Re-association may be necessary. possible settings
+		include - PHY_11B, PHY_11BG_MIXED, PHY_11A, and PHY_11ABG_MIXED 
+
+	Arguments:
+		pAdapter - Pointer to our adapter
+		phymode  - 
+	========================================================================
+*/
+VOID	RTMPSetPhyMode(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	ULONG phymode)
+{
+	DBGPRINT(RT_DEBUG_ERROR,"RTMPSetPhyMode(=%d)\n", phymode);
+	
+	// the selected phymode must be supported by the RF IC encoded in E2PROM
+	if (pAdapter->PortCfg.RfType == RFIC_2426)
+	{
+		phymode = PHY_11B;
+	}
+	else if (pAdapter->PortCfg.RfType < RFIC_5222)
+	{
+		if (phymode == PHY_11A)
+			phymode = PHY_11BG_MIXED;
+	}
+		
+	// if no change, do nothing
+	if (pAdapter->PortCfg.PhyMode == phymode)
+		return;
+
+	pAdapter->PortCfg.PhyMode = (UCHAR)phymode;
+	BuildChannelList(pAdapter);
+	pAdapter->PortCfg.IbssConfig.Channel = FirstChannel(pAdapter);
+	pAdapter->PortCfg.Channel = FirstChannel(pAdapter);
+	AsicSwitchChannel(pAdapter, pAdapter->PortCfg.Channel);
+	AsicLockChannel(pAdapter, pAdapter->PortCfg.Channel);
+	
+	switch (phymode) {
+		case PHY_11B:
+	DBGPRINT(RT_DEBUG_TEMP,"PHY_11B\n");
+			pAdapter->PortCfg.IbssConfig.SupportedRates[0]	= 0x82;    // 1 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.IbssConfig.SupportedRates[1]	= 0x84;    // 2 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.IbssConfig.SupportedRates[2]	= 0x8B;    // 5.5 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.IbssConfig.SupportedRates[3]	= 0x96;    // 11 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.IbssConfig.SupportedRatesLen	= 4;
+			pAdapter->PortCfg.SupportedRates[0]  = 0x82;	// 1 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.SupportedRates[1]  = 0x84;	// 2 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.SupportedRates[2]  = 0x8B;	// 5.5 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.SupportedRates[3]  = 0x96;	// 11 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.SupportedRatesLen  = 4;
+			pAdapter->PortCfg.DesiredRates[0]  = 2; 	// 1 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[1]  = 4; 	// 2 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[2]  = 11;	// 5.5 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[3]  = 22;	// 11 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[4]  = 0;
+			pAdapter->PortCfg.DesiredRates[5]  = 0;
+			pAdapter->PortCfg.DesiredRates[6]  = 0;
+			pAdapter->PortCfg.DesiredRates[7]  = 0;
+			pAdapter->PortCfg.DesiredRates[8]  = 0;
+			pAdapter->PortCfg.DesiredRates[9]  = 0;
+			pAdapter->PortCfg.DesiredRates[10] = 0;
+			pAdapter->PortCfg.DesiredRates[11] = 0;
+			break;
+			
+		case PHY_11BG_MIXED:
+		case PHY_11ABG_MIXED:
+	DBGPRINT(RT_DEBUG_TEMP,"PHY_11BG_MIXED\n");
+			pAdapter->PortCfg.IbssConfig.SupportedRates[0]	= 0x82;    // 1 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.IbssConfig.SupportedRates[1]	= 0x84;    // 2 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.IbssConfig.SupportedRates[2]	= 0x8B;    // 5.5 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.IbssConfig.SupportedRates[3]	= 0x96;    // 11 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.IbssConfig.SupportedRates[4]	= 0x8C;    // 6 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.IbssConfig.SupportedRates[5]	= 0x12;    // 9 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.IbssConfig.SupportedRates[6]	= 0x98;    // 12 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.IbssConfig.SupportedRates[7]	= 0x24;    // 18 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.IbssConfig.SupportedRates[8]	= 0xb0;    // 24 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.IbssConfig.SupportedRates[9]	= 0x48;    // 36 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.IbssConfig.SupportedRates[10] = 0x60;    // 48 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.IbssConfig.SupportedRates[11] = 0x6c;    // 54 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.IbssConfig.SupportedRatesLen	= 12;
+			pAdapter->PortCfg.SupportedRates[0]  = 0x82;	// 1 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.SupportedRates[1]  = 0x84;	// 2 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.SupportedRates[2]  = 0x8B;	// 5.5 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.SupportedRates[3]  = 0x96;	// 11 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.SupportedRates[4]  = 0x8C;	// 6 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.SupportedRates[5]  = 0x12;	// 9 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.SupportedRates[6]  = 0x98;	// 12 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.SupportedRates[7]  = 0x24;	// 18 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.SupportedRates[8]  = 0xb0;	// 24 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.SupportedRates[9]  = 0x48;	// 36 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.SupportedRates[10] = 0x60;	// 48 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.SupportedRates[11] = 0x6c;	// 54 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.SupportedRatesLen  = 12;
+			pAdapter->PortCfg.DesiredRates[0]  = 2; 	// 1 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[1]  = 4; 	// 2 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[2]  = 11;	// 5.5 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[3]  = 22;	// 11 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[4]  = 12;	// 6 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[5]  = 18;	// 9 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[6]  = 24;	// 12 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[7]  = 36;	// 18 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[8]  = 48;	// 24 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[9]  = 72;	// 36 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[10] = 96;	// 48 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[11] = 108;	// 54 mbps, in units of 0.5 Mbps
+			break;
+			
+		case PHY_11A:
+	DBGPRINT(RT_DEBUG_TEMP,"PHY_11A\n");
+			pAdapter->PortCfg.IbssConfig.SupportedRates[0]	= 0x8C;    // 6 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.IbssConfig.SupportedRates[1]	= 0x12;    // 9 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.IbssConfig.SupportedRates[2]	= 0x98;    // 12 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.IbssConfig.SupportedRates[3]	= 0x24;    // 18 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.IbssConfig.SupportedRates[4]	= 0xb0;    // 24 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.IbssConfig.SupportedRates[5]	= 0x48;    // 36 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.IbssConfig.SupportedRates[6]	= 0x60;    // 48 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.IbssConfig.SupportedRates[7]	= 0x6c;    // 54 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.IbssConfig.SupportedRates[8]	= 0;
+			pAdapter->PortCfg.IbssConfig.SupportedRates[9]	= 0;
+			pAdapter->PortCfg.IbssConfig.SupportedRates[10] = 0;
+			pAdapter->PortCfg.IbssConfig.SupportedRates[11] = 0;
+			pAdapter->PortCfg.IbssConfig.SupportedRatesLen	= 8;
+			pAdapter->PortCfg.SupportedRates[0]  = 0x8C;	// 6 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.SupportedRates[1]  = 0x12;	// 9 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.SupportedRates[2]  = 0x98;	// 12 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.SupportedRates[3]  = 0x24;	// 18 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.SupportedRates[4]  = 0xb0;	// 24 mbps, in units of 0.5 Mbps, basic rate
+			pAdapter->PortCfg.SupportedRates[5]  = 0x48;	// 36 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.SupportedRates[6]  = 0x60;	// 48 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.SupportedRates[7]  = 0x6c;	// 54 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.SupportedRates[8]  = 0;
+			pAdapter->PortCfg.SupportedRates[9]  = 0;
+			pAdapter->PortCfg.SupportedRates[10] = 0;
+			pAdapter->PortCfg.SupportedRates[11] = 0;
+			pAdapter->PortCfg.SupportedRatesLen  = 8;
+			pAdapter->PortCfg.DesiredRates[0]  = 12;	// 6 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[1]  = 18;	// 9 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[2]  = 24;	// 12 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[3]  = 36;	// 18 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[4]  = 48;	// 24 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[5]  = 72;	// 36 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[6]  = 96;	// 48 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[7]  = 108;	// 54 mbps, in units of 0.5 Mbps
+			pAdapter->PortCfg.DesiredRates[8]  = 0;
+			pAdapter->PortCfg.DesiredRates[9]  = 0;
+			pAdapter->PortCfg.DesiredRates[10] = 0;
+			pAdapter->PortCfg.DesiredRates[11] = 0;
+			break;
+			
+		default:
+	DBGPRINT(RT_DEBUG_TEMP,"default\n");
+			break;
+	}
+	
+	MlmeUpdateTxRates(pAdapter, FALSE);
+	AsicSetSlotTime(pAdapter, FALSE);
+	MakeIbssBeacon(pAdapter);	 // supported rates may change
+}
+
+
+VOID	RT2570SetDesiredRates(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	LONG			Rates)
+{
+#if 1
+	NDIS_802_11_RATES aryRates;
+	ULONG	rate_mapping[12] = {1, 2, 5, 11, 6, 9, 12, 18, 24, 36, 48, 54}; //according to README
+	DBGPRINT(RT_DEBUG_TEMP, "1.RT2570SetDesiredRates::(Rates=%d)\n",	Rates );
+	
+	DBGPRINT(RT_DEBUG_ERROR, "2.RT2570SetDesiredRates::(Rates=%d)\n",	Rates );
+	if (Rates < 13 && (Rates > 0))
+		Rates = rate_mapping[Rates-1] * 1000000;
+	
+	memset(&aryRates, 0x00, sizeof(NDIS_802_11_RATES));
+	switch (pAdapter->PortCfg.PhyMode)
+	{
+		case PHY_11A: // A only
+			switch (Rates)
+			{
+				case 6000000: //6M
+					aryRates[0] = 0x0c; // 6M
+					break;
+				case 9000000: //9M
+					aryRates[0] = 0x12; // 9M
+					break;
+				case 12000000: //12M
+					aryRates[0] = 0x18; // 12M
+					break;
+				case 18000000: //18M
+					aryRates[0] = 0x24; // 18M
+					break;
+				case 24000000: //24M
+					aryRates[0] = 0x30; // 24M
+					break;
+				case 36000000: //36M
+					aryRates[0] = 0x48; // 36M
+					break;
+				case 48000000: //48M
+					aryRates[0] = 0x60; // 48M
+					break;
+				case 54000000: //54M
+					aryRates[0] = 0x6c; // 54M
+					break;
+				case -1: //Auto
+				default:
+					aryRates[0] = 0x6c; // 54Mbps
+					aryRates[1] = 0x60; // 48Mbps
+					aryRates[2] = 0x48; // 36Mbps
+					aryRates[3] = 0x30; // 24Mbps
+					aryRates[4] = 0x24; // 18M
+					aryRates[5] = 0x18; // 12M
+					aryRates[6] = 0x12; // 9M
+					aryRates[7] = 0x0c; // 6M
+					break;
+			}
+			break;
+		case PHY_11B: // B only
+			switch (Rates)
+			{
+				case 1000000: //6M
+				aryRates[0] = 0x02;
+					break;
+				case 2000000: //6M
+					aryRates[0] = 0x04;
+					break;
+				case 5000000: //5.5M
+					aryRates[0] = 0x0b; // 5.5M
+					break;
+				case 11000000: //11M
+					aryRates[0] = 0x16; // 11M
+					break;
+				case -1: //Auto
+				default:
+						aryRates[0] = 0x16; // 11Mbps
+						aryRates[1] = 0x0b; // 5.5Mbps
+						aryRates[2] = 0x04; // 2Mbps
+						aryRates[3] = 0x02; // 1Mbps
+					break;
+			}
+			break;
+		case PHY_11BG_MIXED: // B/G Mixed
+		case PHY_11ABG_MIXED: // A/B/G Mixed
+		default:
+			switch (Rates)
+			{
+				case 1000000: //6M
+					aryRates[0] = 0x02;
+					break;
+				case 2000000: //6M
+					aryRates[0] = 0x04;
+					break;
+				case 5000000: //5.5M
+					aryRates[0] = 0x0b; // 5.5M
+					break;
+				case 11000000: //11M
+					aryRates[0] = 0x16; // 11M
+					break;
+				case 6000000: //6M
+					aryRates[0] = 0x0c; // 6M
+					break;
+				case 9000000: //9M
+					aryRates[0] = 0x12; // 9M
+					break;
+				case 12000000: //12M
+					aryRates[0] = 0x18; // 12M
+					break;
+				case 18000000: //18M
+					aryRates[0] = 0x24; // 18M
+					break;
+				case 24000000: //24M
+					aryRates[0] = 0x30; // 24M
+					break;
+				case 36000000: //36M
+					aryRates[0] = 0x48; // 36M
+					break;
+				case 48000000: //48M
+					aryRates[0] = 0x60; // 48M
+					break;
+				case 54000000: //54M
+					aryRates[0] = 0x6c; // 54M
+					break;
+				case -1: //Auto
+				default:
+					if (pAdapter->PortCfg.PhyMode == PHY_11B)
+					{ //B Only
+						aryRates[0] = 0x16; // 11Mbps
+						aryRates[1] = 0x0b; // 5.5Mbps
+						aryRates[2] = 0x04; // 2Mbps
+						aryRates[3] = 0x02; // 1Mbps
+					}
+					else
+					{ //(B/G) Mixed or (A/B/G) Mixed
+						aryRates[0] = 0x6c; // 54Mbps
+						aryRates[1] = 0x60; // 48Mbps
+						aryRates[2] = 0x48; // 36Mbps
+						aryRates[3] = 0x30; // 24Mbps
+						aryRates[4] = 0x16; // 11Mbps
+						aryRates[5] = 0x0b; // 5.5Mbps
+						aryRates[6] = 0x04; // 2Mbps
+						aryRates[7] = 0x02; // 1Mbps
+					}
+					break;
+			}
+			break;
+	}
+
+	memset(pAdapter->PortCfg.DesiredRates, 0, MAX_LEN_OF_SUPPORTED_RATES);
+	memcpy(pAdapter->PortCfg.DesiredRates, &aryRates, sizeof(NDIS_802_11_RATES));
+	DBGPRINT(RT_DEBUG_TEMP, " RTMPSetDesiredRates (%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x)\n",
+		pAdapter->PortCfg.DesiredRates[0],pAdapter->PortCfg.DesiredRates[1],
+		pAdapter->PortCfg.DesiredRates[2],pAdapter->PortCfg.DesiredRates[3],
+		pAdapter->PortCfg.DesiredRates[4],pAdapter->PortCfg.DesiredRates[5],
+		pAdapter->PortCfg.DesiredRates[6],pAdapter->PortCfg.DesiredRates[7] );
+	// Changing DesiredRate may affect the MAX TX rate we used to TX frames out
+	MlmeUpdateTxRates(pAdapter, FALSE);
+#endif
+}
+
+INT Set_R17_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+
+	ULONG								TUNN;
+	UINT	i = 0;
+	UCHAR	Value = 0x0;
+	int 								success = TRUE;
+	
+	TUNN = simple_strtol(arg, 0, 10);
+	i = (TUNN/100);
+	Value = TUNN%100;
+	DBGPRINT(RT_DEBUG_TEMP, "Set_R17_Proc -->TUNN = 0x%x id = %d, Value=ox%x!!!\n",TUNN,i,Value);
+	RTUSBWriteBBPRegister(pAdapter, i, Value);
+
+	return success;
+}
+INT Read_R17_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+
+{
+
+	UINT	i = 0;
+	UCHAR	Value = 0x0;
+	int 								success = TRUE;
+	for ( i = 0 ; i<70; i++)
+	{
+		
+		 RTUSBReadBBPRegister(pAdapter, i, &Value);
+		DBGPRINT(RT_DEBUG_TEMP,"Read_BBP_Proc R%d = 0x%x\n",i,Value);
+	}
+	return success;
+
+}
+/* 
+	==========================================================================
+	Description:
+		Set Country Region
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_CountryRegion_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	ULONG								region;
+	int 								success = TRUE;
+
+	region = simple_strtol(arg, 0, 10);
+	if( (region >= REGION_MIN) && (region <= REGION_MAX) )
+	{
+		pAdapter->PortCfg.CountryRegion = (UCHAR) region;
+		DBGPRINT(RT_DEBUG_TRACE, "Set_CountryRegion_Proc::(CountryRegion=%d)\n", pAdapter->PortCfg.CountryRegion);
+		printk("Set_CountryRegion_Proc::(CountryRegion=%d)\n", pAdapter->PortCfg.CountryRegion);
+	}
+	else
+		success = FALSE;
+
+	return success;
+}
+/* 
+	==========================================================================
+	Description:
+		Set SSID
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_SSID_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	int 								success = TRUE;
+	NDIS_802_11_SSID					Ssid, *pSsid=NULL;
+	BOOLEAN 							StateMachineTouched = FALSE;
+	if( strlen(arg) <= MAX_LEN_OF_SSID)
+	{
+		memset(&Ssid, 0, sizeof(NDIS_802_11_SSID));
+		memcpy(Ssid.Ssid, arg, strlen(arg));
+		Ssid.SsidLength = strlen(arg);
+		pSsid = &Ssid;
+
+		if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+		{
+			MlmeRestartStateMachine(pAdapter);
+			MlmePostRestartStateMachine(pAdapter);
+			DBGPRINT(RT_DEBUG_TEMP, "!!! MLME busy, reset MLME state machine !!!\n");
+		}
+		 // tell CNTL state machine to call NdisMSetInformationComplete() after completing
+		// this request, because this request is initiated by NDIS.
+		pAdapter->Mlme.CntlAux.CurrReqIsFromNdis = FALSE; 
+
+		MlmeEnqueue(pAdapter, 
+					MLME_CNTL_STATE_MACHINE, 
+					OID_802_11_SSID,
+					sizeof(NDIS_802_11_SSID),
+					(VOID *)pSsid);
+
+		StateMachineTouched = TRUE;
+		DBGPRINT(RT_DEBUG_TEMP, "Set_SSID_Proc::(Len=%d,Ssid=%s)\n", pAdapter->PortCfg.SsidLen, pAdapter->PortCfg.Ssid);
+	}
+	else
+		success = FALSE;
+
+	RTUSBUp(pAdapter, (&(pAdapter->mlme_semaphore)));
+	return success;
+
+}
+/* 
+	==========================================================================
+	Description:
+		Set Wireless Mode
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_WirelessMode_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	int 								success = TRUE;
+#if 0
+	ULONG								WirelessMode;
+	WirelessMode = simple_strtol(arg, 0, 10);
+
+	if ((WirelessMode == PHY_11BG_MIXED) || (WirelessMode == PHY_11B) ||
+		(WirelessMode == PHY_11A) || (WirelessMode == PHY_11ABG_MIXED))
+	{
+		RTMPSetPhyMode(pAdapter, WirelessMode);
+		DBGPRINT(RT_DEBUG_TEMP, "Set_WirelessMode_Proc::(=%d)\n", WirelessMode);
+	}
+	else
+		success = FALSE;
+#endif
+	return success;
+}
+/* 
+	==========================================================================
+	Description:
+		Set TxRate
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_TxRate_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	int 								success = TRUE;
+#if 0		
+	ULONG								TxRate;
+	ULONG	rate_mapping[12] = {1, 2, 5, 11, 6, 9, 12, 18, 24, 36, 48, 54}; //according to README
+	TxRate = simple_strtol(arg, 0, 10);
+		DBGPRINT(RT_DEBUG_TEMP, "Set_TxRate_Proc::(TxRate=%d)\n", TxRate);
+	if (TxRate > 12)
+		return FALSE;
+	
+	if (TxRate == 0)
+		RT2570SetDesiredRates(pAdapter, -1);
+	else
+		RT2570SetDesiredRates(pAdapter, (LONG) (rate_mapping[TxRate-1] * 1000000));
+#endif
+
+	return success;
+}
+/* 
+	==========================================================================
+	Description:
+		Set Channel
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_Channel_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	int 								success = TRUE;
+	UCHAR								Channel;
+
+	Channel = (UCHAR) simple_strtol(arg, 0, 10);
+
+	if (ChannelSanity(pAdapter, Channel) == TRUE)
+	{
+		pAdapter->PortCfg.Channel = Channel;
+		DBGPRINT(RT_DEBUG_TRACE, "Set_Channel_Proc::(Channel=%d)\n", Channel);
+	}
+	else
+		success = FALSE;
+
+	return success;
+}
+
+/* 
+	==========================================================================
+	Description:
+		Set 11B/11G Protection
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_BGProtection_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+
+{
+	switch (simple_strtol(arg, 0, 10))
+	{
+		case 0: //AUTO
+			pAdapter->PortCfg.UseBGProtection = 0;
+			break;
+		case 1: //Always On
+			pAdapter->PortCfg.UseBGProtection = 1;
+			break;
+		case 2: //Always OFF
+			pAdapter->PortCfg.UseBGProtection = 2;
+			break;		
+		default:  //Invalid argument 
+			return FALSE;
+	}
+	DBGPRINT(RT_DEBUG_TEMP, "Set_BGProtection_Proc::(BGProtection=%d)\n", pAdapter->PortCfg.UseBGProtection);
+
+	return TRUE;
+}
+/* 
+	==========================================================================
+	Description:
+		Set TxPreamble
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_TxPreamble_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+#if 0
+	RT_802_11_PREAMBLE					Preamble;
+	Preamble = simple_strtol(arg, 0, 10);
+	switch (Preamble)
+	{
+		case Rt802_11PreambleShort:
+			pAdapter->PortCfg.WindowsTxPreamble = Preamble;
+			MlmeSetTxPreamble(pAdapter, Rt802_11PreambleShort);
+			break;
+		case Rt802_11PreambleLong:
+		case Rt802_11PreambleAuto:
+			// if user wants AUTO, initialize to LONG here, then change according to AP's
+			// capability upon association.
+			pAdapter->PortCfg.WindowsTxPreamble = Preamble;
+			MlmeSetTxPreamble(pAdapter, Rt802_11PreambleLong);
+			break;
+		default: //Invalid argument 
+			return FALSE;
+	}
+
+	DBGPRINT(RT_DEBUG_TEMP, "Set_TxPreamble_Proc::(TxPreamble=%d)\n", Preamble);
+#endif
+
+	return TRUE;
+}
+/* 
+	==========================================================================
+	Description:
+		Set RTS Threshold
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_RTSThreshold_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	NDIS_802_11_RTS_THRESHOLD			RtsThresh;
+
+	RtsThresh = simple_strtol(arg, 0, 10);
+
+	if((RtsThresh > 0) && (RtsThresh <= MAX_RTS_THRESHOLD))
+		pAdapter->PortCfg.RtsThreshold = (USHORT)RtsThresh;
+	else if (RtsThresh == 0)
+		pAdapter->PortCfg.RtsThreshold = MAX_RTS_THRESHOLD;
+	else
+		return FALSE;
+
+	DBGPRINT(RT_DEBUG_TEMP, "Set_RTSThreshold_Proc::(RTSThreshold=%d)\n", pAdapter->PortCfg.RtsThreshold);
+	return TRUE;
+}
+/* 
+	==========================================================================
+	Description:
+		Set Fragment Threshold
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_FragThreshold_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	NDIS_802_11_FRAGMENTATION_THRESHOLD 	FragThresh;
+
+	FragThresh = simple_strtol(arg, 0, 10);
+
+	if ( (FragThresh >= MIN_FRAG_THRESHOLD) && (FragThresh <= MAX_FRAG_THRESHOLD))
+		pAdapter->PortCfg.FragmentThreshold = (USHORT)FragThresh;
+	else if (FragThresh == 0)
+		pAdapter->PortCfg.FragmentThreshold = MAX_FRAG_THRESHOLD;
+	else
+		return FALSE; //Invalid argument 
+
+	if (pAdapter->PortCfg.FragmentThreshold == MAX_FRAG_THRESHOLD)
+		pAdapter->PortCfg.bFragmentZeroDisable = TRUE;
+	else
+		pAdapter->PortCfg.bFragmentZeroDisable = FALSE;
+
+	DBGPRINT(RT_DEBUG_TEMP, "Set_FragThreshold_Proc::(FragThreshold=%d)\n", FragThresh);
+
+	return TRUE;
+}
+/* 
+	==========================================================================
+	Description:
+		Set TxBurst
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_TxBurst_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	ULONG								TxBurst;
+
+	TxBurst = simple_strtol(arg, 0, 10);
+
+	if (TxBurst == 1)
+		pAdapter->PortCfg.EnableTxBurst = TRUE;
+	else if (TxBurst == 0)
+		pAdapter->PortCfg.EnableTxBurst = FALSE;
+	else
+		return FALSE;  //Invalid argument 
+	
+	DBGPRINT(RT_DEBUG_TEMP, "Set_TxBurst_Proc::(TxBurst=%d)\n", pAdapter->PortCfg.EnableTxBurst);
+
+	return TRUE;
+}
+/* 
+	==========================================================================
+	Description:
+		Set TurboRate Enable or Disable
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_TurboRate_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	ULONG								TurboRate;
+
+	TurboRate = simple_strtol(arg, 0, 10);
+
+	if (TurboRate == 1)
+		pAdapter->PortCfg.EnableTurboRate = TRUE;
+	else if (TurboRate == 0)
+		pAdapter->PortCfg.EnableTurboRate = FALSE;
+	else
+		return FALSE;  //Invalid argument 
+	
+	DBGPRINT(RT_DEBUG_TEMP, "Set_TurboRate_Proc::(TurboRate=%d)\n", pAdapter->PortCfg.EnableTurboRate);
+
+	return TRUE;
+}
+/* 
+	==========================================================================
+	Description:
+		Set Short Slot Time Enable or Disable
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_ShortSlot_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	ULONG								ShortSlot;
+
+	ShortSlot = simple_strtol(arg, 0, 10);
+
+	if (ShortSlot == 1)
+		pAdapter->PortCfg.UseShortSlotTime = TRUE;
+	else if (ShortSlot == 0)
+		pAdapter->PortCfg.UseShortSlotTime = FALSE;
+	else
+		return FALSE;  //Invalid argument 
+
+	DBGPRINT(RT_DEBUG_TEMP, "Set_ShortSlot_Proc::(ShortSlot=%d)\n", pAdapter->PortCfg.UseShortSlotTime);
+
+	return TRUE;
+}
+/* 
+	==========================================================================
+	Description:
+		Set Authentication mode
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_AuthMode_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	if ((strcmp(arg, "OPEN") == 0) || (strcmp(arg, "open") == 0))
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+	else if ((strcmp(arg, "SHARED") == 0) || (strcmp(arg, "shared") == 0))
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeShared;
+	else if ((strcmp(arg, "WPAPSK") == 0) || (strcmp(arg, "wpapsk") == 0))
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeWPAPSK;
+	else if ((strcmp(arg, "WPANONE") == 0) || (strcmp(arg, "wpanone") == 0))
+		pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeWPANone;
+	else
+		return FALSE;  
+
+	pAdapter->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+
+	DBGPRINT(RT_DEBUG_TEMP, "Set_AuthMode_Proc::(AuthMode=%d)\n", pAdapter->PortCfg.AuthMode);
+
+	return TRUE;
+}
+/* 
+	==========================================================================
+	Description:
+		Set Encryption Type
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_EncrypType_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	USHORT	Value;
+	if ((strcmp(arg, "NONE") == 0) || (strcmp(arg, "none") == 0))
+	{
+		pAdapter->PortCfg.WepStatus = Ndis802_11WEPDisabled;
+		RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &Value);
+		Value &= 0xfe00;
+		DBGPRINT(RT_DEBUG_INFO,"Set::NONERead  TXRX_CSR0  %x !!!!!!!!!!!!!!!!!\n",Value);
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, Value);
+	}
+	else if ((strcmp(arg, "WEP") == 0) || (strcmp(arg, "wep") == 0))
+	{
+		pAdapter->PortCfg.WepStatus = Ndis802_11Encryption1Enabled;
+		if ((pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen == 5) || (pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen == 10))
+			pAdapter->PortCfg.CipherAlg = CIPHER_WEP64;
+		else
+			pAdapter->PortCfg.CipherAlg = CIPHER_WEP128;
+			
+		RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &Value);
+		DBGPRINT(RT_DEBUG_TEMP,"Set::WEPRead  TXRX_CSR0  %x !!!!!!!!!!!!!!!!!\n",Value);
+		Value &= 0xfe00;
+		Value |= ((LENGTH_802_11 << 3) | (pAdapter->PortCfg.CipherAlg));
+		DBGPRINT(RT_DEBUG_TEMP,"Set::WEPRead  TXRX_CSR0  %x !!!!!!!!!!!!!!!!!\n",Value);
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, Value);
+	}
+	else if ((strcmp(arg, "TKIP") == 0) || (strcmp(arg, "tkip") == 0))
+	{
+		pAdapter->PortCfg.WepStatus = Ndis802_11Encryption2Enabled;
+		pAdapter->PortCfg.CipherAlg = CIPHER_TKIP;
+		RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &Value);
+		DBGPRINT(RT_DEBUG_INFO,"Set::Read TXRX_CSR0  %x !!!!!!!!!!!!!!!!!\n",Value);
+		Value &= 0xfe00;
+		Value |= ((LENGTH_802_11 << 3) | (pAdapter->PortCfg.CipherAlg));
+		DBGPRINT(RT_DEBUG_INFO,"Set::Read  TXRX_CSR0  %x !!!!!!!!!!!!!!!!!\n",Value);
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, Value);
+	}
+	else if ((strcmp(arg, "AES") == 0) || (strcmp(arg, "aes") == 0))
+	{
+		pAdapter->PortCfg.WepStatus = Ndis802_11Encryption3Enabled;
+		RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &Value);
+		Value &= 0xfe00;
+		Value |= ((LENGTH_802_11 << 3) | (pAdapter->PortCfg.CipherAlg));
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, Value);
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_INFO,"Set::EncrypType ERROR !!!!!!!!!!!!!!!!!\n");
+		
+		return FALSE;
+	}
+
+	DBGPRINT(RT_DEBUG_TEMP, "Set_EncrypType_Proc::(EncrypType=%d)\n", pAdapter->PortCfg.WepStatus);
+
+
+	return TRUE;
+}
+/* 
+	==========================================================================
+	Description:
+		Set Default Key ID
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_DefaultKeyID_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	ULONG								KeyIdx;
+
+	KeyIdx = simple_strtol(arg, 0, 10);
+	if((KeyIdx >= 1 ) && (KeyIdx <= 4))
+		pAdapter->PortCfg.DefaultKeyId = (UCHAR) (KeyIdx - 1 );
+	else
+		return FALSE;  //Invalid argument 
+
+	DBGPRINT(RT_DEBUG_TEMP, "Set_DefaultKeyID_Proc::(DefaultKeyID=%d)\n", pAdapter->PortCfg.DefaultKeyId);
+
+	return TRUE;
+}
+/* 
+	==========================================================================
+	Description:
+		Set WEP KEY1
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_Key1_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	int 								KeyLen;
+	int 								i;
+	USHORT	Value;
+
+	KeyLen = strlen(arg);
+
+	switch (KeyLen)
+	{
+		case 5: //wep 40 Ascii type
+			pAdapter->PortCfg.SharedKey[0].KeyLen = KeyLen;
+			memcpy(pAdapter->PortCfg.SharedKey[0].Key, arg, KeyLen);	
+			DBGPRINT(RT_DEBUG_TEMP, "Set_Key1_Proc::(Key1=%s and type=%s)\n", arg, "Ascii");	   
+		
+			break;
+		case 10: //wep 40 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->PortCfg.SharedKey[0].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->PortCfg.SharedKey[0].Key, KeyLen / 2);
+			DBGPRINT(RT_DEBUG_TEMP, "Set_Key1_Proc::(Key1=%s and type=%s)\n", arg, "Hex");	   
+		 
+			break;
+		case 13: //wep 104 Ascii type
+			pAdapter->PortCfg.SharedKey[0].KeyLen = KeyLen;
+			memcpy(pAdapter->PortCfg.SharedKey[0].Key, arg, KeyLen);	
+			DBGPRINT(RT_DEBUG_TEMP, "Set_Key1_Proc::(Key1=%s and type=%s)\n", arg, "Ascii");	   
+			break;
+		case 26: //wep 104 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->PortCfg.SharedKey[0].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->PortCfg.SharedKey[0].Key, KeyLen / 2);
+			DBGPRINT(RT_DEBUG_TEMP, "Set_Key1_Proc::(Key1=%s and type=%s)\n", arg, "Hex");	   
+			break;
+		default: //Invalid argument 
+			DBGPRINT(RT_DEBUG_TEMP, "Set_Key1_Proc::Invalid argument (=%s)\n", arg);	   
+			return FALSE;
+	}
+
+
+	RTUSBMultiWrite(pAdapter, (USHORT)(SEC_CSR0 + 0 * 0x10), pAdapter->PortCfg.SharedKey[0].Key, 16);	
+
+								
+								
+	// Default key for tx (shared key)
+	pAdapter->PortCfg.DefaultKeyId = (UCHAR)0;
+								
+								
+								
+	if ( (KeyLen == 5) ||( KeyLen == 10) )
+	pAdapter->PortCfg.CipherAlg = CIPHER_WEP64;
+	else
+	pAdapter->PortCfg.CipherAlg = CIPHER_WEP128;
+								
+	 RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &Value);
+	 Value &= 0xfe00;
+	 Value |= ((LENGTH_802_11 << 3) | (pAdapter->PortCfg.CipherAlg));
+	 RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, Value);
+	
+	return TRUE;
+}
+/* 
+	==========================================================================
+	Description:
+		Set WEP KEY2
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_Key2_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	int 								KeyLen;
+	int 								i;
+	USHORT	Value;
+
+	KeyLen = strlen(arg);
+
+	switch (KeyLen)
+	{
+		case 5: //wep 40 Ascii type
+			pAdapter->PortCfg.SharedKey[1].KeyLen = KeyLen;
+			memcpy(pAdapter->PortCfg.SharedKey[1].Key, arg, KeyLen);
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key2_Proc::(Key2=%s and type=%s)\n", arg, "Ascii");
+			break;
+		case 10: //wep 40 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->PortCfg.SharedKey[1].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->PortCfg.SharedKey[1].Key, KeyLen / 2);
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key2_Proc::(Key2=%s and type=%s)\n", arg, "Hex");
+			break;
+		case 13: //wep 104 Ascii type
+			pAdapter->PortCfg.SharedKey[1].KeyLen = KeyLen;
+			memcpy(pAdapter->PortCfg.SharedKey[1].Key, arg, KeyLen);	
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key2_Proc::(Key2=%s and type=%s)\n", arg, "Ascii");
+			break;
+		case 26: //wep 104 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->PortCfg.SharedKey[1].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->PortCfg.SharedKey[1].Key, KeyLen / 2);
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key2_Proc::(Key2=%s and type=%s)\n", arg, "Hex");
+			break;
+		default: //Invalid argument 
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key2_Proc::Invalid argument (=%s)\n", arg);
+			return FALSE;
+	}
+
+	RTUSBMultiWrite(pAdapter, (USHORT)(SEC_CSR0 + 1 * 0x10), pAdapter->PortCfg.SharedKey[1].Key, 16);	
+
+	
+								
+								
+								
+	// Default key for tx (shared key)
+	pAdapter->PortCfg.DefaultKeyId = (UCHAR)1;
+								
+								
+								
+	if ( (KeyLen == 5) ||( KeyLen == 10) )
+	pAdapter->PortCfg.CipherAlg = CIPHER_WEP64;
+	else
+	pAdapter->PortCfg.CipherAlg = CIPHER_WEP128;
+								
+	 RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &Value);
+	 Value &= 0xfe00;
+	 Value |= ((LENGTH_802_11 << 3) | (pAdapter->PortCfg.CipherAlg));
+	 RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, Value);
+
+	return TRUE;
+}
+/* 
+	==========================================================================
+	Description:
+		Set WEP KEY3
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_Key3_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	int 								KeyLen;
+	int 								i;
+	USHORT	Value;	
+
+	KeyLen = strlen(arg);
+
+	switch (KeyLen)
+	{
+		case 5: //wep 40 Ascii type
+			pAdapter->PortCfg.SharedKey[2].KeyLen = KeyLen;
+			memcpy(pAdapter->PortCfg.SharedKey[2].Key, arg, KeyLen);
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key3_Proc::(Key3=%s and type=%s)\n", arg, "Ascii");
+			break;
+		case 10: //wep 40 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->PortCfg.SharedKey[2].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->PortCfg.SharedKey[2].Key, KeyLen / 2);
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key3_Proc::(Key3=%s and type=%s)\n", arg, "Hex");
+			break;
+		case 13: //wep 104 Ascii type
+			pAdapter->PortCfg.SharedKey[2].KeyLen = KeyLen;
+			memcpy(pAdapter->PortCfg.SharedKey[2].Key, arg, KeyLen);
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key3_Proc::(Key3=%s and type=%s)\n", arg, "Ascii");
+			break;
+		case 26: //wep 104 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->PortCfg.SharedKey[2].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->PortCfg.SharedKey[2].Key, KeyLen / 2);
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key3_Proc::(Key3=%s and type=%s)\n", arg, "Hex");
+			break;
+		default: //Invalid argument 
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key3_Proc::Invalid argument (=%s)\n", arg);
+			return FALSE;
+	}
+
+	RTUSBMultiWrite(pAdapter, (USHORT)(SEC_CSR0 + 2 * 0x10), pAdapter->PortCfg.SharedKey[2].Key, 16);	
+
+								
+	// Default key for tx (shared key)
+	pAdapter->PortCfg.DefaultKeyId = (UCHAR)2;
+								
+								
+								
+	if ( (KeyLen == 5) ||( KeyLen == 10) )
+	pAdapter->PortCfg.CipherAlg = CIPHER_WEP64;
+	else
+	pAdapter->PortCfg.CipherAlg = CIPHER_WEP128;
+								
+	 RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &Value);
+	 Value &= 0xfe00;
+	 Value |= ((LENGTH_802_11 << 3) | (pAdapter->PortCfg.CipherAlg));
+	 RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, Value);
+
+	return TRUE;
+}
+/* 
+	==========================================================================
+	Description:
+		Set WEP KEY4
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_Key4_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+	int 								KeyLen;
+	int 								i;
+	USHORT	Value;
+
+	KeyLen = strlen(arg);
+
+	switch (KeyLen)
+	{
+		case 5: //wep 40 Ascii type
+			pAdapter->PortCfg.SharedKey[3].KeyLen = KeyLen;
+			memcpy(pAdapter->PortCfg.SharedKey[3].Key, arg, KeyLen);	
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key4_Proc::(Key4=%s and type=%s)\n", arg, "Ascii");
+			break;
+		case 10: //wep 40 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->PortCfg.SharedKey[3].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->PortCfg.SharedKey[3].Key, KeyLen / 2);
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key4_Proc::(Key4=%s and type=%s)\n", arg, "Hex");
+			break;
+		case 13: //wep 104 Ascii type
+			pAdapter->PortCfg.SharedKey[3].KeyLen = KeyLen;
+			memcpy(pAdapter->PortCfg.SharedKey[3].Key, arg, KeyLen);
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key4_Proc::(Key4=%s and type=%s)\n", arg, "Ascii");
+			break;
+		case 26: //wep 104 Hex type
+			for(i=0; i < KeyLen; i++)
+			{
+				if( !isxdigit(*(arg+i)) )
+					return FALSE;  //Not Hex value;
+			}
+			pAdapter->PortCfg.SharedKey[3].KeyLen = KeyLen / 2 ;
+			AtoH(arg, pAdapter->PortCfg.SharedKey[3].Key, KeyLen / 2);
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key4_Proc::(Key4=%s and type=%s)\n", arg, "Hex");
+			break;
+		default: //Invalid argument 
+			DBGPRINT(RT_DEBUG_TRACE, "Set_Key4_Proc::Invalid argument (=%s)\n", arg);
+			return FALSE;
+	}
+
+	RTUSBMultiWrite(pAdapter, (USHORT)(SEC_CSR0 + 3 * 0x10), pAdapter->PortCfg.SharedKey[3].Key, 16);	
+
+								
+	// Default key for tx (shared key)
+	pAdapter->PortCfg.DefaultKeyId = (UCHAR)3;
+								
+								
+								
+	if ( (KeyLen == 5) ||( KeyLen == 10) )
+	pAdapter->PortCfg.CipherAlg = CIPHER_WEP64;
+	else
+	pAdapter->PortCfg.CipherAlg = CIPHER_WEP128;
+								
+	 RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &Value);
+	 Value &= 0xfe00;
+	 Value |= ((LENGTH_802_11 << 3) | (pAdapter->PortCfg.CipherAlg));
+	 RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, Value);
+
+	return TRUE;
+}
+/* 
+	==========================================================================
+	Description:
+		Set WPA PSK key
+	Return:
+		TRUE if all parameters are OK, FALSE otherwise
+	==========================================================================
+*/
+INT Set_WPAPSK_Proc(
+	IN	PRT2570ADAPTER	 pAdapter, 
+	IN	PUCHAR			arg)
+{
+#if 0
+	UCHAR								keyMaterial[40];
+
+	DBGPRINT(RT_DEBUG_TRACE, "Set_WPAPSK_Proc::(WPAPSK=%s)\n", arg);
+	if ((strlen(arg) < 8) || (strlen(arg) > 64))
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "Set failed!!(WPAPSK=%s), WPAPSK key-string required 8 ~ 64 characters \n", arg);
+		return FALSE;
+	}
+
+	PasswordHash((char *)arg, pAdapter->PortCfg.Ssid, pAdapter->PortCfg.SsidLen, keyMaterial);
+
+	memcpy(pAdapter->PortCfg.PskKey.Key, keyMaterial, 32);
+
+	// Use RaConfig as PSK agent.
+	// Start STA supplicant state machine
+	pAdapter->PortCfg.WpaState = SS_START;
+#ifdef RT2500_DBG
+	DBGPRINT(RT_DEBUG_LOUD, "Set_WPAPSK_Proc WPAPSK Key => \n");
+	DBGPRINT(RT_DEBUG_LOUD, "    ");
+	for (i = 0; i < 32; i++)
+	{
+		DBGPRINT_RAW(RT_DEBUG_LOUD, "%02x:", pAdapter->PortCfg.PskKey.Key[i]);
+		if (i%16 == 15) {
+		  DBGPRINT_RAW(RT_DEBUG_LOUD, "\n");
+		  DBGPRINT(RT_DEBUG_LOUD, "    ");
+		}
+	}
+	DBGPRINT_RAW(RT_DEBUG_LOUD, "\n");
+#endif
+#endif
+return TRUE;
+
+}
+
+
+int usb_rt2570_ioctl(struct net_device *net_dev, struct ifreq *rq,
+			  int cmd)
+{
+	PRT2570ADAPTER		pAdapter= net_dev->priv;
+	struct iwreq						*wrq = (struct iwreq *) rq;
+	struct iw_point 					*erq = NULL;
+	struct iw_freq						*frq = NULL;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE	BssType = Ndis802_11Infrastructure;
+	NDIS_802_11_RTS_THRESHOLD			RtsThresh;
+	NDIS_802_11_FRAGMENTATION_THRESHOLD FragThresh;
+	NDIS_802_11_MAC_ADDRESS 			Bssid;
+	INT 								Status = NDIS_STATUS_SUCCESS;	
+	BOOLEAN 							StateMachineTouched = FALSE;
+	int 								 chan = -1, index = 0, len = 0;
+	USHORT	Value;
+	
+	if ( (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)) || (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)))
+	{
+		DBGPRINT(RT_DEBUG_TRACE,"INFO::remove in progress!\n");
+		return -ENETDOWN;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if (pAdapter->RTUSBCmdThr_pid < 0)
+		return -ENETDOWN;
+#else
+	if (!pAdapter->RTUSBCmdThr_active)
+		return -ENETDOWN;
+#endif
+	
+	switch(cmd) {
+
+		case SIOCGIWNAME:
+			DBGPRINT(RT_DEBUG_INFO,"IOCTL::SIOCGIWNAME\n");
+			strcpy(wrq->u.name,"RT2570 Wireless");	 //Less then 16 bytes. 
+			break;
+		case SIOCSIWESSID:	//Set ESSID
+			DBGPRINT(RT_DEBUG_INFO, "==>ioctl::SIOCSIWESSID\n");
+
+			break;
+		case SIOCGIWESSID:	//Get ESSID
+			DBGPRINT(RT_DEBUG_INFO, "==>ioctl::SIOCGIWESSID\n");
+			break;
+		case SIOCSIWFREQ: // set channel/frequency (Hz)
+			frq = &(wrq->u.freq);
+			if((frq->e == 0) && (frq->m <= 1000))
+				chan = frq->m;	// Setting by channel number 
+			else
+				MAP_KHZ_TO_CHANNEL_ID( (frq->m /100) , chan); // Setting by frequency - search the table , like 2.412G, 2.422G, 
+			pAdapter->PortCfg.IbssConfig.Channel = chan;
+			DBGPRINT(RT_DEBUG_ERROR, "<==ioctl::SIOCSIWFREQ[cmd=0x%x] (Channel=%d)\n", SIOCSIWFREQ, pAdapter->PortCfg.IbssConfig.Channel);
+                break;
+		case SIOCGIWFREQ: // get channel/frequency (Hz)
+			DBGPRINT(RT_DEBUG_TRACE,"==>IOCTL::SIOCGIWFREQ\n");
+			break;
+		case SIOCGIWNICKN: //get node name/nickname
+			DBGPRINT(RT_DEBUG_TRACE,"==>IOCTL::SIOCGIWNICKN\n");
+			erq = &wrq->u.data;
+			erq->length = strlen(pAdapter->nickn);
+			if(copy_to_user(erq->pointer, pAdapter->nickn, erq->length))
+				Status = -EFAULT;
+
+			 DBGPRINT(RT_DEBUG_TRACE,"<==IOCTL::SIOCGIWNICKN\n");
+			break;
+		case SIOCSIWNICKN: //set node name/nickname
+			DBGPRINT(RT_DEBUG_TRACE,"==>IOCTL::SIOCSIWNICKN\n");
+			 DBGPRINT(RT_DEBUG_TRACE,"<==IOCTL::SIOCSIWNICKN\n");
+			break;
+		case SIOCGIWRATE:  //get default bit rate (bps)
+			DBGPRINT(RT_DEBUG_TRACE,"==>IOCTL::SIOCGIWRATE\n");
+			wrq->u.bitrate.value = RateIdToMbps[pAdapter->PortCfg.TxRate] * 1000000;
+			wrq->u.bitrate.disabled = 0;
+			 DBGPRINT(RT_DEBUG_TRACE,"<==IOCTL::SIOCGIWRATE\n");
+			break;
+		case SIOCSIWRATE:  //set default bit rate (bps)
+			DBGPRINT(RT_DEBUG_TEMP,"==>IOCTL::SIOCSIWRATE %d\n",wrq->u.bitrate.value);
+			RT2570SetDesiredRates(pAdapter, wrq->u.bitrate.value);
+			 DBGPRINT(RT_DEBUG_TRACE,"<==IOCTL::SIOCSIWRATE\n");
+			break;
+		case SIOCGIWRTS:  // get RTS/CTS threshold (bytes)
+			DBGPRINT(RT_DEBUG_TRACE,"==>IOCTL::SIOCGIWRTS\n");
+			wrq->u.rts.value = (INT) pAdapter->PortCfg.RtsThreshold;
+			wrq->u.rts.disabled = (wrq->u.rts.value == MAX_RTS_THRESHOLD);
+			wrq->u.rts.fixed = 1;
+			 DBGPRINT(RT_DEBUG_TRACE,"<==IOCTL::SIOCGIWRTS\n");
+			break;
+		case SIOCSIWRTS:  //set RTS/CTS threshold (bytes)
+			DBGPRINT(RT_DEBUG_TRACE,"==>IOCTL::SIOCSIWRTS\n");
+			RtsThresh = wrq->u.rts.value;
+			if (wrq->u.rts.disabled)
+				RtsThresh = MAX_RTS_THRESHOLD;
+
+			if((RtsThresh > 0) && (RtsThresh <= MAX_RTS_THRESHOLD))
+				pAdapter->PortCfg.RtsThreshold = (USHORT)RtsThresh;
+			else if (RtsThresh == 0)
+				pAdapter->PortCfg.RtsThreshold = MAX_RTS_THRESHOLD;
+
+			DBGPRINT(RT_DEBUG_TRACE, "<==ioctl::SIOCSIWRTS (=%d)\n", pAdapter->PortCfg.RtsThreshold);
+			break;
+		case SIOCGIWFRAG:  //get fragmentation thr (bytes)
+			DBGPRINT(RT_DEBUG_TRACE,"==>IOCTL::SIOCGIWFRAG\n");
+			wrq->u.frag.value = (INT) pAdapter->PortCfg.FragmentThreshold;
+			wrq->u.frag.disabled = (wrq->u.frag.value >= MAX_FRAG_THRESHOLD);
+			wrq->u.frag.fixed = 1;
+			 DBGPRINT(RT_DEBUG_TRACE,"<==IOCTL::SIOCGIWFRAG\n");
+			break;
+		case SIOCSIWFRAG:  //set fragmentation thr (bytes)
+			DBGPRINT(RT_DEBUG_TRACE,"==>IOCTL::SIOCSIWFRAG\n");
+			FragThresh = wrq->u.frag.value;
+			if (wrq->u.rts.disabled)
+				FragThresh = MAX_FRAG_THRESHOLD;
+
+			if ( (FragThresh >= MIN_FRAG_THRESHOLD) && (FragThresh <= MAX_FRAG_THRESHOLD))
+				pAdapter->PortCfg.FragmentThreshold = (USHORT)FragThresh;
+			else if (FragThresh == 0)
+				pAdapter->PortCfg.FragmentThreshold = MAX_FRAG_THRESHOLD;
+
+			if (pAdapter->PortCfg.FragmentThreshold == MAX_FRAG_THRESHOLD)
+				pAdapter->PortCfg.bFragmentZeroDisable = TRUE;
+			else
+				pAdapter->PortCfg.bFragmentZeroDisable = FALSE;
+
+			DBGPRINT(RT_DEBUG_TRACE, "<==ioctl::SIOCSIWFRAG (=%d)\n", pAdapter->PortCfg.FragmentThreshold);
+			break;
+		case SIOCGIWENCODE:  //get encoding token & mode
+			DBGPRINT(RT_DEBUG_TRACE,"==>IOCTL::SIOCGIWENCODE\n");
+			index = (wrq->u.encoding.flags & IW_ENCODE_INDEX) - 1;
+			if ((index < 0) || (index >= NR_WEP_KEYS))
+				index = pAdapter->PortCfg.DefaultKeyId; // Default key for tx (shared key)
+
+			if (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeOpen)
+				wrq->u.encoding.flags = IW_ENCODE_OPEN;
+			else if (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeShared)
+				wrq->u.encoding.flags = IW_ENCODE_RESTRICTED;
+
+			if (pAdapter->PortCfg.WepStatus == Ndis802_11WEPDisabled)
+				wrq->u.encoding.flags |= IW_ENCODE_DISABLED;
+			else
+			{
+				if(wrq->u.encoding.pointer)
+				{
+					wrq->u.encoding.length = pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen;
+					if(copy_to_user(wrq->u.encoding.pointer,
+								pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].Key,
+								pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen))
+						Status = -EFAULT;
+
+					wrq->u.encoding.flags |= (pAdapter->PortCfg.DefaultKeyId + 1);
+				}
+			}
+			 DBGPRINT(RT_DEBUG_TEMP,"<==IOCTL::SIOCGIWENCODE , DefaultKeyId=%d\n", pAdapter->PortCfg.DefaultKeyId);
+			break;
+		case SIOCSIWENCODE:  //set encoding token & mode
+			index = (wrq->u.encoding.flags & IW_ENCODE_INDEX) - 1;
+			DBGPRINT(RT_DEBUG_TEMP,"==>IOCTL::SIOCSIWENCODE index= %d\n",index);
+			/* take the old default key if index is invalid */
+			if((index < 0) || (index >= NR_WEP_KEYS))
+				index = pAdapter->PortCfg.DefaultKeyId; 	// Default key for tx (shared key)
+
+			if((wrq->u.encoding.pointer) && ((wrq->u.encoding.flags & IW_ENCODE_NOKEY) == 0))
+			{
+				printk(" !IW_ENCODE_NOKEY \n" );
+				len = wrq->u.encoding.length;
+				if(len > WEP_LARGE_KEY_LEN)
+					len = WEP_LARGE_KEY_LEN;
+
+				memset(pAdapter->PortCfg.SharedKey[index].Key, 0x00, MAX_LEN_OF_KEY);
+				if(copy_from_user(pAdapter->PortCfg.SharedKey[index].Key, wrq->u.encoding.pointer, len))
+					Status = -EINVAL;
+
+				pAdapter->PortCfg.SharedKey[index].KeyLen = len <= WEP_SMALL_KEY_LEN ? WEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN;
+			}
+			if (wrq->u.encoding.flags & IW_ENCODE_DISABLED)
+				pAdapter->PortCfg.WepStatus = Ndis802_11WEPDisabled;
+			else
+				pAdapter->PortCfg.WepStatus = Ndis802_11WEPEnabled;
+
+			if (wrq->u.encoding.flags & IW_ENCODE_RESTRICTED)
+				pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeShared;
+			else 
+				pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+
+			if(pAdapter->PortCfg.WepStatus == Ndis802_11WEPDisabled)
+				pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+
+			if ((wrq->u.encoding.flags & IW_ENCODE_NOKEY) == 0)
+			{
+				RTUSBMultiWrite(pAdapter, (USHORT)(SEC_CSR0 + index * 0x10), pAdapter->PortCfg.SharedKey[index].Key, 16);	
+
+				pAdapter->PortCfg.DefaultKeyId = (UCHAR) index;
+				if ( (len == 5) ||( len == 10) )
+					pAdapter->PortCfg.CipherAlg = CIPHER_WEP64;
+				else
+					pAdapter->PortCfg.CipherAlg = CIPHER_WEP128;
+											
+				 RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &Value);
+				 Value &= 0xfe00;
+				 Value |= ((LENGTH_802_11 << 3) | (pAdapter->PortCfg.CipherAlg));
+				 RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, Value);
+
+			}
+
+			DBGPRINT(RT_DEBUG_TRACE,"<==IOCTL::SIOCSIWENCODE\n");
+			break;
+		case SIOCGIWAP:  //get access point MAC addresses
+			DBGPRINT(RT_DEBUG_TRACE,"==>IOCTL::SIOCGIWAP\n");
+			 DBGPRINT(RT_DEBUG_TEMP,"<==>IOCTL::SIOCGIWAP\n");
+			break;
+		case SIOCSIWAP:  //set access point MAC addresses
+			DBGPRINT(RT_DEBUG_TRACE,"==>IOCTL::SIOCSIWAP\n");
+			memcpy(&Bssid, &wrq->u.ap_addr.sa_data, sizeof(NDIS_802_11_MAC_ADDRESS));
+			if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "!!! MLME busy, reset MLME state machine !!!\n");
+			}
+
+			// tell CNTL state machine to call NdisMSetInformationComplete() after completing
+			// this request, because this request is initiated by NDIS.
+			pAdapter->Mlme.CntlAux.CurrReqIsFromNdis = FALSE; 
+
+			MlmeEnqueue(pAdapter, 
+						MLME_CNTL_STATE_MACHINE, 
+						OID_802_11_BSSID, 
+						sizeof(NDIS_802_11_MAC_ADDRESS),
+						(VOID *)&Bssid);
+			Status = NDIS_STATUS_SUCCESS;
+			StateMachineTouched = TRUE;
+			DBGPRINT(RT_DEBUG_TRACE, "ioctl::SIOCSIWAP %02x:%02x:%02x:%02x:%02x:%02x\n",
+									Bssid[0], Bssid[1], Bssid[2], Bssid[3], Bssid[4], Bssid[5]);
+			 DBGPRINT(RT_DEBUG_TEMP,"<==IOCTL::SIOCSIWAP\n");
+			break;
+		case SIOCGIWMODE:  //get operation mode
+			DBGPRINT(RT_DEBUG_TRACE,"==>IOCTL::SIOCGIWMODE\n");
+			if (ADHOC_ON(pAdapter))
+			{
+				BssType = Ndis802_11IBSS;
+				wrq->u.mode = IW_MODE_ADHOC;
+			}
+			else if (INFRA_ON(pAdapter))
+			{
+				BssType = Ndis802_11Infrastructure;
+				wrq->u.mode = IW_MODE_INFRA;
+			}
+			else
+			{
+				BssType = Ndis802_11AutoUnknown;
+				wrq->u.mode = IW_MODE_AUTO;
+			}
+			DBGPRINT(RT_DEBUG_TRACE, "<==ioctl::SIOCGIWMODE(=%d)\n", BssType);
+			break;
+		case SIOCSIWMODE:  //set operation mode
+			DBGPRINT(RT_DEBUG_TRACE,"==>IOCTL::SIOCSIWMODE\n");
+			DBGPRINT(RT_DEBUG_TEMP,"<==IOCTL::SIOCSIWMODE\n");
+			break;
+		case SIOCGIWSENS:	//get sensitivity (dBm)
+		case SIOCSIWSENS:	//set sensitivity (dBm)
+		case SIOCGIWPOWER:	//get Power Management settings
+		case SIOCSIWPOWER:	//set Power Management settings
+		case SIOCGIWTXPOW:	//get transmit power (dBm)
+		case SIOCSIWTXPOW:	//set transmit power (dBm)
+			DBGPRINT(RT_DEBUG_TRACE,"<==>IOCTL::multi not support\n");
+			Status = -EOPNOTSUPP;
+			break;
+		case SIOCGIWAPLIST:
+			DBGPRINT(RT_DEBUG_TEMP, "Query::SIOCGIWAPLIST (%d BSS returned)\n",pAdapter->PortCfg.BssTab.BssNr);
+			DBGPRINT(RT_DEBUG_TEMP,"<==>WIRELESS_EXT=%d  IOCTL::SIOCGIWAPLIST \n",WIRELESS_EXT);
+			break;
+
+		case SIOCGIWPRIV:
+			if (wrq->u.data.pointer) {
+				if ( !access_ok(VERIFY_WRITE, wrq->u.data.pointer, sizeof(privtab)) )
+					break;
+				wrq->u.data.length = sizeof(privtab) / sizeof(privtab[0]);
+				if (copy_to_user(wrq->u.data.pointer, privtab, sizeof(privtab)))
+					Status = -EFAULT;
+			}
+			break;
+		default:
+			DBGPRINT(RT_DEBUG_INFO, "IOCTL::unknown IOCTL's cmd = 0x%08x\n", cmd);
+			Status = -EOPNOTSUPP;
+			break;
+	}
+
+	if(StateMachineTouched) // Upper layer sent a MLME-related operations
+		RTUSBUp(pAdapter, (&(pAdapter->mlme_semaphore)));
+	
+	return Status;
+}
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rtusb_init.c linux-2.4.35.3-mct/drivers/usb/rt2570/rtusb_init.c
--- linux-2.4.35.3/drivers/usb/rt2570/rtusb_init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rtusb_init.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,2123 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	rtusb_init.c
+ *	
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ *	RobinC		02-06-2005	usb_kill_urb fixes for kernels =>2.6.7
+ ***************************************************************************/
+
+#include	"rt_config.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#include <linux/kthread.h>
+#define RT2570_USB_ALLOC_URB(iso)	usb_alloc_urb(iso, GFP_ATOMIC);	
+#else
+#define RT2570_USB_ALLOC_URB(iso)	usb_alloc_urb(iso);
+#endif
+
+USHORT	 BBPRegTable[] = {
+	0x0302,  // R03
+	0x0419,  // R04
+	0x0E1C,  // R14
+	0x0F30,  // R15
+	0x10ac,  // R16
+	0x1148,  // R17
+	0x1218,  // R18
+	0x13ff,  // R19
+	0x141E,  // R20
+	0x1508,  // R21
+	0x1608,  // R22
+	0x1708,  // R23
+//modified by david    0x1870,	// R24
+	0x1880,  // R24	modified by david
+//modified by gary	  0x1940,  // R25
+	0x1950,  // R25	//modified by gary
+	0x1A08,  // R26
+	0x1B23,  // R27
+	0x1E10,  // R30
+	0x1F2B,  // R31
+	0x20B9,  // R32
+	0x2212,  // R34
+	0x2350,  // R35
+	0x27c4,  // R39
+	0x2802,  // R40
+	0x2960,  // R41
+	0x3510,  // R53
+	0x3618,  // R54
+	0x3808,  // R56
+	0x3910,  // R57
+	0x3A08,  // R58
+	0x3D60,  // R61
+	0x3E10,  // R62
+	0x4BFF,  // R75//by MAX
+};
+#define	NUM_BBP_REG_PARMS	(sizeof(BBPRegTable) / sizeof(USHORT))
+VOID RTMPReadParametersFromFile(PRT2570ADAPTER pAd)
+{
+#if 0
+	UCHAR					src[70];
+	struct file				*srcf;
+	INT 						retval, orgfsuid, orgfsgid;
+	mm_segment_t			orgfs;
+	CHAR									buffer[MAX_INI_BUFFER_SIZE];
+	CHAR									tmpbuf[255];	
+	UCHAR									Channel;
+	ULONG									ulInfo;
+	RT_802_11_PREAMBLE						Preamble;
+	int 									KeyLen;
+	int 									i;
+	BOOLEAN 								bIsHex = TRUE;
+	UCHAR									keyMaterial[40];	
+	ULONG		rate_mapping[12] = {1, 2, 5, 11, 6, 9, 12, 18, 24, 36, 48, 54}; //according to README
+	// Save uid and gid used for filesystem access.
+	// Set user and group to 0 (root)	
+	memset(src, 0, sizeof(src));
+	memcpy(src, PROFILE_PATH, sizeof(PROFILE_PATH));
+	DBGPRINT(RT_DEBUG_TEMP, "--> Read %s \n", src);
+	orgfsuid = current->fsuid;
+	DBGPRINT(RT_DEBUG_TEMP, "1. orgfsuid = %x\n",orgfsuid);
+	orgfsgid = current->fsgid;
+	DBGPRINT(RT_DEBUG_TEMP, "2. %x\n",orgfsgid);
+	current->fsuid= 0;
+	current->fsgid = 0;
+	orgfs = get_fs();
+	DBGPRINT(RT_DEBUG_TEMP, "4. read_orgfs=0x%x\n",orgfs);
+	set_fs(KERNEL_DS);
+	if (src && *src) 
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "--> Read %s \n", src);
+		srcf = filp_open(src, O_RDONLY , 0);
+		if (IS_ERR(srcf)) 
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "--> Error %ld opening %s\n", -PTR_ERR(srcf),src);    
+		}
+		else 
+		{
+			/* The object must have a read method */
+			if (srcf->f_op && srcf->f_op->read) 
+			{
+				retval=srcf->f_op->read(srcf, buffer, MAX_INI_BUFFER_SIZE, &srcf->f_pos);
+				if (retval < 0)
+				{
+					DBGPRINT(RT_DEBUG_TEMP, "--> Read %s error %d\n", src, -retval);
+				}
+				else
+				{
+					//CountryRegion
+					if (RTMPGetKeyParameter("Default", "CountryRegion", tmpbuf, 255, buffer))
+					{
+						ulInfo = simple_strtol(tmpbuf, 0, 10);
+						if ((ulInfo >= REGION_MIN) && (ulInfo <= REGION_MAX) )
+						{
+							pAd->PortCfg.CountryRegion = (UCHAR) ulInfo;
+							DBGPRINT(RT_DEBUG_TRACE, "%s::(CountryRegion=%d)\n", __FUNCTION__, pAd->PortCfg.CountryRegion);
+						}
+					}
+					//SSID
+					memset(tmpbuf, 0x00, 255);
+					if (RTMPGetKeyParameter("Default", "SSID", pAd->PortCfg.Ssid, 32, buffer))
+					{
+						pAd->PortCfg.SsidLen = strlen(pAd->PortCfg.Ssid);
+						pAd->Mlme.CntlAux.SsidLen = pAd->PortCfg.SsidLen;
+						memcpy(pAd->Mlme.CntlAux.Ssid, pAd->PortCfg.Ssid, pAd->Mlme.CntlAux.SsidLen);
+
+						DBGPRINT(RT_DEBUG_TRACE, "%s::(SSID=%s Len=%d)\n", __FUNCTION__, pAd->PortCfg.Ssid, pAd->PortCfg.SsidLen);
+					}
+					 //NetworkType
+					if (RTMPGetKeyParameter("Default", "NetworkType", tmpbuf, 255, buffer))
+					{
+						pAd->bConfigChanged = TRUE;
+						if (strcmp(tmpbuf, "Adhoc") == 0)
+							pAd->PortCfg.BssType = BSS_INDEP;
+						else //Default Infrastructure mode
+							pAd->PortCfg.BssType = BSS_INFRA;
+						// Reset Ralink supplicant to not use, it will be set to start when UI set PMK key
+						pAd->PortCfg.WpaState = SS_NOTUSE;
+						DBGPRINT(RT_DEBUG_TEMP, "%s::(NetworkType=%d)\n", __FUNCTION__, pAd->PortCfg.BssType);
+					}
+					//WirelessMode
+					if (RTMPGetKeyParameter("Default", "WirelessMode", tmpbuf, 10, buffer))
+					{
+						ulInfo = simple_strtol(tmpbuf, 0, 10);
+						if ((ulInfo == PHY_11BG_MIXED) || (ulInfo == PHY_11B) ||
+							(ulInfo == PHY_11A) || (ulInfo == PHY_11ABG_MIXED))
+						{
+							RTMPSetPhyMode(pAd, ulInfo);
+							DBGPRINT(RT_DEBUG_TEMP, "%s::(WirelessMode=%d)\n", __FUNCTION__, ulInfo);
+						}
+					}
+					//TxRate
+					if (RTMPGetKeyParameter("Default", "TxRate", tmpbuf, 10, buffer))
+					{
+						ulInfo = simple_strtol(tmpbuf, 0, 10);
+						{
+							if (ulInfo == 0)
+								RT2570SetDesiredRates(pAd, -1);
+							else if (ulInfo < 13){
+					RT2570SetDesiredRates(pAd, (LONG) (rate_mapping[ulInfo-1] * 1000000));
+							DBGPRINT(RT_DEBUG_TEMP, "1. %s::(TxRate=%d Mbps %d)\n", __FUNCTION__, rate_mapping[ulInfo-1],ulInfo);
+								}
+							DBGPRINT(RT_DEBUG_TEMP, "3. %s::(TxRate=%d Mbps %d)\n", __FUNCTION__, rate_mapping[ulInfo-1],ulInfo);
+						}
+					}
+					//Channel
+					if (RTMPGetKeyParameter("Default", "Channel", tmpbuf, 10, buffer))
+					{
+						Channel = (UCHAR) simple_strtol(tmpbuf, 0, 10);
+						if (ChannelSanity(pAd, Channel) == TRUE)
+						{
+							pAd->PortCfg.Channel = Channel;
+							// If default profile in Registry is an ADHOC network, driver should use the specified channel 
+							// number when starting IBSS the first time, because RaConfig is passive and will not set this
+							// via OID_802_11_CONFIGURATION upon driver bootup.
+							pAd->PortCfg.IbssConfig.Channel = pAd->PortCfg.Channel;
+							DBGPRINT(RT_DEBUG_TEMP, "%s::(Channel=%d)\n", __FUNCTION__, Channel);
+						}
+					}
+					//BGProtection
+					if (RTMPGetKeyParameter("Default", "BGProtection", tmpbuf, 10, buffer))
+					{
+						switch (simple_strtol(tmpbuf, 0, 10))
+						{
+							case 1: //Always On
+								pAd->PortCfg.UseBGProtection = 1;
+								break;
+							case 2: //Always OFF
+								pAd->PortCfg.UseBGProtection = 2;
+								break;
+							case 0: //AUTO
+							default:
+								pAd->PortCfg.UseBGProtection = 0;
+								break;
+						}
+								pAd->PortCfg.UseBGProtection = 2;
+						DBGPRINT(RT_DEBUG_TEMP, "%s::(BGProtection=%d)\n", __FUNCTION__, pAd->PortCfg.UseBGProtection);
+					}
+					//TxPreamble
+					if (RTMPGetKeyParameter("Default", "TxPreamble", tmpbuf, 10, buffer))
+					{
+						Preamble = simple_strtol(tmpbuf, 0, 10);
+						switch (Preamble)
+						{
+							case Rt802_11PreambleShort:
+								pAd->PortCfg.WindowsTxPreamble = Preamble;
+								MlmeSetTxPreamble(pAd, Rt802_11PreambleShort);
+								break;
+							case Rt802_11PreambleLong:
+							case Rt802_11PreambleAuto:
+							default:
+								// if user wants AUTO, initialize to LONG here, then change according to AP's
+								// capability upon association.
+								pAd->PortCfg.WindowsTxPreamble = Preamble;
+								MlmeSetTxPreamble(pAd, Rt802_11PreambleLong);
+						}
+						DBGPRINT(RT_DEBUG_TEMP, "%s::(TxPreamble=%d)\n", __FUNCTION__, Preamble);
+					}
+					//RTSThreshold
+					if (RTMPGetKeyParameter("Default", "RTSThreshold", tmpbuf, 10, buffer))
+					{
+						ulInfo = simple_strtol(tmpbuf, 0, 10);
+
+						if((ulInfo > 0) && (ulInfo <= MAX_RTS_THRESHOLD))
+							pAd->PortCfg.RtsThreshold = (USHORT)ulInfo;
+						else 
+							pAd->PortCfg.RtsThreshold = MAX_RTS_THRESHOLD;
+
+						DBGPRINT(RT_DEBUG_TEMP, "%s::(RTSThreshold=%d)\n", __FUNCTION__, pAd->PortCfg.RtsThreshold);
+					}
+					//FragThreshold
+					if (RTMPGetKeyParameter("Default", "FragThreshold", tmpbuf, 10, buffer))
+					{
+						ulInfo = simple_strtol(tmpbuf, 0, 10);
+
+						if ( (ulInfo >= MIN_FRAG_THRESHOLD) && (ulInfo <= MAX_FRAG_THRESHOLD))
+							pAd->PortCfg.FragmentThreshold = (USHORT)ulInfo;
+						else
+							pAd->PortCfg.FragmentThreshold = MAX_FRAG_THRESHOLD;
+
+						if (pAd->PortCfg.FragmentThreshold == MAX_FRAG_THRESHOLD)
+							pAd->PortCfg.bFragmentZeroDisable = TRUE;
+						else
+							pAd->PortCfg.bFragmentZeroDisable = FALSE;
+
+						DBGPRINT(RT_DEBUG_TEMP, "%s::(FragThreshold=%d)\n", __FUNCTION__, ulInfo);
+					}
+					//TxBurst
+					if (RTMPGetKeyParameter("Default", "TxBurst", tmpbuf, 10, buffer))
+					{
+						ulInfo = simple_strtol(tmpbuf, 0, 10);
+
+						if (ulInfo == 1)
+							pAd->PortCfg.EnableTxBurst = TRUE;
+						else
+							pAd->PortCfg.EnableTxBurst = FALSE;
+
+						DBGPRINT(RT_DEBUG_TEMP, "%s::(TxBurst=%d)\n", __FUNCTION__, pAd->PortCfg.EnableTxBurst);
+					}
+					//TurboRate
+					if (RTMPGetKeyParameter("Default", "TurboRate", tmpbuf, 10, buffer))
+					{
+						ulInfo = simple_strtol(tmpbuf, 0, 10);
+
+						if (ulInfo == 1)
+							pAd->PortCfg.EnableTurboRate = TRUE;
+						else
+							pAd->PortCfg.EnableTurboRate = FALSE;
+
+						DBGPRINT(RT_DEBUG_TEMP, "%s::(TurboRate=%d)\n", __FUNCTION__, pAd->PortCfg.EnableTurboRate);
+					}
+					//ShortSlot
+					if (RTMPGetKeyParameter("Default", "ShortSlot", tmpbuf, 10, buffer))
+					{
+						ulInfo = simple_strtol(tmpbuf, 0, 10);
+
+						if (ulInfo == 1)
+							pAd->PortCfg.UseShortSlotTime = TRUE;
+						else
+							pAd->PortCfg.UseShortSlotTime = FALSE;
+
+						DBGPRINT(RT_DEBUG_TEMP, "%s::(ShortSlot=%d)\n", __FUNCTION__, pAd->PortCfg.UseShortSlotTime);
+					}
+					//POWER_MODE
+					if (RTMPGetKeyParameter("Default", "PSMode", tmpbuf, 10, buffer))
+					{
+						if (pAd->PortCfg.BssType == BSS_INFRA)
+						{
+							if ((strcmp(tmpbuf, "MAX_PSP") == 0) || (strcmp(tmpbuf, "max_psp") == 0))
+							{
+								// do NOT turn on PSM bit here, wait until MlmeCheckForPsmChange()
+								// to exclude certain situations.
+								//	   MlmeSetPsmBit(pAdapter, PWR_SAVE);
+									pAd->PortCfg.WindowsPowerMode = Ndis802_11PowerModeMAX_PSP;
+								pAd->PortCfg.RecvDtim = TRUE;  // FALSE;
+								pAd->PortCfg.DefaultListenCount = 5;
+							}
+							else if ((strcmp(tmpbuf, "Fast_PSP") == 0) || (strcmp(tmpbuf, "fast_psp") == 0) 
+								|| (strcmp(tmpbuf, "FAST_PSP") == 0))
+							{
+								// do NOT turn on PSM bit here, wait until MlmeCheckForPsmChange()
+								// to exclude certain situations.
+								//	   MlmeSetPsmBit(pAdapter, PWR_SAVE);
+								pAd->PortCfg.RecvDtim = TRUE;
+									pAd->PortCfg.WindowsPowerMode = Ndis802_11PowerModeFast_PSP;
+								pAd->PortCfg.DefaultListenCount = 3;
+							}
+							else
+							{ //Default Ndis802_11PowerModeCAM
+								// clear PSM bit immediately
+								MlmeSetPsmBit(pAd, PWR_ACTIVE);
+								pAd->PortCfg.RecvDtim = TRUE;
+									pAd->PortCfg.WindowsPowerMode = Ndis802_11PowerModeCAM;
+							}
+							DBGPRINT(RT_DEBUG_TRACE, "%s::(PSMode=%d)\n", __FUNCTION__, pAd->PortCfg.WindowsPowerMode);
+						}
+					}
+					//AuthMode
+					if (RTMPGetKeyParameter("Default", "AuthMode", tmpbuf, 10, buffer))
+					{
+						if ((strcmp(tmpbuf, "SHARED") == 0) || (strcmp(tmpbuf, "shared") == 0)){
+							pAd->PortCfg.AuthMode = Ndis802_11AuthModeShared;
+						DBGPRINT(RT_DEBUG_INFO, "%s::(AuthMode=shared)\n", __FUNCTION__);
+							}
+						else if ((strcmp(tmpbuf, "WPAPSK") == 0) || (strcmp(tmpbuf, "wpapsk") == 0))
+							pAd->PortCfg.AuthMode = Ndis802_11AuthModeWPAPSK;
+						else if ((strcmp(tmpbuf, "WPANONE") == 0) || (strcmp(tmpbuf, "wpanone") == 0))
+							pAd->PortCfg.AuthMode = Ndis802_11AuthModeWPANone;
+						else{
+							pAd->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+						DBGPRINT(RT_DEBUG_INFO, "%s::(AuthMode=open    buf = %s)\n", __FUNCTION__,tmpbuf);
+							}
+
+						pAd->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+						DBGPRINT(RT_DEBUG_TEMP, "%s::(AuthMode=%d)\n", __FUNCTION__, pAd->PortCfg.AuthMode);
+					}
+					//WPAPSK_KEY
+					if (RTMPGetKeyParameter("Default", "WPAPSK", tmpbuf, 255, buffer))
+					{
+						if ((strlen(tmpbuf) >= 8) && (strlen(tmpbuf) <= 64))
+						{
+							PasswordHash((char *)tmpbuf, pAd->PortCfg.Ssid, pAd->PortCfg.SsidLen, keyMaterial);
+							memcpy(pAd->PortCfg.PskKey.Key, keyMaterial, 32);
+							// Use RaConfig as PSK agent.
+							// Start STA supplicant state machine
+							pAd->PortCfg.WpaState = SS_START;
+							DBGPRINT(RT_DEBUG_LOUD, "%s WPAPSK Key => \n", __FUNCTION__);
+							DBGPRINT(RT_DEBUG_LOUD, "    ");
+							for (i = 0; i < 32; i++)
+							{
+								DBGPRINT_RAW(RT_DEBUG_LOUD, "%02x:", pAd->PortCfg.PskKey.Key[i]);
+								if (i%16 == 15) {
+								  DBGPRINT_RAW(RT_DEBUG_LOUD, "\n");
+								  DBGPRINT(RT_DEBUG_LOUD, "    ");
+							}
+							DBGPRINT_RAW(RT_DEBUG_LOUD, "\n");
+						}
+					}
+					//DefaultKeyID
+					if (RTMPGetKeyParameter("Default", "DefaultKeyID", tmpbuf, 10, buffer))
+					{
+						ulInfo = simple_strtol(tmpbuf, 0, 10);
+						if((ulInfo >= 1 ) && (ulInfo <= 4))
+							pAd->PortCfg.DefaultKeyId = (UCHAR) (ulInfo - 1 );
+						else
+							pAd->PortCfg.DefaultKeyId = 0;
+
+						DBGPRINT(RT_DEBUG_TEMP, "%s::(DefaultKeyID=%d)\n", __FUNCTION__, pAd->PortCfg.DefaultKeyId);
+					}
+					//Key1Str
+					if (RTMPGetKeyParameter("Default", "Key1Str", tmpbuf, 26, buffer))
+					{
+						KeyLen = strlen(tmpbuf);
+						switch (KeyLen)
+						{
+							case 0:
+								pAd->PortCfg.SharedKey[0].KeyLen = 0;
+								break;
+							case 5: //wep 40 Ascii type
+								pAd->PortCfg.SharedKey[0].KeyLen = KeyLen;
+								memcpy(pAd->PortCfg.SharedKey[0].Key, tmpbuf, KeyLen);
+								DBGPRINT(RT_DEBUG_TEMP, "%s::(11Key1=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Ascii");
+								break;
+							case 10: //wep 40 Hex type
+								for(i=0; i < KeyLen; i++)
+								{
+									if( !isxdigit(*(tmpbuf+i)) )
+									{
+										bIsHex = FALSE;
+										break;
+									}
+								}
+								
+								if (bIsHex)
+								{
+									pAd->PortCfg.SharedKey[0].KeyLen = KeyLen / 2 ;
+									AtoH(tmpbuf, pAd->PortCfg.SharedKey[0].Key, KeyLen / 2);
+									DBGPRINT(RT_DEBUG_TEMP, "%s::(Key1=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Hex");
+								}
+								break;
+							case 13: //wep 104 Ascii type
+								pAd->PortCfg.SharedKey[0].KeyLen = KeyLen;
+								memcpy(pAd->PortCfg.SharedKey[0].Key, tmpbuf, KeyLen);	
+								DBGPRINT(RT_DEBUG_TEMP, "%s::(Key1=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Ascii");
+								break;
+							case 26: //wep 104 Hex type
+								for(i=0; i < KeyLen; i++)
+								{
+									if( !isxdigit(*(tmpbuf+i)) )
+									{
+										bIsHex = FALSE;
+										break;
+									}
+								}
+
+								if (bIsHex)
+								{
+									pAd->PortCfg.SharedKey[0].KeyLen = KeyLen / 2 ;
+									AtoH(tmpbuf, pAd->PortCfg.SharedKey[0].Key, KeyLen / 2);
+									DBGPRINT(RT_DEBUG_TEMP, "%s::(Key1=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Hex");
+								}
+								break;
+							default:
+								pAd->PortCfg.SharedKey[0].KeyLen = 0;
+								DBGPRINT(RT_DEBUG_TRACE, "%s::Invalid Key (=%s)\n", __FUNCTION__, tmpbuf);
+						}
+						DBGPRINT(RT_DEBUG_TRACE,"!!!!!!!!!!!!!!!!!\n");
+					   RTUSBMultiWrite(pAd, (USHORT)(SEC_CSR0 + 0 * 0x10), pAd->PortCfg.SharedKey[0].Key, 16);	
+						DBGPRINT(RT_DEBUG_TRACE,"!!!!!!!!!!!!!!!!!\n");
+				   }
+					//Key2Str
+					if (RTMPGetKeyParameter("Default", "Key2Str", tmpbuf, 26, buffer))
+					{
+						KeyLen = strlen(tmpbuf);
+						switch (KeyLen)
+						{
+							case 0:
+								pAd->PortCfg.SharedKey[1].KeyLen = 0;
+								break;
+							case 5: //wep 40 Ascii type
+								pAd->PortCfg.SharedKey[1].KeyLen = KeyLen;
+								memcpy(pAd->PortCfg.SharedKey[1].Key, tmpbuf, KeyLen);
+								DBGPRINT(RT_DEBUG_TRACE, "%s::(Key2=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Ascii");
+							case 10: //wep 40 Hex type
+								for(i=0; i < KeyLen; i++)
+								{
+									if( !isxdigit(*(tmpbuf+i)) )
+									{
+										bIsHex = FALSE;
+										break;
+									}
+								}
+								
+								if (bIsHex)
+								{
+									pAd->PortCfg.SharedKey[1].KeyLen = KeyLen / 2 ;
+									AtoH(tmpbuf, pAd->PortCfg.SharedKey[1].Key, KeyLen / 2);
+									DBGPRINT(RT_DEBUG_TRACE, "%s::(Key2=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Hex");
+								}
+								break;
+							case 13: //wep 104 Ascii type
+								pAd->PortCfg.SharedKey[1].KeyLen = KeyLen;
+								memcpy(pAd->PortCfg.SharedKey[1].Key, tmpbuf, KeyLen);	
+								DBGPRINT(RT_DEBUG_TRACE, "%s::(Key2=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Ascii");
+								break;
+							case 26: //wep 104 Hex type
+								for(i=0; i < KeyLen; i++)
+								{
+									if( !isxdigit(*(tmpbuf+i)) )
+									{
+										bIsHex = FALSE;
+										break;
+									}
+								}
+
+								if (bIsHex)
+								{
+									pAd->PortCfg.SharedKey[1].KeyLen = KeyLen / 2 ;
+									AtoH(tmpbuf, pAd->PortCfg.SharedKey[1].Key, KeyLen / 2);
+									DBGPRINT(RT_DEBUG_TRACE, "%s::(Key2=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Hex");
+								}
+								break;
+							default:
+								pAd->PortCfg.SharedKey[1].KeyLen = 0;
+								DBGPRINT(RT_DEBUG_TRACE, "%s::Invalid argument (=%s)\n", __FUNCTION__, tmpbuf);
+						}
+						RTUSBMultiWrite(pAd, (USHORT)(SEC_CSR0 + 1 * 0x10), pAd->PortCfg.SharedKey[1].Key, 16);	
+					}
+					//Key3Str
+					if (RTMPGetKeyParameter("Default", "Key3Str", tmpbuf, 26, buffer))
+					{
+						KeyLen = strlen(tmpbuf);
+						switch (KeyLen)
+						{
+							case 0:
+								pAd->PortCfg.SharedKey[2].KeyLen = 0;
+								break;
+							case 5: //wep 40 Ascii type
+								pAd->PortCfg.SharedKey[2].KeyLen = KeyLen;
+								memcpy(pAd->PortCfg.SharedKey[2].Key, tmpbuf, KeyLen);
+								DBGPRINT(RT_DEBUG_TRACE, "%s::(Key3=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Ascii");
+							case 10: //wep 40 Hex type
+								for(i=0; i < KeyLen; i++)
+								{
+									if( !isxdigit(*(tmpbuf+i)) )
+									{
+										bIsHex = FALSE;
+										break;
+									}
+								}
+
+								if (bIsHex)
+								{
+									pAd->PortCfg.SharedKey[2].KeyLen = KeyLen / 2 ;
+									AtoH(tmpbuf, pAd->PortCfg.SharedKey[2].Key, KeyLen / 2);
+									DBGPRINT(RT_DEBUG_INFO, "%s::(Key3=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Hex");
+								}
+								break;
+							case 13: //wep 104 Ascii type
+								pAd->PortCfg.SharedKey[2].KeyLen = KeyLen;
+								memcpy(pAd->PortCfg.SharedKey[2].Key, tmpbuf, KeyLen);	
+								DBGPRINT(RT_DEBUG_TRACE, "%s::(Key3=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Ascii");
+								break;
+							case 26: //wep 104 Hex type
+								for(i=0; i < KeyLen; i++)
+								{
+									if( !isxdigit(*(tmpbuf+i)) )
+									{
+										bIsHex = FALSE;
+										break;
+									}
+								}
+
+								if (bIsHex)
+								{
+									pAd->PortCfg.SharedKey[2].KeyLen = KeyLen / 2 ;
+									AtoH(tmpbuf, pAd->PortCfg.SharedKey[2].Key, KeyLen / 2);
+									DBGPRINT(RT_DEBUG_TRACE, "%s::(Key3=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Hex");
+								}
+								break;
+							default:
+								pAd->PortCfg.SharedKey[2].KeyLen = 0;
+								DBGPRINT(RT_DEBUG_INFO, "%s::Invalid argument (=%s)\n", __FUNCTION__, tmpbuf);
+						}
+						RTUSBMultiWrite(pAd, (USHORT)(SEC_CSR0 + 2 * 0x10), pAd->PortCfg.SharedKey[2].Key, 16);	
+					}
+					//Key4Str
+					if (RTMPGetKeyParameter("Default", "Key4Str", tmpbuf, 26, buffer))
+					{
+						KeyLen = strlen(tmpbuf);
+						switch (KeyLen)
+						{
+							case 0:
+								pAd->PortCfg.SharedKey[3].KeyLen = 0;
+								break;
+							case 5: //wep 40 Ascii type
+								pAd->PortCfg.SharedKey[3].KeyLen = KeyLen;
+								memcpy(pAd->PortCfg.SharedKey[3].Key, tmpbuf, KeyLen);
+								DBGPRINT(RT_DEBUG_TRACE, "%s::(Key4=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Ascii");
+							case 10: //wep 40 Hex type
+								for(i=0; i < KeyLen; i++)
+								{
+									if( !isxdigit(*(tmpbuf+i)) )
+									{
+										bIsHex = FALSE;
+										break;
+									}
+								}
+
+								if (bIsHex)
+								{
+									pAd->PortCfg.SharedKey[3].KeyLen = KeyLen / 2 ;
+									AtoH(tmpbuf, pAd->PortCfg.SharedKey[3].Key, KeyLen / 2);
+									DBGPRINT(RT_DEBUG_TRACE, "%s::(Key4=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Hex");
+								}
+								break;
+							case 13: //wep 104 Ascii type
+								pAd->PortCfg.SharedKey[3].KeyLen = KeyLen;
+								memcpy(pAd->PortCfg.SharedKey[3].Key, tmpbuf, KeyLen);	
+								DBGPRINT(RT_DEBUG_TRACE, "%s::(Key4=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Ascii");
+								break;
+							case 26: //wep 104 Hex type
+								for(i=0; i < KeyLen; i++)
+								{
+									if( !isxdigit(*(tmpbuf+i)) )
+									{
+										bIsHex = FALSE;
+										break;
+									}
+								}
+
+								if (bIsHex)
+								{
+									pAd->PortCfg.SharedKey[3].KeyLen = KeyLen / 2 ;
+									AtoH(tmpbuf, pAd->PortCfg.SharedKey[3].Key, KeyLen / 2);
+									DBGPRINT(RT_DEBUG_TRACE, "%s::(Key4=%s and type=%s)\n", __FUNCTION__, tmpbuf, "Hex");
+								}
+								break;
+							default:
+								pAd->PortCfg.SharedKey[3].KeyLen = 0;
+								DBGPRINT(RT_DEBUG_TRACE, "%s::Invalid argument (=%s)\n", __FUNCTION__, tmpbuf);
+						}
+						RTUSBMultiWrite(pAd, (USHORT)(SEC_CSR0 + 3 * 0x10), pAd->PortCfg.SharedKey[3].Key, 16);	
+					}
+					//EncrypType
+					if (RTMPGetKeyParameter("Default", "EncrypType", tmpbuf, 10, buffer))
+					{
+						Set_EncrypType_Proc(pAd,(PUCHAR)tmpbuf);
+						DBGPRINT(RT_DEBUG_TEMP, "%s::(EncrypType=%d)\n", __FUNCTION__, pAd->PortCfg.WepStatus);
+
+					}
+				}
+			}
+			else
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "--> %s does not have a write method\n", src);
+			}
+			
+			retval=filp_close(srcf,NULL);
+			
+			if (retval)
+			{
+				DBGPRINT(RT_DEBUG_TRACE, "--> Error %d closing %s\n", -retval, src);
+			}
+		}
+	}
+	
+	set_fs(orgfs);
+	current->fsuid = orgfsuid;
+	current->fsgid = orgfsgid;
+#endif	
+}
+
+
+/*
+	========================================================================
+	
+	Routine Description:
+		Read additional information from EEPROM, such as MAC address
+
+	Arguments:
+		Adapter						Pointer to our adapter
+
+	Return Value:
+		NDIS_STATUS_SUCCESS
+		NDIS_STATUS_FAILURE
+
+	Note:
+	
+	========================================================================
+*/
+NDIS_STATUS	RTUSBWriteHWMACAddress(
+	IN	PRT2570ADAPTER		pAdapter)
+{
+	MAC_CSR2_STRUC		StaMacReg0;
+	MAC_CSR3_STRUC		StaMacReg1;
+	MAC_CSR4_STRUC		StaMacReg2;
+	NDIS_STATUS		Status = NDIS_STATUS_SUCCESS;
+
+	StaMacReg0.field.Byte0 = pAdapter->CurrentAddress[0];
+	StaMacReg0.field.Byte1 = pAdapter->CurrentAddress[1];
+	StaMacReg1.field.Byte2 = pAdapter->CurrentAddress[2];
+	StaMacReg1.field.Byte3 = pAdapter->CurrentAddress[3];
+	StaMacReg2.field.Byte4 = pAdapter->CurrentAddress[4];
+	StaMacReg2.field.Byte5 = pAdapter->CurrentAddress[5];
+
+	RTUSBWriteMACRegister(pAdapter, MAC_CSR2, StaMacReg0.value);
+	RTUSBWriteMACRegister(pAdapter, MAC_CSR3, StaMacReg1.value);
+	RTUSBWriteMACRegister(pAdapter, MAC_CSR4, StaMacReg2.value);
+	return Status;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+		Read initial parameters from EEPROM
+		
+	Arguments:
+		Adapter						Pointer to our adapter
+
+	Return Value:
+		None
+
+	Note:
+		
+	========================================================================
+*/
+VOID	NICReadEEPROMParameters(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	USHORT			i;
+	int			value;
+	UCHAR			TmpPhy;
+	EEPROM_TX_PWR_STRUC	Power;
+	EEPROM_ANTENNA_STRUC	Antenna;//blue
+//	EEPROM_VERSION_STRUC	Version;
+	
+	DBGPRINT(RT_DEBUG_TRACE,"--> NICReadEEPROMParameters\n");
+
+	//Read MAC address.
+	RTUSBReadEEPROM(pAdapter, EEPROM_MAC_ADDRESS_BASE_OFFSET, pAdapter->PermanentAddress, ETH_LENGTH_OF_ADDRESS);
+	DBGPRINT_RAW(RT_DEBUG_TRACE,"MAC address:\n");
+	for (i = 0; i < ETH_LENGTH_OF_ADDRESS; i++)
+		DBGPRINT_RAW(RT_DEBUG_TRACE,"%02x ", pAdapter->PermanentAddress[i]);
+	DBGPRINT_RAW(RT_DEBUG_TRACE,"\n");
+
+	if (pAdapter->PortCfg.bLocalAdminMAC != TRUE)
+	{
+		pAdapter->CurrentAddress[0] = pAdapter->PermanentAddress[0];
+		pAdapter->CurrentAddress[1] = pAdapter->PermanentAddress[1];
+		pAdapter->CurrentAddress[2] = pAdapter->PermanentAddress[2];
+		pAdapter->CurrentAddress[3] = pAdapter->PermanentAddress[3];
+		pAdapter->CurrentAddress[4] = pAdapter->PermanentAddress[4];
+		pAdapter->CurrentAddress[5] = pAdapter->PermanentAddress[5];
+	}
+
+	// Read BBP default value from EEPROM and store to array(EEPROMDefaultValue) in pAdapter
+	RTUSBReadEEPROM(pAdapter, EEPROM_BBP_BASE_OFFSET, (PUCHAR)(pAdapter->EEPROMDefaultValue), 2 * NUM_EEPROM_BBP_PARMS);
+
+	// We have to parse NIC configuration 0 at here.
+	// If TSSI did not have preloaded value, it should reset the TxAutoAgc to false
+	// Therefore, we have to read TxAutoAgc control beforehand.
+	// Read Tx AGC control bit
+	Antenna.word = pAdapter->EEPROMDefaultValue[0];
+	if (Antenna.field.DynamicTxAgcControl == 1)
+		pAdapter->PortCfg.bAutoTxAgc = TRUE;
+	else
+		pAdapter->PortCfg.bAutoTxAgc = FALSE;		
+	
+
+	// Read Tx power value for all 14 channels
+	// Value from 1 - 0x7f. Default value is 24.
+	RTUSBReadEEPROM(pAdapter, EEPROM_TX_PWR_OFFSET, pAdapter->PortCfg.ChannelTxPower, 2 * NUM_EEPROM_TX_PARMS);
+	for (i = 0; i < 2 * NUM_EEPROM_TX_PARMS; i++)
+	{
+		if (pAdapter->PortCfg.ChannelTxPower[i] > 31)
+			pAdapter->PortCfg.ChannelTxPower[i] = 24;
+		DBGPRINT(RT_DEBUG_INFO, "Tx power for channel %d : %0x\n", i, pAdapter->PortCfg.ChannelTxPower[i]);
+	}
+
+	// Read Tx TSSI reference value, OK to reuse Power data structure
+	RTUSBReadEEPROM(pAdapter, EEPROM_TSSI_REF_OFFSET, pAdapter->PortCfg.ChannelTssiRef, 2 * NUM_EEPROM_TX_PARMS);
+	for (i = 0; i < 2 * NUM_EEPROM_TX_PARMS; i++)
+	{
+		if (pAdapter->PortCfg.ChannelTssiRef[i] == 0xff)
+			pAdapter->PortCfg.bAutoTxAgc = FALSE;					
+		DBGPRINT(RT_DEBUG_INFO, "TSSI reference for channel %d : %0x\n", i, pAdapter->PortCfg.ChannelTssiRef[i]);
+	}
+	
+	// Tx Tssi delta offset 0x24
+	RTUSBReadEEPROM(pAdapter, EEPROM_TSSI_DELTA_OFFSET, (PUCHAR)(&(Power.word)), 2);
+	pAdapter->PortCfg.ChannelTssiDelta = Power.field.Byte0;
+	
+	//CountryRegion byte offset = 0x35
+	value = pAdapter->EEPROMDefaultValue[2] >> 8;
+	DBGPRINT(RT_DEBUG_TRACE,"  CountryRegion= 0x%x \n",value);
+	if ((value >= 0) && (value <= 7))
+	{
+		pAdapter->PortCfg.CountryRegion = (UCHAR) value;
+		TmpPhy = pAdapter->PortCfg.PhyMode;
+		pAdapter->PortCfg.PhyMode = 0xff;
+		RTMPSetPhyMode(pAdapter, TmpPhy);
+	}
+	else
+	{
+		// set default country region 
+		pAdapter->PortCfg.CountryRegion = 6;
+		TmpPhy = pAdapter->PortCfg.PhyMode;
+		pAdapter->PortCfg.PhyMode = 0xff;
+		RTMPSetPhyMode(pAdapter, TmpPhy);
+	}
+
+	RTUSBReadEEPROM(pAdapter, EEPROM_BBP_TUNING_OFFSET, (PUCHAR)(pAdapter->EEPROMBBPTuningParameters), 2 * NUM_EEPROM_BBP_TUNING_PARMS);
+	if ((pAdapter->EEPROMBBPTuningParameters[0] != 0xffff) && (pAdapter->EEPROMBBPTuningParameters[0] != 0))
+	{
+		pAdapter->BBPTuningParameters.BBPTuningThreshold = (UCHAR)((pAdapter->EEPROMBBPTuningParameters[0]) & 0xff);
+		DBGPRINT(RT_DEBUG_INFO, "BBPTuningThreshold = %d\n", pAdapter->BBPTuningParameters.BBPTuningThreshold);
+	}
+	if ((pAdapter->EEPROMBBPTuningParameters[1] != 0xffff) && (pAdapter->EEPROMBBPTuningParameters[1] != 0))
+	{
+		pAdapter->BBPTuningParameters.R24LowerValue = (UCHAR)(pAdapter->EEPROMBBPTuningParameters[1] & 0xff);
+		pAdapter->BBPTuningParameters.R24HigherValue = (UCHAR)((pAdapter->EEPROMBBPTuningParameters[1] & 0xff00) >> 8);
+		DBGPRINT(RT_DEBUG_INFO, "R24LowerValue = 0x%x\n", pAdapter->BBPTuningParameters.R24LowerValue);
+		DBGPRINT(RT_DEBUG_INFO, "R24HigherValue = 0x%x\n", pAdapter->BBPTuningParameters.R24HigherValue);
+	}
+	if ((pAdapter->EEPROMBBPTuningParameters[2] != 0xffff) && (pAdapter->EEPROMBBPTuningParameters[2] != 0))
+	{
+		pAdapter->BBPTuningParameters.R25LowerValue = (UCHAR)(pAdapter->EEPROMBBPTuningParameters[2] & 0xff);
+		pAdapter->BBPTuningParameters.R25HigherValue = (UCHAR)((pAdapter->EEPROMBBPTuningParameters[2] & 0xff00) >> 8);
+		DBGPRINT(RT_DEBUG_INFO, "R25LowerValue = 0x%x\n", pAdapter->BBPTuningParameters.R25LowerValue);
+		DBGPRINT(RT_DEBUG_INFO, "R25HigherValue = 0x%x\n", pAdapter->BBPTuningParameters.R25HigherValue);
+	}
+	if ((pAdapter->EEPROMBBPTuningParameters[3] != 0xffff) && (pAdapter->EEPROMBBPTuningParameters[3] != 0))
+	{
+		pAdapter->BBPTuningParameters.R61LowerValue = (UCHAR)(pAdapter->EEPROMBBPTuningParameters[3] & 0xff);
+		pAdapter->BBPTuningParameters.R61HigherValue = (UCHAR)((pAdapter->EEPROMBBPTuningParameters[3] & 0xff00) >> 8);
+		DBGPRINT(RT_DEBUG_INFO, "R61LowerValue = 0x%x\n", pAdapter->BBPTuningParameters.R61LowerValue);
+		DBGPRINT(RT_DEBUG_INFO, "R61HigherValue = 0x%x\n", pAdapter->BBPTuningParameters.R61HigherValue);
+	}
+	if ((pAdapter->EEPROMBBPTuningParameters[4] != 0xffff) && (pAdapter->EEPROMBBPTuningParameters[4] != 0))
+	{
+		pAdapter->PortCfg.BbpTuning.VgcUpperBound = (UCHAR)(pAdapter->EEPROMBBPTuningParameters[4] & 0xff);
+		DBGPRINT_RAW(RT_DEBUG_INFO, "VgcUpperBound = 0x%x\n", pAdapter->PortCfg.BbpTuning.VgcUpperBound);
+	}
+	if ((pAdapter->EEPROMBBPTuningParameters[5] != 0xffff) && (pAdapter->EEPROMBBPTuningParameters[5] != 0))
+	{
+		pAdapter->BBPTuningParameters.BBPR17LowSensitivity = (UCHAR)(pAdapter->EEPROMBBPTuningParameters[5] & 0xff);
+		pAdapter->BBPTuningParameters.BBPR17MidSensitivity = (UCHAR)((pAdapter->EEPROMBBPTuningParameters[5] & 0xff00) >> 8);
+		DBGPRINT_RAW(RT_DEBUG_INFO, "BBPR17LowSensitivity = 0x%x\n", pAdapter->BBPTuningParameters.BBPR17LowSensitivity);
+		DBGPRINT_RAW(RT_DEBUG_INFO, "BBPR17MidSensitivity = 0x%x\n", pAdapter->BBPTuningParameters.BBPR17MidSensitivity);
+	}
+	if ((pAdapter->EEPROMBBPTuningParameters[6] != 0xffff) && (pAdapter->EEPROMBBPTuningParameters[6] != 0))
+	{
+		pAdapter->BBPTuningParameters.RSSIToDbmOffset = (UCHAR)(pAdapter->EEPROMBBPTuningParameters[6] & 0xff);
+		DBGPRINT_RAW(RT_DEBUG_INFO, "RSSIToDbmOffset = 0x%x\n", pAdapter->BBPTuningParameters.RSSIToDbmOffset);
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE,"<-- NICReadEEPROMParameters\n");
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+		Set default value from EEPROM
+		
+	Arguments:
+		Adapter						Pointer to our adapter
+
+	Return Value:
+		None
+
+	Note:
+		
+	========================================================================
+*/
+VOID	NICInitAsicFromEEPROM(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	USHORT					i, value;
+	USHORT	Value5, Value6;
+	UCHAR					TxValue,RxValue;
+	EEPROM_ANTENNA_STRUC	Antenna;
+	EEPROM_NIC_CONFIG2_STRUC	NicConfig2;
+
+	DBGPRINT(RT_DEBUG_TRACE,"--> NICInitAsicFromEEPROM\n");
+
+	//Initialize BBP registers.
+	for(i = 3; i < NUM_EEPROM_BBP_PARMS; i++)
+	{
+		value = pAdapter->EEPROMDefaultValue[i];
+		
+		if((value != 0xFFFF) && (value != 0))
+		{
+			//blue,RTUSBWriteMACRegister(pAdapter, PHY_CSR7, value);
+			USHORT	id;
+			id = ((value & 0xff00) >> 8);
+			{
+				USHORT	temp;
+				UINT	j = 0;
+				do
+				{
+					RTUSBReadMACRegister(pAdapter, PHY_CSR8, &temp);
+					if (!(temp & BUSY))
+						break;
+					j++;
+				}
+				while (j < RETRY_LIMIT);
+				
+				RTUSBWriteMACRegister(pAdapter, PHY_CSR7, value);
+			}
+				
+		}
+	}
+
+	DBGPRINT(RT_DEBUG_INFO,"pAdapter->BBPTuningParameters.R24LowerValue = %x\n", pAdapter->BBPTuningParameters.R24LowerValue);
+	DBGPRINT(RT_DEBUG_INFO, "pAdapter->BBPTuningParameters.R25LowerValue = %x\n", pAdapter->BBPTuningParameters.R25LowerValue);
+	DBGPRINT(RT_DEBUG_INFO, "pAdapter->BBPTuningParameters.R61LowerValue = %x\n", pAdapter->BBPTuningParameters.R61LowerValue);
+	RTUSBWriteBBPRegister(pAdapter, 24, pAdapter->BBPTuningParameters.R24LowerValue);
+	RTUSBWriteBBPRegister(pAdapter, 25, pAdapter->BBPTuningParameters.R25LowerValue);
+	RTUSBWriteBBPRegister(pAdapter, 61, pAdapter->BBPTuningParameters.R61LowerValue);
+
+
+	//Select antennas.
+	Antenna.word = pAdapter->EEPROMDefaultValue[0];
+
+	if ((Antenna.word == 0xFFFF) || (Antenna.field.TxDefaultAntenna > 2) || (Antenna.field.RxDefaultAntenna > 2))
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"E2PROM error(=0x%04x), hard code as 0x0002\n", Antenna.word);
+		Antenna.word = 0x0002;
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE,"Antenna.word = 0x%x \n", Antenna.word);
+	pAdapter->PortCfg.NumberOfAntenna = 2;	// (UCHAR)Antenna.field.NumOfAntenna;
+	pAdapter->PortCfg.CurrentTxAntenna = (UCHAR)Antenna.field.TxDefaultAntenna;
+	pAdapter->PortCfg.CurrentRxAntenna = (UCHAR)Antenna.field.RxDefaultAntenna;
+	   pAdapter->PortCfg.RfType = (UCHAR) Antenna.field.RfType;//blue
+	DBGPRINT(RT_DEBUG_TRACE,"pAdapter->PortCfg.RfType = 0x%x \n", pAdapter->PortCfg.RfType);
+	RTUSBReadBBPRegister(pAdapter, BBP_Tx_Configure, &TxValue);
+	RTUSBReadBBPRegister(pAdapter, BBP_Rx_Configure, &RxValue);
+	RTUSBReadMACRegister(pAdapter, PHY_CSR5, &Value5);
+	RTUSBReadMACRegister(pAdapter, PHY_CSR6, &Value6);
+
+	// Tx antenna select
+	if(Antenna.field.TxDefaultAntenna == 1)   
+	{
+		TxValue = (TxValue & 0xFC) | 0x00; // Antenna A
+		Value5 = (Value5 & 0xFFFC) | 0x0000;
+		Value6 = (Value6 & 0xFFFC) | 0x0000;
+	}
+	else if(Antenna.field.TxDefaultAntenna == 2)  
+	{
+		TxValue = (TxValue & 0xFC) | 0x02; // Antenna B
+		Value5 = (Value5 & 0xFFFC) | 0x0002;
+		Value6 = (Value6 & 0xFFFC) | 0x0002;
+	}
+	else
+	{
+		TxValue = (TxValue & 0xFC) | 0x01; // Antenna Diversity
+		Value5 = (Value5 & 0xFFFC) | 0x0001;
+		Value6 = (Value6 & 0xFFFC) | 0x0001;
+	}
+
+
+	// Rx antenna select
+	if(Antenna.field.RxDefaultAntenna == 1)
+		RxValue = (RxValue & 0xFC) | 0x00; // Antenna A
+	else if(Antenna.field.RxDefaultAntenna == 2)
+		RxValue = (RxValue & 0xFC) | 0x02; // Antenna B
+	else
+		RxValue = (RxValue & 0xFC) | 0x01; // Antenna Diversity
+
+
+	DBGPRINT(RT_DEBUG_TRACE, "<-- NICInitAsicFromEEPROM pAdapter->PortCfg.RfType = %d\n", pAdapter->PortCfg.RfType);
+	// RT5222 needs special treatment to swap TX I/Q
+	if (pAdapter->PortCfg.RfType == RFIC_5222)
+	{
+		Value5 |= 0x0004;
+		Value6 |= 0x0004;
+		TxValue |= 0x04;		 // TX I/Q flip
+	}
+	// RT2525E need to flip TX I/Q but not RX I/Q
+	else if (pAdapter->PortCfg.RfType == RFIC_2525E)	
+	{
+		Value5 |= 0x0004;
+		Value6 |= 0x0004;
+		TxValue |= 0x04;		 // TX I/Q flip
+		RxValue &= 0xfb;		 // RX I/Q no flip
+	}
+	
+	RTUSBWriteMACRegister(pAdapter, PHY_CSR5, Value5);
+	RTUSBWriteMACRegister(pAdapter, PHY_CSR6, Value6);
+			
+	// Change to match microsoft definition, 0xff: diversity, 0: A, 1: B
+	pAdapter->PortCfg.CurrentTxAntenna--;
+	pAdapter->PortCfg.CurrentRxAntenna--;
+
+	RTUSBWriteBBPRegister(pAdapter, BBP_Tx_Configure, TxValue);
+	RTUSBWriteBBPRegister(pAdapter, BBP_Rx_Configure, RxValue);
+
+	
+	//Set LED mode.
+	if (Antenna.field.LedMode == LED_MODE_TXRX_ACTIVITY)
+		pAdapter->PortCfg.LedMode = LED_MODE_TXRX_ACTIVITY;
+	else if (Antenna.field.LedMode == LED_MODE_SINGLE)
+	{
+		pAdapter->PortCfg.LedMode = LED_MODE_SINGLE;
+		ASIC_LED_ACT_ON(pAdapter);
+	}
+	else if (Antenna.field.LedMode == LED_MODE_ASUS)
+	{
+		pAdapter->PortCfg.LedMode = LED_MODE_ASUS;
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR20, 0x0002);
+	}
+	else if (Antenna.field.LedMode == LED_MODE_ALPHA)
+	{
+		pAdapter->PortCfg.LedMode = LED_MODE_ALPHA;
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR20, 1);
+		pAdapter->PortCfg.LedCntl.fOdd = FALSE;
+	}	 
+	else
+		pAdapter->PortCfg.LedMode = LED_MODE_DEFAULT;
+
+
+	// Read Hardware controlled Radio state enable bit
+	if (Antenna.field.HardwareRadioControl == 1)
+	{
+		pAdapter->PortCfg.bHardwareRadio = TRUE;
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR19, 0);
+
+		// Read GPIO pin0 as Hardware controlled radio state
+		RTUSBReadMACRegister(pAdapter, MAC_CSR19, &value);
+		if ((value & 0x80) == 0)
+		{
+			pAdapter->PortCfg.bHwRadio = FALSE;
+			pAdapter->PortCfg.bRadio = FALSE;
+			RTUSBWriteMACRegister(pAdapter, MAC_CSR13, 0);
+			RTUSBWriteMACRegister(pAdapter, MAC_CSR14, 0);
+			RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_RADIO_OFF);
+        	DBGPRINT(RT_DEBUG_ERROR, "2Set fRTMP_ADAPTER_RADIO_OFF ");
+			if (pAdapter->PortCfg.LedMode == LED_MODE_ASUS)
+			{
+				// Turn bit 17 for Radio OFF
+				RTUSBWriteMACRegister(pAdapter, MAC_CSR20, 1);
+			}
+		}
+	}
+	else
+		pAdapter->PortCfg.bHardwareRadio = FALSE;		
+	
+	NicConfig2.word = pAdapter->EEPROMDefaultValue[1];
+	if (NicConfig2.word == 0xffff)
+		NicConfig2.word = 0;	// empty E2PROM, use default
+	
+	// for dynamic BBP R17:RX sensibility tuning
+	{
+		UCHAR r17;
+		RTUSBReadBBPRegister(pAdapter, 17, &r17);
+		pAdapter->PortCfg.BbpTuningEnable = (NicConfig2.field.DynamicBbpTuning==0)? 1:0;
+		pAdapter->PortCfg.VgcLowerBound   = r17;
+
+		// 2004-3-4 per David's request, R7 starts at upper bound
+		r17 = pAdapter->PortCfg.BbpTuning.VgcUpperBound;
+		pAdapter->PortCfg.LastR17Value = r17;
+		RTUSBWriteBBPRegister(pAdapter, 17, r17);
+
+		// 2004-2-2 per David's request, lower R17 low-bound for very good quality NIC
+		pAdapter->PortCfg.VgcLowerBound -= 6;  
+		DBGPRINT(RT_DEBUG_TRACE,"R17 tuning enable=%d, R17=0x%02x, range=<0x%02x, 0x%02x>\n",
+			pAdapter->PortCfg.BbpTuningEnable, r17, pAdapter->PortCfg.VgcLowerBound, pAdapter->PortCfg.BbpTuning.VgcUpperBound);
+	}
+
+	    AsicSwitchChannel(pAdapter, pAdapter->PortCfg.Channel);
+	DBGPRINT(RT_DEBUG_TRACE,"RF IC=%d, LED mode=%d\n", pAdapter->PortCfg.RfType, pAdapter->PortCfg.LedMode);
+
+	DBGPRINT(RT_DEBUG_TRACE,"<-- NICInitAsicFromEEPROM\n");
+}
+
+VOID	RT2570InitializeAsic(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	ULONG			Index;
+	UCHAR			buffer[22];
+	USHORT			temp;
+	UCHAR			Value = 0xff;
+	UINT			i;
+
+	DBGPRINT(RT_DEBUG_TRACE, "--> NICInitializeAsic\n");
+
+	do
+	{
+		//NdisMSleep(1000);
+		RTUSB_VendorRequest(pAdapter,
+			0,
+			DEVICE_VENDOR_REQUEST_OUT,
+			0x1,
+			0x4,
+			0x1,
+			NULL,
+			0);
+
+		RTUSBSingleWrite(pAdapter, 0x308, 0xf0);//asked by MAX
+
+		// Disable RX at first beginning. Before BulkInReceive, we will enable RX.
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR2, 1);
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR13, 0x1111);//requested by Jerry
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR14, 0x1E11);
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR1, 3); // reset MAC state machine, requested by Kevin 2003-2-11
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR1, 0); // reset MAC state machine, requested by Kevin 2003-2-11
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR5, 0x8C8D);
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR6, 0x8B8A);
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR7, 0x8687);
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR8, 0x0085);
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR21, 0xe78f);
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR9, 0xFF1D);
+
+		i = 0;
+		RTUSBReadMACRegister(pAdapter, MAC_CSR17, &temp);
+		while (((temp & 0x01e0 ) != 0x01e0) && (i < 50))
+		{
+			NdisMSleep(1000);
+			RTUSBReadMACRegister(pAdapter, MAC_CSR17, &temp);
+
+			i++;
+		}
+		if (i == 50)
+		{
+			if (RTUSB_ResetDevice(pAdapter) == FALSE)
+			{
+			//RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS);
+				DBGPRINT(RT_DEBUG_TRACE, "<== NICInitializeAsic ERROR\n");
+			return;
+			}
+			else
+				continue;
+		}
+	
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR1, 4);
+		RTUSBReadMACRegister(pAdapter, MAC_CSR0, &temp);
+		if ( temp >= 3){
+		   RTUSBReadMACRegister(pAdapter, PHY_CSR2, &temp);
+		   RTUSBWriteMACRegister(pAdapter, PHY_CSR2, temp & 0xFFFD);		   
+		}
+		else
+		{
+			DBGPRINT(RT_DEBUG_TRACE, "LNA 3 mode\n");
+			RTUSBWriteMACRegister(pAdapter, PHY_CSR2, 0x3002); // LNA 3 mode
+
+		}
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR11, 2);
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR22, 0x53);
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR15, 0x01ee);
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR16, 0);
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR8, 0x0780);//steven:limit the maximum frame length
+		
+		RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &temp);
+		temp &= 0xe007;
+		temp |= ((LENGTH_802_11 << 3) | (0x000f << 9));
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, temp);
+		
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR19, 0);
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR18, 0x5a);
+
+		//set RF_LE to low when standby
+		RTUSBReadMACRegister(pAdapter, PHY_CSR4, &temp);
+		RTUSBWriteMACRegister(pAdapter, PHY_CSR4, temp | 1);
+		//NdisMSleep(1);//wait for PLL to become stable
+
+		i = 0;
+		do
+		{
+			RTUSBReadBBPRegister(pAdapter, BBP_Version, &Value);
+			DBGPRINT(RT_DEBUG_TRACE, "Read BBP_Version Value = %d\n", Value);
+			i++;
+		}while (((Value == 0xff) || (Value == 0x00)) && (i < 50));
+		if (i < 50)//BBP ready
+		{
+			break;
+		}
+		else
+		{
+			if ( RTUSB_ResetDevice(pAdapter) == FALSE)
+			{
+				RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS);
+				return;
+			}
+		}
+	}while (1);
+
+	// Initialize BBP register to default value
+	for (Index = 0; Index < NUM_BBP_REG_PARMS; Index++)
+	{
+		i = 0;
+		do
+		{
+			RTUSBReadMACRegister(pAdapter, PHY_CSR8, &temp);
+			if (!(temp & BUSY))
+				break;
+			i++;
+		}
+		while (i < RETRY_LIMIT);
+		
+		RTUSBWriteMACRegister(pAdapter, PHY_CSR7, BBPRegTable[Index]);
+	}
+
+
+	// Initialize RF register to default value
+	AsicSwitchChannel(pAdapter, pAdapter->PortCfg.Channel);
+	AsicLockChannel(pAdapter, pAdapter->PortCfg.Channel);
+
+	// Add radio off control
+	if (pAdapter->PortCfg.bRadio == FALSE)
+	{
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR13, 0);
+		RTUSBWriteMACRegister(pAdapter, MAC_CSR14, 0);
+
+		RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_RADIO_OFF);
+        	DBGPRINT(RT_DEBUG_ERROR, "1Set fRTMP_ADAPTER_RADIO_OFF ");
+	}
+
+
+	RTUSBMultiRead(pAdapter, STA_CSR0, buffer, 22);
+	
+	DBGPRINT(RT_DEBUG_TRACE, "<-- NICInitializeAsic\n");
+}
+/*
+	========================================================================
+	
+	Routine Description:
+		Reset NIC from error
+
+	Arguments:
+		Adapter						Pointer to our adapter
+
+	Return Value:
+		None
+
+	IRQL = PASSIVE_LEVEL
+
+	Note:
+		Reset NIC from error state
+		
+	========================================================================
+*/
+VOID	NICResetFromError(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+
+	RT2570InitializeAsic(pAdapter);
+#ifdef	INIT_FROM_EEPROM
+	NICInitAsicFromEEPROM(pAdapter);
+#endif
+	RTUSBWriteHWMACAddress(pAdapter);
+	
+	// Switch to current channel, since during reset process, the connection should remains on.	
+	AsicSwitchChannel(pAdapter, pAdapter->PortCfg.Channel);
+	AsicLockChannel(pAdapter, pAdapter->PortCfg.Channel);
+}
+
+VOID CreateThreads( struct net_device *net_dev )
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) net_dev->priv;
+
+	// Creat MLME Thread
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	// Creat MLME Thread
+	pAdapter->MLMEThr_pid= -1;
+
+	pAdapter->MLMEThr_pid = kernel_thread(MlmeThread, pAdapter, CLONE_VM);
+	if (pAdapter->MLMEThr_pid < 0)
+		printk(KERN_WARNING "%s: unable to start mlme thread\n",pAdapter->net->name);
+
+	// Creat Command Thread
+	pAdapter->RTUSBCmdThr_pid= -1;
+	pAdapter->RTUSBCmdThr_pid = kernel_thread(RTUSBCmdThread, pAdapter, CLONE_VM);
+	if (pAdapter->RTUSBCmdThr_pid < 0)
+		printk(KERN_WARNING "%s: unable to start RTUSBCmd thread\n",pAdapter->net->name);
+#else
+	// Creat MLME Thread
+	pAdapter->MLMEThr = kthread_run(MlmeThread, pAdapter, "rtusb-mlme");
+	if (IS_ERR(pAdapter->MLMEThr))
+		printk(KERN_WARNING "%s: unable to start mlme thread\n",pAdapter->net->name);
+	// Creat Command Thread
+	pAdapter->RTUSBCmdThr = kthread_run(RTUSBCmdThread, pAdapter, "rtusb-usbcmd");
+	if (IS_ERR(pAdapter->RTUSBCmdThr))
+		printk(KERN_WARNING "%s: unable to start RTUSBCmd thread\n",pAdapter->net->name);
+#endif
+}
+
+
+NDIS_STATUS RTMPAllocAdapterBlock( PRT2570ADAPTER	*ppAdapter	)
+{
+	NDIS_STATUS 	Status=NDIS_STATUS_SUCCESS;
+
+#if 0
+	PRT2570ADAPTER	pAdapter;
+	DBGPRINT(RT_DEBUG_TRACE,"--> RTMPAllocAdapterBlock\n");
+
+	*ppAdapter = NULL;
+
+	do
+	{
+		pAdapter = (PRT2570ADAPTER) kmalloc(sizeof(RT2570ADAPTER), GFP_KERNEL);
+		
+		if (!pAdapter) {
+			DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+			Status = NDIS_STATUS_RESOURCES;
+			break;
+		}
+
+		
+		memset((PUCHAR) pAdapter, 0, sizeof(RT2570ADAPTER));
+		
+	} while (FALSE);
+
+	*ppAdapter = pAdapter;
+
+	DBGPRINT(RT_DEBUG_ERROR,"<-- RTMPAllocAdapterBlock, Status=%x\n", Status);
+#endif
+	return Status;
+}
+
+
+NDIS_STATUS NICInitTransmit(  PRT2570ADAPTER	 pAdapter )
+{
+	UCHAR	i;
+	NDIS_STATUS 	Status = NDIS_STATUS_SUCCESS;
+	PTX_CONTEXT	pPsPollContext = &(pAdapter->PsPollContext);
+	PTX_CONTEXT	pNullContext = &(pAdapter->NullContext);
+
+	DBGPRINT(RT_DEBUG_TRACE,"--> NICInitTransmit\n");
+
+	// Initialize all Transmit releated queues
+	skb_queue_head_init(&pAdapter->SendTxWaitQueue);
+	
+	// Init Ring index pointer
+	pAdapter->NextRxBulkInIndex			= 0;
+	pAdapter->NextTxIndex			= 0;
+	pAdapter->NextBulkOutIndex		= 0;	// Next Local tx ring pointer waiting for buck out
+	pAdapter->NextMLMEIndex 		= 0;
+	pAdapter->PushMgmtIndex 	   = 0;
+	pAdapter->PopMgmtIndex		   = 0;
+	atomic_set(&pAdapter->MgmtQueueSize,0);
+	pAdapter->BulkOutPending	= FALSE;	
+	pAdapter->PrioRingFirstIndex	= 0;
+	pAdapter->PrioRingTxCnt 		= 0;
+
+	do
+	{
+		for ( i= 0; i < TX_RING_SIZE; i++ )
+		{
+			PTX_CONTEXT pTxContext = &(pAdapter->TxContext[i]);
+			
+			//Allocate URB
+			pTxContext->pUrb = RT2570_USB_ALLOC_URB(0);
+			if(pTxContext->pUrb == NULL){
+				Status = NDIS_STATUS_RESOURCES;
+				goto done;
+			}
+			pTxContext->TransferBuffer= (PTX_BUFFER) kmalloc(sizeof(TX_BUFFER), GFP_KERNEL);
+			Status = NDIS_STATUS_SUCCESS;
+			if(!pTxContext->TransferBuffer){
+				DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+				Status = NDIS_STATUS_RESOURCES;
+				goto out1;
+			}
+
+			memset(pTxContext->TransferBuffer, 0, sizeof(TX_BUFFER));
+
+			pTxContext->pAdapter = pAdapter;
+			pTxContext->InUse = FALSE;
+			pTxContext->IRPPending = FALSE;
+		}
+		
+		for ( i= 0; i < PRIO_RING_SIZE; i++ )
+		{
+			PTX_CONTEXT	pMLMEContext = &(pAdapter->MLMEContext[i]);
+			
+			pMLMEContext->pUrb = RT2570_USB_ALLOC_URB(0);
+			if(pMLMEContext->pUrb == NULL){
+				Status = NDIS_STATUS_RESOURCES;
+				goto out1;
+			}
+			
+			pMLMEContext->TransferBuffer= (PTX_BUFFER) kmalloc(sizeof(TX_BUFFER), GFP_KERNEL);
+			if(!pMLMEContext->TransferBuffer){
+				DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+				Status = NDIS_STATUS_RESOURCES;
+				goto out2;
+			}
+			
+			memset(pMLMEContext->TransferBuffer, 0, sizeof(TX_BUFFER));
+			pMLMEContext->pAdapter = pAdapter;
+			pMLMEContext->InUse = FALSE;
+			pMLMEContext->IRPPending = FALSE;
+		}
+
+		for (i = 0; i < BEACON_RING_SIZE; i++)
+		{
+			PTX_CONTEXT	pBeaconContext = &(pAdapter->BeaconContext[i]);
+			pBeaconContext->pUrb = RT2570_USB_ALLOC_URB(0);
+			if(pBeaconContext->pUrb == NULL){
+				Status = NDIS_STATUS_RESOURCES;
+				goto out2;
+			}
+			
+			pBeaconContext->TransferBuffer= (PTX_BUFFER) kmalloc(sizeof(TX_BUFFER), GFP_KERNEL);
+			if(!pBeaconContext->TransferBuffer){
+				DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+				Status = NDIS_STATUS_RESOURCES;
+				goto out3;
+			}
+			memset(pBeaconContext->TransferBuffer, 0, sizeof(TX_BUFFER));
+
+			pBeaconContext->pAdapter = pAdapter;
+			pBeaconContext->InUse = FALSE;
+			pBeaconContext->IRPPending = FALSE;
+		}
+
+		pNullContext->pUrb = RT2570_USB_ALLOC_URB(0);
+		if(pNullContext->pUrb == NULL){
+			Status = NDIS_STATUS_RESOURCES;
+			goto out3;
+		}		 
+		
+		pNullContext->TransferBuffer= (PTX_BUFFER) kmalloc(sizeof(TX_BUFFER), GFP_KERNEL);
+		if(!pNullContext->TransferBuffer){
+			DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+			Status = NDIS_STATUS_RESOURCES;
+			goto out4;
+		}
+
+		memset(pNullContext->TransferBuffer, 0, sizeof(TX_BUFFER));
+		pNullContext->pAdapter = pAdapter;
+		pNullContext->InUse = FALSE;
+		pNullContext->IRPPending = FALSE;
+
+		pPsPollContext->pUrb = RT2570_USB_ALLOC_URB(0);
+		if(pPsPollContext->pUrb == NULL){
+			Status = NDIS_STATUS_RESOURCES;
+			goto out4;
+		}		 
+		
+		pPsPollContext->TransferBuffer= (PTX_BUFFER) kmalloc(sizeof(TX_BUFFER), GFP_KERNEL);
+		if(!pPsPollContext->TransferBuffer){
+			DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+			Status = NDIS_STATUS_RESOURCES;
+			goto out5;
+		}
+
+		memset(pPsPollContext->TransferBuffer, 0, sizeof(TX_BUFFER));
+		pPsPollContext->pAdapter = pAdapter;
+		pPsPollContext->InUse = FALSE;
+		pPsPollContext->IRPPending = FALSE;
+
+#if 0					
+
+		//Allocate URB
+		pWpaPskContext->pUrb = RT2570_USB_ALLOC_URB(0);
+		if(pWpaPskContext->pUrb == NULL){
+			Status = NDIS_STATUS_RESOURCES;
+			goto done;
+		}
+			
+			
+	
+		pWpaPskContext->TransferBuffer= (PWPAPSK_BUFFER) kmalloc(sizeof(WPAPSK_BUFFER), GFP_KERNEL);
+		Status = NDIS_STATUS_SUCCESS;
+		if(!pWpaPskContext->TransferBuffer){
+			DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+			Status = NDIS_STATUS_RESOURCES;
+			goto done;
+		}
+
+		memset(pWpaPskContext->TransferBuffer, 0, sizeof(WPAPSK_BUFFER));
+
+		pWpaPskContext->pAdapter = pAdapter;
+		pWpaPskContext->InUse = FALSE;
+		pWpaPskContext->IRPPending = FALSE;
+#endif
+
+
+#ifdef TEST_MODE_SUPPORT
+		Status = RT2570AllocateMemory(&(pAdapter->pTxUrb), sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));
+		if ((Status != NDIS_STATUS_SUCCESS) || (pAdapter->pTxUrb == NULL))
+		{
+			Status = NDIS_STATUS_RESOURCES;
+			goto done;
+		}
+		Status = RT2570AllocateMemory(&(pAdapter->TxBuffer), BUFFER_SIZE);
+		if ((Status != NDIS_STATUS_SUCCESS) || (pAdapter->TxBuffer == NULL))
+		{
+			Status = NDIS_STATUS_RESOURCES;
+			goto done;
+		}
+		memset(pAdapter->TxBuffer, 0, BUFFER_SIZE);
+		stackSize = pAdapter->pNextDeviceObject->StackSize + 1;
+		pAdapter->pTxIrp = IoAllocateIrp(stackSize, FALSE);
+#endif
+	}
+	while (FALSE);
+
+	return Status;
+
+out5:	
+	if (NULL != pPsPollContext->pUrb)
+	{
+		usb_kill_urb(pPsPollContext->pUrb);
+		usb_free_urb(pPsPollContext->pUrb);
+		pPsPollContext->pUrb = NULL;
+	}
+	if (NULL != pPsPollContext->TransferBuffer)
+	{
+		FreeMemory(pPsPollContext->TransferBuffer);
+		pPsPollContext->TransferBuffer = NULL;
+	}
+out4:	
+	if (NULL != pNullContext->pUrb)
+	{
+		usb_kill_urb(pNullContext->pUrb);
+		usb_free_urb(pNullContext->pUrb);
+		pNullContext->pUrb = NULL;
+	}
+	if (NULL != pNullContext->TransferBuffer)
+	{
+		FreeMemory(pNullContext->TransferBuffer);
+		pNullContext->TransferBuffer = NULL;
+	}
+out3:	
+	// Free beacon frame resource
+	for (i = 0; i < BEACON_RING_SIZE; i++)
+	{
+		PTX_CONTEXT	pBeaconContext = &(pAdapter->BeaconContext[i]);
+		if ( NULL != pBeaconContext->pUrb )
+		{
+			usb_kill_urb(pBeaconContext->pUrb);
+			usb_free_urb(pBeaconContext->pUrb);
+			pBeaconContext->pUrb = NULL;
+		}
+		
+		if ( NULL != pBeaconContext->TransferBuffer )
+		{
+			FreeMemory( pBeaconContext->TransferBuffer);
+			pBeaconContext->TransferBuffer = NULL;
+		}
+	}
+out2:	
+	for ( i= 0; i < PRIO_RING_SIZE; i++ )
+	{
+		PTX_CONTEXT pMLMEContext = &(pAdapter->MLMEContext[i]);
+		
+
+		if ( NULL != pMLMEContext->pUrb )
+		{
+			usb_kill_urb(pMLMEContext->pUrb);
+			usb_free_urb(pMLMEContext->pUrb);
+			pMLMEContext->pUrb = NULL;
+		}
+		
+		if ( NULL != pMLMEContext->TransferBuffer )
+		{
+			FreeMemory( pMLMEContext->TransferBuffer);
+			pMLMEContext->TransferBuffer = NULL;
+		}
+	} // for
+out1:	
+	for ( i= 0; i < TX_RING_SIZE; i++ )
+	{
+		PTX_CONTEXT pTxContext = &(pAdapter->TxContext[i]);
+
+		if ( NULL != pTxContext->pUrb )
+		{
+			usb_kill_urb(pTxContext->pUrb);
+			usb_free_urb(pTxContext->pUrb);
+			pTxContext->pUrb = NULL;
+		}
+		if ( NULL != pTxContext->TransferBuffer )
+		{
+			FreeMemory( pTxContext->TransferBuffer);
+			pTxContext->TransferBuffer = NULL;
+		}
+	} // for
+done:	
+	DBGPRINT(RT_DEBUG_TRACE,"<-- NICInitTransmit\n");
+	return Status;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+		Initialize receive data structures
+
+	Arguments:
+		Adapter 					Pointer to our adapter
+
+	Return Value:
+		NDIS_STATUS_SUCCESS
+		NDIS_STATUS_RESOURCES
+
+	Note:
+		Initialize all receive releated private buffer, include those define
+		in RTMP_ADAPTER structure and all private data structures. The mahor
+		work is to allocate buffer for each packet and chain buffer to 
+		NDIS packet descriptor.
+		
+	========================================================================
+*/
+NDIS_STATUS NICInitRecv( PRT2570ADAPTER	pAdapter)
+{
+	UCHAR	i;
+	NDIS_STATUS 	Status = NDIS_STATUS_SUCCESS;
+
+
+	DBGPRINT(RT_DEBUG_TRACE,"--> NICInitRecv\n");
+	pAdapter->NextRxBulkInIndex = 0;
+	atomic_set( &pAdapter->PendingRx, 0);
+	for (i = 0; i < RX_RING_SIZE; i++)
+	{
+		PRX_CONTEXT  pRxContext = &(pAdapter->RxContext[i]);
+		pRxContext->pUrb = RT2570_USB_ALLOC_URB(0);
+		if(pRxContext->pUrb == NULL)
+		{
+			Status = NDIS_STATUS_RESOURCES;
+			DBGPRINT(RT_DEBUG_TRACE,"--> pRxContext->pUrb == NULL\n");
+			break;
+		}
+						
+		pRxContext->TransferBuffer= (PUCHAR) kmalloc(BUFFER_SIZE, GFP_KERNEL);
+		if(!pRxContext->TransferBuffer)
+		{
+			DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+			Status = NDIS_STATUS_RESOURCES;
+			break;
+		}	
+
+		memset(pRxContext->TransferBuffer, 0, BUFFER_SIZE);
+		
+		pRxContext->pAdapter = pAdapter;
+		pRxContext->InUse = FALSE;
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE,"<-- NICInitRecv\n");	
+	return Status;
+}
+NDIS_STATUS RT2570InitAdapterBlock(	PRT2570ADAPTER	pAdapter)
+{
+	NDIS_STATUS 	Status = NDIS_STATUS_SUCCESS;
+	UINT			i;
+	PCmdQElmt		cmdqelmt;
+	
+	do
+	{
+		for (i = 0; i < COMMAND_QUEUE_SIZE; i++)
+		{
+			cmdqelmt = &(pAdapter->CmdQElements[i]);
+			memset(cmdqelmt, 0, sizeof(CmdQElmt));
+			cmdqelmt->buffer = NULL;
+			cmdqelmt->CmdFromNdis = FALSE;
+			cmdqelmt->InUse = FALSE;
+		}
+		RTUSBInitializeCmdQ(&pAdapter->CmdQ);
+
+		init_MUTEX(&(pAdapter->usbdev_semaphore));
+		init_MUTEX_LOCKED(&(pAdapter->mlme_semaphore));
+		init_MUTEX_LOCKED(&(pAdapter->RTUSBCmd_semaphore));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+		init_completion (&pAdapter->notify);
+#endif
+		NdisAllocateSpinLock(&pAdapter->CmdQLock);
+		NdisAllocateSpinLock(&pAdapter->SendTxWaitQueueLock);
+		NdisAllocateSpinLock(&pAdapter->BulkOutLock);
+		NdisAllocateSpinLock(&pAdapter->MLMEWaitQueueLock);
+		NdisAllocateSpinLock(&pAdapter->MLMEQLock);
+	}while(0);
+
+	return Status;
+}
+////////////////////////////////////////////////////////////////////////////
+//
+//	FUNCTION
+//		ReleaseAdapter
+//
+//	DESCRIPTION
+//		Calls USB_InterfaceStop and frees memory allocated for the URBs
+//		calls NdisMDeregisterDevice and frees the memory
+//		allocated in VNetInitialize for the Adapter Object
+//		
+//	INPUT
+//		Adapter 	Pointer to RT2570ADAPTER structure
+//
+//	OUTPUT
+//		-
+//		
+////////////////////////////////////////////////////////////////////////////
+VOID ReleaseAdapter(PRT2570ADAPTER pAdapter, BOOLEAN IsF)
+{
+	UINT	i, IsFree;
+	PTX_CONTEXT	pNullContext = &pAdapter->NullContext;
+	PTX_CONTEXT	pPsPollContext = &pAdapter->PsPollContext;
+	
+	IsFree = 1;
+	DBGPRINT(RT_DEBUG_TRACE, "==> ReleaseAdapter\n");
+	// Free all resources for the RECEIVE buffer queue.
+	for (i = 0; i < RX_RING_SIZE; i++)
+	{
+		PRX_CONTEXT  pRxContext = &(pAdapter->RxContext[i]);
+
+		if (pRxContext->pUrb != NULL)
+		{
+
+			usb_kill_urb(pRxContext->pUrb);
+			if (IsFree)
+			usb_free_urb(pRxContext->pUrb);
+			pRxContext->pUrb = NULL;
+		}
+		if (pRxContext->TransferBuffer != NULL)
+		{
+			FreeMemory(pRxContext->TransferBuffer); 
+			pRxContext->TransferBuffer = NULL;
+		}
+
+	}
+#if 0
+
+	if (NULL != pWpaPskContext->pUrb)
+	{
+		usb_free_urb(pWpaPskContext->pUrb);
+		pWpaPskContext->pUrb = NULL;
+	}
+	if (NULL != pWpaPskContext->TransferBuffer)
+	{
+		FreeMemory(pWpaPskContext->TransferBuffer);
+		pWpaPskContext->TransferBuffer = NULL;
+	}
+#endif
+
+	if (NULL != pPsPollContext->pUrb)
+	{
+		usb_kill_urb(pPsPollContext->pUrb);
+		if (IsFree)
+		usb_free_urb(pPsPollContext->pUrb);
+		pPsPollContext->pUrb = NULL;
+	}
+	if (NULL != pPsPollContext->TransferBuffer)
+	{
+		FreeMemory(pPsPollContext->TransferBuffer);
+		pPsPollContext->TransferBuffer = NULL;
+	}
+
+	if (NULL != pNullContext->pUrb)
+	{
+		usb_kill_urb(pNullContext->pUrb);
+		if (IsFree)
+		usb_free_urb(pNullContext->pUrb);
+		pNullContext->pUrb = NULL;
+	}
+	if (NULL != pNullContext->TransferBuffer)
+	{
+		FreeMemory(pNullContext->TransferBuffer);
+		pNullContext->TransferBuffer = NULL;
+	}
+	// Free beacon frame resource
+	for (i = 0; i < BEACON_RING_SIZE; i++)
+	{
+		PTX_CONTEXT	pBeaconContext = &(pAdapter->BeaconContext[i]);
+		if ( NULL != pBeaconContext->pUrb )
+		{
+			usb_kill_urb(pBeaconContext->pUrb);
+			if (IsFree)
+			usb_free_urb(pBeaconContext->pUrb);
+			pBeaconContext->pUrb = NULL;
+		}
+		
+		if ( NULL != pBeaconContext->TransferBuffer )
+		{
+			FreeMemory( pBeaconContext->TransferBuffer);
+			pBeaconContext->TransferBuffer = NULL;
+		}
+	}
+	for ( i= 0; i < PRIO_RING_SIZE; i++ )
+	{
+		PTX_CONTEXT pMLMEContext = &(pAdapter->MLMEContext[i]);
+		
+
+		if ( NULL != pMLMEContext->pUrb )
+		{
+			usb_kill_urb(pMLMEContext->pUrb);
+			if (IsFree)
+			usb_free_urb(pMLMEContext->pUrb);
+			pMLMEContext->pUrb = NULL;
+		}
+		
+		if ( NULL != pMLMEContext->TransferBuffer )
+		{
+			FreeMemory( pMLMEContext->TransferBuffer);
+			pMLMEContext->TransferBuffer = NULL;
+		}
+	} // for
+	for ( i= 0; i < TX_RING_SIZE; i++ )
+	{
+		PTX_CONTEXT pTxContext = &(pAdapter->TxContext[i]);
+
+
+		if ( NULL != pTxContext->pUrb )
+		{
+			usb_kill_urb(pTxContext->pUrb);
+			if (IsFree)
+			usb_free_urb(pTxContext->pUrb);
+			pTxContext->pUrb = NULL;
+		}
+		
+		if ( NULL != pTxContext->TransferBuffer )
+		{
+			FreeMemory( pTxContext->TransferBuffer);
+			pTxContext->TransferBuffer = NULL;
+		}
+	} // for
+
+	DBGPRINT(RT_DEBUG_TRACE, "<== ReleaseAdapter\n");
+
+}
+
+VOID PortCfgInit(PRT2570ADAPTER pAdapter)
+{
+	UINT i;
+	
+	pAdapter->PortCfg.UseBGProtection = 2; // always not use
+	pAdapter->PortCfg.CapabilityInfo = 0x0000;
+	pAdapter->BulkOutMaxPacketSize = 64;
+	//pAdapter->PortCfg.AuthRspTimeout = AUTH_KEY_TIMEOUT;	 // in msec
+	pAdapter->PortCfg.Psm = PWR_ACTIVE;
+	pAdapter->PortCfg.BeaconPeriod = 100;	  // in mSec
+	//	pAdapter->PortCfg.AssocRspTimeout = ASSOC_TIMEOUT;	// in mSec
+
+#if 1
+	pAdapter->BBPR17InitValue = 0x32;
+#endif
+	pAdapter->PortCfg.CfpMaxDuration = 0;	  // never mind, decided by AP later
+	pAdapter->PortCfg.CfpDurRemain = 0; 	  // never mind, decided by AP later
+	pAdapter->PortCfg.CfpCount = 0; 		  // never mind, decided by AP later
+	pAdapter->PortCfg.CfpPeriod = 0;		  // never mind, decided by AP later
+	pAdapter->PortCfg.AuthMode = Ndis802_11AuthModeOpen;
+	pAdapter->PortCfg.CipherAlg = CIPHER_NONE;
+	pAdapter->PortCfg.MlmeRate = RATE_2;
+	pAdapter->PortCfg.RtsRate = RATE_2;
+	for(i = 0; i < SHARE_KEY_NO; i++)
+	{
+		pAdapter->PortCfg.SharedKey[i].KeyLen = 0;
+	}
+
+	for(i = 0; i < PAIRWISE_KEY_NO; i++) 
+	{
+		pAdapter->PortCfg.PairwiseKey[i].KeyLen = 0;
+	}
+
+	for(i = 0; i < GROUP_KEY_NO; i++) 
+	{
+		pAdapter->PortCfg.GroupKey[i].KeyLen = 0;
+	}
+	pAdapter->PortCfg.WepStatus = Ndis802_11EncryptionDisabled;
+	pAdapter->PortCfg.OrigWepStatus = Ndis802_11EncryptionDisabled;
+	pAdapter->PortCfg.PairCipher = Ndis802_11EncryptionDisabled;
+	pAdapter->PortCfg.GroupCipher = Ndis802_11EncryptionDisabled;
+	pAdapter->PortCfg.bMixCipher = FALSE;
+	pAdapter->PortCfg.DefaultKeyId = 0;
+	
+	pAdapter->PortCfg.PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
+
+	// 802.1x port control
+	pAdapter->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+	pAdapter->PortCfg.LastMicErrorTime = 0;
+	pAdapter->PortCfg.MicErrCnt 	   = 0;
+	pAdapter->PortCfg.bBlockAssoc	   = FALSE;
+
+	pAdapter->PortCfg.RtsThreshold = 2347;
+	pAdapter->PortCfg.FragmentThreshold = 2346;
+	pAdapter->PortCfg.bFragmentZeroDisable = FALSE;
+
+	pAdapter->PortCfg.CurrentTxAntenna = 0xff;	// diversity
+	pAdapter->PortCfg.CurrentRxAntenna = 0xff;	// diversity
+	pAdapter->PortCfg.NumberOfAntenna = 2;
+
+//	pAdapter->PortCfg.TxPowerLevel[0] = 100;
+//	pAdapter->PortCfg.NumOfTxPowerLevel = 1;
+	pAdapter->PortCfg.TxPower = 100; //mW
+	pAdapter->PortCfg.TxPowerPercentage = 0xffffffff; // AUTO
+
+	pAdapter->PortCfg.AntennaSupportTx = TRUE;
+	pAdapter->PortCfg.AntennaSupportRx = TRUE;
+	pAdapter->PortCfg.AntennaSupportDiversityRx = TRUE;
+
+	pAdapter->PortCfg.RecvDtim = TRUE;
+	memset(&pAdapter->PortCfg.Bssid, 0, MAC_ADDR_LEN);
+	memset(&pAdapter->PortCfg.Broadcast, 0xff, MAC_ADDR_LEN);
+	pAdapter->PortCfg.Pss = PWR_ACTIVE;
+	pAdapter->PortCfg.RssiTrigger = 0;
+	pAdapter->PortCfg.LastRssi = 0;
+	pAdapter->PortCfg.AvgRssi  = 0;
+	pAdapter->PortCfg.RssiTriggerMode = RSSI_TRIGGERED_UPON_BELOW_THRESHOLD;
+	pAdapter->PortCfg.AtimWin = 0;
+	pAdapter->PortCfg.Channel = 1;
+
+	pAdapter->PortCfg.Aid = 1;
+
+	pAdapter->PortCfg.DefaultListenCount = 3;//default listen count;
+	pAdapter->PortCfg.BssType = BSS_INFRA;	// BSS_INFRA or BSS_INDEP
+
+	pAdapter->PortCfg.SsidLen = 0;
+	memset(pAdapter->PortCfg.Ssid, 0, MAX_LEN_OF_SSID);  // NOT NULL-terminated
+
+	// global variables mXXXX used in MAC protocol state machines
+	pAdapter->PortCfg.Mibss = FALSE;
+	pAdapter->PortCfg.Massoc = FALSE;
+	pAdapter->PortCfg.Mauth = FALSE;
+	pAdapter->PortCfg.MallowRFMONTx = FALSE;
+	pAdapter->PortCfg.ForcePrismHeader = 0;
+
+	// PHY specification
+	pAdapter->PortCfg.PhyMode = PHY_11BG_MIXED;
+	//	  RTMPSetPhyMode(pAdapter, PHY_11BG_MIXED);   // default in 11BG mixed mode
+	pAdapter->PortCfg.Dsifs = 10;	   // in units of usec 
+	pAdapter->PortCfg.TxPreambleInUsed = Rt802_11PreambleLong; // use Long preamble on TX by defaut
+
+	// user desired power mode
+	pAdapter->PortCfg.WindowsPowerMode = Ndis802_11PowerModeCAM; // Ndis802_11PowerModeFast_PSP;
+	pAdapter->PortCfg.WindowsTxPreamble = Rt802_11PreambleAuto; // use Long preamble on TX by defaut
+	//pAdapter->PortCfg.PacketFilter = NDIS_PACKET_TYPE_ALL_MULTICAST | NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_BROADCAST;
+	pAdapter->bAcceptDirect = TRUE;
+	pAdapter->bAcceptMulticast = FALSE;
+	pAdapter->bAcceptBroadcast = TRUE;
+	pAdapter->bAcceptAllMulticast = TRUE;
+	
+#ifdef NDIS51_MINIPORT
+	pAdapter->PortCfg.WindowsPowerProfile = NdisPowerProfileAcOnLine; // Ndis802_11PowerModeFast_PSP;
+#endif
+	// parameters to be used when this STA starts a new ADHOC network
+	pAdapter->PortCfg.IbssConfig.BeaconPeriod = 100;
+	pAdapter->PortCfg.IbssConfig.AtimWin = 0;
+	pAdapter->PortCfg.IbssConfig.Channel = 1;
+	pAdapter->PortCfg.RfType = RFIC_2525;
+	pAdapter->PortCfg.LedMode = LED_MODE_DEFAULT;
+	//steven	NdisMInitializeTimer(&pAdapter->PortCfg.RfTuningTimer, pAdapter->AdapterHandle, AsicRfTuningExec, pAdapter);
+
+	// Patch for Ndtest
+	pAdapter->PortCfg.IgnoredScanNumber = 0;
+	pAdapter->bTxBusy = FALSE;
+		
+	pAdapter->PortCfg.bHwRadio	= TRUE;
+	pAdapter->PortCfg.bSwRadio	= TRUE;
+	pAdapter->PortCfg.bRadio	= TRUE;
+	DBGPRINT(RT_DEBUG_TEMP, "INIT bRadio=%d\n", pAdapter->PortCfg.bRadio);
+	pAdapter->PortCfg.bHardwareRadio = FALSE;		// Default is OFF
+	pAdapter->PortCfg.bAutoTxAgc = FALSE;			// Default is OFF
+	pAdapter->PortCfg.bShowHiddenSSID = FALSE;		// Default no show
+	pAdapter->PortCfg.AdhocMode = 0; // b/g in adhoc
+	
+	// Nitro mode control
+	pAdapter->PortCfg.EnableTxBurst = 0;		
+	pAdapter->PortCfg.AutoReconnect = TRUE;
+
+	// Save the init time as last scan time, the system should do scan after 2 seconds.
+	// This patch is for driver wake up from standby mode, system will do scan right away.
+	pAdapter->PortCfg.LastScanTime = 0;
+	pAdapter->ScanAllowed = TRUE;
+
+
+	// Default for extra information is not valid
+	pAdapter->ExtraInfo = EXTRA_INFO_CLEAR;
+	// Default Config change flag
+	pAdapter->bConfigChanged = FALSE;
+
+	// dynamic BBP R17:sensibity tuning to overcome background noise
+	pAdapter->PortCfg.BbpTuningEnable  = TRUE;	// overwritten by E2PROM setting
+	pAdapter->PortCfg.VgcLowerBound    = 0x38;	// overwritten by E2PROM setting
+	pAdapter->PortCfg.BbpTuning.FalseCcaLowerThreshold = 100;
+	pAdapter->PortCfg.BbpTuning.FalseCcaUpperThreshold = 4;   // unit 128, 4*128 = 512
+	pAdapter->PortCfg.BbpTuning.VgcDelta			   = 1;
+	pAdapter->PortCfg.BbpTuning.VgcUpperBound		   = BBP_R17_DYNAMIC_UP_BOUND;
+	pAdapter->PortCfg.UseShortSlotTime = 1;//steven:for 2/20 demo purpose
+
+	for (i = 0; i < 12; i++)
+	{
+		pAdapter->TxRateSwitchingStruc[i].LastStableTime = 0;
+		pAdapter->TxRateSwitchingStruc[i].DownRate1Ratio = 55;
+		pAdapter->TxRateSwitchingStruc[i].DownRate2Ratio = 45;
+		pAdapter->TxRateSwitchingStruc[i].UpRateRatio = 85;
+		pAdapter->TxRateSwitchingStruc[i].StableTimeRequired = 3;
+		pAdapter->TxRateSwitchingStruc[i].PenaltyPeriod = 6;
+		pAdapter->TxRateSwitchingStruc[i].DownWaitingTime = 4;
+		switch (i)
+		{
+			case 11:
+			pAdapter->TxRateSwitchingStruc[i].DownRate1Ratio = 70;
+			break;
+		}
+	}
+	pAdapter->BBPTuningParameters.BBPTuningThreshold = 45;
+	pAdapter->BBPTuningParameters.R24LowerValue = 0x80;
+	pAdapter->BBPTuningParameters.R25LowerValue = 0x50;
+	pAdapter->BBPTuningParameters.R61LowerValue = 0x60;
+	pAdapter->BBPTuningParameters.R24HigherValue = 0x70;
+	pAdapter->BBPTuningParameters.R25HigherValue = 0x40;
+	pAdapter->BBPTuningParameters.R61HigherValue = 0x6d;
+	pAdapter->BBPTuningParameters.BBPR17LowSensitivity = BBP_R17_LOW_SENSIBILITY;
+	pAdapter->BBPTuningParameters.BBPR17MidSensitivity = BBP_R17_MID_SENSIBILITY;
+	pAdapter->BBPTuningParameters.RSSIToDbmOffset = RSSI_TO_DBM_OFFSET;
+	pAdapter->BBPTuningParameters.LargeCurrentRSSI = FALSE;
+
+}
+
+UCHAR BtoH(char ch)
+{
+	if (ch >= '0' && ch <= '9') return (ch - '0');		  // Handle numerals
+	if (ch >= 'A' && ch <= 'F') return (ch - 'A' + 0xA);  // Handle capitol hex digits
+	if (ch >= 'a' && ch <= 'f') return (ch - 'a' + 0xA);  // Handle small hex digits
+	return(255);
+}
+
+//
+//	FUNCTION: AtoH(char *, UCHAR *, int)
+//
+//	PURPOSE:  Converts ascii string to network order hex
+//
+//	PARAMETERS:
+//	  src	 - pointer to input ascii string
+//	  dest	 - pointer to output hex
+//	  destlen - size of dest
+//
+//	COMMENTS:
+//
+//	  2 ascii bytes make a hex byte so must put 1st ascii byte of pair
+//	  into upper nibble and 2nd ascii byte of pair into lower nibble.
+//
+
+void AtoH(char * src, UCHAR * dest, int destlen)
+{
+	char * srcptr;
+	PUCHAR destTemp;
+
+	srcptr = src;	
+	destTemp = (PUCHAR) dest; 
+
+	while(destlen--)
+	{
+		*destTemp = BtoH(*srcptr++) << 4;	 // Put 1st ascii byte in upper nibble.
+		*destTemp += BtoH(*srcptr++);	   // Add 2nd ascii byte to above.
+		destTemp++;
+	}
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+		Init timer objects
+
+	Arguments:
+		pAdapter			Pointer to our adapter
+		pTimer				Timer structure
+		pTimerFunc			Function to execute when timer expired
+		Repeat				Ture for period timer
+
+	Return Value:
+		None
+
+	Note:
+		
+	========================================================================
+*/
+VOID	RTMPInitTimer(
+	IN	PRT2570ADAPTER			pAdapter,
+	IN	PRALINK_TIMER_STRUCT	pTimer,
+	IN	PVOID					pTimerFunc)
+{
+	init_timer(&pTimer->Timer);
+	pTimer->Timer.data = (unsigned long)pAdapter;
+	pTimer->Timer.function = pTimerFunc;
+
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+		Init timer objects
+
+	Arguments:
+		pTimer				Timer structure
+		Value				Timer value in milliseconds
+
+	Return Value:
+		None
+
+	Note:
+		
+	========================================================================
+*/
+VOID	RTMPSetTimer(
+	IN	PRT2570ADAPTER			pAdapter,	
+	IN	PRALINK_TIMER_STRUCT	pTimer,
+	IN	ULONG					Value)
+{
+	//
+	// We should not set a timer when driver is on Halt state.
+	// 
+	if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+		return;
+	pTimer->Timer.expires = jiffies + (Value * HZ)/1000;
+	add_timer(&pTimer->Timer);
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+		Cancel timer objects
+
+	Arguments:
+		Adapter						Pointer to our adapter
+
+	Return Value:
+		None
+
+	IRQL = PASSIVE_LEVEL
+	IRQL = DISPATCH_LEVEL
+	
+	Note:
+		Reset NIC to initial state AS IS system boot up time.
+		
+	========================================================================
+*/
+VOID	RTMPCancelTimer(
+	IN	PRALINK_TIMER_STRUCT	pTimer)
+{
+	del_timer_sync(&pTimer->Timer);
+}
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rtusb_io.c linux-2.4.35.3-mct/drivers/usb/rt2570/rtusb_io.c
--- linux-2.4.35.3/drivers/usb/rt2570/rtusb_io.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rtusb_io.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,921 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	rtusb_io.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#include	"rt_config.h"
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NTSTATUS	RTUSBSingleRead(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	OUT	PUSHORT			pValue)
+{
+	NTSTATUS	Status;
+
+	Status = RTUSB_VendorRequest(
+		pAdapter,
+		0,
+		DEVICE_VENDOR_REQUEST_IN,
+		0x3,
+		0,
+		Offset,
+		pValue,
+		2);
+	
+	return Status;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NTSTATUS	RTUSBSingleWrite(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	IN	USHORT			Value)
+{
+	NTSTATUS	Status;
+	
+	Status = RTUSB_VendorRequest(
+		pAdapter,
+		0,
+		DEVICE_VENDOR_REQUEST_OUT,
+		0x2,
+		Value,
+		Offset,
+		NULL,
+		0);
+	
+	return Status;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NTSTATUS	RTUSBMultiRead(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	OUT	PUCHAR			pData,
+	IN	USHORT			length)
+{
+	NTSTATUS	Status;
+	
+	Status = RTUSB_VendorRequest(
+		pAdapter,
+		0,
+		DEVICE_VENDOR_REQUEST_IN,
+		0x7,
+		0,
+		Offset,
+		pData,
+		length);
+	
+	return Status;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NTSTATUS	RTUSBMultiWrite(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	IN	PUCHAR			pData,
+	IN	USHORT			length)
+{
+	NTSTATUS	Status;
+	
+	Status = RTUSB_VendorRequest(
+		pAdapter,
+		0,
+		DEVICE_VENDOR_REQUEST_OUT,
+		0x6,
+		0,
+		Offset,
+		pData,
+		length);
+	
+	return Status;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NTSTATUS	RTUSBReadMACRegister(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	OUT	PUSHORT			pValue)
+{
+	NTSTATUS	Status;
+	
+	Status = RTUSB_VendorRequest(
+		pAdapter,
+		0,
+		DEVICE_VENDOR_REQUEST_IN,
+		0x3,
+		0,
+		Offset + 0x400,
+		pValue,
+		2);
+	
+	return Status;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NTSTATUS	RTUSBWriteMACRegister(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	IN	USHORT			Value)
+{
+	NTSTATUS	Status;
+	if (Offset == TXRX_CSR2)
+     		DBGPRINT(RT_DEBUG_ERROR, " !!!!!set Rx control = %x\n", Value);
+     
+	Status = RTUSB_VendorRequest(
+		pAdapter,
+		0,
+		DEVICE_VENDOR_REQUEST_OUT,
+		0x2,
+		Value,
+		Offset + 0x400,
+		NULL,
+		0);
+	
+	return Status;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NTSTATUS	RTUSBMultiReadMAC(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	OUT	PUCHAR			pData,
+	IN	USHORT			length)
+{
+	NTSTATUS	Status;
+	
+	Status = RTUSB_VendorRequest(
+		pAdapter,
+		0,
+		DEVICE_VENDOR_REQUEST_IN,
+		0x7,
+		0,
+		Offset + 0x400,
+		pData,
+		length);
+	
+	return Status;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NTSTATUS	RTUSBMultiWriteMAC(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	IN	PUCHAR			pData,
+	IN	USHORT			length)
+{
+	NTSTATUS	Status;
+	
+	Status = RTUSB_VendorRequest(
+		pAdapter,
+		0,
+		DEVICE_VENDOR_REQUEST_OUT,
+		0x6,
+		0,
+		Offset + 0x400,
+		pData,
+		length);
+	
+	return Status;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NTSTATUS	RTUSBReadBBPRegister(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	UCHAR			Id,
+	IN	PUCHAR			pValue)
+{
+	PHY_CSR7_STRUC	PhyCsr7;
+	USHORT			temp;
+	UINT			i = 0;
+
+	if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS))
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"device connected\n");
+		return -1;
+	}
+
+	PhyCsr7.value				= 0;
+	PhyCsr7.field.WriteControl	= 1;
+	PhyCsr7.field.RegID 		= Id;
+	RTUSBWriteMACRegister(pAdapter, PHY_CSR7, PhyCsr7.value);
+	
+	do
+	{
+		RTUSBReadMACRegister(pAdapter, PHY_CSR8, &temp);
+		if (!(temp & BUSY))
+			break;
+		i++;
+	}
+	while ((i < RETRY_LIMIT) && (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)));
+
+	if ((i == RETRY_LIMIT) || (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)))
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
+		return STATUS_UNSUCCESSFUL;
+	}
+
+	RTUSBReadMACRegister(pAdapter, PHY_CSR7, (PUSHORT)&PhyCsr7);
+	*pValue = (UCHAR)PhyCsr7.field.Data;
+	
+	return STATUS_SUCCESS;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NTSTATUS	RTUSBWriteBBPRegister(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	UCHAR			Id,
+	IN	UCHAR			Value)
+{
+	PHY_CSR7_STRUC	PhyCsr7;
+	USHORT			temp;
+	UINT			i = 0;
+
+	if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS))
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"device connected\n");
+		return -1;
+	}
+	do
+	{
+		RTUSBReadMACRegister(pAdapter, PHY_CSR8, &temp);
+		if (!(temp & BUSY))
+			break;
+		i++;
+	}
+	while ((i < RETRY_LIMIT) && (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)));
+
+	if ((i == RETRY_LIMIT) || (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)))
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
+		return STATUS_UNSUCCESSFUL;
+	}
+
+	PhyCsr7.value				= 0;
+	PhyCsr7.field.WriteControl	= 0;
+	PhyCsr7.field.RegID 		= Id;
+	PhyCsr7.field.Data			= Value;
+	RTUSBWriteMACRegister(pAdapter, PHY_CSR7, PhyCsr7.value);
+	pAdapter->PortCfg.BbpWriteLatch[Id] = Value;
+	
+	return STATUS_SUCCESS;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NTSTATUS	RTUSBWriteRFRegister(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	ULONG			Value)
+{
+	PHY_CSR10_STRUC	PhyCsr10;
+	UINT			i = 0;
+
+	do
+	{
+		RTUSBReadMACRegister(pAdapter, PHY_CSR10, (PUSHORT)&PhyCsr10);
+		if (!(PhyCsr10.field.Busy))
+			break;
+		i++;
+	}
+	while ((i < RETRY_LIMIT) && (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)));
+
+	if ((i == RETRY_LIMIT) || (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)))
+	{
+		DBGPRINT_RAW(RT_DEBUG_ERROR, "Retry count exhausted or device removed!!!\n");
+		return STATUS_UNSUCCESSFUL;
+	}
+
+	RTUSBWriteMACRegister(pAdapter, PHY_CSR9, (USHORT)(Value & 0x0000ffff));
+	
+	PhyCsr10.value = (USHORT)(Value >> 16);
+	RTUSBWriteMACRegister(pAdapter, PHY_CSR10, PhyCsr10.value);
+	
+	return STATUS_SUCCESS;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NTSTATUS	RTUSBReadEEPROM(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	OUT	PUCHAR			pData,
+	IN	USHORT			length)
+{
+	NTSTATUS	Status;
+	
+	Status = RTUSB_VendorRequest(
+		pAdapter,
+		0,
+		DEVICE_VENDOR_REQUEST_IN,
+		0x9,
+		0,
+		Offset,
+		pData,
+		length);
+	
+	return Status;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NTSTATUS	RTUSBWriteEEPROM(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	USHORT			Offset,
+	IN	PUCHAR			pData,
+	IN	USHORT			length)
+{
+	NTSTATUS	Status;
+	
+	Status = RTUSB_VendorRequest(
+		pAdapter,
+		0,
+		DEVICE_VENDOR_REQUEST_OUT,
+		0x8,
+		0,
+		Offset,
+		pData,
+		length);
+	
+	return Status;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBDequeueCmd(
+	IN	PCmdQ		cmdq,
+	OUT	PCmdQElmt	*pcmdqelmt)
+{
+	*pcmdqelmt = cmdq->head;
+	
+	if (*pcmdqelmt != NULL)
+	{
+		cmdq->head = cmdq->head->next;
+		cmdq->size--;
+		if (cmdq->size == 0)
+			cmdq->tail = NULL;
+	}
+}
+/*
+	  usb_control_msg - Builds a control urb, sends it off and waits for completion
+	  @dev: pointer to the usb device to send the message to
+	  @pipe: endpoint "pipe" to send the message to
+	  @request: USB message request value
+	  @requesttype: USB message request type value
+	  @value: USB message value
+	  @index: USB message index value
+	  @data: pointer to the data to send
+	  @size: length in bytes of the data to send
+	  @timeout: time in jiffies to wait for the message to complete before
+			  timing out (if 0 the wait is forever)
+	  Context: !in_interrupt ()
+
+	  This function sends a simple control message to a specified endpoint
+	  and waits for the message to complete, or timeout.
+	  If successful, it returns the number of bytes transferred, otherwise a negative error number.
+
+	 Don't use this function from within an interrupt context, like a
+	  bottom half handler.	If you need an asynchronous message, or need to send
+	  a message from within interrupt context, use usb_submit_urb()
+	  If a thread in your driver uses this call, make sure your disconnect()
+	  method can wait for it to complete.  Since you don't have a handle on
+	  the URB used, you can't cancel the request.
+  
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+INT	RTUSB_VendorRequest(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	ULONG			TransferFlags,
+	IN	UCHAR			RequestType,
+	IN	UCHAR			Request,
+	IN	USHORT			Value,
+	IN	USHORT			Index,
+	IN	PVOID			TransferBuffer,
+	IN	ULONG			TransferBufferLength)
+{
+	int ret;
+
+	if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS))
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"device connected\n");
+		return -1;
+	}
+	else if (in_interrupt())	
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"in_interrupt, return RTUSB_VendorRequest\n");
+
+		return -1;
+	}
+	else
+	{
+	
+		if( RequestType == DEVICE_VENDOR_REQUEST_OUT)
+			ret=usb_control_msg(pAdapter->usb, usb_sndctrlpipe( pAdapter->usb, 0 ), Request, RequestType, Value,Index, TransferBuffer, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES);
+		else if(RequestType == DEVICE_VENDOR_REQUEST_IN)
+			ret=usb_control_msg(pAdapter->usb, usb_rcvctrlpipe( pAdapter->usb, 0 ), Request, RequestType, Value,Index, (PUSHORT)TransferBuffer, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES);
+		else
+		{
+			DBGPRINT(RT_DEBUG_ERROR,"vendor request direction is failed\n");
+			ret = -1;
+		}
+
+		if((RequestType == DEVICE_VENDOR_REQUEST_OUT) && (ret != 0))
+			DBGPRINT(RT_DEBUG_TRACE,"USBVendorRequest  ret=%d,	\n",ret);
+	
+//	if((RequestType == DEVICE_VENDOR_REQUEST_IN) && (ret != 2))
+//		DBGPRINT(RT_DEBUG_TRACE,"USBVendorRequest	read ret=%d,  TransferBuffer = 0x%x\n",ret, *(PUSHORT)TransferBuffer);
+//	if((TransferBuffer != NULL) )
+//		DBGPRINT(RT_DEBUG_TRACE,"USBVendorRequest	ret=%d, read from = 0x%x TransferBuffer = 0x%x\n",ret,Value, *(PUSHORT)TransferBuffer);
+
+		if (ret <0) {
+			int temp_i=0;
+			DBGPRINT(RT_DEBUG_ERROR,"USBVendorRequest failed ret=%d, \n",ret);
+			ret = 0;
+			do
+			{
+				if( RequestType == DEVICE_VENDOR_REQUEST_OUT)
+					ret=usb_control_msg(pAdapter->usb, usb_sndctrlpipe( pAdapter->usb, 0 ), Request, RequestType, Value,Index, TransferBuffer, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES);
+				else if(RequestType == DEVICE_VENDOR_REQUEST_IN)
+					ret=usb_control_msg(pAdapter->usb, usb_rcvctrlpipe( pAdapter->usb, 0 ), Request, RequestType, Value,Index, (PUSHORT)TransferBuffer, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES);
+				temp_i++;
+			} while( (ret < 0) && (temp_i <= 1) );
+
+			if( ret >= 0)
+				return ret;
+			
+		}
+	}
+	return ret;
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBInitializeCmdQ(
+	IN	PCmdQ	cmdq)
+{
+	cmdq->head = NULL;
+	cmdq->tail = NULL;
+	cmdq->size = 0;
+}
+
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NDIS_STATUS	RTUSBEnqueueCmdFromNdis(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	NDIS_OID		Oid,
+	IN	BOOLEAN			SetInformation,
+	IN	PVOID			pInformationBuffer,
+	IN	ULONG			InformationBufferLength)
+{
+	PCmdQElmt	cmdqelmt = NULL;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if (pAdapter->RTUSBCmdThr_pid < 0)
+		return NDIS_STATUS_RESOURCES;
+#else
+	if (!pAdapter->RTUSBCmdThr_active) 
+		return NDIS_STATUS_RESOURCES;
+#endif
+	cmdqelmt = (PCmdQElmt) kmalloc(sizeof(CmdQElmt), GFP_KERNEL);
+	if (!cmdqelmt) 
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Not enough memory\n");
+		kfree((PCmdQElmt)cmdqelmt);
+		return NDIS_STATUS_RESOURCES;
+	}
+
+	if ((Oid == RT_OID_SINGLE_READ_MAC) ||
+		(Oid == RT_OID_MULTI_READ_MAC) ||
+		(Oid == RT_OID_VENDOR_READ_BBP) ||
+		(Oid == RT_OID_USB_VENDOR_EEPROM_READ))
+	{
+		cmdqelmt->buffer = pInformationBuffer;
+	}
+	else
+	{
+		cmdqelmt->buffer = NULL;
+		if (pInformationBuffer != NULL)
+		{
+			cmdqelmt->buffer =	kmalloc(InformationBufferLength, GFP_KERNEL);
+			if ((!cmdqelmt->buffer) )
+			{
+				kfree((PVOID)cmdqelmt->buffer);
+				kfree((PCmdQElmt)cmdqelmt);
+				return (NDIS_STATUS_RESOURCES);
+			}
+			else
+			{
+				memcpy(cmdqelmt->buffer, pInformationBuffer, InformationBufferLength);
+				cmdqelmt->bufferlength = InformationBufferLength;
+			}
+		}
+		else
+			cmdqelmt->bufferlength = 0;
+	}
+	
+	cmdqelmt->command = Oid;
+	cmdqelmt->CmdFromNdis = TRUE;
+	if (SetInformation == TRUE)
+		cmdqelmt->SetOperation = TRUE;
+	else
+		cmdqelmt->SetOperation = FALSE;
+
+	NdisAcquireSpinLock(&pAdapter->CmdQLock);
+	EnqueueCmd((&pAdapter->CmdQ), cmdqelmt);
+	NdisReleaseSpinLock(&pAdapter->CmdQLock);
+	
+	RTUSBCMDUp(pAdapter, &pAdapter->RTUSBCmd_semaphore);
+
+	if ((Oid == OID_802_11_BSSID_LIST_SCAN) ||
+		(Oid == RT_OID_802_11_BSSID) ||
+		(Oid == OID_802_11_SSID) ||
+		(Oid == OID_802_11_DISASSOCIATE))
+	{
+		return(NDIS_STATUS_SUCCESS);
+	}
+	else
+	{
+		//IncrementIoCount(pAdapter);
+		//return(NDIS_STATUS_PENDING);
+	}
+		return(NDIS_STATUS_SUCCESS);
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+VOID	RTUSBEnqueueInternalCmd(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	NDIS_OID		Oid)
+{
+	PCmdQElmt	cmdqelmt = NULL;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if (pAdapter->RTUSBCmdThr_pid < 0)
+		return NDIS_STATUS_RESOURCES;
+#else
+	if (!pAdapter->RTUSBCmdThr_active) 
+		return NDIS_STATUS_RESOURCES;
+#endif
+	
+	switch (Oid)
+	{
+		case RT_OID_CHECK_GPIO:
+			cmdqelmt = &(pAdapter->CmdQElements[CHECK_GPIO]);
+			break;
+			
+		case RT_OID_PERIODIC_EXECUT:
+			cmdqelmt = &(pAdapter->CmdQElements[PERIODIC_EXECUT]);
+			break;
+			
+		//For Alpha only
+		case RT_OID_ASICLED_EXECUT:
+			cmdqelmt = &(pAdapter->CmdQElements[ASICLED_EXECUT]);
+			break;
+
+		case RT_OID_UPDATE_TX_RATE:
+			cmdqelmt = &(pAdapter->CmdQElements[UPDATE_TX_RATE]);
+			break;
+			
+		case RT_OID_SET_PSM_BIT_SAVE:
+			cmdqelmt = &(pAdapter->CmdQElements[SET_PSM_SAVE]);
+			break;
+			
+		case RT_OID_LINK_DOWN:
+			cmdqelmt = &(pAdapter->CmdQElements[LINK_DOWN]);
+			break;
+			
+		case RT_OID_USB_RESET_BULK_IN:
+			cmdqelmt = &(pAdapter->CmdQElements[RESET_BULKIN]);
+			break;
+			
+		case RT_OID_USB_RESET_BULK_OUT:
+			cmdqelmt = &(pAdapter->CmdQElements[RESET_BULKOUT]);
+			break;
+			
+		case RT_OID_RESET_FROM_ERROR:
+			cmdqelmt = &(pAdapter->CmdQElements[RESET_FROM_ERROR]);
+			break;
+			
+		case RT_OID_RESET_FROM_NDIS:
+			cmdqelmt = &(pAdapter->CmdQElements[RESET_FROM_NDIS]);
+			break;
+
+		default:
+			break;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if ((cmdqelmt != NULL) && (cmdqelmt->InUse == FALSE) && (pAdapter->RTUSBCmdThr_pid > 0))
+#else
+	if ((cmdqelmt != NULL) && (cmdqelmt->InUse == FALSE) && (pAdapter->RTUSBCmdThr_active))
+#endif
+	{
+		cmdqelmt->InUse = TRUE;
+		cmdqelmt->command = Oid;
+
+		NdisAcquireSpinLock(&pAdapter->CmdQLock);
+		EnqueueCmd((&pAdapter->CmdQ), cmdqelmt);
+		NdisReleaseSpinLock(&pAdapter->CmdQLock);
+		RTUSBCMDUp(pAdapter, &pAdapter->RTUSBCmd_semaphore);
+	}
+}
+
+/*
+	========================================================================
+	
+	Routine Description:
+	  Creates an IRP to submite an IOCTL_INTERNAL_USB_RESET_PORT
+	  synchronously. Callers of this function must be running at
+	  PASSIVE LEVEL.
+
+	Arguments:
+
+	Return Value:
+
+	IRQL = 
+	
+	Note:
+	
+	========================================================================
+*/
+NTSTATUS	RTUSB_ResetDevice(
+	IN	PRT2570ADAPTER	pAdapter)
+{
+	NTSTATUS		Status = TRUE;
+
+	DBGPRINT_RAW(RT_DEBUG_TRACE, "--->USB_ResetDevice\n");
+	//RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS);
+	return Status;
+}
+
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/rtusb_main.c linux-2.4.35.3-mct/drivers/usb/rt2570/rtusb_main.c
--- linux-2.4.35.3/drivers/usb/rt2570/rtusb_main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/rtusb_main.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,1927 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	rtusb_main.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ *	RobinC		02-06-2005	usb_kill_urb fixes for kernels =>2.6.7
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+unsigned long flagg;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+ULONG	debug = RT_DEBUG_OFF;
+MODULE_PARM(debug, "i");
+MODULE_PARM_DESC(debug, "Enable level: accepted values: 1 to switch debug on, 0 to switch debug off.");
+#else
+ULONG	debug = RT_DEBUG_OFF;
+module_param(debug, int, 0);
+MODULE_PARM_DESC(debug, "Enable level: accepted values: 1 to switch debug on, 0 to switch debug off.");
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0) */
+
+#define KERNEL_20424	0x20418
+#define KERNEL_20418	0x20412
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+/* Kernel thread and vars, which handles packets that are completed. Only
+ * packets that have a "complete" function are sent here. This way, the
+ * completion is run out of kernel context, and doesn't block the rest of
+ * the stack. */
+static int mlme_kill;
+static int RTUSBCmd_kill;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0) */
+
+extern	const struct iw_handler_def rt2500usb_iw_handler_def;
+
+static struct usb_device_id rtusb_usb_id[] =
+	RTUSB_DEVICES
+;
+/* the number of entries in array above */
+int const rtusb_usb_id_len =
+	sizeof(rtusb_usb_id) / sizeof(struct usb_device_id);
+
+#ifndef PF_NOFREEZE
+#define PF_NOFREEZE  0
+#endif
+/**************************************************************************/
+/**************************************************************************/
+//tested for kernel 2.4 series
+/**************************************************************************/
+/**************************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+
+
+static void usb_rtusb_disconnect(struct usb_device *dev, void *ptr);
+static void *usb_rtusb_probe(struct usb_device *dev, UINT interface,
+				const struct usb_device_id *id_table);
+
+struct usb_driver rtusb_driver = {
+		name:"rt2500usb",
+		probe:usb_rtusb_probe,
+		disconnect:usb_rtusb_disconnect,
+		id_table:rtusb_usb_id,
+	};
+#else
+/**************************************************************************/
+/**************************************************************************/
+//tested for kernel 2.6series
+/**************************************************************************/
+/**************************************************************************/
+static int usb_rtusb_probe (struct usb_interface *intf,
+					  const struct usb_device_id *id);
+
+static void usb_rtusb_disconnect(struct usb_interface *intf);
+
+struct usb_driver rtusb_driver = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16) 
+	.owner =	THIS_MODULE,
+#endif
+	.name="rtusb",
+	.probe=usb_rtusb_probe,
+	.disconnect=usb_rtusb_disconnect,
+	.id_table=rtusb_usb_id,
+	};
+
+
+#endif
+
+
+//static void USB_RxPacketComplete_bh(unsigned long data)
+//{
+//	RTUSBRxPacket(data);
+//}
+
+#if 0
+
+#define MAX_JIFFY_OFFSET ((~0UL >> 1)-1)
+
+static inline unsigned int jiffies_to_msecs(const unsigned long j)
+{
+#if HZ <= 1000 && !(1000 % HZ)
+         return (1000 / HZ) * j;
+#elif HZ > 1000 && !(HZ % 1000)
+         return (j + (HZ / 1000) - 1)/(HZ / 1000);
+#else
+         return (j * 1000) / HZ;
+#endif
+}
+
+static inline unsigned long msecs_to_jiffies(const unsigned int m)
+{
+         if (m > jiffies_to_msecs(MAX_JIFFY_OFFSET))
+                 return MAX_JIFFY_OFFSET;
+#if HZ <= 1000 && !(1000 % HZ)
+         return (m + (1000 / HZ) - 1) / (1000 / HZ);
+#elif HZ > 1000 && !(HZ % 1000)
+         return m * (HZ / 1000);
+ #else
+         return (m * HZ + 999) / 1000;
+ #endif
+}
+/**
+* msleep - sleep safely even with waitqueue interruptions
+* @msecs: Time in milliseconds to sleep for
+*/
+ void msleep(unsigned int msecs)
+{
+	unsigned long timeout = msecs_to_jiffies(msecs) + 1;
+
+	while (timeout)
+	{
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		timeout = schedule_timeout(timeout);
+	}
+}
+
+
+
+#endif
+
+struct net_device_stats *
+rt_getstats(struct net_device *dev)
+{
+	PRT2570ADAPTER pAd = (PRT2570ADAPTER)dev->priv;
+	struct net_device_stats *stats= &pAd->net_device_stats;
+
+	stats->rx_bytes = pAd->RalinkCounters.ReceivedByteCount;
+	stats->rx_packets = pAd->Counters.GoodReceives;
+	stats->rx_errors = pAd->Counters.RxErrors;
+
+	stats->tx_bytes = pAd->RalinkCounters.TransmittedByteCount;
+	stats->tx_packets = pAd->Counters.GoodTransmits;
+	stats->tx_errors = pAd->Counters.TxErrors;
+	return stats;
+}
+
+#if WIRELESS_EXT >= 12
+/*
+    ========================================================================
+
+    Routine Description:
+        get wireless statistics
+
+    Arguments:
+        net_dev                     Pointer to net_device
+
+    Return Value:
+        struct iw_statistics
+
+    Note:
+        This function will be called when query /proc
+
+    ========================================================================
+*/
+struct iw_statistics *RTUSB_get_wireless_stats(
+    IN  struct net_device *net_dev)
+{
+    PRT2570ADAPTER pAd = (PRT2570ADAPTER)net_dev->priv;
+
+    DBGPRINT(RT_DEBUG_TRACE, "--->RTUSB_get_wireless_stats \n");
+
+    // TODO: All elements are zero before be implemented
+
+    pAd->iw_stats.status = 0;                       // Status - device dependent for now
+
+    pAd->iw_stats.qual.qual = pAd->Mlme.ChannelQuality;//pAd->Mlme.RoamCqi;            // link quality (%retries, SNR, %missed beacons or better...)
+    pAd->iw_stats.qual.level = pAd->PortCfg.LastRssi - RSSI_TO_DBM_OFFSET;   // signal level (dBm)
+        
+    pAd->iw_stats.qual.noise = (pAd->PortCfg.LastR17Value > BBP_R17_DYNAMIC_UP_BOUND) ? BBP_R17_DYNAMIC_UP_BOUND : ((ULONG) pAd->PortCfg.LastR17Value);           // noise level (dBm)
+    pAd->iw_stats.qual.updated = 1;     // Flags to know if updated
+
+    pAd->iw_stats.discard.nwid = 0;     // Rx : Wrong nwid/essid
+    pAd->iw_stats.miss.beacon = 0;      // Missed beacons/superframe
+
+    // pAd->iw_stats.discard.code, discard.fragment, discard.retries, discard.misc has counted in other place
+
+    return &pAd->iw_stats;
+}
+#endif
+
+int rt2570_set_mac_address(struct net_device *net_dev, void *addr)
+{
+	RT2570ADAPTER		*pAd = net_dev->priv;
+	struct sockaddr		*mac = (struct sockaddr*) addr;
+
+	if(netif_running(net_dev))
+		return -EBUSY;
+
+	if(!is_valid_ether_addr(&mac->sa_data[0]))
+		return -EINVAL;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,20)) 	
+	BUG_ON(net_dev->addr_len != ETH_ALEN);
+#endif	
+	
+	memcpy(net_dev->dev_addr, mac->sa_data, ETH_ALEN);
+	memcpy(&pAd->CurrentAddress, &mac->sa_data, ETH_ALEN);
+
+	printk(KERN_INFO "***rt2x00***: Info - Mac address changed to: %02x:%02x:%02x:%02x:%02x:%02x.\n", net_dev->dev_addr[0], net_dev->dev_addr[1], net_dev->dev_addr[2], net_dev->dev_addr[3], net_dev->dev_addr[4], net_dev->dev_addr[5]);
+
+	return RTUSBWriteHWMACAddress(pAd);
+}
+
+VOID	RTUSBHalt(
+	IN	PRT2570ADAPTER	pAdapter, BOOLEAN IsFree)
+{
+	MLME_DISASSOC_REQ_STRUCT DisReq;
+	MLME_QUEUE_ELEM          MsgElem;
+	
+	DBGPRINT(RT_DEBUG_TRACE, "====> RTUSBHalt\n");
+	// before set flag fRTMP_ADAPTER_HALT_IN_PROGRESS, 
+	// we should send a disassoc frame to our AP.
+	//
+#if 1
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS))
+	{
+		if (INFRA_ON(pAdapter)) 
+		{
+			COPY_MAC_ADDR(&DisReq.Addr, &pAdapter->PortCfg.Bssid);
+			DisReq.Reason =  REASON_DISASSOC_STA_LEAVING;
+
+			MsgElem.Machine = ASSOC_STATE_MACHINE;
+			MsgElem.MsgType = MT2_MLME_DISASSOC_REQ;
+			MsgElem.MsgLen = sizeof(MLME_DISASSOC_REQ_STRUCT);
+			memcpy(MsgElem.Msg, &DisReq, sizeof(MLME_DISASSOC_REQ_STRUCT));
+
+			MlmeDisassocReqAction(pAdapter, &MsgElem);
+			NdisMSleep(1000);
+		}
+
+		// disable BEACON generation and other BEACON related hardware timers
+		AsicDisableSync(pAdapter);
+	}
+#endif
+	RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS);
+
+	RTUSBCleanUpMLMEWaitQueue(pAdapter);
+	RTUSBCleanUpMLMEBulkOutQueue(pAdapter);
+
+	// Free MLME stuff
+	MlmeHalt(pAdapter);
+	ReleaseAdapter(pAdapter, IsFree);
+
+	RTMP_CLEAR_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS);
+}
+
+VOID CMDHandler(
+    IN PRT2570ADAPTER pAdapter) 
+{
+	PCmdQElmt	cmdqelmt;
+	PUCHAR	pData;
+	NDIS_STATUS	NdisStatus = NDIS_STATUS_SUCCESS;
+
+	while (pAdapter->CmdQ.size > 0)
+	{
+		NdisStatus = NDIS_STATUS_SUCCESS;
+		NdisAcquireSpinLock(&pAdapter->CmdQLock);
+		RTUSBDequeueCmd(&pAdapter->CmdQ, &cmdqelmt);
+		NdisReleaseSpinLock(&pAdapter->CmdQLock);
+		if (cmdqelmt == NULL)
+			break;
+		pData = cmdqelmt->buffer;
+		switch (cmdqelmt->command)
+		{
+			case	RT_OID_CHECK_GPIO:
+			{
+				USHORT data;
+				// Read GPIO pin0 as Hardware controlled radio state
+				RTUSBReadMACRegister(pAdapter, MAC_CSR19, &data);
+				if (data & 0x80)
+				{
+					pAdapter->PortCfg.bHwRadio = TRUE;
+				}
+				else
+				{
+					pAdapter->PortCfg.bHwRadio = FALSE;
+				}
+				if (pAdapter->PortCfg.bRadio != (pAdapter->PortCfg.bHwRadio && pAdapter->PortCfg.bSwRadio))
+				{
+					pAdapter->PortCfg.bRadio = (pAdapter->PortCfg.bHwRadio && pAdapter->PortCfg.bSwRadio);
+					if (pAdapter->PortCfg.bRadio == TRUE)
+					{
+						MlmeRadioOn(pAdapter);
+						// Update extra information
+						pAdapter->ExtraInfo = EXTRA_INFO_CLEAR;
+					}
+					else
+					{
+						MlmeRadioOff(pAdapter);
+						// Update extra information
+						pAdapter->ExtraInfo = HW_RADIO_OFF;
+					}
+				}		
+			}
+			break;
+
+			case	RT_OID_PERIODIC_EXECUT:
+				PeriodicExec(pAdapter);
+			break;
+
+			case	OID_802_11_BSSID_LIST_SCAN:
+			{
+				if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+				{
+					DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! MLME busy (Line#%d)!!!\n", __LINE__);
+					MlmeRestartStateMachine(pAdapter);
+					MlmePostRestartStateMachine(pAdapter);
+				}
+
+				//Now = jiffies;
+				pAdapter->Mlme.CntlAux.CurrReqIsFromNdis = FALSE;
+				// Reset Missed scan number
+				pAdapter->PortCfg.IgnoredScanNumber = 0;
+				//pAdapter->PortCfg.LastScanTime = Now;
+				MlmeEnqueue(pAdapter,
+					MLME_CNTL_STATE_MACHINE,
+					OID_802_11_BSSID_LIST_SCAN,
+					0,
+					NULL);
+				RTUSBUp(pAdapter, &pAdapter->mlme_semaphore);
+			}
+			break;
+			
+			case	RT_OID_802_11_BSSID:
+			{
+
+				if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+				{
+					DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! MLME busy (Line#%d)!!!\n", __LINE__);
+					MlmeRestartStateMachine(pAdapter);
+					MlmePostRestartStateMachine(pAdapter);
+				}
+
+				pAdapter->Mlme.CntlAux.CurrReqIsFromNdis = FALSE;
+
+				// Reset allowed scan retries
+				pAdapter->PortCfg.IgnoredScanNumber = 0;
+
+				MlmeEnqueue(pAdapter,
+					MLME_CNTL_STATE_MACHINE,
+					RT_OID_802_11_BSSID,
+					cmdqelmt->bufferlength,
+					cmdqelmt->buffer);
+				RTUSBUp(pAdapter, &pAdapter->mlme_semaphore);
+			}
+			break;
+			
+			case	OID_802_11_SSID:
+			{
+				if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+				{
+					DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! MLME busy (Line#%d)!!!\n", __LINE__);
+					MlmeRestartStateMachine(pAdapter);
+					MlmePostRestartStateMachine(pAdapter);
+				}
+
+				pAdapter->Mlme.CntlAux.CurrReqIsFromNdis = FALSE;
+
+				// Reset allowed scan retries
+				pAdapter->PortCfg.IgnoredScanNumber = 0;
+
+				MlmeEnqueue(pAdapter,
+						MLME_CNTL_STATE_MACHINE,
+						OID_802_11_SSID,
+						cmdqelmt->bufferlength, 
+						pData);
+				RTUSBUp(pAdapter, &pAdapter->mlme_semaphore);
+			}
+			break;
+
+			case	OID_802_11_DISASSOCIATE:
+			{
+				if (pAdapter->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+				{
+					DBGPRINT_RAW(RT_DEBUG_TRACE, "!!! MLME busy (Line#%d)!!!\n", __LINE__);
+					MlmeRestartStateMachine(pAdapter);
+					MlmePostRestartStateMachine(pAdapter);
+				}
+
+				// Set to immediately send the media disconnect event
+				pAdapter->Mlme.CntlAux.CurrReqIsFromNdis = TRUE;
+
+				MlmeEnqueue(pAdapter,
+					MLME_CNTL_STATE_MACHINE,
+					OID_802_11_DISASSOCIATE,
+					0,
+					NULL);
+				RTUSBUp(pAdapter, &pAdapter->mlme_semaphore);
+			}
+			break;
+
+			case	OID_802_11_RX_ANTENNA_SELECTED:
+			{
+				UCHAR	RxValue;
+				NDIS_802_11_ANTENNA	Antenna = *(NDIS_802_11_ANTENNA *)pData;
+				DBGPRINT_RAW(RT_DEBUG_TRACE, "Set::OID_802_11_RX_ANTENNA_SELECTED (=%d)\n", Antenna);
+				if(Antenna == 0xFFFFFFFF)
+				{// Diversity
+					pAdapter->PortCfg.CurrentRxAntenna = (UCHAR)Antenna;
+					RTUSBReadBBPRegister(pAdapter, BBP_Rx_Configure, &RxValue);
+					RxValue = (RxValue & 0xFC) | 0x01;
+					RTUSBWriteBBPRegister(pAdapter, BBP_Rx_Configure, RxValue);
+				}
+				else if(Antenna < pAdapter->PortCfg.NumberOfAntenna)
+				{
+					pAdapter->PortCfg.CurrentRxAntenna = (UCHAR)Antenna;
+
+					RTUSBReadBBPRegister(pAdapter, BBP_Rx_Configure, &RxValue);
+					if(Antenna == 0)
+					{// Antenna A
+						RxValue = (RxValue & 0xFC) | 0x00;
+					}
+					else if(Antenna == 1)
+					{// Antenna B
+						RxValue = (RxValue & 0xFC) | 0x02;
+					}
+					RTUSBWriteBBPRegister(pAdapter, BBP_Rx_Configure, RxValue);
+				}
+			}
+			break;
+
+			case	OID_802_11_TX_ANTENNA_SELECTED:
+			{
+				NDIS_802_11_ANTENNA	Antenna = *(NDIS_802_11_ANTENNA *)pData;
+				DBGPRINT_RAW(RT_DEBUG_TRACE, "Set::OID_802_11_TX_ANTENNA_SELECTED (=%d)\n", Antenna);
+				if ((Antenna != 0xFFFFFFFF) && (Antenna >= pAdapter->PortCfg.NumberOfAntenna))
+				{
+				}
+				else
+				{
+					UCHAR	TxValue;
+					USHORT	Value5, Value6;
+					pAdapter->PortCfg.CurrentTxAntenna = (UCHAR)Antenna;
+					RTUSBReadBBPRegister(pAdapter, BBP_Tx_Configure, &TxValue);
+					RTUSBReadMACRegister(pAdapter, PHY_CSR5, &Value5);
+					RTUSBReadMACRegister(pAdapter, PHY_CSR6, &Value6);
+					if(Antenna == 0xFFFFFFFF)
+					{// Diversity
+						TxValue = (TxValue & 0xFC) | 0x01;
+						Value5 = (Value5 & 0xFFFC) | 0x0001;
+						Value6 = (Value6 & 0xFFFC) | 0x0001;
+					}
+					else if(Antenna == 0)
+					{// Antenna A
+						TxValue = (TxValue & 0xFC) | 0x00;
+						Value5 = (Value5 & 0xFFFC) | 0x0000;
+						Value6 = (Value6 & 0xFFFC) | 0x0000;
+					}
+					else if(Antenna == 1)
+					{// Antenna B
+						TxValue = (TxValue & 0xFC) | 0x02;
+						Value5 = (Value5 & 0xFFFC) | 0x0002;
+						Value6 = (Value6 & 0xFFFC) | 0x0002;
+					}
+					RTUSBWriteBBPRegister(pAdapter, BBP_Tx_Configure, TxValue);
+					RTUSBWriteMACRegister(pAdapter, PHY_CSR5, Value5);
+					RTUSBWriteMACRegister(pAdapter, PHY_CSR6, Value6);
+				}
+			}
+			break;
+
+			case	RT_OID_SINGLE_WRITE_MAC:
+			{
+				USHORT	Offset, Value;
+				Offset = *((PUSHORT)pData);
+				Value = *((PUSHORT)(pData + 2));
+				DBGPRINT_RAW(RT_DEBUG_INFO, "offset = 0x%04x	value = 0x%04x\n", Offset, Value);
+				RTUSBWriteMACRegister(pAdapter, Offset, Value);
+			}
+			break;
+			
+			case	RT_OID_SINGLE_READ_MAC:
+			{
+				USHORT	Offset = *((PUSHORT)pData);
+				PUSHORT	pValue = (PUSHORT)(pData + 2);
+				DBGPRINT_RAW(RT_DEBUG_INFO, "offset = 0x%04x\n", Offset);
+				RTUSBReadMACRegister(pAdapter, Offset, pValue);
+				DBGPRINT_RAW(RT_DEBUG_INFO, "value = 0x%04x\n", *pValue);
+			}
+			break;
+
+			case	RT_OID_MULTI_READ_MAC:
+			{
+				USHORT	Offset = *((PUSHORT)pData);
+				USHORT	Length = *((PUSHORT)(pData + 2));
+				RTUSBMultiReadMAC(pAdapter, Offset, pData + 4, Length);
+			}
+			break;
+
+			case	RT_OID_MULTI_WRITE_MAC:
+			{
+				USHORT	Offset = *((PUSHORT)pData);
+				USHORT	Length = *((PUSHORT)(pData + 2));
+				RTUSBMultiWriteMAC(pAdapter, Offset, pData + 4, Length);
+			}
+			break;
+
+			case	RT_OID_USB_VENDOR_EEPROM_READ:
+			{
+				USHORT	Offset = *((PUSHORT)pData);
+				USHORT	Length = *((PUSHORT)(pData + 2));
+				RTUSBReadEEPROM(pAdapter, Offset, pData + 4, Length);
+			}
+			break;
+				    
+			case	RT_OID_USB_VENDOR_EEPROM_WRITE:
+			{
+				USHORT	Offset = *((PUSHORT)pData);
+#if 0
+				USHORT	Length = *((PUSHORT)(pData + 2));
+				RTUSBWriteEEPROM(pAdapter, Offset, pData + 4, Length);
+#else//F/W restricts the max EEPROM write size to 62 bytes.
+				USHORT	Residual = *((PUSHORT)(pData + 2));
+				pData += 4;
+				while (Residual > 62)
+				{
+				RTUSBWriteEEPROM(pAdapter, Offset, pData, 62);
+				Offset += 62;
+				Residual -= 62;
+				pData += 62;
+				}
+				RTUSBWriteEEPROM(pAdapter, Offset, pData, Residual);
+#endif
+			}
+			break;
+
+			case	RT_OID_USB_VENDOR_ENTER_TESTMODE:
+				RTUSB_VendorRequest(pAdapter,
+					0,
+					DEVICE_VENDOR_REQUEST_OUT,
+					0x1,
+					0x4,
+					0x1,
+					NULL,
+					0);
+					break;
+
+			case	RT_OID_USB_VENDOR_EXIT_TESTMODE:
+				RTUSB_VendorRequest(pAdapter,
+					0,
+					DEVICE_VENDOR_REQUEST_OUT,
+					0x1,
+					0x4,
+					0x0,
+					NULL,
+					0);
+			break;
+
+			case	RT_OID_USB_RESET_BULK_OUT:
+				DBGPRINT_RAW(RT_DEBUG_ERROR, "RT_OID_USB_RESET_BULK_OUT\n");
+			break;
+
+			case	RT_OID_USB_RESET_BULK_IN:
+					{
+				int	i;
+				DBGPRINT_RAW(RT_DEBUG_ERROR, "!!!!!RT_OID_USB_RESET_BULK_IN\n");
+				DBGPRINT_RAW(RT_DEBUG_ERROR, "!!!!!RT_OID_USB_RESET_BULK_IN\n");
+				DBGPRINT_RAW(RT_DEBUG_ERROR, "!!!!!RT_OID_USB_RESET_BULK_IN\n");
+				RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS);
+				RT2570InitializeAsic(pAdapter);
+				RTUSBWriteMACRegister(pAdapter, TXRX_CSR2, 1);
+				for (i = 0; i < RX_RING_SIZE; i++)
+				{
+					PRX_CONTEXT  pRxContext = &(pAdapter->RxContext[i]);
+
+					if (pRxContext->pUrb != NULL)
+					{
+						usb_kill_urb(pRxContext->pUrb);
+						usb_free_urb(pRxContext->pUrb);
+						pRxContext->pUrb = NULL;
+					}
+					if (pRxContext->TransferBuffer != NULL)
+					{
+						FreeMemory(pRxContext->TransferBuffer); 
+						pRxContext->TransferBuffer = NULL;
+					}
+
+				}
+				NICInitRecv(pAdapter);
+				RTMP_CLEAR_FLAG(pAdapter, fRTMP_ADAPTER_RESET_PIPE_IN_PROGRESS);
+				if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKIN_RESET))
+				{
+					RTMP_CLEAR_FLAG(pAdapter, fRTMP_ADAPTER_BULKIN_RESET);
+				}
+
+				if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RADIO_OFF))
+				{
+					RTUSBBulkReceive(pAdapter);
+					RTUSBWriteMACRegister(pAdapter, TXRX_CSR2, 0x7e);
+				}
+				}
+			break;
+
+			case	RT_OID_802_11_STA_CONFIG:
+			{
+				RT_802_11_STA_CONFIG *pStaConfig = (RT_802_11_STA_CONFIG *)pData;
+				if (pStaConfig->EnableTxBurst != pAdapter->PortCfg.EnableTxBurst)
+				{
+					pAdapter->PortCfg.EnableTxBurst = pStaConfig->EnableTxBurst;
+					//Currently Tx burst mode is only implemented in infrastructure mode.
+					if (INFRA_ON(pAdapter))
+					{
+						if (pAdapter->PortCfg.EnableTxBurst)
+						{
+							//Extend slot time if any encryption method is used to give ASIC more time to do encryption/decryption during Tx burst mode.
+							if (pAdapter->PortCfg.WepStatus != Ndis802_11EncryptionDisabled)
+								RTUSBWriteMACRegister(pAdapter, MAC_CSR10, 0x20);
+							//Set CWmin/CWmax to 0.
+							RTUSBWriteMACRegister(pAdapter, MAC_CSR22, 0x100);
+						}
+						else
+						{
+							if (pAdapter->PortCfg.WepStatus != Ndis802_11EncryptionDisabled)
+								AsicSetSlotTime(pAdapter, (BOOLEAN)pAdapter->PortCfg.ShortSlotInUsed);
+							RTUSBWriteMACRegister(pAdapter, MAC_CSR22, 0x53);
+						}
+					}
+				}
+				pAdapter->PortCfg.EnableTurboRate = pStaConfig->EnableTurboRate;
+				pAdapter->PortCfg.UseBGProtection = pStaConfig->UseBGProtection;
+				//pAdapter->PortCfg.UseShortSlotTime = pStaConfig->UseShortSlotTime;
+				pAdapter->PortCfg.UseShortSlotTime = 1; // 2003-10-30 always SHORT SLOT capable
+				if (pAdapter->PortCfg.AdhocMode != pStaConfig->AdhocMode)
+				{
+					// allow dynamic change of "USE OFDM rate or not" in ADHOC mode
+					// if setting changed, need to reset current TX rate as well as BEACON frame format
+					pAdapter->PortCfg.AdhocMode = pStaConfig->AdhocMode;
+					if (pAdapter->PortCfg.BssType == BSS_INDEP)
+					{
+						MlmeUpdateTxRates(pAdapter, FALSE);
+						MakeIbssBeacon(pAdapter);
+					}
+				}
+				DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_STA_CONFIG (Burst=%d,72/100=%d,Protection=%d,ShortSlot=%d,Adhoc=%d\n",
+				pStaConfig->EnableTxBurst,
+				pStaConfig->EnableTurboRate,
+				pStaConfig->UseBGProtection,
+				pStaConfig->UseShortSlotTime,
+				pStaConfig->AdhocMode);
+			}
+			break;
+
+			case	RT_OID_SET_PSM_BIT_SAVE:
+				MlmeSetPsmBit(pAdapter, PWR_SAVE);
+				EnqueueNullFrame(pAdapter, pAdapter->PortCfg.TxRate);
+				break;
+
+				case	RT_OID_SET_RADIO:
+					if (pAdapter->PortCfg.bRadio == TRUE){
+						MlmeRadioOn(pAdapter);
+						// Update extra information
+						pAdapter->ExtraInfo = EXTRA_INFO_CLEAR;
+					}
+					else{
+						MlmeRadioOff(pAdapter);
+						// Update extra information
+						pAdapter->ExtraInfo = SW_RADIO_OFF;
+					}
+					break;
+
+				case	RT_OID_RESET_FROM_ERROR:
+				case	RT_OID_RESET_FROM_NDIS:
+					{
+						UINT	i = 0;
+
+						RTUSBRejectPendingPackets(pAdapter);//reject all NDIS packets waiting in TX queue
+						RTUSBCleanUpDataBulkOutQueue(pAdapter);
+						MlmeSuspend(pAdapter);
+
+						//Add code to access necessary registers here.
+						//disable Rx
+						RTUSBWriteMACRegister(pAdapter, TXRX_CSR2, 1);
+						//Ask our device to complete any pending bulk in IRP.
+						while ((atomic_read(&pAdapter->PendingRx) > 0) || (pAdapter->BulkOutPending == TRUE))
+						{
+							if (atomic_read(&pAdapter->PendingRx) > 0)
+							{
+								DBGPRINT_RAW(RT_DEBUG_TRACE, "BulkIn IRP Pending!!!\n");
+								RTUSB_VendorRequest(pAdapter,
+													0,
+													DEVICE_VENDOR_REQUEST_OUT,
+													0x0C,
+													0x0,
+													0x0,
+													NULL,
+													0);
+							}
+
+							if (pAdapter->BulkOutPending == TRUE)
+							{
+								DBGPRINT_RAW(RT_DEBUG_TRACE, "BulkOut IRP Pending!!!\n");
+								if (i == 0)
+								{
+									RTUSBCancelPendingBulkOutIRP(pAdapter);
+									i++;
+								}
+							}
+
+							NdisMSleep(500000);
+						}
+
+						NICResetFromError(pAdapter);
+						if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HARDWARE_ERROR))
+						{
+							RTMP_CLEAR_FLAG(pAdapter, fRTMP_ADAPTER_HARDWARE_ERROR);
+						}
+						if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKIN_RESET))
+						{
+							RTMP_CLEAR_FLAG(pAdapter, fRTMP_ADAPTER_BULKIN_RESET);
+						}
+						if (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET))
+						{
+							RTMP_CLEAR_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET);
+						}
+
+						RTMP_CLEAR_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS);
+
+						if ((!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RADIO_OFF)) &&
+							(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) &&
+							(!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)))
+						{
+							MlmeResume(pAdapter);
+							RTUSBBulkReceive(pAdapter);
+							RTUSBWriteMACRegister(pAdapter, TXRX_CSR2, 0x7e);
+						}
+					}
+					break;
+
+				case	RT_OID_LINK_DOWN:
+					DBGPRINT_RAW(RT_DEBUG_TRACE, "LinkDown(RT_OID_LINK_DOWN)\n");
+					LinkDown(pAdapter);
+					break;
+
+				case	RT_OID_VENDOR_WRITE_BBP:
+					{
+						UCHAR	Offset, Value;
+						Offset = *((PUCHAR)pData);
+						Value = *((PUCHAR)(pData + 1));
+						RTUSBWriteBBPRegister(pAdapter, Offset, Value);
+					}
+					break;
+
+				case	RT_OID_VENDOR_READ_BBP:
+					{
+						UCHAR	Offset = *((PUCHAR)pData);
+						PUCHAR	pValue = (PUCHAR)(pData + 1);
+
+						DBGPRINT_RAW(RT_DEBUG_INFO, "offset = 0x%02x\n", Offset);
+						RTUSBReadBBPRegister(pAdapter, Offset, pValue);
+						DBGPRINT_RAW(RT_DEBUG_INFO, "value = 0x%02x\n", *pValue);
+					}
+					break;
+
+				case	RT_OID_VENDOR_WRITE_RF:
+					{
+						ULONG	Value = *((PULONG)pData);
+
+						DBGPRINT_RAW(RT_DEBUG_INFO, "value = 0x%08x\n", Value);
+						RTUSBWriteRFRegister(pAdapter, Value);
+					}
+					break;
+				    
+				case	RT_OID_802_11_RESET_COUNTERS:
+					{
+						UCHAR	Value[22];
+
+						RTUSBMultiReadMAC(pAdapter, STA_CSR0, Value, 22);
+					}
+					break;
+
+
+				case	RT_OID_USB_VENDOR_RESET:
+					RTUSB_VendorRequest(pAdapter,
+										0,
+										DEVICE_VENDOR_REQUEST_OUT,
+										1,
+										1,
+										0,
+										NULL,
+										0);
+					break;
+
+				case	RT_OID_USB_VENDOR_UNPLUG:
+					RTUSB_VendorRequest(pAdapter,
+										0,
+										DEVICE_VENDOR_REQUEST_OUT,
+										1,
+										2,
+										0,
+										NULL,
+										0);
+					break;
+
+				case	RT_OID_USB_VENDOR_SWITCH_FUNCTION:
+					RTUSBWriteMACRegister(pAdapter, MAC_CSR13, 0x2121);
+					RTUSBWriteMACRegister(pAdapter, MAC_CSR14, 0x1e1e);
+					RTUSBWriteMACRegister(pAdapter, MAC_CSR1, 3);
+					RTUSBWriteMACRegister(pAdapter, PHY_CSR4, 0xf);
+
+					RTUSB_VendorRequest(pAdapter,
+										0,
+										DEVICE_VENDOR_REQUEST_OUT,
+										1,
+										3,
+										0,
+										NULL,
+										0);
+					break;
+
+				case	RT_OID_VENDOR_FLIP_IQ:
+					{
+						USHORT	Value1, Value2;
+						RTUSBReadMACRegister(pAdapter, PHY_CSR5, &Value1);
+						RTUSBReadMACRegister(pAdapter, PHY_CSR6, &Value2);
+						if (*pData == 1)
+						{
+							DBGPRINT_RAW(RT_DEBUG_INFO, "I/Q Flip\n");
+							Value1 = Value1 | 0x0004;
+							Value2 = Value2 | 0x0004;
+						}
+						else
+						{
+							DBGPRINT_RAW(RT_DEBUG_INFO, "I/Q Not Flip\n");
+							Value1 = Value1 & 0xFFFB;
+							Value2 = Value2 & 0xFFFB;
+						}
+						RTUSBWriteMACRegister(pAdapter, PHY_CSR5, Value1);
+						RTUSBWriteMACRegister(pAdapter, PHY_CSR6, Value2);
+					}
+					break;
+
+				case	RT_OID_UPDATE_TX_RATE:
+					MlmeUpdateTxRates(pAdapter, FALSE);
+					if (ADHOC_ON(pAdapter))
+						MakeIbssBeacon(pAdapter);
+					break;
+
+#if 0
+				case	RT_OID_UPDATE_R17:
+					switch ((pAdapter->SET_R17_FLAG % 3)) 
+					{
+						case 1:				        	
+							RTUSBWriteBBPRegister(pAdapter, 17, pAdapter->BBPTuningParameters.BBPR17LowSensitivity);
+							RTUSBWriteBBPRegister(pAdapter, 24, pAdapter->BBPTuningParameters.R24HigherValue);
+							RTUSBWriteBBPRegister(pAdapter, 25, pAdapter->BBPTuningParameters.R25HigherValue);
+							RTUSBWriteBBPRegister(pAdapter, 61, pAdapter->BBPTuningParameters.R61HigherValue);
+							DBGPRINT(RT_DEBUG_TRACE,("RT_OID_UPDATE_1 R17 = %x\n",pAdapter->BBPTuningParameters.BBPR17LowSensitivity));
+							break;
+						case 2:
+							RTUSBWriteBBPRegister(pAdapter, 17, pAdapter->PortCfg.BbpTuning.VgcUpperBound);
+							RTUSBWriteBBPRegister(pAdapter, 24, pAdapter->BBPTuningParameters.R24LowerValue);
+							RTUSBWriteBBPRegister(pAdapter, 25, pAdapter->BBPTuningParameters.R25LowerValue);
+							RTUSBWriteBBPRegister(pAdapter, 61, pAdapter->BBPTuningParameters.R61LowerValue);
+							DBGPRINT(RT_DEBUG_TRACE,("RT_OID_UPDATE_2 R17 = %x\n",pAdapter->PortCfg.BbpTuning.VgcUpperBound));
+							break;
+						case 0:
+							RTUSBWriteBBPRegister(pAdapter, 17, pAdapter->BBPR17InitValue);
+							RTUSBWriteBBPRegister(pAdapter, 24, pAdapter->BBPTuningParameters.R24LowerValue);
+							RTUSBWriteBBPRegister(pAdapter, 25, pAdapter->BBPTuningParameters.R25LowerValue);
+							RTUSBWriteBBPRegister(pAdapter, 61, pAdapter->BBPTuningParameters.R61LowerValue);
+							DBGPRINT(RT_DEBUG_TRACE,("RT_OID_UPDATE_0 R17 = %x\n",pAdapter->BBPR17InitValue));
+							break;     
+					}
+					break;
+#endif
+				case	RT_OID_802_11_PREAMBLE:
+					{
+						ULONG	Preamble = *((PULONG)(cmdqelmt->buffer));
+						if (Preamble == Rt802_11PreambleShort)
+						{
+							pAdapter->PortCfg.WindowsTxPreamble = Preamble;
+							MlmeSetTxPreamble(pAdapter, Rt802_11PreambleShort);
+						}
+						else if ((Preamble == Rt802_11PreambleLong) || (Preamble == Rt802_11PreambleAuto))
+						{
+							// if user wants AUTO, initialize to LONG here, then change according to AP's
+							// capability upon association.
+							pAdapter->PortCfg.WindowsTxPreamble = Preamble;
+							MlmeSetTxPreamble(pAdapter, Rt802_11PreambleLong);
+						}
+						DBGPRINT(RT_DEBUG_TRACE, "Set::RT_OID_802_11_SET_PREAMBLE (=%d)\n", Preamble);
+					}
+					break;
+
+				case	OID_802_11_NETWORK_TYPE_IN_USE:
+					{
+						NDIS_802_11_NETWORK_TYPE	NetType = *(PNDIS_802_11_NETWORK_TYPE)(cmdqelmt->buffer);
+						if (NetType == Ndis802_11DS)
+							RTMPSetPhyMode(pAdapter, PHY_11B);
+						else if (NetType == Ndis802_11OFDM24)
+							RTMPSetPhyMode(pAdapter, PHY_11BG_MIXED);
+						else if (NetType == Ndis802_11OFDM5)
+							RTMPSetPhyMode(pAdapter, PHY_11A);
+						DBGPRINT(RT_DEBUG_ERROR, "Set::OID_802_11_NETWORK_TYPE_IN_USE (=%d)\n",NetType);
+					}
+					break;
+
+				case	RT_OID_802_11_PHY_MODE:
+					{
+						ULONG	phymode = *(ULONG *)(cmdqelmt->buffer);
+						RTMPSetPhyMode(pAdapter, phymode);
+						DBGPRINT(RT_DEBUG_ERROR, "Set::RT_OID_802_11_SET_PHY_MODE (=%d)\n", phymode);
+					}
+					break;
+
+				case	OID_802_11_WEP_STATUS:
+					{
+						USHORT	Value;
+						NDIS_802_11_WEP_STATUS	WepStatus = *(PNDIS_802_11_WEP_STATUS)pData;
+						if (pAdapter->PortCfg.WepStatus != WepStatus)
+						{
+							// Config has changed
+							pAdapter->bConfigChanged = TRUE;
+							pAdapter->PortCfg.WepStatus = WepStatus;
+							pAdapter->PortCfg.OrigWepStatus = WepStatus;
+							pAdapter->PortCfg.PairCipher = WepStatus;
+							pAdapter->PortCfg.GroupCipher = WepStatus;								
+						}
+							
+						if ((WepStatus == Ndis802_11Encryption1Enabled) && (pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen != 0))
+						{
+							if (pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen <= 5)
+								pAdapter->PortCfg.CipherAlg = CIPHER_WEP64;
+							else
+								pAdapter->PortCfg.CipherAlg = CIPHER_WEP128;
+
+							RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &Value);
+							Value &= 0xfe00;
+							Value |= ((LENGTH_802_11 << 3) | (pAdapter->PortCfg.CipherAlg));
+							RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, Value);
+						}
+						else if (WepStatus == Ndis802_11Encryption2Enabled)
+						{
+							pAdapter->PortCfg.CipherAlg = CIPHER_TKIP;
+
+							RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &Value);
+							Value &= 0xfe00;
+							Value |= ((LENGTH_802_11 << 3) | (pAdapter->PortCfg.CipherAlg));
+							RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, Value);
+						}
+						else if (WepStatus == Ndis802_11Encryption3Enabled)
+						{
+							pAdapter->PortCfg.CipherAlg = CIPHER_AES;
+
+							RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &Value);
+							Value &= 0xfe00;
+							Value |= ((LENGTH_802_11 << 3) | (pAdapter->PortCfg.CipherAlg));
+							RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, Value);
+						}
+						else if (WepStatus == Ndis802_11EncryptionDisabled)
+						{
+							pAdapter->PortCfg.CipherAlg = CIPHER_NONE;
+
+							RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &Value);
+							Value &= 0xfe00;
+							RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, Value);
+						}
+						DBGPRINT(RT_DEBUG_TRACE, "OID_802_11_WEP_STATUS::TXRX_CSR0 (value=0x%x)\n", Value);
+					}
+					break;
+
+				case	OID_802_11_ADD_WEP:
+					{
+						ULONG	KeyIdx;
+						TXRX_CSR0_STRUC  TxRxCsr0;
+						PNDIS_802_11_WEP	pWepKey = (PNDIS_802_11_WEP)pData;
+
+						KeyIdx = pWepKey->KeyIndex & 0x0fffffff;
+						if (KeyIdx <= 4)
+						{
+							pAdapter->PortCfg.SharedKey[KeyIdx].KeyLen = (UCHAR)pWepKey->KeyLength;
+							memset(pAdapter->PortCfg.SharedKey[KeyIdx].Key, 0, MAX_LEN_OF_KEY);
+							memcpy(pAdapter->PortCfg.SharedKey[KeyIdx].Key, &pWepKey->KeyMaterial, pWepKey->KeyLength);
+
+							RTUSBMultiWriteMAC(pAdapter, (USHORT)(SEC_CSR0 + KeyIdx * 0x10), pAdapter->PortCfg.SharedKey[KeyIdx].Key, 16);//steven:always write 16 bytes.
+
+							if (pWepKey->KeyIndex & 0x80000000)
+							{
+								// Default key for tx (shared key)
+								pAdapter->PortCfg.DefaultKeyId = (UCHAR)KeyIdx;
+
+								if (pWepKey->KeyLength <= 5)
+									pAdapter->PortCfg.CipherAlg = CIPHER_WEP64;
+								else
+									pAdapter->PortCfg.CipherAlg = CIPHER_WEP128;
+
+								RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &TxRxCsr0.value);
+								TxRxCsr0.value &= 0xfe00;
+								TxRxCsr0.field.IVOffset = LENGTH_802_11;
+								TxRxCsr0.field.Algorithm = pAdapter->PortCfg.CipherAlg;
+								TxRxCsr0.field.KeyID |= (0x01 << KeyIdx);
+						DBGPRINT(RT_DEBUG_TRACE, "Set::TXRX_CSR0 (value=0x%x)\n", TxRxCsr0.value);
+								RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, TxRxCsr0.value);
+							}
+						}
+						DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_ADD_WEP (id=%d, Len=%d-byte)\n", KeyIdx, pWepKey->KeyLength);
+					}
+					break;
+				    
+				case	OID_802_11_ADD_KEY_WEP:
+					{
+						PNDIS_802_11_KEY	pKey = (PNDIS_802_11_KEY)pData;
+						TXRX_CSR0_STRUC  TxRxCsr0;							
+						ULONG	KeyIdx = pKey->KeyIndex & 0x0fffffff;
+
+						// it is a shared key
+						if (KeyIdx <= 4)
+						{
+							pAdapter->PortCfg.SharedKey[KeyIdx].KeyLen = (UCHAR)pKey->KeyLength;
+
+							memset(pAdapter->PortCfg.SharedKey[KeyIdx].Key, 0, MAX_LEN_OF_KEY);
+							memcpy(pAdapter->PortCfg.SharedKey[KeyIdx].Key, &pKey->KeyMaterial, pKey->KeyLength);
+							RTUSBMultiWriteMAC(pAdapter, (USHORT)(SEC_CSR0 + KeyIdx * 0x10), pAdapter->PortCfg.SharedKey[KeyIdx].Key, 16);
+
+							if (pKey->KeyIndex & 0x80000000)
+							{
+								// Default key for tx (shared key)
+								pAdapter->PortCfg.DefaultKeyId = (UCHAR)KeyIdx;
+
+								if (pKey->KeyLength <= 5)
+									pAdapter->PortCfg.CipherAlg = CIPHER_WEP64;
+								else
+									pAdapter->PortCfg.CipherAlg = CIPHER_WEP128;
+
+								RTUSBReadMACRegister(pAdapter, TXRX_CSR0, &TxRxCsr0.value);
+								TxRxCsr0.value &= 0xfe00;
+								TxRxCsr0.field.IVOffset = LENGTH_802_11;
+								TxRxCsr0.field.Algorithm = pAdapter->PortCfg.CipherAlg;
+								TxRxCsr0.field.KeyID |= (0x01 << KeyIdx);
+								RTUSBWriteMACRegister(pAdapter, TXRX_CSR0, TxRxCsr0.value);									
+								DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_ADD_WEP TXRX_CSR0=(0x%08x)\n",TxRxCsr0.value);								
+							}
+						}
+					}
+					break;
+
+				case	OID_802_11_ADD_KEY:
+					DBGPRINT(RT_DEBUG_TRACE, "Set::OID_802_11_ADD_KEY  \n");								
+{
+	int	i = 0;
+		DBGPRINT(RT_DEBUG_INFO,"pKey->KeyMaterial = ");
+		for (i = 0; i < 16; i++)
+		{
+			DBGPRINT_RAW(RT_DEBUG_INFO,"%02x:",
+			  ((PNDIS_802_11_KEY)pData)->KeyMaterial[i]);
+		}
+		DBGPRINT_RAW(RT_DEBUG_INFO,"\n");						
+}
+					NdisStatus = RTMPWPAAddKeyProc(pAdapter, pData);
+							RTUSBBulkReceive(pAdapter);
+
+					break;
+
+				case	OID_802_11_REMOVE_KEY:
+					NdisStatus = RTMPWPARemoveKeyProc(pAdapter, pData);
+					break;
+
+				case RT_OID_REMOVE_ALLKEYS:
+					RTMPWPARemoveAllKeys(pAdapter);
+					break;
+#if 0
+				case RT_OID_802_11_QUERY_HARDWARE_REGISTER:
+					NdisStatus = RTUSBQueryHardWareRegister(pAdapter, pData);
+					break;
+				case RT_OID_802_11_SET_HARDWARE_REGISTER:
+					NdisStatus = RTMPSetHardWareRegister(pAdapter, pData);
+					break;
+#endif					
+			
+			default:
+			break;
+		}
+
+		if (cmdqelmt->CmdFromNdis == TRUE)
+		{
+			if ((cmdqelmt->command != OID_802_11_BSSID_LIST_SCAN) &&
+				(cmdqelmt->command != RT_OID_802_11_BSSID) &&
+				(cmdqelmt->command != OID_802_11_SSID) &&
+				(cmdqelmt->command != OID_802_11_DISASSOCIATE))
+			{
+			}
+
+			if ((cmdqelmt->command != RT_OID_SINGLE_READ_MAC) &&
+				(cmdqelmt->command != RT_OID_MULTI_READ_MAC) &&
+				(cmdqelmt->command != RT_OID_VENDOR_READ_BBP) &&
+#ifdef DBG					
+				(cmdqelmt->command != RT_OID_802_11_QUERY_HARDWARE_REGISTER) &&
+#endif					
+				(cmdqelmt->command != RT_OID_USB_VENDOR_EEPROM_READ))
+			{
+				if (cmdqelmt->buffer != NULL)
+					kfree(cmdqelmt->buffer);
+			}
+			
+			kfree((PCmdQElmt)cmdqelmt);
+		}
+		else
+			cmdqelmt->InUse = FALSE;			
+
+	}
+
+
+}
+
+static int usb_rtusb_open(struct net_device *net_dev)
+{
+
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) net_dev->priv;
+	NDIS_STATUS 	Status = NDIS_STATUS_SUCCESS;
+	NDIS_802_11_WEP WepKey;
+
+	printk("RT25usb  Driver version %x.%x.%x\n", DRV_MAJORVERSION,DRV_MINORVERSION, DRV_SUBVERSION);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+    if (!try_module_get(THIS_MODULE))
+    {
+        DBGPRINT(RT_DEBUG_ERROR, "%s: cannot reserve module\n", __FUNCTION__);
+        return -1;
+    }
+#else
+    MOD_INC_USE_COUNT;
+#endif
+
+	init_MUTEX(&(pAdapter->usbdev_semaphore));
+	
+	// init mediastate to disconnected
+	pAdapter->MediaState = NdisMediaStateDisconnected;
+	
+	pAdapter->rx_bh.func = RTUSBRxPacket;
+	// Init  RTMP_ADAPTER CmdQElements
+	Status = RT2570InitAdapterBlock(pAdapter);
+	if (Status != NDIS_STATUS_SUCCESS)
+	{
+		return Status;
+	}
+
+	//NdisAllocateSpinLock
+	// Init send data structures and related parameters
+	//
+	Status = NICInitTransmit(pAdapter);
+	if (Status != NDIS_STATUS_SUCCESS)
+	{
+		return Status;
+	}
+
+	//
+	// Init receive data structures and related parameters
+	//
+	Status = NICInitRecv(pAdapter);
+	if (Status != NDIS_STATUS_SUCCESS)
+	{
+		goto out;
+	}
+
+	RT2570InitializeAsic(pAdapter);
+	// RTMPReadParametersFromFile(pAdapter);
+	// Init the hardware and set up everything
+	//
+	
+	NICReadEEPROMParameters(pAdapter);
+
+	NICInitAsicFromEEPROM(pAdapter);
+
+	RTUSBWriteHWMACAddress(pAdapter);
+	
+	// initialize MLME
+	Status = MlmeInit(pAdapter);
+	if(Status != NDIS_STATUS_SUCCESS)
+	{
+		goto out;
+	}
+
+	// mlmethread flag restart
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	mlme_kill = 0;
+	RTUSBCmd_kill =0;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0) */
+	CreateThreads(net_dev);
+
+	// at every open handler, copy mac address.
+	memcpy(pAdapter->net->dev_addr, pAdapter->CurrentAddress, pAdapter->net->addr_len);
+
+	// Clear Reset Flag before starting receiving/transmitting
+	RTMP_CLEAR_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS);
+
+	
+	if (!RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RADIO_OFF))
+	{
+		RTUSBBulkReceive(pAdapter);
+		RTUSBWriteMACRegister(pAdapter, TXRX_CSR2, 0x7e);
+	} 
+	// start as if the link is up
+	//netif_device_attach (pAdapter->net);
+	// Start net interface tx /rx
+	netif_start_queue(net_dev);
+	netif_carrier_on(net_dev);
+	netif_wake_queue(net_dev);
+
+	if (pAdapter->PortCfg.WepStatus != Ndis802_11WEPDisabled)
+	{
+		memcpy(WepKey.KeyMaterial, pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].Key, pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen);
+                WepKey.KeyIndex = 0x80000000 + pAdapter->PortCfg.DefaultKeyId;
+                WepKey.KeyLength = pAdapter->PortCfg.SharedKey[pAdapter->PortCfg.DefaultKeyId].KeyLen;
+		RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_WEP, TRUE, &WepKey, sizeof(WepKey));
+	}
+
+	return 0;
+out:
+	ReleaseAdapter(pAdapter, FALSE);
+
+	return 0;
+
+}
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static int usb_rtusb_close(struct net_device *net)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) net->priv;
+	int ret;
+	DECLARE_WAIT_QUEUE_HEAD (unlink_wakeup); 
+	DECLARE_WAITQUEUE (wait, current);
+	int	i = 0;
+	printk("enter usb_rtusb_close( )\n");
+	DBGPRINT(RT_DEBUG_TEMP,"-->usb_rt2570_close \n");
+	netif_carrier_off(pAdapter->net);
+	netif_stop_queue(pAdapter->net);
+
+	DBGPRINT(RT_DEBUG_TEMP,"Ensure there are no more active urbs \n");
+	// ensure there are no more active urbs. 
+	add_wait_queue (&unlink_wakeup, &wait);
+	pAdapter->wait = &unlink_wakeup;
+	// maybe wait for deletions to finish.
+	while ((i < 10) && atomic_read(&pAdapter->PendingRx) > 0) {
+		//msleep(UNLINK_TIMEOUT_MS);
+		i++;
+		DBGPRINT ( RT_DEBUG_TEMP,"waited for %d urb to complete\n", atomic_read(&pAdapter->PendingRx));
+	}
+	pAdapter->wait = NULL;
+	remove_wait_queue (&unlink_wakeup, &wait); 
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if (pAdapter->MLMEThr_pid >= 0)
+	{
+		mlme_kill = 1;
+		RTUSBCMDUp(pAdapter, (&(pAdapter->mlme_semaphore)));
+		wmb(); // need to check
+		ret = kill_proc (pAdapter->MLMEThr_pid, SIGTERM, 1);
+		if (ret) 
+		{
+			printk (KERN_ERR "%s: unable to signal thread\n", pAdapter->net->name);
+			return ret;
+		}
+		wait_for_completion (&pAdapter->notify);
+	}
+	if (pAdapter->RTUSBCmdThr_pid>= 0)
+	{
+		RTUSBCmd_kill = 1;
+		RTUSBCMDUp(pAdapter, (&(pAdapter->RTUSBCmd_semaphore)));
+		wmb(); // need to check
+		ret = kill_proc (pAdapter->RTUSBCmdThr_pid, SIGTERM, 1);
+		if (ret) 
+		{
+			printk (KERN_ERR "%s: unable to signal thread\n", pAdapter->net->name);
+			return ret;
+		}
+		wait_for_completion (&pAdapter->notify);
+	}
+#else
+	if (pAdapter->MLMEThr_active)
+	{
+		ret = kthread_stop(pAdapter->MLMEThr);
+		if (ret) 
+		{
+			printk (KERN_ERR "%s: unable to stop thread\n", pAdapter->net->name);
+			return ret;
+		}
+	}
+	if (pAdapter->RTUSBCmdThr_active)
+	{
+		ret = kthread_stop(pAdapter->RTUSBCmdThr);
+		if (ret) 
+		{
+			printk (KERN_ERR "%s: unable to stop thread\n", pAdapter->net->name);
+			return ret;
+		}
+	}
+#endif
+	RTUSBHalt( pAdapter, FALSE);
+	DBGPRINT(RT_DEBUG_TEMP,"<--usb_rt2570_close\n");
+
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+int MlmeThread(void * Context)
+{
+	PRT2570ADAPTER	pAdapter = (PRT2570ADAPTER)Context;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0)
+	pAdapter->MLMEThr_active = 1;
+#else
+	daemonize();
+	current->flags |= PF_NOFREEZE;
+	/* signal that we've started the thread */
+	complete(&(pAdapter->notify));
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0) */
+
+	while (1)
+	{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0)
+		if (kthread_should_stop())
+			break;
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0) */
+		/* lock the device pointers */
+		down(&(pAdapter->mlme_semaphore));
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+		if (mlme_kill)
+			break;
+#endif
+		/* lock the device pointers , need to check if required*/
+		down(&(pAdapter->usbdev_semaphore));
+		MlmeHandler(pAdapter);		
+
+		/* unlock the device pointers */
+		up(&(pAdapter->usbdev_semaphore));
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	/* notify the exit routine that we're actually exiting now 
+	*
+	* complete()/wait_for_completion() is similar to up()/down(),
+	* except that complete() is safe in the case where the structure
+	* is getting deleted in a parallel mode of execution (i.e. just
+	* after the down() -- that's necessary for the thread-shutdown
+	* case.
+	*
+	* complete_and_exit() goes even further than this -- it is safe in
+	* the case that the thread of the caller is going away (not just
+	* the structure) -- this is necessary for the module-remove case.
+	* This is important in preemption kernels, which transfer the flow
+	* of execution immediately upon a complete().
+	*/
+	complete_and_exit (&pAdapter->notify, 0);
+	DBGPRINT(RT_DEBUG_TRACE, "<---MlmeThread\n");
+#else
+	DBGPRINT(RT_DEBUG_TRACE, "MlmeThread end\n");
+	pAdapter->MLMEThr_active = 0;
+#endif
+	return 0;
+}
+
+int RTUSBCmdThread(void * Context)
+{
+	PRT2570ADAPTER	pAdapter = (PRT2570ADAPTER)Context;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	daemonize();
+	current->flags |= PF_NOFREEZE;
+	/* signal that we've started the thread */
+	complete(&(pAdapter->notify));
+#else
+	pAdapter->RTUSBCmdThr_active = 1;
+#endif
+
+	while (1)
+	{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0)
+		if (kthread_should_stop())
+			break;
+#endif
+
+		/* lock the device pointers */
+		down(&(pAdapter->RTUSBCmd_semaphore));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+		if (RTUSBCmd_kill)
+			break;
+#endif
+		/* lock the device pointers , need to check if required*/
+		down(&(pAdapter->usbdev_semaphore));
+		CMDHandler(pAdapter);		
+
+		/* unlock the device pointers */
+		up(&(pAdapter->usbdev_semaphore));
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	complete_and_exit (&pAdapter->notify, 0);
+	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBCmdThread\n");
+#else
+	DBGPRINT(RT_DEBUG_TRACE, "RTUSBCmdThread end\n");
+	pAdapter->RTUSBCmdThr_active = 0;
+#endif
+	return 0;
+}
+
+static void *usb_rtusb_probe(struct usb_device *dev, UINT interface,
+				const struct usb_device_id *id_table)
+{	
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER)NULL;
+	int i;
+	struct net_device *netdev;
+	int res = -ENOMEM;
+ 
+	
+	for (i = 0; i < rtusb_usb_id_len; i++)
+	{
+		if (le16_to_cpu(dev->descriptor.idVendor) == rtusb_usb_id[i].idVendor &&
+			le16_to_cpu(dev->descriptor.idProduct) == rtusb_usb_id[i].idProduct)
+		{
+			printk("idVendor = 0x%x, idProduct = 0x%x \n",
+				le16_to_cpu(dev->descriptor.idVendor),
+				le16_to_cpu(dev->descriptor.idProduct));
+			break;
+		}
+	}
+	if (i == rtusb_usb_id_len) {
+		printk("Device Descriptor not matching\n");
+		return NULL;
+	}
+
+	netdev = alloc_etherdev(sizeof (*pAdapter));
+	if(!netdev)
+	{
+		//if (!(pAdapter->net = init_etherdev(0, 0) )) {
+		printk("alloc_etherdev failed\n");
+			
+		MOD_DEC_USE_COUNT;
+		usb_dec_dev_use(dev);
+		return NULL;
+	}
+	
+	pAdapter = netdev->priv;
+	pAdapter->net = netdev;
+	netif_stop_queue(netdev);
+	pAdapter->config = dev->config;
+	pAdapter->usb = dev;
+	SET_MODULE_OWNER(pAdapter->net);
+	ether_setup(pAdapter->net);
+	netdev->open = usb_rtusb_open;
+	netdev->hard_start_xmit = RTUSBSendPackets;
+	netdev->stop = usb_rtusb_close;
+	netdev->priv = pAdapter;
+	netdev->get_stats = rt_getstats;
+#if WIRELESS_EXT >= 11
+	netdev->get_wireless_stats = RTUSB_get_wireless_stats;
+	netdev->wireless_handlers = (struct iw_handler_def *) &rt2500usb_iw_handler_def;
+#endif
+	netdev->set_mac_address = rt2570_set_mac_address;
+	netdev->do_ioctl = usb_rt2570_ioctl;
+	pAdapter->net->hard_header_len = 14;
+	pAdapter->net->mtu = 1500;
+	pAdapter->net->addr_len = 6;
+	pAdapter->net->weight = 64;
+	pAdapter->MediaState = NdisMediaStateDisconnected;
+
+
+	{// find available 
+		int 	i=0;
+		char	slot_name[IFNAMSIZ];
+		struct net_device	*device;
+
+		for (i = 0; i < 8; i++)
+		{
+			sprintf(slot_name, "rausb%d", i);
+			
+			for (device = dev_base; device != NULL; device = device->next)
+			{
+				if (strncmp(device->name, slot_name, 6) == 0)
+				{
+					break;
+				}
+			}
+			if(device == NULL)	break;
+		}
+		if(i == 8)
+		{
+			DBGPRINT(RT_DEBUG_ERROR, "No available slot name\n");
+			return NULL;
+		}
+
+		sprintf(pAdapter->net->name, "rausb%d", i);
+		DBGPRINT(RT_DEBUG_ERROR, "usbdevice->name %s\n",pAdapter->net->name);
+	}
+
+	//pAdapter->rx_bh.data = (unsigned long)pAdapter;
+
+	pAdapter->rx_bh.func = RTUSBRxPacket;
+	res = register_netdev(pAdapter->net);
+	if (res)
+		goto out3;
+
+	// start as if the link is up
+	// netif_device_attach (pAdapter->net);
+
+	PortCfgInit(pAdapter);
+
+	return pAdapter;
+out3:
+	printk("3 register_netdev failed err=%d\n",res);
+
+	return NULL;
+}
+//Disconnect function is called within exit routine
+static void usb_rtusb_disconnect(struct usb_device *dev, void *ptr)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) ptr;
+	
+
+	if (!pAdapter)
+		return;
+	
+	tasklet_kill(&pAdapter->rx_bh);
+	RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS);
+	// for debug, wait to show some messages to /proc system
+	udelay(1);
+	//After Add Thread implementation, Upon exec there, pAdapter->net seems becomes NULL, 
+	//need to check why???
+	//assert(pAdapter->net != NULL)
+	if(pAdapter->net != NULL)
+	{
+		printk("unregister_netdev( )\n");
+		unregister_netdev (pAdapter->net);
+	}
+
+	DBGPRINT(RT_DEBUG_ERROR,"<=== RTUSB disconnect successfully\n");
+
+}
+
+#else
+static int usb_rtusb_close(struct net_device *net)
+{
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER) net->priv;
+	int ret;
+	DECLARE_WAIT_QUEUE_HEAD (unlink_wakeup); 
+	DECLARE_WAITQUEUE (wait, current);
+	int	i = 0;
+	netif_carrier_off(pAdapter->net);
+	netif_stop_queue(pAdapter->net);
+
+	// ensure there are no more active urbs. 
+	add_wait_queue (&unlink_wakeup, &wait);
+	pAdapter->wait = &unlink_wakeup;
+	
+	// maybe wait for deletions to finish.
+	while ((i < 25) && atomic_read(&pAdapter->PendingRx) > 0) {
+#if LINUX_VERSION_CODE >KERNEL_VERSION(2,6,9)
+
+		msleep(UNLINK_TIMEOUT_MS);
+#endif
+		i++;
+	}
+	pAdapter->wait = NULL;
+	remove_wait_queue (&unlink_wakeup, &wait); 
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if (pAdapter->MLMEThr_pid >= 0)
+	{
+		mlme_kill = 1;
+		RTUSBCMDUp(pAdapter, (&(pAdapter->mlme_semaphore)));
+		wmb(); // need to check
+		ret = kill_proc (pAdapter->MLMEThr_pid, SIGTERM, 1);
+		if (ret) 
+		{
+			printk (KERN_ERR "%s: unable to signal thread\n", pAdapter->net->name);
+			return ret;
+		}
+		wait_for_completion (&pAdapter->notify);
+	}
+	if (pAdapter->RTUSBCmdThr_pid>= 0)
+	{
+		RTUSBCmd_kill = 1;
+		RTUSBCMDUp(pAdapter, (&(pAdapter->RTUSBCmd_semaphore)));
+		wmb(); // need to check
+		ret = kill_proc (pAdapter->RTUSBCmdThr_pid, SIGTERM, 1);
+		if (ret) 
+		{
+			printk (KERN_ERR "%s: unable to signal thread\n", pAdapter->net->name);
+			return ret;
+		}
+		wait_for_completion (&pAdapter->notify);
+	}
+#else
+	if (pAdapter->MLMEThr_active)
+	{
+		ret = kthread_stop(pAdapter->MLMEThr);
+		if (ret) 
+		{
+			printk (KERN_ERR "%s: unable to stop thread\n", pAdapter->net->name);
+			return ret;
+		}
+	}
+	if (pAdapter->RTUSBCmdThr_active)
+	{
+		ret = kthread_stop(pAdapter->RTUSBCmdThr);
+		if (ret) 
+		{
+			printk (KERN_ERR "%s: unable to stop thread\n", pAdapter->net->name);
+			return ret;
+		}
+	}
+#endif
+	RTUSBHalt( pAdapter, FALSE);
+	DBGPRINT(RT_DEBUG_TEMP,"<--usb_rt2570_close\n");
+
+	module_put(THIS_MODULE);
+
+	return 0;
+}
+
+int MlmeThread(void * Context)
+{
+	PRT2570ADAPTER	pAdapter = (PRT2570ADAPTER)Context;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	daemonize("rt2500usb");
+	allow_signal(SIGTERM);
+	current->flags |= PF_NOFREEZE;
+	/* signal that we've started the thread */
+	complete(&(pAdapter->notify));
+#else
+	pAdapter->MLMEThr_active = 1;
+#endif
+
+	while (1)
+	{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0)
+		if (kthread_should_stop())
+			break;
+#endif
+		/* lock the device pointers */
+		down(&(pAdapter->mlme_semaphore));
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+		if (mlme_kill)
+			break;
+#endif
+		/* lock the device pointers , need to check if required*/
+		down(&(pAdapter->usbdev_semaphore));
+
+		MlmeHandler(pAdapter);		
+
+		/* unlock the device pointers */
+		up(&(pAdapter->usbdev_semaphore));
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	complete_and_exit (&pAdapter->notify, 0);
+	DBGPRINT(RT_DEBUG_TRACE, "<---MlmeThread\n");
+#else
+	DBGPRINT(RT_DEBUG_TRACE, "MlmeThread end\n");
+	pAdapter->MLMEThr_active = 0;
+#endif
+	return 0;
+}
+
+int RTUSBCmdThread(void * Context)
+{
+
+	PRT2570ADAPTER	pAdapter = (PRT2570ADAPTER)Context;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	daemonize("rt2500usb");
+	allow_signal(SIGTERM);
+	current->flags |= PF_NOFREEZE;
+	/* signal that we've started the thread */
+	complete(&(pAdapter->notify));
+#else
+	pAdapter->RTUSBCmdThr_active = 1;
+#endif
+
+	while (1)
+	{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0)
+		if (kthread_should_stop())
+			break;
+#endif
+		/* lock the device pointers */
+		down(&(pAdapter->RTUSBCmd_semaphore));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+		if (RTUSBCmd_kill)
+			break;
+#endif
+		/* lock the device pointers , need to check if required*/
+		down(&(pAdapter->usbdev_semaphore));
+
+		CMDHandler(pAdapter);		
+
+		/* unlock the device pointers */
+		up(&(pAdapter->usbdev_semaphore));
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	complete_and_exit (&pAdapter->notify, 0);
+	DBGPRINT(RT_DEBUG_TRACE, "<---RTUSBCmdThread\n");
+#else
+	DBGPRINT(RT_DEBUG_TRACE, "RTUSBCmdThread end\n");
+	pAdapter->RTUSBCmdThr_active = 0;
+#endif
+	return 0;
+}
+
+static int usb_rtusb_probe (struct usb_interface *intf,
+					  const struct usb_device_id *id)
+{	
+	struct usb_device *dev = interface_to_usbdev(intf);
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER)NULL;
+	int i;
+	struct net_device *netdev;
+	int res = -ENOMEM;
+ 
+	
+	usb_get_dev(dev);
+	for (i = 0; i < rtusb_usb_id_len; i++)
+	{
+		if (le16_to_cpu(dev->descriptor.idVendor) == rtusb_usb_id[i].idVendor &&
+			le16_to_cpu(dev->descriptor.idProduct) == rtusb_usb_id[i].idProduct)
+		{
+			printk("idVendor = 0x%x, idProduct = 0x%x \n",
+				le16_to_cpu(dev->descriptor.idVendor),
+				le16_to_cpu(dev->descriptor.idProduct));
+			break;
+		}
+	}
+	if (i == rtusb_usb_id_len) {
+		printk("Device Descriptor not matching\n");
+		return res;
+	}
+
+	netdev = alloc_etherdev(sizeof (*pAdapter));
+	if(!netdev)
+	{
+		//if (!(pAdapter->net = init_etherdev(0, 0) )) {
+		printk("alloc_etherdev failed\n");
+	
+		module_put(THIS_MODULE);
+		return res;
+	}
+	
+	pAdapter = netdev->priv;
+	pAdapter->net = netdev;
+	netif_stop_queue(netdev);
+	pAdapter->config = &dev->config->desc;
+	pAdapter->usb = dev;
+	SET_MODULE_OWNER(pAdapter->net);
+	ether_setup(pAdapter->net);
+	netdev->open = usb_rtusb_open;
+	netdev->stop = usb_rtusb_close;
+	netdev->priv = pAdapter;
+	netdev->hard_start_xmit = RTUSBSendPackets;
+	netdev->get_stats = rt_getstats;
+#if 1
+#if WIRELESS_EXT >= 12
+#if WIRELESS_EXT < 17
+	netdev->get_wireless_stats = RTUSB_get_wireless_stats;
+#else
+	netdev->wireless_handlers = (struct iw_handler_def *) &rt2500usb_iw_handler_def;
+#endif
+#endif
+	netdev->do_ioctl = usb_rt2570_ioctl;
+#endif
+	pAdapter->net->set_mac_address = rt2570_set_mac_address;
+	pAdapter->net->hard_header_len = 14;
+	pAdapter->net->mtu = 1500;
+	pAdapter->net->addr_len = 6;
+	pAdapter->net->weight = 64;
+	pAdapter->MediaState = NdisMediaStateDisconnected;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	pAdapter->MLMEThr_pid= -1;
+	pAdapter->RTUSBCmdThr_pid= -1;
+#else
+	pAdapter->MLMEThr_active = 0;
+	pAdapter->RTUSBCmdThr_active = 0;
+#endif
+	RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS);
+
+	SET_NETDEV_DEV(pAdapter->net, &intf->dev);
+
+	{// find available 
+		int 	i=0;
+		char	slot_name[IFNAMSIZ];
+		struct net_device	*device;
+
+		for (i = 0; i < 8; i++)
+		{
+			sprintf(slot_name, "rausb%d", i);
+			
+			for (device = dev_base; device != NULL; device = device->next)
+			{
+				if (strncmp(device->name, slot_name, 6) == 0)
+				{
+					break;
+				}
+			}
+			if(device == NULL)	break;
+		}
+		if(i == 8)
+		{
+			DBGPRINT(RT_DEBUG_ERROR, "No available slot name\n");
+			return res;
+		}
+
+		sprintf(pAdapter->net->name, "rausb%d", i);
+	}
+
+	pAdapter->rx_bh.func = RTUSBRxPacket;
+	//bottom half data is assign at  each task_scheduler
+	//pAdapter->rx_bh.data = (unsigned long)pAdapter;
+
+	res = register_netdev(pAdapter->net);
+	if (res)
+		goto out3;
+
+	usb_set_intfdata(intf, pAdapter);
+
+	PortCfgInit(pAdapter);
+
+	return 0;
+out3:
+	printk("3 register_netdev failed err=%d\n",res);
+	free_netdev(netdev);
+
+	return -1;
+}
+static void usb_rtusb_disconnect(struct usb_interface *intf)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	PRT2570ADAPTER pAdapter = (PRT2570ADAPTER)NULL;
+	
+	pAdapter = usb_get_intfdata(intf);
+
+	usb_set_intfdata(intf, NULL);
+	RTMP_SET_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS);
+	DBGPRINT(RT_DEBUG_ERROR,"unregister usbnet usb-%s-%s\n",
+		dev->bus->bus_name, dev->devpath);
+	if (!pAdapter)
+		return;
+	
+	tasklet_kill(&pAdapter->rx_bh);
+	// for debug, wait to show some messages to /proc system
+	udelay(1);
+	//After Add Thread implementation, Upon exec there, pAdapter->net seems becomes NULL, 
+	//need to check why???
+	//assert(pAdapter->net != NULL)
+	if(pAdapter->net != NULL)
+	{
+		printk("unregister_netdev( )\n");
+		unregister_netdev (pAdapter->net);
+	}
+	udelay(1);
+	flush_scheduled_work ();
+	udelay(1);
+
+	free_netdev(pAdapter->net);
+	usb_put_dev(dev);
+	udelay(1);
+	DBGPRINT(RT_DEBUG_ERROR,"<=== RTUSB disconnect successfully\n");
+
+}
+
+#endif
+
+
+ int __init usb_rtusb_init(void)
+{
+	DBGPRINT(RT_DEBUG_ERROR,"enter rtusb init( )\n");
+
+	return usb_register(&rtusb_driver);
+}
+ void __exit usb_rtusb_exit(void)
+{
+	udelay(1);
+	udelay(1);
+	usb_deregister(&rtusb_driver);
+	printk("<===usb_rtusb_exit\n");
+}
+
+/**************************************************************/
+MODULE_DESCRIPTION("Ralink RT2570 usb 802.11g WLAN driver " DRV_VERSION " " DRV_RELDATE);
+MODULE_AUTHOR("http://rt2x00.sourceforge.net");
+MODULE_DEVICE_TABLE(usb, rtusb_usb_id);
+MODULE_LICENSE("GPL");
+
+module_init(usb_rtusb_init);	// initialization function
+module_exit(usb_rtusb_exit);	// exit function
+/**************************************************************/
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/sanity.c linux-2.4.35.3-mct/drivers/usb/rt2570/sanity.c
--- linux-2.4.35.3/drivers/usb/rt2570/sanity.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/sanity.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,954 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	sanityc
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+UCHAR	WPA_OUI[] = {0x00, 0x50, 0xf2, 0x01};
+UCHAR	RSN_OUI[] = {0x00, 0x0f, 0xac};
+
+extern 	UCHAR	BCAST[];
+
+/* 
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+    ==========================================================================
+ */
+BOOLEAN MlmeScanReqSanity(
+    IN PRT2570ADAPTER pAd, 
+    IN VOID *Msg, 
+    IN ULONG MsgLen, 
+    OUT UCHAR *BssType, 
+    OUT CHAR Ssid[], 
+    OUT UCHAR *SsidLen, 
+    OUT UCHAR *ScanType) 
+{
+    MLME_SCAN_REQ_STRUCT *Info;
+    
+    Info = (MLME_SCAN_REQ_STRUCT *)(Msg);
+    *BssType = Info->BssType;
+    *SsidLen = Info->SsidLen;
+    memcpy(Ssid, Info->Ssid, *SsidLen);
+    *ScanType = Info->ScanType;
+    
+    if ((*BssType == BSS_INFRA || *BssType == BSS_INDEP || *BssType == BSS_ANY) &&
+       (*ScanType == SCAN_ACTIVE || *ScanType == SCAN_PASSIVE)) 
+        return TRUE;
+    else 
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "MlmeScanReqSanity fail - wrong BssType or ScanType\n");
+        return FALSE;
+    }
+}
+
+/* 
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+    ==========================================================================
+ */
+BOOLEAN MlmeStartReqSanity(
+    IN PRT2570ADAPTER pAd, 
+    IN VOID *Msg, 
+    IN ULONG MsgLen, 
+    OUT CHAR Ssid[], 
+    OUT UCHAR *SsidLen) 
+{
+    MLME_START_REQ_STRUCT *Info;
+
+    Info = (MLME_START_REQ_STRUCT *)(Msg);
+    
+    if (Info->SsidLen > MAX_LEN_OF_SSID)
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "MlmeStartReqSanity fail - wrong SSID length\n");
+        return FALSE;
+    }
+
+    *SsidLen = Info->SsidLen;
+    memcpy(Ssid, Info->Ssid, *SsidLen);
+
+    return TRUE;
+}
+
+/* 
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+BOOLEAN MlmeAssocReqSanity(
+    IN PRT2570ADAPTER pAd, 
+    IN VOID *Msg, 
+    IN ULONG MsgLen, 
+    OUT MACADDR *ApAddr, 
+    OUT USHORT *CapabilityInfo, 
+    OUT ULONG *Timeout, 
+    OUT USHORT *ListenIntv) 
+{
+    MLME_ASSOC_REQ_STRUCT *Info;
+
+    Info = (MLME_ASSOC_REQ_STRUCT *)Msg;
+    *Timeout = Info->Timeout;                             // timeout
+    COPY_MAC_ADDR(ApAddr, &Info->Addr);                   // AP address
+    *CapabilityInfo = Info->CapabilityInfo;               // capability info
+    *ListenIntv = Info->ListenIntv;
+    
+    return TRUE;
+}
+
+/* 
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+    ==========================================================================
+ */
+BOOLEAN MlmeAuthReqSanity(
+    IN PRT2570ADAPTER pAd, 
+    IN VOID *Msg, 
+    IN ULONG MsgLen, 
+    OUT MACADDR *Addr, 
+    OUT ULONG *Timeout, 
+    OUT USHORT *Alg) 
+{
+    MLME_AUTH_REQ_STRUCT *Info;
+
+    Info  = (MLME_AUTH_REQ_STRUCT *)Msg;
+    COPY_MAC_ADDR(Addr, &Info->Addr);
+    *Timeout = Info->Timeout;
+    *Alg = Info->Alg;
+    
+    if ((*Alg == Ndis802_11AuthModeShared || *Alg == Ndis802_11AuthModeOpen) && !MAC_ADDR_IS_GROUP(*Addr)) 
+    {
+        return TRUE;
+    } 
+    else 
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "MlmeAuthReqSanity fail - wrong algorithm\n");
+        return FALSE;
+    }
+}
+
+/* 
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+BOOLEAN PeerAssocRspSanity(
+    IN PRT2570ADAPTER pAd, 
+    IN VOID *Msg, 
+    IN ULONG MsgLen, 
+    OUT MACADDR *Addr2, 
+    OUT USHORT *CapabilityInfo, 
+    OUT USHORT *Status, 
+    OUT USHORT *Aid, 
+    OUT UCHAR Rates[], 
+    OUT UCHAR *RatesLen,
+    OUT BOOLEAN *ExtendedRateIeExist) 
+{
+    CHAR          IeType, *Ptr;
+    MACFRAME     *Fr = (MACFRAME *)Msg;
+    PBEACON_EID_STRUCT	eid_ptr;
+    
+    COPY_MAC_ADDR(Addr2, &Fr->Hdr.Addr2);
+    Ptr = Fr->Octet;
+        
+    memcpy(CapabilityInfo, &Fr->Octet[0], 2);
+    memcpy(Status,         &Fr->Octet[2], 2);
+	// Mask out unnecessary capability information
+	*CapabilityInfo &= SUPPORTED_CAPABILITY_INFO;
+    
+    if (*Status == MLME_SUCCESS) 
+    {
+        memcpy(Aid, &Fr->Octet[4], 2);
+        *Aid = (*Aid) & 0x3fff; // AID is low 14-bit
+        
+        // -- get supported rates from payload and advance the pointer
+        IeType = Fr->Octet[6];
+        *RatesLen = Fr->Octet[7];
+        if ((IeType != IE_SUPP_RATES) || (*RatesLen > MAX_LEN_OF_SUPPORTED_RATES))
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "PeerAssocRspSanity fail - wrong SupportedRates IE\n");
+            return FALSE;
+        } 
+        else 
+       		memcpy(Rates, &Fr->Octet[8], *RatesLen);
+
+        // many AP implement proprietary IEs in non-standard order, we'd better
+        // tolerate mis-ordered IEs to get best compatibility
+        *ExtendedRateIeExist = FALSE;
+        eid_ptr = (PBEACON_EID_STRUCT) &Fr->Octet[8 + (*RatesLen)];
+            
+        // get variable fields from payload and advance the pointer
+        while (((UCHAR*)eid_ptr + eid_ptr->Len + 1) < ((UCHAR*)Fr + MsgLen))
+        {
+            switch (eid_ptr->Eid)
+            {
+                case IE_EXT_SUPP_RATES:
+                    *ExtendedRateIeExist = TRUE;
+                    if ((*RatesLen + eid_ptr->Len) <= MAX_LEN_OF_SUPPORTED_RATES)
+                    {
+                        memcpy(&Rates[*RatesLen], eid_ptr->Octet, eid_ptr->Len);
+                        *RatesLen = (*RatesLen) + eid_ptr->Len;
+                    }
+                    else
+                    {
+                        memcpy(&Rates[*RatesLen], eid_ptr->Octet, MAX_LEN_OF_SUPPORTED_RATES - (*RatesLen));
+                        *RatesLen = MAX_LEN_OF_SUPPORTED_RATES;
+                    }
+                    break;
+                default:
+                    DBGPRINT(RT_DEBUG_TRACE, "PeerAssocRspSanity - ignore unrecognized EID = %d\n", eid_ptr->Eid);
+                    break;
+            }
+                   
+            eid_ptr = (PBEACON_EID_STRUCT)((UCHAR*)eid_ptr + 2 + eid_ptr->Len);        
+        }
+    }
+    
+    return TRUE;
+}
+
+/* 
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+BOOLEAN PeerDisassocSanity(
+    IN PRT2570ADAPTER pAd, 
+    IN VOID *Msg, 
+    IN ULONG MsgLen, 
+    OUT MACADDR *Addr2, 
+    OUT USHORT *Reason) 
+{
+    MACFRAME *Fr = (MACFRAME *)Msg;
+
+    COPY_MAC_ADDR(Addr2, &Fr->Hdr.Addr2);
+    memcpy(Reason, &Fr->Octet[0], 2);
+
+    return TRUE;
+}
+
+/* 
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+BOOLEAN PeerDeauthSanity(
+    IN PRT2570ADAPTER pAd, 
+    IN VOID *Msg, 
+    IN ULONG MsgLen, 
+    OUT MACADDR *Addr2, 
+    OUT USHORT *Reason) 
+{
+    MACFRAME *Fr = (MACFRAME *)Msg;
+
+    COPY_MAC_ADDR(Addr2, &Fr->Hdr.Addr2);
+    memcpy(Reason, &Fr->Octet[0], 2);
+
+    return TRUE;
+}
+
+/* 
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+BOOLEAN PeerAuthSanity(
+    IN PRT2570ADAPTER pAd, 
+    IN VOID *Msg, 
+    IN ULONG MsgLen, 
+    OUT MACADDR *Addr, 
+    OUT USHORT *Alg, 
+    OUT USHORT *Seq, 
+    OUT USHORT *Status, 
+    CHAR *ChlgText) 
+{
+    MACFRAME     *Fr = (MACFRAME *)Msg;
+
+    COPY_MAC_ADDR(Addr,    &Fr->Hdr.Addr2);
+    memcpy(Alg,    &Fr->Octet[0], 2);
+    memcpy(Seq,    &Fr->Octet[2], 2);
+    memcpy(Status, &Fr->Octet[4], 2);
+
+    if (*Alg == Ndis802_11AuthModeOpen) 
+    {
+        if (*Seq == 1 || *Seq == 2) 
+        {
+            return TRUE;
+        } 
+        else 
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "PeerAuthSanity fail - wrong Seg#\n");
+            return FALSE;
+        }
+    } 
+    else if (*Alg == Ndis802_11AuthModeShared) 
+    {
+        if (*Seq == 1 || *Seq == 4) 
+        {
+            return TRUE;
+        } 
+        else if (*Seq == 2 || *Seq == 3) 
+        {
+            memcpy(ChlgText, &Fr->Octet[8], CIPHER_TEXT_LEN);
+            return TRUE;
+        } 
+        else 
+        {
+            DBGPRINT(RT_DEBUG_TRACE, "PeerAuthSanity fail - wrong Seg#\n");
+            return FALSE;
+        }
+    } 
+    else 
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "PeerAuthSanity fail - wrong algorithm\n");
+        return FALSE;
+    }
+}
+
+/* 
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+BOOLEAN PeerProbeReqSanity(
+    IN PRT2570ADAPTER pAd, 
+    IN VOID *Msg, 
+    IN ULONG MsgLen, 
+    OUT MACADDR *Addr2,
+    OUT CHAR Ssid[], 
+    OUT UCHAR *SsidLen) 
+//    OUT UCHAR Rates[], 
+//    OUT UCHAR *RatesLen) 
+{
+    UCHAR Idx;
+	UCHAR	RateLen;
+	CHAR          IeType;
+    MACFRAME *Fr = (MACFRAME *)Msg;
+
+    COPY_MAC_ADDR(Addr2, &Fr->Hdr.Addr2);
+
+    if ((Fr->Octet[0] != IE_SSID) || (Fr->Octet[1] > MAX_LEN_OF_SSID)) 
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "PeerProbeReqSanity fail - wrong SSID IE(Type=%d,Len=%d)\n",Fr->Octet[0],Fr->Octet[1]);
+        return FALSE;
+    } 
+    
+    *SsidLen = Fr->Octet[1];
+    memcpy(Ssid, &Fr->Octet[2], *SsidLen);
+
+    Idx = *SsidLen + 2;
+
+	// -- get supported rates from payload and advance the pointer
+	IeType = Fr->Octet[Idx];
+	RateLen = Fr->Octet[Idx + 1];
+	if (IeType != IE_SUPP_RATES) 
+    {
+        DBGPRINT(RT_DEBUG_TRACE, "PeerProbeReqSanity fail - wrong SupportRates IE(Type=%d,Len=%d)\n",Fr->Octet[Idx],Fr->Octet[Idx+1]);
+        return FALSE;
+    }
+	else
+	{
+		if ((pAd->PortCfg.AdhocMode == 2) && (RateLen < 8))
+			return (FALSE);
+	}
+
+    return TRUE;
+}
+
+/* 
+    ==========================================================================
+    Description:
+        MLME message sanity check
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+BOOLEAN PeerBeaconAndProbeRspSanity(
+    IN PRT2570ADAPTER pAd, 
+    IN VOID *Msg, 
+    IN ULONG MsgLen, 
+    OUT MACADDR *Addr2, 
+    OUT MACADDR *Bssid, 
+    OUT CHAR Ssid[], 
+    OUT UCHAR *SsidLen, 
+    OUT UCHAR *BssType, 
+    OUT USHORT *BeaconPeriod, 
+    OUT UCHAR *Channel, 
+    OUT LARGE_INTEGER *Timestamp, 
+    OUT BOOLEAN *CfExist, 
+    OUT CF_PARM *CfParm, 
+    OUT USHORT *AtimWin, 
+    OUT USHORT *CapabilityInfo, 
+    OUT UCHAR Rate[], 
+    OUT UCHAR *RateLen,
+    OUT BOOLEAN *ExtendedRateIeExist,
+    OUT UCHAR *Erp,
+    OUT UCHAR *DtimCount, 
+    OUT UCHAR *DtimPeriod, 
+    OUT UCHAR *BcastFlag, 
+    OUT UCHAR *MessageToMe, 
+    OUT UCHAR *Legacy,
+    OUT UCHAR SupRate[],
+	OUT UCHAR *SupRateLen,
+	OUT UCHAR ExtRate[],
+	OUT UCHAR *ExtRateLen,
+    OUT UCHAR *LengthVIE,
+    OUT	PNDIS_802_11_VARIABLE_IEs pVIE) 
+{
+    CHAR				*Ptr, TimLen;
+    MACFRAME			*Fr;
+    PBEACON_EID_STRUCT	eid_ptr;
+    UCHAR				SubType;
+	UCHAR				Sanity;
+
+	// Add for 3 necessary EID field check
+	Sanity = 0;
+
+    *ExtendedRateIeExist = FALSE;
+    *Erp = 0;
+	*LengthVIE = 0;					// Set the length of VIE to init value 0
+    
+    Fr = (MACFRAME *)Msg;
+    
+    // get subtype from header
+    SubType = (UCHAR)Fr->Hdr.SubType;
+
+    // get Addr2 and BSSID from header
+    COPY_MAC_ADDR(Addr2, &Fr->Hdr.Addr2);
+    COPY_MAC_ADDR(Bssid, &Fr->Hdr.Addr3);
+    
+    Ptr = Fr->Octet;
+    
+    // get timestamp from payload and advance the pointer
+    memcpy(Timestamp, Ptr, TIMESTAMP_LEN);
+    Ptr += TIMESTAMP_LEN;
+
+    // get beacon interval from payload and advance the pointer
+    memcpy(BeaconPeriod, Ptr, 2);
+    Ptr += 2;
+
+    // get capability info from payload and advance the pointer
+    memcpy(CapabilityInfo, Ptr, 2);
+    Ptr += 2;
+    if (CAP_IS_ESS_ON(*CapabilityInfo)) 
+    {
+        *BssType = BSS_INFRA;
+    } 
+    else 
+    {
+        *BssType = BSS_INDEP;
+    }
+
+	// Mask out unnecessary capability information
+	*CapabilityInfo &= SUPPORTED_CAPABILITY_INFO;
+	
+    eid_ptr = (PBEACON_EID_STRUCT) Ptr;
+
+    // get variable fields from payload and advance the pointer
+    while(((UCHAR*)eid_ptr + eid_ptr->Len + 1) < ((UCHAR*)Fr + MsgLen))
+    {
+        switch(eid_ptr->Eid)
+        {
+            case IE_SSID:
+				// Already has one SSID EID in this beacon, ignore the second one
+				if (Sanity & 0x1)
+					break;				
+                if(eid_ptr->Len <= MAX_LEN_OF_SSID)
+                {
+                    memcpy(Ssid, eid_ptr->Octet, eid_ptr->Len);
+                    *SsidLen = eid_ptr->Len;
+					Sanity |= 0x1;
+                }
+                else
+                {
+                    DBGPRINT(RT_DEBUG_TRACE, "PeerBeaconAndProbeRspSanity - wrong IE_SSID (len=%d)\n",eid_ptr->Len);
+                    return FALSE;
+                }
+                break;
+
+            case IE_SUPP_RATES:
+                if(eid_ptr->Len <= MAX_LEN_OF_SUPPORTED_RATES)
+                {
+            		int		index;
+            		UCHAR	rate, i;
+            		PUCHAR	eid_rate;
+
+            		i = 0;
+            		eid_rate = eid_ptr->Octet;
+            		for (index = 0; index < eid_ptr->Len; index++)
+            		{
+            			rate = eid_rate[index] & 0x7f; // Mask out basic rate set bit
+            			if ((rate == 2) || (rate == 4) || (rate == 11) || (rate == 22) ||
+            			    (rate == 12) || (rate == 18) || (rate == 24) || (rate == 36) ||
+            			    (rate == 48) || (rate == 72) || (rate == 96) || (rate == 108))
+            				Rate[i++] = eid_rate[index];	// Save rate with basic rate set bit if exists
+            		}
+            		*RateLen = i;
+					Sanity |= 0x2;
+					// Copy supported rate from desired AP's beacon. We are trying to match
+					// AP's supported and extended rate settings.
+					memcpy(SupRate, eid_ptr->Octet, eid_ptr->Len);
+					*SupRateLen = eid_ptr->Len;
+					// Check against the supported rates
+					RTMPCheckRates(pAd, SupRate, SupRateLen);
+                }
+                else
+                {
+                    DBGPRINT(RT_DEBUG_TRACE, "PeerBeaconAndProbeRspSanity - wrong IE_SUPP_RATES (len=%d)\n",eid_ptr->Len);
+                    return FALSE;
+                }
+                break;
+
+            case IE_FH_PARM:
+                DBGPRINT(RT_DEBUG_TRACE, "PeerBeaconAndProbeRspSanity(IE_FH_PARM) \n");
+                break;
+
+            case IE_DS_PARM:
+                if(eid_ptr->Len == 1)
+                {
+                    *Channel = *eid_ptr->Octet;                    
+                    if (ChannelSanity(pAd, *Channel) == 0)
+                    {
+                        DBGPRINT(RT_DEBUG_TRACE, "PeerBeaconAndProbeRspSanity - wrong IE_DS_PARM (ch=%d)\n",*Channel);
+                        return FALSE;
+                    }
+					Sanity |= 0x4;
+                }
+                else
+                {
+                    DBGPRINT(RT_DEBUG_TRACE, "PeerBeaconAndProbeRspSanity - wrong IE_DS_PARM (len=%d)\n",eid_ptr->Len);
+                    return FALSE;
+                }
+                break;
+
+            case IE_CF_PARM:
+                if(eid_ptr->Len == 6)
+                {
+                    *CfExist = TRUE;
+                    memcpy(CfParm, eid_ptr->Octet, eid_ptr->Len);
+                }
+                else
+                {
+                    DBGPRINT(RT_DEBUG_TRACE, "PeerBeaconAndProbeRspSanity - wrong IE_CF_PARM\n");
+                    return FALSE;
+                }
+                break;
+
+            case IE_IBSS_PARM:
+                if(eid_ptr->Len == 2)
+                {
+                    memcpy(AtimWin, eid_ptr->Octet, eid_ptr->Len);
+                }
+                else
+                {
+                    DBGPRINT(RT_DEBUG_TRACE, "PeerBeaconAndProbeRspSanity - wrong IE_IBSS_PARM\n");
+                    return FALSE;
+                }
+                break;
+
+            case IE_TIM:
+                if(INFRA_ON(pAd) && SubType == SUBTYPE_BEACON)
+                {
+                    GetTimBit((PUCHAR)eid_ptr, pAd->PortCfg.Aid, &TimLen, BcastFlag, DtimCount, DtimPeriod, MessageToMe);
+                }
+                break;
+
+			// New for WPA
+			case IE_WPA:
+				// Check the OUI version, filter out non-standard usage
+				if ((memcmp(eid_ptr->Octet, WPA_OUI, 4) == 0))
+				{
+					// Copy to pVIE which will report to microsoft bssid list.
+					Ptr = (PUCHAR) pVIE;
+					memcpy(Ptr + *LengthVIE, &eid_ptr->Eid, eid_ptr->Len + 2);
+					*LengthVIE += (eid_ptr->Len + 2);
+				}
+				DBGPRINT(RT_DEBUG_INFO, "PeerBeaconAndProbeRspSanity - Receive IE_WPA\n");
+				break;
+
+			case IE_EXT_SUPP_RATES:
+			    // concatenate all extended rates to Rates[] and RateLen
+			    *ExtendedRateIeExist = TRUE;
+                if (eid_ptr->Len <= MAX_LEN_OF_SUPPORTED_RATES)
+                {
+            		int		index;
+            		UCHAR	rate, i;
+            		PUCHAR	eid_rate;
+
+            		i = *RateLen;
+            		eid_rate = eid_ptr->Octet;
+            		for (index = 0; index < eid_ptr->Len; index++)
+            		{
+            			rate = eid_rate[index] & 0x7f; // Mask out basic rate set bit
+            			if ((rate == 2) || (rate == 4) || (rate == 11) || (rate == 22) ||
+            			    (rate == 12) || (rate == 18) || (rate == 24) || (rate == 36) ||
+            			    (rate == 48) || (rate == 72) || (rate == 96) || (rate == 108))
+            				Rate[i++] = eid_rate[index];	// Save rate with basic rate set bit if exists
+
+            		    if (i >= MAX_LEN_OF_SUPPORTED_RATES)
+            		        break;
+            		}
+            		*RateLen = i;
+					// Copy extended rate from desired AP's beacon. We are trying to match
+					// AP's supported and extended rate settings.
+					memcpy(ExtRate, eid_ptr->Octet, eid_ptr->Len);
+					*ExtRateLen = eid_ptr->Len;
+					// Check against the supported rates
+					RTMPCheckRates(pAd, ExtRate, ExtRateLen);
+				}
+			    break;
+
+            case IE_ERP:
+                if (eid_ptr->Len == 1)
+                {
+                    *Erp = (UCHAR)eid_ptr->Octet[0];
+                }
+                break;
+                
+			// WPA2 & 802.11i RSN
+			case IE_RSN:
+				// There is no OUI for version anymore, check the group cipher OUI before copying
+				if ((memcmp(eid_ptr->Octet + 2, RSN_OUI, 3) == 0))
+				{
+					// Copy to pVIE which will report to microsoft bssid list.
+					Ptr = (PUCHAR) pVIE;
+					memcpy(Ptr + *LengthVIE, &eid_ptr->Eid, eid_ptr->Len + 2);
+					*LengthVIE += (eid_ptr->Len + 2);
+				}
+                DBGPRINT(RT_DEBUG_INFO, "IE_RSN length = %d\n", eid_ptr->Len);
+                break;
+				
+            default:
+                DBGPRINT(RT_DEBUG_INFO, "PeerBeaconAndProbeRspSanity - unrecognized EID = %d\n", eid_ptr->Eid);
+                break;
+        }
+        
+        eid_ptr = (PBEACON_EID_STRUCT)((UCHAR*)eid_ptr + 2 + eid_ptr->Len);        
+    }
+
+    // in 802.11a band, AP may skip this DS IE in their BEACON
+    if ((pAd->PortCfg.Channel > 14) && ((Sanity & 0x04)==0))
+    {
+        *Channel = pAd->PortCfg.Channel;
+        Sanity |= 0x04;
+    }
+    
+    if (Sanity != 0x7)
+    {
+        DBGPRINT(RT_DEBUG_WARN, "PeerBeaconAndProbeRspSanity - missing field, Sanity=0x%02x\n", Sanity);
+        return FALSE;
+    }
+    else
+    {
+        return TRUE;
+    }
+
+}
+
+/* 
+    ==========================================================================
+    Description:
+        
+	IRQL = DISPATCH_LEVEL
+
+    ==========================================================================
+ */
+BOOLEAN GetTimBit(
+    IN CHAR *Ptr, 
+    IN USHORT Aid, 
+    OUT UCHAR *TimLen, 
+    OUT UCHAR *BcastFlag, 
+    OUT UCHAR *DtimCount, 
+    OUT UCHAR *DtimPeriod,
+    OUT UCHAR *MessageToMe) 
+{
+    UCHAR          BitCntl, N1, N2, MyByte, MyBit;
+    CHAR          *IdxPtr;
+
+    IdxPtr = Ptr;
+    
+    IdxPtr ++;
+    *TimLen = *IdxPtr;
+    
+    // get DTIM Count from TIM element
+    IdxPtr ++;
+    *DtimCount = *IdxPtr;
+    
+    // get DTIM Period from TIM element
+    IdxPtr++;
+    *DtimPeriod = *IdxPtr;
+        
+    // get Bitmap Control from TIM element
+    IdxPtr++;
+    BitCntl = *IdxPtr;
+
+    if ((*DtimCount == 0) && (BitCntl & 0x01)) 
+        *BcastFlag = TRUE;
+    else 
+        *BcastFlag = FALSE;
+    
+    // Parse Partial Virtual Bitmap from TIM element
+    N1 = BitCntl & 0xfe;    // N1 is the first bitmap byte#
+    N2 = *TimLen - 4 + N1;  // N2 is the last bitmap byte#
+    
+    if ((Aid < (N1 << 3)) || (Aid >= ((N2 + 1) << 3)))
+        *MessageToMe = FALSE;
+    else
+    {
+        MyByte = (Aid >> 3) - N1;                       // my byte position in the bitmap byte-stream
+        MyBit = Aid % 16 - ((MyByte & 0x01)? 8:0);
+
+        IdxPtr += (MyByte + 1);
+
+        //if (*IdxPtr)
+        //    DBGPRINT(RT_DEBUG_WARN, ("TIM bitmap = 0x%02x\n", *IdxPtr));
+            
+        if (*IdxPtr & (0x01 << MyBit))
+            *MessageToMe = TRUE;
+        else 
+            *MessageToMe = FALSE;
+    }
+
+    return TRUE;
+}
+
+/*!
+ *  \brief Get legacy bit, right now for 11b it is always 0
+ *  \param
+ *  \return TRUE if the parameters are OK, FALSE otherwise. Always return TRUE
+ *  \pre
+ *  \post
+ */
+BOOLEAN GetLegacy(
+    IN CHAR *Ptr, 
+    OUT UCHAR *Legacy) 
+{
+    *Legacy = 0;
+    return TRUE;
+}
+
+// IRQL = DISPATCH_LEVEL
+UCHAR ChannelSanity(
+    IN PRT2570ADAPTER pAd, 
+    IN UCHAR channel)
+{
+    UCHAR index;
+
+    for (index = 0; index < pAd->PortCfg.ChannelListNum; index ++)
+    {
+        if (channel == pAd->PortCfg.ChannelList[index])
+            return 1;
+    }
+    return 0;
+}
+
+/*
+	========================================================================
+	Routine Description:
+		Sanity check NetworkType (11b, 11g or 11a)
+		
+	Arguments:
+		pBss - Pointer to BSS table.
+
+	Return Value:
+        Ndis802_11DS .......(11b)
+        Ndis802_11OFDM24....(11g)
+        Ndis802_11OFDM5.....(11a)
+        
+	IRQL = DISPATCH_LEVEL
+	
+	========================================================================
+*/
+NDIS_802_11_NETWORK_TYPE NetworkTypeInUseSanity(
+    IN PBSS_ENTRY pBss)
+{
+	NDIS_802_11_NETWORK_TYPE	NetWorkType = Ndis802_11DS;
+	UCHAR						rate, i;
+
+	if (pBss->Channel <= 14)
+	{
+		for (i = 0; i < pBss->RatesLen; i++)
+		{
+			rate = pBss->Rates[i] & 0x7f; // Mask out basic rate set bit		
+			if ((rate == 2) || (rate == 4) || (rate == 11) || (rate == 22))
+			{
+				//
+				// basic rate means Ndis802_11DS
+				//
+				NetWorkType = Ndis802_11DS;
+				continue;
+			}
+			else
+			{
+				//
+				// Otherwise (even rate > 108) means Ndis802_11OFDM24
+				//
+				NetWorkType = Ndis802_11OFDM24;
+				break;
+			}	
+		}
+	}
+	else
+	{
+		NetWorkType = Ndis802_11OFDM5;
+	}
+
+	return NetWorkType;
+}
+
+/*
+	========================================================================
+	Routine Description:
+		Sanity check pairwise key on pAdapter->PortCfg.AuthMode < Ndis802_11AuthModeWPA
+		
+	Arguments:
+		pAdapter - Pointer to our adapter
+		pBuf 	 - Pointer to NDIS_802_11_KEY structure
+
+	Return Value:
+		NDIS_STATUS_SUCCESS
+		NDIS_STATUS_INVALID_DATA
+        
+	IRQL = DISPATCH_LEVEL
+
+	Note:
+		For OID_802_11_ADD_KEY setting, on old wep stuff also need to verify
+		the structure of NIDS_802_11_KEY
+	========================================================================
+*/
+NDIS_STATUS	RTMPWPAWepKeySanity(
+	IN	PRT2570ADAPTER	pAdapter,
+	IN	PVOID			pBuf)
+{
+	PNDIS_802_11_KEY	pKey;
+	ULONG				KeyIdx;
+	NDIS_STATUS			Status = NDIS_STATUS_SUCCESS;
+	BOOLEAN 			bTxKey; 		// Set the key as transmit key
+	BOOLEAN 			bPairwise;		// Indicate the key is pairwise key
+
+	pKey = (PNDIS_802_11_KEY) pBuf;
+	KeyIdx = pKey->KeyIndex & 0x0fffffff;
+	// Bit 31 of Add-key, Tx Key
+	bTxKey		   = (pKey->KeyIndex & 0x80000000) ? TRUE : FALSE;
+	// Bit 30 of Add-key PairwiseKey
+	bPairwise	   = (pKey->KeyIndex & 0x40000000) ? TRUE : FALSE;
+
+	// 1. Check Group / Pairwise Key
+	if (bPairwise)	// Pairwise Key
+	{
+		// 1. Check KeyIdx 
+		// it is a shared key
+		if (KeyIdx > 4)
+			return (-EINVAL);
+
+		// 2. Check bTx, it must be true, otherwise, return NDIS_STATUS_INVALID_DATA
+		if (bTxKey == FALSE)
+			return (-EINVAL);
+
+		// 3. If BSSID is not all 0xff, return NDIS_STATUS_INVALID_DATA
+		if ((memcmp(pKey->BSSID, BCAST, 6) == 0))
+			return (-EINVAL);
+
+		// check key length
+		if ((pKey->KeyLength != 5) && (pKey->KeyLength != 13))
+			return (-EINVAL);
+	}
+	else
+	{
+		// Group Key
+		// 1. Check BSSID, if not current BSSID or Bcast, return NDIS_STATUS_INVALID_DATA
+		if ((memcmp(&pKey->BSSID, &BCAST, 6) != 0) &&
+			(memcmp(&pKey->BSSID, &pAdapter->PortCfg.Bssid, 6) != 0))
+			return (-EINVAL);
+		// 2. Check Key index for supported Group Key
+		if (KeyIdx > 4)
+			return (-EINVAL);
+	}
+
+	pAdapter->PortCfg.SharedKey[KeyIdx].KeyLen = (UCHAR) pKey->KeyLength;
+	memcpy(pAdapter->PortCfg.SharedKey[KeyIdx].Key, &pKey->KeyMaterial, pKey->KeyLength);
+	if (pKey->KeyIndex & 0x80000000)
+	{
+		// Default key for tx (shared key)
+		pAdapter->PortCfg.DefaultKeyId = (UCHAR) KeyIdx;
+	}	
+
+	return (Status);
+}
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/sha1.h linux-2.4.35.3-mct/drivers/usb/rt2570/sha1.h
--- linux-2.4.35.3/drivers/usb/rt2570/sha1.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/sha1.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,56 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	sha1.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#ifndef SHA1_H
+#define SHA1_H
+
+#define A_SHA_DIGEST_LEN 20
+
+typedef struct 
+{
+    unsigned long   H[5];
+    unsigned long   W[80];
+    int             lenW;
+    unsigned long   sizeHi,sizeLo;
+} A_SHA_CTX;
+
+void A_SHAInit(A_SHA_CTX *ctx);
+void A_SHAUpdate(A_SHA_CTX *ctx, unsigned char *dataIn, int len);
+void A_SHAFinal(A_SHA_CTX *ctx, unsigned char hashout[20]);
+void shaHashBlock(A_SHA_CTX *ctx);
+ void F(char *password, unsigned char *ssid, int ssidlength, int iterations, int count, unsigned char *output);
+int PasswordHash(char *password, unsigned char *ssid, int ssidlength, unsigned char *output);
+
+#endif /* SHA1_H */
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/sync.c linux-2.4.35.3-mct/drivers/usb/rt2570/sync.c
--- linux-2.4.35.3/drivers/usb/rt2570/sync.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/sync.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,1578 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	sync.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+// 2.4 Ghz channel plan
+UCHAR Ra24Ghz_FCC[] = {1,2,3,4,5,6,7,8,9,10,11};
+UCHAR Ra24Ghz_IC[]  = {1,2,3,4,5,6,7,8,9,10,11};
+UCHAR Ra24Ghz_ESTI[]= {1,2,3,4,5,6,7,8,9,10,11,12,13};
+UCHAR Ra24Ghz_SPAIN[] = {10,11};
+UCHAR Ra24Ghz_FRANCE[] = {10,11,12,13};
+UCHAR Ra24Ghz_MKK[] =  {14};
+UCHAR Ra24Ghz_MKK1[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14};
+UCHAR Ra24Ghz_ISRAEL[]  = {3,4,5,6,7,8,9};
+    
+// 5 Ghz channel plan
+UCHAR Ra5Ghz_UNII[] = {36,40,44,48,52,56,60,64,  149,153,157,161};
+UCHAR Ra5Ghz_MMAC[] = {34,38,42,46};
+UCHAR Ra5Ghz_HyperLAN2[] = {36,40,44,48,52,56,60,64,  100,104,108,112,116,120,124,128,132,136,140};
+
+extern UCHAR CipherSuiteWpaNoneTkip[];
+extern UCHAR CipherSuiteWpaNoneTkipLen;
+
+extern UCHAR CipherSuiteWpaNoneAes[];
+extern UCHAR CipherSuiteWpaNoneAesLen;
+
+/*
+    ==========================================================================
+    Description:
+        The sync state machine, 
+    Parameters:
+        Sm - pointer to the state machine
+    Note:
+        the state machine looks like the following
+        
+    Column 1-2
+                        SYNC_IDLE                       JOIN_WAIT_BEACON
+    MT2_MLME_SCAN_REQ   mlme_scan_req_action            invalid_state_when_scan
+    MT2_MLME_JOIN_REQ   mlme_join_req_action            invalid_state_when_join
+    MT2_MLME_START_REQ  mlme_start_req_action           invalid_state_when_start
+    MT2_PEER_BEACON     peer_beacon                     peer_beacon_at_join_wait_beacon_action
+    MT2_PEER_PROBE_RSP  peer_beacon                     drop
+    MT2_PEER_ATIM       drop                            drop
+    MT2_SCAN_TIMEOUT    Drop                            Drop
+    MT2_BEACON_TIMEOUT  Drop                            beacon_timeout_at_join_wait_beacon_action
+    MT2_ATIM_TIMEOUT    Drop                            Drop
+    MT2_PEER_PROBE_REQ  ????                            drop
+    
+    column 3
+                         SCAN_LISTEN
+    MT2_MLME_SCAN_REQ    invalid_state_when_scan
+    MT2_MLME_JOIN_REQ    invalid_state_when_join
+    MT2_MLME_START_REQ   invalid_state_when_start
+    MT2_PEER_BEACON      peer_beacon_at_scan_action
+    MT2_PEER_PROBE_RSP   peer_probe_rsp_at_scan_action
+    MT2_PEER_ATIM        drop
+    MT2_SCAN_TIMEOUT     scan_timeout_action
+    MT2_BEACON_TIMEOUT   Drop
+    MT2_ATIM_TIMEOUT     Drop
+    MT2_PEER_PROBE_REQ   drop
+    ==========================================================================
+ */
+VOID SyncStateMachineInit(
+    IN PRT2570ADAPTER pAd, 
+    IN STATE_MACHINE *Sm, 
+    OUT STATE_MACHINE_FUNC Trans[]) 
+{
+    StateMachineInit(Sm, Trans, MAX_SYNC_STATE, MAX_SYNC_MSG, (STATE_MACHINE_FUNC)Drop, SYNC_IDLE, SYNC_MACHINE_BASE);
+
+    // column 1
+    StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_SCAN_REQ, (STATE_MACHINE_FUNC)MlmeScanReqAction);
+    StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_JOIN_REQ, (STATE_MACHINE_FUNC)MlmeJoinReqAction);
+    StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_START_REQ, (STATE_MACHINE_FUNC)MlmeStartReqAction);
+    StateMachineSetAction(Sm, SYNC_IDLE, MT2_PEER_BEACON, (STATE_MACHINE_FUNC)PeerBeacon);
+//  StateMachineSetAction(Sm, SYNC_IDLE, MT2_PEER_PROBE_RSP, PeerBeacon);
+    StateMachineSetAction(Sm, SYNC_IDLE, MT2_PEER_PROBE_REQ, (STATE_MACHINE_FUNC)PeerProbeReqAction); 
+
+    //column 2
+    StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_SCAN_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenScan);
+    StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_JOIN_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenJoin);
+    StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_START_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenStart);
+    StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_PEER_BEACON, (STATE_MACHINE_FUNC)PeerBeaconAtJoinAction);
+    StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_BEACON_TIMEOUT, (STATE_MACHINE_FUNC)BeaconTimeoutAtJoinAction);
+
+    // column 3
+    StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_SCAN_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenScan);
+    StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_JOIN_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenJoin);
+    StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_START_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenStart);
+    StateMachineSetAction(Sm, SCAN_LISTEN, MT2_PEER_BEACON, (STATE_MACHINE_FUNC)PeerBeaconAtScanAction);
+    StateMachineSetAction(Sm, SCAN_LISTEN, MT2_PEER_PROBE_RSP, (STATE_MACHINE_FUNC)PeerBeaconAtScanAction);
+    StateMachineSetAction(Sm, SCAN_LISTEN, MT2_SCAN_TIMEOUT, (STATE_MACHINE_FUNC)ScanTimeoutAction);
+
+    // timer init
+    RTMPInitTimer(pAd, &pAd->Mlme.SyncAux.BeaconTimer, &BeaconTimeout);
+    //pAd->Mlme.SyncAux.BeaconTimer.data = (unsigned long)pAd;
+    //pAd->Mlme.SyncAux.BeaconTimer.function = &BeaconTimeout;
+    RTMPInitTimer(pAd, &pAd->Mlme.SyncAux.ScanTimer,  &ScanTimeout);
+    //pAd->Mlme.SyncAux.ScanTimer.data = (unsigned long)pAd;
+    //pAd->Mlme.SyncAux.ScanTimer.function = &ScanTimeout;
+}
+
+/* 
+    ==========================================================================
+    Description:
+        Becaon timeout handler, executed in timer thread
+    ==========================================================================
+ */
+VOID BeaconTimeout(
+    IN  unsigned long data) 
+{
+	PRT2570ADAPTER  pAd = (PRT2570ADAPTER)data;
+
+	DBGPRINT(RT_DEBUG_TRACE,"SYNC - BeaconTimeout\n");
+
+	// Do nothing if the driver is starting halt state.
+	// This might happen when timer already been fired before cancel timer with mlmehalt
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+		return;
+
+	MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_BEACON_TIMEOUT, 0, NULL);
+	RTUSBUp(pAd, &pAd->mlme_semaphore);
+}
+
+/* 
+    ==========================================================================
+    Description:
+        ATIM timeout handler, executed in timer thread
+    ==========================================================================
+ */
+VOID AtimTimeout(
+    IN  unsigned long data) 
+{
+	PRT2570ADAPTER  pAd = (PRT2570ADAPTER)data;
+
+	DBGPRINT(RT_DEBUG_TRACE,"SYNC - AtimTimeout \n");
+	MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_ATIM_TIMEOUT, 0, NULL);
+	RTUSBUp(pAd, &pAd->mlme_semaphore);
+}
+
+/* 
+    ==========================================================================
+    Description:
+        Scan timeout handler, executed in timer thread
+    ==========================================================================
+ */
+VOID ScanTimeout(
+    IN  unsigned long data) 
+{
+	PRT2570ADAPTER  pAd = (PRT2570ADAPTER)data;
+
+	DBGPRINT(RT_DEBUG_INFO,"SYNC - Scan Timeout \n");
+
+	// Do nothing if the driver is starting halt state.
+	// This might happen when timer already been fired before cancel timer with mlmehalt
+	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
+		return;
+
+	MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_SCAN_TIMEOUT, 0, NULL);
+	RTUSBUp(pAd, &pAd->mlme_semaphore);
+}
+
+/* 
+    ==========================================================================
+    Description:
+        MLME SCAN req state machine procedure
+    ==========================================================================
+ */
+VOID MlmeScanReqAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+	UCHAR          Ssid[MAX_LEN_OF_SSID], SsidLen, ScanType, BssType;
+	ULONG          Now;
+
+	if (pAd->PortCfg.BssType == BSS_MONITOR)
+		return;
+
+	DBGPRINT(RT_DEBUG_INFO, "SYNC - MlmeScanReqAction\n");
+#if 0
+	// Check the total scan tries for one single OID command
+	if (pAd->PortCfg.IgnoredScanNumber >= 3)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "SYNC - MlmeScanReqAction: Too many tries already\n");
+		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+		MlmeCntlConfirm(pAd, MT2_SCAN_CONF, MLME_INVALID_FORMAT);
+		return;
+	}
+#endif
+	// Increase the scan retry counters.
+	pAd->PortCfg.IgnoredScanNumber++;
+
+	// Suspend MSDU transmission here
+	RTUSBSuspendMsduTransmission(pAd);
+
+	// first check the parameter sanity
+	if (MlmeScanReqSanity(pAd, 
+	                      Elem->Msg, 
+	                      Elem->MsgLen, 
+	                      &BssType, 
+	                      Ssid, 
+	                      &SsidLen, 
+	                      &ScanType)) 
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "SYNC - MlmeScanReqAction\n");
+		// temporarily recover BBP from short-distance-low-sensibility mode during SCAN
+		// for best SCANNING result;
+		AsicRestoreBbpSensibility(pAd);
+
+		Now = jiffies;
+		pAd->PortCfg.LastScanTime = Now;
+		// reset all the timers
+		RTMPCancelTimer(&pAd->Mlme.SyncAux.BeaconTimer);
+		RTMPCancelTimer(&pAd->Mlme.SyncAux.ScanTimer);
+
+		// record desired BSS parameters
+		pAd->Mlme.SyncAux.BssType = BssType;
+		pAd->Mlme.SyncAux.ScanType = ScanType;
+		pAd->Mlme.SyncAux.SsidLen = SsidLen;
+		memcpy(pAd->Mlme.SyncAux.Ssid, Ssid, SsidLen);
+
+		// start from the first channel
+		pAd->Mlme.SyncAux.Channel = FirstChannel(pAd);
+		ScanNextChannel(pAd);
+	} 
+	else 
+	{
+		DBGPRINT(RT_DEBUG_ERROR, "SYNC - MlmeScanReqAction() sanity check fail. BUG!!!\n");
+		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+		MlmeCntlConfirm(pAd, MT2_SCAN_CONF, MLME_INVALID_FORMAT);
+	}
+}
+
+/* 
+    ==========================================================================
+    Description:
+        MLME JOIN req state machine procedure
+    ==========================================================================
+ */
+VOID MlmeJoinReqAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    BSS_ENTRY    *pBss;
+    MLME_JOIN_REQ_STRUCT *Info = (MLME_JOIN_REQ_STRUCT *)(Elem->Msg);
+
+    DBGPRINT(RT_DEBUG_INFO, "SYNC - MlmeJoinReqAction(BSS #%d)\n", Info->BssIdx);
+        
+    // reset all the timers
+    RTMPCancelTimer(&pAd->Mlme.SyncAux.ScanTimer);
+    RTMPCancelTimer(&pAd->Mlme.SyncAux.BeaconTimer);
+
+    pBss = &pAd->Mlme.CntlAux.SsidBssTab.BssEntry[Info->BssIdx];
+    
+    // record the desired SSID & BSSID we're waiting for        
+    COPY_MAC_ADDR(&pAd->Mlme.SyncAux.Bssid, &pBss->Bssid);
+    memcpy(pAd->Mlme.SyncAux.Ssid, pBss->Ssid, pBss->SsidLen);
+    pAd->Mlme.SyncAux.SsidLen = pBss->SsidLen;
+        
+    // switch channel and waiting for beacon timer
+    AsicSwitchChannel(pAd, pBss->Channel);
+    AsicLockChannel(pAd, pBss->Channel);
+    DBGPRINT(RT_DEBUG_INFO, "SYNC - Wait BEACON from %02x:%02x:%02x:%02x:%02x:%02x ...\n", 
+        pAd->Mlme.SyncAux.Bssid.Octet[0], pAd->Mlme.SyncAux.Bssid.Octet[1],
+        pAd->Mlme.SyncAux.Bssid.Octet[2], pAd->Mlme.SyncAux.Bssid.Octet[3],
+        pAd->Mlme.SyncAux.Bssid.Octet[4], pAd->Mlme.SyncAux.Bssid.Octet[5]);
+    pAd->Mlme.SyncAux.BeaconTimer.Timer.expires = JOIN_TIMEOUT;
+    RTMPSetTimer(pAd, &pAd->Mlme.SyncAux.BeaconTimer, JOIN_TIMEOUT);
+    pAd->Mlme.SyncMachine.CurrState = JOIN_WAIT_BEACON;
+}
+
+/* 
+    ==========================================================================
+    Description:
+        MLME START Request state machine procedure, starting an IBSS
+    ==========================================================================
+ */
+VOID MlmeStartReqAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    UCHAR         Ssid[MAX_LEN_OF_SSID], SsidLen; 
+
+    // New for WPA security suites
+    UCHAR                       VarIE[MAX_VIE_LEN];     // Total VIE length = MAX_VIE_LEN - -5
+    NDIS_802_11_VARIABLE_IEs    *pVIE = NULL;
+    LARGE_INTEGER               TimeStamp;
+    BOOLEAN Privacy;
+#ifdef  SINGLE_ADHOC_LINKUP
+    ULONG   Bssidx;
+    BOOLEAN CfExist = FALSE;
+    CF_PARM CfParm;
+#endif
+
+    // Init Variable IE structure
+    pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
+    pVIE->Length = 0;
+    TimeStamp.vv.LowPart  = 0;
+    TimeStamp.vv.HighPart = 0;
+    
+    if (MlmeStartReqSanity(pAd, Elem->Msg, Elem->MsgLen, Ssid, &SsidLen)) 
+    {
+        // reset all the timers
+        RTMPCancelTimer(&pAd->Mlme.SyncAux.ScanTimer);
+        RTMPCancelTimer(&pAd->Mlme.SyncAux.BeaconTimer);
+
+        // PortCfg.PrivacyInvoked should have been set via OID_802_11_WEP_STATUS. 
+        // pAd->PortCfg.PrivacyInvoked = FALSE;
+        
+        memcpy(pAd->PortCfg.Ssid, Ssid, SsidLen); 
+        pAd->PortCfg.SsidLen           = SsidLen;
+        pAd->PortCfg.BssType           = BSS_INDEP;
+        Privacy = (pAd->PortCfg.WepStatus == Ndis802_11Encryption1Enabled) || 
+                  (pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) || 
+                  (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled);
+        pAd->PortCfg.CapabilityInfo    = CAP_GENERATE(0,1,0,0,Privacy, (pAd->PortCfg.WindowsTxPreamble == Rt802_11PreambleShort));
+        pAd->PortCfg.BeaconPeriod      = pAd->PortCfg.IbssConfig.BeaconPeriod;
+        pAd->PortCfg.AtimWin           = pAd->PortCfg.IbssConfig.AtimWin;
+        pAd->PortCfg.Channel           = pAd->PortCfg.IbssConfig.Channel;
+        if ((pAd->PortCfg.PhyMode == PHY_11ABG_MIXED) && (pAd->PortCfg.Channel > 14))
+        {
+            // no 1,2,5.5,11 Mbps when in 5Ghz band
+            pAd->PortCfg.SupportedRatesLen = pAd->PortCfg.IbssConfig.SupportedRatesLen - 4;
+            memset(pAd->PortCfg.SupportedRates, 0, MAX_LEN_OF_SUPPORTED_RATES);
+            memcpy(pAd->PortCfg.SupportedRates, &pAd->PortCfg.IbssConfig.SupportedRates[4], MAX_LEN_OF_SUPPORTED_RATES - 4);
+        }
+        else
+        {
+            pAd->PortCfg.SupportedRatesLen = pAd->PortCfg.IbssConfig.SupportedRatesLen;
+            memcpy(pAd->PortCfg.SupportedRates, pAd->PortCfg.IbssConfig.SupportedRates, MAX_LEN_OF_SUPPORTED_RATES);
+        }
+//      pAd->PortCfg.Pss = PWR_ACTIVE;
+        
+        // generate a radom number as BSSID
+        MacAddrRandomBssid(pAd, &pAd->PortCfg.Bssid);
+        AsicSetBssid(pAd, &pAd->PortCfg.Bssid); 
+        AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
+        AsicLockChannel(pAd, pAd->PortCfg.Channel);
+
+        DBGPRINT(RT_DEBUG_TRACE, "SYNC - MlmeStartReqAction(ch= %d,supported rate len= %d)\n",
+            pAd->PortCfg.Channel, pAd->PortCfg.SupportedRatesLen);
+
+#ifdef  SINGLE_ADHOC_LINKUP
+        // Add itself as the entry within BSS table
+        Bssidx = BssTableSearch(&pAd->PortCfg.BssTab, &pAd->PortCfg.Bssid);
+        if (Bssidx == BSS_NOT_FOUND)
+        {
+            Bssidx = BssTableSetEntry(pAd, &pAd->PortCfg.BssTab, &pAd->PortCfg.Bssid,
+                Ssid, SsidLen, pAd->PortCfg.BssType, pAd->PortCfg.BeaconPeriod, 
+                CfExist, &CfParm, pAd->PortCfg.AtimWin, pAd->PortCfg.CapabilityInfo, 
+                pAd->PortCfg.SupportedRates, pAd->PortCfg.SupportedRatesLen, TRUE,
+                pAd->PortCfg.Channel, Elem->Rssi, TimeStamp, pVIE);
+        }
+#endif
+
+        pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+        MlmeCntlConfirm(pAd, MT2_START_CONF, (USHORT)MLME_SUCCESS);
+    } 
+    else 
+    {
+        DBGPRINT(RT_DEBUG_ERROR, "SYNC - MlmeStartReqAction() sanity check fail. BUG!!!\n");
+        pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+        MlmeCntlConfirm(pAd, MT2_START_CONF, MLME_INVALID_FORMAT);
+    }
+}
+
+/* 
+    ==========================================================================
+    Description:
+        peer sends beacon back when scanning
+    ==========================================================================
+ */
+VOID PeerBeaconAtScanAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    MACADDR         Bssid, Addr2;
+    UCHAR           Ssid[MAX_LEN_OF_SSID], BssType, Channel, Rates[MAX_LEN_OF_SUPPORTED_RATES], RatesLen, 
+                    SsidLen, DtimCount, DtimPeriod, BcastFlag, MessageToMe, Legacy;
+    CF_PARM         CfParm;
+    USHORT          BeaconPeriod, AtimWin, CapabilityInfo;
+    MACFRAME       *Fr;
+    LARGE_INTEGER   TimeStamp;
+    BOOLEAN         CfExist = FALSE;
+    BOOLEAN         ExtendedRateIeExist;
+    UCHAR           Erp;
+    UCHAR         SupRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+    UCHAR         SupRateLen, ExtRateLen;
+	UCHAR			LenVIE;
+    // New for WPA security suites
+    UCHAR                       VarIE[MAX_VIE_LEN];     // Total VIE length = MAX_VIE_LEN - -5
+    NDIS_802_11_VARIABLE_IEs    *pVIE = NULL;
+
+
+    // memset(Ssid, 0, MAX_LEN_OF_SSID);
+    Fr = (MACFRAME *) Elem->Msg;
+    // Init Variable IE structure
+    pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
+    pVIE->Length = 0;
+    if (PeerBeaconAndProbeRspSanity(pAd, 
+                                Elem->Msg, 
+                                Elem->MsgLen, 
+                                &Addr2, 
+                                &Bssid, Ssid, 
+                                &SsidLen, 
+                                &BssType, 
+                                &BeaconPeriod, 
+                                &Channel, 
+                                &TimeStamp, 
+                                &CfExist, 
+                                &CfParm, 
+                                &AtimWin, 
+                                &CapabilityInfo, 
+                                Rates, 
+                                &RatesLen,
+                                &ExtendedRateIeExist,
+                                &Erp,
+                                &DtimCount, 
+                                &DtimPeriod, 
+                                &BcastFlag, 
+                                &MessageToMe, 
+                                &Legacy,
+                                SupRate,
+                                &SupRateLen,
+                                ExtRate,
+                                &ExtRateLen,
+								&LenVIE,
+                                pVIE)) 
+    {
+        ULONG Idx;
+        UCHAR Rssi = 0;
+
+        // This correct im-proper RSSI indication during SITE SURVEY issue.
+        // Always report bigger RSSI during SCANNING when receiving multiple BEACONs from the same AP. 
+        // This case happens because BEACONs come from adjacent channels, so RSSI become weaker as we 
+        // switch to more far away channels.
+        Idx = BssTableSearch(&pAd->PortCfg.BssTab, &Bssid);
+        if (pAd->Mlme.SyncAux.Channel != Channel)
+            {
+            return;
+            }
+        if (Idx != BSS_NOT_FOUND) 
+            Rssi = pAd->PortCfg.BssTab.BssEntry[Idx].Rssi;
+        if (Elem->Rssi > Rssi)
+            Rssi = Elem->Rssi;
+        
+        DBGPRINT(RT_DEBUG_INFO, "SYNC - PeerBeaconAtScanAction (Subtype=%d, SsidLen=%d, Ssid=%s)\n", Fr->Hdr.SubType, SsidLen,Ssid);
+
+        // Mask out unnecessary capability information
+        CapabilityInfo &= SUPPORTED_CAPABILITY_INFO;
+        
+        BssTableSetEntry(pAd, &pAd->PortCfg.BssTab, &Bssid, Ssid, SsidLen, BssType, 
+                         BeaconPeriod, CfExist, &CfParm, AtimWin, CapabilityInfo, Rates, 
+                         RatesLen, ExtendedRateIeExist, Channel, Rssi, TimeStamp, LenVIE, pVIE);
+    }
+    // sanity check fail, ignored
+}
+
+/* 
+    ==========================================================================
+    Description:
+        When waiting joining the (I)BSS, beacon received from external
+    ==========================================================================
+ */
+VOID PeerBeaconAtJoinAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    MACADDR       Bssid, Addr2;
+    UCHAR           Ssid[MAX_LEN_OF_SSID], BssType, Channel, Rates[MAX_LEN_OF_SUPPORTED_RATES], RatesLen, 
+                    SsidLen, DtimCount, DtimPeriod, BcastFlag, MessageToMe, Legacy;
+    LARGE_INTEGER TimeStamp;
+    USHORT        BeaconPeriod, AtimWin, CapabilityInfo;
+    CF_PARM       Cf;
+    BOOLEAN       CfExist = FALSE, ExtendedRateIeExist;
+    UCHAR         Erp;
+    UCHAR         SupRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+    UCHAR         SupRateLen, ExtRateLen;
+	UCHAR		  LenVIE;
+
+    // New for WPA security suites
+    UCHAR                       VarIE[MAX_VIE_LEN];     // Total VIE length = MAX_VIE_LEN - -5
+    NDIS_802_11_VARIABLE_IEs    *pVIE = NULL;
+
+    // Init Variable IE structure
+    pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
+    pVIE->Length = 0;
+    if (PeerBeaconAndProbeRspSanity(pAd, 
+                                Elem->Msg, 
+                                Elem->MsgLen, 
+                                &Addr2, 
+                                &Bssid, 
+                                Ssid, 
+                                &SsidLen, 
+                                &BssType, 
+                                &BeaconPeriod, 
+                                &Channel, 
+                                &TimeStamp, 
+                                &CfExist, 
+                                &Cf, 
+                                &AtimWin, 
+                                &CapabilityInfo, 
+                                Rates, 
+                                &RatesLen,
+                                &ExtendedRateIeExist,
+                                &Erp,
+                                &DtimCount, 
+                                &DtimPeriod, 
+                                &BcastFlag, 
+                                &MessageToMe, 
+                                &Legacy,
+                                SupRate,
+                                &SupRateLen,
+                                ExtRate,
+                                &ExtRateLen,
+								&LenVIE,
+                                pVIE)) 
+    {
+        // Disqualify 11b only adhoc when we are in 11g only adhoc mode
+        if ((BssType == BSS_INDEP) && (pAd->PortCfg.AdhocMode == 2) && (RatesLen < 12))
+            return;
+        
+        if (MAC_ADDR_EQUAL(&pAd->Mlme.SyncAux.Bssid, &Bssid))
+        {
+            RTMPCancelTimer( &pAd->Mlme.SyncAux.BeaconTimer);
+            // Update RSSI to prevent No signal display when cards first initialized
+            pAd->PortCfg.LastRssi = Elem->Rssi;
+            pAd->PortCfg.AvgRssi  = Elem->Rssi;
+            
+            if (pAd->Mlme.CntlAux.SsidLen > 0)
+            {
+                memcpy(pAd->PortCfg.Ssid, pAd->Mlme.CntlAux.Ssid, pAd->Mlme.CntlAux.SsidLen);
+                pAd->PortCfg.SsidLen = pAd->Mlme.CntlAux.SsidLen;
+            }
+            else
+            {
+                memcpy(pAd->PortCfg.Ssid, Ssid, SsidLen);
+                pAd->PortCfg.SsidLen = SsidLen;
+            }
+        
+            COPY_MAC_ADDR(&pAd->PortCfg.Bssid, &Bssid);
+            AsicSetBssid(pAd, &pAd->PortCfg.Bssid);
+
+            pAd->PortCfg.BssType = BssType;
+            pAd->PortCfg.BeaconPeriod = BeaconPeriod;
+            pAd->PortCfg.Channel = Channel;
+
+            // filter out non-supported rates
+            {
+                int i;
+                pAd->PortCfg.SupportedRatesLen = 0;
+                for (i=0;i<RatesLen;i++)
+                {
+                    UCHAR Rate = Rates[i] & 0x7f;
+                    if ((pAd->PortCfg.PhyMode == PHY_11B) &&
+                        (Rate == 2 || Rate == 4 || Rate == 11 || Rate == 22))
+                    {
+                        ///DBGPRINT(RT_DEBUG_TRACE, ("SYNC - Supported Rate[%d] = 0x%02x\n",pAd->PortCfg.SupportedRatesLen, Rates[i]));
+                        pAd->PortCfg.SupportedRates[pAd->PortCfg.SupportedRatesLen] = Rates[i];
+                        pAd->PortCfg.SupportedRatesLen ++;
+                    }
+                    else if ((Rate == 2 || Rate == 4 || Rate == 11 || Rate == 22) ||
+                             (Rate == 12 || Rate == 18 || Rate == 24 || Rate == 36) ||
+                             (Rate == 48 || Rate == 72 || Rate == 96 || Rate == 108))
+                    {
+                        // DBGPRINT(RT_DEBUG_TRACE, ("SYNC - Supported Rate[%d] = 0x%02x\n",pAd->PortCfg.SupportedRatesLen, Rates[i]));
+                        pAd->PortCfg.SupportedRates[pAd->PortCfg.SupportedRatesLen] = Rates[i];
+                        pAd->PortCfg.SupportedRatesLen ++;
+                    }
+                }
+            }
+
+            // Copy AP's supported rate to portcfg for creating assoication request
+            // Also filter out not supported rate
+            // Supported rate
+            {
+                int i;
+                pAd->PortCfg.SupRateLen = 0;
+                for (i = 0; i < SupRateLen; i++)
+                {
+                    UCHAR Rate = SupRate[i] & 0x7f;
+                    if ((pAd->PortCfg.PhyMode == PHY_11B) &&
+                        (Rate == 2 || Rate == 4 || Rate == 11 || Rate == 22))
+                    {
+                        pAd->PortCfg.SupRate[pAd->PortCfg.SupRateLen] = SupRate[i];
+                        pAd->PortCfg.SupRateLen ++;
+                    }
+                    else if ((Rate == 2 || Rate == 4 || Rate == 11 || Rate == 22) ||
+                             (Rate == 12 || Rate == 18 || Rate == 24 || Rate == 36) ||
+                             (Rate == 48 || Rate == 72 || Rate == 96 || Rate == 108))
+                    {
+                        pAd->PortCfg.SupRate[pAd->PortCfg.SupRateLen] = SupRate[i];
+                        pAd->PortCfg.SupRateLen ++;
+                    }
+                }
+            }
+
+            // Copy AP's supported rate to portcfg for creating assoication request
+            // Also filter out not supported rate
+            // Extended rate
+            if (ExtendedRateIeExist == TRUE)
+            {
+                int i;
+                pAd->PortCfg.ExtRateLen = 0;
+                for (i = 0; i < ExtRateLen; i++)
+                {
+                    UCHAR Rate = ExtRate[i] & 0x7f;
+                    if ((pAd->PortCfg.PhyMode == PHY_11B) &&
+                        (Rate == 2 || Rate == 4 || Rate == 11 || Rate == 22))
+                    {
+                        pAd->PortCfg.ExtRate[pAd->PortCfg.ExtRateLen] = ExtRate[i];
+                        pAd->PortCfg.ExtRateLen ++;
+                    }
+                    else if ((Rate == 2 || Rate == 4 || Rate == 11 || Rate == 22) ||
+                             (Rate == 12 || Rate == 18 || Rate == 24 || Rate == 36) ||
+                             (Rate == 48 || Rate == 72 || Rate == 96 || Rate == 108))
+                    {
+                        pAd->PortCfg.ExtRate[pAd->PortCfg.ExtRateLen] = ExtRate[i];
+                        pAd->PortCfg.ExtRateLen ++;
+                    }
+                }
+            }
+            else
+            {
+                pAd->PortCfg.ExtRateLen = 0;
+            }
+            
+            DBGPRINT(RT_DEBUG_TRACE, "SYNC - AP's SupportedRatesLen=%d, set STA's SupportedRateLen=%d\n", 
+                RatesLen, pAd->PortCfg.SupportedRatesLen);
+            
+            // Mask out unnecessary capability information
+            CapabilityInfo &= SUPPORTED_CAPABILITY_INFO;
+            
+            // Check for 802.11g information, if 802.11 b/g mixed mode.
+            // We can't support its short preamble for now.
+            pAd->PortCfg.CapabilityInfo = CapabilityInfo;
+
+            if ((BssType == BSS_INDEP) && (CAP_IS_IBSS_ON(CapabilityInfo))) 
+            {
+                pAd->PortCfg.AtimWin = AtimWin;
+            } 
+            else if (BssType == BSS_INFRA) 
+            {
+                pAd->PortCfg.CfpPeriod = Cf.CfpPeriod;
+                pAd->PortCfg.CfpMaxDuration = Cf.CfpMaxDuration;
+                pAd->PortCfg.CfpDurRemain = Cf.CfpDurRemaining;
+                pAd->PortCfg.CfpCount = Cf.CfpCount;
+                pAd->PortCfg.CfpPeriod = Cf.CfpPeriod;
+
+                AsicEnableBssSync(pAd);
+            }
+
+            pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+            MlmeCntlConfirm(pAd, MT2_JOIN_CONF, MLME_SUCCESS);
+        }
+        // not to me BEACON, ignored
+    } 
+    // sanity check fail, ignore this frame
+}
+
+/* 
+    ==========================================================================
+    Description:
+        receive BEACON from peer
+    ==========================================================================
+ */
+VOID PeerBeacon(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    MACADDR       Bssid, Addr2;
+    CHAR          Ssid[MAX_LEN_OF_SSID];
+    CF_PARM       CfParm;
+    UCHAR         SsidLen, MessageToMe=0, BssType, Channel, Rates[MAX_LEN_OF_SUPPORTED_RATES];
+    UCHAR         RatesLen, DtimCount=0, DtimPeriod=0, BcastFlag=0, Legacy;
+    USHORT        CapabilityInfo, AtimWin, BeaconPeriod;
+    LARGE_INTEGER TimeStamp;
+    BOOLEAN       CfExist = FALSE;
+    USHORT        TbttNumToNextWakeUp;
+    BOOLEAN       ExtendedRateIeExist;
+    UCHAR         Erp;
+    UCHAR         SupRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+    UCHAR         SupRateLen, ExtRateLen;
+	UCHAR         LenVIE;
+
+    // New for WPA security suites
+    UCHAR                       VarIE[MAX_VIE_LEN];     // Total VIE length = MAX_VIE_LEN - -5
+    NDIS_802_11_VARIABLE_IEs    *pVIE = NULL;
+
+    if (!INFRA_ON(pAd) && !ADHOC_ON(pAd))
+ {     // return;
+
+}
+    // Init Variable IE structure
+    pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
+    pVIE->Length = 0;
+    if (PeerBeaconAndProbeRspSanity(pAd, 
+                                Elem->Msg, 
+                                Elem->MsgLen, 
+                                &Addr2, 
+                                &Bssid, 
+                                Ssid, 
+                                &SsidLen, 
+                                &BssType, 
+                                &BeaconPeriod, 
+                                &Channel, 
+                                &TimeStamp, 
+                                &CfExist, 
+                                &CfParm, 
+                                &AtimWin, 
+                                &CapabilityInfo, 
+                                Rates, 
+                                &RatesLen,
+                                &ExtendedRateIeExist,
+                                &Erp,
+                                &DtimCount, 
+                                &DtimPeriod, 
+                                &BcastFlag, 
+                                &MessageToMe, 
+                                &Legacy,
+                                SupRate,
+                                &SupRateLen,
+                                ExtRate,
+                                &ExtRateLen,
+                                &LenVIE,
+                                pVIE)) 
+    {
+        BOOLEAN is_my_bssid, is_my_ssid;
+        ULONG   Bssidx, Now;
+        BSS_ENTRY *pBss;
+
+	// Init Variable IE structure
+	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
+	pVIE->Length = 0;
+        is_my_bssid = (MAC_ADDR_EQUAL(&Bssid, &pAd->PortCfg.Bssid) ? TRUE : FALSE);
+        is_my_ssid = (((pAd->PortCfg.SsidLen == SsidLen) && (memcmp(Ssid, pAd->PortCfg.Ssid, (ULONG) SsidLen) == 0)) ? TRUE : FALSE);
+        // Mask out unnecessary capability information
+        CapabilityInfo &= SUPPORTED_CAPABILITY_INFO;
+
+        // ignore BEACON not for my SSID
+        if ((! is_my_ssid) && (! is_my_bssid))
+            {
+            return;
+            }
+
+        //
+        // Housekeeping "SsidBssTab" table for later-on ROAMing usage. 
+        //
+        Bssidx = BssTableSearch(&pAd->Mlme.CntlAux.SsidBssTab, &Bssid);
+        if (Bssidx == BSS_NOT_FOUND)
+        {
+            // Return immediately when in transition process when changing association
+            // Found this bug when doing WHQL ad-hoc test case
+            if (pAd->PortCfg.SsidLen != pAd->Mlme.CntlAux.SsidLen)
+                return;
+            if (memcmp(pAd->PortCfg.Ssid, pAd->Mlme.CntlAux.Ssid, pAd->PortCfg.SsidLen) != 0)
+                return;
+            
+            // discover new AP of this network, create BSS entry
+            Bssidx = BssTableSetEntry(pAd, &pAd->Mlme.CntlAux.SsidBssTab, &Bssid, Ssid, SsidLen, 
+                        BssType, BeaconPeriod, CfExist, &CfParm, AtimWin, CapabilityInfo, 
+                        Rates, RatesLen, ExtendedRateIeExist, Channel, Elem->Rssi, TimeStamp, LenVIE, pVIE);
+
+            if (Bssidx == BSS_NOT_FOUND) // return if BSS table full
+                return;  
+
+            DBGPRINT(RT_DEBUG_TRACE, "SYNC - New AP added to SsidBssTab[%d], RSSI=%d, MAC=%02x:%02x:%02x:%02x:%02x:%02x\n", 
+                Bssidx, Elem->Rssi, Bssid.Octet[0], Bssid.Octet[1], Bssid.Octet[2], 
+                Bssid.Octet[3], Bssid.Octet[4], Bssid.Octet[5]);
+        }
+        
+        // if the ssid matched & bssid unmatched, we should select the bssid with large value.
+        // This might happened when two STA start at the same time
+        if (is_my_ssid && (! is_my_bssid) && ADHOC_ON(pAd))
+        {
+            INT i;
+
+            // Add to safe guard adhoc wep status mismatch
+            if (pAd->PortCfg.WepStatus != pAd->Mlme.CntlAux.SsidBssTab.BssEntry[Bssidx].WepStatus)
+                return;
+            
+            // link down the one with smaller BSSID value.
+            for (i = 0; i < 6; i++)
+            {
+                if (Bssid.Octet[i] > pAd->PortCfg.Bssid.Octet[i])
+                {
+                    AsicDisableSync(pAd);
+                    memcpy(&pAd->PortCfg.Bssid, &Bssid, 6);
+                    AsicSetBssid(pAd, &pAd->PortCfg.Bssid); 
+                    AsicEnableIbssSync(pAd);
+                    break;
+                }
+            }
+        }
+
+        DBGPRINT(RT_DEBUG_INFO, "SYNC - PeerBeacon from %02x:%02x:%02x:%02x:%02x:%02x - Dtim=%d/%d, Rssi=%02x\n", 
+            Bssid.Octet[0], Bssid.Octet[1], Bssid.Octet[2], 
+            Bssid.Octet[3], Bssid.Octet[4], Bssid.Octet[5], 
+            DtimCount, DtimPeriod, Elem->Rssi);
+
+        Now = jiffies;
+        pBss = &pAd->Mlme.CntlAux.SsidBssTab.BssEntry[Bssidx];
+        pBss->Rssi = Elem->Rssi;       // lastest RSSI
+        pBss->LastBeaconRxTime = Now;   // last RX timestamp
+        
+        //
+        // BEACON from my BSSID - either IBSS or INFRA network
+        // 
+        if (is_my_bssid)
+        {
+            // 2002/12/06 - patch Abocom AP bug, which forgets to set "Privacy" bit in 
+            // AssocRsp even though this bit is ON in Beacon. So we update according 
+            // to following Beacon frame.
+            // pAd->PortCfg.PrivacyInvoked = CAP_IS_PRIVACY_ON(CapabilityInfo);
+            
+            pAd->PortCfg.LastBeaconRxTime = Now;
+#if 1
+            // at least one 11b peer joined. downgrade the MaxTxRate to 11Mbps
+            // after last 11b peer left for several seconds, we'll auto switch back to 11G rate
+            // in MlmePeriodicExec()
+            if (ADHOC_ON(pAd) && (RatesLen <= 4))   
+            {
+                // this timestamp is for MlmePeriodicExec() to check if all 11B peers have left
+                pAd->PortCfg.Last11bBeaconRxTime = Now;
+                
+                if (pAd->PortCfg.MaxTxRate > RATE_11)
+                {
+                    DBGPRINT(RT_DEBUG_TRACE, "SYNC - 11b peer joined. down-grade to 11b TX rates \n");
+                    memcpy(pAd->PortCfg.SupportedRates, Rates, MAX_LEN_OF_SUPPORTED_RATES);
+                    pAd->PortCfg.SupportedRatesLen = RatesLen;
+                    MlmeUpdateTxRates(pAd, FALSE);
+                    MakeIbssBeacon(pAd);        // supported rates changed
+                }
+            }
+#endif                
+            // check if RSSI reaches threshold
+            pAd->PortCfg.LastRssi = (pAd->PortCfg.LastRssi + Elem->Rssi) / 2;
+            pAd->PortCfg.AvgRssi  = (pAd->PortCfg.AvgRssi * 7 + Elem->Rssi) >> 3;
+            if ((pAd->PortCfg.RssiTriggerMode == RSSI_TRIGGERED_UPON_BELOW_THRESHOLD) &&
+                (pAd->PortCfg.LastRssi < pAd->PortCfg.RssiTrigger))
+            {
+                NdisMIndicateStatus(pAd->AdapterHandle, NDIS_STATUS_MEDIA_SPECIFIC_INDICATION, &Dbm, sizeof(NDIS_802_11_RSSI));
+            }
+            else if ((pAd->PortCfg.RssiTriggerMode == RSSI_TRIGGERED_UPON_EXCCEED_THRESHOLD) &&
+                (pAd->PortCfg.LastRssi > pAd->PortCfg.RssiTrigger))
+            {
+                //NDIS_802_11_RSSI Dbm = pAd->PortCfg.LastRssi - pAd->BBPTuningParameters.RSSIToDbmOffset;
+                NdisMIndicateStatus(pAd->AdapterHandle, NDIS_STATUS_MEDIA_SPECIFIC_INDICATION, &Dbm, sizeof(NDIS_802_11_RSSI));
+                //DBGPRINT(RT_DEBUG_TRACE, "SYNC - NdisMIndicateStatus *** RSSI %d dBm, greater than threshold %d dBm\n", 
+                //    Dbm, pAd->PortCfg.RssiTrigger - pAd->BBPTuningParameters.RSSIToDbmOffset);
+            }
+
+            if (INFRA_ON(pAd)) // && (pAd->PortCfg.PhyMode == PHY_11BG_MIXED))
+            {
+                BOOLEAN bUseShortSlot, bUseBGProtection;
+                
+                // decide to use/change to - 
+                //      1. long slot (20 us) or short slot (9 us) time
+                //      2. turn on/off RTS/CTS and/or CTS-to-self protection
+                //      3. short preamble
+                bUseShortSlot = (pAd->PortCfg.UseShortSlotTime == TRUE) && CAP_IS_SHORT_SLOT_TIME(CapabilityInfo);
+                if (bUseShortSlot != pAd->PortCfg.ShortSlotInUsed)
+                    AsicSetSlotTime(pAd, bUseShortSlot);
+
+                bUseBGProtection = (pAd->PortCfg.UseBGProtection == 1) ||    // always use
+                                   ((pAd->PortCfg.UseBGProtection == 0) && ERP_IS_USE_PROTECTION(Erp));
+                if (bUseBGProtection != pAd->PortCfg.BGProtectionInUsed)
+                {
+                    pAd->PortCfg.BGProtectionInUsed = bUseBGProtection;
+                    DBGPRINT(RT_DEBUG_TRACE, "SYNC - AP changed B/G protection to %d\n", bUseBGProtection);
+                }
+
+                if ((pAd->PortCfg.TxPreambleInUsed == Rt802_11PreambleShort) && ERP_IS_USE_BARKER_PREAMBLE(Erp))
+                {
+                    MlmeSetTxPreamble(pAd, Rt802_11PreambleLong);
+                    DBGPRINT(RT_DEBUG_TRACE, "SYNC - AP forced to use LONG preamble\n");
+                }
+            }
+            
+            if (INFRA_ON(pAd))
+            {
+                if (pAd->PortCfg.Psm == PWR_SAVE)
+                {
+                    //  1. AP has backlogged unicast-to-me frame, stay AWAKE, send PSPOLL
+                    //  2. AP has backlogged broadcast/multicast frame and we want those frames, stay AWAKE
+                    //  3. we have outgoing frames in TxRing or PrioRing, better stay AWAKE
+                    //  4. Psm change to PWR_SAVE, but AP not been informed yet, we better stay AWAKE
+                    //  5. otherwise, put PHY back to sleep to save battery.
+                    if (MessageToMe)
+                    {
+                        DBGPRINT_RAW(RT_DEBUG_TRACE, "SYNC - AP backlog unicast-to-me, stay AWAKE, send PSPOLL\n");
+                        EnqueuePsPoll(pAd);
+                    }
+                    else if (BcastFlag && (DtimCount == 0) && pAd->PortCfg.RecvDtim)
+                    {
+                        DBGPRINT_RAW(RT_DEBUG_TRACE, "SYNC - AP backlog broadcast/multicast, stay AWAKE\n");
+                    }
+                    else
+                    {
+                        USHORT temp;
+                        RTUSBSingleRead(pAd, 0x320, &temp);
+                        if (pAd->BulkOutPending ||
+                            (!LOCAL_TX_RING_EMPTY(pAd)) ||
+                            (pAd->PrioRingTxCnt != 0) ||
+                            // (pAd->PsPollContext.Ready == TRUE) ||
+                            (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) ||
+                            (!(temp & 0x80)))
+                        {
+//                          DBGPRINT_RAW(RT_DEBUG_TRACE, ("SYNC - outgoing frame in TxRing/PrioRing, stay AWAKE\n"));
+                            if (pAd->BulkOutPending)
+                                DBGPRINT_RAW(RT_DEBUG_TRACE, "Bulk Out Pending\n");
+                            if (!LOCAL_TX_RING_EMPTY(pAd))
+                                DBGPRINT_RAW(RT_DEBUG_TRACE, "Data Queue Non-empty\n");
+                            if (pAd->PrioRingTxCnt != 0)
+                                DBGPRINT_RAW(RT_DEBUG_TRACE, "MLME Queue Non-empty\n");
+                            if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+                                DBGPRINT_RAW(RT_DEBUG_TRACE, "Scan In Progress\n");
+                            if (!(temp & 0x80))
+                                DBGPRINT_RAW(RT_DEBUG_TRACE, "Device Queue Non-empty\n");
+                            DBGPRINT_RAW(RT_DEBUG_TRACE, "Stay AWAKE\n");
+                        }
+                        else
+                        {
+                            USHORT NextDtim = DtimCount;
+                            if (NextDtim == 0)
+                                NextDtim = DtimPeriod;
+                            
+                            TbttNumToNextWakeUp = pAd->PortCfg.DefaultListenCount;
+                            if (pAd->PortCfg.RecvDtim && (TbttNumToNextWakeUp > NextDtim))
+                                TbttNumToNextWakeUp = NextDtim;
+                            
+                            DBGPRINT_RAW(RT_DEBUG_TRACE, "SYNC - PHY sleeps for %d Tbcn\n", TbttNumToNextWakeUp);
+                            AsicSleepThenAutoWakeup(pAd, TbttNumToNextWakeUp);
+                        }
+                    }
+                }
+                else
+                {
+                    ULONG   PowerMode;
+                        PowerMode = pAd->PortCfg.WindowsPowerMode;
+                    
+                    if ((PowerMode != Ndis802_11PowerModeCAM) &&
+                        (pAd->BulkOutPending == FALSE) &&
+                        (!LOCAL_TX_RING_EMPTY(pAd)) &&
+//                      (pAd->MLMEQ.size == 0) &&
+//                      (pAd->PsPollContext.Ready != TRUE) &&
+                        (skb_queue_empty(&pAd->SendTxWaitQueue)) &&
+//                      (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) &&
+                        (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE))
+                    {
+                        MlmeSetPsmBit(pAd, PWR_SAVE);
+                        EnqueueNullFrame(pAd, pAd->PortCfg.TxRate);
+                    }
+                }               
+            }
+            
+            // At least another peer in this IBSS, declare MediaState as CONNECTED
+            if (ADHOC_ON(pAd) && (pAd->MediaState == NdisMediaStateDisconnected))
+            {
+                pAd->BeaconIntervalChangeAllowed = TRUE;
+                pAd->SentBeaconsCount = 0;
+                pAd->ReceivedBeaconsCount = 0;
+                pAd->MediaState = NdisMediaStateConnected;
+                NdisMIndicateStatus(pAd->AdapterHandle, NDIS_STATUS_MEDIA_CONNECT, (PVOID)NULL, 0);
+                NdisMIndicateStatusComplete(pAd->AdapterHandle);
+
+                // 2003/03/12 - john
+                // Make sure this entry in "PortCfg.BssTab" table, thus complies to Microsoft's policy that
+                // "site survey" result should always include the current connected network. 
+                //
+                Bssidx = BssTableSearch(&pAd->PortCfg.BssTab, &Bssid);
+                if (Bssidx == BSS_NOT_FOUND)
+                {
+                    Bssidx = BssTableSetEntry(pAd, &pAd->PortCfg.BssTab, &Bssid, Ssid, SsidLen, 
+                                BssType, BeaconPeriod, CfExist, &CfParm, AtimWin, CapabilityInfo, 
+                                Rates, RatesLen, ExtendedRateIeExist, Channel, Elem->Rssi, TimeStamp, LenVIE, pVIE);
+                }
+            }
+        }
+        // not my BSSID, ignore it
+    }
+    // sanity check fail, ignore this frame
+    else
+                    DBGPRINT(RT_DEBUG_TRACE, " sanity check fail peerBEACON \n");
+
+}
+
+/* 
+    ==========================================================================
+    Description:
+        Receive PROBE REQ from remote peer when operating in IBSS mode
+    ==========================================================================
+ */
+VOID PeerProbeReqAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    MACADDR       Addr2;
+    CHAR          Ssid[MAX_LEN_OF_SSID];
+    UCHAR         SsidLen;
+    MACHDR        ProbeRspHdr;
+    NDIS_STATUS   NStatus;
+    UCHAR         *OutBuffer = NULL;
+    ULONG         FrameLen = 0;
+    LARGE_INTEGER FakeTimestamp;
+    UCHAR         SsidIe = IE_SSID, DsIe = IE_DS_PARM, IbssIe = IE_IBSS_PARM, SuppIe = IE_SUPP_RATES, 
+                  DsLen = 1, IbssLen = 2;
+    UCHAR         SupportedRatesLen;
+    UCHAR         SupportedRates[MAX_LEN_OF_SUPPORTED_RATES];
+    UCHAR         ExtRateIe = IE_EXT_SUPP_RATES, ExtRatesLen;
+    UCHAR         ErpIe[3] = {IE_ERP, 1, 0};
+    
+    if (! ADHOC_ON(pAd))
+        return;
+
+    if (PeerProbeReqSanity(pAd, Elem->Msg, Elem->MsgLen, &Addr2, Ssid, &SsidLen)) //, Rates, &RatesLen))
+    {
+        if ((SsidLen == 0) || (memcmp(Ssid, pAd->PortCfg.Ssid, (ULONG) SsidLen) == 0))
+        {
+            // 2003-12-10 802.11g WIFI spec disallow OFDM rates in 802.11g ADHOC mode
+            //            make sure 1,2,5.5,11 are the firt 4 rates in PortCfg.SupportedRates[] array
+            if ((pAd->PortCfg.PhyMode == PHY_11BG_MIXED) && (pAd->PortCfg.AdhocMode == 0))
+            {
+                int i;
+                SupportedRatesLen=0;
+                for (i=0;i<pAd->PortCfg.SupportedRatesLen;i++)
+                {
+                    switch (pAd->PortCfg.SupportedRates[i] & 0x7f)
+                    {
+                        case 2:
+                        case 4:
+                        case 11:
+                        case 22:
+                            SupportedRates[SupportedRatesLen] = pAd->PortCfg.SupportedRates[i];
+                            SupportedRatesLen ++;
+                            break;
+                        default:
+                            break;
+                    }
+                }
+                // error handling - should never happen
+                if (SupportedRatesLen != 4)
+                {
+                    SupportedRatesLen = 4;
+                    SupportedRates[0] = 0x82;
+                    SupportedRates[1] = 0x84;
+                    SupportedRates[2] = 0x8b;
+                    SupportedRates[3] = 0x96;
+                }
+            }
+            else
+            {
+                SupportedRatesLen = pAd->PortCfg.SupportedRatesLen;
+                memcpy(SupportedRates, pAd->PortCfg.SupportedRates, SupportedRatesLen);
+            }
+
+            // allocate and send out ProbeRsp frame
+            NStatus = MlmeAllocateMemory(pAd, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+            if (NStatus != NDIS_STATUS_SUCCESS)
+                return;
+            
+            pAd->PortCfg.AtimWin = 0;  // ??????
+            DBGPRINT(RT_DEBUG_TRACE, "SYNC - Send PROBE_RSP to %02x:%02x:%02x:%02x:%02x:%02x...\n", 
+                Addr2.Octet[0],Addr2.Octet[1],Addr2.Octet[2],Addr2.Octet[3],Addr2.Octet[4],Addr2.Octet[5] );
+            MgtMacHeaderInit(pAd, &ProbeRspHdr, SUBTYPE_PROBE_RSP, 0, &Addr2, &pAd->PortCfg.Bssid);
+
+            if (SupportedRatesLen <= 8)
+            {
+                MakeOutgoingFrame(OutBuffer,                        &FrameLen, 
+                              MAC_HDR_LEN,                      &ProbeRspHdr, 
+                              TIMESTAMP_LEN,                    &FakeTimestamp,
+                              2,                                &pAd->PortCfg.BeaconPeriod,
+                              2,                                &pAd->PortCfg.CapabilityInfo,
+                              1,                                &SsidIe, 
+                              1,                                &pAd->PortCfg.SsidLen, 
+                              pAd->PortCfg.SsidLen,             pAd->PortCfg.Ssid,
+                              1,                                &SuppIe, 
+                              1,                                &SupportedRatesLen,
+                              SupportedRatesLen,                SupportedRates, 
+                              1,                                &DsIe, 
+                              1,                                &DsLen, 
+                              1,                                &pAd->PortCfg.Channel,
+                              1,                                &IbssIe, 
+                              1,                                &IbssLen, 
+                              2,                                &pAd->PortCfg.AtimWin,
+                              END_OF_ARGS);
+            }
+            else
+            {
+                ExtRatesLen = SupportedRatesLen - 8;
+                SupportedRatesLen = 8;
+                MakeOutgoingFrame(OutBuffer,                        &FrameLen, 
+                              MAC_HDR_LEN,                      &ProbeRspHdr, 
+                              TIMESTAMP_LEN,                    &FakeTimestamp,
+                              2,                                &pAd->PortCfg.BeaconPeriod,
+                              2,                                &pAd->PortCfg.CapabilityInfo,
+                              1,                                &SsidIe, 
+                              1,                                &pAd->PortCfg.SsidLen, 
+                              pAd->PortCfg.SsidLen,             pAd->PortCfg.Ssid,
+                              1,                                &SuppIe, 
+                              1,                                &SupportedRatesLen,
+                              SupportedRatesLen,                SupportedRates, 
+                              1,                                &DsIe, 
+                              1,                                &DsLen, 
+                              1,                                &pAd->PortCfg.Channel,
+                              1,                                &IbssIe, 
+                              1,                                &IbssLen, 
+                              2,                                &pAd->PortCfg.AtimWin,
+                              3,                                ErpIe,
+                              1,                                &ExtRateIe,
+                              1,                                &ExtRatesLen,
+                              ExtRatesLen,                      &SupportedRates[SupportedRatesLen],
+                              END_OF_ARGS);
+            }
+            // If adhoc secruity is set for WPA-None, append the cipher suite IE
+            if (pAd->PortCfg.AuthMode == Ndis802_11AuthModeWPANone)
+            {
+                ULONG   tmp;
+                UCHAR   WpaIe = IE_WPA;
+                
+                if (pAd->PortCfg.WepStatus == Ndis802_11Encryption2Enabled)     // Tkip
+                {
+                    MakeOutgoingFrame(OutBuffer + FrameLen,         &tmp,
+                            1,                         &WpaIe,
+                            1,                          &CipherSuiteWpaNoneTkipLen,
+                            CipherSuiteWpaNoneTkipLen,  &CipherSuiteWpaNoneTkip[0],
+                            END_OF_ARGS);
+                    FrameLen += tmp;
+                }
+                else if (pAd->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)    // Aes
+                {
+                    MakeOutgoingFrame(OutBuffer + FrameLen,         &tmp,
+                            1,                         &WpaIe,
+                            1,                          &CipherSuiteWpaNoneAesLen,
+                            CipherSuiteWpaNoneAesLen,   &CipherSuiteWpaNoneAes[0],
+                            END_OF_ARGS);
+                    FrameLen += tmp;
+                }
+            }
+            
+            MiniportMMRequest(pAd, OutBuffer, FrameLen);
+        }
+    }
+}
+
+VOID BeaconTimeoutAtJoinAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    DBGPRINT(RT_DEBUG_TRACE, "SYNC - BeaconTimeoutAtJoinAction\n");
+    pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+    MlmeCntlConfirm(pAd, MT2_JOIN_CONF, MLME_REJ_TIMEOUT);
+}
+
+/* 
+    ==========================================================================
+    Description:
+        Scan timeout procedure. basically add channel index by 1 and rescan
+    ==========================================================================
+ */
+VOID ScanTimeoutAction(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    if (pAd->Mlme.SyncMachine.CurrState == SCAN_LISTEN)//MLME could have been reset. Make sure this is not the case before going on. 
+    {
+        pAd->Mlme.SyncAux.Channel = NextChannel(pAd, pAd->Mlme.SyncAux.Channel);
+        ScanNextChannel(pAd);
+    }
+}
+
+/* 
+    ==========================================================================
+    Description:
+        Scan next channel
+    ==========================================================================
+ */
+VOID ScanNextChannel(
+    IN PRT2570ADAPTER pAd) 
+{
+	MACHDR          Hdr;
+	UCHAR           SsidIe = IE_SSID, SuppRateIe = IE_SUPP_RATES;
+	VOID           *OutBuffer = NULL;
+	VOID           *OutBuffer2 = NULL;
+	NDIS_STATUS     NStatus;
+	ULONG           FrameLen = 0;
+	UCHAR           SsidLen = 0;
+	int		i=0;
+
+	if ((pAd->Mlme.SyncAux.Channel == 0) ) 
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "SYNC - End of SCAN, restore to channel %d, find %d BSS\n",pAd->PortCfg.Channel, pAd->PortCfg.BssTab.BssNr);
+
+		for (i=0;i<pAd->PortCfg.BssTab.BssNr;i++) {
+			DBGPRINT(RT_DEBUG_TRACE, "BSS%d: %s\n", i, pAd->PortCfg.BssTab.BssEntry[i].Ssid);
+		}
+
+		AsicSwitchChannel(pAd, pAd->PortCfg.Channel);
+		AsicLockChannel(pAd, pAd->PortCfg.Channel);
+
+		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+		MlmeCntlConfirm(pAd, MT2_SCAN_CONF, MLME_SUCCESS);
+	}
+	else if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS))
+	{
+		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+		MlmeCntlConfirm(pAd, MT2_SCAN_CONF, MLME_FAIL_NO_RESOURCE);
+	}
+	else 
+	{
+		AsicSwitchChannel(pAd, pAd->Mlme.SyncAux.Channel);
+		AsicLockChannel(pAd, pAd->Mlme.SyncAux.Channel);
+
+        // Total SCAN time still limits within 3 sec (DDK constraint). 
+        // TODO: We need more intelligent rules here to further improve out-of-service issue.
+        // e.g. temporary stop copying NDIS packet to TxRing until SCAN complete
+
+        // We need to shorten active scan time in order for WZC connect issue
+        if (pAd->Mlme.SyncAux.ScanType == SCAN_ACTIVE) 
+        {
+		RTMPSetTimer(pAd, &pAd->Mlme.SyncAux.ScanTimer, ACTIVE_SCAN_TIME); 
+        }
+        else if (pAd->PortCfg.PhyMode == PHY_11ABG_MIXED)
+        {
+		RTMPSetTimer(pAd, &pAd->Mlme.SyncAux.ScanTimer, MIN_CHANNEL_TIME); 
+        }
+        else
+    	{
+		RTMPSetTimer(pAd, &pAd->Mlme.SyncAux.ScanTimer, MAX_CHANNEL_TIME); 
+    	}
+		
+        MgtMacHeaderInit(pAd, &Hdr, SUBTYPE_PROBE_REQ, 0, &pAd->PortCfg.Broadcast, &pAd->PortCfg.Broadcast);
+        // There is no need to send broadcast probe request if active scan is in effect.
+        // The same rulr should apply to passive scan also.
+        if (pAd->Mlme.SyncAux.ScanType == SCAN_PASSIVE) 
+        {
+            // Send the first probe request with empty SSID
+            NStatus = MlmeAllocateMemory(pAd, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+            if (NStatus != NDIS_STATUS_SUCCESS)
+            {
+                DBGPRINT(RT_DEBUG_TRACE, "SYNC - ScanNextChannel() allocate memory fail\n");
+                pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+                MlmeCntlConfirm(pAd, MT2_SCAN_CONF, MLME_FAIL_NO_RESOURCE);
+                return;
+            }
+            
+            DBGPRINT(RT_DEBUG_INFO, "SYNC - send passive ProbeReq @ channel=%d...\n", pAd->Mlme.SyncAux.Channel);
+            SsidLen = 0;
+            MakeOutgoingFrame(OutBuffer,    &FrameLen,
+                          sizeof(MACHDR),   (UCHAR*)&Hdr,
+                          1,                &SsidIe,
+                          1,                &SsidLen,  
+                          1,                &SuppRateIe,
+                          1,                &pAd->PortCfg.SupportedRatesLen,
+                          pAd->PortCfg.SupportedRatesLen, pAd->PortCfg.SupportedRates, 
+                          END_OF_ARGS);
+            MiniportMMRequest(pAd, OutBuffer, FrameLen);
+        }
+        else if (pAd->Mlme.SyncAux.ScanType == SCAN_ACTIVE) 
+        {
+            // Allocate another for probe scan with SSID
+            NStatus = MlmeAllocateMemory(pAd, (PVOID)&OutBuffer2);  //Get an unused nonpaged memory
+            if (NStatus != NDIS_STATUS_SUCCESS)
+            {
+                DBGPRINT(RT_DEBUG_TRACE, "SYNC - ScanNextChannel() allocate memory fail\n");
+                pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+                MlmeCntlConfirm(pAd, MT2_SCAN_CONF, MLME_FAIL_NO_RESOURCE);
+                return;
+            }
+            // make another probe scan with SSID from mlme.cntlaux.ssid
+            SsidLen = pAd->PortCfg.SsidLen;
+            MakeOutgoingFrame(OutBuffer2,       &FrameLen,
+                              sizeof(MACHDR),   &Hdr,
+                              1,                &SsidIe,
+                              1,                &SsidLen,
+                              SsidLen,          pAd->PortCfg.Ssid,
+                              1,                &SuppRateIe,
+                              1,                &pAd->PortCfg.SupportedRatesLen,
+                              pAd->PortCfg.SupportedRatesLen, pAd->PortCfg.SupportedRates, 
+                              END_OF_ARGS);
+            MiniportMMRequest(pAd, OutBuffer2, FrameLen);
+
+            DBGPRINT(RT_DEBUG_INFO, "SYNC - send active ProbeReq @ channel=%d with essid=%s\n", pAd->Mlme.SyncAux.Channel, pAd->PortCfg.Ssid);
+        }
+
+        pAd->Mlme.SyncMachine.CurrState = SCAN_LISTEN;
+    }
+}
+
+/* 
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+VOID InvalidStateWhenScan(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    DBGPRINT(RT_DEBUG_TRACE, "AYNC - InvalidStateWhenScan(state=%d). Reset SYNC machine\n", pAd->Mlme.SyncMachine.CurrState);
+    pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+    MlmeCntlConfirm(pAd, MT2_SCAN_CONF, MLME_STATE_MACHINE_REJECT);
+}
+
+/* 
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+VOID InvalidStateWhenJoin(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    DBGPRINT(RT_DEBUG_TRACE, "InvalidStateWhenJoin(state=%d). Reset SYNC machine\n", pAd->Mlme.SyncMachine.CurrState);
+    pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+    MlmeCntlConfirm(pAd, MT2_JOIN_CONF, MLME_STATE_MACHINE_REJECT);
+}
+
+/* 
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+VOID InvalidStateWhenStart(
+    IN PRT2570ADAPTER pAd, 
+    IN MLME_QUEUE_ELEM *Elem) 
+{
+    DBGPRINT(RT_DEBUG_TRACE, "InvalidStateWhenStart(state=%d). Reset SYNC machine\n", pAd->Mlme.SyncMachine.CurrState);
+    pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+    MlmeCntlConfirm(pAd, MT2_START_CONF, MLME_STATE_MACHINE_REJECT);
+}
+
+/* 
+    ==========================================================================
+    Description:
+    ==========================================================================
+ */
+VOID EnqueuePsPoll(
+    IN PRT2570ADAPTER pAdapter) 
+{
+	PTX_CONTEXT pPsPollContext;
+	PSPOLL_FRAME	*pPsPollFrame;
+	
+	if ((RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) ||
+	    (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET)) ||
+	    (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)))
+	{
+		return;
+	}
+    
+	pPsPollContext = &(pAdapter->PsPollContext);
+	pPsPollFrame = (PSPOLL_FRAME*)pAdapter->PsPollContext.TransferBuffer->WirelessPacket;
+	if (pPsPollContext->InUse == FALSE)
+	{
+		PTXD_STRUC  pTxD;
+		    
+		pPsPollContext->InUse = TRUE;
+
+		pTxD  = &(pPsPollContext->TransferBuffer->TxDesc);
+		memset(pTxD, 0, sizeof(TXD_STRUC));
+		RTUSBWriteTxDescriptor(pTxD, FALSE, 0, FALSE, FALSE, TRUE, IFS_BACKOFF,
+		    sizeof(PSPOLL_FRAME), FALSE, 0, CW_MIN_IN_BITS, CW_MAX_IN_BITS,
+		    sizeof(PSPOLL_FRAME) + 4, pAdapter->PortCfg.MlmeRate, 4,
+		    pAdapter->PortCfg.TxPreambleInUsed);
+
+		pPsPollFrame->PwrMgmt = 0;
+
+		// Fill out frame length information for global Bulk out arbitor
+		pPsPollContext->BulkOutSize = sizeof(PS_POLL_BUFFER);
+		RTUSB_SET_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_PSPOLL);
+
+		// Kick bulk out 
+		RTUSBKickBulkOut(pAdapter);
+	}
+}
+
+/* 
+    ==========================================================================
+    Description:
+        Send out a NULL frame to AP. The prpose is to inform AP this client 
+        current PSM bit.
+    NOTE:
+        This routine should only be used in infrastructure mode.
+    ==========================================================================
+ */
+VOID    EnqueueNullFrame(
+    IN  PRT2570ADAPTER  pAdapter,
+    IN  UCHAR           TxRate) 
+{
+	PTX_CONTEXT pNullContext;
+	PTXD_STRUC      pTxD;
+	HEADER_802_11	*pNullFrame;
+
+	if ((RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_RESET_IN_PROGRESS)) ||
+	    (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_BULKOUT_RESET)) ||
+	    (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_HALT_IN_PROGRESS)) ||
+	    (RTMP_TEST_FLAG(pAdapter, fRTMP_ADAPTER_REMOVE_IN_PROGRESS)))
+	{
+		return;
+	}
+    
+	// WPA 802.1x secured port control
+	if (((pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPA) || 
+	    (pAdapter->PortCfg.AuthMode == Ndis802_11AuthModeWPAPSK)) &&
+	    (pAdapter->PortCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
+	{
+		return;
+	}
+	pNullFrame = (HEADER_802_11*)pAdapter->NullContext.TransferBuffer->WirelessPacket;
+	pNullContext = &(pAdapter->NullContext);
+	if (pNullContext->InUse == FALSE)
+	{
+		// Set the in use bit
+		pNullContext->InUse = TRUE;
+
+		// Fill Null frame body and TxD
+		pTxD  = &(pNullContext->TransferBuffer->TxDesc);
+		memset(pTxD, 0, sizeof(TXD_STRUC));
+		RTUSBWriteTxDescriptor(pTxD, FALSE, 7, TRUE, FALSE, TRUE, IFS_BACKOFF, sizeof(MACHDR), FALSE, 0, CW_MIN_IN_BITS, CW_MAX_IN_BITS, sizeof(MACHDR) + 4, TxRate, 4, pAdapter->PortCfg.TxPreambleInUsed);
+		pNullFrame->Controlhead.Duration = RTUSBCalcDuration(pAdapter, TxRate, 14);
+		pNullFrame->Controlhead.Frame.PwrMgt = (pAdapter->PortCfg.Psm == PWR_SAVE);     
+		DBGPRINT(RT_DEBUG_TRACE, "SYNC - send NULL Frame @%d Mbps...\n", RateIdToMbps[TxRate]);
+
+		// Fill out frame length information for global Bulk out arbitor
+		pNullContext->BulkOutSize = sizeof(TXD_STRUC) + sizeof(HEADER_802_11);
+		RTUSB_SET_BULK_FLAG(pAdapter, fRTUSB_BULK_OUT_DATA_NULL);
+
+		// Kick bulk out 
+		RTUSBKickBulkOut(pAdapter);
+	}
+}
+
+/* 
+    ==========================================================================
+    Description:
+        Update PortCfg->ChannelList[] according to 1) Country Region 2) RF IC type,
+        and 3) PHY-mode user selected.
+        The outcome is used by driver when doing site survey.
+    ==========================================================================
+ */
+VOID BuildChannelList(
+    IN PRT2570ADAPTER pAd)
+{
+    UCHAR i,  index = 0;
+    memset(pAd->PortCfg.ChannelList, 0, MAX_LEN_OF_CHANNELS);
+
+    // if not 11a-only mode, channel list starts from 2.4Ghz band
+    if (pAd->PortCfg.PhyMode != PHY_11A)
+    {
+        switch (pAd->PortCfg.CountryRegion)
+        {
+            case REGION_FCC:    // 1 - 11
+                memcpy(&pAd->PortCfg.ChannelList[index], Ra24Ghz_FCC, sizeof(Ra24Ghz_FCC));
+                index += sizeof(Ra24Ghz_FCC);
+                break;
+            case REGION_IC:     // 1 -11
+                memcpy(&pAd->PortCfg.ChannelList[index], Ra24Ghz_IC, sizeof(Ra24Ghz_IC));
+                index += sizeof(Ra24Ghz_IC);
+                break;
+            case REGION_ISRAEL:  // 3 - 9
+                memcpy(&pAd->PortCfg.ChannelList[index], Ra24Ghz_ISRAEL, sizeof(Ra24Ghz_ISRAEL));
+                index += sizeof(Ra24Ghz_ISRAEL);
+                break;
+            case REGION_ETSI:   // 1 - 13
+                memcpy(&pAd->PortCfg.ChannelList[index], Ra24Ghz_ESTI, sizeof(Ra24Ghz_ESTI));
+                index += sizeof(Ra24Ghz_ESTI);
+                break;
+            case REGION_SPAIN:  // 10 - 11
+                memcpy(&pAd->PortCfg.ChannelList[index], Ra24Ghz_SPAIN, sizeof(Ra24Ghz_SPAIN));
+                index += sizeof(Ra24Ghz_SPAIN);
+                break;
+            case REGION_FRANCE: // 10 -13
+                memcpy(&pAd->PortCfg.ChannelList[index], Ra24Ghz_FRANCE, sizeof(Ra24Ghz_FRANCE));
+                index += sizeof(Ra24Ghz_FRANCE);
+                break;
+            case REGION_MKK:    // 14
+                memcpy(&pAd->PortCfg.ChannelList[index], Ra24Ghz_MKK, sizeof(Ra24Ghz_MKK));
+                index += sizeof(Ra24Ghz_MKK);
+                break;
+            case REGION_MKK1:   // 1 - 14
+                memcpy(&pAd->PortCfg.ChannelList[index], Ra24Ghz_MKK1, sizeof(Ra24Ghz_MKK1));
+                index += sizeof(Ra24Ghz_MKK1);
+                break;
+            default:            // Error. should never happen
+                break;
+        }   
+    }
+
+    if ((pAd->PortCfg.PhyMode == PHY_11A) || (pAd->PortCfg.PhyMode == PHY_11ABG_MIXED))
+    {
+        // 2003-10-05 john - use UNII temoparaily for all regulation domains for easy test untill
+        // RF guys confirm the supported channel plans
+        memcpy(&pAd->PortCfg.ChannelList[index], Ra5Ghz_UNII, sizeof(Ra5Ghz_UNII));
+        index += sizeof(Ra5Ghz_UNII);
+    }
+
+    pAd->PortCfg.ChannelListNum = index;
+    
+    DBGPRINT(RT_DEBUG_TRACE,"country code=%d, RFIC=%d, PHY mode=%d, support %d channels\n", 
+        pAd->PortCfg.CountryRegion, pAd->PortCfg.RfType, pAd->PortCfg.PhyMode, pAd->PortCfg.ChannelListNum);
+    for (i=0;i<index;i++)
+    {
+        DBGPRINT_RAW(RT_DEBUG_INFO,"channel #%d\n", pAd->PortCfg.ChannelList[i]);
+    }
+}
+
+/* 
+    ==========================================================================
+    Description:
+        This routine return the first channel number according to the country 
+        code selection and RF IC selection (signal band or dual band). It is called
+        whenever driver need to start a site survey of all supported channels.
+    Return:
+        ch - the first channel number of current country code setting
+    ==========================================================================
+ */
+UCHAR FirstChannel(
+    IN PRT2570ADAPTER pAd)
+{
+    return pAd->PortCfg.ChannelList[0];
+}
+
+/* 
+    ==========================================================================
+    Description:
+        This routine returns the next channel number. This routine is called
+        during driver need to start a site survey of all supported channels.
+    Return:
+        next_channel - the next channel number valid in current country code setting.
+    Note:
+        return 0 if no more next channel
+    ==========================================================================
+ */
+UCHAR NextChannel(
+    IN PRT2570ADAPTER pAd, 
+    IN UCHAR channel)
+{
+    int i;
+    UCHAR next_channel = 0;
+            
+    for (i = 0; i < (pAd->PortCfg.ChannelListNum - 1); i++)
+        if (channel == pAd->PortCfg.ChannelList[i])
+        {
+            next_channel = pAd->PortCfg.ChannelList[i+1];
+            break;
+    }   
+    return next_channel;
+}
+
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/wpa.c linux-2.4.35.3-mct/drivers/usb/rt2570/wpa.c
--- linux-2.4.35.3/drivers/usb/rt2570/wpa.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/wpa.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,1347 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	wpa.c
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#include "rt_config.h"
+
+UCHAR   CipherWpaPskTkip[] = {
+        0xDD, 0x16,             // RSN IE
+        0x00, 0x50, 0xf2, 0x01, // oui
+        0x01, 0x00,             // Version
+        0x00, 0x50, 0xf2, 0x02, // Multicast
+        0x01, 0x00,             // Number of unicast
+        0x00, 0x50, 0xf2, 0x02, // unicast
+        0x01, 0x00,             // number of authentication method
+        0x00, 0x50, 0xf2, 0x02  // authentication
+        };
+UCHAR   CipherWpaPskTkipLen = (sizeof(CipherWpaPskTkip) / sizeof(UCHAR));
+
+UCHAR   CipherWpaPskAes[] = {
+        0xDD, 0x16,             // RSN IE
+        0x00, 0x50, 0xf2, 0x01, // oui
+        0x01, 0x00,             // Version
+        0x00, 0x50, 0xf2, 0x04, // Multicast
+        0x01, 0x00,             // Number of unicast
+        0x00, 0x50, 0xf2, 0x04, // unicast
+        0x01, 0x00,             // number of authentication method
+        0x00, 0x50, 0xf2, 0x02  // authentication
+        };
+UCHAR   CipherWpaPskAesLen = (sizeof(CipherWpaPskAes) / sizeof(UCHAR));
+
+/*
+    ========================================================================
+    
+    Routine Description:
+        Classify WPA EAP message type
+
+    Arguments:
+        EAPType     Value of EAP message type
+        MsgType     Internal Message definition for MLME state machine
+        
+    Return Value:
+        TRUE        Found appropriate message type
+        FALSE       No appropriate message type
+
+    Note:
+        All these constants are defined in wpa.h
+        For supplicant, there is only EAPOL Key message avaliable
+        
+    ========================================================================
+*/
+BOOLEAN WpaMsgTypeSubst(
+    IN  UCHAR   EAPType,
+    OUT ULONG   *MsgType)   
+{
+    switch (EAPType)
+    {
+        case EAPPacket:
+            *MsgType = EAP_MSG_TYPE_EAPPacket;
+            break;
+        case EAPOLStart:
+            *MsgType = EAP_MSG_TYPE_EAPOLStart;
+            break;
+        case EAPOLLogoff:
+            *MsgType = EAP_MSG_TYPE_EAPOLLogoff;
+            break;
+        case EAPOLKey:
+            *MsgType = EAP_MSG_TYPE_EAPOLKey;
+            break;
+        case EAPOLASFAlert:
+            *MsgType = EAP_MSG_TYPE_EAPOLASFAlert;
+            break;
+        default:
+            DBGPRINT(RT_DEBUG_ERROR, "WpaMsgTypeSubst : return FALSE; \n");
+            return FALSE;       
+    }   
+    return TRUE;
+}
+
+/*  
+    ==========================================================================
+    Description: 
+        association state machine init, including state transition and timer init
+    Parameters: 
+        S - pointer to the association state machine
+    ==========================================================================
+ */
+VOID WpaPskStateMachineInit(
+    IN  PRT2570ADAPTER   pAd, 
+    IN  STATE_MACHINE *S, 
+    OUT STATE_MACHINE_FUNC Trans[]) 
+{
+    StateMachineInit(S, (STATE_MACHINE_FUNC*)Trans, MAX_WPA_PSK_STATE, MAX_WPA_PSK_MSG, (STATE_MACHINE_FUNC)Drop, WPA_PSK_IDLE, WPA_MACHINE_BASE);
+    StateMachineSetAction(S, WPA_PSK_IDLE, EAP_MSG_TYPE_EAPOLKey, (STATE_MACHINE_FUNC)WpaEAPOLKeyAction);
+}
+
+/*
+    ==========================================================================
+    Description:
+        This is state machine function. 
+        When receiving EAPOL packets which is  for 802.1x key management. 
+        Use both in WPA, and WPAPSK case. 
+        In this function, further dispatch to different functions according to the received packet.  3 categories are : 
+          1.  normal 4-way pairwisekey and 2-way groupkey handshake
+          2.  MIC error (Countermeasures attack)  report packet from STA.
+          3.  Request for pairwise/group key update from STA
+    Return:
+    ==========================================================================
+*/
+VOID WpaEAPOLKeyAction(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem) 
+{
+    INT             MsgType;
+    PKEY_DESCRIPTER pKeyDesc;
+    PHEADER_802_11 pHeader; //red
+    
+    DBGPRINT(RT_DEBUG_TRACE, "-----> WpaEAPOLKeyAction\n");
+
+    pHeader	= (PHEADER_802_11) &Elem->Msg[0];//red
+	
+    // Get 802.11 header first
+    if( (pAdapter->PortCfg.CipherAlg == CIPHER_TKIP || pAdapter->PortCfg.CipherAlg == CIPHER_AES) && pHeader->Controlhead.Frame.Wep)
+	    pKeyDesc = (PKEY_DESCRIPTER) &Elem->Msg[(LENGTH_802_11 + LENGTH_802_1_H + 8 + LENGTH_EAPOL_H)];
+    else	
+	   pKeyDesc = (PKEY_DESCRIPTER) &Elem->Msg[(LENGTH_802_11 + LENGTH_802_1_H + LENGTH_EAPOL_H)];
+    // Sanity check, this should only happen in WPA-PSK mode
+    if (pAdapter->PortCfg.AuthMode != Ndis802_11AuthModeWPAPSK)
+        return;
+
+    // 0. Debug print all bit information
+    DBGPRINT(RT_DEBUG_INFO, "KeyInfo Key Description Version %d\n", pKeyDesc->KeyInfo.KeyDescVer);
+    DBGPRINT(RT_DEBUG_INFO, "KeyInfo Key Type %d\n", pKeyDesc->KeyInfo.KeyType);
+    DBGPRINT(RT_DEBUG_INFO, "KeyInfo Key Index %d\n", pKeyDesc->KeyInfo.KeyIndex);
+    DBGPRINT(RT_DEBUG_INFO, "KeyInfo Install %d\n", pKeyDesc->KeyInfo.Install);
+    DBGPRINT(RT_DEBUG_INFO, "KeyInfo Key Ack %d\n", pKeyDesc->KeyInfo.KeyAck);
+    DBGPRINT(RT_DEBUG_INFO, "KeyInfo Key MIC %d\n", pKeyDesc->KeyInfo.KeyMic);
+    DBGPRINT(RT_DEBUG_INFO, "KeyInfo Secure %d\n", pKeyDesc->KeyInfo.Secure);
+    DBGPRINT(RT_DEBUG_INFO, "KeyInfo Error %d\n", pKeyDesc->KeyInfo.Error);
+    DBGPRINT(RT_DEBUG_INFO, "KeyInfo Request %d\n", pKeyDesc->KeyInfo.Request);
+    DBGPRINT(RT_DEBUG_INFO, "KeyInfo DL %d\n", pKeyDesc->KeyInfo.DL);
+    
+    // 1. Check EAPOL frame version and type
+    if( (pAdapter->PortCfg.CipherAlg == CIPHER_TKIP || pAdapter->PortCfg.CipherAlg == CIPHER_AES) && pHeader->Controlhead.Frame.Wep)//red
+    {
+    		if ((Elem->Msg[LENGTH_802_11+LENGTH_802_1_H + 8] != EAPOL_VER) || (pKeyDesc->Type != RSN_KEY_DESC))
+		{
+		        DBGPRINT(RT_DEBUG_ERROR, "   Key descripter does not match with WPA rule \n");
+		        return;
+    		}
+    }
+    else
+    {
+    		if ((Elem->Msg[LENGTH_802_11+LENGTH_802_1_H] != EAPOL_VER) || (pKeyDesc->Type != RSN_KEY_DESC))
+    		{
+		        DBGPRINT(RT_DEBUG_ERROR, "   Key descripter does not match with WPA rule \n");
+		        return;
+		}
+    }
+    
+
+    // 2.Check Version for AES & TKIP
+    if ((pAdapter->PortCfg.WepStatus == Ndis802_11Encryption3Enabled) && (pKeyDesc->KeyInfo.KeyDescVer != DESC_TYPE_AES))
+    {
+        DBGPRINT(RT_DEBUG_ERROR, "   Key descripter version not match AES \n");
+        return;
+    }
+    else if ((pAdapter->PortCfg.WepStatus == Ndis802_11Encryption2Enabled) && (pKeyDesc->KeyInfo.KeyDescVer != DESC_TYPE_TKIP))
+    {
+        DBGPRINT(RT_DEBUG_ERROR, "   Key descripter version not match TKIP \n");
+        return;
+    }
+
+    // First validate replay counter, only accept message with larger replay counter
+    if (memcmp(pKeyDesc->ReplayCounter, pAdapter->PortCfg.ReplayCounter, (size_t)LEN_KEY_DESC_REPLAY) <= 0)
+        return;
+
+    // Classify message Type, either pairwise message 1, 3, or group message 1 for supplicant
+    MsgType = EAPOL_MSG_INVALID;
+    if ((pKeyDesc->KeyInfo.KeyType == 1) &&
+        (pKeyDesc->KeyInfo.KeyIndex == 0) &&
+        (pKeyDesc->KeyInfo.KeyAck == 1) &&
+        (pKeyDesc->KeyInfo.KeyMic == 0) &&
+        (pKeyDesc->KeyInfo.Secure == 0) &&
+        (pKeyDesc->KeyInfo.Error == 0) &&
+        (pKeyDesc->KeyInfo.Request == 0))
+    {
+        MsgType = EAPOL_PAIR_MSG_1;
+        DBGPRINT(RT_DEBUG_ERROR, "Receive EAPOL Key Pairwise Message 1\n");
+    }
+    else if ((pKeyDesc->KeyInfo.KeyType == 1) &&
+        (pKeyDesc->KeyInfo.KeyIndex == 0) &&
+        (pKeyDesc->KeyInfo.KeyAck == 1) &&
+        (pKeyDesc->KeyInfo.KeyMic == 1) &&
+        (pKeyDesc->KeyInfo.Secure == 0) &&
+        (pKeyDesc->KeyInfo.Error == 0) &&
+        (pKeyDesc->KeyInfo.Request == 0))
+    {
+        MsgType = EAPOL_PAIR_MSG_3;
+        DBGPRINT(RT_DEBUG_ERROR, "Receive EAPOL Key Pairwise Message 3\n");
+    }
+    else if ((pKeyDesc->KeyInfo.KeyType == 0) &&
+        (pKeyDesc->KeyInfo.KeyIndex != 0) &&
+        (pKeyDesc->KeyInfo.KeyAck == 1) &&
+        (pKeyDesc->KeyInfo.KeyMic == 1) &&
+        (pKeyDesc->KeyInfo.Secure == 1) &&
+        (pKeyDesc->KeyInfo.Error == 0) &&
+        (pKeyDesc->KeyInfo.Request == 0))
+    {
+        MsgType = EAPOL_GROUP_MSG_1;
+        DBGPRINT(RT_DEBUG_ERROR, "Receive EAPOL Key Group Message 1\n");
+    }
+    
+    // We will assume link is up (assoc suceess and port not secured).
+    // All state has to be able to process message from previous state
+    switch (pAdapter->PortCfg.WpaState)
+    {
+        case SS_START:
+            if (MsgType == EAPOL_PAIR_MSG_1)
+            {
+                WpaPairMsg1Action(pAdapter, Elem);
+                pAdapter->PortCfg.WpaState = SS_WAIT_MSG_3;
+            }
+            break;
+                
+        case SS_WAIT_MSG_3:
+            if (MsgType == EAPOL_PAIR_MSG_1)
+            {
+                WpaPairMsg1Action(pAdapter, Elem);
+                pAdapter->PortCfg.WpaState = SS_WAIT_MSG_3;
+            }
+            else if (MsgType == EAPOL_PAIR_MSG_3)
+            {
+                WpaPairMsg3Action(pAdapter, Elem);
+                pAdapter->PortCfg.WpaState = SS_WAIT_GROUP;
+            }
+            break;
+                
+        case SS_WAIT_GROUP:     // When doing group key exchange
+        case SS_FINISH:         // This happened when update group key
+            if (MsgType == EAPOL_PAIR_MSG_1)
+            {
+                WpaPairMsg1Action(pAdapter, Elem);
+                pAdapter->PortCfg.WpaState = SS_WAIT_MSG_3;
+                // Reset port secured variable
+                pAdapter->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+            }
+            else if (MsgType == EAPOL_PAIR_MSG_3)
+            {
+                WpaPairMsg3Action(pAdapter, Elem);
+                pAdapter->PortCfg.WpaState = SS_WAIT_GROUP;
+                // Reset port secured variable
+                pAdapter->PortCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+            }
+            else if (MsgType == EAPOL_GROUP_MSG_1)
+            {
+                WpaGroupMsg1Action(pAdapter, Elem);
+                pAdapter->PortCfg.WpaState = SS_FINISH;
+            }
+            break;
+                
+        default:
+            break;              
+    }
+    
+    DBGPRINT(RT_DEBUG_TRACE, "<----- WpaEAPOLKeyAction\n");
+}
+
+/*
+    ========================================================================
+    
+    Routine Description:
+        Process Pairwise key 4-way handshaking
+
+    Arguments:
+        pAdapter    Pointer to our adapter
+        Elem        Message body
+        
+    Return Value:
+        None
+        
+    Note:
+        
+    ========================================================================
+*/
+VOID    WpaPairMsg1Action(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem) 
+{
+    PHEADER_802_11      pHeader;
+    UCHAR               PTK[80];
+    UCHAR               *OutBuffer = NULL;
+    HEADER_802_11       Header_802_11;
+    NDIS_STATUS         NStatus;
+    UCHAR               AckRate = RATE_2;
+    USHORT              AckDuration = 0;
+     ULONG               FrameLen = 0;
+    UCHAR               EAPHEAD[8] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00,0x88,0x8e};
+    PEAPOL_PACKET       pMsg1;
+    EAPOL_PACKET        Packet;
+    UCHAR               Mic[16];    
+       
+    DBGPRINT(RT_DEBUG_ERROR, "WpaPairMsg1Action ----->\n");
+    
+    pHeader = (PHEADER_802_11) Elem->Msg;
+    
+    // Save Data Length to pDesc for receiving packet, then put in outgoing frame   Data Len fields.
+    pMsg1 = (PEAPOL_PACKET) &Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
+    
+    // Process message 1 from authenticator
+    // Key must be Pairwise key, already verified at callee.
+    // 1. Save Replay counter, it will use to verify message 3 and construct message 2
+    memcpy(pAdapter->PortCfg.ReplayCounter, pMsg1->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+
+    // 2. Save ANonce
+    memcpy(pAdapter->PortCfg.ANonce, pMsg1->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE);
+        
+    // TSNonce <--- SNonce
+    // Generate random SNonce
+    GenRandom(pAdapter, pAdapter->PortCfg.SNonce);  
+
+    // TPTK <--- Calc PTK(ANonce, TSNonce)
+    WpaCountPTK(pAdapter->PortCfg.PskKey.Key,   
+        pAdapter->PortCfg.ANonce,
+        pAdapter->PortCfg.Bssid.Octet, 
+        pAdapter->PortCfg.SNonce, 
+        pAdapter->CurrentAddress,    
+        PTK, 
+        LEN_PTK);   
+
+    // Save key to PTK entry
+    memcpy(pAdapter->PortCfg.PTK, PTK, LEN_PTK);
+    
+    // =====================================
+    // Use Priority Ring & MiniportMMRequest
+    // =====================================
+    pAdapter->Sequence = ((pAdapter->Sequence) + 1) & (MAX_SEQ_NUMBER);
+    WpaMacHeaderInit(pAdapter, &Header_802_11, 0, &pAdapter->PortCfg.Bssid);
+
+    // ACK size is 14 include CRC, and its rate is based on real time information
+    AckRate = pAdapter->PortCfg.ExpectedACKRate[pAdapter->PortCfg.TxRate];
+    AckDuration = RTUSBCalcDuration(pAdapter, AckRate, 14);
+    Header_802_11.Controlhead.Duration = pAdapter->PortCfg.Dsifs + AckDuration;
+    
+    // Zero message 2 body
+    memset(&Packet, 0, sizeof(Packet));
+    Packet.Version = EAPOL_VER;
+    Packet.Type    = EAPOLKey;
+    //
+    // Message 2 as  EAPOL-Key(0,1,0,0,0,P,0,SNonce,MIC,RSN IE)
+    //
+    Packet.KeyDesc.Type = RSN_KEY_DESC;
+    // 1. Key descriptor version and appropriate RSN IE
+    if (pAdapter->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+        Packet.KeyDesc.KeyInfo.KeyDescVer = 2;
+        Packet.KeyDesc.KeyDataLen[1] = CipherWpaPskAesLen;
+        memcpy(Packet.KeyDesc.KeyData, CipherWpaPskAes, CipherWpaPskAesLen);
+    }
+    else    // TKIP
+    {
+        Packet.KeyDesc.KeyInfo.KeyDescVer = 1;
+        Packet.KeyDesc.KeyDataLen[1] = CipherWpaPskTkipLen;
+        memcpy(Packet.KeyDesc.KeyData, CipherWpaPskTkip, CipherWpaPskTkipLen);
+    }
+    // Update packet length after decide Key data payload
+    Packet.Len[1]  = sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE + Packet.KeyDesc.KeyDataLen[1];
+
+    // 2. Key Type PeerKey
+    Packet.KeyDesc.KeyInfo.KeyType = 1;
+
+    // 3. KeyMic field presented
+    Packet.KeyDesc.KeyInfo.KeyMic  = 1;
+
+    // 4. Fill SNonce
+    memcpy(Packet.KeyDesc.KeyNonce, pAdapter->PortCfg.SNonce, LEN_KEY_DESC_NONCE);
+
+    // 5. Key Replay Count
+    memcpy(Packet.KeyDesc.ReplayCounter, pAdapter->PortCfg.ReplayCounter, LEN_KEY_DESC_REPLAY);
+    
+    // Send EAPOL(0, 1, 0, 0, 0, K, 0, TSNonce, 0, MIC(TPTK), 0)
+    // Out buffer for transmitting message 2        
+    NStatus = MlmeAllocateMemory(pAdapter, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS) 
+        return;                 
+
+    // Prepare EAPOL frame for MIC calculation
+    // Be careful, only EAPOL frame is counted for MIC calculation
+
+    MakeOutgoingFrame(OutBuffer, &FrameLen,
+        Packet.Len[1] + 4, &Packet,
+        END_OF_ARGS);
+
+	
+
+    // 5. Prepare and Fill MIC value
+    memset(Mic, 0, sizeof(Mic));
+    if (pAdapter->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+        // AES
+        UCHAR digest[80];
+            
+        HMAC_SHA1(OutBuffer, FrameLen, PTK, LEN_EAP_MICK, digest);
+        memcpy(Mic, digest, LEN_KEY_DESC_MIC);
+    }
+    else
+    {
+        INT i;
+#if 0
+        DBGPRINT_RAW(RT_DEBUG_TRACE, " PMK = ");
+        for (i = 0; i < 16; i++)
+            DBGPRINT_RAW(RT_DEBUG_TRACE, "%2x-", pAdapter->PortCfg.PskKey.Key[i]);
+        
+#endif
+        DBGPRINT_RAW(RT_DEBUG_INFO, "\n PTK = ");
+        for (i = 0; i < 64; i++)
+            DBGPRINT_RAW(RT_DEBUG_INFO, "%2x-", pAdapter->PortCfg.PTK[i]);
+        DBGPRINT_RAW(RT_DEBUG_INFO, "\n FrameLen = %d\n", FrameLen);
+        
+        hmac_md5(PTK,  LEN_EAP_MICK, OutBuffer, FrameLen, Mic);
+    }
+    memcpy(Packet.KeyDesc.KeyMic, Mic, LEN_KEY_DESC_MIC);
+
+    FrameLen = 0;
+    // Make  Transmitting frame
+
+    MakeOutgoingFrame(OutBuffer, &FrameLen, sizeof(MACHDR), &Header_802_11,
+        sizeof(EAPHEAD), EAPHEAD, 
+        Packet.Len[1] + 4, &Packet,
+        END_OF_ARGS);
+
+	
+    // Send using priority queue
+    MiniportMMRequest(pAdapter, OutBuffer, FrameLen);
+        
+    DBGPRINT(RT_DEBUG_TRACE, "WpaPairMsg1Action <-----\n");
+}
+
+/*
+    ========================================================================
+    
+    Routine Description:
+        Process Pairwise key 4-way handshaking
+
+    Arguments:
+        pAdapter    Pointer to our adapter
+        Elem        Message body
+        
+    Return Value:
+        None
+        
+    Note:
+        
+    ========================================================================
+*/
+VOID    WpaPairMsg3Action(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem) 
+{
+    PHEADER_802_11      pHeader;
+    UCHAR               *OutBuffer = NULL;
+    HEADER_802_11       Header_802_11;
+    NDIS_STATUS         NStatus;
+    UCHAR               AckRate = RATE_2;
+    USHORT              AckDuration = 0;
+    ULONG               FrameLen = 0;
+    UCHAR               EAPHEAD[8] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00,0x88,0x8e};
+    EAPOL_PACKET        Packet;
+    PEAPOL_PACKET       pMsg3;
+    PUCHAR              pTmp;
+     UCHAR               Mic[16], OldMic[16];    
+    NDIS_802_11_KEY     PeerKey;
+    
+       
+    DBGPRINT(RT_DEBUG_ERROR, "WpaPairMsg3Action ----->\n");
+    
+    pHeader = (PHEADER_802_11) Elem->Msg;
+    
+    // Process message 3 frame.
+    pMsg3 = (PEAPOL_PACKET) &Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
+
+    // 1. Verify RSN IE & cipher type match
+    if (pAdapter->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+        if (pMsg3->KeyDesc.KeyInfo.KeyDescVer != 2)
+            return;
+        pTmp = (PUCHAR) &CipherWpaPskAes;
+    }
+    else    // TKIP
+    {
+        if (pMsg3->KeyDesc.KeyInfo.KeyDescVer != 1)
+            return;
+         pTmp = (PUCHAR) &CipherWpaPskTkip;
+    }
+
+    // Fix compatibility issue, when AP append nonsense data after auth mode with different size.
+    // We should qualify this kind of RSN as acceptable
+    if (memcmp((PUCHAR) &pMsg3->KeyDesc.KeyData[2], pTmp + 2, CipherWpaPskTkipLen - 2) != 0)
+    {
+        DBGPRINT(RT_DEBUG_ERROR, " RSN IE mismatched msg 3 of 4-way handshake!!!!!!!!!! \n");
+        return;
+    }
+    else
+        DBGPRINT(RT_DEBUG_TRACE, " RSN IE matched in msg 3 of 4-way handshake!!!!!!!!!! \n");
+    
+    // 2. Check MIC value
+    // Save the MIC and replace with zero
+    memcpy(OldMic, pMsg3->KeyDesc.KeyMic, LEN_KEY_DESC_MIC);
+    memset(pMsg3->KeyDesc.KeyMic, 0, LEN_KEY_DESC_MIC);
+    if (pAdapter->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+        // AES
+        UCHAR digest[80];
+            
+        HMAC_SHA1((PUCHAR) pMsg3, pMsg3->Len[1] + 4, pAdapter->PortCfg.PTK, LEN_EAP_MICK, digest);
+        memcpy(Mic, digest, LEN_KEY_DESC_MIC);
+    }
+    else
+    {
+        hmac_md5(pAdapter->PortCfg.PTK, LEN_EAP_MICK, (PUCHAR) pMsg3, pMsg3->Len[1] + 4, Mic);
+    }
+    
+    if (memcmp(OldMic, Mic, LEN_KEY_DESC_MIC) != 0)
+    {
+        DBGPRINT(RT_DEBUG_ERROR, " MIC Different in msg 3 of 4-way handshake!!!!!!!!!! \n");
+        return;
+    }
+    else
+        DBGPRINT(RT_DEBUG_TRACE, " MIC VALID in msg 3 of 4-way handshake!!!!!!!!!! \n");
+
+    // 3. Check Replay Counter, it has to be larger than last one. No need to be exact one larger
+    if (memcmp(pMsg3->KeyDesc.ReplayCounter, pAdapter->PortCfg.ReplayCounter, LEN_KEY_DESC_REPLAY) <= 0)
+        return;
+
+    // Update new replay counter
+    memcpy(pAdapter->PortCfg.ReplayCounter, pMsg3->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+
+    // 4. Double check ANonce
+    if (memcmp(pAdapter->PortCfg.ANonce, pMsg3->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE) != 0)
+        return;
+    
+    // 5. Construct Message 4
+    // =====================================
+    // Use Priority Ring & MiniportMMRequest
+    // =====================================
+    pAdapter->Sequence = ((pAdapter->Sequence) + 1) & (MAX_SEQ_NUMBER);
+    WpaMacHeaderInit(pAdapter, &Header_802_11, 0, &pAdapter->PortCfg.Bssid);
+
+    // ACK size is 14 include CRC, and its rate is based on real time information
+    AckRate = pAdapter->PortCfg.ExpectedACKRate[pAdapter->PortCfg.TxRate];
+    AckDuration = RTUSBCalcDuration(pAdapter, AckRate, 14);
+    Header_802_11.Controlhead.Duration = pAdapter->PortCfg.Dsifs + AckDuration;
+    
+    // Zero message 4 body
+    memset(&Packet, 0, sizeof(Packet));
+    Packet.Version = EAPOL_VER;
+    Packet.Type    = EAPOLKey;
+    Packet.Len[1]  = sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE;     // No data field
+    
+    //
+    // Message 4 as  EAPOL-Key(0,1,0,0,0,P,0,0,MIC,0)
+    //
+    Packet.KeyDesc.Type = RSN_KEY_DESC;
+    
+    // Key descriptor version and appropriate RSN IE
+    Packet.KeyDesc.KeyInfo.KeyDescVer = pMsg3->KeyDesc.KeyInfo.KeyDescVer;
+
+    // Key Type PeerKey
+    Packet.KeyDesc.KeyInfo.KeyType = 1;
+
+    // KeyMic field presented
+    Packet.KeyDesc.KeyInfo.KeyMic  = 1;
+
+    // Key Replay count 
+    memcpy(Packet.KeyDesc.ReplayCounter, pMsg3->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+
+    // Out buffer for transmitting message 4        
+    NStatus = MlmeAllocateMemory(pAdapter, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS)
+        return;                 
+
+    // Prepare EAPOL frame for MIC calculation
+    // Be careful, only EAPOL frame is counted for MIC calculation
+    MakeOutgoingFrame(OutBuffer, &FrameLen,
+        Packet.Len[1] + 4, &Packet,
+        END_OF_ARGS);
+
+    // Prepare and Fill MIC value
+    memset(Mic, 0, sizeof(Mic));
+    if (pAdapter->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+        // AES
+        UCHAR digest[80];
+            
+        HMAC_SHA1(OutBuffer, FrameLen, pAdapter->PortCfg.PTK, LEN_EAP_MICK, digest);
+        memcpy(Mic, digest, LEN_KEY_DESC_MIC);
+    }
+    else
+    {
+        hmac_md5(pAdapter->PortCfg.PTK, LEN_EAP_MICK, OutBuffer, FrameLen, Mic);
+    }
+    memcpy(Packet.KeyDesc.KeyMic, Mic, LEN_KEY_DESC_MIC);
+
+    FrameLen = 0;
+    
+    // Make  Transmitting frame
+    MakeOutgoingFrame(OutBuffer, &FrameLen, sizeof(MACHDR), &Header_802_11,
+        sizeof(EAPHEAD), EAPHEAD, 
+        Packet.Len[1] + 4, &Packet,
+        END_OF_ARGS);
+
+
+    // 7. Update PTK
+    memset(&PeerKey, 0, sizeof(PeerKey));
+    PeerKey.Length    = sizeof(PeerKey);
+    PeerKey.KeyIndex  = 0xe0000000;           
+    PeerKey.KeyLength = 16;
+    memcpy(PeerKey.BSSID, pAdapter->PortCfg.Bssid.Octet, 6);
+    memcpy(&PeerKey.KeyRSC, pMsg3->KeyDesc.KeyRsc, LEN_KEY_DESC_RSC);
+    memcpy(PeerKey.KeyMaterial, &pAdapter->PortCfg.PTK[32], 32);
+    // Call Add peer key function
+    RTMPWPAAddKeyProc(pAdapter, &PeerKey);
+	//RTUSBEnqueueCmdFromNdis(pAdapter, OID_802_11_ADD_KEY, TRUE, &PeerKey, sizeof(PeerKey));
+    
+    // 6. Send Message 4 to authenticator
+    // Send using priority queue
+    MiniportMMRequest(pAdapter, OutBuffer, FrameLen);
+    DBGPRINT(RT_DEBUG_ERROR, "WpaPairMsg3Action <-----\n");
+}
+
+
+/*
+    ========================================================================
+    
+    Routine Description:
+        Process Group key 2-way handshaking
+
+    Arguments:
+        pAdapter    Pointer to our adapter
+        Elem        Message body
+        
+    Return Value:
+        None
+        
+    Note:
+        
+    ========================================================================
+*/
+VOID    WpaGroupMsg1Action(
+    IN  PRT2570ADAPTER   pAdapter, 
+    IN  MLME_QUEUE_ELEM *Elem) 
+{
+	UCHAR               *OutBuffer = NULL;
+	HEADER_802_11       Header_802_11;
+	NDIS_STATUS         NStatus;
+	UCHAR               AckRate = RATE_2;
+	USHORT              AckDuration = 0;
+	ULONG               FrameLen = 0;
+	UCHAR               EAPHEAD[8] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00,0x88,0x8e};
+	EAPOL_PACKET        Packet;
+	PEAPOL_PACKET       pGroup;
+	UCHAR               Mic[16], OldMic[16];
+	UCHAR               GTK[32], Key[32];
+	NDIS_802_11_KEY     GroupKey;
+	UCHAR MSG[MAX_LEN_OF_MLME_BUFFER];
+    
+	if((memcmp(&Elem->Msg[LENGTH_802_11 + 8], EAPHEAD, LENGTH_802_1_H) == 0))
+	{
+	DBGPRINT(RT_DEBUG_ERROR, "WpaGroupMsg1Action ----->MsgLen=%d\n",Elem->MsgLen);
+		memcpy(MSG, Elem->Msg, LENGTH_802_11);
+		memcpy(&MSG[LENGTH_802_11], &Elem->Msg[LENGTH_802_11+8], (Elem->MsgLen ));
+	}
+	else
+	{
+	DBGPRINT(RT_DEBUG_ERROR, "WpaGroupMsg1Action ----->2\n");
+		memcpy(MSG, Elem->Msg, Elem->MsgLen);
+	}
+	// Process Group message 1 frame.
+	pGroup = (PEAPOL_PACKET) &MSG[LENGTH_802_11 + LENGTH_802_1_H];
+//	pGroup = (PEAPOL_PACKET) &Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H + 8];//red
+
+    // 1. Verify Replay counter
+    //    Check Replay Counter, it has to be larger than last one. No need to be exact one larger
+    if (memcmp(pGroup->KeyDesc.ReplayCounter, pAdapter->PortCfg.ReplayCounter, LEN_KEY_DESC_REPLAY) <= 0)
+	{
+		DBGPRINT(RT_DEBUG_ERROR,"Different Replay Counter in Group 2 Handshake\n");
+		return;
+	}
+
+	// Update new replay counter
+	memcpy(pAdapter->PortCfg.ReplayCounter, pGroup->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+
+    // 2. Verify MIC is valid
+    // Save the MIC and replace with zero
+		
+    memset(OldMic, 0, LEN_KEY_DESC_MIC);
+    memcpy(OldMic, pGroup->KeyDesc.KeyMic, LEN_KEY_DESC_MIC);
+    memset(pGroup->KeyDesc.KeyMic, 0, LEN_KEY_DESC_MIC);
+    if (pAdapter->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+        // AES
+        UCHAR digest[80];
+            
+        HMAC_SHA1((PUCHAR) pGroup, pGroup->Len[1] + 4, pAdapter->PortCfg.PTK, LEN_EAP_MICK, digest);
+        memcpy(Mic, digest, LEN_KEY_DESC_MIC);
+    }
+	else
+	{
+		hmac_md5(pAdapter->PortCfg.PTK, LEN_EAP_MICK, (PUCHAR) pGroup, 131, Mic);
+	}
+   
+    if (memcmp(OldMic, Mic, LEN_KEY_DESC_MIC) != 0)
+    {
+        DBGPRINT(RT_DEBUG_ERROR, " MIC Different in group msg 1 of 2-way handshake!!!!!!!!!! \n");
+        return;
+    }
+    else
+        DBGPRINT(RT_DEBUG_TEMP, " MIC VALID in group msg 1 of 2-way handshake!!!!!!!!!! \n");
+
+    // 3. Decrypt GTK from Key Data
+    if (pAdapter->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+        if (pGroup->KeyDesc.KeyInfo.KeyDescVer != 2)
+            return;
+        // Decrypt AES GTK
+        AES_GTK_KEY_UNWRAP(&pAdapter->PortCfg.PTK[16], GTK, pGroup->KeyDesc.KeyData);       
+    }
+    else    // TKIP
+    {
+        INT i;
+        
+        if (pGroup->KeyDesc.KeyInfo.KeyDescVer != 1)
+            return;
+        // Decrypt TKIP GTK
+        // Construct 32 bytes RC4 Key
+        memcpy(Key, pGroup->KeyDesc.KeyIv, 16);
+        memcpy(&Key[16], &pAdapter->PortCfg.PTK[16], 16);
+        ARCFOUR_INIT(&pAdapter->PrivateInfo.WEPCONTEXT, Key, 32);
+        //discard first 256 bytes
+        for (i = 0; i < 256; i++)
+            ARCFOUR_BYTE(&pAdapter->PrivateInfo.WEPCONTEXT);
+        // Decrypt GTK. Becareful, there is no ICV to check the result is correct or not
+        ARCFOUR_DECRYPT(&pAdapter->PrivateInfo.WEPCONTEXT, GTK, pGroup->KeyDesc.KeyData, 32);       
+    }
+    
+    // 4. Construct Group Message 2
+    pAdapter->Sequence = ((pAdapter->Sequence) + 1) & (MAX_SEQ_NUMBER);
+    WpaMacHeaderInit(pAdapter, &Header_802_11, 1, &pAdapter->PortCfg.Bssid);
+
+    // ACK size is 14 include CRC, and its rate is based on real time information
+    AckRate = pAdapter->PortCfg.ExpectedACKRate[pAdapter->PortCfg.TxRate];
+    AckDuration = RTUSBCalcDuration(pAdapter, AckRate, 14);
+    Header_802_11.Controlhead.Duration = pAdapter->PortCfg.Dsifs + AckDuration;
+    
+    // Zero Group message 1 body
+    memset(&Packet, 0, sizeof(Packet));
+    Packet.Version = EAPOL_VER;
+    Packet.Type    = EAPOLKey;
+    Packet.Len[1]  = sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE;     // No data field
+    
+    //
+    // Group Message 2 as  EAPOL-Key(1,0,0,0,G,0,0,MIC,0)
+    //
+    Packet.KeyDesc.Type = RSN_KEY_DESC;
+    
+    // Key descriptor version and appropriate RSN IE
+    Packet.KeyDesc.KeyInfo.KeyDescVer = pGroup->KeyDesc.KeyInfo.KeyDescVer;
+
+    // Key Type Group key
+    Packet.KeyDesc.KeyInfo.KeyType = 0;
+
+    // KeyMic field presented
+    Packet.KeyDesc.KeyInfo.KeyMic  = 1;
+
+    // Secure bit is 1
+    Packet.KeyDesc.KeyInfo.Secure  = 1;
+    
+    // Key Replay count 
+    memcpy(Packet.KeyDesc.ReplayCounter, pGroup->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY);
+    // Out buffer for transmitting group message 2      
+    NStatus = MlmeAllocateMemory(pAdapter, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+    if (NStatus != NDIS_STATUS_SUCCESS)
+        return;                 
+
+    // Prepare EAPOL frame for MIC calculation
+    // Be careful, only EAPOL frame is counted for MIC calculation
+    MakeOutgoingFrame(OutBuffer, &FrameLen,
+        Packet.Len[1] + 4 , &Packet,
+        END_OF_ARGS);
+
+    // Prepare and Fill MIC value
+    memset(Mic, 0, sizeof(Mic));
+    if (pAdapter->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+        // AES
+        UCHAR digest[80];
+            
+        HMAC_SHA1(OutBuffer, FrameLen, pAdapter->PortCfg.PTK, LEN_EAP_MICK, digest);
+        memcpy(Mic, digest, LEN_KEY_DESC_MIC);
+    }
+    else
+    {            
+        hmac_md5(pAdapter->PortCfg.PTK, LEN_EAP_MICK, OutBuffer, FrameLen, Mic);
+    }
+    memcpy(Packet.KeyDesc.KeyMic, Mic, LEN_KEY_DESC_MIC);
+
+    FrameLen = 0;   
+
+    MakeOutgoingFrame(OutBuffer, &FrameLen, sizeof(MACHDR), &Header_802_11,
+//    	 8,pTempIvEiv,
+        sizeof(EAPHEAD), EAPHEAD, 
+        Packet.Len[1] + 4, &Packet,
+        END_OF_ARGS);	
+
+    // 5. Copy frame to Tx ring and prepare for encryption
+     WpaHardEncrypt(pAdapter, OutBuffer, FrameLen);
+
+    // 6 Free allocated memory
+    MlmeFreeMemory(pAdapter, OutBuffer);
+    
+    // 6. Update GTK
+    memset(&GroupKey, 0, sizeof(GroupKey));
+    GroupKey.Length    = sizeof(GroupKey);
+    GroupKey.KeyIndex  = 0x80000000 | pGroup->KeyDesc.KeyInfo.KeyIndex;           
+    GroupKey.KeyLength = 16;
+    memcpy(GroupKey.BSSID, pAdapter->PortCfg.Bssid.Octet, 6);
+    memcpy(GroupKey.KeyMaterial, GTK, 32);
+    // Call Add peer key function
+    RTMPWPAAddKeyProc(pAdapter, &GroupKey);
+    
+    DBGPRINT(RT_DEBUG_TRACE, "WpaGroupMsg1Action <-----\n");
+}
+/*
+    ========================================================================
+    
+    Routine Description:
+        Init WPA MAC header
+
+    Arguments:
+        pAdapter    Pointer to our adapter
+        
+    Return Value:
+        None
+        
+    Note:
+        
+    ========================================================================
+*/
+VOID    WpaMacHeaderInit(
+    IN      PRT2570ADAPTER   pAd, 
+    IN OUT  PHEADER_802_11  Hdr, 
+    IN      UCHAR           wep, 
+    IN      PMACADDR        pAddr1) 
+{
+    memset(Hdr, 0, sizeof(HEADER_802_11));
+    Hdr->Controlhead.Frame.Type = BTYPE_DATA;   
+    Hdr->Controlhead.Frame.ToDs = 1;
+    if (wep == 1)
+        Hdr->Controlhead.Frame.Wep = 1;
+    
+     // Addr1: DA, Addr2: BSSID, Addr3: SA
+    COPY_MAC_ADDR(&Hdr->Controlhead.Addr1, pAddr1);
+    COPY_MAC_ADDR(&Hdr->Controlhead.Addr2, &pAd->CurrentAddress);
+    COPY_MAC_ADDR(&Hdr->Addr3, &pAd->PortCfg.Bssid);
+    Hdr->Sequence = pAd->Sequence;      
+}
+
+/*
+    ========================================================================
+
+    Routine Description:
+        Copy frame from waiting queue into relative ring buffer and set 
+    appropriate ASIC register to kick hardware encryption before really
+    sent out to air.
+        
+    Arguments:
+        pAdapter        Pointer to our adapter
+        PNDIS_PACKET    Pointer to outgoing Ndis frame
+        NumberOfFrag    Number of fragment required
+        
+    Return Value:
+        None
+
+    Note:
+    
+    ========================================================================
+*/
+VOID    WpaHardEncrypt(
+    IN  PRT2570ADAPTER   pAdapter,
+    IN  PUCHAR          pPacket,
+    IN  ULONG           Len)
+{
+	CHAR                 *OutBuffer = NULL;
+	UCHAR           FrameGap;
+	PUCHAR          pDest;
+	PUCHAR          pSrc;
+	ULONG           Iv16;
+	ULONG           Iv32;
+	PWPA_KEY        pWpaKey;
+	NDIS_STATUS           NStatus;
+
+	NStatus = MlmeAllocateMemory(pAdapter, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
+	if (NStatus != NDIS_STATUS_SUCCESS) 
+	{
+		DBGPRINT(RT_DEBUG_TRACE, "WPA - WpaHardEncrypt allocate memory failed\n");
+		pAdapter->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+		MlmeCntlConfirm(pAdapter, MT2_DISASSOC_CONF, MLME_FAIL_NO_RESOURCE);
+		return;
+	}
+	
+	FrameGap = IFS_BACKOFF;     // Default frame gap mode
+	pDest = (PUCHAR)OutBuffer;
+	pSrc = pPacket; // Point to start of MSDU
+    
+	// outgoing frame always wakeup PHY to prevent frame lost and 
+	// turn off PSM bit to improve performance
+	if (pAdapter->PortCfg.Psm == PWR_SAVE)
+	{
+		MlmeSetPsmBit(pAdapter, PWR_ACTIVE);
+	}
+	AsicForceWakeup(pAdapter);
+    
+	pWpaKey = (PWPA_KEY) &pAdapter->PortCfg.PairwiseKey[0];
+	pWpaKey->Type = PAIRWISE_KEY;
+	if (pWpaKey->KeyLen == 0)
+	{
+		// No pairwise key, this should not happen
+		//NdisReleaseSpinLock(&pAdapter->TxRingLock);
+		DBGPRINT(RT_DEBUG_ERROR,"no pairwise key\n");
+		return;
+	}
+
+	if (pAdapter->PortCfg.WepStatus == Ndis802_11Encryption2Enabled)
+	{
+		INT     i = 0;
+		// Start CALCULATE MIC Value
+		RTMPInitMICEngine(
+		                pAdapter,
+		                pWpaKey->Key,
+				pSrc + 4,
+				pSrc + 10,
+				pWpaKey->TxMic);
+		
+		memcpy(pDest, pSrc, LENGTH_802_11);
+		pDest += LENGTH_802_11;
+		pSrc += LENGTH_802_11;
+		RTMPTkipAppend(&pAdapter->PrivateInfo.Tx, pSrc, (Len - LENGTH_802_11));
+		RTMPTkipGetMIC(&pAdapter->PrivateInfo.Tx);
+		//pAdapter->PrivateInfo.Tx.MIC[3]++;
+		// Prepare IV, EIV, IV offset, Key for hardware encryption
+		RTMPInitTkipEngine(
+			pAdapter,
+			pWpaKey->Key,
+			0,
+			pAdapter->CurrentAddress,
+			pWpaKey->TxMic,
+			pWpaKey->TxTsc,
+			1,
+			&Iv16,
+			&Iv32,
+			pDest);
+
+		// Increase TxTsc value for next transmission
+		while (++pWpaKey->TxTsc[i] == 0x0)
+		{
+			i++;
+			if (i == 6)
+			break;
+		}
+
+		if (i == 6)
+		{
+			// TODO: TSC has done one full cycle, do re-keying stuff follow specs
+			// Should send a special event microsoft defined to request re-key
+		}
+            
+		pDest += 8;
+            
+		RTMPTkipEncryptData(pAdapter, pSrc, pDest, (Len-LENGTH_802_11));
+		pDest +=  (Len-LENGTH_802_11);
+		//printk("-4\n");
+
+		RTMPTkipEncryptData(pAdapter, pAdapter->PrivateInfo.Tx.MIC, pDest, 8);
+		pDest +=  8;
+		Len += 8;
+		RTMPSetICV(pAdapter, pDest);
+		Len += 12;
+			
+		MiniportMMRequest(pAdapter, OutBuffer, Len);
+        
+    }
+    else if (pAdapter->PortCfg.WepStatus == Ndis802_11Encryption3Enabled)
+    {
+#if 0
+        INT     i;
+        PUCHAR  pTmp;
+
+        i = 0;
+        pTmp = (PUCHAR) &Iv16;
+        *pTmp       = pWpaKey->TxTsc[0];
+        *(pTmp + 1) = pWpaKey->TxTsc[1];
+        *(pTmp + 2) = 0;
+        *(pTmp + 3) = 0x20;
+            
+        Iv32 = *(PULONG)(&pWpaKey->TxTsc[2]);
+            
+        // Increase TxTsc value for next transmission
+        while (++pWpaKey->TxTsc[i] == 0x0)
+        {
+            i++;
+            if (i == 6)
+                break;
+        }
+            
+        // Copy IV
+        memcpy(&pTxD->Iv, &Iv16, 4);
+            
+        // Copy EIV
+        memcpy(&pTxD->Eiv, &Iv32, 4);
+            
+        // Set IV offset
+        pTxD->IvOffset = LENGTH_802_11;
+
+        // Copy TKey
+        //red,memcpy(pTxD->Key, pWpaKey->Key, 16);
+
+        // Set Cipher suite
+        //red,CipherAlg = CIPHER_AES;
+
+	//red
+	pTempDest += LENGTH_802_11;
+	memcpy(pTempDest, &Iv16, 4);
+	pTempDest += 4;
+	memcpy(pTempDest, &Iv32, 4);
+	pTempDest += 4;
+            
+        // IV + EIV + HW MIC
+        //red,Asic's suggestionLen += 16;
+        PLCPLength = Len + 12;//12 is MIC + crc32
+#endif
+    }               
+                
+}
+
+/*
+    ========================================================================
+    
+    Routine Description:
+        SHA1 function 
+
+    Arguments:
+        
+    Return Value:
+
+    Note:
+        
+    ========================================================================
+*/
+VOID    HMAC_SHA1(
+    IN  UCHAR   *text,
+    IN  UINT    text_len,
+    IN  UCHAR   *key,
+    IN  UINT    key_len,
+    IN  UCHAR   *digest)
+{
+    SHA_CTX context;
+    UCHAR   k_ipad[65]; /* inner padding - key XORd with ipad   */
+    UCHAR   k_opad[65]; /* outer padding - key XORd with opad   */
+    INT     i;
+
+    // if key is longer than 64 bytes reset it to key=SHA1(key) 
+    if (key_len > 64) 
+    {
+        SHA_CTX      tctx;
+        SHAInit(&tctx);
+        SHAUpdate(&tctx, key, key_len);
+        SHAFinal(&tctx, key);
+        key_len = 20;
+    }
+    memset(k_ipad, 0, sizeof(k_ipad));
+    memset(k_opad, 0, sizeof(k_opad));
+    memcpy(k_ipad, key, key_len);
+    memcpy(k_opad, key, key_len);
+
+    // XOR key with ipad and opad values  
+    for (i = 0; i < 64; i++) 
+    {   
+        k_ipad[i] ^= 0x36;
+        k_opad[i] ^= 0x5c;
+    }
+
+    // perform inner SHA1 
+    SHAInit(&context);                      /* init context for 1st pass */
+    SHAUpdate(&context, k_ipad, 64);        /*  start with inner pad */
+    SHAUpdate(&context, text, text_len);    /*  then text of datagram */
+    SHAFinal(&context, digest);             /* finish up 1st pass */
+
+    //perform outer SHA1  
+    SHAInit(&context);                  /* init context for 2nd pass */
+    SHAUpdate(&context, k_opad, 64);    /*  start with outer pad */
+    SHAUpdate(&context, digest, 20);    /*  then results of 1st hash */
+    SHAFinal(&context, digest);         /* finish up 2nd pass */
+}
+
+/*
+    ========================================================================
+    
+    Routine Description:
+        PRF function 
+
+    Arguments:
+        
+    Return Value:
+
+    Note:
+        802.1i  Annex F.9
+        
+    ========================================================================
+*/
+VOID    PRF(
+    IN  UCHAR   *key,
+    IN  INT     key_len,
+    IN  UCHAR   *prefix,
+    IN  INT     prefix_len,
+    IN  UCHAR   *data,
+    IN  INT     data_len,
+    OUT UCHAR   *output,
+    IN  INT     len)
+{
+    INT     i;
+    UCHAR   input[1024];
+    INT     currentindex = 0;
+    INT     total_len;
+    
+    memcpy(input, prefix, prefix_len);
+    input[prefix_len] = 0;
+    memcpy(&input[prefix_len + 1], data, data_len);
+    total_len = prefix_len + 1 + data_len;
+    input[total_len] = 0;
+    total_len++;
+    for (i = 0; i < (len + 19) / 20; i++)
+    {
+        HMAC_SHA1(input, total_len, key, key_len, &output[currentindex]);
+        currentindex += 20;
+        input[total_len - 1]++;
+    }   
+}
+
+/*
+    ========================================================================
+    
+    Routine Description:
+        Count TPTK from PMK
+
+    Arguments:
+        
+    Return Value:
+        Output      Store the TPTK
+
+    Note:
+        
+    ========================================================================
+*/
+VOID WpaCountPTK(
+    IN  UCHAR   *PMK,
+    IN  UCHAR   *ANonce,
+    IN  UCHAR   *AA,
+    IN  UCHAR   *SNonce,
+    IN  UCHAR   *SA,
+    OUT UCHAR   *output,
+    IN  UINT    len)
+{   
+    UCHAR   concatenation[76];
+    UINT    CurrPos = 0;
+    UCHAR   temp[32];
+    UCHAR   Prefix[] = {'P', 'a', 'i', 'r', 'w', 'i', 's', 'e', ' ', 'k', 'e', 'y', ' ', 
+                        'e', 'x', 'p', 'a', 'n', 's', 'i', 'o', 'n'};
+
+    memset(temp, 0, sizeof(temp));
+
+    // Get smaller address
+    if (memcmp(SA, AA, 6) > 0)
+        memcpy(concatenation, AA, 6);
+    else
+        memcpy(concatenation, SA, 6);
+    CurrPos += 6;
+
+    // Get larger address
+    if (memcmp(SA, AA, 6) > 0)
+        memcpy(&concatenation[CurrPos], SA, 6);
+    else
+        memcpy(&concatenation[CurrPos], AA, 6);
+    CurrPos += 6;
+
+    // Get smaller address
+    if (memcmp(ANonce, SNonce, 32) > 0) 
+        memcpy(&concatenation[CurrPos], SNonce, 32);
+    else        
+        memcpy(&concatenation[CurrPos], ANonce, 32);
+    CurrPos += 32;
+
+    // Get larger address
+    if (memcmp(ANonce, SNonce, 32) > 0)
+        memcpy(&concatenation[CurrPos], ANonce, 32);
+    else        
+        memcpy(&concatenation[CurrPos], SNonce, 32);
+    CurrPos += 32;
+        
+    PRF(PMK, LEN_MASTER_KEY, Prefix,  22, concatenation, 76 , output, len);
+}
+
+/*
+    ========================================================================
+    
+    Routine Description:
+        Misc function to Generate random number
+
+    Arguments:
+        
+    Return Value:
+
+    Note:
+        802.1i  Annex F.9
+        
+    ========================================================================
+*/
+VOID    GenRandom(
+    IN  PRT2570ADAPTER   pAd, 
+    OUT UCHAR           *random)
+{   
+    INT     i, curr ;
+    UCHAR   local[80], KeyCounter[32];
+    UCHAR   result[80];
+     ULONG   CurrentTime;
+    UCHAR   prefix[] = {'I', 'n', 'i', 't', ' ', 'C', 'o', 'u', 'n', 't', 'e', 'r'};
+
+    memset(result, 0, 80);
+    memset(local, 0, 80);
+    memset(KeyCounter, 0, 32);
+    memcpy(local, pAd->CurrentAddress, ETH_LENGTH_OF_ADDRESS);
+    
+    for (i = 0; i < 32; i++)
+    {       
+        curr =  ETH_LENGTH_OF_ADDRESS;
+        CurrentTime = jiffies;
+        memcpy(local,  pAd->CurrentAddress, ETH_LENGTH_OF_ADDRESS);
+        curr += ETH_LENGTH_OF_ADDRESS;
+        memcpy(&local[curr],  &CurrentTime, sizeof(CurrentTime));
+        curr += sizeof(CurrentTime);
+        memcpy(&local[curr],  result, 32);
+        curr += 32;
+        memcpy(&local[curr],  &i,  2);
+        curr += 2;
+        PRF(KeyCounter, 32, prefix,12, local,   curr, result, 32); 
+    }
+    memcpy(random, result,  32);
+}
+
+/*
+    ========================================================================
+    
+    Routine Description:
+        Misc function to decrypt AES body
+    
+    Arguments:
+            
+    Return Value:
+    
+    Note:
+        This function references to RFC 3394 for aes key unwrap algorithm.
+            
+    ========================================================================
+*/
+VOID    AES_GTK_KEY_UNWRAP( 
+    IN  UCHAR   *key,
+    OUT UCHAR   *plaintext,
+    IN  UCHAR   *ciphertext)
+{
+    UCHAR       A[8],   BIN[16], BOUT[16];
+    UCHAR       R1[8],R2[8];
+    UCHAR       xor;
+    INT         num_blocks = 2;
+    INT         j;
+    aes_context aesctx;
+    
+    // Initialize
+    // A = C[0]
+    memcpy(A, ciphertext, 8);
+    // R1 = C1
+    memcpy(R1, &ciphertext[8], 8);
+    // R2 = C2
+    memcpy(R2, &ciphertext[16], 8);
+
+    aes_set_key(&aesctx, key, 128);
+    
+    for (j = 5; j >= 0; j--)
+    {
+        xor = num_blocks * j + 2;
+        memcpy(BIN, A, 8);
+        BIN[7] = A[7] ^ xor;
+        memcpy(&BIN[8], R2, 8);
+        aes_decrypt(&aesctx, BIN, BOUT);
+        memcpy(A, &BOUT[0], 8);
+        memcpy(R2, &BOUT[8], 8);
+        
+        xor = num_blocks * j + 1;
+        memcpy(BIN, A, 8);
+        BIN[7] = A[7] ^ xor;
+        memcpy(&BIN[8], R1, 8);
+        aes_decrypt(&aesctx, BIN, BOUT);
+        memcpy(A, &BOUT[0], 8);
+        memcpy(R1, &BOUT[8], 8);
+    }
+
+    // OUTPUT
+    memcpy(&plaintext[0], R1, 8);
+    memcpy(&plaintext[8], R2, 8);
+}
diff -Naru linux-2.4.35.3/drivers/usb/rt2570/wpa.h linux-2.4.35.3-mct/drivers/usb/rt2570/wpa.h
--- linux-2.4.35.3/drivers/usb/rt2570/wpa.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/rt2570/wpa.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,145 @@
+/*************************************************************************** 
+ * RT2x00 SourceForge Project - http://rt2x00.sourceforge.net              * 
+ *                                                                         * 
+ *   This program is free software; you can redistribute it and/or modify  * 
+ *   it under the terms of the GNU General Public License as published by  * 
+ *   the Free Software Foundation; either version 2 of the License, or     * 
+ *   (at your option) any later version.                                   * 
+ *                                                                         * 
+ *   This program is distributed in the hope that it will be useful,       * 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        * 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         * 
+ *   GNU General Public License for more details.                          * 
+ *                                                                         * 
+ *   You should have received a copy of the GNU General Public License     * 
+ *   along with this program; if not, write to the                         * 
+ *   Free Software Foundation, Inc.,                                       * 
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             * 
+ *                                                                         * 
+ *   Licensed under the GNU GPL                                            * 
+ *   Original code supplied under license from RaLink Inc, 2004.           * 
+ ***************************************************************************/
+
+/*************************************************************************** 
+ *	Module Name:	wpa.h
+ *
+ *	Abstract:
+ *
+ *	Revision History:
+ *	Who		When		What
+ *	--------	----------	-------------------------------
+ *	Name		Date		Modification logs
+ *	Jan Lee		2005-06-01	Release
+ ***************************************************************************/
+
+#ifndef __WPA_H__
+#define __WPA_H__
+
+//Messages for the wpa state machine,
+#define WPA_MACHINE_BASE            21
+#define EAP_MSG_TYPE_EAPPacket      21
+#define EAP_MSG_TYPE_EAPOLStart     22
+#define EAP_MSG_TYPE_EAPOLLogoff    23
+#define EAP_MSG_TYPE_EAPOLKey       24
+#define EAP_MSG_TYPE_EAPOLASFAlert  25
+#define MAX_WPA_PSK_MSG             5
+
+// WpaPsk EAPOL Key descripter frame format related length
+#define LEN_KEY_DESC_NONCE          32
+#define LEN_KEY_DESC_IV             16
+#define LEN_KEY_DESC_RSC            8
+#define LEN_KEY_DESC_ID             8
+#define LEN_KEY_DESC_REPLAY         8
+#define LEN_KEY_DESC_MIC            16
+
+//EPA VERSION
+#define EAPOL_VER                   1
+#define DESC_TYPE_TKIP              1
+#define DESC_TYPE_AES               2
+#define RSN_KEY_DESC                0xfe
+
+#define LEN_MASTER_KEY              32  
+
+// EAPOL EK, MK
+#define LEN_EAP_EK                  16
+#define LEN_EAP_MICK                16
+#define LEN_EAP_KEY                 ((LEN_EAP_EK)+(LEN_EAP_MICK))
+// TKIP key related
+#define LEN_TKIP_EK                 16
+#define LEN_TKIP_RXMICK             8
+#define LEN_TKIP_TXMICK             8
+#define LEN_AES_EK                  16
+#define LEN_AES_KEY                 LEN_AES_EK
+#define LEN_TKIP_KEY                ((LEN_TKIP_EK)+(LEN_TKIP_RXMICK)+(LEN_TKIP_TXMICK))
+#define TKIP_AP_TXMICK_OFFSET       ((LEN_EAP_KEY)+(LEN_TKIP_EK))
+#define TKIP_AP_RXMICK_OFFSET       (TKIP_AP_TXMICK_OFFSET+LEN_TKIP_TXMICK)
+#define TKIP_GTK_LENGTH             ((LEN_TKIP_EK)+(LEN_TKIP_RXMICK)+(LEN_TKIP_TXMICK))
+#define LEN_PTK                     ((LEN_EAP_KEY)+(LEN_TKIP_KEY))
+#define MAX_LEN_OF_RSNIE            48
+
+//EAP Packet Type
+#define EAPPacket       0
+#define EAPOLStart      1
+#define EAPOLLogoff     2
+#define EAPOLKey        3
+#define EAPOLASFAlert   4
+#define EAPTtypeMax     5
+
+#define EAPOL_MSG_INVALID   0
+#define EAPOL_PAIR_MSG_1    1
+#define EAPOL_PAIR_MSG_3    2
+#define EAPOL_GROUP_MSG_1   3
+
+// EAPOL Key Information definition within Key descriptor format
+typedef struct _KEY_INFO
+{
+    UCHAR   KeyMic:1;
+    UCHAR   Secure:1;
+    UCHAR   Error:1;
+    UCHAR   Request:1;
+    UCHAR   DL:1;
+    UCHAR   Rsvd:3;
+    UCHAR   KeyDescVer:3;
+    UCHAR   KeyType:1;
+    UCHAR   KeyIndex:2;
+    UCHAR   Install:1;
+    UCHAR   KeyAck:1;
+}   KEY_INFO, *PKEY_INFO;
+
+// EAPOL Key descriptor format
+typedef struct  _KEY_DESCRIPTER
+{
+    UCHAR       Type;
+    KEY_INFO    KeyInfo;
+    UCHAR       KeyLength[2];
+    UCHAR       ReplayCounter[LEN_KEY_DESC_REPLAY];
+    UCHAR       KeyNonce[LEN_KEY_DESC_NONCE];
+    UCHAR       KeyIv[LEN_KEY_DESC_IV];
+    UCHAR       KeyRsc[LEN_KEY_DESC_RSC];
+    UCHAR       KeyId[LEN_KEY_DESC_ID];
+    UCHAR       KeyMic[LEN_KEY_DESC_MIC];
+    UCHAR       KeyDataLen[2];     
+    UCHAR       KeyData[MAX_LEN_OF_RSNIE];
+}   KEY_DESCRIPTER, *PKEY_DESCRIPTER;
+
+typedef struct  _EAPOL_PACKET
+{
+    UCHAR               Version;
+    UCHAR               Type;
+    UCHAR               Len[2];
+    KEY_DESCRIPTER      KeyDesc;
+}   EAPOL_PACKET, *PEAPOL_PACKET;
+
+// For supplicant state machine states. 802.11i Draft 4.1, p. 97
+// We simplified it
+typedef enum    _WpaState
+{
+    SS_NOTUSE,              // 0
+    SS_START,               // 1
+    SS_WAIT_MSG_3,          // 2
+    SS_WAIT_GROUP,          // 3
+    SS_FINISH,              // 4
+    SS_KEYUPDATE,           // 5
+}   WPA_STATE;
+
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/serial/.depend linux-2.4.35.3-mct/drivers/usb/serial/.depend
--- linux-2.4.35.3/drivers/usb/serial/.depend	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/serial/.depend	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,360 @@
+belkin_sa.o: belkin_sa.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h \
+   belkin_sa.h
+cyberjack.o: cyberjack.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h
+digi_acceleport.o: digi_acceleport.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tqueue.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h
+empeg.o: empeg.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h
+ftdi_sio.o: ftdi_sio.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/serial.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h \
+   ftdi_sio.h
+io_edgeport.o: io_edgeport.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/serial.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/ioctl.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h \
+   io_edgeport.h \
+   io_ionsp.h \
+   io_16654.h \
+   io_fw_boot.h \
+   io_fw_boot2.h \
+   io_fw_down.h \
+   io_fw_down2.h \
+   io_tables.h
+io_edgeport.h: \
+   io_usbvend.h
+	@touch io_edgeport.h
+io_ti.o: io_ti.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/serial.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/ioctl.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h \
+   io_16654.h \
+   io_usbvend.h \
+   io_ti.h \
+   io_fw_down3.h
+ipaq.o: ipaq.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h \
+   ipaq.h
+ir-usb.o: ir-usb.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h
+keyspan.o: keyspan.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   usb-serial.h \
+   keyspan.h \
+   keyspan_usa26msg.h \
+   keyspan_usa28msg.h \
+   keyspan_usa49msg.h \
+   keyspan_usa90msg.h
+keyspan.h: \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/usa28.h) \
+   keyspan_usa28_fw.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/usa28x.h) \
+   keyspan_usa28x_fw.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/usa28xa.h) \
+   keyspan_usa28xa_fw.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/usa28xb.h) \
+   keyspan_usa28xb_fw.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/usa19.h) \
+   keyspan_usa19_fw.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/usa19qi.h) \
+   keyspan_usa19qi_fw.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/mpr.h) \
+   keyspan_mpr_fw.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/usa19qw.h) \
+   keyspan_usa19qw_fw.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/usa18x.h) \
+   keyspan_usa18x_fw.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/usa19w.h) \
+   keyspan_usa19w_fw.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/usa49w.h) \
+   keyspan_usa49w_fw.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/usa49wlc.h) \
+   keyspan_usa49wlc_fw.h
+	@touch keyspan.h
+keyspan_pda.o: keyspan_pda.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tqueue.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/pda.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/pda/module.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/xircom.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/xircom/module.h) \
+   keyspan_pda_fw.h \
+   xircom_pgs_fw.h \
+   usb-serial.h
+kl5kusb105.o: kl5kusb105.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h \
+   kl5kusb105.h
+kobil_sct.o: kobil_sct.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/ioctl.h \
+   kobil_sct.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h
+mct_u232.o: mct_u232.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h \
+   mct_u232.h
+omninet.o: omninet.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h
+pl2303.o: pl2303.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/serial.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h \
+   pl2303.h
+usbserial.o: usbserial.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/sched.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/signal.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/poll.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/fcntl.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/list.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/smp_lock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h \
+   pl2303.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/generic.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/pl2303.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/pl2303/module.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/devfs/fs.h)
+usb-serial.h: \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/pda.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/pda/module.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/xircom.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/xircom/module.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/keyspan/module.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/whiteheat.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/whiteheat/module.h)
+	@touch usb-serial.h
+visor.o: visor.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h \
+   visor.h
+whiteheat.o: whiteheat.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_driver.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tty_flip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/serial/debug.h) \
+   usb-serial.h \
+   whiteheat_fw.h \
+   whiteheat.h
+.PRECIOUS:	io_edgeport.h \
+	keyspan.h \
+	usb-serial.h \
+
diff -Naru linux-2.4.35.3/drivers/usb/storage/.depend linux-2.4.35.3-mct/drivers/usb/storage/.depend
--- linux-2.4.35.3/drivers/usb/storage/.depend	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/storage/.depend	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,192 @@
+datafab.o: datafab.c \
+   transport.h \
+   protocol.h \
+   usb.h \
+   debug.h \
+   datafab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/sched.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h
+debug.o: debug.c \
+   debug.h
+debug.h: \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/blk.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/cdrom.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/drivers/scsi/scsi.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/debug.h)
+	@touch debug.h
+dpcm.o: dpcm.c \
+   transport.h \
+   protocol.h \
+   usb.h \
+   debug.h \
+   dpcm.h \
+   sddr09.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/sddr09.h)
+freecom.o: freecom.c \
+   transport.h \
+   protocol.h \
+   usb.h \
+   debug.h \
+   freecom.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/hdreg.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/debug.h)
+initializers.o: initializers.c \
+   initializers.h \
+   debug.h \
+   transport.h
+initializers.h: \
+   usb.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/sddr09.h)
+	@touch initializers.h
+isd200.o: isd200.c \
+   transport.h \
+   protocol.h \
+   usb.h \
+   debug.h \
+   scsiglue.h \
+   isd200.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/sched.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/hdreg.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/ide.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/debug.h)
+jumpshot.o: jumpshot.c \
+   transport.h \
+   protocol.h \
+   usb.h \
+   debug.h \
+   jumpshot.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/sched.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h
+protocol.o: protocol.c \
+   protocol.h \
+   usb.h \
+   debug.h \
+   scsiglue.h \
+   transport.h
+protocol.h: \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/blk.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/drivers/scsi/scsi.h \
+   usb.h
+	@touch protocol.h
+scsiglue.o: scsiglue.c \
+   scsiglue.h \
+   usb.h \
+   debug.h \
+   transport.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h
+scsiglue.h: \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/blk.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/drivers/scsi/scsi.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/drivers/scsi/hosts.h
+	@touch scsiglue.h
+sddr09.o: sddr09.c \
+   transport.h \
+   protocol.h \
+   usb.h \
+   debug.h \
+   sddr09.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/sched.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h
+sddr55.o: sddr55.c \
+   transport.h \
+   protocol.h \
+   usb.h \
+   debug.h \
+   sddr55.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/sched.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/debug.h)
+shuttle_usbat.o: shuttle_usbat.c \
+   transport.h \
+   protocol.h \
+   usb.h \
+   debug.h \
+   shuttle_usbat.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/sched.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h
+transport.o: transport.c \
+   transport.h \
+   protocol.h \
+   usb.h \
+   debug.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/sched.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/debug.h)
+transport.h: \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/blk.h \
+   usb.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/drivers/scsi/scsi.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/hp8200e.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/sddr09.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/sddr55.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/freecom.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/datafab.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/jumpshot.h)
+	@touch transport.h
+unusual_devs.h: \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/hp8200e.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/dpcm.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/sddr09.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/isd200.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/jumpshot.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/freecom.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/datafab.h) \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/sddr55.h)
+	@touch unusual_devs.h
+usb.o: usb.c \
+   usb.h \
+   scsiglue.h \
+   transport.h \
+   protocol.h \
+   debug.h \
+   initializers.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/hp8200e.h) \
+   shuttle_usbat.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/sddr09.h) \
+   sddr09.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/sddr55.h) \
+   sddr55.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/dpcm.h) \
+   dpcm.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/freecom.h) \
+   freecom.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/isd200.h) \
+   isd200.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/datafab.h) \
+   datafab.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/usb/storage/jumpshot.h) \
+   jumpshot.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/sched.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   unusual_devs.h \
+   unusual_devs.h
+usb.h: \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/blk.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/smp_lock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/completion.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/spinlock.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/atomic.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/drivers/scsi/scsi.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/drivers/scsi/hosts.h
+	@touch usb.h
+.PRECIOUS:	debug.h \
+	initializers.h \
+	protocol.h \
+	scsiglue.h \
+	transport.h \
+	unusual_devs.h \
+	usb.h \
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/.depend linux-2.4.35.3-mct/drivers/usb/zd1211/.depend
--- linux-2.4.35.3/drivers/usb/zd1211/.depend	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/.depend	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,249 @@
+zd1205.o: zd1205.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/net/checksum.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tcp.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/udp.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/fs.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/stat.h \
+   zd1205.h \
+   zdinlinef.h \
+   zddebug.h \
+   zddebug2.h \
+   menu_drv_macro.h \
+   zdhw.h \
+   zdsorts.h \
+   zdglobal.h \
+   zdutils.h \
+   zdpsmon.h \
+   zd1211.h \
+   zdhci.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/net/iw_handler.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/proc/fs.h)
+zd1205.h: \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/types.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/init.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/mm.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/errno.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/ioport.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/pci.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/kernel.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/netdevice.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/etherdevice.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/skbuff.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/delay.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/timer.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/slab.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/interrupt.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/version.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/string.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/wait.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/reboot.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/io.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/unaligned.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/processor.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/ethtool.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/inetdevice.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/bitops.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/if.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/uaccess.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/proc_fs.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/ip.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/wireless.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/if_arp.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/unistd.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/asm/div64.h \
+   zdcompat.h \
+   zdequates.h \
+   zdapi.h \
+   zydas_common.h \
+   zd1211_wext.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/net/wireless.h)
+	@touch zd1205.h
+zd1205_proc.o: zd1205_proc.c \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/proc/fs.h) \
+   zd1205.h
+zd1211.o: zd1211.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/net/checksum.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/tcp.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/udp.h \
+   zddebug.h \
+   zdhw.h \
+   zd1211.h \
+   zdcompat.h \
+   WS11UPhR.h \
+   WS11UPhm.h \
+   WS11UPhm.h \
+   WS11Ur.h \
+   WS11Ub.h \
+   $(wildcard /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/config/net/wireless.h)
+zd1211.h: \
+   zd1205.h
+	@touch zd1211.h
+zd80211.h: \
+   zdos.h \
+   zdtypes.h \
+   zdsorts.h \
+   zdutils.h \
+   zdglobal.h \
+   zdsm.h \
+   zdbuf.h \
+   zdhci.h \
+   zdpsmon.h \
+   zdpmfilter.h \
+   zdmmrx.h \
+   zdshared.h \
+   zdhw.h \
+   zdtkipseed.h \
+   zdmic.h \
+   zdencrypt.h
+	@touch zd80211.h
+zdapi.h: \
+   zdtypes.h \
+   zdsorts.h
+	@touch zdapi.h
+zdasocsvc.o: zdasocsvc.c \
+   zd80211.h \
+   zd1205.h
+zdauthreq.o: zdauthreq.c \
+   zd80211.h
+zdauthrsp.o: zdauthrsp.c \
+   zd80211.h \
+   zd1205.h
+zdbuf.o: zdbuf.c \
+   zd80211.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/vmalloc.h
+zddebug2.o: zddebug2.c \
+   zddebug2.h \
+   menu_drv_macro.h
+zddebug2.h: \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/string.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/netdevice.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/skbuff.h \
+   zd1205.h \
+   zdsorts.h \
+   zdutils.h
+	@touch zddebug2.h
+zddebug.o: zddebug.c \
+   zddebug.h \
+   zdhw.h \
+   zdsm.h \
+   zdpmfilter.h \
+   zdhci.h \
+   zdpsmon.h \
+   zdutils.h \
+   zd1211.h
+zddebug.h: \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/string.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/netdevice.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/skbuff.h \
+   zd1205.h
+	@touch zddebug.h
+zdencrypt.o: zdencrypt.c \
+   zd80211.h
+zdglobal.o: zdglobal.c \
+   zd80211.h \
+   zddebug.h
+zdhci.o: zdhci.c \
+   zd80211.h \
+   zdhci.h \
+   zdequates.h \
+   zd1205.h \
+   zddebug.h
+zdhci.h: \
+   zdapi.h
+	@touch zdhci.h
+zdhw.o: zdhw.c \
+   zdtypes.h \
+   zdequates.h \
+   zdapi.h \
+   zdhw.h \
+   zddebug.h \
+   zd1211.h \
+   zd1205.h
+zdhw.h: \
+   zdequates.h
+	@touch zdhw.h
+zdinlinef.h: \
+   zd1205.h \
+   zdglobal.h \
+   zddebug.h
+	@touch zdinlinef.h
+zdmic.o: zdmic.c \
+   zd80211.h
+zdmmrx.o: zdmmrx.c \
+   zd80211.h
+zdos.h: \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/string.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/netdevice.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/skbuff.h
+	@touch zdos.h
+zdpci_hotplug.o: zdpci_hotplug.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/version.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/modversions.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/pci.h \
+   zd1205.h \
+   zddebug.h \
+   zdpci_hotplug.h \
+   zdversion.h
+zdpci_pcmcia.o: zdpci_pcmcia.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/version.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/modversions.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/pci.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/pcmcia/driver_ops.h \
+   zd1205.h \
+   zddebug.h \
+   zdpci_pcmcia.h \
+   zdversion.h
+zdpmfilter.o: zdpmfilter.c \
+   zd80211.h \
+   zd1205.h \
+   zddebug.h
+zdpsmon.o: zdpsmon.c \
+   zd80211.h \
+   zddebug.h
+zdshared.o: zdshared.c \
+   zd80211.h \
+   zddebug.h \
+   zd1205.h
+zdsm.h: \
+   zdos.h \
+   zdsorts.h
+	@touch zdsm.h
+zdsorts.h: \
+   zdtkipseed.h \
+   zdmic.h
+	@touch zdsorts.h
+zdsynch.o: zdsynch.c \
+   zd80211.h
+zdtkipseed.o: zdtkipseed.c \
+   zd80211.h
+zdusb.o: zdusb.c \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/version.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/modversions.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/module.h \
+   /home/andi/openmct/trunk/openmct/packages/system/linux/src/include/linux/usb.h \
+   zd1205.h \
+   zdusb.h \
+   zddebug.h \
+   zdversion.h \
+   zd1211.h
+zdutils.h: \
+   zdsorts.h
+	@touch zdutils.h
+.PRECIOUS:	zd1205.h \
+	zd1211.h \
+	zd80211.h \
+	zdapi.h \
+	zddebug2.h \
+	zddebug.h \
+	zdhci.h \
+	zdhw.h \
+	zdinlinef.h \
+	zdos.h \
+	zdsm.h \
+	zdsorts.h \
+	zdutils.h \
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/Makefile linux-2.4.35.3-mct/drivers/usb/zd1211/Makefile
--- linux-2.4.35.3/drivers/usb/zd1211/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/Makefile	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,20 @@
+#
+# Makefile for the USB ZD1211 device drivers.
+#
+
+O_TARGET	:= zd1211usb.o
+
+EXTRA_CFLAGS += 	-DZD1211 -DZDCONF_WE_STAT_SUPPORT=1 -DHOST_IF_USB -DAMAC -DGCCK \
+			-DOFDM -DHOSTAPD_SUPPORT -DUSE_EP4_SET_REG -DDOWNLOADFIRMWARE -DfTX_GAIN_OFDM=0 \
+			-DfNEW_CODE_MAP=1 -DfWRITE_WORD_REG=1 -DfREAD_MUL_REG=1 -DENHANCE_RX=1 \
+			-Os
+
+obj-y		:= zd1205.o zdasocsvc.o zdauthreq.o zdauthrsp.o zdmmrx.o zdshared.o \
+		   zdhci.o zdglobal.o zdencrypt.o zdpmfilter.o zdpsmon.o zdsynch.o \
+		   zdbuf.o zd1205_proc.o zdhw.o zddebug.o zdtkipseed.o zdmic.o zdusb.o \
+		   zd1211.o
+
+obj-m		= zd1211usb.o
+
+include $(TOPDIR)/Rules.make
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/WS11UPh.h linux-2.4.35.3-mct/drivers/usb/zd1211/WS11UPh.h
--- linux-2.4.35.3/drivers/usb/zd1211/WS11UPh.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/WS11UPh.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,328 @@
+#ifdef ZD1211
+={
+         0x08, 0x91, 0xFF, 0xED, 0x09, 0x93, 0x1E, 0xEE, 0xD1, 0x94, 0x11, 0xEE, 0x88, 0xD4, 0xD1, 0x96, 0xD1, 0x98, 0x5C, 0x99, 0x5C, 0x99, 0x4C, 0x99, 0x04, 0x9D, 0xD1, 0x98, 0xD1, 0x9A, 0x03, 0xEE,
+         0xF4, 0x94, 0xD3, 0xD4, 0x41, 0x2A, 0x40, 0x4A, 0x45, 0xBE, 0x88, 0x92, 0x41, 0x24, 0x40, 0x44, 0x53, 0xBE, 0x40, 0xF0, 0x93, 0xEE, 0x41, 0xEE, 0x98, 0x9A, 0xC9, 0xF7, 0x02, 0x00, 0x1F, 0xEC,
+         0x00, 0x00, 0xB2, 0xF8, 0x4D, 0x00, 0x80, 0xEC, 0x00, 0x00, 0xA3, 0xF7, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xD8, 0xA0, 0x90, 0x98, 0x9A, 0x98, 0x9A, 0xA0, 0xD8,
+         0x40, 0xF0, 0x98, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0x64, 0xEF, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0xDA, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0,
+         0xFF, 0xF6, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0x56, 0xF5, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0xD5, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0,
+         0x94, 0xF7, 0xA0, 0x90, 0x98, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x42, 0x02, 0xC1, 0x92, 0x03, 0x96, 0x1B, 0xD7, 0x2A, 0x86,
+         0x1A, 0xD5, 0x2B, 0x86, 0x09, 0xA3, 0x00, 0x80, 0x19, 0xD3, 0x2C, 0x86, 0x00, 0xEE, 0x0A, 0x65, 0xC0, 0x7A, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFE, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x05, 0x00, 0x05, 0x94, 0xC5, 0xD4, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x01, 0xD4, 0x42, 0x02, 0xC1, 0x96, 0x0A, 0x65, 0xC0, 0x7A,
+         0x02, 0x99, 0xC4, 0x92, 0x41, 0xA2, 0xC4, 0xD2, 0xC5, 0x98, 0x1C, 0xD9, 0x2A, 0x86, 0x01, 0x98, 0x1C, 0xD9, 0x2B, 0x86, 0x1B, 0xD7, 0x2C, 0x86, 0x00, 0xEE, 0x09, 0xB3, 0xFE, 0xFF, 0xC2, 0xD2,
+         0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xE5, 0xEE, 0x11, 0x93, 0xCD, 0xF7, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xAE, 0xEE, 0x40, 0xF1,
+         0x40, 0x92, 0x19, 0xD3, 0xCD, 0xF7, 0xC5, 0x92, 0x41, 0x92, 0x19, 0xD3, 0x00, 0x83, 0x40, 0x92, 0x19, 0xD3, 0x00, 0x83, 0x0F, 0x9F, 0x95, 0xF8, 0x0F, 0x9F, 0x99, 0xEE, 0x42, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0x99, 0xEE, 0x40, 0x92, 0x19, 0xD3, 0xCD, 0xF7, 0x09, 0x93, 0xBC, 0xF7, 0x19, 0xD3, 0x6C, 0xEC, 0x40, 0xF0, 0x87, 0xF2, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x0F, 0x9F,
+         0x99, 0xEE, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x12, 0x95, 0x19, 0xD3, 0x10, 0x95, 0x19, 0xD3, 0x02, 0x80, 0x19, 0xD3, 0x03, 0x82,
+         0x09, 0x93, 0xBC, 0xF7, 0x19, 0xD3, 0x6C, 0xEC, 0x40, 0xF0, 0x87, 0xF2, 0x40, 0xF0, 0xF3, 0xF3, 0x11, 0x93, 0x04, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xE3, 0xEE, 0x40, 0x92, 0x19, 0xD3,
+         0x04, 0xEC, 0x40, 0xF0, 0x60, 0xF2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x44, 0x96, 0x09, 0xB3, 0xFF, 0xFD, 0x19, 0xD3, 0x44, 0x96, 0x40, 0xF0, 0x8D, 0xF7,
+         0x6E, 0x92, 0x19, 0xD3, 0x05, 0x84, 0x40, 0xF0, 0xC4, 0xEE, 0x4B, 0x62, 0x0A, 0x95, 0x2E, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x2B, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x00, 0xEE, 0xD1, 0xD4, 0x0B, 0x97,
+         0x2F, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x34, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x39, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x3E, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x43, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x48, 0xEE,
+         0xD1, 0xD4, 0x0B, 0x97, 0x4D, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x4E, 0xEE, 0xC1, 0xD4, 0x0A, 0x65, 0x00, 0x44, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x43, 0xF1, 0x09, 0x93, 0x01, 0x3F,
+         0x19, 0xD3, 0xC0, 0x85, 0x11, 0x93, 0x44, 0x96, 0x09, 0xB3, 0xFF, 0xFC, 0x19, 0xD3, 0x44, 0x96, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x03, 0x96,
+         0x41, 0x02, 0x03, 0x99, 0xC4, 0x94, 0x42, 0x04, 0xC1, 0x04, 0xC2, 0x94, 0xC3, 0xD4, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x6E, 0xEC, 0x13, 0x97,
+         0x6F, 0xEC, 0x1B, 0xD7, 0x02, 0x80, 0x11, 0x93, 0x73, 0xEC, 0x19, 0xD3, 0x7C, 0x96, 0x0B, 0x97, 0xA0, 0x00, 0x1B, 0xD7, 0x77, 0xEC, 0x0A, 0x65, 0x0E, 0x42, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3,
+         0xFF, 0xBF, 0x11, 0xA3, 0x74, 0xEC, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3,
+         0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x47, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x14, 0x99, 0x03, 0x80, 0x0C, 0xB3, 0x00, 0x10, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x7B, 0xF0,
+         0x11, 0x93, 0x7E, 0xEC, 0x41, 0x02, 0x19, 0xD3, 0x7E, 0xEC, 0x11, 0x93, 0xCB, 0xF7, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x84, 0xEF, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3,
+         0x00, 0x04, 0xC2, 0xD2, 0x0F, 0x9F, 0x95, 0xF0, 0x11, 0x93, 0x6E, 0xEC, 0x02, 0xD2, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xD0, 0xEF, 0x41, 0x92, 0x19, 0xD3, 0x6E, 0xEC, 0x19, 0xD3, 0x7E, 0xEC,
+         0x12, 0x95, 0x02, 0x80, 0x1A, 0xD5, 0x6F, 0xEC, 0x13, 0x97, 0x7C, 0x96, 0x1B, 0xD7, 0x73, 0xEC, 0x0A, 0x65, 0x0E, 0x42, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x00, 0x40, 0x19, 0xD3, 0x74, 0xEC,
+         0x09, 0x63, 0x00, 0x40, 0xC2, 0xD2, 0x02, 0x94, 0x1A, 0xD5, 0x7C, 0x96, 0x0C, 0xB3, 0x00, 0x08, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xB0, 0xEF, 0x0C, 0xB3, 0xFF, 0x07, 0x0F, 0x9F, 0xB4, 0xEF,
+         0x11, 0x93, 0x06, 0x80, 0x09, 0xB3, 0xFF, 0x07, 0x09, 0x03, 0x00, 0xA0, 0x19, 0xD3, 0x71, 0xEC, 0x40, 0x98, 0x0B, 0x97, 0x7B, 0xEC, 0x04, 0x95, 0x03, 0x05, 0x14, 0x03, 0x71, 0xEC, 0x46, 0x02,
+         0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x08, 0x42, 0x48, 0x02, 0x9E, 0x0F, 0x9F, 0xBB, 0xEF, 0x11, 0x93, 0x71, 0xEC, 0xC1, 0x92, 0xC5, 0xD2, 0x5F, 0xB2, 0x19, 0xD3, 0x7A, 0xEC, 0x0F, 0x9F, 0xD3, 0xEF,
+         0x13, 0x97, 0x72, 0xEC, 0xC5, 0xD6, 0x12, 0x95, 0x7A, 0xEC, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x70, 0xF0, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xF1, 0xEF, 0x0A, 0xB3,
+         0x07, 0x00, 0x09, 0x05, 0x88, 0xEC, 0xC2, 0x94, 0x01, 0xD4, 0x09, 0x03, 0x80, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x7A, 0xEC, 0xC5, 0x98, 0x0C, 0xB9, 0x00, 0xFF, 0x01, 0xA9, 0xC5, 0xD8, 0x0F, 0x9F,
+         0xFD, 0xEF, 0x0A, 0x05, 0xFF, 0xFF, 0x0A, 0x03, 0x90, 0xEC, 0xC1, 0x92, 0x01, 0xD2, 0x1A, 0xD5, 0x7A, 0xEC, 0xC5, 0x92, 0x09, 0x03, 0xFF, 0xFF, 0xC5, 0xD2, 0x11, 0x93, 0x71, 0xEC, 0xC5, 0x94,
+         0xC1, 0xD4, 0x11, 0x93, 0x71, 0xEC, 0x09, 0x07, 0x0B, 0x00, 0x03, 0xD6, 0xC3, 0x98, 0x06, 0xD8, 0x7C, 0x95, 0x7A, 0x95, 0x4C, 0x02, 0xC1, 0x92, 0x59, 0x93, 0x59, 0x93, 0x01, 0xA5, 0x01, 0x98,
+         0x0C, 0xF5, 0x7B, 0x93, 0x09, 0x09, 0x01, 0x00, 0x06, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x04, 0xD2, 0x5C, 0x93, 0x59, 0x93, 0x04, 0x94, 0x01, 0xA5, 0x03, 0x96, 0xC3, 0xD4, 0x11, 0x93, 0x71, 0xEC,
+         0x4C, 0x02, 0x05, 0xD2, 0xC1, 0x92, 0x09, 0xB3, 0x00, 0xFF, 0x7C, 0x95, 0x7A, 0x95, 0x02, 0xA3, 0x05, 0x98, 0xC4, 0xD2, 0x12, 0x95, 0x71, 0xEC, 0x45, 0x04, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3,
+         0x00, 0x01, 0xC2, 0xD2, 0x12, 0x95, 0x7A, 0xEC, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x45, 0xF0, 0x12, 0x95, 0x71, 0xEC, 0x4A, 0x04, 0x02, 0x99, 0xC4, 0x92, 0x01, 0x98,
+         0x0C, 0xF3, 0x7B, 0x93, 0x41, 0x02, 0x0F, 0x9F, 0x66, 0xF0, 0x43, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x67, 0xF0, 0x11, 0x93, 0x71, 0xEC, 0x42, 0x02, 0x0A, 0x05, 0xFF, 0xFF, 0xC1, 0xD4, 0x11, 0x93,
+         0x71, 0xEC, 0x4A, 0x02, 0x12, 0x95, 0x60, 0x96, 0xC1, 0xD4, 0x12, 0x95, 0x71, 0xEC, 0x4B, 0x04, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x1F, 0xFF, 0xC2, 0xD2, 0x12, 0x95, 0x71, 0xEC, 0x4B, 0x04,
+         0x11, 0x93, 0x62, 0x96, 0x41, 0x93, 0x59, 0x93, 0x02, 0x99, 0xC4, 0xA2, 0xC2, 0xD2, 0xC5, 0x92, 0x19, 0xD3, 0x72, 0xEC, 0x0A, 0x95, 0x0C, 0x02, 0x1A, 0xD5, 0x02, 0x80, 0x0F, 0x9F, 0x95, 0xF0,
+         0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x00, 0x04, 0xC2, 0xD2, 0x40, 0xF0, 0x39, 0xEF, 0x0F, 0x9F, 0x95, 0xF0, 0x11, 0x93, 0x6E, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F,
+         0x8A, 0xF0, 0x40, 0xF0, 0x39, 0xEF, 0x11, 0x93, 0x6F, 0xEC, 0x44, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x95, 0xF0, 0x48, 0x98, 0x1C, 0xD9, 0x02, 0x80, 0x11, 0x93, 0x6C, 0xEC, 0x41, 0x22,
+         0x0A, 0x95, 0x95, 0xF0, 0x88, 0xD4, 0x88, 0xDC, 0x91, 0x9A, 0x47, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x04, 0x82, 0x48, 0xB2, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0xAC, 0xF0, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFF, 0xFE, 0xC2, 0xD2, 0x41, 0x92, 0x19, 0xD3, 0x97, 0xEC, 0x11, 0x93, 0x04, 0x82, 0x43, 0xB2, 0x12, 0x95,
+         0x03, 0x82, 0x02, 0xB3, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xD3, 0xF0, 0x0A, 0xB3, 0x00, 0xFF, 0x48, 0xA2, 0x19, 0xD3, 0x03, 0x82, 0x40, 0xF0, 0x00, 0xF4, 0x11, 0x93, 0x97, 0xEC, 0x41, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0xD3, 0xF0, 0x11, 0x93, 0x07, 0x82, 0x11, 0x43, 0x03, 0xEC, 0x02, 0x0E, 0x0F, 0x9F, 0xD3, 0xF0, 0x11, 0x93, 0x03, 0x82, 0x09, 0xA3, 0x00, 0x01, 0x19, 0xD3, 0x03, 0x82,
+         0x40, 0x96, 0x1B, 0xD7, 0x97, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x20, 0xBC, 0xC8, 0xD2,
+         0x40, 0xF0, 0x70, 0xF1, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x44, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x07, 0x00, 0x07, 0x96, 0x41, 0x02, 0xC1, 0x92, 0x02, 0xD2, 0x0B, 0xB3,
+         0x00, 0xFF, 0x09, 0x43, 0x00, 0x9B, 0x02, 0x5E, 0x0F, 0x9F, 0xFF, 0xF0, 0x0B, 0x03, 0xC9, 0x5C, 0x02, 0x94, 0xD2, 0x96, 0xD1, 0xD6, 0xC2, 0x98, 0xC1, 0xD8, 0x0F, 0x9F, 0x6D, 0xF1, 0x09, 0x43,
+         0x00, 0x99, 0x02, 0x5E, 0x0F, 0x9F, 0x20, 0xF1, 0x0B, 0x03, 0x00, 0x67, 0x61, 0x97, 0x0B, 0x03, 0x17, 0xF8, 0x02, 0x94, 0xD2, 0x98, 0xC1, 0xD8, 0xC2, 0x94, 0xD9, 0xD4, 0x03, 0xD2, 0x40, 0x46,
+         0x02, 0x5E, 0x0F, 0x9F, 0x6D, 0xF1, 0x09, 0x03, 0xFF, 0xFF, 0x0B, 0x97, 0x7E, 0x00, 0xC8, 0xD6, 0xC8, 0xD2, 0x57, 0x98, 0xC8, 0xD8, 0x40, 0xF0, 0x53, 0xEE, 0x43, 0x00, 0x0F, 0x9F, 0x6D, 0xF1,
+         0x0B, 0xB3, 0x00, 0xF0, 0x09, 0x43, 0x00, 0x90, 0x02, 0x5E, 0x0F, 0x9F, 0x30, 0xF1, 0x0B, 0x03, 0x02, 0x00, 0xC5, 0xD2, 0x02, 0x94, 0x0A, 0x03, 0x01, 0x00, 0xC1, 0x92, 0xC5, 0x98, 0xC4, 0xD2,
+         0x02, 0x92, 0xC1, 0x94, 0x03, 0x93, 0xC1, 0xD4, 0x0B, 0x47, 0x00, 0x95, 0x02, 0x5E, 0x0F, 0x9F, 0x6D, 0xF1, 0x02, 0x96, 0xC3, 0x92, 0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x6D, 0xF1,
+         0x11, 0x93, 0x98, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x6D, 0xF1, 0x41, 0x98, 0x1C, 0xD9, 0x98, 0xEC, 0x12, 0x95, 0x02, 0x80, 0x01, 0xD4, 0x40, 0xF0, 0x7E, 0xF2, 0x0B, 0x67, 0xFD, 0x7D,
+         0x03, 0x99, 0xC4, 0x92, 0x0C, 0x99, 0x20, 0x03, 0x1C, 0xD9, 0x06, 0x82, 0x41, 0x98, 0x1C, 0xD9, 0x02, 0x82, 0x42, 0x98, 0x1C, 0xD9, 0x05, 0x82, 0x0C, 0x69, 0x80, 0x7F, 0x1C, 0xD9, 0x00, 0xB0,
+         0x09, 0xA3, 0x00, 0x01, 0xC3, 0xD2, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x6B, 0xF1, 0x42, 0xA4, 0x1A, 0xD5, 0x02, 0x80, 0x44, 0x00, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x05, 0x92, 0xC5, 0xD2, 0x60, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x7D, 0xF1, 0x40, 0xF0, 0x3D, 0xF7, 0xC5, 0x94, 0x0A, 0xB3, 0x10, 0x00,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x86, 0xF1, 0x40, 0xF0, 0x81, 0xF5, 0xC5, 0x96, 0x0B, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x8F, 0xF1, 0x40, 0xF0, 0xBC, 0xF4, 0xC5, 0x94,
+         0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xF0, 0xF1, 0x13, 0x97, 0x21, 0xBC, 0x01, 0xD6, 0x0B, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xA1, 0xF1, 0x40, 0xF0,
+         0x62, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAA, 0xF1, 0x40, 0xF0, 0x6C, 0xFB, 0x01, 0x96, 0x0B, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0xCA, 0xF1, 0x40, 0xF0, 0xB0, 0xFA, 0x41, 0x92, 0x19, 0xD3, 0xCA, 0xF7, 0x11, 0x93, 0x03, 0xEC, 0x09, 0x43, 0x40, 0x00, 0x02, 0x5E, 0x0F, 0x9F, 0xC0, 0xF1, 0x40, 0x94, 0x1A, 0xD5, 0xCA, 0xF7,
+         0x11, 0x93, 0x00, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xD3, 0xF1, 0x40, 0xF0, 0x60, 0xF2, 0x0F, 0x9F, 0xD3, 0xF1, 0x01, 0x96, 0x0B, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0xD3, 0xF1, 0x40, 0xF0, 0x7C, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x10, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xDC, 0xF1, 0x40, 0xF0, 0x87, 0xFB, 0x11, 0x93, 0x10, 0xEC, 0x42, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0xE7, 0xF1, 0x44, 0x96, 0x1B, 0xD7, 0x0B, 0xBC, 0x0F, 0x9F, 0xED, 0xF1, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xED, 0xF1, 0x19, 0xD3, 0x0B, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x10, 0xEC,
+         0xC5, 0x94, 0x0A, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x3A, 0xF2, 0x13, 0x97, 0x28, 0xBC, 0x01, 0xD6, 0x0B, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x02, 0xF2,
+         0x40, 0xF0, 0x20, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x15, 0xF2, 0x40, 0xF0, 0xC4, 0xEE, 0x40, 0xF0, 0x8F, 0xFB, 0x40, 0xF0, 0x43, 0xF2, 0x40, 0x96,
+         0x1B, 0xD7, 0x00, 0xEC, 0x41, 0x92, 0x19, 0xD3, 0xCD, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x31, 0xF2, 0x40, 0xF0, 0x9E, 0xFB, 0x09, 0x63, 0x00, 0x44,
+         0x01, 0x97, 0xC3, 0x94, 0x48, 0xA4, 0xC1, 0xD4, 0x00, 0xEE, 0x40, 0x92, 0x19, 0xD3, 0x12, 0x95, 0x19, 0xD3, 0x10, 0x95, 0x19, 0xD3, 0x02, 0x80, 0x19, 0xD3, 0x03, 0x82, 0x41, 0x92, 0x19, 0xD3,
+         0xCD, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x3A, 0xF2, 0x40, 0xF0, 0xAE, 0xFB, 0x0A, 0x65, 0x00, 0x44, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2,
+         0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x40, 0x19, 0xD3, 0xF2, 0xBD, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2,
+         0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43,
+         0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x09, 0x93, 0x00, 0x01, 0x19, 0xD3, 0x02, 0x80, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x00, 0x09, 0x19, 0xD3, 0x02, 0x80, 0x40, 0xF0, 0x7E, 0xF2,
+         0x40, 0x92, 0x19, 0xD3, 0x6E, 0xEC, 0xC8, 0xD2, 0x09, 0x93, 0x6C, 0xEC, 0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0,
+         0x9A, 0xF4, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAD, 0xF2, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x0F, 0x9F, 0xBA, 0xF2, 0x40, 0xF0, 0xBC, 0xF2, 0x40, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0xBA, 0xF2, 0xC8, 0xD2, 0x09, 0x93, 0x6C, 0xEC, 0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93,
+         0xF1, 0xBD, 0x19, 0xD3, 0x95, 0xEC, 0x11, 0x93, 0x93, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xD4, 0xF2, 0x09, 0x63, 0x00, 0x80, 0x01, 0x97, 0xC3, 0x94, 0x0A, 0x07, 0x07, 0x00, 0xC1, 0xD6,
+         0x0A, 0x05, 0x00, 0xA0, 0x1A, 0xD5, 0x70, 0xEC, 0x11, 0x93, 0x95, 0xEC, 0x19, 0xD3, 0x01, 0x80, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x41, 0xA2, 0xC2, 0xD2, 0x40, 0x92, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x13, 0x97, 0x93, 0xEC, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0x54, 0xF3, 0x12, 0x95, 0x70, 0xEC, 0x0A, 0x03, 0x07, 0x00, 0xC1, 0x92,
+         0xC2, 0xD2, 0x11, 0x93, 0x70, 0xEC, 0x09, 0x05, 0x01, 0x00, 0x48, 0x02, 0xC1, 0x92, 0xC2, 0xD2, 0x11, 0x93, 0x70, 0xEC, 0x4E, 0x02, 0xC1, 0x94, 0xC5, 0xD6, 0xC5, 0x92, 0x11, 0x07, 0x70, 0xEC,
+         0x0B, 0x03, 0x0F, 0x00, 0xC1, 0x98, 0x46, 0x06, 0x7A, 0x93, 0x79, 0x93, 0x5C, 0x95, 0x5A, 0x95, 0x02, 0xA3, 0xC3, 0xD2, 0x04, 0x95, 0xC5, 0x96, 0x41, 0x06, 0xC5, 0xD6, 0x42, 0x46, 0x02, 0x9E,
+         0x0F, 0x9F, 0xFD, 0xF2, 0x11, 0x93, 0x70, 0xEC, 0x09, 0x05, 0x05, 0x00, 0x41, 0x02, 0xC1, 0x92, 0xC2, 0xD2, 0x11, 0x93, 0x70, 0xEC, 0xC1, 0x92, 0x09, 0xB5, 0x1F, 0x00, 0x43, 0x44, 0x02, 0x8E,
+         0x0F, 0x9F, 0x2A, 0xF3, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x2B, 0xF3, 0x0A, 0x05, 0xFF, 0xFF, 0x0F, 0x9F, 0x2B, 0xF3, 0x43, 0x94, 0x11, 0x93, 0x70, 0xEC, 0x42, 0x02, 0xC1, 0xD4, 0x11, 0x93,
+         0x70, 0xEC, 0x49, 0x02, 0xC1, 0x92, 0x19, 0xD3, 0x93, 0xEC, 0x09, 0x05, 0xF2, 0xFF, 0x1A, 0xD5, 0x6D, 0xEC, 0x09, 0x43, 0xD0, 0x07, 0x02, 0x9E, 0x0F, 0x9F, 0x54, 0xF3, 0x11, 0x93, 0xD1, 0xF7,
+         0x41, 0x02, 0x19, 0xD3, 0xD1, 0xF7, 0x11, 0x93, 0xD0, 0xF7, 0x09, 0xA3, 0x40, 0x00, 0x19, 0xD3, 0xD0, 0xF7, 0x09, 0x63, 0x00, 0x80, 0x01, 0x95, 0xC2, 0x94, 0x1A, 0xD5, 0x94, 0xEC, 0x40, 0x96,
+         0x1B, 0xD7, 0x93, 0xEC, 0x0F, 0x9F, 0xBA, 0xF3, 0x11, 0x93, 0x6D, 0xEC, 0x12, 0x95, 0x95, 0xEC, 0x02, 0x43, 0x02, 0x8E, 0x0F, 0x9F, 0xA2, 0xF3, 0x02, 0x0E, 0x0F, 0x9F, 0x75, 0xF3, 0x11, 0x93,
+         0xD1, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0xD1, 0xF7, 0x11, 0x93, 0xD0, 0xF7, 0x09, 0xA3, 0x80, 0x00, 0x19, 0xD3, 0xD0, 0xF7, 0x09, 0x63, 0x00, 0x80, 0x01, 0x95, 0xC2, 0x94, 0x1A, 0xD5, 0x94, 0xEC,
+         0x40, 0x96, 0x1B, 0xD7, 0x93, 0xEC, 0x0F, 0x9F, 0xBA, 0xF3, 0x11, 0x93, 0x03, 0x80, 0x09, 0xB3, 0x00, 0x40, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x87, 0xF3, 0x11, 0x93, 0x98, 0xEC, 0x40, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0x87, 0xF3, 0x40, 0xF0, 0xCE, 0xF3, 0x0F, 0x9F, 0xBC, 0xF3, 0x41, 0x92, 0xC8, 0xD2, 0x0A, 0x95, 0x6C, 0xEC, 0xC8, 0xD4, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x11, 0x93,
+         0x98, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x9A, 0xF3, 0x42, 0x96, 0x1B, 0xD7, 0x98, 0xEC, 0x0F, 0x9F, 0xBC, 0xF3, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x42, 0xA2, 0xC2, 0xD2,
+         0x0F, 0x9F, 0xBC, 0xF3, 0x12, 0x45, 0x03, 0xEC, 0x02, 0x4E, 0x0F, 0x9F, 0xB4, 0xF3, 0x11, 0x93, 0xD1, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0xD1, 0xF7, 0x11, 0x93, 0xD0, 0xF7, 0x09, 0xA3, 0x00, 0x08,
+         0x19, 0xD3, 0xD0, 0xF7, 0x1A, 0xD5, 0x6D, 0xEC, 0x11, 0x93, 0x6D, 0xEC, 0x19, 0x25, 0x6D, 0xEC, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xCE, 0xF3, 0x40, 0x92, 0xC8, 0xD2, 0x09, 0x93, 0x6C, 0xEC, 0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x11, 0x93, 0xCC, 0xF7, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xDE, 0xF3, 0x0A, 0x65, 0xBC, 0x69, 0x02, 0x97, 0xC3, 0x92, 0x09, 0x83, 0x00, 0x02, 0xC2, 0xD2, 0x11, 0x93, 0x94, 0xEC,
+         0x19, 0xD3, 0x04, 0x80, 0x12, 0x95, 0x93, 0xEC, 0x1A, 0xD5, 0x05, 0x80, 0x09, 0x63, 0x00, 0x80, 0x01, 0x97, 0xC3, 0x96, 0x1B, 0xD7, 0x94, 0xEC, 0x40, 0x94, 0x1A, 0xD5, 0x93, 0xEC, 0x19, 0xD3,
+         0xF2, 0xBD, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x20, 0x03, 0x19, 0xD3, 0x06, 0x82, 0x09, 0x93, 0x00, 0x01, 0x19, 0xD3, 0x03, 0x82, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0xC5, 0xD2, 0x12, 0x95, 0x04, 0x82, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x76, 0xF4, 0x0A, 0xA3, 0x02, 0x00,
+         0x19, 0xD3, 0x04, 0x82, 0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x28, 0xF4, 0x41, 0x96, 0xC5, 0xD6, 0x0A, 0x65, 0xBD, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x80, 0x00, 0xC2, 0xD2,
+         0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0x0F, 0x9F, 0x5C, 0xF4, 0x4F, 0x96, 0x12, 0x95, 0x01, 0x82, 0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0x32, 0xF4, 0x47, 0x96, 0x11, 0x93, 0x96, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x57, 0xF4, 0x44, 0x44, 0x02, 0x9E, 0x0F, 0x9F, 0x57, 0xF4, 0x12, 0x95, 0x00, 0x82, 0x0A, 0x05, 0xFF, 0xAF,
+         0x01, 0xD4, 0xC8, 0xD6, 0x41, 0x92, 0xC8, 0xD2, 0x40, 0xF0, 0x78, 0xF7, 0x42, 0x00, 0x01, 0x96, 0xC3, 0x94, 0x01, 0xB5, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x57, 0xF4, 0x02, 0x92, 0x50, 0x92,
+         0x19, 0xD3, 0xA2, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0xA2, 0xBC, 0x0F, 0x9F, 0x5D, 0xF4, 0x0A, 0x65, 0x5E, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x41, 0x92, 0x19, 0xD3, 0x96, 0xEC,
+         0x11, 0x93, 0x97, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x71, 0xF4, 0x13, 0x97, 0x00, 0x82, 0x1B, 0xD7, 0x02, 0x82, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x00, 0x01,
+         0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3, 0x97, 0xEC, 0x0F, 0x9F, 0x79, 0xF4, 0xC5, 0x96, 0x1B, 0xD7, 0x96, 0xEC, 0xC5, 0x92, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x85, 0xF4, 0x0A, 0x65, 0xEA, 0x43,
+         0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x43, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x09, 0x05, 0x01, 0x00, 0x42, 0x02,
+         0xC1, 0x96, 0xC2, 0x92, 0x03, 0x22, 0x40, 0x42, 0x02, 0xAE, 0x0F, 0x9F, 0x98, 0xF4, 0x03, 0x03, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x03, 0x80, 0x0A, 0xB3,
+         0x00, 0x40, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xB6, 0xF4, 0x0A, 0xB7, 0x00, 0x08, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0xB9, 0xF4, 0x11, 0x93, 0x03, 0xEC, 0x41, 0x02, 0x09, 0xB3, 0xFE, 0xFF,
+         0x12, 0x95, 0x07, 0x80, 0x01, 0x45, 0x02, 0x8E, 0x0F, 0x9F, 0xB9, 0xF4, 0x41, 0x92, 0x0F, 0x9F, 0xBA, 0xF4, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00,
+         0x42, 0x92, 0xC5, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x11, 0x93, 0x77, 0xEC, 0x09, 0x43, 0xA0, 0x00, 0x02, 0x5E, 0x0F, 0x9F, 0xE4, 0xF4,
+         0x09, 0x63, 0x08, 0x43, 0x0B, 0x67, 0xFF, 0x5F, 0x01, 0x95, 0xC2, 0xD6, 0x0A, 0x95, 0x7A, 0xEC, 0xD2, 0x96, 0x1B, 0xD7, 0xFA, 0xBC, 0xD2, 0x96, 0xC1, 0xD6, 0xD2, 0x92, 0x19, 0xD3, 0xFA, 0xBC,
+         0x1A, 0xD5, 0x77, 0xEC, 0x0F, 0x9F, 0x03, 0xF5, 0x0B, 0x67, 0xFF, 0x6F, 0x1B, 0xD7, 0xF8, 0xBC, 0x19, 0xD3, 0xFA, 0xBC, 0x09, 0xB5, 0x00, 0xFF, 0x0A, 0x45, 0x00, 0x9B, 0x02, 0x5E, 0x0F, 0x9F,
+         0xF7, 0xF4, 0x09, 0x03, 0xC9, 0x5C, 0x19, 0xD3, 0x77, 0xEC, 0x0F, 0x9F, 0x16, 0xF5, 0x0A, 0x45, 0x00, 0x99, 0x02, 0x5E, 0x0F, 0x9F, 0x07, 0xF5, 0x09, 0x03, 0x00, 0x67, 0x61, 0x93, 0x09, 0x03,
+         0x17, 0xF8, 0x19, 0xD3, 0x77, 0xEC, 0x41, 0x94, 0xC5, 0xD4, 0x0F, 0x9F, 0x18, 0xF5, 0x09, 0x43, 0x10, 0x95, 0x02, 0x4E, 0x0F, 0x9F, 0x12, 0xF5, 0x11, 0x93, 0x98, 0xEC, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x18, 0xF5, 0x0B, 0x97, 0x78, 0xEC, 0x1B, 0xD7, 0x77, 0xEC, 0x41, 0x92, 0xC5, 0xD2, 0x12, 0x95, 0x77, 0xEC, 0xC8, 0xD4, 0x40, 0xF0, 0x99, 0xF7, 0x19, 0xD3, 0xF8, 0xBC, 0x11, 0x93,
+         0x77, 0xEC, 0xC5, 0x96, 0x03, 0x03, 0xC1, 0x92, 0x19, 0xD3, 0xFA, 0xBC, 0x0A, 0x65, 0x52, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92,
+         0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x41, 0x00, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x06, 0x92, 0x01, 0xD2, 0x0A, 0x65, 0xF0, 0x6A, 0x0B, 0x97,
+         0x78, 0xEC, 0x02, 0x99, 0xC4, 0x98, 0xD3, 0xD8, 0x02, 0xD6, 0x0A, 0x03, 0x02, 0x00, 0x01, 0x97, 0xC3, 0x98, 0x02, 0x96, 0xC3, 0xD8, 0x01, 0x96, 0xC1, 0xD6, 0x1A, 0xD5, 0x77, 0xEC, 0xC5, 0x98,
+         0x14, 0x99, 0x78, 0xEC, 0xC2, 0xD8, 0x43, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0xC8, 0xD2, 0x40, 0xF0, 0x37, 0xF5, 0x41, 0x00, 0x11, 0x93, 0x98, 0xEC,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x71, 0xF5, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x6E, 0xF5, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x42, 0xA2, 0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3,
+         0x98, 0xEC, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x64, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0xAF, 0xBC, 0x47, 0xB2, 0x59, 0x93, 0x59, 0x93, 0x11, 0xA3, 0xBF, 0xBC, 0x21, 0xD2, 0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x95, 0xF5, 0x21, 0x92, 0x41, 0x02, 0x21, 0xD2, 0x05, 0x95, 0x40, 0x96, 0x20, 0xD6, 0x21, 0x96, 0x63, 0x93, 0x0F, 0x9F, 0xA5, 0xF5, 0x13, 0x97, 0xFC, 0xBC, 0xD2, 0xD6, 0x13, 0x97,
+         0xFE, 0xBC, 0xD2, 0xD6, 0x20, 0x96, 0x42, 0x06, 0x20, 0xD6, 0x20, 0x96, 0x01, 0x47, 0x02, 0x1E, 0x0F, 0x9F, 0x9C, 0xF5, 0xC5, 0x92, 0x63, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x7E, 0xF6, 0x02, 0x8E,
+         0x0F, 0x9F, 0xBC, 0xF5, 0x61, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x53, 0xF6, 0x62, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xD1, 0xF5, 0x0F, 0x9F, 0x88, 0xF6, 0x09, 0x43, 0x28, 0x01, 0x02, 0x4E, 0x0F, 0x9F,
+         0xE1, 0xF5, 0x02, 0x8E, 0x0F, 0x9F, 0xCA, 0xF5, 0x68, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xE8, 0xF5, 0x0F, 0x9F, 0x88, 0xF6, 0x09, 0x43, 0x28, 0x02, 0x02, 0x4E, 0x0F, 0x9F, 0x1B, 0xF6, 0x0F, 0x9F,
+         0x88, 0xF6, 0x01, 0x92, 0x19, 0xD3, 0x77, 0xEC, 0x09, 0x43, 0x10, 0x95, 0x02, 0x5E, 0x0F, 0x9F, 0x43, 0xF6, 0x11, 0x93, 0x12, 0x95, 0xC8, 0xD2, 0x40, 0xF0, 0x37, 0xF5, 0x41, 0x00, 0x0F, 0x9F,
+         0x43, 0xF6, 0x09, 0x63, 0x00, 0x08, 0x19, 0xD3, 0x76, 0xEC, 0x40, 0x94, 0x1A, 0xD5, 0x75, 0xEC, 0x40, 0x96, 0x20, 0xD6, 0x11, 0x93, 0x76, 0xEC, 0x09, 0x43, 0xF4, 0xFF, 0x02, 0x8E, 0x0F, 0x9F,
+         0x88, 0xF6, 0x0D, 0x07, 0x02, 0x00, 0x0D, 0x09, 0x01, 0x00, 0x04, 0x93, 0xC1, 0x94, 0x42, 0x08, 0x0A, 0xB5, 0xFF, 0x00, 0x03, 0x93, 0xC1, 0x92, 0x42, 0x06, 0x59, 0x93, 0x59, 0x93, 0x23, 0xD2,
+         0x01, 0xA5, 0x11, 0x93, 0x76, 0xEC, 0xC1, 0xD4, 0x12, 0x95, 0x76, 0xEC, 0x11, 0x93, 0x75, 0xEC, 0xD2, 0x82, 0x19, 0xD3, 0x75, 0xEC, 0x1A, 0xD5, 0x76, 0xEC, 0x20, 0x92, 0x42, 0x02, 0x20, 0xD2,
+         0x47, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x88, 0xF6, 0x0A, 0x45, 0xF4, 0xFF, 0x02, 0x9E, 0x0F, 0x9F, 0xF5, 0xF5, 0x0F, 0x9F, 0x88, 0xF6, 0x11, 0x93, 0x75, 0xEC, 0x09, 0xB5, 0xFF, 0x00, 0x79, 0x93,
+         0x79, 0x93, 0x01, 0x85, 0x1A, 0xD5, 0x75, 0xEC, 0x01, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0x40, 0xF6, 0x6F, 0x94, 0x1A, 0xD5, 0x05, 0x84, 0x40, 0xF1, 0x0B, 0x97, 0xF7, 0x07, 0xC8, 0xD6, 0x09, 0x63,
+         0x00, 0x08, 0xC8, 0xD2, 0x40, 0x94, 0xC8, 0xD4, 0x40, 0xF0, 0x53, 0xEE, 0x43, 0xF1, 0x6D, 0x96, 0x1B, 0xD7, 0x05, 0x84, 0x41, 0x92, 0x19, 0xD3, 0x77, 0xEC, 0x43, 0x00, 0x0F, 0x9F, 0x43, 0xF6,
+         0x40, 0x94, 0x1A, 0xD5, 0x77, 0xEC, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF,
+         0xC2, 0xD2, 0x0F, 0x9F, 0x88, 0xF6, 0x0D, 0x03, 0x04, 0x00, 0xC8, 0xD2, 0x01, 0x92, 0xC8, 0xD2, 0x40, 0xF0, 0xE5, 0xF0, 0x21, 0x94, 0x0A, 0x03, 0xF4, 0xFF, 0x61, 0x93, 0x21, 0xD2, 0x40, 0x96,
+         0x20, 0xD6, 0x42, 0x00, 0x01, 0x47, 0x02, 0x0E, 0x0F, 0x9F, 0x88, 0xF6, 0x0D, 0x05, 0x06, 0x00, 0x20, 0x92, 0x05, 0x03, 0x47, 0x02, 0xC8, 0xD2, 0x02, 0x97, 0xC3, 0x92, 0x43, 0x04, 0xC8, 0xD2,
+         0x22, 0xD4, 0x40, 0xF0, 0xE5, 0xF0, 0x42, 0x00, 0x20, 0x92, 0x43, 0x02, 0x20, 0xD2, 0x22, 0x94, 0x21, 0x42, 0x02, 0x1E, 0x0F, 0x9F, 0x68, 0xF6, 0x0F, 0x9F, 0x88, 0xF6, 0x02, 0x94, 0xC8, 0xD4,
+         0x01, 0x96, 0xC8, 0xD6, 0x04, 0x92, 0x05, 0x94, 0x90, 0xD4, 0x40, 0xF0, 0x8B, 0xF6, 0x44, 0x00, 0x64, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x47, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03,
+         0x0A, 0x00, 0x0A, 0x96, 0x0B, 0x98, 0x09, 0x05, 0x02, 0x00, 0xC2, 0x94, 0xC5, 0xD4, 0x43, 0x02, 0xC1, 0x92, 0x01, 0xD2, 0x02, 0xD2, 0x5F, 0x92, 0x01, 0x94, 0x02, 0x23, 0xC8, 0xD2, 0x90, 0xD8,
+         0x40, 0xF0, 0x52, 0xF7, 0x43, 0x00, 0x01, 0x97, 0x02, 0x99, 0x11, 0x93, 0x80, 0x96, 0x09, 0xB5, 0x7F, 0xFF, 0x1A, 0xD5, 0x80, 0x96, 0xC5, 0x94, 0x0A, 0x83, 0xFF, 0xFF, 0x11, 0xB3, 0x2C, 0x93,
+         0x09, 0xB3, 0xFB, 0xFF, 0x19, 0xD3, 0x2C, 0x93, 0x01, 0x92, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xE5, 0xF6, 0x41, 0x94, 0xC8, 0xD4, 0x90, 0xD8, 0x40, 0xF0, 0x52, 0xF7, 0x43, 0x00, 0x01, 0x97,
+         0x02, 0x99, 0x40, 0x48, 0x05, 0x3E, 0x02, 0x4E, 0x40, 0x46, 0x02, 0x0E, 0x0F, 0x9F, 0xCD, 0xF6, 0x11, 0x93, 0x2C, 0x93, 0x48, 0xA2, 0x0F, 0x9F, 0xD1, 0xF6, 0x11, 0x93, 0x2C, 0x93, 0x09, 0xB3,
+         0xF7, 0xFF, 0x19, 0xD3, 0x2C, 0x93, 0x03, 0x92, 0x11, 0x93, 0x2C, 0x93, 0x44, 0xA2, 0x19, 0xD3, 0x2C, 0x93, 0x09, 0xB3, 0xFB, 0xFF, 0x19, 0xD3, 0x2C, 0x93, 0x02, 0x94, 0x0A, 0x05, 0xFF, 0xFF,
+
+         0x02, 0xD4, 0x40, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0xB9, 0xF6, 0x09, 0x63, 0xD4, 0x6C, 0x01, 0x95, 0xC2, 0x96, 0xC5, 0x94, 0x02, 0xA7, 0xC1, 0xD6, 0x01, 0x92, 0x54, 0x42, 0x02, 0x5E, 0x0F, 0x9F,
+         0xF5, 0xF6, 0x0A, 0x83, 0xFF, 0xFF, 0x1B, 0xB3, 0x2C, 0x93, 0x0A, 0x65, 0x80, 0x69, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x80, 0x00, 0xC2, 0xD2, 0x47, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x40, 0x19, 0xD3, 0xF2, 0xBD, 0x40, 0xF0, 0x9A, 0xF4, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x10, 0xF7, 0x40, 0xF0, 0xBC, 0xF2, 0x0F, 0x9F, 0x1E, 0xF7,
+         0x40, 0x96, 0xC8, 0xD6, 0x09, 0x93, 0x6C, 0xEC, 0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF,
+         0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3, 0x2D, 0xBC, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00,
+         0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x11, 0x93, 0x03, 0xEC, 0x19, 0xD3, 0x01, 0x82, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97, 0xC3, 0x92, 0x43, 0xA2, 0xC2, 0xD2,
+         0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x03, 0x92, 0x04, 0x94, 0x05, 0x96, 0x40, 0xF0, 0x5C, 0xF7, 0x88, 0x98, 0x90, 0x9A, 0x03, 0x97, 0x19, 0x5E, 0x60, 0x46, 0x03, 0x0E,
+         0x40, 0x94, 0x40, 0x92, 0x90, 0x9A, 0x44, 0x46, 0x05, 0x0E, 0x59, 0x93, 0x9A, 0x95, 0x44, 0x26, 0x0E, 0x5E, 0x47, 0xEE, 0x0E, 0xBD, 0xBF, 0xFF, 0x09, 0xC3, 0x00, 0x80, 0x02, 0x5E, 0x0E, 0xAD,
+         0x40, 0x00, 0x41, 0x93, 0x42, 0x95, 0x01, 0x0E, 0x41, 0xA4, 0x41, 0x26, 0x4D, 0x4E, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x03, 0x92, 0x04, 0x96, 0x0D, 0x5E, 0x50, 0x46, 0x02, 0x0E,
+         0x40, 0x92, 0x09, 0xEE, 0x44, 0x46, 0x04, 0x0E, 0x59, 0x93, 0x44, 0x26, 0x04, 0x5E, 0x46, 0xEE, 0x41, 0x93, 0x41, 0x26, 0x43, 0x4E, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00,
+         0x40, 0xF0, 0xB1, 0xFE, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x03, 0x94, 0x1A, 0xD5, 0xA0, 0xF7, 0x11, 0x93,
+         0x00, 0x90, 0x88, 0x98, 0x90, 0x9A, 0x1D, 0x00, 0x1A, 0x00, 0x03, 0x00, 0x03, 0x00, 0x18, 0x00, 0x19, 0x00, 0x1A, 0x00, 0x1B, 0x00, 0x16, 0x00, 0x21, 0x00, 0x12, 0x00, 0x09, 0x00, 0x13, 0x00,
+         0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x21, 0x00, 0x2D, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0xF2, 0xC2, 0xF7, 0x00, 0x00,
+         0x9C, 0xF2, 0xC2, 0xF7, 0x00, 0x00, 0xE1, 0xF2, 0xBF, 0xF7, 0xC6, 0xF7, 0x00, 0x00, 0xBF, 0xF3, 0xC2, 0xF7, 0x30, 0x43, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+ };
+#elif defined(ZD1211B)
+={
+         0x08, 0x91, 0xFF, 0xED, 0x09, 0x93, 0x1E, 0xEE, 0xD1, 0x94, 0x11, 0xEE, 0x88, 0xD4, 0xD1, 0x96, 0xD1, 0x98, 0x5C, 0x99, 0x5C, 0x99, 0x4C, 0x99, 0x04, 0x9D, 0xD1, 0x98, 0xD1, 0x9A, 0x03, 0xEE,
+         0xF4, 0x94, 0xD3, 0xD4, 0x41, 0x2A, 0x40, 0x4A, 0x45, 0xBE, 0x88, 0x92, 0x41, 0x24, 0x40, 0x44, 0x53, 0xBE, 0x40, 0xF0, 0x93, 0xEE, 0x41, 0xEE, 0x98, 0x9A, 0xC9, 0xF7, 0x02, 0x00, 0x1F, 0xEC,
+         0x00, 0x00, 0xB2, 0xF8, 0x4D, 0x00, 0x80, 0xEC, 0x00, 0x00, 0xA3, 0xF7, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xD8, 0xA0, 0x90, 0x98, 0x9A, 0x98, 0x9A, 0xA0, 0xD8,
+         0x40, 0xF0, 0x98, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0x64, 0xEF, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0xDA, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0,
+         0xFF, 0xF6, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0x56, 0xF5, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0xD5, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0,
+         0x94, 0xF7, 0xA0, 0x90, 0x98, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x42, 0x02, 0xC1, 0x92, 0x03, 0x96, 0x1B, 0xD7, 0x2A, 0x86,
+         0x1A, 0xD5, 0x2B, 0x86, 0x09, 0xA3, 0x00, 0x80, 0x19, 0xD3, 0x2C, 0x86, 0x00, 0xEE, 0x0A, 0x65, 0xC0, 0x7A, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFE, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x05, 0x00, 0x05, 0x94, 0xC5, 0xD4, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x01, 0xD4, 0x42, 0x02, 0xC1, 0x96, 0x0A, 0x65, 0xC0, 0x7A,
+         0x02, 0x99, 0xC4, 0x92, 0x41, 0xA2, 0xC4, 0xD2, 0xC5, 0x98, 0x1C, 0xD9, 0x2A, 0x86, 0x01, 0x98, 0x1C, 0xD9, 0x2B, 0x86, 0x1B, 0xD7, 0x2C, 0x86, 0x00, 0xEE, 0x09, 0xB3, 0xFE, 0xFF, 0xC2, 0xD2,
+         0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xE5, 0xEE, 0x11, 0x93, 0xCD, 0xF7, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xAE, 0xEE, 0x40, 0xF1,
+         0x40, 0x92, 0x19, 0xD3, 0xCD, 0xF7, 0xC5, 0x92, 0x41, 0x92, 0x19, 0xD3, 0x00, 0x83, 0x40, 0x92, 0x19, 0xD3, 0x00, 0x83, 0x0F, 0x9F, 0x95, 0xF8, 0x0F, 0x9F, 0x99, 0xEE, 0x42, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0x99, 0xEE, 0x40, 0x92, 0x19, 0xD3, 0xCD, 0xF7, 0x09, 0x93, 0xBC, 0xF7, 0x19, 0xD3, 0x6C, 0xEC, 0x40, 0xF0, 0x87, 0xF2, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x0F, 0x9F,
+         0x99, 0xEE, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x12, 0x95, 0x19, 0xD3, 0x10, 0x95, 0x19, 0xD3, 0x02, 0x80, 0x19, 0xD3, 0x03, 0x82,
+         0x09, 0x93, 0xBC, 0xF7, 0x19, 0xD3, 0x6C, 0xEC, 0x40, 0xF0, 0x87, 0xF2, 0x40, 0xF0, 0xF3, 0xF3, 0x11, 0x93, 0x04, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xE3, 0xEE, 0x40, 0x92, 0x19, 0xD3,
+         0x04, 0xEC, 0x40, 0xF0, 0x60, 0xF2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x44, 0x96, 0x09, 0xB3, 0xFF, 0xFD, 0x19, 0xD3, 0x44, 0x96, 0x40, 0xF0, 0x8D, 0xF7,
+         0x6E, 0x92, 0x19, 0xD3, 0x05, 0x84, 0x40, 0xF0, 0xC4, 0xEE, 0x4B, 0x62, 0x0A, 0x95, 0x2E, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x2B, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x00, 0xEE, 0xD1, 0xD4, 0x0B, 0x97,
+         0x2F, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x34, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x39, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x3E, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x43, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x48, 0xEE,
+         0xD1, 0xD4, 0x0B, 0x97, 0x4D, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x4E, 0xEE, 0xC1, 0xD4, 0x0A, 0x65, 0x00, 0x44, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x43, 0xF1, 0x09, 0x93, 0x01, 0x3F,
+         0x19, 0xD3, 0xC0, 0x85, 0x11, 0x93, 0x44, 0x96, 0x09, 0xB3, 0xFF, 0xFC, 0x19, 0xD3, 0x44, 0x96, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x03, 0x96,
+         0x41, 0x02, 0x03, 0x99, 0xC4, 0x94, 0x42, 0x04, 0xC1, 0x04, 0xC2, 0x94, 0xC3, 0xD4, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x6E, 0xEC, 0x13, 0x97,
+         0x6F, 0xEC, 0x1B, 0xD7, 0x02, 0x80, 0x11, 0x93, 0x73, 0xEC, 0x19, 0xD3, 0x7C, 0x96, 0x0B, 0x97, 0xA0, 0x00, 0x1B, 0xD7, 0x77, 0xEC, 0x0A, 0x65, 0x0E, 0x42, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3,
+         0xFF, 0xBF, 0x11, 0xA3, 0x74, 0xEC, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3,
+         0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x47, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x14, 0x99, 0x03, 0x80, 0x0C, 0xB3, 0x00, 0x10, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x7B, 0xF0,
+         0x11, 0x93, 0x7E, 0xEC, 0x41, 0x02, 0x19, 0xD3, 0x7E, 0xEC, 0x11, 0x93, 0xCB, 0xF7, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x84, 0xEF, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3,
+         0x00, 0x04, 0xC2, 0xD2, 0x0F, 0x9F, 0x95, 0xF0, 0x11, 0x93, 0x6E, 0xEC, 0x02, 0xD2, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xD0, 0xEF, 0x41, 0x92, 0x19, 0xD3, 0x6E, 0xEC, 0x19, 0xD3, 0x7E, 0xEC,
+         0x12, 0x95, 0x02, 0x80, 0x1A, 0xD5, 0x6F, 0xEC, 0x13, 0x97, 0x7C, 0x96, 0x1B, 0xD7, 0x73, 0xEC, 0x0A, 0x65, 0x0E, 0x42, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x00, 0x40, 0x19, 0xD3, 0x74, 0xEC,
+         0x09, 0x63, 0x00, 0x40, 0xC2, 0xD2, 0x02, 0x94, 0x1A, 0xD5, 0x7C, 0x96, 0x0C, 0xB3, 0x00, 0x08, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xB0, 0xEF, 0x0C, 0xB3, 0xFF, 0x07, 0x0F, 0x9F, 0xB4, 0xEF,
+         0x11, 0x93, 0x06, 0x80, 0x09, 0xB3, 0xFF, 0x07, 0x09, 0x03, 0x00, 0xA0, 0x19, 0xD3, 0x71, 0xEC, 0x40, 0x98, 0x0B, 0x97, 0x7B, 0xEC, 0x04, 0x95, 0x03, 0x05, 0x14, 0x03, 0x71, 0xEC, 0x46, 0x02,
+         0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x08, 0x42, 0x48, 0x02, 0x9E, 0x0F, 0x9F, 0xBB, 0xEF, 0x11, 0x93, 0x71, 0xEC, 0xC1, 0x92, 0xC5, 0xD2, 0x5F, 0xB2, 0x19, 0xD3, 0x7A, 0xEC, 0x0F, 0x9F, 0xD3, 0xEF,
+         0x13, 0x97, 0x72, 0xEC, 0xC5, 0xD6, 0x12, 0x95, 0x7A, 0xEC, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x70, 0xF0, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xF1, 0xEF, 0x0A, 0xB3,
+         0x07, 0x00, 0x09, 0x05, 0x88, 0xEC, 0xC2, 0x94, 0x01, 0xD4, 0x09, 0x03, 0x80, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x7A, 0xEC, 0xC5, 0x98, 0x0C, 0xB9, 0x00, 0xFF, 0x01, 0xA9, 0xC5, 0xD8, 0x0F, 0x9F,
+         0xFD, 0xEF, 0x0A, 0x05, 0xFF, 0xFF, 0x0A, 0x03, 0x90, 0xEC, 0xC1, 0x92, 0x01, 0xD2, 0x1A, 0xD5, 0x7A, 0xEC, 0xC5, 0x92, 0x09, 0x03, 0xFF, 0xFF, 0xC5, 0xD2, 0x11, 0x93, 0x71, 0xEC, 0xC5, 0x94,
+         0xC1, 0xD4, 0x11, 0x93, 0x71, 0xEC, 0x09, 0x07, 0x0B, 0x00, 0x03, 0xD6, 0xC3, 0x98, 0x06, 0xD8, 0x7C, 0x95, 0x7A, 0x95, 0x4C, 0x02, 0xC1, 0x92, 0x59, 0x93, 0x59, 0x93, 0x01, 0xA5, 0x01, 0x98,
+         0x0C, 0xF5, 0x7B, 0x93, 0x09, 0x09, 0x01, 0x00, 0x06, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x04, 0xD2, 0x5C, 0x93, 0x59, 0x93, 0x04, 0x94, 0x01, 0xA5, 0x03, 0x96, 0xC3, 0xD4, 0x11, 0x93, 0x71, 0xEC,
+         0x4C, 0x02, 0x05, 0xD2, 0xC1, 0x92, 0x09, 0xB3, 0x00, 0xFF, 0x7C, 0x95, 0x7A, 0x95, 0x02, 0xA3, 0x05, 0x98, 0xC4, 0xD2, 0x12, 0x95, 0x71, 0xEC, 0x45, 0x04, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3,
+         0x00, 0x01, 0xC2, 0xD2, 0x12, 0x95, 0x7A, 0xEC, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x45, 0xF0, 0x12, 0x95, 0x71, 0xEC, 0x4A, 0x04, 0x02, 0x99, 0xC4, 0x92, 0x01, 0x98,
+         0x0C, 0xF3, 0x7B, 0x93, 0x41, 0x02, 0x0F, 0x9F, 0x66, 0xF0, 0x43, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x67, 0xF0, 0x11, 0x93, 0x71, 0xEC, 0x42, 0x02, 0x0A, 0x05, 0xFF, 0xFF, 0xC1, 0xD4, 0x11, 0x93,
+         0x71, 0xEC, 0x4A, 0x02, 0x12, 0x95, 0x60, 0x96, 0xC1, 0xD4, 0x12, 0x95, 0x71, 0xEC, 0x4B, 0x04, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x1F, 0xFF, 0xC2, 0xD2, 0x12, 0x95, 0x71, 0xEC, 0x4B, 0x04,
+         0x11, 0x93, 0x62, 0x96, 0x41, 0x93, 0x59, 0x93, 0x02, 0x99, 0xC4, 0xA2, 0xC2, 0xD2, 0xC5, 0x92, 0x19, 0xD3, 0x72, 0xEC, 0x0A, 0x95, 0x0C, 0x02, 0x1A, 0xD5, 0x02, 0x80, 0x0F, 0x9F, 0x95, 0xF0,
+         0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x00, 0x04, 0xC2, 0xD2, 0x40, 0xF0, 0x39, 0xEF, 0x0F, 0x9F, 0x95, 0xF0, 0x11, 0x93, 0x6E, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F,
+         0x8A, 0xF0, 0x40, 0xF0, 0x39, 0xEF, 0x11, 0x93, 0x6F, 0xEC, 0x44, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x95, 0xF0, 0x48, 0x98, 0x1C, 0xD9, 0x02, 0x80, 0x11, 0x93, 0x6C, 0xEC, 0x41, 0x22,
+         0x0A, 0x95, 0x95, 0xF0, 0x88, 0xD4, 0x88, 0xDC, 0x91, 0x9A, 0x47, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x04, 0x82, 0x48, 0xB2, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0xAC, 0xF0, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFF, 0xFE, 0xC2, 0xD2, 0x41, 0x92, 0x19, 0xD3, 0x97, 0xEC, 0x11, 0x93, 0x04, 0x82, 0x43, 0xB2, 0x12, 0x95,
+         0x03, 0x82, 0x02, 0xB3, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xD3, 0xF0, 0x0A, 0xB3, 0x00, 0xFF, 0x48, 0xA2, 0x19, 0xD3, 0x03, 0x82, 0x40, 0xF0, 0x00, 0xF4, 0x11, 0x93, 0x97, 0xEC, 0x41, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0xD3, 0xF0, 0x11, 0x93, 0x07, 0x82, 0x11, 0x43, 0x03, 0xEC, 0x02, 0x0E, 0x0F, 0x9F, 0xD3, 0xF0, 0x11, 0x93, 0x03, 0x82, 0x09, 0xA3, 0x00, 0x01, 0x19, 0xD3, 0x03, 0x82,
+         0x40, 0x96, 0x1B, 0xD7, 0x97, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x20, 0xBC, 0xC8, 0xD2,
+         0x40, 0xF0, 0x70, 0xF1, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x44, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x07, 0x00, 0x07, 0x96, 0x41, 0x02, 0xC1, 0x92, 0x02, 0xD2, 0x0B, 0xB3,
+         0x00, 0xFF, 0x09, 0x43, 0x00, 0x9B, 0x02, 0x5E, 0x0F, 0x9F, 0xFF, 0xF0, 0x0B, 0x03, 0xC9, 0x5C, 0x02, 0x94, 0xD2, 0x96, 0xD1, 0xD6, 0xC2, 0x98, 0xC1, 0xD8, 0x0F, 0x9F, 0x6D, 0xF1, 0x09, 0x43,
+         0x00, 0x99, 0x02, 0x5E, 0x0F, 0x9F, 0x20, 0xF1, 0x0B, 0x03, 0x00, 0x67, 0x61, 0x97, 0x0B, 0x03, 0x17, 0xF8, 0x02, 0x94, 0xD2, 0x98, 0xC1, 0xD8, 0xC2, 0x94, 0xD9, 0xD4, 0x03, 0xD2, 0x40, 0x46,
+         0x02, 0x5E, 0x0F, 0x9F, 0x6D, 0xF1, 0x09, 0x03, 0xFF, 0xFF, 0x0B, 0x97, 0x7E, 0x00, 0xC8, 0xD6, 0xC8, 0xD2, 0x57, 0x98, 0xC8, 0xD8, 0x40, 0xF0, 0x53, 0xEE, 0x43, 0x00, 0x0F, 0x9F, 0x6D, 0xF1,
+         0x0B, 0xB3, 0x00, 0xF0, 0x09, 0x43, 0x00, 0x90, 0x02, 0x5E, 0x0F, 0x9F, 0x30, 0xF1, 0x0B, 0x03, 0x02, 0x00, 0xC5, 0xD2, 0x02, 0x94, 0x0A, 0x03, 0x01, 0x00, 0xC1, 0x92, 0xC5, 0x98, 0xC4, 0xD2,
+         0x02, 0x92, 0xC1, 0x94, 0x03, 0x93, 0xC1, 0xD4, 0x0B, 0x47, 0x00, 0x95, 0x02, 0x5E, 0x0F, 0x9F, 0x6D, 0xF1, 0x02, 0x96, 0xC3, 0x92, 0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x6D, 0xF1,
+         0x11, 0x93, 0x98, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x6D, 0xF1, 0x41, 0x98, 0x1C, 0xD9, 0x98, 0xEC, 0x12, 0x95, 0x02, 0x80, 0x01, 0xD4, 0x40, 0xF0, 0x7E, 0xF2, 0x0B, 0x67, 0xFD, 0x7D,
+         0x03, 0x99, 0xC4, 0x92, 0x0C, 0x99, 0x20, 0x03, 0x1C, 0xD9, 0x06, 0x82, 0x41, 0x98, 0x1C, 0xD9, 0x02, 0x82, 0x42, 0x98, 0x1C, 0xD9, 0x05, 0x82, 0x0C, 0x69, 0x80, 0x7F, 0x1C, 0xD9, 0x00, 0xB0,
+         0x09, 0xA3, 0x00, 0x01, 0xC3, 0xD2, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x6B, 0xF1, 0x42, 0xA4, 0x1A, 0xD5, 0x02, 0x80, 0x44, 0x00, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x05, 0x92, 0xC5, 0xD2, 0x60, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x7D, 0xF1, 0x40, 0xF0, 0x3D, 0xF7, 0xC5, 0x94, 0x0A, 0xB3, 0x10, 0x00,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x86, 0xF1, 0x40, 0xF0, 0x81, 0xF5, 0xC5, 0x96, 0x0B, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x8F, 0xF1, 0x40, 0xF0, 0xBC, 0xF4, 0xC5, 0x94,
+         0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xF0, 0xF1, 0x13, 0x97, 0x21, 0xBC, 0x01, 0xD6, 0x0B, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xA1, 0xF1, 0x40, 0xF0,
+         0x62, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAA, 0xF1, 0x40, 0xF0, 0x6C, 0xFB, 0x01, 0x96, 0x0B, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0xCA, 0xF1, 0x40, 0xF0, 0xB0, 0xFA, 0x41, 0x92, 0x19, 0xD3, 0xCA, 0xF7, 0x11, 0x93, 0x03, 0xEC, 0x09, 0x43, 0x40, 0x00, 0x02, 0x5E, 0x0F, 0x9F, 0xC0, 0xF1, 0x40, 0x94, 0x1A, 0xD5, 0xCA, 0xF7,
+         0x11, 0x93, 0x00, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xD3, 0xF1, 0x40, 0xF0, 0x60, 0xF2, 0x0F, 0x9F, 0xD3, 0xF1, 0x01, 0x96, 0x0B, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0xD3, 0xF1, 0x40, 0xF0, 0x7C, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x10, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xDC, 0xF1, 0x40, 0xF0, 0x87, 0xFB, 0x11, 0x93, 0x10, 0xEC, 0x42, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0xE7, 0xF1, 0x44, 0x96, 0x1B, 0xD7, 0x0B, 0xBC, 0x0F, 0x9F, 0xED, 0xF1, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xED, 0xF1, 0x19, 0xD3, 0x0B, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x10, 0xEC,
+         0xC5, 0x94, 0x0A, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x3A, 0xF2, 0x13, 0x97, 0x28, 0xBC, 0x01, 0xD6, 0x0B, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x02, 0xF2,
+         0x40, 0xF0, 0x20, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x15, 0xF2, 0x40, 0xF0, 0xC4, 0xEE, 0x40, 0xF0, 0x8F, 0xFB, 0x40, 0xF0, 0x43, 0xF2, 0x40, 0x96,
+         0x1B, 0xD7, 0x00, 0xEC, 0x41, 0x92, 0x19, 0xD3, 0xCD, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x31, 0xF2, 0x40, 0xF0, 0x9E, 0xFB, 0x09, 0x63, 0x00, 0x44,
+         0x01, 0x97, 0xC3, 0x94, 0x48, 0xA4, 0xC1, 0xD4, 0x00, 0xEE, 0x40, 0x92, 0x19, 0xD3, 0x12, 0x95, 0x19, 0xD3, 0x10, 0x95, 0x19, 0xD3, 0x02, 0x80, 0x19, 0xD3, 0x03, 0x82, 0x41, 0x92, 0x19, 0xD3,
+         0xCD, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x3A, 0xF2, 0x40, 0xF0, 0xAE, 0xFB, 0x0A, 0x65, 0x00, 0x44, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2,
+         0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x40, 0x19, 0xD3, 0xF2, 0xBD, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2,
+         0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43,
+         0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x09, 0x93, 0x00, 0x01, 0x19, 0xD3, 0x02, 0x80, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x00, 0x09, 0x19, 0xD3, 0x02, 0x80, 0x40, 0xF0, 0x7E, 0xF2,
+         0x40, 0x92, 0x19, 0xD3, 0x6E, 0xEC, 0xC8, 0xD2, 0x09, 0x93, 0x6C, 0xEC, 0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0,
+         0x9A, 0xF4, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAD, 0xF2, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x0F, 0x9F, 0xBA, 0xF2, 0x40, 0xF0, 0xBC, 0xF2, 0x40, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0xBA, 0xF2, 0xC8, 0xD2, 0x09, 0x93, 0x6C, 0xEC, 0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93,
+         0xF1, 0xBD, 0x19, 0xD3, 0x95, 0xEC, 0x11, 0x93, 0x93, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xD4, 0xF2, 0x09, 0x63, 0x00, 0x80, 0x01, 0x97, 0xC3, 0x94, 0x0A, 0x07, 0x07, 0x00, 0xC1, 0xD6,
+         0x0A, 0x05, 0x00, 0xA0, 0x1A, 0xD5, 0x70, 0xEC, 0x11, 0x93, 0x95, 0xEC, 0x19, 0xD3, 0x01, 0x80, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x41, 0xA2, 0xC2, 0xD2, 0x40, 0x92, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x13, 0x97, 0x93, 0xEC, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0x54, 0xF3, 0x12, 0x95, 0x70, 0xEC, 0x0A, 0x03, 0x07, 0x00, 0xC1, 0x92,
+         0xC2, 0xD2, 0x11, 0x93, 0x70, 0xEC, 0x09, 0x05, 0x01, 0x00, 0x48, 0x02, 0xC1, 0x92, 0xC2, 0xD2, 0x11, 0x93, 0x70, 0xEC, 0x4E, 0x02, 0xC1, 0x94, 0xC5, 0xD6, 0xC5, 0x92, 0x11, 0x07, 0x70, 0xEC,
+         0x0B, 0x03, 0x0F, 0x00, 0xC1, 0x98, 0x46, 0x06, 0x7A, 0x93, 0x79, 0x93, 0x5C, 0x95, 0x5A, 0x95, 0x02, 0xA3, 0xC3, 0xD2, 0x04, 0x95, 0xC5, 0x96, 0x41, 0x06, 0xC5, 0xD6, 0x42, 0x46, 0x02, 0x9E,
+         0x0F, 0x9F, 0xFD, 0xF2, 0x11, 0x93, 0x70, 0xEC, 0x09, 0x05, 0x05, 0x00, 0x41, 0x02, 0xC1, 0x92, 0xC2, 0xD2, 0x11, 0x93, 0x70, 0xEC, 0xC1, 0x92, 0x09, 0xB5, 0x1F, 0x00, 0x43, 0x44, 0x02, 0x8E,
+         0x0F, 0x9F, 0x2A, 0xF3, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x2B, 0xF3, 0x0A, 0x05, 0xFF, 0xFF, 0x0F, 0x9F, 0x2B, 0xF3, 0x43, 0x94, 0x11, 0x93, 0x70, 0xEC, 0x42, 0x02, 0xC1, 0xD4, 0x11, 0x93,
+         0x70, 0xEC, 0x49, 0x02, 0xC1, 0x92, 0x19, 0xD3, 0x93, 0xEC, 0x09, 0x05, 0xF2, 0xFF, 0x1A, 0xD5, 0x6D, 0xEC, 0x09, 0x43, 0xD0, 0x07, 0x02, 0x9E, 0x0F, 0x9F, 0x54, 0xF3, 0x11, 0x93, 0xD1, 0xF7,
+         0x41, 0x02, 0x19, 0xD3, 0xD1, 0xF7, 0x11, 0x93, 0xD0, 0xF7, 0x09, 0xA3, 0x40, 0x00, 0x19, 0xD3, 0xD0, 0xF7, 0x09, 0x63, 0x00, 0x80, 0x01, 0x95, 0xC2, 0x94, 0x1A, 0xD5, 0x94, 0xEC, 0x40, 0x96,
+         0x1B, 0xD7, 0x93, 0xEC, 0x0F, 0x9F, 0xBA, 0xF3, 0x11, 0x93, 0x6D, 0xEC, 0x12, 0x95, 0x95, 0xEC, 0x02, 0x43, 0x02, 0x8E, 0x0F, 0x9F, 0xA2, 0xF3, 0x02, 0x0E, 0x0F, 0x9F, 0x75, 0xF3, 0x11, 0x93,
+         0xD1, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0xD1, 0xF7, 0x11, 0x93, 0xD0, 0xF7, 0x09, 0xA3, 0x80, 0x00, 0x19, 0xD3, 0xD0, 0xF7, 0x09, 0x63, 0x00, 0x80, 0x01, 0x95, 0xC2, 0x94, 0x1A, 0xD5, 0x94, 0xEC,
+         0x40, 0x96, 0x1B, 0xD7, 0x93, 0xEC, 0x0F, 0x9F, 0xBA, 0xF3, 0x11, 0x93, 0x03, 0x80, 0x09, 0xB3, 0x00, 0x40, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x87, 0xF3, 0x11, 0x93, 0x98, 0xEC, 0x40, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0x87, 0xF3, 0x40, 0xF0, 0xCE, 0xF3, 0x0F, 0x9F, 0xBC, 0xF3, 0x41, 0x92, 0xC8, 0xD2, 0x0A, 0x95, 0x6C, 0xEC, 0xC8, 0xD4, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x11, 0x93,
+         0x98, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x9A, 0xF3, 0x42, 0x96, 0x1B, 0xD7, 0x98, 0xEC, 0x0F, 0x9F, 0xBC, 0xF3, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x42, 0xA2, 0xC2, 0xD2,
+         0x0F, 0x9F, 0xBC, 0xF3, 0x12, 0x45, 0x03, 0xEC, 0x02, 0x4E, 0x0F, 0x9F, 0xB4, 0xF3, 0x11, 0x93, 0xD1, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0xD1, 0xF7, 0x11, 0x93, 0xD0, 0xF7, 0x09, 0xA3, 0x00, 0x08,
+         0x19, 0xD3, 0xD0, 0xF7, 0x1A, 0xD5, 0x6D, 0xEC, 0x11, 0x93, 0x6D, 0xEC, 0x19, 0x25, 0x6D, 0xEC, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xCE, 0xF3, 0x40, 0x92, 0xC8, 0xD2, 0x09, 0x93, 0x6C, 0xEC, 0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x11, 0x93, 0xCC, 0xF7, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xDE, 0xF3, 0x0A, 0x65, 0xBC, 0x69, 0x02, 0x97, 0xC3, 0x92, 0x09, 0x83, 0x00, 0x02, 0xC2, 0xD2, 0x11, 0x93, 0x94, 0xEC,
+         0x19, 0xD3, 0x04, 0x80, 0x12, 0x95, 0x93, 0xEC, 0x1A, 0xD5, 0x05, 0x80, 0x09, 0x63, 0x00, 0x80, 0x01, 0x97, 0xC3, 0x96, 0x1B, 0xD7, 0x94, 0xEC, 0x40, 0x94, 0x1A, 0xD5, 0x93, 0xEC, 0x19, 0xD3,
+         0xF2, 0xBD, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x20, 0x03, 0x19, 0xD3, 0x06, 0x82, 0x09, 0x93, 0x00, 0x01, 0x19, 0xD3, 0x03, 0x82, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0xC5, 0xD2, 0x12, 0x95, 0x04, 0x82, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x76, 0xF4, 0x0A, 0xA3, 0x02, 0x00,
+         0x19, 0xD3, 0x04, 0x82, 0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x28, 0xF4, 0x41, 0x96, 0xC5, 0xD6, 0x0A, 0x65, 0xBD, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x80, 0x00, 0xC2, 0xD2,
+         0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0x0F, 0x9F, 0x5C, 0xF4, 0x4F, 0x96, 0x12, 0x95, 0x01, 0x82, 0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0x32, 0xF4, 0x47, 0x96, 0x11, 0x93, 0x96, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x57, 0xF4, 0x44, 0x44, 0x02, 0x9E, 0x0F, 0x9F, 0x57, 0xF4, 0x12, 0x95, 0x00, 0x82, 0x0A, 0x05, 0xFF, 0xAF,
+         0x01, 0xD4, 0xC8, 0xD6, 0x41, 0x92, 0xC8, 0xD2, 0x40, 0xF0, 0x78, 0xF7, 0x42, 0x00, 0x01, 0x96, 0xC3, 0x94, 0x01, 0xB5, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x57, 0xF4, 0x02, 0x92, 0x50, 0x92,
+         0x19, 0xD3, 0xA2, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0xA2, 0xBC, 0x0F, 0x9F, 0x5D, 0xF4, 0x0A, 0x65, 0x5E, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x41, 0x92, 0x19, 0xD3, 0x96, 0xEC,
+         0x11, 0x93, 0x97, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x71, 0xF4, 0x13, 0x97, 0x00, 0x82, 0x1B, 0xD7, 0x02, 0x82, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x00, 0x01,
+         0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3, 0x97, 0xEC, 0x0F, 0x9F, 0x79, 0xF4, 0xC5, 0x96, 0x1B, 0xD7, 0x96, 0xEC, 0xC5, 0x92, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x85, 0xF4, 0x0A, 0x65, 0xEA, 0x43,
+         0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x43, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x09, 0x05, 0x01, 0x00, 0x42, 0x02,
+         0xC1, 0x96, 0xC2, 0x92, 0x03, 0x22, 0x40, 0x42, 0x02, 0xAE, 0x0F, 0x9F, 0x98, 0xF4, 0x03, 0x03, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x03, 0x80, 0x0A, 0xB3,
+         0x00, 0x40, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xB6, 0xF4, 0x0A, 0xB7, 0x00, 0x08, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0xB9, 0xF4, 0x11, 0x93, 0x03, 0xEC, 0x41, 0x02, 0x09, 0xB3, 0xFE, 0xFF,
+         0x12, 0x95, 0x07, 0x80, 0x01, 0x45, 0x02, 0x8E, 0x0F, 0x9F, 0xB9, 0xF4, 0x41, 0x92, 0x0F, 0x9F, 0xBA, 0xF4, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00,
+         0x42, 0x92, 0xC5, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x11, 0x93, 0x77, 0xEC, 0x09, 0x43, 0xA0, 0x00, 0x02, 0x5E, 0x0F, 0x9F, 0xE4, 0xF4,
+         0x09, 0x63, 0x08, 0x43, 0x0B, 0x67, 0xFF, 0x5F, 0x01, 0x95, 0xC2, 0xD6, 0x0A, 0x95, 0x7A, 0xEC, 0xD2, 0x96, 0x1B, 0xD7, 0xFA, 0xBC, 0xD2, 0x96, 0xC1, 0xD6, 0xD2, 0x92, 0x19, 0xD3, 0xFA, 0xBC,
+         0x1A, 0xD5, 0x77, 0xEC, 0x0F, 0x9F, 0x03, 0xF5, 0x0B, 0x67, 0xFF, 0x6F, 0x1B, 0xD7, 0xF8, 0xBC, 0x19, 0xD3, 0xFA, 0xBC, 0x09, 0xB5, 0x00, 0xFF, 0x0A, 0x45, 0x00, 0x9B, 0x02, 0x5E, 0x0F, 0x9F,
+         0xF7, 0xF4, 0x09, 0x03, 0xC9, 0x5C, 0x19, 0xD3, 0x77, 0xEC, 0x0F, 0x9F, 0x16, 0xF5, 0x0A, 0x45, 0x00, 0x99, 0x02, 0x5E, 0x0F, 0x9F, 0x07, 0xF5, 0x09, 0x03, 0x00, 0x67, 0x61, 0x93, 0x09, 0x03,
+         0x17, 0xF8, 0x19, 0xD3, 0x77, 0xEC, 0x41, 0x94, 0xC5, 0xD4, 0x0F, 0x9F, 0x18, 0xF5, 0x09, 0x43, 0x10, 0x95, 0x02, 0x4E, 0x0F, 0x9F, 0x12, 0xF5, 0x11, 0x93, 0x98, 0xEC, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x18, 0xF5, 0x0B, 0x97, 0x78, 0xEC, 0x1B, 0xD7, 0x77, 0xEC, 0x41, 0x92, 0xC5, 0xD2, 0x12, 0x95, 0x77, 0xEC, 0xC8, 0xD4, 0x40, 0xF0, 0x99, 0xF7, 0x19, 0xD3, 0xF8, 0xBC, 0x11, 0x93,
+         0x77, 0xEC, 0xC5, 0x96, 0x03, 0x03, 0xC1, 0x92, 0x19, 0xD3, 0xFA, 0xBC, 0x0A, 0x65, 0x52, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92,
+         0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x41, 0x00, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x06, 0x92, 0x01, 0xD2, 0x0A, 0x65, 0xF0, 0x6A, 0x0B, 0x97,
+         0x78, 0xEC, 0x02, 0x99, 0xC4, 0x98, 0xD3, 0xD8, 0x02, 0xD6, 0x0A, 0x03, 0x02, 0x00, 0x01, 0x97, 0xC3, 0x98, 0x02, 0x96, 0xC3, 0xD8, 0x01, 0x96, 0xC1, 0xD6, 0x1A, 0xD5, 0x77, 0xEC, 0xC5, 0x98,
+         0x14, 0x99, 0x78, 0xEC, 0xC2, 0xD8, 0x43, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0xC8, 0xD2, 0x40, 0xF0, 0x37, 0xF5, 0x41, 0x00, 0x11, 0x93, 0x98, 0xEC,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x71, 0xF5, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x6E, 0xF5, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x42, 0xA2, 0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3,
+         0x98, 0xEC, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x64, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0xAF, 0xBC, 0x47, 0xB2, 0x59, 0x93, 0x59, 0x93, 0x11, 0xA3, 0xBF, 0xBC, 0x21, 0xD2, 0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x95, 0xF5, 0x21, 0x92, 0x41, 0x02, 0x21, 0xD2, 0x05, 0x95, 0x40, 0x96, 0x20, 0xD6, 0x21, 0x96, 0x63, 0x93, 0x0F, 0x9F, 0xA5, 0xF5, 0x13, 0x97, 0xFC, 0xBC, 0xD2, 0xD6, 0x13, 0x97,
+         0xFE, 0xBC, 0xD2, 0xD6, 0x20, 0x96, 0x42, 0x06, 0x20, 0xD6, 0x20, 0x96, 0x01, 0x47, 0x02, 0x1E, 0x0F, 0x9F, 0x9C, 0xF5, 0xC5, 0x92, 0x63, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x7E, 0xF6, 0x02, 0x8E,
+         0x0F, 0x9F, 0xBC, 0xF5, 0x61, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x53, 0xF6, 0x62, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xD1, 0xF5, 0x0F, 0x9F, 0x88, 0xF6, 0x09, 0x43, 0x28, 0x01, 0x02, 0x4E, 0x0F, 0x9F,
+         0xE1, 0xF5, 0x02, 0x8E, 0x0F, 0x9F, 0xCA, 0xF5, 0x68, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xE8, 0xF5, 0x0F, 0x9F, 0x88, 0xF6, 0x09, 0x43, 0x28, 0x02, 0x02, 0x4E, 0x0F, 0x9F, 0x1B, 0xF6, 0x0F, 0x9F,
+         0x88, 0xF6, 0x01, 0x92, 0x19, 0xD3, 0x77, 0xEC, 0x09, 0x43, 0x10, 0x95, 0x02, 0x5E, 0x0F, 0x9F, 0x43, 0xF6, 0x11, 0x93, 0x12, 0x95, 0xC8, 0xD2, 0x40, 0xF0, 0x37, 0xF5, 0x41, 0x00, 0x0F, 0x9F,
+         0x43, 0xF6, 0x09, 0x63, 0x00, 0x08, 0x19, 0xD3, 0x76, 0xEC, 0x40, 0x94, 0x1A, 0xD5, 0x75, 0xEC, 0x40, 0x96, 0x20, 0xD6, 0x11, 0x93, 0x76, 0xEC, 0x09, 0x43, 0xF4, 0xFF, 0x02, 0x8E, 0x0F, 0x9F,
+         0x88, 0xF6, 0x0D, 0x07, 0x02, 0x00, 0x0D, 0x09, 0x01, 0x00, 0x04, 0x93, 0xC1, 0x94, 0x42, 0x08, 0x0A, 0xB5, 0xFF, 0x00, 0x03, 0x93, 0xC1, 0x92, 0x42, 0x06, 0x59, 0x93, 0x59, 0x93, 0x23, 0xD2,
+         0x01, 0xA5, 0x11, 0x93, 0x76, 0xEC, 0xC1, 0xD4, 0x12, 0x95, 0x76, 0xEC, 0x11, 0x93, 0x75, 0xEC, 0xD2, 0x82, 0x19, 0xD3, 0x75, 0xEC, 0x1A, 0xD5, 0x76, 0xEC, 0x20, 0x92, 0x42, 0x02, 0x20, 0xD2,
+         0x47, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x88, 0xF6, 0x0A, 0x45, 0xF4, 0xFF, 0x02, 0x9E, 0x0F, 0x9F, 0xF5, 0xF5, 0x0F, 0x9F, 0x88, 0xF6, 0x11, 0x93, 0x75, 0xEC, 0x09, 0xB5, 0xFF, 0x00, 0x79, 0x93,
+         0x79, 0x93, 0x01, 0x85, 0x1A, 0xD5, 0x75, 0xEC, 0x01, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0x40, 0xF6, 0x6F, 0x94, 0x1A, 0xD5, 0x05, 0x84, 0x40, 0xF1, 0x0B, 0x97, 0xF7, 0x07, 0xC8, 0xD6, 0x09, 0x63,
+         0x00, 0x08, 0xC8, 0xD2, 0x40, 0x94, 0xC8, 0xD4, 0x40, 0xF0, 0x53, 0xEE, 0x43, 0xF1, 0x6D, 0x96, 0x1B, 0xD7, 0x05, 0x84, 0x41, 0x92, 0x19, 0xD3, 0x77, 0xEC, 0x43, 0x00, 0x0F, 0x9F, 0x43, 0xF6,
+         0x40, 0x94, 0x1A, 0xD5, 0x77, 0xEC, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF,
+         0xC2, 0xD2, 0x0F, 0x9F, 0x88, 0xF6, 0x0D, 0x03, 0x04, 0x00, 0xC8, 0xD2, 0x01, 0x92, 0xC8, 0xD2, 0x40, 0xF0, 0xE5, 0xF0, 0x21, 0x94, 0x0A, 0x03, 0xF4, 0xFF, 0x61, 0x93, 0x21, 0xD2, 0x40, 0x96,
+         0x20, 0xD6, 0x42, 0x00, 0x01, 0x47, 0x02, 0x0E, 0x0F, 0x9F, 0x88, 0xF6, 0x0D, 0x05, 0x06, 0x00, 0x20, 0x92, 0x05, 0x03, 0x47, 0x02, 0xC8, 0xD2, 0x02, 0x97, 0xC3, 0x92, 0x43, 0x04, 0xC8, 0xD2,
+         0x22, 0xD4, 0x40, 0xF0, 0xE5, 0xF0, 0x42, 0x00, 0x20, 0x92, 0x43, 0x02, 0x20, 0xD2, 0x22, 0x94, 0x21, 0x42, 0x02, 0x1E, 0x0F, 0x9F, 0x68, 0xF6, 0x0F, 0x9F, 0x88, 0xF6, 0x02, 0x94, 0xC8, 0xD4,
+         0x01, 0x96, 0xC8, 0xD6, 0x04, 0x92, 0x05, 0x94, 0x90, 0xD4, 0x40, 0xF0, 0x8B, 0xF6, 0x44, 0x00, 0x64, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x47, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03,
+         0x0A, 0x00, 0x0A, 0x96, 0x0B, 0x98, 0x09, 0x05, 0x02, 0x00, 0xC2, 0x94, 0xC5, 0xD4, 0x43, 0x02, 0xC1, 0x92, 0x01, 0xD2, 0x02, 0xD2, 0x5F, 0x92, 0x01, 0x94, 0x02, 0x23, 0xC8, 0xD2, 0x90, 0xD8,
+         0x40, 0xF0, 0x52, 0xF7, 0x43, 0x00, 0x01, 0x97, 0x02, 0x99, 0x11, 0x93, 0x80, 0x96, 0x09, 0xB5, 0x7F, 0xFF, 0x1A, 0xD5, 0x80, 0x96, 0xC5, 0x94, 0x0A, 0x83, 0xFF, 0xFF, 0x11, 0xB3, 0x2C, 0x93,
+         0x09, 0xB3, 0xFB, 0xFF, 0x19, 0xD3, 0x2C, 0x93, 0x01, 0x92, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xE5, 0xF6, 0x41, 0x94, 0xC8, 0xD4, 0x90, 0xD8, 0x40, 0xF0, 0x52, 0xF7, 0x43, 0x00, 0x01, 0x97,
+         0x02, 0x99, 0x40, 0x48, 0x05, 0x3E, 0x02, 0x4E, 0x40, 0x46, 0x02, 0x0E, 0x0F, 0x9F, 0xCD, 0xF6, 0x11, 0x93, 0x2C, 0x93, 0x48, 0xA2, 0x0F, 0x9F, 0xD1, 0xF6, 0x11, 0x93, 0x2C, 0x93, 0x09, 0xB3,
+         0xF7, 0xFF, 0x19, 0xD3, 0x2C, 0x93, 0x03, 0x92, 0x11, 0x93, 0x2C, 0x93, 0x44, 0xA2, 0x19, 0xD3, 0x2C, 0x93, 0x09, 0xB3, 0xFB, 0xFF, 0x19, 0xD3, 0x2C, 0x93, 0x02, 0x94, 0x0A, 0x05, 0xFF, 0xFF,
+         0x02, 0xD4, 0x40, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0xB9, 0xF6, 0x09, 0x63, 0xD4, 0x6C, 0x01, 0x95, 0xC2, 0x96, 0xC5, 0x94, 0x02, 0xA7, 0xC1, 0xD6, 0x01, 0x92, 0x54, 0x42, 0x02, 0x5E, 0x0F, 0x9F,
+         0xF5, 0xF6, 0x0A, 0x83, 0xFF, 0xFF, 0x1B, 0xB3, 0x2C, 0x93, 0x0A, 0x65, 0x80, 0x69, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x80, 0x00, 0xC2, 0xD2, 0x47, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x40, 0x19, 0xD3, 0xF2, 0xBD, 0x40, 0xF0, 0x9A, 0xF4, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x10, 0xF7, 0x40, 0xF0, 0xBC, 0xF2, 0x0F, 0x9F, 0x1E, 0xF7,
+         0x40, 0x96, 0xC8, 0xD6, 0x09, 0x93, 0x6C, 0xEC, 0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF,
+         0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3, 0x2D, 0xBC, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00,
+         0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x11, 0x93, 0x03, 0xEC, 0x19, 0xD3, 0x01, 0x82, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97, 0xC3, 0x92, 0x43, 0xA2, 0xC2, 0xD2,
+         0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x03, 0x92, 0x04, 0x94, 0x05, 0x96, 0x40, 0xF0, 0x5C, 0xF7, 0x88, 0x98, 0x90, 0x9A, 0x03, 0x97, 0x19, 0x5E, 0x60, 0x46, 0x03, 0x0E,
+         0x40, 0x94, 0x40, 0x92, 0x90, 0x9A, 0x44, 0x46, 0x05, 0x0E, 0x59, 0x93, 0x9A, 0x95, 0x44, 0x26, 0x0E, 0x5E, 0x47, 0xEE, 0x0E, 0xBD, 0xBF, 0xFF, 0x09, 0xC3, 0x00, 0x80, 0x02, 0x5E, 0x0E, 0xAD,
+         0x40, 0x00, 0x41, 0x93, 0x42, 0x95, 0x01, 0x0E, 0x41, 0xA4, 0x41, 0x26, 0x4D, 0x4E, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x03, 0x92, 0x04, 0x96, 0x0D, 0x5E, 0x50, 0x46, 0x02, 0x0E,
+         0x40, 0x92, 0x09, 0xEE, 0x44, 0x46, 0x04, 0x0E, 0x59, 0x93, 0x44, 0x26, 0x04, 0x5E, 0x46, 0xEE, 0x41, 0x93, 0x41, 0x26, 0x43, 0x4E, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00,
+         0x40, 0xF0, 0xB1, 0xFE, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x03, 0x94, 0x1A, 0xD5, 0xA0, 0xF7, 0x11, 0x93,
+         0x00, 0x90, 0x88, 0x98, 0x90, 0x9A, 0x1D, 0x00, 0x1A, 0x00, 0x03, 0x00, 0x03, 0x00, 0x18, 0x00, 0x19, 0x00, 0x1A, 0x00, 0x1B, 0x00, 0x16, 0x00, 0x21, 0x00, 0x12, 0x00, 0x09, 0x00, 0x13, 0x00,
+         0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x21, 0x00, 0x2D, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0xF2, 0xC2, 0xF7, 0x00, 0x00,
+         0x9C, 0xF2, 0xC2, 0xF7, 0x00, 0x00, 0xE1, 0xF2, 0xBF, 0xF7, 0xC6, 0xF7, 0x00, 0x00, 0xBF, 0xF3, 0xC2, 0xF7, 0x30, 0x43, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+ };
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/WS11UPhR.h linux-2.4.35.3-mct/drivers/usb/zd1211/WS11UPhR.h
--- linux-2.4.35.3/drivers/usb/zd1211/WS11UPhR.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/WS11UPhR.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,328 @@
+#ifdef ZD1211
+={
+         0x08, 0x91, 0xFF, 0xED, 0x09, 0x93, 0x1E, 0xEE, 0xD1, 0x94, 0x11, 0xEE, 0x88, 0xD4, 0xD1, 0x96, 0xD1, 0x98, 0x5C, 0x99, 0x5C, 0x99, 0x4C, 0x99, 0x04, 0x9D, 0xD1, 0x98, 0xD1, 0x9A, 0x03, 0xEE,
+         0xF4, 0x94, 0xD3, 0xD4, 0x41, 0x2A, 0x40, 0x4A, 0x45, 0xBE, 0x88, 0x92, 0x41, 0x24, 0x40, 0x44, 0x53, 0xBE, 0x40, 0xF0, 0x93, 0xEE, 0x41, 0xEE, 0x98, 0x9A, 0xD4, 0xF7, 0x02, 0x00, 0x1F, 0xEC,
+         0x00, 0x00, 0xB2, 0xF8, 0x4D, 0x00, 0xA1, 0xEC, 0x00, 0x00, 0xA6, 0xF7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xD8, 0xA0, 0x90, 0x98, 0x9A, 0x98, 0x9A, 0xA0, 0xD8,
+         0x40, 0xF0, 0xB4, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0x64, 0xEF, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0xF6, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0,
+         0xF7, 0xF6, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0xF8, 0xF5, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0xF1, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0,
+         0x97, 0xF7, 0xA0, 0x90, 0x98, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x42, 0x02, 0xC1, 0x92, 0x03, 0x96, 0x1B, 0xD7, 0x2A, 0x86,
+         0x1A, 0xD5, 0x2B, 0x86, 0x09, 0xA3, 0x00, 0x80, 0x19, 0xD3, 0x2C, 0x86, 0x00, 0xEE, 0x0A, 0x65, 0xC0, 0x7A, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFE, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x05, 0x00, 0x05, 0x94, 0xC5, 0xD4, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x01, 0xD4, 0x42, 0x02, 0xC1, 0x96, 0x0A, 0x65, 0xC0, 0x7A,
+         0x02, 0x99, 0xC4, 0x92, 0x41, 0xA2, 0xC4, 0xD2, 0xC5, 0x98, 0x1C, 0xD9, 0x2A, 0x86, 0x01, 0x98, 0x1C, 0xD9, 0x2B, 0x86, 0x1B, 0xD7, 0x2C, 0x86, 0x00, 0xEE, 0x09, 0xB3, 0xFE, 0xFF, 0xC2, 0xD2,
+         0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xE5, 0xEE, 0x11, 0x93, 0xD8, 0xF7, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xAE, 0xEE, 0x40, 0xF1,
+         0x40, 0x92, 0x19, 0xD3, 0xD8, 0xF7, 0xC5, 0x92, 0x41, 0x92, 0x19, 0xD3, 0x00, 0x83, 0x40, 0x92, 0x19, 0xD3, 0x00, 0x83, 0x0F, 0x9F, 0x95, 0xF8, 0x0F, 0x9F, 0x99, 0xEE, 0x42, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0x99, 0xEE, 0x40, 0x92, 0x19, 0xD3, 0xD8, 0xF7, 0x09, 0x93, 0xC7, 0xF7, 0x19, 0xD3, 0x91, 0xEC, 0x40, 0xF0, 0x5F, 0xF2, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x0F, 0x9F,
+         0x99, 0xEE, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x12, 0x95, 0x19, 0xD3, 0x10, 0x95, 0x19, 0xD3, 0x02, 0x80, 0x19, 0xD3, 0x03, 0x82,
+         0x09, 0x93, 0xC7, 0xF7, 0x19, 0xD3, 0x91, 0xEC, 0x40, 0xF0, 0x5F, 0xF2, 0x40, 0xF0, 0xDE, 0xF3, 0x11, 0x93, 0x04, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xE3, 0xEE, 0x40, 0x92, 0x19, 0xD3,
+         0x04, 0xEC, 0x40, 0xF0, 0x38, 0xF2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x44, 0x96, 0x09, 0xB3, 0xFF, 0xFD, 0x19, 0xD3, 0x44, 0x96, 0x40, 0xF0, 0x90, 0xF7,
+         0x6E, 0x92, 0x19, 0xD3, 0x05, 0x84, 0x40, 0xF0, 0xC4, 0xEE, 0x4B, 0x62, 0x0A, 0x95, 0x2E, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x2B, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x00, 0xEE, 0xD1, 0xD4, 0x0B, 0x97,
+         0x2F, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x34, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x39, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x3E, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x43, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x48, 0xEE,
+         0xD1, 0xD4, 0x0B, 0x97, 0x4D, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x4E, 0xEE, 0xC1, 0xD4, 0x0A, 0x65, 0x00, 0x44, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x43, 0xF1, 0x09, 0x93, 0x01, 0x3F,
+         0x19, 0xD3, 0xC0, 0x85, 0x11, 0x93, 0x44, 0x96, 0x09, 0xB3, 0xFF, 0xFC, 0x19, 0xD3, 0x44, 0x96, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x03, 0x96,
+         0x41, 0x02, 0x03, 0x99, 0xC4, 0x94, 0x42, 0x04, 0xC1, 0x04, 0xC2, 0x94, 0xC3, 0xD4, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x94, 0xEC, 0x13, 0x97,
+         0x95, 0xEC, 0x1B, 0xD7, 0x02, 0x80, 0x11, 0x93, 0x99, 0xEC, 0x19, 0xD3, 0x7C, 0x96, 0x0B, 0x97, 0xA0, 0x00, 0x1B, 0xD7, 0x6E, 0xEC, 0x0A, 0x65, 0x0E, 0x42, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3,
+         0xFF, 0xBF, 0x11, 0xA3, 0x9A, 0xEC, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3,
+         0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x47, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x14, 0x99, 0x03, 0x80, 0x0C, 0xB3, 0x00, 0x10, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x97, 0xF0,
+         0x11, 0x93, 0x9F, 0xEC, 0x41, 0x02, 0x19, 0xD3, 0x9F, 0xEC, 0x11, 0x93, 0xD6, 0xF7, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x84, 0xEF, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3,
+         0x00, 0x04, 0xC2, 0xD2, 0x0F, 0x9F, 0xB1, 0xF0, 0x11, 0x93, 0x94, 0xEC, 0x02, 0xD2, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xD0, 0xEF, 0x41, 0x92, 0x19, 0xD3, 0x94, 0xEC, 0x19, 0xD3, 0x9F, 0xEC,
+         0x12, 0x95, 0x02, 0x80, 0x1A, 0xD5, 0x95, 0xEC, 0x13, 0x97, 0x7C, 0x96, 0x1B, 0xD7, 0x99, 0xEC, 0x0A, 0x65, 0x0E, 0x42, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x00, 0x40, 0x19, 0xD3, 0x9A, 0xEC,
+         0x09, 0x63, 0x00, 0x40, 0xC2, 0xD2, 0x02, 0x94, 0x1A, 0xD5, 0x7C, 0x96, 0x0C, 0xB3, 0x00, 0x08, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xB0, 0xEF, 0x0C, 0xB3, 0xFF, 0x07, 0x0F, 0x9F, 0xB4, 0xEF,
+         0x11, 0x93, 0x06, 0x80, 0x09, 0xB3, 0xFF, 0x07, 0x09, 0x03, 0x00, 0xA0, 0x19, 0xD3, 0x97, 0xEC, 0x40, 0x98, 0x0B, 0x97, 0x9C, 0xEC, 0x04, 0x95, 0x03, 0x05, 0x14, 0x03, 0x97, 0xEC, 0x46, 0x02,
+         0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x08, 0x42, 0x48, 0x02, 0x9E, 0x0F, 0x9F, 0xBB, 0xEF, 0x11, 0x93, 0x97, 0xEC, 0xC1, 0x92, 0xC5, 0xD2, 0x5F, 0xB2, 0x19, 0xD3, 0x9B, 0xEC, 0x0F, 0x9F, 0xD3, 0xEF,
+         0x13, 0x97, 0x98, 0xEC, 0xC5, 0xD6, 0x11, 0x93, 0x03, 0x80, 0x09, 0xB3, 0x00, 0x08, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xE9, 0xEF, 0x11, 0x93, 0xDC, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0xDC, 0xF7,
+         0x11, 0x93, 0xDB, 0xF7, 0x09, 0xA3, 0x00, 0x10, 0x19, 0xD3, 0xDB, 0xF7, 0x40, 0x98, 0x1C, 0xD9, 0x9B, 0xEC, 0x12, 0x95, 0x9B, 0xEC, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x86, 0xF0, 0x0A, 0xB3,
+         0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x07, 0xF0, 0x0A, 0xB3, 0x07, 0x00, 0x09, 0x05, 0xA9, 0xEC, 0xC2, 0x94, 0x01, 0xD4, 0x09, 0x03, 0xA1, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x9B, 0xEC,
+
+         0xC5, 0x94, 0x0A, 0xB5, 0x00, 0xFF, 0x01, 0xA5, 0xC5, 0xD4, 0x0F, 0x9F, 0x13, 0xF0, 0x0A, 0x05, 0xFF, 0xFF, 0x0A, 0x03, 0xB1, 0xEC, 0xC1, 0x92, 0x01, 0xD2, 0x1A, 0xD5, 0x9B, 0xEC, 0xC5, 0x96,
+         0x0B, 0x07, 0xFF, 0xFF, 0xC5, 0xD6, 0x11, 0x93, 0x97, 0xEC, 0xC5, 0x98, 0xC1, 0xD8, 0x11, 0x93, 0x97, 0xEC, 0x09, 0x05, 0x0B, 0x00, 0x03, 0xD4, 0xC2, 0x96, 0x06, 0xD6, 0x7B, 0x95, 0x7A, 0x95,
+         0x4C, 0x02, 0xC1, 0x92, 0x59, 0x93, 0x59, 0x93, 0x01, 0xA5, 0x01, 0x98, 0x0C, 0xF5, 0x7B, 0x93, 0x09, 0x09, 0x01, 0x00, 0x06, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x04, 0xD2, 0x5C, 0x93, 0x59, 0x93,
+         0x04, 0x94, 0x01, 0xA5, 0x03, 0x96, 0xC3, 0xD4, 0x11, 0x93, 0x97, 0xEC, 0x4C, 0x02, 0x05, 0xD2, 0xC1, 0x92, 0x09, 0xB3, 0x00, 0xFF, 0x7C, 0x95, 0x7A, 0x95, 0x02, 0xA3, 0x05, 0x98, 0xC4, 0xD2,
+         0x12, 0x95, 0x97, 0xEC, 0x45, 0x04, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x00, 0x01, 0xC2, 0xD2, 0x12, 0x95, 0x9B, 0xEC, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x5B, 0xF0,
+         0x12, 0x95, 0x97, 0xEC, 0x4A, 0x04, 0x02, 0x99, 0xC4, 0x92, 0x01, 0x98, 0x0C, 0xF3, 0x7B, 0x93, 0x41, 0x02, 0x0F, 0x9F, 0x7C, 0xF0, 0x43, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x7D, 0xF0, 0x11, 0x93,
+         0x97, 0xEC, 0x42, 0x02, 0x0A, 0x05, 0xFF, 0xFF, 0xC1, 0xD4, 0x11, 0x93, 0x97, 0xEC, 0x4A, 0x02, 0x12, 0x95, 0x60, 0x96, 0xC1, 0xD4, 0x12, 0x95, 0x97, 0xEC, 0x4B, 0x04, 0x02, 0x97, 0xC3, 0x92,
+         0x09, 0xB3, 0x1F, 0xFF, 0xC2, 0xD2, 0x12, 0x95, 0x97, 0xEC, 0x4B, 0x04, 0x11, 0x93, 0x62, 0x96, 0x41, 0x93, 0x59, 0x93, 0x02, 0x99, 0xC4, 0xA2, 0xC2, 0xD2, 0xC5, 0x92, 0x19, 0xD3, 0x98, 0xEC,
+         0x0A, 0x95, 0x0C, 0x02, 0x1A, 0xD5, 0x02, 0x80, 0x0F, 0x9F, 0xB1, 0xF0, 0x09, 0x63, 0xFE, 0x7F, 0x01, 0x97, 0xC3, 0x94, 0x0A, 0xA5, 0x00, 0x04, 0xC1, 0xD4, 0x11, 0x93, 0x9F, 0xEC, 0x09, 0xA3,
+         0x00, 0x01, 0x19, 0xD3, 0x9F, 0xEC, 0x40, 0xF0, 0x39, 0xEF, 0x0F, 0x9F, 0xB1, 0xF0, 0x11, 0x93, 0x94, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xA6, 0xF0, 0x40, 0xF0, 0x39, 0xEF, 0x11, 0x93,
+         0x95, 0xEC, 0x44, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xB1, 0xF0, 0x48, 0x98, 0x1C, 0xD9, 0x02, 0x80, 0x11, 0x93, 0x91, 0xEC, 0x41, 0x22, 0x0A, 0x95, 0xB1, 0xF0, 0x88, 0xD4, 0x88, 0xDC,
+         0x91, 0x9A, 0x47, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x04, 0x82, 0x48, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xC8, 0xF0, 0x0A, 0x65, 0xFD, 0x7D,
+         0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFF, 0xFE, 0xC2, 0xD2, 0x41, 0x92, 0x19, 0xD3, 0xBF, 0xEC, 0x11, 0x93, 0x04, 0x82, 0x43, 0xB2, 0x12, 0x95, 0x03, 0x82, 0x02, 0xB3, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0xEF, 0xF0, 0x0A, 0xB3, 0x00, 0xFF, 0x48, 0xA2, 0x19, 0xD3, 0x03, 0x82, 0x40, 0xF0, 0xEB, 0xF3, 0x11, 0x93, 0xBF, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xEF, 0xF0, 0x11, 0x93,
+         0x07, 0x82, 0x11, 0x43, 0x03, 0xEC, 0x02, 0x0E, 0x0F, 0x9F, 0xEF, 0xF0, 0x11, 0x93, 0x03, 0x82, 0x09, 0xA3, 0x00, 0x01, 0x19, 0xD3, 0x03, 0x82, 0x40, 0x96, 0x1B, 0xD7, 0xBF, 0xEC, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x20, 0xBC, 0xC8, 0xD2, 0x40, 0xF0, 0x48, 0xF1, 0x41, 0x00, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x05, 0x00, 0x05, 0x94, 0x41, 0x02, 0xC1, 0x92, 0x01, 0x97, 0xC3, 0x96, 0xC2, 0xD6, 0x0A, 0x45, 0x00, 0x95, 0x02, 0x5E,
+         0x0F, 0x9F, 0x45, 0xF1, 0xC1, 0x92, 0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x45, 0xF1, 0x11, 0x93, 0xC0, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x45, 0xF1, 0x41, 0x98, 0x1C, 0xD9,
+         0xC0, 0xEC, 0x12, 0x95, 0x02, 0x80, 0x01, 0xD4, 0x40, 0xF0, 0x56, 0xF2, 0x0B, 0x67, 0xFD, 0x7D, 0x03, 0x99, 0xC4, 0x92, 0x0C, 0x99, 0x96, 0x03, 0x1C, 0xD9, 0x06, 0x82, 0x41, 0x98, 0x1C, 0xD9,
+         0x02, 0x82, 0x42, 0x98, 0x1C, 0xD9, 0x05, 0x82, 0x0C, 0x69, 0x80, 0x7F, 0x1C, 0xD9, 0x00, 0xB0, 0x09, 0xA3, 0x00, 0x01, 0xC3, 0xD2, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x43, 0xF1, 0x42, 0xA4, 0x1A, 0xD5, 0x02, 0x80, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x05, 0x92, 0xC5, 0xD2, 0x60, 0xB2, 0x40, 0x42,
+         0x02, 0x4E, 0x0F, 0x9F, 0x55, 0xF1, 0x40, 0xF0, 0x35, 0xF7, 0xC5, 0x94, 0x0A, 0xB3, 0x10, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x5E, 0xF1, 0x40, 0xF0, 0x23, 0xF6, 0xC5, 0x96, 0x0B, 0xB3,
+         0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x67, 0xF1, 0x40, 0xF0, 0x5D, 0xF5, 0xC5, 0x94, 0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xC8, 0xF1, 0x13, 0x97, 0x21, 0xBC,
+         0x01, 0xD6, 0x0B, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x79, 0xF1, 0x40, 0xF0, 0x62, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x82, 0xF1,
+         0x40, 0xF0, 0x6C, 0xFB, 0x01, 0x96, 0x0B, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xA2, 0xF1, 0x40, 0xF0, 0xB0, 0xFA, 0x41, 0x92, 0x19, 0xD3, 0xD5, 0xF7, 0x11, 0x93, 0x03, 0xEC,
+         0x09, 0x43, 0x40, 0x00, 0x02, 0x5E, 0x0F, 0x9F, 0x98, 0xF1, 0x40, 0x94, 0x1A, 0xD5, 0xD5, 0xF7, 0x11, 0x93, 0x00, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAB, 0xF1, 0x40, 0xF0, 0x38, 0xF2,
+         0x0F, 0x9F, 0xAB, 0xF1, 0x01, 0x96, 0x0B, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAB, 0xF1, 0x40, 0xF0, 0x7C, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x10, 0x00, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0xB4, 0xF1, 0x40, 0xF0, 0x87, 0xFB, 0x11, 0x93, 0x10, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xBF, 0xF1, 0x44, 0x96, 0x1B, 0xD7, 0x0B, 0xBC, 0x0F, 0x9F, 0xC5, 0xF1, 0x41, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0xC5, 0xF1, 0x19, 0xD3, 0x0B, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0xC5, 0x94, 0x0A, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x12, 0xF2, 0x13, 0x97,
+         0x28, 0xBC, 0x01, 0xD6, 0x0B, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xDA, 0xF1, 0x40, 0xF0, 0x18, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0xED, 0xF1, 0x40, 0xF0, 0xC4, 0xEE, 0x40, 0xF0, 0x8F, 0xFB, 0x40, 0xF0, 0x1B, 0xF2, 0x40, 0x96, 0x1B, 0xD7, 0x00, 0xEC, 0x41, 0x92, 0x19, 0xD3, 0xD8, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x09, 0xF2, 0x40, 0xF0, 0x9E, 0xFB, 0x09, 0x63, 0x00, 0x44, 0x01, 0x97, 0xC3, 0x94, 0x48, 0xA4, 0xC1, 0xD4, 0x00, 0xEE, 0x40, 0x92, 0x19, 0xD3, 0x12, 0x95,
+         0x19, 0xD3, 0x10, 0x95, 0x19, 0xD3, 0x02, 0x80, 0x19, 0xD3, 0x03, 0x82, 0x41, 0x92, 0x19, 0xD3, 0xD8, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x12, 0xF2,
+         0x40, 0xF0, 0xAE, 0xFB, 0x0A, 0x65, 0x00, 0x44, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x40,
+         0x19, 0xD3, 0xF2, 0xBD, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x0A, 0x65,
+         0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x0A, 0x65,
+         0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97,
+         0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x00, 0x01, 0x19, 0xD3, 0x02, 0x80, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x00, 0x09, 0x19, 0xD3, 0x02, 0x80, 0x40, 0xF0, 0x56, 0xF2, 0x40, 0x92, 0x19, 0xD3, 0x94, 0xEC, 0xC8, 0xD2, 0x09, 0x93, 0x91, 0xEC, 0xC8, 0xD2, 0x40, 0xF0,
+         0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0x3B, 0xF5, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x85, 0xF2, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97,
+         0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x0F, 0x9F, 0x92, 0xF2, 0x40, 0xF0, 0x94, 0xF2, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x92, 0xF2, 0xC8, 0xD2, 0x09, 0x93, 0x91, 0xEC, 0xC8, 0xD2, 0x40, 0xF0,
+         0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0xF1, 0xBD, 0x19, 0xD3, 0xB6, 0xEC, 0x11, 0x93, 0xB4, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F,
+         0xAC, 0xF2, 0x09, 0x63, 0x00, 0x80, 0x01, 0x97, 0xC3, 0x94, 0x0A, 0x07, 0x07, 0x00, 0xC1, 0xD6, 0x0A, 0x05, 0x00, 0xA0, 0x1A, 0xD5, 0x96, 0xEC, 0x11, 0x93, 0xB6, 0xEC, 0x19, 0xD3, 0x01, 0x80,
+         0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x41, 0xA2, 0xC2, 0xD2, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x13, 0x97, 0xB4, 0xEC, 0x40, 0x46,
+         0x02, 0x5E, 0x0F, 0x9F, 0x2C, 0xF3, 0x12, 0x95, 0x96, 0xEC, 0x0A, 0x03, 0x07, 0x00, 0xC1, 0x92, 0xC2, 0xD2, 0x11, 0x93, 0x96, 0xEC, 0x09, 0x05, 0x01, 0x00, 0x48, 0x02, 0xC1, 0x92, 0xC2, 0xD2,
+         0x11, 0x93, 0x96, 0xEC, 0x4E, 0x02, 0xC1, 0x94, 0xC5, 0xD6, 0xC5, 0x92, 0x11, 0x07, 0x96, 0xEC, 0x0B, 0x03, 0x0F, 0x00, 0xC1, 0x98, 0x46, 0x06, 0x7A, 0x93, 0x79, 0x93, 0x5C, 0x95, 0x5A, 0x95,
+         0x02, 0xA3, 0xC3, 0xD2, 0x04, 0x95, 0xC5, 0x96, 0x41, 0x06, 0xC5, 0xD6, 0x42, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0xD5, 0xF2, 0x11, 0x93, 0x96, 0xEC, 0x09, 0x05, 0x05, 0x00, 0x41, 0x02, 0xC1, 0x92,
+         0xC2, 0xD2, 0x11, 0x93, 0x96, 0xEC, 0xC1, 0x92, 0x09, 0xB5, 0x1F, 0x00, 0x43, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x02, 0xF3, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x03, 0xF3, 0x0A, 0x05, 0xFF, 0xFF,
+         0x0F, 0x9F, 0x03, 0xF3, 0x43, 0x94, 0x11, 0x93, 0x96, 0xEC, 0x42, 0x02, 0xC1, 0xD4, 0x11, 0x93, 0x96, 0xEC, 0x49, 0x02, 0xC1, 0x92, 0x19, 0xD3, 0xB4, 0xEC, 0x09, 0x05, 0xF2, 0xFF, 0x1A, 0xD5,
+         0x92, 0xEC, 0x09, 0x43, 0xD0, 0x07, 0x02, 0x9E, 0x0F, 0x9F, 0x2C, 0xF3, 0x11, 0x93, 0xDC, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0xDC, 0xF7, 0x11, 0x93, 0xDB, 0xF7, 0x09, 0xA3, 0x40, 0x00, 0x19, 0xD3,
+         0xDB, 0xF7, 0x09, 0x63, 0x00, 0x80, 0x01, 0x95, 0xC2, 0x94, 0x1A, 0xD5, 0xB5, 0xEC, 0x40, 0x96, 0x1B, 0xD7, 0xB4, 0xEC, 0x0F, 0x9F, 0x92, 0xF3, 0x11, 0x93, 0x92, 0xEC, 0x12, 0x95, 0xB6, 0xEC,
+         0x02, 0x43, 0x02, 0x8E, 0x0F, 0x9F, 0x7A, 0xF3, 0x02, 0x0E, 0x0F, 0x9F, 0x4D, 0xF3, 0x11, 0x93, 0xDC, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0xDC, 0xF7, 0x11, 0x93, 0xDB, 0xF7, 0x09, 0xA3, 0x80, 0x00,
+         0x19, 0xD3, 0xDB, 0xF7, 0x09, 0x63, 0x00, 0x80, 0x01, 0x95, 0xC2, 0x94, 0x1A, 0xD5, 0xB5, 0xEC, 0x40, 0x96, 0x1B, 0xD7, 0xB4, 0xEC, 0x0F, 0x9F, 0x92, 0xF3, 0x11, 0x93, 0x03, 0x80, 0x09, 0xB3,
+         0x00, 0x40, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x5F, 0xF3, 0x11, 0x93, 0xC0, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x5F, 0xF3, 0x40, 0xF0, 0xA6, 0xF3, 0x0F, 0x9F, 0x94, 0xF3, 0x41, 0x92,
+         0xC8, 0xD2, 0x0A, 0x95, 0x91, 0xEC, 0xC8, 0xD4, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x11, 0x93, 0xC0, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x72, 0xF3, 0x42, 0x96, 0x1B, 0xD7, 0xC0, 0xEC,
+         0x0F, 0x9F, 0x94, 0xF3, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x42, 0xA2, 0xC2, 0xD2, 0x0F, 0x9F, 0x94, 0xF3, 0x12, 0x45, 0x03, 0xEC, 0x02, 0x4E, 0x0F, 0x9F, 0x8C, 0xF3, 0x11, 0x93,
+         0xDC, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0xDC, 0xF7, 0x11, 0x93, 0xDB, 0xF7, 0x09, 0xA3, 0x00, 0x08, 0x19, 0xD3, 0xDB, 0xF7, 0x1A, 0xD5, 0x92, 0xEC, 0x11, 0x93, 0x92, 0xEC, 0x19, 0x25, 0x92, 0xEC,
+         0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xA6, 0xF3, 0x40, 0x92, 0xC8, 0xD2, 0x09, 0x93, 0x91, 0xEC,
+         0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0xD7, 0xF7, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xB6, 0xF3, 0x0A, 0x65,
+         0xBC, 0x69, 0x02, 0x97, 0xC3, 0x92, 0x09, 0x83, 0x00, 0x02, 0xC2, 0xD2, 0x11, 0x93, 0x03, 0x80, 0x09, 0xB3, 0x00, 0x40, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xC9, 0xF3, 0x11, 0x93, 0xDC, 0xF7,
+         0x41, 0x02, 0x19, 0xD3, 0xDC, 0xF7, 0x11, 0x93, 0xDB, 0xF7, 0x09, 0xA3, 0x00, 0x20, 0x19, 0xD3, 0xDB, 0xF7, 0x11, 0x93, 0xB5, 0xEC, 0x19, 0xD3, 0x04, 0x80, 0x12, 0x95, 0xB4, 0xEC, 0x1A, 0xD5,
+         0x05, 0x80, 0x09, 0x63, 0x00, 0x80, 0x01, 0x97, 0xC3, 0x96, 0x1B, 0xD7, 0xB5, 0xEC, 0x40, 0x94, 0x1A, 0xD5, 0xB4, 0xEC, 0x19, 0xD3, 0xF2, 0xBD, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x09, 0x93, 0x96, 0x03, 0x19, 0xD3, 0x06, 0x82, 0x09, 0x93, 0x00, 0x01, 0x19, 0xD3, 0x03, 0x82, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x47, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93,
+         0x01, 0x82, 0xC5, 0xD2, 0x40, 0x94, 0x01, 0xD4, 0x13, 0x97, 0xB8, 0xEC, 0x02, 0xD6, 0x03, 0x95, 0x0C, 0x99, 0xBB, 0xEC, 0x04, 0x05, 0x13, 0x97, 0x03, 0xEC, 0x01, 0x27, 0x02, 0x99, 0xC4, 0x92,
+         0x03, 0x03, 0xC2, 0xD2, 0x14, 0x99, 0xBA, 0xEC, 0x03, 0x09, 0x1C, 0xD9, 0xBA, 0xEC, 0x12, 0x95, 0x04, 0x82, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x29, 0xF5, 0x01, 0x92,
+         0x03, 0xD2, 0x0A, 0xA3, 0x02, 0x00, 0x19, 0xD3, 0x04, 0x82, 0x02, 0x96, 0x0B, 0x05, 0x01, 0x00, 0x1A, 0xD5, 0xB8, 0xEC, 0xC5, 0x92, 0x43, 0x42, 0x02, 0x9E, 0x0F, 0x9F, 0x37, 0xF4, 0x42, 0x44,
+         0x02, 0x8E, 0x0F, 0x9F, 0x37, 0xF4, 0x11, 0x93, 0xBF, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x37, 0xF4, 0x0C, 0x49, 0xD3, 0x08, 0x02, 0x8E, 0x0F, 0x9F, 0x37, 0xF4, 0x11, 0x63, 0x07, 0x82,
+         0x11, 0xA3, 0x07, 0x82, 0x71, 0x93, 0x79, 0x93, 0x79, 0x93, 0x79, 0x93, 0x03, 0xD2, 0xC5, 0x94, 0x0A, 0xB5, 0xFC, 0xFF, 0x04, 0xD4, 0x03, 0x96, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0x46, 0xF4,
+         0x11, 0x93, 0xB8, 0xEC, 0x41, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x4D, 0xF4, 0xC5, 0x98, 0x0C, 0x03, 0xFF, 0xFF, 0x42, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x74, 0xF4, 0x0A, 0x95, 0xBB, 0xEC, 0x42, 0x92,
+         0x19, 0xD3, 0xB9, 0xEC, 0xC5, 0x96, 0x43, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0x66, 0xF4, 0x0B, 0x07, 0xFC, 0xFF, 0xC5, 0xD6, 0xD2, 0x98, 0x1C, 0xD9, 0xC8, 0xBC, 0xD2, 0x96, 0x1B, 0xD7, 0xCA, 0xBC,
+         0x09, 0x03, 0xFF, 0xFF, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x52, 0xF4, 0x19, 0xD3, 0xB9, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x72, 0xF4, 0x0A, 0x05, 0xFE, 0xFF, 0xCA, 0xD2, 0xC2, 0xD2,
+         0x0F, 0x9F, 0x74, 0xF4, 0x1A, 0xD5, 0x93, 0xEC, 0x03, 0x98, 0x40, 0x48, 0x02, 0x5E, 0x0F, 0x9F, 0xA1, 0xF4, 0x11, 0x93, 0xB8, 0xEC, 0x41, 0x42, 0x02, 0x9E, 0x0F, 0x9F, 0x84, 0xF4, 0x04, 0x94,
+         0x48, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x8F, 0xF4, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xA1, 0xF4, 0x11, 0x93, 0x04, 0x82, 0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xA1, 0xF4, 0x41, 0x96,
+         0x01, 0xD6, 0x0A, 0x65, 0xBD, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xA3, 0x80, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x0F, 0x9F,
+         0xFA, 0xF4, 0xC5, 0x98, 0x43, 0x48, 0x02, 0x9E, 0x0F, 0x9F, 0xFA, 0xF4, 0x4F, 0x96, 0x0C, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAE, 0xF4, 0x47, 0x96, 0x11, 0x93, 0xB7, 0xEC,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xD6, 0xF4, 0x11, 0x93, 0xB8, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xD6, 0xF4, 0x12, 0x95, 0x00, 0x82, 0x0A, 0x05, 0xFF, 0xAF, 0x05, 0xD4, 0xC8, 0xD6,
+         0xC8, 0xD2, 0x40, 0xF0, 0x7B, 0xF7, 0x42, 0x00, 0x05, 0x96, 0xC3, 0x94, 0x01, 0xB5, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0xD6, 0xF4, 0x06, 0x98, 0x50, 0x98, 0x1C, 0xD9, 0xA2, 0xBC, 0x40, 0x98,
+         0x1C, 0xD9, 0xA2, 0xBC, 0x40, 0x92, 0x03, 0xD2, 0x0F, 0x9F, 0xFF, 0xF4, 0x03, 0x94, 0x40, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0xE3, 0xF4, 0x0A, 0x65, 0x5E, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2,
+         0xC2, 0xD2, 0x0F, 0x9F, 0xFF, 0xF4, 0x11, 0x93, 0xB8, 0xEC, 0x0C, 0x99, 0xBB, 0xEC, 0x04, 0x03, 0x04, 0x96, 0x13, 0x25, 0x03, 0xEC, 0xC1, 0xD4, 0x11, 0x93, 0xBA, 0xEC, 0x19, 0x05, 0xBA, 0xEC,
+         0x1B, 0xD7, 0x01, 0x82, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x99, 0xC4, 0x92, 0x43, 0xA2, 0xC2, 0xD2, 0x41, 0x92, 0x01, 0xD2, 0x03, 0x94, 0x40, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0x13, 0xF5, 0x11, 0x93,
+         0xB9, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x0B, 0xF5, 0x19, 0xD3, 0xB8, 0xEC, 0x19, 0xD3, 0xBA, 0xEC, 0x19, 0xD3, 0xBB, 0xEC, 0x03, 0x96, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0x13, 0xF5,
+         0x41, 0x98, 0x1C, 0xD9, 0xB7, 0xEC, 0x11, 0x93, 0xBF, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x24, 0xF5, 0x11, 0x93, 0x00, 0x82, 0x19, 0xD3, 0x02, 0x82, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97,
+         0xC3, 0x92, 0x09, 0xA3, 0x00, 0x01, 0xC2, 0xD2, 0x40, 0x98, 0x1C, 0xD9, 0xBF, 0xEC, 0x0F, 0x9F, 0x2C, 0xF5, 0x01, 0x92, 0x19, 0xD3, 0xB7, 0xEC, 0x01, 0x94, 0x40, 0x44, 0x02, 0x5E, 0x0F, 0x9F,
+         0x38, 0xF5, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x47, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x03, 0x80,
+         0x0A, 0xB3, 0x00, 0x40, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x57, 0xF5, 0x0A, 0xB7, 0x00, 0x08, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0x5A, 0xF5, 0x11, 0x93, 0x03, 0xEC, 0x41, 0x02, 0x09, 0xB3,
+         0xFE, 0xFF, 0x12, 0x95, 0x07, 0x80, 0x01, 0x45, 0x02, 0x8E, 0x0F, 0x9F, 0x5A, 0xF5, 0x41, 0x92, 0x0F, 0x9F, 0x5B, 0xF5, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B,
+         0x01, 0x00, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x13, 0x97, 0x6E, 0xEC, 0x0B, 0x47, 0xA0, 0x00, 0x02, 0x5E, 0x0F, 0x9F, 0x86, 0xF5, 0x09, 0x63,
+         0x08, 0x43, 0x0A, 0x65, 0xFF, 0x5F, 0x01, 0x99, 0xC4, 0xD4, 0x0A, 0x95, 0x9B, 0xEC, 0xD2, 0x96, 0x1B, 0xD7, 0xFA, 0xBC, 0xD2, 0x96, 0xC4, 0xD6, 0xD2, 0x98, 0x1C, 0xD9, 0xFA, 0xBC, 0xD2, 0x96,
+         0xC1, 0xD6, 0xC2, 0x94, 0x1A, 0xD5, 0xFA, 0xBC, 0x0F, 0x9F, 0xC4, 0xF5, 0x0C, 0x69, 0xFF, 0x6F, 0x1C, 0xD9, 0xF8, 0xBC, 0x0B, 0x47, 0x10, 0x95, 0x02, 0x5E, 0x0F, 0x9F, 0x9E, 0xF5, 0x0A, 0x95,
+         0x6F, 0xEC, 0x09, 0x63, 0x06, 0x43, 0x01, 0x99, 0xC4, 0xD6, 0xD2, 0x96, 0x1B, 0xD7, 0xF8, 0xBC, 0x0C, 0x69, 0xEE, 0x6A, 0xC1, 0xD8, 0xC2, 0x94, 0x1A, 0xD5, 0xF8, 0xBC, 0x40, 0x92, 0xC5, 0xD2,
+         0x11, 0x43, 0xC1, 0xEC, 0x02, 0x0E, 0x0F, 0x9F, 0xC1, 0xF5, 0xC5, 0x94, 0x0A, 0x03, 0x71, 0xEC, 0xC1, 0x94, 0x1A, 0xD5, 0xFA, 0xBC, 0x11, 0x93, 0xC0, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0xB3, 0xF5, 0x0A, 0x95, 0x6F, 0xEC, 0xC8, 0xD4, 0x40, 0xF0, 0x9C, 0xF7, 0x19, 0xD3, 0xF8, 0xBC, 0x41, 0x00, 0xC5, 0x96, 0x41, 0x06, 0xC5, 0xD6, 0x13, 0x47, 0xC1, 0xEC, 0x02, 0x1E, 0x0F, 0x9F,
+         0xA5, 0xF5, 0x40, 0x98, 0x1C, 0xD9, 0xFA, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x6E, 0xEC, 0x19, 0xD3, 0xC1, 0xEC, 0x0A, 0x65, 0x52, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x0A, 0x65,
+         0xEB, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x06, 0x92, 0x01, 0xD2, 0x0A, 0x65,
+         0xF0, 0x6A, 0x0B, 0x97, 0x6F, 0xEC, 0x02, 0x99, 0xC4, 0x98, 0xD3, 0xD8, 0x02, 0xD6, 0x0A, 0x03, 0x02, 0x00, 0x01, 0x97, 0xC3, 0x98, 0x02, 0x96, 0xC3, 0xD8, 0x01, 0x96, 0xC1, 0xD6, 0x1A, 0xD5,
+         0x6E, 0xEC, 0xC5, 0x98, 0x14, 0x99, 0x6F, 0xEC, 0xC2, 0xD8, 0x43, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0xC8, 0xD2, 0x40, 0xF0, 0xD9, 0xF5, 0x41, 0x00,
+         0x11, 0x93, 0xC0, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x13, 0xF6, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x10, 0xF6, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x42, 0xA2, 0xC2, 0xD2,
+         0x40, 0x92, 0x19, 0xD3, 0xC0, 0xEC, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF,
+         0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x63, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0xAF, 0xBC, 0x47, 0xB2, 0x59, 0x95, 0x5A, 0x95, 0x12, 0xA5, 0xBF, 0xBC, 0x0A, 0xB3, 0x01, 0x00,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x35, 0xF6, 0x41, 0x04, 0x05, 0x93, 0x40, 0x96, 0x20, 0xD6, 0x62, 0x97, 0x0F, 0x9F, 0x44, 0xF6, 0x14, 0x99, 0xFC, 0xBC, 0xD1, 0xD8, 0x14, 0x99, 0xFE, 0xBC,
+         0xD1, 0xD8, 0x20, 0x98, 0x42, 0x08, 0x20, 0xD8, 0x20, 0x98, 0x03, 0x49, 0x02, 0x1E, 0x0F, 0x9F, 0x3B, 0xF6, 0xC5, 0x92, 0x62, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x5D, 0xF6, 0x02, 0x8E, 0x0F, 0x9F,
+         0x57, 0xF6, 0x61, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x81, 0xF6, 0x0F, 0x9F, 0xAE, 0xF6, 0x63, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xA4, 0xF6, 0x0F, 0x9F, 0xAE, 0xF6, 0x0D, 0x03, 0x01, 0x00, 0x0C, 0x99,
+         0x71, 0xEC, 0x0B, 0x05, 0xFF, 0xFF, 0x40, 0x96, 0x0F, 0x9F, 0x6A, 0xF6, 0xD1, 0x96, 0xD4, 0xD6, 0x20, 0x96, 0x41, 0x06, 0x20, 0xD6, 0x02, 0x47, 0x02, 0x1E, 0x0F, 0x9F, 0x66, 0xF6, 0x1A, 0xD5,
+         0xC1, 0xEC, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x0F, 0x9F,
+         0xAE, 0xF6, 0x0A, 0x03, 0xFE, 0xFF, 0x61, 0x95, 0x40, 0x98, 0x20, 0xD8, 0x02, 0x49, 0x02, 0x0E, 0x0F, 0x9F, 0xAE, 0xF6, 0x0D, 0x03, 0x01, 0x00, 0x21, 0xD2, 0x20, 0x92, 0x05, 0x03, 0x42, 0x02,
+         0xC8, 0xD2, 0x21, 0x96, 0xC3, 0x92, 0x42, 0x06, 0x21, 0xD6, 0xC8, 0xD2, 0x22, 0xD4, 0x40, 0xF0, 0x01, 0xF1, 0x42, 0x00, 0x20, 0x98, 0x42, 0x08, 0x20, 0xD8, 0x22, 0x94, 0x02, 0x49, 0x02, 0x1E,
+         0x0F, 0x9F, 0x8D, 0xF6, 0x0F, 0x9F, 0xAE, 0xF6, 0x0D, 0x03, 0x03, 0x00, 0xC8, 0xD2, 0x02, 0x92, 0xC8, 0xD2, 0x01, 0x96, 0xC8, 0xD6, 0x40, 0xF0, 0xB1, 0xF6, 0x43, 0x00, 0x63, 0x00, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x45, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x08, 0x00, 0x08, 0x94, 0xC5, 0xD4, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x03, 0xD4, 0x42, 0x02, 0xC1, 0x92, 0x01, 0xD2,
+         0x02, 0x97, 0xC5, 0x94, 0x0A, 0x83, 0xFF, 0xFF, 0x11, 0xB3, 0x2C, 0x93, 0x09, 0xB3, 0xFB, 0xFF, 0x19, 0xD3, 0x2C, 0x93, 0x03, 0x92, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xE4, 0xF6, 0x01, 0x94,
+         0xD2, 0x92, 0x19, 0xD3, 0x2C, 0x93, 0x01, 0xD4, 0x02, 0x94, 0x12, 0x95, 0x2C, 0x93, 0x44, 0xA4, 0x1A, 0xD5, 0x2C, 0x93, 0x0A, 0xB5, 0xFB, 0xFF, 0x1A, 0xD5, 0x2C, 0x93, 0x0B, 0x07, 0xFF, 0xFF,
+         0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0xCF, 0xF6, 0x09, 0x63, 0xD4, 0x6C, 0x01, 0x95, 0xC2, 0x96, 0xC5, 0x94, 0x02, 0xA7, 0xC1, 0xD6, 0x03, 0x92, 0x54, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xF4, 0xF6,
+         0x0A, 0x83, 0xFF, 0xFF, 0x1B, 0xB3, 0x2C, 0x93, 0x45, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x40, 0x19, 0xD3, 0xF2, 0xBD, 0x40, 0xF0, 0x3B, 0xF5,
+         0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x08, 0xF7, 0x40, 0xF0, 0x94, 0xF2, 0x0F, 0x9F, 0x16, 0xF7, 0x40, 0x96, 0xC8, 0xD6, 0x09, 0x93, 0x91, 0xEC, 0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x0A, 0x65,
+         0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3,
+         0x40, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3, 0x2D, 0xBC, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92,
+         0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0xEA, 0x43, 0x01, 0x97, 0xC3, 0x94, 0x44, 0xA4, 0xC1, 0xD4, 0x11, 0x93, 0xB9, 0xEC,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x6F, 0xF7, 0x12, 0x95, 0x93, 0xEC, 0x0B, 0x67, 0x36, 0x43, 0xD2, 0x98, 0x1C, 0xD9, 0xC8, 0xBC, 0xD2, 0x98, 0x03, 0x93, 0xC1, 0xD8, 0x11, 0x93, 0xB9, 0xEC,
+         0x09, 0x03, 0xFF, 0xFF, 0x19, 0xD3, 0xB9, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x48, 0xF7, 0x19, 0xD3, 0xB8, 0xEC, 0x19, 0xD3, 0xBA, 0xEC, 0x0A, 0x05, 0xFE, 0xFF, 0xCA, 0xD2, 0xCA, 0xD2,
+         0xC2, 0xD2, 0x0A, 0x65, 0x5E, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0x0F, 0x9F, 0x78, 0xF7, 0x11, 0x93,
+         0x03, 0xEC, 0x19, 0xD3, 0x01, 0x82, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97, 0xC3, 0x92, 0x43, 0xA2, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x03, 0x92, 0x04, 0x96,
+         0x0D, 0x5E, 0x50, 0x46, 0x02, 0x0E, 0x40, 0x92, 0x09, 0xEE, 0x44, 0x46, 0x04, 0x0E, 0x59, 0x93, 0x44, 0x26, 0x04, 0x5E, 0x46, 0xEE, 0x41, 0x93, 0x41, 0x26, 0x43, 0x4E, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xB1, 0xFE, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x03, 0x94,
+         0x1A, 0xD5, 0xA3, 0xF7, 0x11, 0x93, 0x00, 0x90, 0x88, 0x98, 0x90, 0x9A, 0x1D, 0x00, 0x1A, 0x00, 0x03, 0x00, 0x03, 0x00, 0x18, 0x00, 0x19, 0x00, 0x1A, 0x00, 0x1B, 0x00, 0x16, 0x00, 0x21, 0x00,
+         0x12, 0x00, 0x09, 0x00, 0x13, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x21, 0x00, 0x2D, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0xF2, 0xCD, 0xF7, 0x00, 0x00, 0x74, 0xF2, 0xCD, 0xF7, 0x00, 0x00, 0xB9, 0xF2, 0xCA, 0xF7,
+         0xD1, 0xF7, 0x00, 0x00, 0x97, 0xF3, 0xCD, 0xF7, 0x05, 0x46, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+ };
+#elif defined(ZD1211B)
+={
+         0x08, 0x91, 0xFF, 0xED, 0x09, 0x93, 0x1E, 0xEE, 0xD1, 0x94, 0x11, 0xEE, 0x88, 0xD4, 0xD1, 0x96, 0xD1, 0x98, 0x5C, 0x99, 0x5C, 0x99, 0x4C, 0x99, 0x04, 0x9D, 0xD1, 0x98, 0xD1, 0x9A, 0x03, 0xEE,
+         0xF4, 0x94, 0xD3, 0xD4, 0x41, 0x2A, 0x40, 0x4A, 0x45, 0xBE, 0x88, 0x92, 0x41, 0x24, 0x40, 0x44, 0x53, 0xBE, 0x40, 0xF0, 0x93, 0xEE, 0x41, 0xEE, 0x98, 0x9A, 0xC6, 0xF7, 0x02, 0x00, 0x1F, 0xEC,
+         0x00, 0x00, 0xB2, 0xF8, 0x4D, 0x00, 0xA0, 0xEC, 0x00, 0x00, 0x98, 0xF7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xD8, 0xA0, 0x90, 0x98, 0x9A, 0x98, 0x9A, 0xA0, 0xD8,
+         0x40, 0xF0, 0xB4, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0x64, 0xEF, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0xF6, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0,
+         0xE9, 0xF6, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0xE7, 0xF5, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0xF1, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0,
+         0x89, 0xF7, 0xA0, 0x90, 0x98, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x42, 0x02, 0xC1, 0x92, 0x03, 0x96, 0x1B, 0xD7, 0x2A, 0x86,
+         0x1A, 0xD5, 0x2B, 0x86, 0x09, 0xA3, 0x00, 0x80, 0x19, 0xD3, 0x2C, 0x86, 0x00, 0xEE, 0x0A, 0x65, 0xC0, 0x7A, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFE, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x05, 0x00, 0x05, 0x94, 0xC5, 0xD4, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x01, 0xD4, 0x42, 0x02, 0xC1, 0x96, 0x0A, 0x65, 0xC0, 0x7A,
+         0x02, 0x99, 0xC4, 0x92, 0x41, 0xA2, 0xC4, 0xD2, 0xC5, 0x98, 0x1C, 0xD9, 0x2A, 0x86, 0x01, 0x98, 0x1C, 0xD9, 0x2B, 0x86, 0x1B, 0xD7, 0x2C, 0x86, 0x00, 0xEE, 0x09, 0xB3, 0xFE, 0xFF, 0xC2, 0xD2,
+         0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xE5, 0xEE, 0x11, 0x93, 0xCA, 0xF7, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xAE, 0xEE, 0x40, 0xF1,
+         0x40, 0x92, 0x19, 0xD3, 0xCA, 0xF7, 0xC5, 0x92, 0x41, 0x92, 0x19, 0xD3, 0x00, 0x83, 0x40, 0x92, 0x19, 0xD3, 0x00, 0x83, 0x0F, 0x9F, 0x95, 0xF8, 0x0F, 0x9F, 0x99, 0xEE, 0x42, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0x99, 0xEE, 0x40, 0x92, 0x19, 0xD3, 0xCA, 0xF7, 0x09, 0x93, 0xB9, 0xF7, 0x19, 0xD3, 0x91, 0xEC, 0x40, 0xF0, 0x5F, 0xF2, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x0F, 0x9F,
+         0x99, 0xEE, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x12, 0x95, 0x19, 0xD3, 0x10, 0x95, 0x19, 0xD3, 0x02, 0x80, 0x19, 0xD3, 0x03, 0x82,
+         0x09, 0x93, 0xB9, 0xF7, 0x19, 0xD3, 0x91, 0xEC, 0x40, 0xF0, 0x5F, 0xF2, 0x40, 0xF0, 0xCD, 0xF3, 0x11, 0x93, 0x04, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xE3, 0xEE, 0x40, 0x92, 0x19, 0xD3,
+         0x04, 0xEC, 0x40, 0xF0, 0x38, 0xF2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x44, 0x96, 0x09, 0xB3, 0xFF, 0xFD, 0x19, 0xD3, 0x44, 0x96, 0x40, 0xF0, 0x82, 0xF7,
+         0x6E, 0x92, 0x19, 0xD3, 0x05, 0x84, 0x40, 0xF0, 0xC4, 0xEE, 0x4B, 0x62, 0x0A, 0x95, 0x2E, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x2B, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x00, 0xEE, 0xD1, 0xD4, 0x0B, 0x97,
+         0x2F, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x34, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x39, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x3E, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x43, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x48, 0xEE,
+         0xD1, 0xD4, 0x0B, 0x97, 0x4D, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x4E, 0xEE, 0xC1, 0xD4, 0x0A, 0x65, 0x00, 0x44, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x43, 0xF1, 0x09, 0x93, 0x01, 0x3F,
+         0x19, 0xD3, 0xC0, 0x85, 0x11, 0x93, 0x44, 0x96, 0x09, 0xB3, 0xFF, 0xFC, 0x19, 0xD3, 0x44, 0x96, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x03, 0x96,
+         0x41, 0x02, 0x03, 0x99, 0xC4, 0x94, 0x42, 0x04, 0xC1, 0x04, 0xC2, 0x94, 0xC3, 0xD4, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x94, 0xEC, 0x13, 0x97,
+         0x95, 0xEC, 0x1B, 0xD7, 0x02, 0x80, 0x11, 0x93, 0x99, 0xEC, 0x19, 0xD3, 0x7C, 0x96, 0x0B, 0x97, 0xA0, 0x00, 0x1B, 0xD7, 0x6E, 0xEC, 0x0A, 0x65, 0x0E, 0x42, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3,
+         0xFF, 0xBF, 0x11, 0xA3, 0x9A, 0xEC, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3,
+         0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x47, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x14, 0x99, 0x03, 0x80, 0x0C, 0xB3, 0x00, 0x10, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x97, 0xF0,
+         0x11, 0x93, 0x9F, 0xEC, 0x41, 0x02, 0x19, 0xD3, 0x9F, 0xEC, 0x11, 0x93, 0xC8, 0xF7, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x84, 0xEF, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3,
+         0x00, 0x04, 0xC2, 0xD2, 0x0F, 0x9F, 0xB1, 0xF0, 0x11, 0x93, 0x94, 0xEC, 0x02, 0xD2, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xD0, 0xEF, 0x41, 0x92, 0x19, 0xD3, 0x94, 0xEC, 0x19, 0xD3, 0x9F, 0xEC,
+         0x12, 0x95, 0x02, 0x80, 0x1A, 0xD5, 0x95, 0xEC, 0x13, 0x97, 0x7C, 0x96, 0x1B, 0xD7, 0x99, 0xEC, 0x0A, 0x65, 0x0E, 0x42, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x00, 0x40, 0x19, 0xD3, 0x9A, 0xEC,
+         0x09, 0x63, 0x00, 0x40, 0xC2, 0xD2, 0x02, 0x94, 0x1A, 0xD5, 0x7C, 0x96, 0x0C, 0xB3, 0x00, 0x08, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xB0, 0xEF, 0x0C, 0xB3, 0xFF, 0x07, 0x0F, 0x9F, 0xB4, 0xEF,
+         0x11, 0x93, 0x06, 0x80, 0x09, 0xB3, 0xFF, 0x07, 0x09, 0x03, 0x00, 0xA0, 0x19, 0xD3, 0x97, 0xEC, 0x40, 0x98, 0x0B, 0x97, 0x9C, 0xEC, 0x04, 0x95, 0x03, 0x05, 0x14, 0x03, 0x97, 0xEC, 0x46, 0x02,
+         0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x08, 0x42, 0x48, 0x02, 0x9E, 0x0F, 0x9F, 0xBB, 0xEF, 0x11, 0x93, 0x97, 0xEC, 0xC1, 0x92, 0xC5, 0xD2, 0x5F, 0xB2, 0x19, 0xD3, 0x9B, 0xEC, 0x0F, 0x9F, 0xD3, 0xEF,
+         0x13, 0x97, 0x98, 0xEC, 0xC5, 0xD6, 0x11, 0x93, 0x03, 0x80, 0x09, 0xB3, 0x00, 0x08, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xE9, 0xEF, 0x11, 0x93, 0xCE, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0xCE, 0xF7,
+         0x11, 0x93, 0xCD, 0xF7, 0x09, 0xA3, 0x00, 0x10, 0x19, 0xD3, 0xCD, 0xF7, 0x40, 0x98, 0x1C, 0xD9, 0x9B, 0xEC, 0x12, 0x95, 0x9B, 0xEC, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x86, 0xF0, 0x0A, 0xB3,
+         0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x07, 0xF0, 0x0A, 0xB3, 0x07, 0x00, 0x09, 0x05, 0xA8, 0xEC, 0xC2, 0x94, 0x01, 0xD4, 0x09, 0x03, 0xA0, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x9B, 0xEC,
+         0xC5, 0x94, 0x0A, 0xB5, 0x00, 0xFF, 0x01, 0xA5, 0xC5, 0xD4, 0x0F, 0x9F, 0x13, 0xF0, 0x0A, 0x05, 0xFF, 0xFF, 0x0A, 0x03, 0xB0, 0xEC, 0xC1, 0x92, 0x01, 0xD2, 0x1A, 0xD5, 0x9B, 0xEC, 0xC5, 0x96,
+         0x0B, 0x07, 0xFF, 0xFF, 0xC5, 0xD6, 0x11, 0x93, 0x97, 0xEC, 0xC5, 0x98, 0xC1, 0xD8, 0x11, 0x93, 0x97, 0xEC, 0x09, 0x05, 0x0B, 0x00, 0x03, 0xD4, 0xC2, 0x96, 0x06, 0xD6, 0x7B, 0x95, 0x7A, 0x95,
+         0x4C, 0x02, 0xC1, 0x92, 0x59, 0x93, 0x59, 0x93, 0x01, 0xA5, 0x01, 0x98, 0x0C, 0xF5, 0x7B, 0x93, 0x09, 0x09, 0x01, 0x00, 0x06, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x04, 0xD2, 0x5C, 0x93, 0x59, 0x93,
+         0x04, 0x94, 0x01, 0xA5, 0x03, 0x96, 0xC3, 0xD4, 0x11, 0x93, 0x97, 0xEC, 0x4C, 0x02, 0x05, 0xD2, 0xC1, 0x92, 0x09, 0xB3, 0x00, 0xFF, 0x7C, 0x95, 0x7A, 0x95, 0x02, 0xA3, 0x05, 0x98, 0xC4, 0xD2,
+         0x12, 0x95, 0x97, 0xEC, 0x45, 0x04, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x00, 0x01, 0xC2, 0xD2, 0x12, 0x95, 0x9B, 0xEC, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x5B, 0xF0,
+         0x12, 0x95, 0x97, 0xEC, 0x4A, 0x04, 0x02, 0x99, 0xC4, 0x92, 0x01, 0x98, 0x0C, 0xF3, 0x7B, 0x93, 0x41, 0x02, 0x0F, 0x9F, 0x7C, 0xF0, 0x43, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x7D, 0xF0, 0x11, 0x93,
+         0x97, 0xEC, 0x42, 0x02, 0x0A, 0x05, 0xFF, 0xFF, 0xC1, 0xD4, 0x11, 0x93, 0x97, 0xEC, 0x4A, 0x02, 0x12, 0x95, 0x60, 0x96, 0xC1, 0xD4, 0x12, 0x95, 0x97, 0xEC, 0x4B, 0x04, 0x02, 0x97, 0xC3, 0x92,
+         0x09, 0xB3, 0x1F, 0xFF, 0xC2, 0xD2, 0x12, 0x95, 0x97, 0xEC, 0x4B, 0x04, 0x11, 0x93, 0x62, 0x96, 0x41, 0x93, 0x59, 0x93, 0x02, 0x99, 0xC4, 0xA2, 0xC2, 0xD2, 0xC5, 0x92, 0x19, 0xD3, 0x98, 0xEC,
+         0x0A, 0x95, 0x0C, 0x02, 0x1A, 0xD5, 0x02, 0x80, 0x0F, 0x9F, 0xB1, 0xF0, 0x09, 0x63, 0xFE, 0x7F, 0x01, 0x97, 0xC3, 0x94, 0x0A, 0xA5, 0x00, 0x04, 0xC1, 0xD4, 0x11, 0x93, 0x9F, 0xEC, 0x09, 0xA3,
+         0x00, 0x01, 0x19, 0xD3, 0x9F, 0xEC, 0x40, 0xF0, 0x39, 0xEF, 0x0F, 0x9F, 0xB1, 0xF0, 0x11, 0x93, 0x94, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xA6, 0xF0, 0x40, 0xF0, 0x39, 0xEF, 0x11, 0x93,
+         0x95, 0xEC, 0x44, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xB1, 0xF0, 0x48, 0x98, 0x1C, 0xD9, 0x02, 0x80, 0x11, 0x93, 0x91, 0xEC, 0x41, 0x22, 0x0A, 0x95, 0xB1, 0xF0, 0x88, 0xD4, 0x88, 0xDC,
+         0x91, 0x9A, 0x47, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x04, 0x82, 0x48, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xC8, 0xF0, 0x0A, 0x65, 0xFD, 0x7D,
+         0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFF, 0xFE, 0xC2, 0xD2, 0x41, 0x92, 0x19, 0xD3, 0xBE, 0xEC, 0x11, 0x93, 0x04, 0x82, 0x43, 0xB2, 0x12, 0x95, 0x03, 0x82, 0x02, 0xB3, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0xEF, 0xF0, 0x0A, 0xB3, 0x00, 0xFF, 0x48, 0xA2, 0x19, 0xD3, 0x03, 0x82, 0x40, 0xF0, 0xDA, 0xF3, 0x11, 0x93, 0xBE, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xEF, 0xF0, 0x11, 0x93,
+         0x07, 0x82, 0x11, 0x43, 0x03, 0xEC, 0x02, 0x0E, 0x0F, 0x9F, 0xEF, 0xF0, 0x11, 0x93, 0x03, 0x82, 0x09, 0xA3, 0x00, 0x01, 0x19, 0xD3, 0x03, 0x82, 0x40, 0x96, 0x1B, 0xD7, 0xBE, 0xEC, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x20, 0xBC, 0xC8, 0xD2, 0x40, 0xF0, 0x48, 0xF1, 0x41, 0x00, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x05, 0x00, 0x05, 0x94, 0x41, 0x02, 0xC1, 0x92, 0x01, 0x97, 0xC3, 0x96, 0xC2, 0xD6, 0x0A, 0x45, 0x00, 0x95, 0x02, 0x5E,
+         0x0F, 0x9F, 0x45, 0xF1, 0xC1, 0x92, 0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x45, 0xF1, 0x11, 0x93, 0xBF, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x45, 0xF1, 0x41, 0x98, 0x1C, 0xD9,
+         0xBF, 0xEC, 0x12, 0x95, 0x02, 0x80, 0x01, 0xD4, 0x40, 0xF0, 0x56, 0xF2, 0x0B, 0x67, 0xFD, 0x7D, 0x03, 0x99, 0xC4, 0x92, 0x0C, 0x99, 0x96, 0x03, 0x1C, 0xD9, 0x06, 0x82, 0x41, 0x98, 0x1C, 0xD9,
+         0x02, 0x82, 0x42, 0x98, 0x1C, 0xD9, 0x05, 0x82, 0x0C, 0x69, 0x80, 0x7F, 0x1C, 0xD9, 0x00, 0xB0, 0x09, 0xA3, 0x00, 0x01, 0xC3, 0xD2, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x43, 0xF1, 0x42, 0xA4, 0x1A, 0xD5, 0x02, 0x80, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x05, 0x92, 0xC5, 0xD2, 0x60, 0xB2, 0x40, 0x42,
+         0x02, 0x4E, 0x0F, 0x9F, 0x55, 0xF1, 0x40, 0xF0, 0x27, 0xF7, 0xC5, 0x94, 0x0A, 0xB3, 0x10, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x5E, 0xF1, 0x40, 0xF0, 0x15, 0xF6, 0xC5, 0x96, 0x0B, 0xB3,
+         0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x67, 0xF1, 0x40, 0xF0, 0x4C, 0xF5, 0xC5, 0x94, 0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xC8, 0xF1, 0x13, 0x97, 0x21, 0xBC,
+         0x01, 0xD6, 0x0B, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x79, 0xF1, 0x40, 0xF0, 0x62, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x82, 0xF1,
+         0x40, 0xF0, 0x6C, 0xFB, 0x01, 0x96, 0x0B, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xA2, 0xF1, 0x40, 0xF0, 0xB0, 0xFA, 0x41, 0x92, 0x19, 0xD3, 0xC7, 0xF7, 0x11, 0x93, 0x03, 0xEC,
+         0x09, 0x43, 0x40, 0x00, 0x02, 0x5E, 0x0F, 0x9F, 0x98, 0xF1, 0x40, 0x94, 0x1A, 0xD5, 0xC7, 0xF7, 0x11, 0x93, 0x00, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAB, 0xF1, 0x40, 0xF0, 0x38, 0xF2,
+         0x0F, 0x9F, 0xAB, 0xF1, 0x01, 0x96, 0x0B, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAB, 0xF1, 0x40, 0xF0, 0x7C, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x10, 0x00, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0xB4, 0xF1, 0x40, 0xF0, 0x87, 0xFB, 0x11, 0x93, 0x10, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xBF, 0xF1, 0x44, 0x96, 0x1B, 0xD7, 0x0B, 0xBC, 0x0F, 0x9F, 0xC5, 0xF1, 0x41, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0xC5, 0xF1, 0x19, 0xD3, 0x0B, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0xC5, 0x94, 0x0A, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x12, 0xF2, 0x13, 0x97,
+         0x28, 0xBC, 0x01, 0xD6, 0x0B, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xDA, 0xF1, 0x40, 0xF0, 0x0A, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0xED, 0xF1, 0x40, 0xF0, 0xC4, 0xEE, 0x40, 0xF0, 0x8F, 0xFB, 0x40, 0xF0, 0x1B, 0xF2, 0x40, 0x96, 0x1B, 0xD7, 0x00, 0xEC, 0x41, 0x92, 0x19, 0xD3, 0xCA, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x09, 0xF2, 0x40, 0xF0, 0x9E, 0xFB, 0x09, 0x63, 0x00, 0x44, 0x01, 0x97, 0xC3, 0x94, 0x48, 0xA4, 0xC1, 0xD4, 0x00, 0xEE, 0x40, 0x92, 0x19, 0xD3, 0x12, 0x95,
+         0x19, 0xD3, 0x10, 0x95, 0x19, 0xD3, 0x02, 0x80, 0x19, 0xD3, 0x03, 0x82, 0x41, 0x92, 0x19, 0xD3, 0xCA, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x12, 0xF2,
+         0x40, 0xF0, 0xAE, 0xFB, 0x0A, 0x65, 0x00, 0x44, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x40,
+         0x19, 0xD3, 0xF2, 0xBD, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x0A, 0x65,
+         0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x0A, 0x65,
+         0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97,
+         0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x00, 0x01, 0x19, 0xD3, 0x02, 0x80, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x00, 0x09, 0x19, 0xD3, 0x02, 0x80, 0x40, 0xF0, 0x56, 0xF2, 0x40, 0x92, 0x19, 0xD3, 0x94, 0xEC, 0xC8, 0xD2, 0x09, 0x93, 0x91, 0xEC, 0xC8, 0xD2, 0x40, 0xF0,
+         0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0x2A, 0xF5, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x85, 0xF2, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97,
+         0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x0F, 0x9F, 0x92, 0xF2, 0x40, 0xF0, 0x94, 0xF2, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x92, 0xF2, 0xC8, 0xD2, 0x09, 0x93, 0x91, 0xEC, 0xC8, 0xD2, 0x40, 0xF0,
+         0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0xF1, 0xBD, 0x19, 0xD3, 0xB5, 0xEC, 0x11, 0x93, 0xB3, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F,
+         0xAC, 0xF2, 0x09, 0x63, 0x00, 0x80, 0x01, 0x97, 0xC3, 0x94, 0x0A, 0x07, 0x07, 0x00, 0xC1, 0xD6, 0x0A, 0x05, 0x00, 0xA0, 0x1A, 0xD5, 0x96, 0xEC, 0x11, 0x93, 0xB5, 0xEC, 0x19, 0xD3, 0x01, 0x80,
+         0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x41, 0xA2, 0xC2, 0xD2, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x13, 0x97, 0xB3, 0xEC, 0x40, 0x46,
+         0x02, 0x5E, 0x0F, 0x9F, 0x1B, 0xF3, 0x12, 0x95, 0x96, 0xEC, 0x0A, 0x03, 0x07, 0x00, 0xC1, 0x92, 0xC2, 0xD2, 0x11, 0x93, 0x96, 0xEC, 0x09, 0x05, 0x01, 0x00, 0x48, 0x02, 0xC1, 0x92, 0xC2, 0xD2,
+         0x11, 0x93, 0x96, 0xEC, 0x4E, 0x02, 0xC1, 0x94, 0xC5, 0xD6, 0xC5, 0x92, 0x11, 0x07, 0x96, 0xEC, 0x0B, 0x03, 0x0F, 0x00, 0xC1, 0x98, 0x46, 0x06, 0x7A, 0x93, 0x79, 0x93, 0x5C, 0x95, 0x5A, 0x95,
+         0x02, 0xA3, 0xC3, 0xD2, 0x04, 0x95, 0xC5, 0x96, 0x41, 0x06, 0xC5, 0xD6, 0x42, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0xD5, 0xF2, 0x11, 0x93, 0x96, 0xEC, 0x09, 0x05, 0x05, 0x00, 0x41, 0x02, 0xC1, 0x92,
+         0xC2, 0xD2, 0x11, 0x93, 0x96, 0xEC, 0xC1, 0x92, 0x09, 0xB5, 0x1F, 0x00, 0x43, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x02, 0xF3, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x03, 0xF3, 0x0A, 0x05, 0xFF, 0xFF,
+         0x0F, 0x9F, 0x03, 0xF3, 0x43, 0x94, 0x11, 0x93, 0x96, 0xEC, 0x42, 0x02, 0xC1, 0xD4, 0x13, 0x97, 0x96, 0xEC, 0x03, 0x93, 0xD1, 0x94, 0x7A, 0x95, 0x7A, 0x95, 0xC1, 0x92, 0x59, 0x93, 0x59, 0x93,
+         0x01, 0x05, 0x49, 0x06, 0xC3, 0x92, 0x7F, 0xB2, 0x01, 0x05, 0x1A, 0xD5, 0xB3, 0xEC, 0x0A, 0x05, 0xF2, 0xFF, 0x1A, 0xD5, 0x92, 0xEC, 0x11, 0x93, 0x92, 0xEC, 0x12, 0x95, 0xB5, 0xEC, 0x02, 0x43,
+         0x02, 0x8E, 0x0F, 0x9F, 0x69, 0xF3, 0x02, 0x0E, 0x0F, 0x9F, 0x3C, 0xF3, 0x11, 0x93, 0xCE, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0xCE, 0xF7, 0x11, 0x93, 0xCD, 0xF7, 0x09, 0xA3, 0x80, 0x00, 0x19, 0xD3,
+         0xCD, 0xF7, 0x09, 0x63, 0x00, 0x80, 0x01, 0x95, 0xC2, 0x94, 0x1A, 0xD5, 0xB4, 0xEC, 0x40, 0x96, 0x1B, 0xD7, 0xB3, 0xEC, 0x0F, 0x9F, 0x81, 0xF3, 0x11, 0x93, 0x03, 0x80, 0x09, 0xB3, 0x00, 0x40,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x4E, 0xF3, 0x11, 0x93, 0xBF, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x4E, 0xF3, 0x40, 0xF0, 0x95, 0xF3, 0x0F, 0x9F, 0x83, 0xF3, 0x41, 0x92, 0xC8, 0xD2,
+         0x0A, 0x95, 0x91, 0xEC, 0xC8, 0xD4, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x11, 0x93, 0xBF, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x61, 0xF3, 0x42, 0x96, 0x1B, 0xD7, 0xBF, 0xEC, 0x0F, 0x9F,
+         0x83, 0xF3, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x42, 0xA2, 0xC2, 0xD2, 0x0F, 0x9F, 0x83, 0xF3, 0x12, 0x45, 0x03, 0xEC, 0x02, 0x4E, 0x0F, 0x9F, 0x7B, 0xF3, 0x11, 0x93, 0xCE, 0xF7,
+         0x41, 0x02, 0x19, 0xD3, 0xCE, 0xF7, 0x11, 0x93, 0xCD, 0xF7, 0x09, 0xA3, 0x00, 0x08, 0x19, 0xD3, 0xCD, 0xF7, 0x1A, 0xD5, 0x92, 0xEC, 0x11, 0x93, 0x92, 0xEC, 0x19, 0x25, 0x92, 0xEC, 0x09, 0x63,
+         0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0x95, 0xF3, 0x40, 0x92, 0xC8, 0xD2, 0x09, 0x93, 0x91, 0xEC, 0xC8, 0xD2,
+         0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0xC9, 0xF7, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xA5, 0xF3, 0x0A, 0x65, 0xBC, 0x69,
+         0x02, 0x97, 0xC3, 0x92, 0x09, 0x83, 0x00, 0x02, 0xC2, 0xD2, 0x11, 0x93, 0x03, 0x80, 0x09, 0xB3, 0x00, 0x40, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xB8, 0xF3, 0x11, 0x93, 0xCE, 0xF7, 0x41, 0x02,
+         0x19, 0xD3, 0xCE, 0xF7, 0x11, 0x93, 0xCD, 0xF7, 0x09, 0xA3, 0x00, 0x20, 0x19, 0xD3, 0xCD, 0xF7, 0x11, 0x93, 0xB4, 0xEC, 0x19, 0xD3, 0x04, 0x80, 0x12, 0x95, 0xB3, 0xEC, 0x1A, 0xD5, 0x05, 0x80,
+         0x09, 0x63, 0x00, 0x80, 0x01, 0x97, 0xC3, 0x96, 0x1B, 0xD7, 0xB4, 0xEC, 0x40, 0x94, 0x1A, 0xD5, 0xB3, 0xEC, 0x19, 0xD3, 0xF2, 0xBD, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00,
+         0x09, 0x93, 0x96, 0x03, 0x19, 0xD3, 0x06, 0x82, 0x09, 0x93, 0x00, 0x01, 0x19, 0xD3, 0x03, 0x82, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x47, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x01, 0x82,
+         0xC5, 0xD2, 0x40, 0x94, 0x01, 0xD4, 0x13, 0x97, 0xB7, 0xEC, 0x02, 0xD6, 0x03, 0x95, 0x0C, 0x99, 0xBA, 0xEC, 0x04, 0x05, 0x13, 0x97, 0x03, 0xEC, 0x01, 0x27, 0x02, 0x99, 0xC4, 0x92, 0x03, 0x03,
+         0xC2, 0xD2, 0x14, 0x99, 0xB9, 0xEC, 0x03, 0x09, 0x1C, 0xD9, 0xB9, 0xEC, 0x12, 0x95, 0x04, 0x82, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x18, 0xF5, 0x01, 0x92, 0x03, 0xD2,
+         0x0A, 0xA3, 0x02, 0x00, 0x19, 0xD3, 0x04, 0x82, 0x02, 0x96, 0x0B, 0x05, 0x01, 0x00, 0x1A, 0xD5, 0xB7, 0xEC, 0xC5, 0x92, 0x43, 0x42, 0x02, 0x9E, 0x0F, 0x9F, 0x26, 0xF4, 0x42, 0x44, 0x02, 0x8E,
+         0x0F, 0x9F, 0x26, 0xF4, 0x11, 0x93, 0xBE, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x26, 0xF4, 0x0C, 0x49, 0xD3, 0x08, 0x02, 0x8E, 0x0F, 0x9F, 0x26, 0xF4, 0x11, 0x63, 0x07, 0x82, 0x11, 0xA3,
+         0x07, 0x82, 0x71, 0x93, 0x79, 0x93, 0x79, 0x93, 0x79, 0x93, 0x03, 0xD2, 0xC5, 0x94, 0x0A, 0xB5, 0xFC, 0xFF, 0x04, 0xD4, 0x03, 0x96, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0x35, 0xF4, 0x11, 0x93,
+         0xB7, 0xEC, 0x41, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x3C, 0xF4, 0xC5, 0x98, 0x0C, 0x03, 0xFF, 0xFF, 0x42, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x63, 0xF4, 0x0A, 0x95, 0xBA, 0xEC, 0x42, 0x92, 0x19, 0xD3,
+         0xB8, 0xEC, 0xC5, 0x96, 0x43, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0x55, 0xF4, 0x0B, 0x07, 0xFC, 0xFF, 0xC5, 0xD6, 0xD2, 0x98, 0x1C, 0xD9, 0xC8, 0xBC, 0xD2, 0x96, 0x1B, 0xD7, 0xCA, 0xBC, 0x09, 0x03,
+         0xFF, 0xFF, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x41, 0xF4, 0x19, 0xD3, 0xB8, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x61, 0xF4, 0x0A, 0x05, 0xFE, 0xFF, 0xCA, 0xD2, 0xC2, 0xD2, 0x0F, 0x9F,
+         0x63, 0xF4, 0x1A, 0xD5, 0x93, 0xEC, 0x03, 0x98, 0x40, 0x48, 0x02, 0x5E, 0x0F, 0x9F, 0x90, 0xF4, 0x11, 0x93, 0xB7, 0xEC, 0x41, 0x42, 0x02, 0x9E, 0x0F, 0x9F, 0x73, 0xF4, 0x04, 0x94, 0x48, 0x44,
+         0x02, 0x4E, 0x0F, 0x9F, 0x7E, 0xF4, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x90, 0xF4, 0x11, 0x93, 0x04, 0x82, 0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x90, 0xF4, 0x41, 0x96, 0x01, 0xD6,
+         0x0A, 0x65, 0xBD, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xA3, 0x80, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x0F, 0x9F, 0xE9, 0xF4,
+         0xC5, 0x98, 0x43, 0x48, 0x02, 0x9E, 0x0F, 0x9F, 0xE9, 0xF4, 0x4F, 0x96, 0x0C, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x9D, 0xF4, 0x47, 0x96, 0x11, 0x93, 0xB6, 0xEC, 0x40, 0x42,
+         0x02, 0x4E, 0x0F, 0x9F, 0xC5, 0xF4, 0x11, 0x93, 0xB7, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xC5, 0xF4, 0x12, 0x95, 0x00, 0x82, 0x0A, 0x05, 0xFF, 0xAF, 0x05, 0xD4, 0xC8, 0xD6, 0xC8, 0xD2,
+         0x40, 0xF0, 0x6D, 0xF7, 0x42, 0x00, 0x05, 0x96, 0xC3, 0x94, 0x01, 0xB5, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0xC5, 0xF4, 0x06, 0x98, 0x50, 0x98, 0x1C, 0xD9, 0xA2, 0xBC, 0x40, 0x98, 0x1C, 0xD9,
+         0xA2, 0xBC, 0x40, 0x92, 0x03, 0xD2, 0x0F, 0x9F, 0xEE, 0xF4, 0x03, 0x94, 0x40, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0xD2, 0xF4, 0x0A, 0x65, 0x5E, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2,
+         0x0F, 0x9F, 0xEE, 0xF4, 0x11, 0x93, 0xB7, 0xEC, 0x0C, 0x99, 0xBA, 0xEC, 0x04, 0x03, 0x04, 0x96, 0x13, 0x25, 0x03, 0xEC, 0xC1, 0xD4, 0x11, 0x93, 0xB9, 0xEC, 0x19, 0x05, 0xB9, 0xEC, 0x1B, 0xD7,
+         0x01, 0x82, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x99, 0xC4, 0x92, 0x43, 0xA2, 0xC2, 0xD2, 0x41, 0x92, 0x01, 0xD2, 0x03, 0x94, 0x40, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0x02, 0xF5, 0x11, 0x93, 0xB8, 0xEC,
+         0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xFA, 0xF4, 0x19, 0xD3, 0xB7, 0xEC, 0x19, 0xD3, 0xB9, 0xEC, 0x19, 0xD3, 0xBA, 0xEC, 0x03, 0x96, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0x02, 0xF5, 0x41, 0x98,
+         0x1C, 0xD9, 0xB6, 0xEC, 0x11, 0x93, 0xBE, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x13, 0xF5, 0x11, 0x93, 0x00, 0x82, 0x19, 0xD3, 0x02, 0x82, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97, 0xC3, 0x92,
+         0x09, 0xA3, 0x00, 0x01, 0xC2, 0xD2, 0x40, 0x98, 0x1C, 0xD9, 0xBE, 0xEC, 0x0F, 0x9F, 0x1B, 0xF5, 0x01, 0x92, 0x19, 0xD3, 0xB6, 0xEC, 0x01, 0x94, 0x40, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0x27, 0xF5,
+         0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x47, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x03, 0x80, 0x0A, 0xB3,
+         0x00, 0x40, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x46, 0xF5, 0x0A, 0xB7, 0x00, 0x08, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0x49, 0xF5, 0x11, 0x93, 0x03, 0xEC, 0x41, 0x02, 0x09, 0xB3, 0xFE, 0xFF,
+         0x12, 0x95, 0x07, 0x80, 0x01, 0x45, 0x02, 0x8E, 0x0F, 0x9F, 0x49, 0xF5, 0x41, 0x92, 0x0F, 0x9F, 0x4A, 0xF5, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00,
+         0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x13, 0x97, 0x6E, 0xEC, 0x0B, 0x47, 0xA0, 0x00, 0x02, 0x5E, 0x0F, 0x9F, 0x75, 0xF5, 0x09, 0x63, 0x08, 0x43,
+         0x0A, 0x65, 0xFF, 0x5F, 0x01, 0x99, 0xC4, 0xD4, 0x0A, 0x95, 0x9B, 0xEC, 0xD2, 0x96, 0x1B, 0xD7, 0xFA, 0xBC, 0xD2, 0x96, 0xC4, 0xD6, 0xD2, 0x98, 0x1C, 0xD9, 0xFA, 0xBC, 0xD2, 0x96, 0xC1, 0xD6,
+         0xC2, 0x94, 0x1A, 0xD5, 0xFA, 0xBC, 0x0F, 0x9F, 0xB3, 0xF5, 0x0C, 0x69, 0xFF, 0x6F, 0x1C, 0xD9, 0xF8, 0xBC, 0x0B, 0x47, 0x10, 0x95, 0x02, 0x5E, 0x0F, 0x9F, 0x8D, 0xF5, 0x0A, 0x95, 0x6F, 0xEC,
+         0x09, 0x63, 0x06, 0x43, 0x01, 0x99, 0xC4, 0xD6, 0xD2, 0x96, 0x1B, 0xD7, 0xF8, 0xBC, 0x0C, 0x69, 0xEE, 0x6A, 0xC1, 0xD8, 0xC2, 0x94, 0x1A, 0xD5, 0xF8, 0xBC, 0x40, 0x92, 0xC5, 0xD2, 0x11, 0x43,
+         0xC0, 0xEC, 0x02, 0x0E, 0x0F, 0x9F, 0xB0, 0xF5, 0xC5, 0x94, 0x0A, 0x03, 0x71, 0xEC, 0xC1, 0x94, 0x1A, 0xD5, 0xFA, 0xBC, 0x11, 0x93, 0xBF, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xA2, 0xF5,
+         0x0A, 0x95, 0x6F, 0xEC, 0xC8, 0xD4, 0x40, 0xF0, 0x8E, 0xF7, 0x19, 0xD3, 0xF8, 0xBC, 0x41, 0x00, 0xC5, 0x96, 0x41, 0x06, 0xC5, 0xD6, 0x13, 0x47, 0xC0, 0xEC, 0x02, 0x1E, 0x0F, 0x9F, 0x94, 0xF5,
+         0x40, 0x98, 0x1C, 0xD9, 0xFA, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x6E, 0xEC, 0x19, 0xD3, 0xC0, 0xEC, 0x0A, 0x65, 0x52, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43,
+         0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x06, 0x92, 0x01, 0xD2, 0x0A, 0x65, 0xF0, 0x6A,
+         0x0B, 0x97, 0x6F, 0xEC, 0x02, 0x99, 0xC4, 0x98, 0xD3, 0xD8, 0x02, 0xD6, 0x0A, 0x03, 0x02, 0x00, 0x01, 0x97, 0xC3, 0x98, 0x02, 0x96, 0xC3, 0xD8, 0x01, 0x96, 0xC1, 0xD6, 0x1A, 0xD5, 0x6E, 0xEC,
+         0xC5, 0x98, 0x14, 0x99, 0x6F, 0xEC, 0xC2, 0xD8, 0x43, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x6E, 0x92, 0x19, 0xD3, 0x05, 0x84, 0x40, 0x96, 0xC8, 0xD6, 0x40, 0xF0,
+         0xC8, 0xF5, 0x41, 0x00, 0x11, 0x93, 0xBF, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x05, 0xF6, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x02, 0xF6, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92,
+         0x42, 0xA2, 0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3, 0xBF, 0xEC, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92,
+         0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x63, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0xAF, 0xBC, 0x47, 0xB2, 0x59, 0x95, 0x5A, 0x95, 0x12, 0xA5, 0xBF, 0xBC,
+         0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x27, 0xF6, 0x41, 0x04, 0x05, 0x93, 0x40, 0x96, 0x20, 0xD6, 0x62, 0x97, 0x0F, 0x9F, 0x36, 0xF6, 0x14, 0x99, 0xFC, 0xBC, 0xD1, 0xD8,
+         0x14, 0x99, 0xFE, 0xBC, 0xD1, 0xD8, 0x20, 0x98, 0x42, 0x08, 0x20, 0xD8, 0x20, 0x98, 0x03, 0x49, 0x02, 0x1E, 0x0F, 0x9F, 0x2D, 0xF6, 0xC5, 0x92, 0x62, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x4F, 0xF6,
+         0x02, 0x8E, 0x0F, 0x9F, 0x49, 0xF6, 0x61, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x73, 0xF6, 0x0F, 0x9F, 0xA0, 0xF6, 0x63, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x96, 0xF6, 0x0F, 0x9F, 0xA0, 0xF6, 0x0D, 0x03,
+         0x01, 0x00, 0x0C, 0x99, 0x71, 0xEC, 0x0B, 0x05, 0xFF, 0xFF, 0x40, 0x96, 0x0F, 0x9F, 0x5C, 0xF6, 0xD1, 0x96, 0xD4, 0xD6, 0x20, 0x96, 0x41, 0x06, 0x20, 0xD6, 0x02, 0x47, 0x02, 0x1E, 0x0F, 0x9F,
+         0x58, 0xF6, 0x1A, 0xD5, 0xC0, 0xEC, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF,
+         0xC2, 0xD2, 0x0F, 0x9F, 0xA0, 0xF6, 0x0A, 0x03, 0xFE, 0xFF, 0x61, 0x95, 0x40, 0x98, 0x20, 0xD8, 0x02, 0x49, 0x02, 0x0E, 0x0F, 0x9F, 0xA0, 0xF6, 0x0D, 0x03, 0x01, 0x00, 0x21, 0xD2, 0x20, 0x92,
+         0x05, 0x03, 0x42, 0x02, 0xC8, 0xD2, 0x21, 0x96, 0xC3, 0x92, 0x42, 0x06, 0x21, 0xD6, 0xC8, 0xD2, 0x22, 0xD4, 0x40, 0xF0, 0x01, 0xF1, 0x42, 0x00, 0x20, 0x98, 0x42, 0x08, 0x20, 0xD8, 0x22, 0x94,
+         0x02, 0x49, 0x02, 0x1E, 0x0F, 0x9F, 0x7F, 0xF6, 0x0F, 0x9F, 0xA0, 0xF6, 0x0D, 0x03, 0x03, 0x00, 0xC8, 0xD2, 0x02, 0x92, 0xC8, 0xD2, 0x01, 0x96, 0xC8, 0xD6, 0x40, 0xF0, 0xA3, 0xF6, 0x43, 0x00,
+         0x63, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x45, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x08, 0x00, 0x08, 0x94, 0xC5, 0xD4, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x03, 0xD4, 0x42, 0x02,
+         0xC1, 0x92, 0x01, 0xD2, 0x02, 0x97, 0xC5, 0x94, 0x0A, 0x83, 0xFF, 0xFF, 0x11, 0xB3, 0x2C, 0x93, 0x09, 0xB3, 0xFB, 0xFF, 0x19, 0xD3, 0x2C, 0x93, 0x03, 0x92, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0xD6, 0xF6, 0x01, 0x94, 0xD2, 0x92, 0x19, 0xD3, 0x2C, 0x93, 0x01, 0xD4, 0x02, 0x94, 0x12, 0x95, 0x2C, 0x93, 0x44, 0xA4, 0x1A, 0xD5, 0x2C, 0x93, 0x0A, 0xB5, 0xFB, 0xFF, 0x1A, 0xD5, 0x2C, 0x93,
+         0x0B, 0x07, 0xFF, 0xFF, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0xC1, 0xF6, 0x09, 0x63, 0xD4, 0x6C, 0x01, 0x95, 0xC2, 0x96, 0xC5, 0x94, 0x02, 0xA7, 0xC1, 0xD6, 0x03, 0x92, 0x54, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0xE6, 0xF6, 0x0A, 0x83, 0xFF, 0xFF, 0x1B, 0xB3, 0x2C, 0x93, 0x45, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x40, 0x19, 0xD3, 0xF2, 0xBD,
+         0x40, 0xF0, 0x2A, 0xF5, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xFA, 0xF6, 0x40, 0xF0, 0x94, 0xF2, 0x0F, 0x9F, 0x08, 0xF7, 0x40, 0x96, 0xC8, 0xD6, 0x09, 0x93, 0x91, 0xEC, 0xC8, 0xD2, 0x40, 0xF0,
+         0x2A, 0xEF, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97,
+         0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3, 0x2D, 0xBC, 0x0A, 0x65, 0xD8, 0x43,
+         0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0xEA, 0x43, 0x01, 0x97, 0xC3, 0x94, 0x44, 0xA4, 0xC1, 0xD4,
+         0x11, 0x93, 0xB8, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x61, 0xF7, 0x12, 0x95, 0x93, 0xEC, 0x0B, 0x67, 0x36, 0x43, 0xD2, 0x98, 0x1C, 0xD9, 0xC8, 0xBC, 0xD2, 0x98, 0x03, 0x93, 0xC1, 0xD8,
+         0x11, 0x93, 0xB8, 0xEC, 0x09, 0x03, 0xFF, 0xFF, 0x19, 0xD3, 0xB8, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x3A, 0xF7, 0x19, 0xD3, 0xB7, 0xEC, 0x19, 0xD3, 0xB9, 0xEC, 0x0A, 0x05, 0xFE, 0xFF,
+         0xCA, 0xD2, 0xCA, 0xD2, 0xC2, 0xD2, 0x0A, 0x65, 0x5E, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0x0F, 0x9F,
+         0x6A, 0xF7, 0x11, 0x93, 0x03, 0xEC, 0x19, 0xD3, 0x01, 0x82, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97, 0xC3, 0x92, 0x43, 0xA2, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00,
+         0x03, 0x92, 0x04, 0x96, 0x0D, 0x5E, 0x50, 0x46, 0x02, 0x0E, 0x40, 0x92, 0x09, 0xEE, 0x44, 0x46, 0x04, 0x0E, 0x59, 0x93, 0x44, 0x26, 0x04, 0x5E, 0x46, 0xEE, 0x41, 0x93, 0x41, 0x26, 0x43, 0x4E,
+         0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xB1, 0xFE, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x03, 0x94, 0x1A, 0xD5, 0x95, 0xF7, 0x11, 0x93, 0x00, 0x90, 0x88, 0x98, 0x90, 0x9A, 0x1D, 0x00, 0x1A, 0x00, 0x03, 0x00, 0x03, 0x00, 0x18, 0x00, 0x19, 0x00, 0x1A, 0x00, 0x1B, 0x00,
+         0x16, 0x00, 0x21, 0x00, 0x12, 0x00, 0x09, 0x00, 0x13, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x21, 0x00, 0x2D, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0xF2, 0xBF, 0xF7, 0x00, 0x00, 0x74, 0xF2, 0xBF, 0xF7, 0x00, 0x00,
+         0xB9, 0xF2, 0xBC, 0xF7, 0xC3, 0xF7, 0x00, 0x00, 0x86, 0xF3, 0xBF, 0xF7, 0x21, 0x47, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+ };
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/WS11UPhm.h linux-2.4.35.3-mct/drivers/usb/zd1211/WS11UPhm.h
--- linux-2.4.35.3/drivers/usb/zd1211/WS11UPhm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/WS11UPhm.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,327 @@
+#ifdef ZD1211
+={
+         0x08, 0x91, 0xFF, 0xED, 0x09, 0x93, 0x1E, 0xEE, 0xD1, 0x94, 0x11, 0xEE, 0x88, 0xD4, 0xD1, 0x96, 0xD1, 0x98, 0x5C, 0x99, 0x5C, 0x99, 0x4C, 0x99, 0x04, 0x9D, 0xD1, 0x98, 0xD1, 0x9A, 0x03, 0xEE,
+         0xF4, 0x94, 0xD3, 0xD4, 0x41, 0x2A, 0x40, 0x4A, 0x45, 0xBE, 0x88, 0x92, 0x41, 0x24, 0x40, 0x44, 0x53, 0xBE, 0x40, 0xF0, 0x93, 0xEE, 0x41, 0xEE, 0x98, 0x9A, 0xD1, 0xF7, 0x02, 0x00, 0x1F, 0xEC,
+         0x00, 0x00, 0xB2, 0xF8, 0x4D, 0x00, 0xA0, 0xEC, 0x00, 0x00, 0xAA, 0xF7, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xD8, 0xA0, 0x90, 0x98, 0x9A, 0x98, 0x9A, 0xA0, 0xD8,
+         0x40, 0xF0, 0xB4, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0x64, 0xEF, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0xF6, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0,
+         0x38, 0xF7, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0x30, 0xF5, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0xF1, 0xF0, 0xA0, 0x90, 0x98, 0x9A, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0,
+         0x33, 0xF7, 0xA0, 0x90, 0x98, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x42, 0x02, 0xC1, 0x92, 0x03, 0x96, 0x1B, 0xD7, 0x2A, 0x86,
+         0x1A, 0xD5, 0x2B, 0x86, 0x09, 0xA3, 0x00, 0x80, 0x19, 0xD3, 0x2C, 0x86, 0x00, 0xEE, 0x0A, 0x65, 0xC0, 0x7A, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFE, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x05, 0x00, 0x05, 0x94, 0xC5, 0xD4, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x01, 0xD4, 0x42, 0x02, 0xC1, 0x96, 0x0A, 0x65, 0xC0, 0x7A,
+         0x02, 0x99, 0xC4, 0x92, 0x41, 0xA2, 0xC4, 0xD2, 0xC5, 0x98, 0x1C, 0xD9, 0x2A, 0x86, 0x01, 0x98, 0x1C, 0xD9, 0x2B, 0x86, 0x1B, 0xD7, 0x2C, 0x86, 0x00, 0xEE, 0x09, 0xB3, 0xFE, 0xFF, 0xC2, 0xD2,
+         0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xE5, 0xEE, 0x11, 0x93, 0xD5, 0xF7, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xAE, 0xEE, 0x40, 0xF1,
+         0x40, 0x92, 0x19, 0xD3, 0xD5, 0xF7, 0xC5, 0x92, 0x41, 0x92, 0x19, 0xD3, 0x00, 0x83, 0x40, 0x92, 0x19, 0xD3, 0x00, 0x83, 0x0F, 0x9F, 0x95, 0xF8, 0x0F, 0x9F, 0x99, 0xEE, 0x42, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0x99, 0xEE, 0x40, 0x92, 0x19, 0xD3, 0xD5, 0xF7, 0x09, 0x93, 0xC4, 0xF7, 0x19, 0xD3, 0x91, 0xEC, 0x40, 0xF0, 0x5F, 0xF2, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x0F, 0x9F,
+         0x99, 0xEE, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x12, 0x95, 0x19, 0xD3, 0x10, 0x95, 0x19, 0xD3, 0x02, 0x80, 0x19, 0xD3, 0x03, 0x82,
+         0x09, 0x93, 0xC4, 0xF7, 0x19, 0xD3, 0x91, 0xEC, 0x40, 0xF0, 0x5F, 0xF2, 0x40, 0xF0, 0xDE, 0xF3, 0x11, 0x93, 0x04, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xE3, 0xEE, 0x40, 0x92, 0x19, 0xD3,
+         0x04, 0xEC, 0x40, 0xF0, 0x38, 0xF2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x44, 0x96, 0x09, 0xB3, 0xFF, 0xFD, 0x19, 0xD3, 0x44, 0x96, 0x40, 0xF0, 0x2C, 0xF7,
+         0x6E, 0x92, 0x19, 0xD3, 0x05, 0x84, 0x40, 0xF0, 0xC4, 0xEE, 0x4B, 0x62, 0x0A, 0x95, 0x2E, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x2B, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x00, 0xEE, 0xD1, 0xD4, 0x0B, 0x97,
+         0x2F, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x34, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x39, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x3E, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x43, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x48, 0xEE,
+         0xD1, 0xD4, 0x0B, 0x97, 0x4D, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x4E, 0xEE, 0xC1, 0xD4, 0x0A, 0x65, 0x00, 0x44, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x43, 0xF1, 0x09, 0x93, 0x01, 0x3F,
+         0x19, 0xD3, 0xC0, 0x85, 0x11, 0x93, 0x44, 0x96, 0x09, 0xB3, 0xFF, 0xFC, 0x19, 0xD3, 0x44, 0x96, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x03, 0x96,
+         0x41, 0x02, 0x03, 0x99, 0xC4, 0x94, 0x42, 0x04, 0xC1, 0x04, 0xC2, 0x94, 0xC3, 0xD4, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x93, 0xEC, 0x13, 0x97,
+         0x94, 0xEC, 0x1B, 0xD7, 0x02, 0x80, 0x11, 0x93, 0x98, 0xEC, 0x19, 0xD3, 0x7C, 0x96, 0x0B, 0x97, 0xA0, 0x00, 0x1B, 0xD7, 0x6E, 0xEC, 0x0A, 0x65, 0x0E, 0x42, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3,
+         0xFF, 0xBF, 0x11, 0xA3, 0x99, 0xEC, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3,
+         0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x47, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x14, 0x99, 0x03, 0x80, 0x0C, 0xB3, 0x00, 0x10, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x97, 0xF0,
+         0x11, 0x93, 0x9E, 0xEC, 0x41, 0x02, 0x19, 0xD3, 0x9E, 0xEC, 0x11, 0x93, 0xD3, 0xF7, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x84, 0xEF, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3,
+         0x00, 0x04, 0xC2, 0xD2, 0x0F, 0x9F, 0xB1, 0xF0, 0x11, 0x93, 0x93, 0xEC, 0x02, 0xD2, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xD0, 0xEF, 0x41, 0x92, 0x19, 0xD3, 0x93, 0xEC, 0x19, 0xD3, 0x9E, 0xEC,
+         0x12, 0x95, 0x02, 0x80, 0x1A, 0xD5, 0x94, 0xEC, 0x13, 0x97, 0x7C, 0x96, 0x1B, 0xD7, 0x98, 0xEC, 0x0A, 0x65, 0x0E, 0x42, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x00, 0x40, 0x19, 0xD3, 0x99, 0xEC,
+         0x09, 0x63, 0x00, 0x40, 0xC2, 0xD2, 0x02, 0x94, 0x1A, 0xD5, 0x7C, 0x96, 0x0C, 0xB3, 0x00, 0x08, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xB0, 0xEF, 0x0C, 0xB3, 0xFF, 0x07, 0x0F, 0x9F, 0xB4, 0xEF,
+         0x11, 0x93, 0x06, 0x80, 0x09, 0xB3, 0xFF, 0x07, 0x09, 0x03, 0x00, 0xA0, 0x19, 0xD3, 0x96, 0xEC, 0x40, 0x98, 0x0B, 0x97, 0x9B, 0xEC, 0x04, 0x95, 0x03, 0x05, 0x14, 0x03, 0x96, 0xEC, 0x46, 0x02,
+         0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x08, 0x42, 0x48, 0x02, 0x9E, 0x0F, 0x9F, 0xBB, 0xEF, 0x11, 0x93, 0x96, 0xEC, 0xC1, 0x92, 0xC5, 0xD2, 0x5F, 0xB2, 0x19, 0xD3, 0x9A, 0xEC, 0x0F, 0x9F, 0xD3, 0xEF,
+         0x13, 0x97, 0x97, 0xEC, 0xC5, 0xD6, 0x11, 0x93, 0x03, 0x80, 0x09, 0xB3, 0x00, 0x08, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xE9, 0xEF, 0x11, 0x93, 0xDA, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0xDA, 0xF7,
+         0x11, 0x93, 0xD9, 0xF7, 0x09, 0xA3, 0x00, 0x10, 0x19, 0xD3, 0xD9, 0xF7, 0x40, 0x98, 0x1C, 0xD9, 0x9A, 0xEC, 0x12, 0x95, 0x9A, 0xEC, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x86, 0xF0, 0x0A, 0xB3,
+         0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x07, 0xF0, 0x0A, 0xB3, 0x07, 0x00, 0x09, 0x05, 0xA8, 0xEC, 0xC2, 0x94, 0x01, 0xD4, 0x09, 0x03, 0xA0, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x9A, 0xEC,
+         0xC5, 0x94, 0x0A, 0xB5, 0x00, 0xFF, 0x01, 0xA5, 0xC5, 0xD4, 0x0F, 0x9F, 0x13, 0xF0, 0x0A, 0x05, 0xFF, 0xFF, 0x0A, 0x03, 0xB0, 0xEC, 0xC1, 0x92, 0x01, 0xD2, 0x1A, 0xD5, 0x9A, 0xEC, 0xC5, 0x96,
+         0x0B, 0x07, 0xFF, 0xFF, 0xC5, 0xD6, 0x11, 0x93, 0x96, 0xEC, 0xC5, 0x98, 0xC1, 0xD8, 0x11, 0x93, 0x96, 0xEC, 0x09, 0x05, 0x0B, 0x00, 0x03, 0xD4, 0xC2, 0x96, 0x06, 0xD6, 0x7B, 0x95, 0x7A, 0x95,
+         0x4C, 0x02, 0xC1, 0x92, 0x59, 0x93, 0x59, 0x93, 0x01, 0xA5, 0x01, 0x98, 0x0C, 0xF5, 0x7B, 0x93, 0x09, 0x09, 0x01, 0x00, 0x06, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x04, 0xD2, 0x5C, 0x93, 0x59, 0x93,
+         0x04, 0x94, 0x01, 0xA5, 0x03, 0x96, 0xC3, 0xD4, 0x11, 0x93, 0x96, 0xEC, 0x4C, 0x02, 0x05, 0xD2, 0xC1, 0x92, 0x09, 0xB3, 0x00, 0xFF, 0x7C, 0x95, 0x7A, 0x95, 0x02, 0xA3, 0x05, 0x98, 0xC4, 0xD2,
+         0x12, 0x95, 0x96, 0xEC, 0x45, 0x04, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x00, 0x01, 0xC2, 0xD2, 0x12, 0x95, 0x9A, 0xEC, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x5B, 0xF0,
+         0x12, 0x95, 0x96, 0xEC, 0x4A, 0x04, 0x02, 0x99, 0xC4, 0x92, 0x01, 0x98, 0x0C, 0xF3, 0x7B, 0x93, 0x41, 0x02, 0x0F, 0x9F, 0x7C, 0xF0, 0x43, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x7D, 0xF0, 0x11, 0x93,
+         0x96, 0xEC, 0x42, 0x02, 0x0A, 0x05, 0xFF, 0xFF, 0xC1, 0xD4, 0x11, 0x93, 0x96, 0xEC, 0x4A, 0x02, 0x12, 0x95, 0x60, 0x96, 0xC1, 0xD4, 0x12, 0x95, 0x96, 0xEC, 0x4B, 0x04, 0x02, 0x97, 0xC3, 0x92,
+         0x09, 0xB3, 0x1F, 0xFF, 0xC2, 0xD2, 0x12, 0x95, 0x96, 0xEC, 0x4B, 0x04, 0x11, 0x93, 0x62, 0x96, 0x41, 0x93, 0x59, 0x93, 0x02, 0x99, 0xC4, 0xA2, 0xC2, 0xD2, 0xC5, 0x92, 0x19, 0xD3, 0x97, 0xEC,
+         0x0A, 0x95, 0x0C, 0x02, 0x1A, 0xD5, 0x02, 0x80, 0x0F, 0x9F, 0xB1, 0xF0, 0x09, 0x63, 0xFE, 0x7F, 0x01, 0x97, 0xC3, 0x94, 0x0A, 0xA5, 0x00, 0x04, 0xC1, 0xD4, 0x11, 0x93, 0x9E, 0xEC, 0x09, 0xA3,
+         0x00, 0x01, 0x19, 0xD3, 0x9E, 0xEC, 0x40, 0xF0, 0x39, 0xEF, 0x0F, 0x9F, 0xB1, 0xF0, 0x11, 0x93, 0x93, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xA6, 0xF0, 0x40, 0xF0, 0x39, 0xEF, 0x11, 0x93,
+         0x94, 0xEC, 0x44, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xB1, 0xF0, 0x48, 0x98, 0x1C, 0xD9, 0x02, 0x80, 0x11, 0x93, 0x91, 0xEC, 0x41, 0x22, 0x0A, 0x95, 0xB1, 0xF0, 0x88, 0xD4, 0x88, 0xDC,
+         0x91, 0x9A, 0x47, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x04, 0x82, 0x48, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xC8, 0xF0, 0x0A, 0x65, 0xFD, 0x7D,
+         0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFF, 0xFE, 0xC2, 0xD2, 0x41, 0x92, 0x19, 0xD3, 0xB7, 0xEC, 0x11, 0x93, 0x04, 0x82, 0x43, 0xB2, 0x12, 0x95, 0x03, 0x82, 0x02, 0xB3, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0xEF, 0xF0, 0x0A, 0xB3, 0x00, 0xFF, 0x48, 0xA2, 0x19, 0xD3, 0x03, 0x82, 0x40, 0xF0, 0xEB, 0xF3, 0x11, 0x93, 0xB7, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xEF, 0xF0, 0x11, 0x93,
+         0x07, 0x82, 0x11, 0x43, 0x03, 0xEC, 0x02, 0x0E, 0x0F, 0x9F, 0xEF, 0xF0, 0x11, 0x93, 0x03, 0x82, 0x09, 0xA3, 0x00, 0x01, 0x19, 0xD3, 0x03, 0x82, 0x40, 0x96, 0x1B, 0xD7, 0xB7, 0xEC, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x20, 0xBC, 0xC8, 0xD2, 0x40, 0xF0, 0x48, 0xF1, 0x41, 0x00, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x05, 0x00, 0x05, 0x94, 0x41, 0x02, 0xC1, 0x92, 0x01, 0x97, 0xC3, 0x96, 0xC2, 0xD6, 0x0A, 0x45, 0x00, 0x95, 0x02, 0x5E,
+         0x0F, 0x9F, 0x45, 0xF1, 0xC1, 0x92, 0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x45, 0xF1, 0x11, 0x93, 0xB8, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x45, 0xF1, 0x41, 0x98, 0x1C, 0xD9,
+         0xB8, 0xEC, 0x12, 0x95, 0x02, 0x80, 0x01, 0xD4, 0x40, 0xF0, 0x56, 0xF2, 0x0B, 0x67, 0xFD, 0x7D, 0x03, 0x99, 0xC4, 0x92, 0x0C, 0x99, 0x96, 0x03, 0x1C, 0xD9, 0x06, 0x82, 0x41, 0x98, 0x1C, 0xD9,
+         0x02, 0x82, 0x42, 0x98, 0x1C, 0xD9, 0x05, 0x82, 0x0C, 0x69, 0x80, 0x7F, 0x1C, 0xD9, 0x00, 0xB0, 0x09, 0xA3, 0x00, 0x01, 0xC3, 0xD2, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x43, 0xF1, 0x42, 0xA4, 0x1A, 0xD5, 0x02, 0x80, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x05, 0x92, 0xC5, 0xD2, 0x60, 0xB2, 0x40, 0x42,
+         0x02, 0x4E, 0x0F, 0x9F, 0x55, 0xF1, 0x40, 0xF0, 0x76, 0xF7, 0xC5, 0x94, 0x0A, 0xB3, 0x10, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x5E, 0xF1, 0x40, 0xF0, 0x5B, 0xF5, 0xC5, 0x96, 0x0B, 0xB3,
+         0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x67, 0xF1, 0x40, 0xF0, 0x95, 0xF4, 0xC5, 0x94, 0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xC8, 0xF1, 0x13, 0x97, 0x21, 0xBC,
+         0x01, 0xD6, 0x0B, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x79, 0xF1, 0x40, 0xF0, 0x62, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x82, 0xF1,
+         0x40, 0xF0, 0x6C, 0xFB, 0x01, 0x96, 0x0B, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xA2, 0xF1, 0x40, 0xF0, 0xB0, 0xFA, 0x41, 0x92, 0x19, 0xD3, 0xD2, 0xF7, 0x11, 0x93, 0x03, 0xEC,
+         0x09, 0x43, 0x40, 0x00, 0x02, 0x5E, 0x0F, 0x9F, 0x98, 0xF1, 0x40, 0x94, 0x1A, 0xD5, 0xD2, 0xF7, 0x11, 0x93, 0x00, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAB, 0xF1, 0x40, 0xF0, 0x38, 0xF2,
+         0x0F, 0x9F, 0xAB, 0xF1, 0x01, 0x96, 0x0B, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAB, 0xF1, 0x40, 0xF0, 0x7C, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x10, 0x00, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0xB4, 0xF1, 0x40, 0xF0, 0x87, 0xFB, 0x11, 0x93, 0x10, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xBF, 0xF1, 0x44, 0x96, 0x1B, 0xD7, 0x0B, 0xBC, 0x0F, 0x9F, 0xC5, 0xF1, 0x41, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0xC5, 0xF1, 0x19, 0xD3, 0x0B, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0xC5, 0x94, 0x0A, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x12, 0xF2, 0x13, 0x97,
+         0x28, 0xBC, 0x01, 0xD6, 0x0B, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xDA, 0xF1, 0x40, 0xF0, 0x59, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0xED, 0xF1, 0x40, 0xF0, 0xC4, 0xEE, 0x40, 0xF0, 0x8F, 0xFB, 0x40, 0xF0, 0x1B, 0xF2, 0x40, 0x96, 0x1B, 0xD7, 0x00, 0xEC, 0x41, 0x92, 0x19, 0xD3, 0xD5, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x09, 0xF2, 0x40, 0xF0, 0x9E, 0xFB, 0x09, 0x63, 0x00, 0x44, 0x01, 0x97, 0xC3, 0x94, 0x48, 0xA4, 0xC1, 0xD4, 0x00, 0xEE, 0x40, 0x92, 0x19, 0xD3, 0x12, 0x95,
+         0x19, 0xD3, 0x10, 0x95, 0x19, 0xD3, 0x02, 0x80, 0x19, 0xD3, 0x03, 0x82, 0x41, 0x92, 0x19, 0xD3, 0xD5, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x12, 0xF2,
+         0x40, 0xF0, 0xAE, 0xFB, 0x0A, 0x65, 0x00, 0x44, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x40,
+         0x19, 0xD3, 0xF2, 0xBD, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x0A, 0x65,
+         0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x0A, 0x65,
+         0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97,
+         0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x00, 0x01, 0x19, 0xD3, 0x02, 0x80, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x00, 0x09, 0x19, 0xD3, 0x02, 0x80, 0x40, 0xF0, 0x56, 0xF2, 0x40, 0x92, 0x19, 0xD3, 0x93, 0xEC, 0xC8, 0xD2, 0x09, 0x93, 0x91, 0xEC, 0xC8, 0xD2, 0x40, 0xF0,
+         0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0x73, 0xF4, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x85, 0xF2, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97,
+         0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x0F, 0x9F, 0x92, 0xF2, 0x40, 0xF0, 0x94, 0xF2, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x92, 0xF2, 0xC8, 0xD2, 0x09, 0x93, 0x91, 0xEC, 0xC8, 0xD2, 0x40, 0xF0,
+         0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0xF1, 0xBD, 0x19, 0xD3, 0xB5, 0xEC, 0x11, 0x93, 0xB3, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F,
+         0xAC, 0xF2, 0x09, 0x63, 0x00, 0x80, 0x01, 0x97, 0xC3, 0x94, 0x0A, 0x07, 0x07, 0x00, 0xC1, 0xD6, 0x0A, 0x05, 0x00, 0xA0, 0x1A, 0xD5, 0x95, 0xEC, 0x11, 0x93, 0xB5, 0xEC, 0x19, 0xD3, 0x01, 0x80,
+         0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x41, 0xA2, 0xC2, 0xD2, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x13, 0x97, 0xB3, 0xEC, 0x40, 0x46,
+         0x02, 0x5E, 0x0F, 0x9F, 0x2C, 0xF3, 0x12, 0x95, 0x95, 0xEC, 0x0A, 0x03, 0x07, 0x00, 0xC1, 0x92, 0xC2, 0xD2, 0x11, 0x93, 0x95, 0xEC, 0x09, 0x05, 0x01, 0x00, 0x48, 0x02, 0xC1, 0x92, 0xC2, 0xD2,
+         0x11, 0x93, 0x95, 0xEC, 0x4E, 0x02, 0xC1, 0x94, 0xC5, 0xD6, 0xC5, 0x92, 0x11, 0x07, 0x95, 0xEC, 0x0B, 0x03, 0x0F, 0x00, 0xC1, 0x98, 0x46, 0x06, 0x7A, 0x93, 0x79, 0x93, 0x5C, 0x95, 0x5A, 0x95,
+         0x02, 0xA3, 0xC3, 0xD2, 0x04, 0x95, 0xC5, 0x96, 0x41, 0x06, 0xC5, 0xD6, 0x42, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0xD5, 0xF2, 0x11, 0x93, 0x95, 0xEC, 0x09, 0x05, 0x05, 0x00, 0x41, 0x02, 0xC1, 0x92,
+         0xC2, 0xD2, 0x11, 0x93, 0x95, 0xEC, 0xC1, 0x92, 0x09, 0xB5, 0x1F, 0x00, 0x43, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x02, 0xF3, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x03, 0xF3, 0x0A, 0x05, 0xFF, 0xFF,
+         0x0F, 0x9F, 0x03, 0xF3, 0x43, 0x94, 0x11, 0x93, 0x95, 0xEC, 0x42, 0x02, 0xC1, 0xD4, 0x11, 0x93, 0x95, 0xEC, 0x49, 0x02, 0xC1, 0x92, 0x19, 0xD3, 0xB3, 0xEC, 0x09, 0x05, 0xF2, 0xFF, 0x1A, 0xD5,
+         0x92, 0xEC, 0x09, 0x43, 0xD0, 0x07, 0x02, 0x9E, 0x0F, 0x9F, 0x2C, 0xF3, 0x11, 0x93, 0xDA, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0xDA, 0xF7, 0x11, 0x93, 0xD9, 0xF7, 0x09, 0xA3, 0x40, 0x00, 0x19, 0xD3,
+         0xD9, 0xF7, 0x09, 0x63, 0x00, 0x80, 0x01, 0x95, 0xC2, 0x94, 0x1A, 0xD5, 0xB4, 0xEC, 0x40, 0x96, 0x1B, 0xD7, 0xB3, 0xEC, 0x0F, 0x9F, 0x92, 0xF3, 0x11, 0x93, 0x92, 0xEC, 0x12, 0x95, 0xB5, 0xEC,
+         0x02, 0x43, 0x02, 0x8E, 0x0F, 0x9F, 0x7A, 0xF3, 0x02, 0x0E, 0x0F, 0x9F, 0x4D, 0xF3, 0x11, 0x93, 0xDA, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0xDA, 0xF7, 0x11, 0x93, 0xD9, 0xF7, 0x09, 0xA3, 0x80, 0x00,
+         0x19, 0xD3, 0xD9, 0xF7, 0x09, 0x63, 0x00, 0x80, 0x01, 0x95, 0xC2, 0x94, 0x1A, 0xD5, 0xB4, 0xEC, 0x40, 0x96, 0x1B, 0xD7, 0xB3, 0xEC, 0x0F, 0x9F, 0x92, 0xF3, 0x11, 0x93, 0x03, 0x80, 0x09, 0xB3,
+         0x00, 0x40, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x5F, 0xF3, 0x11, 0x93, 0xB8, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x5F, 0xF3, 0x40, 0xF0, 0xA6, 0xF3, 0x0F, 0x9F, 0x94, 0xF3, 0x41, 0x92,
+         0xC8, 0xD2, 0x0A, 0x95, 0x91, 0xEC, 0xC8, 0xD4, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x11, 0x93, 0xB8, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x72, 0xF3, 0x42, 0x96, 0x1B, 0xD7, 0xB8, 0xEC,
+         0x0F, 0x9F, 0x94, 0xF3, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x42, 0xA2, 0xC2, 0xD2, 0x0F, 0x9F, 0x94, 0xF3, 0x12, 0x45, 0x03, 0xEC, 0x02, 0x4E, 0x0F, 0x9F, 0x8C, 0xF3, 0x11, 0x93,
+         0xDA, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0xDA, 0xF7, 0x11, 0x93, 0xD9, 0xF7, 0x09, 0xA3, 0x00, 0x08, 0x19, 0xD3, 0xD9, 0xF7, 0x1A, 0xD5, 0x92, 0xEC, 0x11, 0x93, 0x92, 0xEC, 0x19, 0x25, 0x92, 0xEC,
+         0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xA6, 0xF3, 0x40, 0x92, 0xC8, 0xD2, 0x09, 0x93, 0x91, 0xEC,
+         0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0xD4, 0xF7, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xB6, 0xF3, 0x0A, 0x65,
+         0xBC, 0x69, 0x02, 0x97, 0xC3, 0x92, 0x09, 0x83, 0x00, 0x02, 0xC2, 0xD2, 0x11, 0x93, 0x03, 0x80, 0x09, 0xB3, 0x00, 0x40, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xC9, 0xF3, 0x11, 0x93, 0xDA, 0xF7,
+         0x41, 0x02, 0x19, 0xD3, 0xDA, 0xF7, 0x11, 0x93, 0xD9, 0xF7, 0x09, 0xA3, 0x00, 0x20, 0x19, 0xD3, 0xD9, 0xF7, 0x11, 0x93, 0xB4, 0xEC, 0x19, 0xD3, 0x04, 0x80, 0x12, 0x95, 0xB3, 0xEC, 0x1A, 0xD5,
+         0x05, 0x80, 0x09, 0x63, 0x00, 0x80, 0x01, 0x97, 0xC3, 0x96, 0x1B, 0xD7, 0xB4, 0xEC, 0x40, 0x94, 0x1A, 0xD5, 0xB3, 0xEC, 0x19, 0xD3, 0xF2, 0xBD, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x09, 0x93, 0x96, 0x03, 0x19, 0xD3, 0x06, 0x82, 0x09, 0x93, 0x00, 0x01, 0x19, 0xD3, 0x03, 0x82, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x13, 0x97,
+         0x01, 0x82, 0x40, 0x92, 0xC5, 0xD2, 0x12, 0x95, 0x04, 0x82, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x61, 0xF4, 0x0A, 0xA3, 0x02, 0x00, 0x19, 0xD3, 0x04, 0x82, 0x41, 0xB2,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x15, 0xF4, 0x41, 0x96, 0xC5, 0xD6, 0x0A, 0x65, 0xBD, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x80, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97,
+         0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0x0F, 0x9F, 0x47, 0xF4, 0x43, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0x48, 0xF4, 0x4F, 0x98, 0x0B, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x21, 0xF4,
+         0x47, 0x98, 0x11, 0x93, 0xB6, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x42, 0xF4, 0x12, 0x95, 0x00, 0x82, 0x0A, 0x05, 0xFF, 0xAF, 0x01, 0xD4, 0xC8, 0xD8, 0x41, 0x92, 0xC8, 0xD2, 0x40, 0xF0,
+         0x8B, 0xF7, 0x42, 0x00, 0x01, 0x96, 0xC3, 0x94, 0x01, 0xB5, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x42, 0xF4, 0x02, 0x92, 0x50, 0x92, 0x19, 0xD3, 0xA2, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0xA2, 0xBC,
+         0x0F, 0x9F, 0x48, 0xF4, 0x0A, 0x65, 0x5E, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x41, 0x92, 0x19, 0xD3, 0xB6, 0xEC, 0x11, 0x93, 0xB7, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F,
+         0x5C, 0xF4, 0x13, 0x97, 0x00, 0x82, 0x1B, 0xD7, 0x02, 0x82, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x00, 0x01, 0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3, 0xB7, 0xEC, 0x0F, 0x9F,
+         0x64, 0xF4, 0xC5, 0x96, 0x1B, 0xD7, 0xB6, 0xEC, 0xC5, 0x92, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x70, 0xF4, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2,
+         0x43, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x03, 0x80, 0x0A, 0xB3, 0x00, 0x40, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x8F, 0xF4, 0x0A, 0xB7, 0x00, 0x08,
+         0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0x92, 0xF4, 0x11, 0x93, 0x03, 0xEC, 0x41, 0x02, 0x09, 0xB3, 0xFE, 0xFF, 0x12, 0x95, 0x07, 0x80, 0x01, 0x45, 0x02, 0x8E, 0x0F, 0x9F, 0x92, 0xF4, 0x41, 0x92,
+         0x0F, 0x9F, 0x93, 0xF4, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2,
+         0x13, 0x97, 0x6E, 0xEC, 0x0B, 0x47, 0xA0, 0x00, 0x02, 0x5E, 0x0F, 0x9F, 0xBE, 0xF4, 0x09, 0x63, 0x08, 0x43, 0x0A, 0x65, 0xFF, 0x5F, 0x01, 0x99, 0xC4, 0xD4, 0x0A, 0x95, 0x9A, 0xEC, 0xD2, 0x96,
+         0x1B, 0xD7, 0xFA, 0xBC, 0xD2, 0x96, 0xC4, 0xD6, 0xD2, 0x98, 0x1C, 0xD9, 0xFA, 0xBC, 0xD2, 0x96, 0xC1, 0xD6, 0xC2, 0x94, 0x1A, 0xD5, 0xFA, 0xBC, 0x0F, 0x9F, 0xFC, 0xF4, 0x0C, 0x69, 0xFF, 0x6F,
+         0x1C, 0xD9, 0xF8, 0xBC, 0x0B, 0x47, 0x10, 0x95, 0x02, 0x5E, 0x0F, 0x9F, 0xD6, 0xF4, 0x0A, 0x95, 0x6F, 0xEC, 0x09, 0x63, 0x06, 0x43, 0x01, 0x99, 0xC4, 0xD6, 0xD2, 0x96, 0x1B, 0xD7, 0xF8, 0xBC,
+         0x0C, 0x69, 0xEE, 0x6A, 0xC1, 0xD8, 0xC2, 0x94, 0x1A, 0xD5, 0xF8, 0xBC, 0x40, 0x92, 0xC5, 0xD2, 0x11, 0x43, 0xB9, 0xEC, 0x02, 0x0E, 0x0F, 0x9F, 0xF9, 0xF4, 0xC5, 0x94, 0x0A, 0x03, 0x71, 0xEC,
+         0xC1, 0x94, 0x1A, 0xD5, 0xFA, 0xBC, 0x11, 0x93, 0xB8, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xEB, 0xF4, 0x0A, 0x95, 0x6F, 0xEC, 0xC8, 0xD4, 0x40, 0xF0, 0xA0, 0xF7, 0x19, 0xD3, 0xF8, 0xBC,
+         0x41, 0x00, 0xC5, 0x96, 0x41, 0x06, 0xC5, 0xD6, 0x13, 0x47, 0xB9, 0xEC, 0x02, 0x1E, 0x0F, 0x9F, 0xDD, 0xF4, 0x40, 0x98, 0x1C, 0xD9, 0xFA, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x6E, 0xEC, 0x19, 0xD3,
+         0xB9, 0xEC, 0x0A, 0x65, 0x52, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x41, 0x00, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x06, 0x92, 0x01, 0xD2, 0x0A, 0x65, 0xF0, 0x6A, 0x0B, 0x97, 0x6F, 0xEC, 0x02, 0x99, 0xC4, 0x98, 0xD3, 0xD8, 0x02, 0xD6, 0x0A, 0x03,
+         0x02, 0x00, 0x01, 0x97, 0xC3, 0x98, 0x02, 0x96, 0xC3, 0xD8, 0x01, 0x96, 0xC1, 0xD6, 0x1A, 0xD5, 0x6E, 0xEC, 0xC5, 0x98, 0x14, 0x99, 0x6F, 0xEC, 0xC2, 0xD8, 0x43, 0x00, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0xC8, 0xD2, 0x40, 0xF0, 0x11, 0xF5, 0x41, 0x00, 0x11, 0x93, 0xB8, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x4B, 0xF5, 0x42, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0x48, 0xF5, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x42, 0xA2, 0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3, 0xB8, 0xEC, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3,
+         0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x63, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93,
+         0xAF, 0xBC, 0x47, 0xB2, 0x59, 0x95, 0x5A, 0x95, 0x12, 0xA5, 0xBF, 0xBC, 0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x6D, 0xF5, 0x41, 0x04, 0x05, 0x93, 0x40, 0x96, 0x20, 0xD6,
+         0x62, 0x97, 0x0F, 0x9F, 0x7C, 0xF5, 0x14, 0x99, 0xFC, 0xBC, 0xD1, 0xD8, 0x14, 0x99, 0xFE, 0xBC, 0xD1, 0xD8, 0x20, 0x98, 0x42, 0x08, 0x20, 0xD8, 0x20, 0x98, 0x03, 0x49, 0x02, 0x1E, 0x0F, 0x9F,
+         0x73, 0xF5, 0xC5, 0x92, 0x62, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x99, 0xF5, 0x02, 0x8E, 0x0F, 0x9F, 0x8F, 0xF5, 0x61, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xBD, 0xF5, 0x0F, 0x9F, 0xF5, 0xF5, 0x63, 0x42,
+         0x02, 0x4E, 0x0F, 0x9F, 0xE0, 0xF5, 0x64, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xEB, 0xF5, 0x0F, 0x9F, 0xF5, 0xF5, 0x0D, 0x03, 0x01, 0x00, 0x0C, 0x99, 0x71, 0xEC, 0x0B, 0x05, 0xFF, 0xFF, 0x40, 0x96,
+         0x0F, 0x9F, 0xA6, 0xF5, 0xD1, 0x96, 0xD4, 0xD6, 0x20, 0x96, 0x41, 0x06, 0x20, 0xD6, 0x02, 0x47, 0x02, 0x1E, 0x0F, 0x9F, 0xA2, 0xF5, 0x1A, 0xD5, 0xB9, 0xEC, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x99,
+         0xC4, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x0F, 0x9F, 0xF5, 0xF5, 0x0A, 0x03, 0xFE, 0xFF, 0x61, 0x95,
+         0x40, 0x98, 0x20, 0xD8, 0x02, 0x49, 0x02, 0x0E, 0x0F, 0x9F, 0xF5, 0xF5, 0x0D, 0x03, 0x01, 0x00, 0x21, 0xD2, 0x20, 0x92, 0x05, 0x03, 0x42, 0x02, 0xC8, 0xD2, 0x21, 0x96, 0xC3, 0x92, 0x42, 0x06,
+         0x21, 0xD6, 0xC8, 0xD2, 0x22, 0xD4, 0x40, 0xF0, 0x01, 0xF1, 0x42, 0x00, 0x20, 0x98, 0x42, 0x08, 0x20, 0xD8, 0x22, 0x94, 0x02, 0x49, 0x02, 0x1E, 0x0F, 0x9F, 0xC9, 0xF5, 0x0F, 0x9F, 0xF5, 0xF5,
+         0x0D, 0x03, 0x03, 0x00, 0xC8, 0xD2, 0x02, 0x92, 0xC8, 0xD2, 0x01, 0x96, 0xC8, 0xD6, 0x40, 0xF0, 0xF8, 0xF5, 0x0F, 0x9F, 0xF4, 0xF5, 0x01, 0x98, 0xC8, 0xD8, 0x0D, 0x03, 0x03, 0x00, 0xC8, 0xD2,
+         0x02, 0x92, 0xC8, 0xD2, 0x40, 0xF0, 0x98, 0xF6, 0x43, 0x00, 0x63, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x45, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x08, 0x00, 0x08, 0x94, 0xC5, 0xD4,
+         0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x03, 0xD4, 0x42, 0x02, 0xC1, 0x92, 0x01, 0xD2, 0x02, 0x97, 0xC5, 0x94, 0x0A, 0x83, 0xFF, 0xFF, 0x11, 0xB3, 0x2C, 0x93, 0x09, 0xB3, 0xFB, 0xFF, 0x19, 0xD3,
+         0x2C, 0x93, 0x03, 0x92, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x2B, 0xF6, 0x01, 0x94, 0xD2, 0x92, 0x19, 0xD3, 0x2C, 0x93, 0x01, 0xD4, 0x02, 0x94, 0x12, 0x95, 0x2C, 0x93, 0x44, 0xA4, 0x1A, 0xD5,
+         0x2C, 0x93, 0x0A, 0xB5, 0xFB, 0xFF, 0x1A, 0xD5, 0x2C, 0x93, 0x0B, 0x07, 0xFF, 0xFF, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0x16, 0xF6, 0x09, 0x63, 0xD4, 0x6C, 0x01, 0x95, 0xC2, 0x96, 0xC5, 0x94,
+         0x02, 0xA7, 0xC1, 0xD6, 0x03, 0x92, 0x54, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x3B, 0xF6, 0x0A, 0x83, 0xFF, 0xFF, 0x1B, 0xB3, 0x2C, 0x93, 0x45, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20,
+         0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x04, 0x00, 0x04, 0x94, 0xC5, 0xD4, 0x41, 0x02, 0xC1, 0x92, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x68, 0xF6, 0x09, 0x63, 0xD4, 0x6C, 0x01, 0x97, 0xC3, 0x94,
+         0x0A, 0xB5, 0xFD, 0xFF, 0xC3, 0xD4, 0x0B, 0x97, 0xAA, 0x00, 0x1B, 0xD7, 0x55, 0x05, 0x00, 0xEE, 0x42, 0xA4, 0x01, 0x97, 0xC3, 0xD4, 0x0B, 0x97, 0x55, 0x00, 0x1B, 0xD7, 0xAA, 0x02, 0x00, 0xEE,
+         0x0A, 0xB5, 0xFD, 0xFF, 0xC1, 0xD4, 0xC5, 0x92, 0x19, 0xD3, 0x55, 0x05, 0x0F, 0x9F, 0x71, 0xF6, 0x0A, 0x65, 0xD4, 0x6C, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFD, 0xFF, 0xC2, 0xD2, 0xC5, 0x92,
+         0xC0, 0xD3, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x05, 0x92, 0x01, 0xD2, 0x40, 0x98, 0x0F, 0x9F, 0x7E, 0xF6, 0x41, 0x08, 0x0C, 0x49, 0xFE, 0x7F,
+         0x02, 0x8E, 0x0F, 0x9F, 0x95, 0xF6, 0xC5, 0x94, 0x01, 0x96, 0xC3, 0x94, 0x1A, 0xD5, 0x9F, 0xEC, 0x12, 0x95, 0x9F, 0xEC, 0x0A, 0xB5, 0x40, 0x00, 0x1A, 0xD5, 0x9F, 0xEC, 0xC3, 0x92, 0x09, 0xB3,
+         0x40, 0x00, 0x01, 0x45, 0x02, 0x5E, 0x0F, 0x9F, 0x7D, 0xF6, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x44, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x07, 0x00, 0x07, 0x94, 0xC5, 0xD4,
+         0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x01, 0xD4, 0x42, 0x02, 0xC1, 0x92, 0x02, 0xD2, 0x79, 0x95, 0x7A, 0x95, 0x40, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0xFA, 0xF6, 0x11, 0x93, 0xD6, 0xF7, 0x42, 0x42,
+         0x02, 0x4E, 0x0F, 0x9F, 0xB6, 0xF6, 0x41, 0x96, 0x1B, 0xD7, 0xD6, 0xF7, 0x03, 0xD4, 0x40, 0x92, 0xC8, 0xD2, 0x0A, 0x95, 0xA0, 0x00, 0xC8, 0xD4, 0x40, 0xF0, 0x3E, 0xF6, 0x02, 0x96, 0x1B, 0xD7,
+         0x2C, 0x93, 0xC5, 0x94, 0x03, 0x92, 0x01, 0x05, 0x01, 0x92, 0x03, 0x96, 0x03, 0x03, 0xC1, 0x92, 0xC2, 0xD2, 0xC5, 0x92, 0xC8, 0xD2, 0x40, 0xF0, 0x74, 0xF6, 0x43, 0x00, 0x03, 0x94, 0x41, 0x04,
+         0x03, 0xD4, 0x4F, 0x44, 0x02, 0x9E, 0x0F, 0x9F, 0xB7, 0xF6, 0x40, 0x96, 0x03, 0xD6, 0xC5, 0x92, 0xC1, 0x94, 0x0A, 0xB5, 0xFF, 0x00, 0x01, 0x96, 0xC3, 0x92, 0x0F, 0x9F, 0xEF, 0xF6, 0x03, 0x94,
+         0x41, 0x04, 0x03, 0xD4, 0x4F, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x22, 0xF7, 0xC5, 0x92, 0x02, 0x03, 0xC1, 0x94, 0x0A, 0xB5, 0xFF, 0x00, 0x01, 0x92, 0x03, 0x96, 0x03, 0x03, 0xC1, 0x92, 0x09, 0xB3,
+         0xFF, 0x00, 0x01, 0x45, 0x02, 0x4E, 0x0F, 0x9F, 0xDF, 0xF6, 0x42, 0x92, 0x19, 0xD3, 0xD6, 0xF7, 0x0F, 0x9F, 0x22, 0xF7, 0x41, 0x94, 0xC8, 0xD4, 0x0B, 0x97, 0xE8, 0x00, 0xC8, 0xD6, 0x40, 0xF0,
+         0x3E, 0xF6, 0x41, 0x92, 0xC8, 0xD2, 0x4F, 0x94, 0xC8, 0xD4, 0x40, 0xF0, 0x3E, 0xF6, 0x02, 0x96, 0x1B, 0xD7, 0x2C, 0x93, 0x40, 0x92, 0x03, 0xD2, 0x44, 0x00, 0xC5, 0x94, 0x03, 0x96, 0x03, 0x05,
+         0x01, 0x92, 0x03, 0x03, 0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x06, 0x03, 0xD6, 0x4F, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0x0D, 0xF7, 0x41, 0x92, 0xC8, 0xD2, 0x0A, 0x95, 0xD0, 0x00, 0xC8, 0xD4, 0x40, 0xF0,
+         0x3E, 0xF6, 0x42, 0x00, 0x0A, 0x65, 0xD4, 0x6C, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFD, 0xFF, 0xC2, 0xD2, 0x44, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0,
+         0xB1, 0xFE, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x40, 0x19, 0xD3, 0xF2, 0xBD, 0x40, 0xF0,
+         0x73, 0xF4, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x49, 0xF7, 0x40, 0xF0, 0x94, 0xF2, 0x0F, 0x9F, 0x57, 0xF7, 0x40, 0x96, 0xC8, 0xD6, 0x09, 0x93, 0x91, 0xEC, 0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF,
+         0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92,
+         0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3, 0x2D, 0xBC, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97,
+         0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x11, 0x93,
+         0x03, 0xEC, 0x19, 0xD3, 0x01, 0x82, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97, 0xC3, 0x92, 0x43, 0xA2, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x03, 0x92, 0x04, 0x96,
+         0x0D, 0x5E, 0x50, 0x46, 0x02, 0x0E, 0x40, 0x92, 0x09, 0xEE, 0x44, 0x46, 0x04, 0x0E, 0x59, 0x93, 0x44, 0x26, 0x04, 0x5E, 0x46, 0xEE, 0x41, 0x93, 0x41, 0x26, 0x43, 0x4E, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x03, 0x94, 0x1A, 0xD5, 0xA7, 0xF7, 0x11, 0x93, 0x00, 0x90, 0x88, 0x98, 0x90, 0x9A, 0x1D, 0x00, 0x1A, 0x00, 0x03, 0x00, 0x03, 0x00, 0x18, 0x00, 0x19, 0x00,
+         0x1A, 0x00, 0x1B, 0x00, 0x16, 0x00, 0x21, 0x00, 0x12, 0x00, 0x09, 0x00, 0x13, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x21, 0x00, 0x2D, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0xF2, 0xCA, 0xF7, 0x00, 0x00, 0x74, 0xF2, 0xCA, 0xF7, 0x00, 0x00, 0xB9, 0xF2, 0xC7, 0xF7, 0xCE, 0xF7, 0x00, 0x00, 0x97, 0xF3,
+         0xCA, 0xF7, 0x05, 0x46, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+ };
+#elif defined(ZD1211B)
+={
+         0x08, 0x91, 0xFF, 0xED, 0x09, 0x93, 0x1E, 0xEE, 0xD1, 0x94, 0x11, 0xEE, 0x88, 0xD4, 0xD1, 0x96, 0xD1, 0x98, 0x5C, 0x99, 0x5C, 0x99, 0x4C, 0x99, 0x04, 0x9D, 0xD1, 0x98, 0xD1, 0x9A, 0x03, 0xEE,
+         0xF4, 0x94, 0xD3, 0xD4, 0x41, 0x2A, 0x40, 0x4A, 0x45, 0xBE, 0x88, 0x92, 0x41, 0x24, 0x40, 0x44, 0x53, 0xBE, 0x40, 0xF0, 0x93, 0xEE, 0x41, 0xEE, 0x98, 0x9A, 0x25, 0xF7, 0x02, 0x00, 0x1F, 0xEC,
+         0x00, 0x00, 0xB2, 0xF8, 0x4D, 0x00, 0x9A, 0xEC, 0x00, 0x00, 0x1E, 0xF7, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xD8, 0xA0, 0x90, 0x98, 0x9A, 0x98, 0x9A, 0xA0, 0xD8,
+         0x40, 0xF0, 0x5A, 0xEF, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0x39, 0xEF, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0x9C, 0xEF, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0,
+         0x9D, 0xF6, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0xBE, 0xF3, 0xA0, 0x90, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0, 0x97, 0xEF, 0xA0, 0x90, 0x98, 0x9A, 0x98, 0x9A, 0xA0, 0xD8, 0x40, 0xF0,
+         0x98, 0xF6, 0xA0, 0x90, 0x98, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x42, 0x02, 0xC1, 0x92, 0x03, 0x96, 0x1B, 0xD7, 0x2A, 0x86,
+         0x1A, 0xD5, 0x2B, 0x86, 0x09, 0xA3, 0x00, 0x80, 0x19, 0xD3, 0x2C, 0x86, 0x00, 0xEE, 0x0A, 0x65, 0xC0, 0x7A, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFE, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x05, 0x00, 0x05, 0x94, 0xC5, 0xD4, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x01, 0xD4, 0x42, 0x02, 0xC1, 0x96, 0x0A, 0x65, 0xC0, 0x7A,
+         0x02, 0x99, 0xC4, 0x92, 0x41, 0xA2, 0xC4, 0xD2, 0xC5, 0x98, 0x1C, 0xD9, 0x2A, 0x86, 0x01, 0x98, 0x1C, 0xD9, 0x2B, 0x86, 0x1B, 0xD7, 0x2C, 0x86, 0x00, 0xEE, 0x09, 0xB3, 0xFE, 0xFF, 0xC2, 0xD2,
+         0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xE5, 0xEE, 0x11, 0x93, 0x29, 0xF7, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xAE, 0xEE, 0x40, 0xF1,
+         0x40, 0x92, 0x19, 0xD3, 0x29, 0xF7, 0xC5, 0x92, 0x41, 0x92, 0x19, 0xD3, 0x00, 0x83, 0x40, 0x92, 0x19, 0xD3, 0x00, 0x83, 0x0F, 0x9F, 0x95, 0xF8, 0x0F, 0x9F, 0x99, 0xEE, 0x42, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0x99, 0xEE, 0x40, 0x92, 0x19, 0xD3, 0x29, 0xF7, 0x09, 0x93, 0x33, 0xF7, 0x19, 0xD3, 0x96, 0xEC, 0x40, 0xF0, 0x0C, 0xF1, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x0F, 0x9F,
+         0x99, 0xEE, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x12, 0x95, 0x19, 0xD3, 0x10, 0x95, 0x19, 0xD3, 0x02, 0x80, 0x19, 0xD3, 0x03, 0x82,
+         0x09, 0x93, 0x33, 0xF7, 0x19, 0xD3, 0x96, 0xEC, 0x40, 0xF0, 0x0C, 0xF1, 0x40, 0xF0, 0x89, 0xF2, 0x11, 0x93, 0x04, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xE3, 0xEE, 0x40, 0x92, 0x19, 0xD3,
+         0x04, 0xEC, 0x40, 0xF0, 0xE5, 0xF0, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x44, 0x96, 0x09, 0xB3, 0xFF, 0xFD, 0x19, 0xD3, 0x44, 0x96, 0x40, 0xF0, 0x91, 0xF6,
+         0x6E, 0x92, 0x19, 0xD3, 0x05, 0x84, 0x40, 0xF0, 0xC4, 0xEE, 0x4B, 0x62, 0x0A, 0x95, 0x2E, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x2B, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x00, 0xEE, 0xD1, 0xD4, 0x0B, 0x97,
+         0x2F, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x34, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x39, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x3E, 0xEE, 0xD1, 0xD4, 0x0B, 0x97, 0x43, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x48, 0xEE,
+         0xD1, 0xD4, 0x0B, 0x97, 0x4D, 0xEE, 0xD1, 0xD6, 0x0A, 0x95, 0x4E, 0xEE, 0xC1, 0xD4, 0x0A, 0x65, 0x00, 0x44, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x43, 0xF1, 0x09, 0x93, 0x01, 0x3F,
+         0x19, 0xD3, 0xC0, 0x85, 0x11, 0x93, 0x44, 0x96, 0x09, 0xB3, 0xFF, 0xFC, 0x19, 0xD3, 0x44, 0x96, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x03, 0x96,
+         0x41, 0x02, 0x03, 0x99, 0xC4, 0x94, 0x42, 0x04, 0xC1, 0x04, 0xC2, 0x94, 0xC3, 0xD4, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x03, 0x80, 0x09, 0xB3, 0x00, 0x10,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x4D, 0xEF, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x00, 0x04, 0xC2, 0xD2, 0x0F, 0x9F, 0x58, 0xEF, 0x48, 0x92, 0x19, 0xD3, 0x02, 0x80,
+         0x11, 0x93, 0x96, 0xEC, 0x41, 0x22, 0x0A, 0x95, 0x58, 0xEF, 0x88, 0xD4, 0x88, 0xDC, 0x91, 0x9A, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x04, 0x82, 0x48, 0xB2,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x6E, 0xEF, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFF, 0xFE, 0xC2, 0xD2, 0x41, 0x92, 0x19, 0xD3, 0x9E, 0xEC, 0x11, 0x93, 0x04, 0x82,
+         0x43, 0xB2, 0x12, 0x95, 0x03, 0x82, 0x02, 0xB3, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x95, 0xEF, 0x0A, 0xB3, 0x00, 0xFF, 0x48, 0xA2, 0x19, 0xD3, 0x03, 0x82, 0x40, 0xF0, 0x96, 0xF2, 0x11, 0x93,
+         0x9E, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x95, 0xEF, 0x11, 0x93, 0x07, 0x82, 0x11, 0x43, 0x03, 0xEC, 0x02, 0x0E, 0x0F, 0x9F, 0x95, 0xEF, 0x11, 0x93, 0x03, 0x82, 0x09, 0xA3, 0x00, 0x01,
+         0x19, 0xD3, 0x03, 0x82, 0x40, 0x96, 0x1B, 0xD7, 0x9E, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93,
+         0x20, 0xBC, 0xC8, 0xD2, 0x40, 0xF0, 0xF5, 0xEF, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x06, 0x00, 0x06, 0x94, 0xC5, 0xD4, 0x41, 0x02,
+         0xC1, 0x92, 0x01, 0xD2, 0xC1, 0x98, 0xC8, 0xD8, 0xC8, 0xD4, 0x40, 0xF0, 0xFA, 0xF6, 0x42, 0x00, 0xC5, 0x92, 0x09, 0x43, 0x00, 0x95, 0x02, 0x5E, 0x0F, 0x9F, 0xF2, 0xEF, 0x01, 0x94, 0xC2, 0x92,
+         0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xF2, 0xEF, 0x11, 0x93, 0x9F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xF2, 0xEF, 0x41, 0x98, 0x1C, 0xD9, 0x9F, 0xEC, 0x12, 0x95, 0x02, 0x80,
+         0x02, 0xD4, 0x40, 0xF0, 0x03, 0xF1, 0x0B, 0x67, 0xFD, 0x7D, 0x03, 0x99, 0xC4, 0x92, 0x0C, 0x99, 0x96, 0x03, 0x1C, 0xD9, 0x06, 0x82, 0x41, 0x98, 0x1C, 0xD9, 0x02, 0x82, 0x42, 0x98, 0x1C, 0xD9,
+         0x05, 0x82, 0x0C, 0x69, 0x80, 0x7F, 0x1C, 0xD9, 0x00, 0xB0, 0x09, 0xA3, 0x00, 0x01, 0xC3, 0xD2, 0x02, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xF0, 0xEF, 0x42, 0xA4,
+         0x1A, 0xD5, 0x02, 0x80, 0x43, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x05, 0x92, 0xC5, 0xD2, 0x60, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x02, 0xF0,
+         0x40, 0xF0, 0xDB, 0xF6, 0xC5, 0x94, 0x0A, 0xB3, 0x10, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x0B, 0xF0, 0x40, 0xF0, 0xE9, 0xF3, 0xC5, 0x96, 0x0B, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x14, 0xF0, 0x40, 0xF0, 0x40, 0xF3, 0xC5, 0x94, 0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x75, 0xF0, 0x13, 0x97, 0x21, 0xBC, 0x01, 0xD6, 0x0B, 0xB3, 0x02, 0x00,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x26, 0xF0, 0x40, 0xF0, 0x62, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x2F, 0xF0, 0x40, 0xF0, 0x6C, 0xFB, 0x01, 0x96,
+         0x0B, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x4F, 0xF0, 0x40, 0xF0, 0xB0, 0xFA, 0x41, 0x92, 0x19, 0xD3, 0x26, 0xF7, 0x11, 0x93, 0x03, 0xEC, 0x09, 0x43, 0x40, 0x00, 0x02, 0x5E,
+         0x0F, 0x9F, 0x45, 0xF0, 0x40, 0x94, 0x1A, 0xD5, 0x26, 0xF7, 0x11, 0x93, 0x00, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x58, 0xF0, 0x40, 0xF0, 0xE5, 0xF0, 0x0F, 0x9F, 0x58, 0xF0, 0x01, 0x96,
+         0x0B, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x58, 0xF0, 0x40, 0xF0, 0x7C, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x10, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x61, 0xF0, 0x40, 0xF0,
+         0x87, 0xFB, 0x11, 0x93, 0x10, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x6C, 0xF0, 0x44, 0x96, 0x1B, 0xD7, 0x0B, 0xBC, 0x0F, 0x9F, 0x72, 0xF0, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x72, 0xF0,
+         0x19, 0xD3, 0x0B, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0xC5, 0x94, 0x0A, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xBF, 0xF0, 0x13, 0x97, 0x28, 0xBC, 0x01, 0xD6, 0x0B, 0xB3,
+         0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x87, 0xF0, 0x40, 0xF0, 0xBE, 0xF6, 0x01, 0x94, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x9A, 0xF0, 0x40, 0xF0, 0xC4, 0xEE,
+         0x40, 0xF0, 0x8F, 0xFB, 0x40, 0xF0, 0xC8, 0xF0, 0x40, 0x96, 0x1B, 0xD7, 0x00, 0xEC, 0x41, 0x92, 0x19, 0xD3, 0x29, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0xB6, 0xF0, 0x40, 0xF0, 0x9E, 0xFB, 0x09, 0x63, 0x00, 0x44, 0x01, 0x97, 0xC3, 0x94, 0x48, 0xA4, 0xC1, 0xD4, 0x00, 0xEE, 0x40, 0x92, 0x19, 0xD3, 0x12, 0x95, 0x19, 0xD3, 0x10, 0x95, 0x19, 0xD3,
+         0x02, 0x80, 0x19, 0xD3, 0x03, 0x82, 0x41, 0x92, 0x19, 0xD3, 0x29, 0xF7, 0x01, 0x94, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xBF, 0xF0, 0x40, 0xF0, 0xAE, 0xFB, 0x0A, 0x65,
+         0x00, 0x44, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x40, 0x19, 0xD3, 0xF2, 0xBD, 0x0A, 0x65,
+         0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92,
+         0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92,
+         0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF,
+         0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x00, 0x01, 0x19, 0xD3, 0x02, 0x80, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93,
+         0x00, 0x09, 0x19, 0xD3, 0x02, 0x80, 0x40, 0xF0, 0x03, 0xF1, 0x40, 0x92, 0xC8, 0xD2, 0x09, 0x93, 0x96, 0xEC, 0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0x1E, 0xF3, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x30, 0xF1, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x0F, 0x9F, 0x3D, 0xF1,
+         0x40, 0xF0, 0x3F, 0xF1, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x3D, 0xF1, 0xC8, 0xD2, 0x09, 0x93, 0x96, 0xEC, 0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0xF1, 0xBD, 0x19, 0xD3, 0x9C, 0xEC, 0x11, 0x93, 0x9A, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x57, 0xF1, 0x09, 0x63, 0x00, 0x80, 0x01, 0x97, 0xC3, 0x94,
+         0x0A, 0x07, 0x07, 0x00, 0xC1, 0xD6, 0x0A, 0x05, 0x00, 0xA0, 0x1A, 0xD5, 0x98, 0xEC, 0x11, 0x93, 0x9C, 0xEC, 0x19, 0xD3, 0x01, 0x80, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x41, 0xA2,
+         0xC2, 0xD2, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x13, 0x97, 0x9A, 0xEC, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0xD7, 0xF1, 0x12, 0x95, 0x98, 0xEC,
+         0x0A, 0x03, 0x07, 0x00, 0xC1, 0x92, 0xC2, 0xD2, 0x11, 0x93, 0x98, 0xEC, 0x09, 0x05, 0x01, 0x00, 0x48, 0x02, 0xC1, 0x92, 0xC2, 0xD2, 0x11, 0x93, 0x98, 0xEC, 0x4E, 0x02, 0xC1, 0x94, 0xC5, 0xD6,
+         0xC5, 0x92, 0x11, 0x07, 0x98, 0xEC, 0x0B, 0x03, 0x0F, 0x00, 0xC1, 0x98, 0x46, 0x06, 0x7A, 0x93, 0x79, 0x93, 0x5C, 0x95, 0x5A, 0x95, 0x02, 0xA3, 0xC3, 0xD2, 0x04, 0x95, 0xC5, 0x96, 0x41, 0x06,
+         0xC5, 0xD6, 0x42, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0x80, 0xF1, 0x11, 0x93, 0x98, 0xEC, 0x09, 0x05, 0x05, 0x00, 0x41, 0x02, 0xC1, 0x92, 0xC2, 0xD2, 0x11, 0x93, 0x98, 0xEC, 0xC1, 0x92, 0x09, 0xB5,
+         0x1F, 0x00, 0x43, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0xAD, 0xF1, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0xAE, 0xF1, 0x0A, 0x05, 0xFF, 0xFF, 0x0F, 0x9F, 0xAE, 0xF1, 0x43, 0x94, 0x11, 0x93, 0x98, 0xEC,
+         0x42, 0x02, 0xC1, 0xD4, 0x11, 0x93, 0x98, 0xEC, 0x49, 0x02, 0xC1, 0x92, 0x19, 0xD3, 0x9A, 0xEC, 0x09, 0x05, 0xF2, 0xFF, 0x1A, 0xD5, 0x97, 0xEC, 0x09, 0x43, 0xD0, 0x07, 0x02, 0x9E, 0x0F, 0x9F,
+         0xD7, 0xF1, 0x11, 0x93, 0x2F, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0x2F, 0xF7, 0x11, 0x93, 0x2E, 0xF7, 0x09, 0xA3, 0x40, 0x00, 0x19, 0xD3, 0x2E, 0xF7, 0x09, 0x63, 0x00, 0x80, 0x01, 0x95, 0xC2, 0x94,
+         0x1A, 0xD5, 0x9B, 0xEC, 0x40, 0x96, 0x1B, 0xD7, 0x9A, 0xEC, 0x0F, 0x9F, 0x3D, 0xF2, 0x11, 0x93, 0x97, 0xEC, 0x12, 0x95, 0x9C, 0xEC, 0x02, 0x43, 0x02, 0x8E, 0x0F, 0x9F, 0x25, 0xF2, 0x02, 0x0E,
+         0x0F, 0x9F, 0xF8, 0xF1, 0x11, 0x93, 0x2F, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0x2F, 0xF7, 0x11, 0x93, 0x2E, 0xF7, 0x09, 0xA3, 0x80, 0x00, 0x19, 0xD3, 0x2E, 0xF7, 0x09, 0x63, 0x00, 0x80, 0x01, 0x95,
+         0xC2, 0x94, 0x1A, 0xD5, 0x9B, 0xEC, 0x40, 0x96, 0x1B, 0xD7, 0x9A, 0xEC, 0x0F, 0x9F, 0x3D, 0xF2, 0x11, 0x93, 0x03, 0x80, 0x09, 0xB3, 0x00, 0x40, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x0A, 0xF2,
+         0x11, 0x93, 0x9F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x0A, 0xF2, 0x40, 0xF0, 0x51, 0xF2, 0x0F, 0x9F, 0x3F, 0xF2, 0x41, 0x92, 0xC8, 0xD2, 0x0A, 0x95, 0x96, 0xEC, 0xC8, 0xD4, 0x40, 0xF0,
+         0x2A, 0xEF, 0x42, 0x00, 0x11, 0x93, 0x9F, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x1D, 0xF2, 0x42, 0x96, 0x1B, 0xD7, 0x9F, 0xEC, 0x0F, 0x9F, 0x3F, 0xF2, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97,
+         0xC3, 0x92, 0x42, 0xA2, 0xC2, 0xD2, 0x0F, 0x9F, 0x3F, 0xF2, 0x12, 0x45, 0x03, 0xEC, 0x02, 0x4E, 0x0F, 0x9F, 0x37, 0xF2, 0x11, 0x93, 0x2F, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0x2F, 0xF7, 0x11, 0x93,
+         0x2E, 0xF7, 0x09, 0xA3, 0x00, 0x08, 0x19, 0xD3, 0x2E, 0xF7, 0x1A, 0xD5, 0x97, 0xEC, 0x11, 0x93, 0x97, 0xEC, 0x19, 0x25, 0x97, 0xEC, 0x09, 0x63, 0x00, 0x80, 0x19, 0xD3, 0xF2, 0xBD, 0x41, 0x00,
+         0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0x51, 0xF2, 0x40, 0x92, 0xC8, 0xD2, 0x09, 0x93, 0x96, 0xEC, 0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x42, 0x00, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x28, 0xF7, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x61, 0xF2, 0x0A, 0x65, 0xBC, 0x69, 0x02, 0x97, 0xC3, 0x92, 0x09, 0x83, 0x00, 0x02,
+         0xC2, 0xD2, 0x11, 0x93, 0x03, 0x80, 0x09, 0xB3, 0x00, 0x40, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x74, 0xF2, 0x11, 0x93, 0x2F, 0xF7, 0x41, 0x02, 0x19, 0xD3, 0x2F, 0xF7, 0x11, 0x93, 0x2E, 0xF7,
+         0x09, 0xA3, 0x00, 0x20, 0x19, 0xD3, 0x2E, 0xF7, 0x11, 0x93, 0x9B, 0xEC, 0x19, 0xD3, 0x04, 0x80, 0x12, 0x95, 0x9A, 0xEC, 0x1A, 0xD5, 0x05, 0x80, 0x09, 0x63, 0x00, 0x80, 0x01, 0x97, 0xC3, 0x96,
+         0x1B, 0xD7, 0x9B, 0xEC, 0x40, 0x94, 0x1A, 0xD5, 0x9A, 0xEC, 0x19, 0xD3, 0xF2, 0xBD, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x96, 0x03, 0x19, 0xD3, 0x06, 0x82,
+         0x09, 0x93, 0x00, 0x01, 0x19, 0xD3, 0x03, 0x82, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x13, 0x97, 0x01, 0x82, 0x40, 0x92, 0xC5, 0xD2, 0x12, 0x95, 0x04, 0x82,
+         0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x0C, 0xF3, 0x0A, 0xA3, 0x02, 0x00, 0x19, 0xD3, 0x04, 0x82, 0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xC0, 0xF2, 0x41, 0x96,
+         0xC5, 0xD6, 0x0A, 0x65, 0xBD, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x80, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0x0F, 0x9F, 0xF2, 0xF2,
+         0x43, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0xF3, 0xF2, 0x4F, 0x98, 0x0B, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xCC, 0xF2, 0x47, 0x98, 0x11, 0x93, 0x9D, 0xEC, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0xED, 0xF2, 0x12, 0x95, 0x00, 0x82, 0x0A, 0x05, 0xFF, 0xAF, 0x01, 0xD4, 0xC8, 0xD8, 0x41, 0x92, 0xC8, 0xD2, 0x40, 0xF0, 0x09, 0xF7, 0x42, 0x00, 0x01, 0x96, 0xC3, 0x94, 0x01, 0xB5,
+         0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0xED, 0xF2, 0x02, 0x92, 0x50, 0x92, 0x19, 0xD3, 0xA2, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0xA2, 0xBC, 0x0F, 0x9F, 0xF3, 0xF2, 0x0A, 0x65, 0x5E, 0x43, 0x02, 0x97,
+         0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x41, 0x92, 0x19, 0xD3, 0x9D, 0xEC, 0x11, 0x93, 0x9E, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x07, 0xF3, 0x13, 0x97, 0x00, 0x82, 0x1B, 0xD7, 0x02, 0x82,
+         0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x00, 0x01, 0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3, 0x9E, 0xEC, 0x0F, 0x9F, 0x0F, 0xF3, 0xC5, 0x96, 0x1B, 0xD7, 0x9D, 0xEC, 0xC5, 0x92,
+         0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x1B, 0xF3, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x43, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x12, 0x95, 0x03, 0x80, 0x0A, 0xB3, 0x00, 0x40, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x3A, 0xF3, 0x0A, 0xB7, 0x00, 0x08, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0x3D, 0xF3, 0x11, 0x93,
+         0x03, 0xEC, 0x41, 0x02, 0x09, 0xB3, 0xFE, 0xFF, 0x12, 0x95, 0x07, 0x80, 0x01, 0x45, 0x02, 0x8E, 0x0F, 0x9F, 0x3D, 0xF3, 0x41, 0x92, 0x0F, 0x9F, 0x3E, 0xF3, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x0C, 0x69, 0xFF, 0x6F, 0x1C, 0xD9, 0xF8, 0xBC, 0x13, 0x97,
+         0x6E, 0xEC, 0x0B, 0x47, 0x10, 0x95, 0x02, 0x5E, 0x0F, 0x9F, 0x65, 0xF3, 0x0A, 0x95, 0x6F, 0xEC, 0x09, 0x63, 0x06, 0x43, 0x01, 0x99, 0xC4, 0xD6, 0xD2, 0x96, 0x1B, 0xD7, 0xF8, 0xBC, 0x0C, 0x69,
+         0xEE, 0x6A, 0xC1, 0xD8, 0xC2, 0x94, 0x1A, 0xD5, 0xF8, 0xBC, 0x40, 0x92, 0xC5, 0xD2, 0x11, 0x43, 0xA0, 0xEC, 0x02, 0x0E, 0x0F, 0x9F, 0x88, 0xF3, 0xC5, 0x94, 0x0A, 0x03, 0x71, 0xEC, 0xC1, 0x94,
+         0x1A, 0xD5, 0xFA, 0xBC, 0x11, 0x93, 0x9F, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x7A, 0xF3, 0x0A, 0x95, 0x6F, 0xEC, 0xC8, 0xD4, 0x40, 0xF0, 0xF0, 0xF6, 0x19, 0xD3, 0xF8, 0xBC, 0x41, 0x00,
+         0xC5, 0x96, 0x41, 0x06, 0xC5, 0xD6, 0x13, 0x47, 0xA0, 0xEC, 0x02, 0x1E, 0x0F, 0x9F, 0x6C, 0xF3, 0x40, 0x92, 0x19, 0xD3, 0xFA, 0xBC, 0x19, 0xD3, 0x6E, 0xEC, 0x19, 0xD3, 0xA0, 0xEC, 0x0A, 0x65,
+         0x52, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x06, 0x92, 0x01, 0xD2, 0x0A, 0x65, 0xF0, 0x6A, 0x0B, 0x97, 0x6F, 0xEC, 0x02, 0x99, 0xC4, 0x98, 0xD3, 0xD8, 0x02, 0xD6, 0x0A, 0x03, 0x02, 0x00, 0x01, 0x97,
+         0xC3, 0x98, 0x02, 0x96, 0xC3, 0xD8, 0x01, 0x96, 0xC1, 0xD6, 0x1A, 0xD5, 0x6E, 0xEC, 0xC5, 0x98, 0x14, 0x99, 0x6F, 0xEC, 0xC2, 0xD8, 0x43, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x40, 0x92, 0xC8, 0xD2, 0x40, 0xF0, 0x9F, 0xF3, 0x41, 0x00, 0x11, 0x93, 0x9F, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xD9, 0xF3, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xD6, 0xF3,
+         0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x42, 0xA2, 0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3, 0x9F, 0xEC, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2,
+         0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x6E, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0xAF, 0xBC, 0x47, 0xB2,
+         0x59, 0x95, 0x5A, 0x95, 0x12, 0xA5, 0xBF, 0xBC, 0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xFB, 0xF3, 0x41, 0x04, 0x05, 0x93, 0x40, 0x96, 0x20, 0xD6, 0x62, 0x97, 0x0F, 0x9F,
+         0x0A, 0xF4, 0x14, 0x99, 0xFC, 0xBC, 0xD1, 0xD8, 0x14, 0x99, 0xFE, 0xBC, 0xD1, 0xD8, 0x20, 0x98, 0x42, 0x08, 0x20, 0xD8, 0x20, 0x98, 0x03, 0x49, 0x02, 0x1E, 0x0F, 0x9F, 0x01, 0xF4, 0xC5, 0x92,
+         0x64, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xF8, 0xF4, 0x02, 0x8E, 0x0F, 0x9F, 0x24, 0xF4, 0x62, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x3D, 0xF4, 0x02, 0x8E, 0x0F, 0x9F, 0xEC, 0xF4, 0x61, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0xC9, 0xF4, 0x0F, 0x9F, 0x5A, 0xF5, 0x68, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x5A, 0xF4, 0x02, 0x8E, 0x0F, 0x9F, 0x31, 0xF4, 0x65, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x04, 0xF5, 0x0F, 0x9F,
+         0x5A, 0xF5, 0x09, 0x43, 0x28, 0x01, 0x02, 0x4E, 0x0F, 0x9F, 0x53, 0xF4, 0x09, 0x43, 0x28, 0x02, 0x02, 0x4E, 0x0F, 0x9F, 0x8E, 0xF4, 0x0F, 0x9F, 0x5A, 0xF5, 0x0D, 0x03, 0x01, 0x00, 0x0C, 0x99,
+         0x71, 0xEC, 0x0B, 0x05, 0xFF, 0xFF, 0x40, 0x96, 0x0F, 0x9F, 0x4A, 0xF4, 0xD1, 0x96, 0xD4, 0xD6, 0x20, 0x96, 0x41, 0x06, 0x20, 0xD6, 0x02, 0x47, 0x02, 0x1E, 0x0F, 0x9F, 0x46, 0xF4, 0x1A, 0xD5,
+         0xA0, 0xEC, 0x0F, 0x9F, 0xB9, 0xF4, 0x0C, 0x69, 0x00, 0x08, 0x1C, 0xD9, 0x6D, 0xEC, 0x40, 0x92, 0x19, 0xD3, 0x6C, 0xEC, 0x40, 0x94, 0x20, 0xD4, 0x11, 0x93, 0x6D, 0xEC, 0x09, 0x43, 0xF4, 0xFF,
+         0x02, 0x8E, 0x0F, 0x9F, 0x5A, 0xF5, 0x0D, 0x07, 0x02, 0x00, 0x2A, 0xD6, 0x0D, 0x09, 0x01, 0x00, 0x04, 0x93, 0xC1, 0x94, 0x42, 0x08, 0x0A, 0xB5, 0xFF, 0x00, 0x2A, 0x96, 0xC3, 0x92, 0x42, 0x06,
+         0x2A, 0xD6, 0x59, 0x93, 0x59, 0x93, 0x01, 0xA5, 0x11, 0x93, 0x6D, 0xEC, 0xC1, 0xD4, 0x12, 0x95, 0x6D, 0xEC, 0x11, 0x93, 0x6C, 0xEC, 0xD2, 0x82, 0x19, 0xD3, 0x6C, 0xEC, 0x1A, 0xD5, 0x6D, 0xEC,
+         0x20, 0x96, 0x42, 0x06, 0x20, 0xD6, 0x47, 0x46, 0x02, 0x8E, 0x0F, 0x9F, 0x5A, 0xF5, 0x0A, 0x45, 0xF4, 0xFF, 0x02, 0x9E, 0x0F, 0x9F, 0x68, 0xF4, 0x0F, 0x9F, 0x5A, 0xF5, 0x11, 0x93, 0x6C, 0xEC,
+         0x09, 0xB5, 0xFF, 0x00, 0x79, 0x93, 0x79, 0x93, 0x01, 0x85, 0x1A, 0xD5, 0x6C, 0xEC, 0x01, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0xB3, 0xF4, 0x6F, 0x98, 0x1C, 0xD9, 0x05, 0x84, 0x40, 0xF1, 0x09, 0x93,
+         0xF7, 0x07, 0xC8, 0xD2, 0x0A, 0x65, 0x00, 0x08, 0xC8, 0xD4, 0x40, 0x96, 0xC8, 0xD6, 0x40, 0xF0, 0x53, 0xEE, 0x43, 0xF1, 0x6D, 0x98, 0x1C, 0xD9, 0x05, 0x84, 0x41, 0x92, 0x19, 0xD3, 0x71, 0xEC,
+         0x43, 0x00, 0x0F, 0x9F, 0xB6, 0xF4, 0x40, 0x94, 0x1A, 0xD5, 0x71, 0xEC, 0x41, 0x96, 0x1B, 0xD7, 0xA0, 0xEC, 0x0A, 0x65, 0xEB, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xA3, 0xC0, 0x00, 0xC2, 0xD2,
+         0x0A, 0x65, 0xE9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x0F, 0x9F, 0x5A, 0xF5, 0x0A, 0x03, 0xFE, 0xFF, 0x61, 0x95, 0x40, 0x98, 0x20, 0xD8, 0x02, 0x49, 0x02, 0x0E,
+         0x0F, 0x9F, 0x5A, 0xF5, 0x0D, 0x03, 0x01, 0x00, 0x29, 0xD2, 0x20, 0x92, 0x05, 0x03, 0x42, 0x02, 0xC8, 0xD2, 0x29, 0x96, 0xC3, 0x92, 0x42, 0x06, 0x29, 0xD6, 0xC8, 0xD2, 0x2B, 0xD4, 0x40, 0xF0,
+         0xA7, 0xEF, 0x42, 0x00, 0x20, 0x98, 0x42, 0x08, 0x20, 0xD8, 0x2B, 0x94, 0x02, 0x49, 0x02, 0x1E, 0x0F, 0x9F, 0xD5, 0xF4, 0x0F, 0x9F, 0x5A, 0xF5, 0x0D, 0x03, 0x03, 0x00, 0xC8, 0xD2, 0x02, 0x92,
+         0xC8, 0xD2, 0x01, 0x94, 0xC8, 0xD4, 0x40, 0xF0, 0x5D, 0xF5, 0x43, 0x00, 0x0F, 0x9F, 0x5A, 0xF5, 0x01, 0x96, 0xC8, 0xD6, 0x0D, 0x03, 0x03, 0x00, 0xC8, 0xD2, 0x02, 0x98, 0xC8, 0xD8, 0x40, 0xF0,
+         0xFD, 0xF5, 0x43, 0x00, 0x0F, 0x9F, 0x5A, 0xF5, 0x40, 0x92, 0x40, 0x94, 0x19, 0xD3, 0x2B, 0xF7, 0x1A, 0xD5, 0x2C, 0xF7, 0x01, 0x92, 0x19, 0xD3, 0x6D, 0xEC, 0x40, 0x94, 0x20, 0xD4, 0x02, 0x92,
+         0x01, 0x45, 0x02, 0x0E, 0x0F, 0x9F, 0x5A, 0xF5, 0x21, 0xD2, 0x13, 0x97, 0x6D, 0xEC, 0x22, 0xD6, 0xC3, 0x92, 0x09, 0xB5, 0xFF, 0x00, 0x02, 0x97, 0x40, 0x98, 0x79, 0x93, 0x79, 0x93, 0x2C, 0xD2,
+         0x40, 0x94, 0x23, 0xD2, 0x24, 0xD4, 0x23, 0x92, 0x03, 0x03, 0x01, 0x95, 0x25, 0xD4, 0x41, 0x94, 0x03, 0x43, 0x02, 0x1E, 0x0F, 0x9F, 0x2D, 0xF5, 0x40, 0x94, 0x24, 0x92, 0x04, 0x03, 0x02, 0x03,
+         0x26, 0xD2, 0x11, 0x93, 0x2B, 0xF7, 0x12, 0x95, 0x2C, 0xF7, 0x27, 0xD2, 0x28, 0xD4, 0x25, 0x92, 0x27, 0x94, 0x02, 0x03, 0x01, 0x97, 0x41, 0x94, 0x2D, 0xD4, 0x27, 0x94, 0x02, 0x43, 0x02, 0x1E,
+         0x0F, 0x9F, 0x44, 0xF5, 0x40, 0x92, 0x2D, 0xD2, 0x26, 0x92, 0x28, 0x94, 0x02, 0x03, 0x01, 0x99, 0x2D, 0x94, 0x02, 0x09, 0x1B, 0xD7, 0x2B, 0xF7, 0x1C, 0xD9, 0x2C, 0xF7, 0x22, 0x96, 0x0B, 0x03,
+         0x01, 0x00, 0x19, 0xD3, 0x6D, 0xEC, 0x20, 0x98, 0x41, 0x08, 0x20, 0xD8, 0x21, 0x48, 0x02, 0x1E, 0x0F, 0x9F, 0x15, 0xF5, 0x6E, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x45, 0x20, 0x08, 0x0B,
+         0x01, 0x00, 0x0D, 0x03, 0x08, 0x00, 0x08, 0x94, 0xC5, 0xD4, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x03, 0xD4, 0x42, 0x02, 0xC1, 0x92, 0x01, 0xD2, 0x02, 0x97, 0xC5, 0x94, 0x0A, 0x83, 0xFF, 0xFF,
+         0x11, 0xB3, 0x2C, 0x93, 0x09, 0xB3, 0xFB, 0xFF, 0x19, 0xD3, 0x2C, 0x93, 0x03, 0x92, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x90, 0xF5, 0x01, 0x94, 0xD2, 0x92, 0x19, 0xD3, 0x2C, 0x93, 0x01, 0xD4,
+         0x02, 0x94, 0x12, 0x95, 0x2C, 0x93, 0x44, 0xA4, 0x1A, 0xD5, 0x2C, 0x93, 0x0A, 0xB5, 0xFB, 0xFF, 0x1A, 0xD5, 0x2C, 0x93, 0x0B, 0x07, 0xFF, 0xFF, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0x7B, 0xF5,
+         0x09, 0x63, 0xD4, 0x6C, 0x01, 0x95, 0xC2, 0x96, 0xC5, 0x94, 0x02, 0xA7, 0xC1, 0xD6, 0x03, 0x92, 0x54, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xA0, 0xF5, 0x0A, 0x83, 0xFF, 0xFF, 0x1B, 0xB3, 0x2C, 0x93,
+         0x45, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x04, 0x00, 0x04, 0x94, 0xC5, 0xD4, 0x41, 0x02, 0xC1, 0x92, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F,
+         0xCD, 0xF5, 0x09, 0x63, 0xD4, 0x6C, 0x01, 0x97, 0xC3, 0x94, 0x0A, 0xB5, 0xFD, 0xFF, 0xC3, 0xD4, 0x0B, 0x97, 0xAA, 0x00, 0x1B, 0xD7, 0x55, 0x05, 0x00, 0xEE, 0x42, 0xA4, 0x01, 0x97, 0xC3, 0xD4,
+         0x0B, 0x97, 0x55, 0x00, 0x1B, 0xD7, 0xAA, 0x02, 0x00, 0xEE, 0x0A, 0xB5, 0xFD, 0xFF, 0xC1, 0xD4, 0xC5, 0x92, 0x19, 0xD3, 0x55, 0x05, 0x0F, 0x9F, 0xD6, 0xF5, 0x0A, 0x65, 0xD4, 0x6C, 0x02, 0x97,
+         0xC3, 0x92, 0x09, 0xB3, 0xFD, 0xFF, 0xC2, 0xD2, 0xC5, 0x92, 0xC0, 0xD3, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x05, 0x92, 0x01, 0xD2, 0x40, 0x98,
+         0x0F, 0x9F, 0xE3, 0xF5, 0x41, 0x08, 0x0C, 0x49, 0xFE, 0x7F, 0x02, 0x8E, 0x0F, 0x9F, 0xFA, 0xF5, 0xC5, 0x94, 0x01, 0x96, 0xC3, 0x94, 0x1A, 0xD5, 0x99, 0xEC, 0x12, 0x95, 0x99, 0xEC, 0x0A, 0xB5,
+         0x40, 0x00, 0x1A, 0xD5, 0x99, 0xEC, 0xC3, 0x92, 0x09, 0xB3, 0x40, 0x00, 0x01, 0x45, 0x02, 0x5E, 0x0F, 0x9F, 0xE2, 0xF5, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x44, 0x20, 0x08, 0x0B,
+         0x01, 0x00, 0x0D, 0x03, 0x07, 0x00, 0x07, 0x94, 0xC5, 0xD4, 0x09, 0x05, 0x01, 0x00, 0xC2, 0x94, 0x01, 0xD4, 0x42, 0x02, 0xC1, 0x92, 0x02, 0xD2, 0x79, 0x95, 0x7A, 0x95, 0x40, 0x44, 0x02, 0x5E,
+         0x0F, 0x9F, 0x5F, 0xF6, 0x11, 0x93, 0x2B, 0xF7, 0x42, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x1B, 0xF6, 0x41, 0x96, 0x1B, 0xD7, 0x2B, 0xF7, 0x03, 0xD4, 0x40, 0x92, 0xC8, 0xD2, 0x0A, 0x95, 0xA0, 0x00,
+         0xC8, 0xD4, 0x40, 0xF0, 0xA3, 0xF5, 0x02, 0x96, 0x1B, 0xD7, 0x2C, 0x93, 0xC5, 0x94, 0x03, 0x92, 0x01, 0x05, 0x01, 0x92, 0x03, 0x96, 0x03, 0x03, 0xC1, 0x92, 0xC2, 0xD2, 0xC5, 0x92, 0xC8, 0xD2,
+         0x40, 0xF0, 0xD9, 0xF5, 0x43, 0x00, 0x03, 0x94, 0x41, 0x04, 0x03, 0xD4, 0x4F, 0x44, 0x02, 0x9E, 0x0F, 0x9F, 0x1C, 0xF6, 0x40, 0x96, 0x03, 0xD6, 0xC5, 0x92, 0xC1, 0x94, 0x0A, 0xB5, 0xFF, 0x00,
+         0x01, 0x96, 0xC3, 0x92, 0x0F, 0x9F, 0x54, 0xF6, 0x03, 0x94, 0x41, 0x04, 0x03, 0xD4, 0x4F, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x87, 0xF6, 0xC5, 0x92, 0x02, 0x03, 0xC1, 0x94, 0x0A, 0xB5, 0xFF, 0x00,
+         0x01, 0x92, 0x03, 0x96, 0x03, 0x03, 0xC1, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x01, 0x45, 0x02, 0x4E, 0x0F, 0x9F, 0x44, 0xF6, 0x42, 0x92, 0x19, 0xD3, 0x2B, 0xF7, 0x0F, 0x9F, 0x87, 0xF6, 0x41, 0x94,
+         0xC8, 0xD4, 0x0B, 0x97, 0xE8, 0x00, 0xC8, 0xD6, 0x40, 0xF0, 0xA3, 0xF5, 0x41, 0x92, 0xC8, 0xD2, 0x4F, 0x94, 0xC8, 0xD4, 0x40, 0xF0, 0xA3, 0xF5, 0x02, 0x96, 0x1B, 0xD7, 0x2C, 0x93, 0x40, 0x92,
+         0x03, 0xD2, 0x44, 0x00, 0xC5, 0x94, 0x03, 0x96, 0x03, 0x05, 0x01, 0x92, 0x03, 0x03, 0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x06, 0x03, 0xD6, 0x4F, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0x72, 0xF6, 0x41, 0x92,
+         0xC8, 0xD2, 0x0A, 0x95, 0xD0, 0x00, 0xC8, 0xD4, 0x40, 0xF0, 0xA3, 0xF5, 0x42, 0x00, 0x0A, 0x65, 0xD4, 0x6C, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFD, 0xFF, 0xC2, 0xD2, 0x44, 0x00, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xB1, 0xFE, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00,
+         0x09, 0x63, 0x00, 0x40, 0x19, 0xD3, 0xF2, 0xBD, 0x40, 0xF0, 0x1E, 0xF3, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xAE, 0xF6, 0x40, 0xF0, 0x3F, 0xF1, 0x0F, 0x9F, 0xBC, 0xF6, 0x40, 0x96, 0xC8, 0xD6,
+         0x09, 0x93, 0x96, 0xEC, 0xC8, 0xD2, 0x40, 0xF0, 0x2A, 0xEF, 0x0A, 0x65, 0xFE, 0x7F, 0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x0A, 0x65, 0xE8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC2, 0xD2, 0x0A, 0x65, 0xEA, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x40, 0x92,
+         0x19, 0xD3, 0x2D, 0xBC, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xBF, 0xFF, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xEA, 0x43,
+         0x02, 0x97, 0xC3, 0x92, 0x44, 0xA2, 0xC2, 0xD2, 0x11, 0x93, 0x03, 0xEC, 0x19, 0xD3, 0x01, 0x82, 0x0A, 0x65, 0xFD, 0x7D, 0x02, 0x97, 0xC3, 0x92, 0x43, 0xA2, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x03, 0x94, 0x1A, 0xD5, 0xF7, 0xF6, 0x11, 0x93, 0x00, 0x90, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0D, 0x03, 0x03, 0x00, 0x09, 0x07,
+         0x01, 0x00, 0xC3, 0x94, 0xC1, 0x96, 0x1B, 0xD7, 0x06, 0xF7, 0x1A, 0xD5, 0x00, 0x90, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x03, 0x92, 0x04, 0x96, 0x0D, 0x5E, 0x50, 0x46,
+         0x02, 0x0E, 0x40, 0x92, 0x09, 0xEE, 0x44, 0x46, 0x04, 0x0E, 0x59, 0x93, 0x44, 0x26, 0x04, 0x5E, 0x46, 0xEE, 0x41, 0x93, 0x41, 0x26, 0x43, 0x4E, 0x88, 0x98, 0x90, 0x9A, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x48, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0xF1, 0x39, 0xF7, 0x00, 0x00, 0x1F, 0xF1, 0x39, 0xF7, 0x00, 0x00, 0x64, 0xF1, 0x36, 0xF7, 0x3D, 0xF7, 0x00, 0x00, 0x42, 0xF2, 0x39, 0xF7,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+ };
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/WS11Ub.h linux-2.4.35.3-mct/drivers/usb/zd1211/WS11Ub.h
--- linux-2.4.35.3/drivers/usb/zd1211/WS11Ub.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/WS11Ub.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,259 @@
+#ifdef ZD1211
+={
+         0x00, 0xF0, 0x66, 0xFE, 0x67, 0xFE, 0x68, 0xFE, 0x69, 0xFE, 0x6A, 0xFE, 0x6B, 0xFE, 0x6C, 0xFE, 0x6D, 0xFE, 0x09, 0x63, 0xD6, 0x79, 0x57, 0x94, 0xD1, 0xD4, 0x0A, 0x95, 0x17, 0xF8, 0xD1, 0xD4,
+         0x0A, 0x95, 0xD2, 0x07, 0x00, 0xEE, 0xC1, 0xD4, 0x00, 0xEE, 0x0F, 0x9F, 0x95, 0xF8, 0x30, 0x43, 0x10, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x66, 0x66, 0x66, 0x00, 0x00, 0x6A, 0x6A,
+         0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xFF, 0x07,
+         0x00, 0x00, 0x12, 0x01, 0x00, 0x02, 0xFF, 0xFF, 0xFF, 0x40, 0xCE, 0x0A, 0x11, 0x12, 0x30, 0x43, 0x10, 0x20, 0x00, 0x01, 0x04, 0x03, 0x09, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x52,
+         0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0x4A, 0x4A,
+         0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0x42, 0x42,
+         0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0x0C, 0x03,
+         0x5A, 0x00, 0x79, 0x00, 0x44, 0x00, 0x41, 0x00, 0x53, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x18, 0x03, 0x55, 0x00, 0x53, 0x00, 0x42, 0x00, 0x32, 0x00, 0x2E, 0x00,
+         0x30, 0x00, 0x20, 0x00, 0x57, 0x00, 0x4C, 0x00, 0x41, 0x00, 0x4E, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x88, 0x88,
+         0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x08, 0x91, 0xFF, 0xED, 0x09, 0x93, 0xC7, 0xFE, 0xD1, 0x94, 0x11, 0xEE, 0x88, 0xD4, 0xD1, 0x96, 0xD1, 0x98, 0x5C, 0x99, 0x5C, 0x99,
+         0x4C, 0x99, 0x04, 0x9D, 0xD1, 0x98, 0xD1, 0x9A, 0x03, 0xEE, 0xF4, 0x94, 0xD3, 0xD4, 0x41, 0x2A, 0x40, 0x4A, 0x45, 0xBE, 0x88, 0x92, 0x41, 0x24, 0x40, 0x44, 0x53, 0xBE, 0x40, 0xF0, 0xE0, 0xFE,
+         0x41, 0xEE, 0x98, 0x9A, 0x09, 0x02, 0x2E, 0x00, 0x01, 0x01, 0x00, 0x80, 0xFA, 0x09, 0x04, 0x00, 0x00, 0x04, 0xFF, 0x00, 0x00, 0x00, 0x07, 0x05, 0x01, 0x02, 0x00, 0x02, 0x00, 0x07, 0x05, 0x82,
+         0x02, 0x00, 0x02, 0x00, 0x07, 0x05, 0x83, 0x03, 0x40, 0x00, 0x01, 0x07, 0x05, 0x04, 0x03, 0x40, 0x00, 0x01, 0x09, 0x02, 0x2E, 0x00, 0x01, 0x01, 0x00, 0x80, 0xFA, 0x09, 0x04, 0x00, 0x00, 0x04,
+         0xFF, 0x00, 0x00, 0x00, 0x07, 0x05, 0x01, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x82, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x83, 0x03, 0x40, 0x00, 0x01, 0x07, 0x05, 0x04, 0x02, 0x40, 0x00, 0x00,
+         0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
+         0xEE, 0xEE, 0xEE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0xFC, 0x7E, 0xBF, 0xDF, 0xFB, 0xFD, 0xFB, 0xFD, 0xCA, 0xFB,
+         0xCE, 0xFB, 0x12, 0xFC, 0xD2, 0xFB, 0x12, 0xFC, 0xD6, 0xFB, 0xE0, 0xFB, 0x12, 0xFC, 0xEA, 0xFB, 0xF4, 0xFB, 0xFE, 0xFB, 0x08, 0xFC, 0xE7, 0xFC, 0xEB, 0xFC, 0xF6, 0xFC, 0x35, 0xFD, 0x35, 0xFD,
+         0x20, 0xFD, 0x2B, 0xFD, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x00, 0xEC, 0x41, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0x81, 0xF9, 0x11, 0x93, 0x01, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F,
+         0x81, 0xF9, 0x11, 0x93, 0x02, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x81, 0xF9, 0x4F, 0x96, 0x1B, 0xD7, 0x30, 0xBC, 0x1A, 0xD5, 0x80, 0xBC, 0x0C, 0x99, 0x86, 0x00, 0x1C, 0xD9, 0x90, 0xBC,
+         0x46, 0x94, 0x0C, 0x69, 0x6F, 0x43, 0x01, 0x97, 0xD4, 0xD4, 0x0B, 0x07, 0xFF, 0xFF, 0x40, 0x46, 0x02, 0x3E, 0x0F, 0x9F, 0x34, 0xF9, 0x42, 0x96, 0x1B, 0xD7, 0x61, 0xBC, 0x40, 0x92, 0x19, 0xD3,
+         0x60, 0xBC, 0x0A, 0x65, 0xBF, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0x9F, 0xFF, 0xC4, 0xD2, 0x0A, 0x95, 0xF2, 0x00, 0x1A, 0xD5, 0x31, 0xBC, 0x52, 0x98, 0x1C, 0xD9, 0x82, 0xBC, 0x09, 0x93,
+         0x82, 0x00, 0x19, 0xD3, 0x92, 0xBC, 0x40, 0x94, 0x1A, 0xD5, 0x42, 0xBC, 0x0B, 0xA3, 0x20, 0x00, 0x19, 0xD3, 0x43, 0xBC, 0x0B, 0x97, 0xFE, 0x00, 0x1B, 0xD7, 0x32, 0xBC, 0x53, 0x98, 0x1C, 0xD9,
+         0x8E, 0xBC, 0x09, 0x93, 0x83, 0x00, 0x19, 0xD3, 0x9E, 0xBC, 0x0A, 0x95, 0x40, 0x00, 0x1A, 0xD5, 0x44, 0xBC, 0x60, 0x96, 0x1B, 0xD7, 0x45, 0xBC, 0x0C, 0x99, 0xFF, 0x00, 0x1C, 0xD9, 0x33, 0xBC,
+         0x44, 0x96, 0x1B, 0xD7, 0x8F, 0xBC, 0x19, 0xD3, 0x9F, 0xBC, 0x40, 0x98, 0x1C, 0xD9, 0x67, 0xBC, 0x1A, 0xD5, 0x66, 0xBC, 0x0A, 0x65, 0xB9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x9F, 0xFF,
+         0xC3, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x00, 0xEC, 0x41, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0xEE, 0xF9, 0x11, 0x93, 0x01, 0xEC, 0x40, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0xEE, 0xF9, 0x11, 0x93, 0x02, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xEE, 0xF9, 0x4F, 0x96, 0x1B, 0xD7, 0x30, 0xBC, 0x1A, 0xD5, 0x80, 0xBC, 0x0A, 0x95, 0x86, 0x00, 0x1A, 0xD5,
+         0x90, 0xBC, 0x46, 0x94, 0x0B, 0x67, 0x6F, 0x43, 0xD3, 0xD4, 0x09, 0x03, 0xFF, 0xFF, 0x40, 0x42, 0x02, 0x3E, 0x0F, 0x9F, 0xA4, 0xF9, 0x40, 0x96, 0x1B, 0xD7, 0x61, 0xBC, 0x0C, 0x99, 0x40, 0x00,
+         0x1C, 0xD9, 0x60, 0xBC, 0x0A, 0x65, 0xBF, 0x43, 0xC2, 0x92, 0x09, 0xB3, 0x9F, 0xFF, 0xC2, 0xD2, 0x0A, 0x95, 0xF2, 0x00, 0x1A, 0xD5, 0x31, 0xBC, 0x52, 0x96, 0x1B, 0xD7, 0x82, 0xBC, 0x09, 0x93,
+         0x82, 0x00, 0x19, 0xD3, 0x92, 0xBC, 0x1C, 0xD9, 0x42, 0xBC, 0x40, 0x94, 0x0A, 0xA7, 0x20, 0x00, 0x1B, 0xD7, 0x43, 0xBC, 0x0A, 0x95, 0xFE, 0x00, 0x1A, 0xD5, 0x32, 0xBC, 0x53, 0x94, 0x1A, 0xD5,
+         0x8E, 0xBC, 0x0A, 0x95, 0x83, 0x00, 0x1A, 0xD5, 0x9E, 0xBC, 0x1C, 0xD9, 0x44, 0xBC, 0x1B, 0xD7, 0x45, 0xBC, 0x0B, 0x97, 0xFF, 0x00, 0x1B, 0xD7, 0x33, 0xBC, 0x44, 0x94, 0x1A, 0xD5, 0x8F, 0xBC,
+         0x19, 0xD3, 0x9F, 0xBC, 0x40, 0x96, 0x1B, 0xD7, 0x67, 0xBC, 0x1C, 0xD9, 0x66, 0xBC, 0x0A, 0x65, 0xB9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x9F, 0xFF, 0xC3, 0xD2, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x95, 0x09, 0xEC, 0x02, 0x97, 0xC3, 0x92, 0x71, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x37, 0xFA, 0x02, 0x8E, 0x0F, 0x9F, 0x04, 0xFA, 0x70, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x0A, 0xFA, 0x0F, 0x9F, 0x5F, 0xFA, 0x72, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x29, 0xFA, 0x0F, 0x9F, 0x5F, 0xFA, 0x0A, 0x03, 0x03, 0x00, 0xC1, 0x96, 0x1B, 0xD7, 0x0E, 0xEC, 0x0A, 0x03,
+         0x01, 0x00, 0xC1, 0x94, 0x1A, 0xD5, 0x0D, 0xEC, 0x0A, 0x45, 0xFF, 0xED, 0x02, 0x8E, 0x0F, 0x9F, 0x24, 0xFA, 0x0B, 0x03, 0x01, 0x00, 0x61, 0x93, 0x11, 0x03, 0x4D, 0xEC, 0x19, 0xD3, 0x4D, 0xEC,
+         0x0A, 0x03, 0x00, 0xDE, 0x19, 0xD3, 0x0D, 0xEC, 0x42, 0x98, 0x1C, 0xD9, 0x11, 0xEC, 0x0F, 0x9F, 0x5F, 0xFA, 0x0A, 0x03, 0x03, 0x00, 0xC1, 0x92, 0x19, 0xD3, 0x0E, 0xEC, 0x0A, 0x03, 0x01, 0x00,
+         0xC1, 0x92, 0x19, 0xD3, 0x0D, 0xEC, 0x40, 0xF0, 0xF8, 0xFD, 0x0F, 0x9F, 0x5F, 0xFA, 0x41, 0x92, 0x19, 0xD3, 0x0C, 0xBC, 0x42, 0x94, 0x1A, 0xD5, 0xF0, 0xBD, 0x19, 0xD3, 0x0B, 0xBC, 0x40, 0x92,
+         0x19, 0xD3, 0x10, 0xEC, 0x12, 0x95, 0x4D, 0xEC, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x5D, 0xFA, 0x02, 0x43, 0x02, 0x0E, 0x0F, 0x9F, 0x58, 0xFA, 0x0B, 0x97, 0x00, 0x10, 0x0A, 0x65, 0x00, 0x12,
+         0xD2, 0x98, 0xD3, 0xD8, 0x41, 0x02, 0x11, 0x43, 0x4D, 0xEC, 0x02, 0x1E, 0x0F, 0x9F, 0x50, 0xFA, 0x40, 0x92, 0x19, 0xD3, 0x4D, 0xEC, 0x0F, 0x9F, 0x5F, 0xFA, 0x0F, 0x9F, 0x00, 0xEE, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFD, 0xFF, 0xC2, 0xD2, 0x09, 0x93, 0xFF, 0x00, 0x19, 0xD3, 0x12, 0xBC,
+         0x19, 0xD3, 0x13, 0xBC, 0x19, 0xD3, 0x14, 0xBC, 0x19, 0xD3, 0x16, 0xBC, 0x19, 0xD3, 0x17, 0xBC, 0x0C, 0x69, 0x00, 0x44, 0x04, 0x93, 0xC1, 0x94, 0x0A, 0xB5, 0xEF, 0xFF, 0xC5, 0xD4, 0x41, 0x94,
+         0x1A, 0xD5, 0x02, 0xBC, 0x0B, 0x67, 0xEF, 0x43, 0x03, 0x95, 0xC2, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC3, 0xD2, 0xC5, 0x96, 0x0B, 0xA5, 0x20, 0x00, 0xC4, 0xD4, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x0E, 0xEC, 0x19, 0xD3, 0x11, 0xEC, 0x19, 0xD3, 0x00, 0xEC, 0x19, 0xD3, 0x01, 0xEC, 0x19, 0xD3, 0x02, 0xEC, 0x19, 0xD3,
+         0x0F, 0xEC, 0x19, 0xD3, 0x10, 0xEC, 0x19, 0xD3, 0x1C, 0xEC, 0x40, 0xF0, 0x61, 0xFA, 0x40, 0x92, 0x19, 0xD3, 0x08, 0xBC, 0x41, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x12, 0xEC, 0x41, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x13, 0xFB, 0x41, 0x94, 0x1A, 0xD5, 0x12, 0xEC, 0x11, 0x93, 0x00, 0xBC, 0x09, 0xB3,
+         0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xEA, 0xFA, 0x09, 0x93, 0x00, 0x02, 0x19, 0xD3, 0x03, 0xEC, 0x09, 0x93, 0x31, 0xF8, 0x19, 0xD3, 0x13, 0xEC, 0x02, 0x97, 0x01, 0x99, 0x03, 0x95,
+         0x09, 0x93, 0x16, 0xEC, 0x01, 0x05, 0x03, 0x93, 0x04, 0x03, 0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x06, 0x43, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0xCF, 0xFA, 0x11, 0x93, 0x39, 0xF8, 0x79, 0x93, 0x79, 0x93,
+         0x19, 0xD3, 0x1A, 0xEC, 0x09, 0x93, 0x1F, 0xEC, 0x19, 0xD3, 0x14, 0xEC, 0x09, 0x93, 0x36, 0xEC, 0x0F, 0x9F, 0x0D, 0xFB, 0x09, 0x93, 0x40, 0x00, 0x19, 0xD3, 0x03, 0xEC, 0x09, 0x93, 0x31, 0xF8,
+         0x19, 0xD3, 0x13, 0xEC, 0x02, 0x97, 0x01, 0x99, 0x03, 0x95, 0x09, 0x93, 0x16, 0xEC, 0x01, 0x05, 0x03, 0x93, 0x04, 0x03, 0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x06, 0x43, 0x46, 0x02, 0x9E, 0x0F, 0x9F,
+         0xF4, 0xFA, 0x11, 0x93, 0x39, 0xF8, 0x79, 0x93, 0x79, 0x93, 0x19, 0xD3, 0x1A, 0xEC, 0x09, 0x93, 0x36, 0xEC, 0x19, 0xD3, 0x14, 0xEC, 0x09, 0x93, 0x1F, 0xEC, 0x19, 0xD3, 0x15, 0xEC, 0x09, 0x93,
+         0x0A, 0x06, 0x19, 0xD3, 0x16, 0xEC, 0x13, 0x97, 0x0C, 0xBC, 0x0B, 0xB3, 0x80, 0x00, 0x0A, 0x95, 0x06, 0xEC, 0xD2, 0xD2, 0x0B, 0xB3, 0x60, 0x00, 0xC2, 0xD2, 0x09, 0x93, 0x06, 0xEC, 0x09, 0x05,
+         0x02, 0x00, 0x0B, 0xB3, 0x03, 0x00, 0xC2, 0xD2, 0xC5, 0x92, 0x11, 0x93, 0x0E, 0xBC, 0x19, 0xD3, 0x09, 0xEC, 0x14, 0x99, 0x0C, 0xBC, 0x13, 0x97, 0x0E, 0xBC, 0x5B, 0x97, 0x5B, 0x97, 0x1B, 0x09,
+         0x0A, 0xEC, 0x14, 0x99, 0x0C, 0xBC, 0x13, 0x97, 0x0E, 0xBC, 0x5B, 0x97, 0x5B, 0x97, 0x1B, 0x09, 0x0B, 0xEC, 0x14, 0x99, 0x0C, 0xBC, 0x13, 0x97, 0x0E, 0xBC, 0x5B, 0x97, 0x5B, 0x97, 0x1B, 0x09,
+         0x0C, 0xEC, 0x11, 0x93, 0x07, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x56, 0xFB, 0x09, 0x43, 0x40, 0x00, 0x02, 0x5E, 0x0F, 0x9F, 0x5C, 0xFB, 0x11, 0x93, 0x1B, 0xEC, 0x41, 0x22, 0x0A, 0x95,
+         0x54, 0xFB, 0x88, 0xD4, 0x88, 0xDC, 0x91, 0x9A, 0x0F, 0x9F, 0x5F, 0xFB, 0x40, 0xF0, 0xBE, 0xFB, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x5F, 0xFB, 0x42, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x41, 0x00,
+         0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xF8, 0xFD, 0x40, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93,
+         0x11, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x77, 0xFB, 0x40, 0xF0, 0x43, 0xFE, 0x40, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92,
+         0x19, 0xD3, 0x11, 0xEC, 0x41, 0x92, 0x19, 0xD3, 0x0B, 0xBC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x44, 0x92, 0x19, 0xD3, 0x0B, 0xBC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFD, 0xFF, 0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3, 0x12, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x09, 0x93, 0x70, 0x00, 0x19, 0xD3, 0x05, 0x84, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xF7, 0xFF, 0xC2, 0xD2, 0x09, 0x93, 0x6D, 0x00, 0x19, 0xD3, 0x05, 0x84, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x11, 0x93, 0x09, 0xEC, 0x4B, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x12, 0xFC, 0x09, 0x03, 0xFF, 0xF8, 0xC1, 0x9E, 0x40, 0xF0, 0x15, 0xFC, 0x0F, 0x9F, 0x13, 0xFC, 0x40, 0xF0, 0x2B, 0xFC,
+         0x0F, 0x9F, 0x13, 0xFC, 0x40, 0xF0, 0x3F, 0xFC, 0x0F, 0x9F, 0x13, 0xFC, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x12, 0xFC, 0x40, 0xF0, 0xB7, 0xFC, 0x0F, 0x9F, 0x13, 0xFC,
+         0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x12, 0xFC, 0x40, 0xF0, 0xCB, 0xFC, 0x0F, 0x9F, 0x13, 0xFC, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x12, 0xFC,
+         0x40, 0xF0, 0x47, 0xFD, 0x0F, 0x9F, 0x13, 0xFC, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x12, 0xFC, 0x40, 0xF0, 0x56, 0xFD, 0x0F, 0x9F, 0x13, 0xFC, 0x11, 0x93, 0x0F, 0xEC,
+         0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x12, 0xFC, 0x40, 0xF0, 0x97, 0xFD, 0x0F, 0x9F, 0x13, 0xFC, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x12, 0xFC, 0x40, 0xF0, 0xBD, 0xFD,
+         0x0F, 0x9F, 0x13, 0xFC, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x08, 0xEC, 0x4F, 0xB2, 0x09, 0x03, 0x1C, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x0C, 0xBC,
+         0x40, 0x92, 0x19, 0xD3, 0x0E, 0xBC, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x0A, 0xEC,
+         0x41, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x3C, 0xFC, 0x40, 0x92, 0x19, 0xD3, 0x1E, 0xEC, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x0F, 0x9F, 0x3D, 0xFC, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x0A, 0xEC, 0x01, 0x95, 0xC2, 0x96, 0x41, 0x46, 0x02, 0x4E, 0x0F, 0x9F, 0x58, 0xFC, 0x02, 0x1E, 0x0F, 0x9F, 0x53, 0xFC, 0x42, 0x46, 0x02, 0x4E, 0x0F, 0x9F,
+         0x62, 0xFC, 0x0F, 0x9F, 0xA9, 0xFC, 0x41, 0x96, 0x1B, 0xD7, 0x10, 0xEC, 0x0F, 0x9F, 0xAC, 0xFC, 0x0A, 0x65, 0x00, 0x44, 0x02, 0x99, 0xC4, 0x92, 0x41, 0xA2, 0xC2, 0xD2, 0x1B, 0xD7, 0x10, 0xEC,
+         0x0F, 0x9F, 0xAC, 0xFC, 0x41, 0x02, 0xC1, 0x92, 0x79, 0x93, 0x79, 0x93, 0x44, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x81, 0xFC, 0x02, 0x9E, 0x0F, 0x9F, 0x73, 0xFC, 0x45, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0xAC, 0xFC, 0x0F, 0x9F, 0xA9, 0xFC, 0x41, 0x42, 0x02, 0x1E, 0x0F, 0x9F, 0xA9, 0xFC, 0x09, 0x03, 0x4D, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x08, 0xBC, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x0F, 0x9F,
+         0xAC, 0xFC, 0x0A, 0x65, 0xF8, 0x43, 0x50, 0x98, 0x02, 0x97, 0xC3, 0xD8, 0x09, 0x63, 0xF5, 0x43, 0x41, 0x98, 0x01, 0x97, 0xC3, 0xD8, 0x40, 0x94, 0x02, 0x93, 0x0C, 0x99, 0x51, 0xEC, 0x04, 0x03,
+         0x01, 0x97, 0xC3, 0x96, 0x1B, 0xD7, 0x0C, 0xBC, 0xC1, 0x92, 0x79, 0x93, 0x79, 0x93, 0x19, 0xD3, 0x0E, 0xBC, 0x41, 0x04, 0x5A, 0x44, 0x02, 0x9E, 0x0F, 0x9F, 0x8C, 0xFC, 0x0C, 0x99, 0x7E, 0x00,
+         0x1C, 0xD9, 0x0C, 0xBC, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x19, 0xD3, 0x0B, 0xBC, 0x0F, 0x9F, 0xAC, 0xFC, 0x40, 0x92, 0x0F, 0x9F, 0xB5, 0xFC, 0x11, 0x93, 0x10, 0xEC, 0x41, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0xB4, 0xFC, 0x19, 0xD3, 0x1E, 0xEC, 0x41, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x0A, 0xEC, 0x09, 0x43, 0xFF, 0x00, 0x02, 0x8E, 0x0F, 0x9F,
+         0xC8, 0xFC, 0x19, 0xD3, 0x01, 0xBC, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x0F, 0x9F, 0xC9, 0xFC, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x14, 0xEC,
+         0x0A, 0x95, 0x09, 0x02, 0xC1, 0xD4, 0x11, 0x93, 0x15, 0xEC, 0x0B, 0x97, 0x09, 0x07, 0xC1, 0xD6, 0x0A, 0x95, 0x0A, 0xEC, 0x02, 0x97, 0xC3, 0x92, 0x79, 0x93, 0x79, 0x93, 0x09, 0x03, 0xFF, 0xFF,
+         0x46, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x35, 0xFD, 0x09, 0x03, 0x0B, 0xF9, 0xC1, 0x9E, 0x11, 0x93, 0x13, 0xEC, 0x0F, 0x9F, 0x22, 0xFD, 0xC2, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x40, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0x35, 0xFD, 0x11, 0x93, 0x14, 0xEC, 0x0F, 0x9F, 0x2D, 0xFD, 0xC2, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x50, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x12, 0xFD, 0x02, 0x8E, 0x0F, 0x9F, 0x06, 0xFD,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x0C, 0xFD, 0x0F, 0x9F, 0x35, 0xFD, 0x60, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x18, 0xFD, 0x0F, 0x9F, 0x35, 0xFD, 0x09, 0x93, 0x3A, 0xF8, 0x19, 0xD3, 0x0D, 0xEC,
+         0x0F, 0x9F, 0x1C, 0xFD, 0x0A, 0x95, 0x6F, 0xF8, 0x1A, 0xD5, 0x0D, 0xEC, 0x0F, 0x9F, 0x1C, 0xFD, 0x0B, 0x97, 0x7A, 0xF8, 0x1B, 0xD7, 0x0D, 0xEC, 0x11, 0x93, 0x0D, 0xEC, 0x0F, 0x9F, 0x24, 0xFD,
+         0x09, 0x93, 0x16, 0xEC, 0x19, 0xD3, 0x0D, 0xEC, 0xC1, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x19, 0xD3, 0x0E, 0xEC, 0x0F, 0x9F, 0x38, 0xFD, 0x11, 0x93, 0x15, 0xEC, 0x19, 0xD3, 0x0D, 0xEC, 0x41, 0x02,
+         0xC1, 0x92, 0x19, 0xD3, 0x0E, 0xEC, 0x0F, 0x9F, 0x38, 0xFD, 0x40, 0x92, 0x0F, 0x9F, 0x45, 0xFD, 0x11, 0x93, 0x0E, 0xEC, 0x12, 0x95, 0x0C, 0xEC, 0x02, 0x43, 0x02, 0x9E, 0x0F, 0x9F, 0x42, 0xFD,
+         0x1A, 0xD5, 0x0E, 0xEC, 0x40, 0xF0, 0xF8, 0xFD, 0x41, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x00, 0xEC, 0x19, 0xD3, 0x0C, 0xBC, 0x42, 0x92, 0x19, 0xD3,
+         0xF0, 0xBD, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x0A, 0xEC, 0x09, 0xB5, 0xFF, 0x00, 0x40, 0x44, 0x02, 0x5E, 0x0F, 0x9F,
+         0x6C, 0xFD, 0x1A, 0xD5, 0x00, 0xEC, 0x0A, 0x65, 0xFF, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x7F, 0xFF, 0xC2, 0xD2, 0x0F, 0x9F, 0x92, 0xFD, 0x11, 0x93, 0x00, 0xBC, 0x09, 0xB3, 0x40, 0x00,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x81, 0xFD, 0x41, 0x44, 0x02, 0x9E, 0x0F, 0x9F, 0x7B, 0xFD, 0x40, 0x92, 0x0F, 0x9F, 0x95, 0xFD, 0x1A, 0xD5, 0x00, 0xEC, 0x40, 0xF0, 0x12, 0xF9, 0x0F, 0x9F,
+         0x89, 0xFD, 0x41, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x95, 0xFD, 0x1A, 0xD5, 0x00, 0xEC, 0x40, 0xF0, 0x83, 0xF9, 0x0A, 0x65, 0xFF, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x80, 0x00, 0xC2, 0xD2,
+         0x40, 0xF0, 0x90, 0xFE, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x01, 0xBC, 0x09, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0xBB, 0xFD, 0x12, 0x95, 0x00, 0xEC, 0x41, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0xAE, 0xFD, 0x11, 0x93, 0x0B, 0xEC, 0x41, 0x42, 0x02, 0x9E, 0x0F, 0x9F, 0xB1, 0xFD, 0x40, 0x92, 0x0F, 0x9F,
+         0xBB, 0xFD, 0x11, 0x93, 0x02, 0xEC, 0x19, 0xD3, 0x0C, 0xBC, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x1A, 0xD5, 0x10, 0xEC, 0x02, 0x93, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00,
+         0x11, 0x93, 0x01, 0xBC, 0x09, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xF5, 0xFD, 0x13, 0x97, 0x0B, 0xEC, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0xF5, 0xFD, 0x11, 0x93, 0x0A, 0xEC,
+         0x09, 0xB5, 0xFF, 0x00, 0x11, 0x93, 0x14, 0xEC, 0x46, 0x02, 0xC1, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x01, 0x45, 0x02, 0x5E, 0x0F, 0x9F, 0xF5, 0xFD, 0x1B, 0xD7, 0x01, 0xEC, 0x1A, 0xD5, 0x02, 0xEC,
+         0x11, 0x93, 0x00, 0xBC, 0x09, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xEC, 0xFD, 0x40, 0xF0, 0x12, 0xF9, 0x0F, 0x9F, 0xEE, 0xFD, 0x40, 0xF0, 0x83, 0xF9, 0x40, 0xF0, 0x90, 0xFE,
+         0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x0F, 0x9F, 0xF6, 0xFD, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x0E, 0xEC, 0x09, 0x93, 0x40, 0x00,
+         0x7F, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x05, 0xFE, 0x02, 0x93, 0x1A, 0x23, 0x0E, 0xEC, 0x40, 0x98, 0x61, 0x95, 0x02, 0xD4, 0x09, 0xB7, 0x01, 0x00, 0xC5, 0xD6, 0x43, 0xB2, 0x01, 0xD2, 0x0F, 0x9F,
+         0x1F, 0xFE, 0x12, 0x95, 0x0D, 0xEC, 0x02, 0x93, 0xC1, 0x92, 0x19, 0xD3, 0x0C, 0xBC, 0xD2, 0x92, 0x79, 0x93, 0x79, 0x93, 0x19, 0xD3, 0x0E, 0xBC, 0x1A, 0xD5, 0x0D, 0xEC, 0x41, 0x08, 0x02, 0x48,
+         0x02, 0x1E, 0x0F, 0x9F, 0x11, 0xFE, 0xC5, 0x94, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x2D, 0xFE, 0x11, 0x93, 0x0D, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x0C, 0xBC, 0x01, 0x96, 0x40, 0x46, 0x02, 0x4E,
+         0x0F, 0x9F, 0x35, 0xFE, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x11, 0x93, 0x0E, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x40, 0xFE, 0x19, 0xD3, 0x11, 0xEC, 0x41, 0x94, 0x1A, 0xD5, 0x10, 0xEC,
+         0x43, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x0E, 0xEC, 0x0A, 0x95, 0x40, 0x00, 0x7F, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x50, 0xFE, 0x01, 0x95,
+         0x19, 0x25, 0x0E, 0xEC, 0x40, 0x98, 0x0A, 0x03, 0x01, 0x00, 0x01, 0xD2, 0x43, 0xB4, 0xC5, 0xD4, 0x0F, 0x9F, 0x74, 0xFE, 0x11, 0x93, 0x0D, 0xEC, 0x12, 0x95, 0x0C, 0xBC, 0xC1, 0xD4, 0x12, 0x95,
+         0x0D, 0xEC, 0x11, 0x93, 0x0E, 0xBC, 0x59, 0x93, 0x59, 0x93, 0x02, 0x97, 0xC3, 0x02, 0xC2, 0xD2, 0x11, 0x93, 0x05, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x73, 0xFE, 0x11, 0x93, 0x0D, 0xEC,
+         0x41, 0x02, 0x19, 0xD3, 0x0D, 0xEC, 0x41, 0x08, 0x01, 0x94, 0x62, 0x93, 0x01, 0x49, 0x02, 0x1E, 0x0F, 0x9F, 0x5A, 0xFE, 0xC5, 0x96, 0x40, 0x46, 0x02, 0x4E, 0x0F, 0x9F, 0x82, 0xFE, 0x41, 0x92,
+         0x19, 0xD3, 0xF0, 0xBD, 0x11, 0x93, 0x0E, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x8D, 0xFE, 0x19, 0xD3, 0x11, 0xEC, 0x41, 0x94, 0x1A, 0xD5, 0x10, 0xEC, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x41, 0x96, 0x0A, 0x65, 0xBF, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0xEF, 0xFF, 0xC4, 0xD2, 0x42, 0x04, 0x41, 0x06, 0x4A, 0x46, 0x02, 0x9E, 0x0F, 0x9F,
+         0x96, 0xFE, 0x41, 0x96, 0x0A, 0x65, 0x9F, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0xEF, 0xFF, 0xC4, 0xD2, 0x42, 0x04, 0x41, 0x06, 0x4A, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0xA4, 0xFE, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x08, 0x14, 0x19, 0xD3, 0x01, 0x84, 0x0A, 0x65, 0xFE, 0x7B, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFF, 0xE0, 0xC2, 0xD2, 0x0A, 0x65,
+         0xC0, 0x7A, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x01, 0x00, 0x1F, 0xEC, 0x00, 0x00, 0xB2, 0xF8, 0x4D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x00, 0x00, 0xF0, 0xF9,
+         0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x00, 0x02, 0x19, 0xD3, 0x44, 0x96, 0x09, 0x63, 0x80, 0x69, 0x01, 0x97, 0xC3, 0x94, 0x0A, 0xB5, 0x7F, 0xFF, 0xC1, 0xD4, 0x55, 0x92,
+         0x19, 0xD3, 0x2C, 0x90, 0x0B, 0x97, 0xFE, 0x00, 0x1B, 0xD7, 0x40, 0x85, 0x40, 0xF0, 0x99, 0xFF, 0xC5, 0x92, 0x40, 0x92, 0x00, 0xEE, 0x41, 0x02, 0x70, 0x42, 0x44, 0x8E, 0x11, 0x93, 0x04, 0xEC,
+         0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x09, 0xFF, 0x40, 0x96, 0x1B, 0xD7, 0x04, 0xEC, 0x0F, 0x9F, 0x00, 0xEE, 0x09, 0x93, 0x4F, 0x00, 0x19, 0xD3, 0x05, 0x84, 0x40, 0xF0, 0x90, 0xFA, 0x0B, 0x97,
+         0xDE, 0xFE, 0x1B, 0xD7, 0x1B, 0xEC, 0x41, 0x92, 0x19, 0xD3, 0x05, 0xEC, 0x11, 0x93, 0x20, 0xBC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x16, 0xFF, 0xC8, 0xD2, 0x40, 0xF0, 0x25, 0xFF, 0x41, 0x00,
+         0x0F, 0x9F, 0x16, 0xFF, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x05, 0x92, 0xC5, 0xD2, 0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x73, 0xFF,
+         0x12, 0x95, 0x21, 0xBC, 0x01, 0xD4, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x3B, 0xFF, 0x40, 0xF0, 0x62, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x44, 0xFF, 0x40, 0xF0, 0x6C, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x4F, 0xFF, 0x40, 0xF0, 0xB0, 0xFA, 0x0F, 0x9F, 0x58, 0xFF, 0x01, 0x94,
+         0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x58, 0xFF, 0x40, 0xF0, 0x7C, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x10, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x61, 0xFF, 0x40, 0xF0,
+         0x87, 0xFB, 0x11, 0x93, 0x10, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x6A, 0xFF, 0x44, 0x92, 0x0F, 0x9F, 0x6E, 0xFF, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x70, 0xFF, 0x19, 0xD3, 0x0B, 0xBC,
+         0x40, 0x94, 0x1A, 0xD5, 0x10, 0xEC, 0xC5, 0x94, 0x0A, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x96, 0xFF, 0x11, 0x93, 0x28, 0xBC, 0x01, 0xD2, 0x42, 0xB2, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x84, 0xFF, 0x40, 0xF0, 0x8F, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x8D, 0xFF, 0x40, 0xF0, 0x9E, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x08, 0x00,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x96, 0xFF, 0x40, 0xF0, 0xAE, 0xFB, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xB1, 0xFE, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+ };
+#elif defined(ZD1211B)
+={
+         0x00, 0xF0, 0x66, 0xFE, 0x67, 0xFE, 0x68, 0xFE, 0x69, 0xFE, 0x6A, 0xFE, 0x6B, 0xFE, 0x6C, 0xFE, 0x6D, 0xFE, 0x09, 0x63, 0xD6, 0x79, 0x57, 0x94, 0xD1, 0xD4, 0x0A, 0x95, 0x17, 0xF8, 0xD1, 0xD4,
+         0x0A, 0x95, 0xD2, 0x07, 0x00, 0xEE, 0xC1, 0xD4, 0x00, 0xEE, 0x0F, 0x9F, 0x95, 0xF8, 0x10, 0x48, 0x10, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x66, 0x66, 0x66, 0x00, 0x00, 0x6A, 0x6A,
+         0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xFF, 0x07,
+         0x00, 0x00, 0x12, 0x01, 0x00, 0x02, 0xFF, 0xFF, 0xFF, 0x40, 0xCE, 0x0A, 0x11, 0x12, 0x10, 0x48, 0x10, 0x20, 0x00, 0x01, 0x04, 0x03, 0x09, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x52,
+         0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0x4A, 0x4A,
+         0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0x42, 0x42,
+         0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0x0C, 0x03,
+         0x5A, 0x00, 0x79, 0x00, 0x44, 0x00, 0x41, 0x00, 0x53, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x18, 0x03, 0x55, 0x00, 0x53, 0x00, 0x42, 0x00, 0x32, 0x00, 0x2E, 0x00,
+         0x30, 0x00, 0x20, 0x00, 0x57, 0x00, 0x4C, 0x00, 0x41, 0x00, 0x4E, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x88, 0x88,
+         0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x08, 0x91, 0xFF, 0xED, 0x09, 0x93, 0xC7, 0xFE, 0xD1, 0x94, 0x11, 0xEE, 0x88, 0xD4, 0xD1, 0x96, 0xD1, 0x98, 0x5C, 0x99, 0x5C, 0x99,
+         0x4C, 0x99, 0x04, 0x9D, 0xD1, 0x98, 0xD1, 0x9A, 0x03, 0xEE, 0xF4, 0x94, 0xD3, 0xD4, 0x41, 0x2A, 0x40, 0x4A, 0x45, 0xBE, 0x88, 0x92, 0x41, 0x24, 0x40, 0x44, 0x53, 0xBE, 0x40, 0xF0, 0xE0, 0xFE,
+         0x41, 0xEE, 0x98, 0x9A, 0x09, 0x02, 0x2E, 0x00, 0x01, 0x01, 0x00, 0x80, 0xFA, 0x09, 0x04, 0x00, 0x00, 0x04, 0xFF, 0x00, 0x00, 0x00, 0x07, 0x05, 0x01, 0x02, 0x00, 0x02, 0x00, 0x07, 0x05, 0x82,
+         0x02, 0x00, 0x02, 0x00, 0x07, 0x05, 0x83, 0x03, 0x40, 0x00, 0x01, 0x07, 0x05, 0x04, 0x03, 0x40, 0x00, 0x01, 0x09, 0x02, 0x2E, 0x00, 0x01, 0x01, 0x00, 0x80, 0xFA, 0x09, 0x04, 0x00, 0x00, 0x04,
+         0xFF, 0x00, 0x00, 0x00, 0x07, 0x05, 0x01, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x82, 0x02, 0x40, 0x00, 0x00, 0x07, 0x05, 0x83, 0x03, 0x40, 0x00, 0x01, 0x07, 0x05, 0x04, 0x02, 0x40, 0x00, 0x00,
+         0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
+         0xEE, 0xEE, 0xEE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0xFC, 0x7E, 0xBF, 0xDF, 0xFB, 0xFD, 0xFB, 0xFD, 0xCA, 0xFB,
+         0xCE, 0xFB, 0x12, 0xFC, 0xD2, 0xFB, 0x12, 0xFC, 0xD6, 0xFB, 0xE0, 0xFB, 0x12, 0xFC, 0xEA, 0xFB, 0xF4, 0xFB, 0xFE, 0xFB, 0x08, 0xFC, 0xE7, 0xFC, 0xEB, 0xFC, 0xF6, 0xFC, 0x35, 0xFD, 0x35, 0xFD,
+         0x20, 0xFD, 0x2B, 0xFD, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x00, 0xEC, 0x41, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0x81, 0xF9, 0x11, 0x93, 0x01, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F,
+         0x81, 0xF9, 0x11, 0x93, 0x02, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x81, 0xF9, 0x4F, 0x96, 0x1B, 0xD7, 0x30, 0xBC, 0x1A, 0xD5, 0x80, 0xBC, 0x0C, 0x99, 0x86, 0x00, 0x1C, 0xD9, 0x90, 0xBC,
+         0x46, 0x94, 0x0C, 0x69, 0x6F, 0x43, 0x01, 0x97, 0xD4, 0xD4, 0x0B, 0x07, 0xFF, 0xFF, 0x40, 0x46, 0x02, 0x3E, 0x0F, 0x9F, 0x34, 0xF9, 0x42, 0x96, 0x1B, 0xD7, 0x61, 0xBC, 0x40, 0x92, 0x19, 0xD3,
+         0x60, 0xBC, 0x0A, 0x65, 0xBF, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0x9F, 0xFF, 0xC4, 0xD2, 0x0A, 0x95, 0xF2, 0x00, 0x1A, 0xD5, 0x31, 0xBC, 0x52, 0x98, 0x1C, 0xD9, 0x82, 0xBC, 0x09, 0x93,
+         0x82, 0x00, 0x19, 0xD3, 0x92, 0xBC, 0x40, 0x94, 0x1A, 0xD5, 0x42, 0xBC, 0x0B, 0xA3, 0x20, 0x00, 0x19, 0xD3, 0x43, 0xBC, 0x0B, 0x97, 0xFE, 0x00, 0x1B, 0xD7, 0x32, 0xBC, 0x53, 0x98, 0x1C, 0xD9,
+         0x8E, 0xBC, 0x09, 0x93, 0x83, 0x00, 0x19, 0xD3, 0x9E, 0xBC, 0x0A, 0x95, 0x40, 0x00, 0x1A, 0xD5, 0x44, 0xBC, 0x60, 0x96, 0x1B, 0xD7, 0x45, 0xBC, 0x0C, 0x99, 0xFF, 0x00, 0x1C, 0xD9, 0x33, 0xBC,
+         0x44, 0x96, 0x1B, 0xD7, 0x8F, 0xBC, 0x19, 0xD3, 0x9F, 0xBC, 0x40, 0x98, 0x1C, 0xD9, 0x67, 0xBC, 0x1A, 0xD5, 0x66, 0xBC, 0x0A, 0x65, 0xB9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x9F, 0xFF,
+         0xC3, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x00, 0xEC, 0x41, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0xEE, 0xF9, 0x11, 0x93, 0x01, 0xEC, 0x40, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0xEE, 0xF9, 0x11, 0x93, 0x02, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xEE, 0xF9, 0x4F, 0x96, 0x1B, 0xD7, 0x30, 0xBC, 0x1A, 0xD5, 0x80, 0xBC, 0x0A, 0x95, 0x86, 0x00, 0x1A, 0xD5,
+         0x90, 0xBC, 0x46, 0x94, 0x0B, 0x67, 0x6F, 0x43, 0xD3, 0xD4, 0x09, 0x03, 0xFF, 0xFF, 0x40, 0x42, 0x02, 0x3E, 0x0F, 0x9F, 0xA4, 0xF9, 0x40, 0x96, 0x1B, 0xD7, 0x61, 0xBC, 0x0C, 0x99, 0x40, 0x00,
+         0x1C, 0xD9, 0x60, 0xBC, 0x0A, 0x65, 0xBF, 0x43, 0xC2, 0x92, 0x09, 0xB3, 0x9F, 0xFF, 0xC2, 0xD2, 0x0A, 0x95, 0xF2, 0x00, 0x1A, 0xD5, 0x31, 0xBC, 0x52, 0x96, 0x1B, 0xD7, 0x82, 0xBC, 0x09, 0x93,
+         0x82, 0x00, 0x19, 0xD3, 0x92, 0xBC, 0x1C, 0xD9, 0x42, 0xBC, 0x40, 0x94, 0x0A, 0xA7, 0x20, 0x00, 0x1B, 0xD7, 0x43, 0xBC, 0x0A, 0x95, 0xFE, 0x00, 0x1A, 0xD5, 0x32, 0xBC, 0x53, 0x94, 0x1A, 0xD5,
+         0x8E, 0xBC, 0x0A, 0x95, 0x83, 0x00, 0x1A, 0xD5, 0x9E, 0xBC, 0x1C, 0xD9, 0x44, 0xBC, 0x1B, 0xD7, 0x45, 0xBC, 0x0B, 0x97, 0xFF, 0x00, 0x1B, 0xD7, 0x33, 0xBC, 0x44, 0x94, 0x1A, 0xD5, 0x8F, 0xBC,
+         0x19, 0xD3, 0x9F, 0xBC, 0x40, 0x96, 0x1B, 0xD7, 0x67, 0xBC, 0x1C, 0xD9, 0x66, 0xBC, 0x0A, 0x65, 0xB9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x9F, 0xFF, 0xC3, 0xD2, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x95, 0x09, 0xEC, 0x02, 0x97, 0xC3, 0x92, 0x71, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x37, 0xFA, 0x02, 0x8E, 0x0F, 0x9F, 0x04, 0xFA, 0x70, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x0A, 0xFA, 0x0F, 0x9F, 0x5F, 0xFA, 0x72, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x29, 0xFA, 0x0F, 0x9F, 0x5F, 0xFA, 0x0A, 0x03, 0x03, 0x00, 0xC1, 0x96, 0x1B, 0xD7, 0x0E, 0xEC, 0x0A, 0x03,
+         0x01, 0x00, 0xC1, 0x94, 0x1A, 0xD5, 0x0D, 0xEC, 0x0A, 0x45, 0xFF, 0xED, 0x02, 0x8E, 0x0F, 0x9F, 0x24, 0xFA, 0x0B, 0x03, 0x01, 0x00, 0x61, 0x93, 0x11, 0x03, 0x4D, 0xEC, 0x19, 0xD3, 0x4D, 0xEC,
+         0x0A, 0x03, 0x00, 0xDE, 0x19, 0xD3, 0x0D, 0xEC, 0x42, 0x98, 0x1C, 0xD9, 0x11, 0xEC, 0x0F, 0x9F, 0x5F, 0xFA, 0x0A, 0x03, 0x03, 0x00, 0xC1, 0x92, 0x19, 0xD3, 0x0E, 0xEC, 0x0A, 0x03, 0x01, 0x00,
+         0xC1, 0x92, 0x19, 0xD3, 0x0D, 0xEC, 0x40, 0xF0, 0xF8, 0xFD, 0x0F, 0x9F, 0x5F, 0xFA, 0x41, 0x92, 0x19, 0xD3, 0x0C, 0xBC, 0x42, 0x94, 0x1A, 0xD5, 0xF0, 0xBD, 0x19, 0xD3, 0x0B, 0xBC, 0x40, 0x92,
+         0x19, 0xD3, 0x10, 0xEC, 0x12, 0x95, 0x4D, 0xEC, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x5D, 0xFA, 0x02, 0x43, 0x02, 0x0E, 0x0F, 0x9F, 0x58, 0xFA, 0x0B, 0x97, 0x00, 0x10, 0x0A, 0x65, 0x00, 0x12,
+         0xD2, 0x98, 0xD3, 0xD8, 0x41, 0x02, 0x11, 0x43, 0x4D, 0xEC, 0x02, 0x1E, 0x0F, 0x9F, 0x50, 0xFA, 0x40, 0x92, 0x19, 0xD3, 0x4D, 0xEC, 0x0F, 0x9F, 0x5F, 0xFA, 0x0F, 0x9F, 0x00, 0xEE, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFD, 0xFF, 0xC2, 0xD2, 0x09, 0x93, 0xFF, 0x00, 0x19, 0xD3, 0x12, 0xBC,
+         0x19, 0xD3, 0x13, 0xBC, 0x19, 0xD3, 0x14, 0xBC, 0x19, 0xD3, 0x16, 0xBC, 0x19, 0xD3, 0x17, 0xBC, 0x0C, 0x69, 0x00, 0x44, 0x04, 0x93, 0xC1, 0x94, 0x0A, 0xB5, 0xEF, 0xFF, 0xC5, 0xD4, 0x41, 0x94,
+         0x1A, 0xD5, 0x02, 0xBC, 0x0B, 0x67, 0xEF, 0x43, 0x03, 0x95, 0xC2, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC3, 0xD2, 0xC5, 0x96, 0x0B, 0xA5, 0x20, 0x00, 0xC4, 0xD4, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x0E, 0xEC, 0x19, 0xD3, 0x11, 0xEC, 0x19, 0xD3, 0x00, 0xEC, 0x19, 0xD3, 0x01, 0xEC, 0x19, 0xD3, 0x02, 0xEC, 0x19, 0xD3,
+         0x0F, 0xEC, 0x19, 0xD3, 0x10, 0xEC, 0x19, 0xD3, 0x1C, 0xEC, 0x40, 0xF0, 0x61, 0xFA, 0x40, 0x92, 0x19, 0xD3, 0x08, 0xBC, 0x41, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x12, 0xEC, 0x41, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x13, 0xFB, 0x41, 0x94, 0x1A, 0xD5, 0x12, 0xEC, 0x11, 0x93, 0x00, 0xBC, 0x09, 0xB3,
+         0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xEA, 0xFA, 0x09, 0x93, 0x00, 0x02, 0x19, 0xD3, 0x03, 0xEC, 0x09, 0x93, 0x31, 0xF8, 0x19, 0xD3, 0x13, 0xEC, 0x02, 0x97, 0x01, 0x99, 0x03, 0x95,
+         0x09, 0x93, 0x16, 0xEC, 0x01, 0x05, 0x03, 0x93, 0x04, 0x03, 0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x06, 0x43, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0xCF, 0xFA, 0x11, 0x93, 0x39, 0xF8, 0x79, 0x93, 0x79, 0x93,
+         0x19, 0xD3, 0x1A, 0xEC, 0x09, 0x93, 0x1F, 0xEC, 0x19, 0xD3, 0x14, 0xEC, 0x09, 0x93, 0x36, 0xEC, 0x0F, 0x9F, 0x0D, 0xFB, 0x09, 0x93, 0x40, 0x00, 0x19, 0xD3, 0x03, 0xEC, 0x09, 0x93, 0x31, 0xF8,
+         0x19, 0xD3, 0x13, 0xEC, 0x02, 0x97, 0x01, 0x99, 0x03, 0x95, 0x09, 0x93, 0x16, 0xEC, 0x01, 0x05, 0x03, 0x93, 0x04, 0x03, 0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x06, 0x43, 0x46, 0x02, 0x9E, 0x0F, 0x9F,
+         0xF4, 0xFA, 0x11, 0x93, 0x39, 0xF8, 0x79, 0x93, 0x79, 0x93, 0x19, 0xD3, 0x1A, 0xEC, 0x09, 0x93, 0x36, 0xEC, 0x19, 0xD3, 0x14, 0xEC, 0x09, 0x93, 0x1F, 0xEC, 0x19, 0xD3, 0x15, 0xEC, 0x09, 0x93,
+         0x0A, 0x06, 0x19, 0xD3, 0x16, 0xEC, 0x13, 0x97, 0x0C, 0xBC, 0x0B, 0xB3, 0x80, 0x00, 0x0A, 0x95, 0x06, 0xEC, 0xD2, 0xD2, 0x0B, 0xB3, 0x60, 0x00, 0xC2, 0xD2, 0x09, 0x93, 0x06, 0xEC, 0x09, 0x05,
+         0x02, 0x00, 0x0B, 0xB3, 0x03, 0x00, 0xC2, 0xD2, 0xC5, 0x92, 0x11, 0x93, 0x0E, 0xBC, 0x19, 0xD3, 0x09, 0xEC, 0x14, 0x99, 0x0C, 0xBC, 0x13, 0x97, 0x0E, 0xBC, 0x5B, 0x97, 0x5B, 0x97, 0x1B, 0x09,
+         0x0A, 0xEC, 0x14, 0x99, 0x0C, 0xBC, 0x13, 0x97, 0x0E, 0xBC, 0x5B, 0x97, 0x5B, 0x97, 0x1B, 0x09, 0x0B, 0xEC, 0x14, 0x99, 0x0C, 0xBC, 0x13, 0x97, 0x0E, 0xBC, 0x5B, 0x97, 0x5B, 0x97, 0x1B, 0x09,
+         0x0C, 0xEC, 0x11, 0x93, 0x07, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x56, 0xFB, 0x09, 0x43, 0x40, 0x00, 0x02, 0x5E, 0x0F, 0x9F, 0x5C, 0xFB, 0x11, 0x93, 0x1B, 0xEC, 0x41, 0x22, 0x0A, 0x95,
+         0x54, 0xFB, 0x88, 0xD4, 0x88, 0xDC, 0x91, 0x9A, 0x0F, 0x9F, 0x5F, 0xFB, 0x40, 0xF0, 0xBE, 0xFB, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x5F, 0xFB, 0x42, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x41, 0x00,
+         0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0xF8, 0xFD, 0x40, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93,
+         0x11, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x77, 0xFB, 0x40, 0xF0, 0x43, 0xFE, 0x40, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92,
+         0x19, 0xD3, 0x11, 0xEC, 0x41, 0x92, 0x19, 0xD3, 0x0B, 0xBC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x44, 0x92, 0x19, 0xD3, 0x0B, 0xBC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFD, 0xFF, 0xC2, 0xD2, 0x40, 0x92, 0x19, 0xD3, 0x12, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x09, 0x93, 0x70, 0x00, 0x19, 0xD3, 0x05, 0x84, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xF7, 0xFF, 0xC2, 0xD2, 0x09, 0x93, 0x6D, 0x00, 0x19, 0xD3, 0x05, 0x84, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x11, 0x93, 0x09, 0xEC, 0x4B, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x12, 0xFC, 0x09, 0x03, 0xFF, 0xF8, 0xC1, 0x9E, 0x40, 0xF0, 0x15, 0xFC, 0x0F, 0x9F, 0x13, 0xFC, 0x40, 0xF0, 0x2B, 0xFC,
+         0x0F, 0x9F, 0x13, 0xFC, 0x40, 0xF0, 0x3F, 0xFC, 0x0F, 0x9F, 0x13, 0xFC, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x12, 0xFC, 0x40, 0xF0, 0xB7, 0xFC, 0x0F, 0x9F, 0x13, 0xFC,
+         0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x12, 0xFC, 0x40, 0xF0, 0xCB, 0xFC, 0x0F, 0x9F, 0x13, 0xFC, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x12, 0xFC,
+         0x40, 0xF0, 0x47, 0xFD, 0x0F, 0x9F, 0x13, 0xFC, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x12, 0xFC, 0x40, 0xF0, 0x56, 0xFD, 0x0F, 0x9F, 0x13, 0xFC, 0x11, 0x93, 0x0F, 0xEC,
+         0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x12, 0xFC, 0x40, 0xF0, 0x97, 0xFD, 0x0F, 0x9F, 0x13, 0xFC, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x12, 0xFC, 0x40, 0xF0, 0xBD, 0xFD,
+         0x0F, 0x9F, 0x13, 0xFC, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x08, 0xEC, 0x4F, 0xB2, 0x09, 0x03, 0x1C, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x0C, 0xBC,
+         0x40, 0x92, 0x19, 0xD3, 0x0E, 0xBC, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x0A, 0xEC,
+         0x41, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x3C, 0xFC, 0x40, 0x92, 0x19, 0xD3, 0x1E, 0xEC, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x0F, 0x9F, 0x3D, 0xFC, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x0A, 0xEC, 0x01, 0x95, 0xC2, 0x96, 0x41, 0x46, 0x02, 0x4E, 0x0F, 0x9F, 0x58, 0xFC, 0x02, 0x1E, 0x0F, 0x9F, 0x53, 0xFC, 0x42, 0x46, 0x02, 0x4E, 0x0F, 0x9F,
+         0x62, 0xFC, 0x0F, 0x9F, 0xA9, 0xFC, 0x41, 0x96, 0x1B, 0xD7, 0x10, 0xEC, 0x0F, 0x9F, 0xAC, 0xFC, 0x0A, 0x65, 0x00, 0x44, 0x02, 0x99, 0xC4, 0x92, 0x41, 0xA2, 0xC2, 0xD2, 0x1B, 0xD7, 0x10, 0xEC,
+         0x0F, 0x9F, 0xAC, 0xFC, 0x41, 0x02, 0xC1, 0x92, 0x79, 0x93, 0x79, 0x93, 0x44, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x81, 0xFC, 0x02, 0x9E, 0x0F, 0x9F, 0x73, 0xFC, 0x45, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0xAC, 0xFC, 0x0F, 0x9F, 0xA9, 0xFC, 0x41, 0x42, 0x02, 0x1E, 0x0F, 0x9F, 0xA9, 0xFC, 0x09, 0x03, 0x4D, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x08, 0xBC, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x0F, 0x9F,
+         0xAC, 0xFC, 0x0A, 0x65, 0xF8, 0x43, 0x50, 0x98, 0x02, 0x97, 0xC3, 0xD8, 0x09, 0x63, 0xF5, 0x43, 0x41, 0x98, 0x01, 0x97, 0xC3, 0xD8, 0x40, 0x94, 0x02, 0x93, 0x0C, 0x99, 0x51, 0xEC, 0x04, 0x03,
+         0x01, 0x97, 0xC3, 0x96, 0x1B, 0xD7, 0x0C, 0xBC, 0xC1, 0x92, 0x79, 0x93, 0x79, 0x93, 0x19, 0xD3, 0x0E, 0xBC, 0x41, 0x04, 0x5A, 0x44, 0x02, 0x9E, 0x0F, 0x9F, 0x8C, 0xFC, 0x0C, 0x99, 0x7E, 0x00,
+         0x1C, 0xD9, 0x0C, 0xBC, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x19, 0xD3, 0x0B, 0xBC, 0x0F, 0x9F, 0xAC, 0xFC, 0x40, 0x92, 0x0F, 0x9F, 0xB5, 0xFC, 0x11, 0x93, 0x10, 0xEC, 0x41, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0xB4, 0xFC, 0x19, 0xD3, 0x1E, 0xEC, 0x41, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x0A, 0xEC, 0x09, 0x43, 0xFF, 0x00, 0x02, 0x8E, 0x0F, 0x9F,
+         0xC8, 0xFC, 0x19, 0xD3, 0x01, 0xBC, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x0F, 0x9F, 0xC9, 0xFC, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x14, 0xEC,
+         0x0A, 0x95, 0x09, 0x02, 0xC1, 0xD4, 0x11, 0x93, 0x15, 0xEC, 0x0B, 0x97, 0x09, 0x07, 0xC1, 0xD6, 0x0A, 0x95, 0x0A, 0xEC, 0x02, 0x97, 0xC3, 0x92, 0x79, 0x93, 0x79, 0x93, 0x09, 0x03, 0xFF, 0xFF,
+         0x46, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x35, 0xFD, 0x09, 0x03, 0x0B, 0xF9, 0xC1, 0x9E, 0x11, 0x93, 0x13, 0xEC, 0x0F, 0x9F, 0x22, 0xFD, 0xC2, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x40, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0x35, 0xFD, 0x11, 0x93, 0x14, 0xEC, 0x0F, 0x9F, 0x2D, 0xFD, 0xC2, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x50, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x12, 0xFD, 0x02, 0x8E, 0x0F, 0x9F, 0x06, 0xFD,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x0C, 0xFD, 0x0F, 0x9F, 0x35, 0xFD, 0x60, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x18, 0xFD, 0x0F, 0x9F, 0x35, 0xFD, 0x09, 0x93, 0x3A, 0xF8, 0x19, 0xD3, 0x0D, 0xEC,
+         0x0F, 0x9F, 0x1C, 0xFD, 0x0A, 0x95, 0x6F, 0xF8, 0x1A, 0xD5, 0x0D, 0xEC, 0x0F, 0x9F, 0x1C, 0xFD, 0x0B, 0x97, 0x7A, 0xF8, 0x1B, 0xD7, 0x0D, 0xEC, 0x11, 0x93, 0x0D, 0xEC, 0x0F, 0x9F, 0x24, 0xFD,
+         0x09, 0x93, 0x16, 0xEC, 0x19, 0xD3, 0x0D, 0xEC, 0xC1, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x19, 0xD3, 0x0E, 0xEC, 0x0F, 0x9F, 0x38, 0xFD, 0x11, 0x93, 0x15, 0xEC, 0x19, 0xD3, 0x0D, 0xEC, 0x41, 0x02,
+         0xC1, 0x92, 0x19, 0xD3, 0x0E, 0xEC, 0x0F, 0x9F, 0x38, 0xFD, 0x40, 0x92, 0x0F, 0x9F, 0x45, 0xFD, 0x11, 0x93, 0x0E, 0xEC, 0x12, 0x95, 0x0C, 0xEC, 0x02, 0x43, 0x02, 0x9E, 0x0F, 0x9F, 0x42, 0xFD,
+         0x1A, 0xD5, 0x0E, 0xEC, 0x40, 0xF0, 0xF8, 0xFD, 0x41, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x00, 0xEC, 0x19, 0xD3, 0x0C, 0xBC, 0x42, 0x92, 0x19, 0xD3,
+         0xF0, 0xBD, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x0A, 0xEC, 0x09, 0xB5, 0xFF, 0x00, 0x40, 0x44, 0x02, 0x5E, 0x0F, 0x9F,
+         0x6C, 0xFD, 0x1A, 0xD5, 0x00, 0xEC, 0x0A, 0x65, 0xFF, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x7F, 0xFF, 0xC2, 0xD2, 0x0F, 0x9F, 0x92, 0xFD, 0x11, 0x93, 0x00, 0xBC, 0x09, 0xB3, 0x40, 0x00,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x81, 0xFD, 0x41, 0x44, 0x02, 0x9E, 0x0F, 0x9F, 0x7B, 0xFD, 0x40, 0x92, 0x0F, 0x9F, 0x95, 0xFD, 0x1A, 0xD5, 0x00, 0xEC, 0x40, 0xF0, 0x12, 0xF9, 0x0F, 0x9F,
+         0x89, 0xFD, 0x41, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x95, 0xFD, 0x1A, 0xD5, 0x00, 0xEC, 0x40, 0xF0, 0x83, 0xF9, 0x0A, 0x65, 0xFF, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x80, 0x00, 0xC2, 0xD2,
+         0x40, 0xF0, 0x90, 0xFE, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x01, 0xBC, 0x09, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0xBB, 0xFD, 0x12, 0x95, 0x00, 0xEC, 0x41, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0xAE, 0xFD, 0x11, 0x93, 0x0B, 0xEC, 0x41, 0x42, 0x02, 0x9E, 0x0F, 0x9F, 0xB1, 0xFD, 0x40, 0x92, 0x0F, 0x9F,
+         0xBB, 0xFD, 0x11, 0x93, 0x02, 0xEC, 0x19, 0xD3, 0x0C, 0xBC, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x1A, 0xD5, 0x10, 0xEC, 0x02, 0x93, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00,
+         0x11, 0x93, 0x01, 0xBC, 0x09, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xF5, 0xFD, 0x13, 0x97, 0x0B, 0xEC, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0xF5, 0xFD, 0x11, 0x93, 0x0A, 0xEC,
+         0x09, 0xB5, 0xFF, 0x00, 0x11, 0x93, 0x14, 0xEC, 0x46, 0x02, 0xC1, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x01, 0x45, 0x02, 0x5E, 0x0F, 0x9F, 0xF5, 0xFD, 0x1B, 0xD7, 0x01, 0xEC, 0x1A, 0xD5, 0x02, 0xEC,
+         0x11, 0x93, 0x00, 0xBC, 0x09, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xEC, 0xFD, 0x40, 0xF0, 0x12, 0xF9, 0x0F, 0x9F, 0xEE, 0xFD, 0x40, 0xF0, 0x83, 0xF9, 0x40, 0xF0, 0x90, 0xFE,
+         0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x0F, 0x9F, 0xF6, 0xFD, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x0E, 0xEC, 0x09, 0x93, 0x40, 0x00,
+         0x7F, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x05, 0xFE, 0x02, 0x93, 0x1A, 0x23, 0x0E, 0xEC, 0x40, 0x98, 0x61, 0x95, 0x02, 0xD4, 0x09, 0xB7, 0x01, 0x00, 0xC5, 0xD6, 0x43, 0xB2, 0x01, 0xD2, 0x0F, 0x9F,
+         0x1F, 0xFE, 0x12, 0x95, 0x0D, 0xEC, 0x02, 0x93, 0xC1, 0x92, 0x19, 0xD3, 0x0C, 0xBC, 0xD2, 0x92, 0x79, 0x93, 0x79, 0x93, 0x19, 0xD3, 0x0E, 0xBC, 0x1A, 0xD5, 0x0D, 0xEC, 0x41, 0x08, 0x02, 0x48,
+         0x02, 0x1E, 0x0F, 0x9F, 0x11, 0xFE, 0xC5, 0x94, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x2D, 0xFE, 0x11, 0x93, 0x0D, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x0C, 0xBC, 0x01, 0x96, 0x40, 0x46, 0x02, 0x4E,
+         0x0F, 0x9F, 0x35, 0xFE, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x11, 0x93, 0x0E, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x40, 0xFE, 0x19, 0xD3, 0x11, 0xEC, 0x41, 0x94, 0x1A, 0xD5, 0x10, 0xEC,
+         0x43, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x0E, 0xEC, 0x0A, 0x95, 0x40, 0x00, 0x7F, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x50, 0xFE, 0x01, 0x95,
+         0x19, 0x25, 0x0E, 0xEC, 0x40, 0x98, 0x0A, 0x03, 0x01, 0x00, 0x01, 0xD2, 0x43, 0xB4, 0xC5, 0xD4, 0x0F, 0x9F, 0x74, 0xFE, 0x11, 0x93, 0x0D, 0xEC, 0x12, 0x95, 0x0C, 0xBC, 0xC1, 0xD4, 0x12, 0x95,
+         0x0D, 0xEC, 0x11, 0x93, 0x0E, 0xBC, 0x59, 0x93, 0x59, 0x93, 0x02, 0x97, 0xC3, 0x02, 0xC2, 0xD2, 0x11, 0x93, 0x05, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x73, 0xFE, 0x11, 0x93, 0x0D, 0xEC,
+         0x41, 0x02, 0x19, 0xD3, 0x0D, 0xEC, 0x41, 0x08, 0x01, 0x94, 0x62, 0x93, 0x01, 0x49, 0x02, 0x1E, 0x0F, 0x9F, 0x5A, 0xFE, 0xC5, 0x96, 0x40, 0x46, 0x02, 0x4E, 0x0F, 0x9F, 0x82, 0xFE, 0x41, 0x92,
+         0x19, 0xD3, 0xF0, 0xBD, 0x11, 0x93, 0x0E, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x8D, 0xFE, 0x19, 0xD3, 0x11, 0xEC, 0x41, 0x94, 0x1A, 0xD5, 0x10, 0xEC, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A,
+         0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x41, 0x96, 0x0A, 0x65, 0xBF, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0xEF, 0xFF, 0xC4, 0xD2, 0x42, 0x04, 0x41, 0x06, 0x4A, 0x46, 0x02, 0x9E, 0x0F, 0x9F,
+         0x96, 0xFE, 0x41, 0x96, 0x0A, 0x65, 0x9F, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0xEF, 0xFF, 0xC4, 0xD2, 0x42, 0x04, 0x41, 0x06, 0x4A, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0xA4, 0xFE, 0x88, 0x98,
+         0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x08, 0x14, 0x19, 0xD3, 0x01, 0x84, 0x0A, 0x65, 0xFE, 0x7B, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFF, 0xE0, 0xC2, 0xD2, 0x0A, 0x65,
+         0xC0, 0x7A, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x01, 0x00, 0x1F, 0xEC, 0x00, 0x00, 0xB2, 0xF8, 0x4D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x00, 0x00, 0xF0, 0xF9,
+         0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x44, 0x96, 0x12, 0x95, 0x1A, 0xF8, 0x0A, 0xB3, 0x00, 0x01, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xF7, 0xFE, 0x62, 0x93,
+         0x79, 0x93, 0x79, 0x93, 0x43, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xFD, 0xFE, 0x11, 0x93, 0x44, 0x96, 0x09, 0xA3, 0x00, 0x02, 0x19, 0xD3, 0x44, 0x96, 0x09, 0x63, 0x80, 0x69, 0x01, 0x97,
+         0xC3, 0x94, 0x0A, 0xB5, 0x7F, 0xFF, 0xC1, 0xD4, 0x11, 0x93, 0x19, 0xF8, 0x4F, 0xB2, 0x4D, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x10, 0xFF, 0x55, 0x92, 0x19, 0xD3, 0x2C, 0x90, 0x0F, 0x9F, 0x16, 0xFF,
+         0x44, 0x96, 0x1B, 0xD7, 0x2C, 0x90, 0x6F, 0x92, 0x19, 0xD3, 0xEC, 0x93, 0x0B, 0x97, 0xFE, 0x00, 0x1B, 0xD7, 0x40, 0x85, 0x40, 0xF0, 0xBD, 0xFF, 0xC5, 0x92, 0x40, 0x92, 0x00, 0xEE, 0x41, 0x02,
+         0x70, 0x42, 0x44, 0x8E, 0x11, 0x93, 0x04, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x2D, 0xFF, 0x40, 0x96, 0x1B, 0xD7, 0x04, 0xEC, 0x0F, 0x9F, 0x00, 0xEE, 0x09, 0x93, 0x4F, 0x00, 0x19, 0xD3,
+         0x05, 0x84, 0x40, 0xF0, 0x90, 0xFA, 0x0B, 0x97, 0xDE, 0xFE, 0x1B, 0xD7, 0x1B, 0xEC, 0x41, 0x92, 0x19, 0xD3, 0x05, 0xEC, 0x11, 0x93, 0x20, 0xBC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x3A, 0xFF,
+         0xC8, 0xD2, 0x40, 0xF0, 0x49, 0xFF, 0x41, 0x00, 0x0F, 0x9F, 0x3A, 0xFF, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x05, 0x92, 0xC5, 0xD2, 0x41, 0xB2,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x97, 0xFF, 0x12, 0x95, 0x21, 0xBC, 0x01, 0xD4, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x5F, 0xFF, 0x40, 0xF0, 0x62, 0xFB, 0x01, 0x94,
+         0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x68, 0xFF, 0x40, 0xF0, 0x6C, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x73, 0xFF, 0x40, 0xF0,
+         0xB0, 0xFA, 0x0F, 0x9F, 0x7C, 0xFF, 0x01, 0x94, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x7C, 0xFF, 0x40, 0xF0, 0x7C, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x10, 0x00, 0x40, 0x42,
+         0x02, 0x4E, 0x0F, 0x9F, 0x85, 0xFF, 0x40, 0xF0, 0x87, 0xFB, 0x11, 0x93, 0x10, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x8E, 0xFF, 0x44, 0x92, 0x0F, 0x9F, 0x92, 0xFF, 0x41, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0x94, 0xFF, 0x19, 0xD3, 0x0B, 0xBC, 0x40, 0x94, 0x1A, 0xD5, 0x10, 0xEC, 0xC5, 0x94, 0x0A, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xBA, 0xFF, 0x11, 0x93, 0x28, 0xBC,
+         0x01, 0xD2, 0x42, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xA8, 0xFF, 0x40, 0xF0, 0x8F, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xB1, 0xFF, 0x40, 0xF0,
+         0x9E, 0xFB, 0x01, 0x94, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xBA, 0xFF, 0x40, 0xF0, 0xAE, 0xFB, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00,
+         0x40, 0xF0, 0xB1, 0xFE, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+ };
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/WS11Ur.h linux-2.4.35.3-mct/drivers/usb/zd1211/WS11Ur.h
--- linux-2.4.35.3/drivers/usb/zd1211/WS11Ur.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/WS11Ur.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,231 @@
+#ifdef ZD1211
+={
+         0x08, 0x91, 0xFF, 0xED, 0x09, 0x93, 0x1D, 0xEE, 0xD1, 0x94, 0x11, 0xEE, 0x88, 0xD4, 0xD1, 0x96, 0xD1, 0x98, 0x5C, 0x99, 0x5C, 0x99, 0x4C, 0x99, 0x04, 0x9D, 0xD1, 0x98, 0xD1, 0x9A, 0x03, 0xEE,
+         0xF4, 0x94, 0xD3, 0xD4, 0x41, 0x2A, 0x40, 0x4A, 0x45, 0xBE, 0x88, 0x92, 0x41, 0x24, 0x40, 0x44, 0x53, 0xBE, 0x40, 0xF0, 0xFE, 0xF3, 0x41, 0xEE, 0x98, 0x9A, 0x01, 0x00, 0x1F, 0xEC, 0x00, 0x00,
+         0xB2, 0xF8, 0x4D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A,
+         0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x01, 0xF1, 0x05, 0xF1, 0x49, 0xF1, 0x09, 0xF1, 0x49, 0xF1, 0x0D, 0xF1, 0x17, 0xF1, 0x49, 0xF1, 0x21, 0xF1, 0x2B, 0xF1, 0x35, 0xF1, 0x3F, 0xF1,
+         0x1E, 0xF2, 0x22, 0xF2, 0x2D, 0xF2, 0x6C, 0xF2, 0x6C, 0xF2, 0x57, 0xF2, 0x62, 0xF2, 0x00, 0x00, 0x27, 0xEF, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x00, 0xEC, 0x41, 0x44, 0x02, 0x5E,
+         0x0F, 0x9F, 0xB8, 0xEE, 0x11, 0x93, 0x01, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xB8, 0xEE, 0x11, 0x93, 0x02, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xB8, 0xEE, 0x4F, 0x96, 0x1B, 0xD7,
+         0x30, 0xBC, 0x1A, 0xD5, 0x80, 0xBC, 0x0C, 0x99, 0x86, 0x00, 0x1C, 0xD9, 0x90, 0xBC, 0x46, 0x94, 0x0C, 0x69, 0x6F, 0x43, 0x01, 0x97, 0xD4, 0xD4, 0x0B, 0x07, 0xFF, 0xFF, 0x40, 0x46, 0x02, 0x3E,
+         0x0F, 0x9F, 0x6B, 0xEE, 0x42, 0x96, 0x1B, 0xD7, 0x61, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x60, 0xBC, 0x0A, 0x65, 0xBF, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0x9F, 0xFF, 0xC4, 0xD2, 0x0A, 0x95,
+         0xF2, 0x00, 0x1A, 0xD5, 0x31, 0xBC, 0x52, 0x98, 0x1C, 0xD9, 0x82, 0xBC, 0x09, 0x93, 0x82, 0x00, 0x19, 0xD3, 0x92, 0xBC, 0x40, 0x94, 0x1A, 0xD5, 0x42, 0xBC, 0x0B, 0xA3, 0x20, 0x00, 0x19, 0xD3,
+         0x43, 0xBC, 0x0B, 0x97, 0xFE, 0x00, 0x1B, 0xD7, 0x32, 0xBC, 0x53, 0x98, 0x1C, 0xD9, 0x8E, 0xBC, 0x09, 0x93, 0x83, 0x00, 0x19, 0xD3, 0x9E, 0xBC, 0x0A, 0x95, 0x40, 0x00, 0x1A, 0xD5, 0x44, 0xBC,
+         0x60, 0x96, 0x1B, 0xD7, 0x45, 0xBC, 0x0C, 0x99, 0xFF, 0x00, 0x1C, 0xD9, 0x33, 0xBC, 0x44, 0x96, 0x1B, 0xD7, 0x8F, 0xBC, 0x19, 0xD3, 0x9F, 0xBC, 0x40, 0x98, 0x1C, 0xD9, 0x67, 0xBC, 0x1A, 0xD5,
+         0x66, 0xBC, 0x0A, 0x65, 0xB9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x9F, 0xFF, 0xC3, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x00, 0xEC, 0x41, 0x44,
+         0x02, 0x5E, 0x0F, 0x9F, 0x25, 0xEF, 0x11, 0x93, 0x01, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x25, 0xEF, 0x11, 0x93, 0x02, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x25, 0xEF, 0x4F, 0x96,
+         0x1B, 0xD7, 0x30, 0xBC, 0x1A, 0xD5, 0x80, 0xBC, 0x0A, 0x95, 0x86, 0x00, 0x1A, 0xD5, 0x90, 0xBC, 0x46, 0x94, 0x0B, 0x67, 0x6F, 0x43, 0xD3, 0xD4, 0x09, 0x03, 0xFF, 0xFF, 0x40, 0x42, 0x02, 0x3E,
+         0x0F, 0x9F, 0xDB, 0xEE, 0x40, 0x96, 0x1B, 0xD7, 0x61, 0xBC, 0x0C, 0x99, 0x40, 0x00, 0x1C, 0xD9, 0x60, 0xBC, 0x0A, 0x65, 0xBF, 0x43, 0xC2, 0x92, 0x09, 0xB3, 0x9F, 0xFF, 0xC2, 0xD2, 0x0A, 0x95,
+         0xF2, 0x00, 0x1A, 0xD5, 0x31, 0xBC, 0x52, 0x96, 0x1B, 0xD7, 0x82, 0xBC, 0x09, 0x93, 0x82, 0x00, 0x19, 0xD3, 0x92, 0xBC, 0x1C, 0xD9, 0x42, 0xBC, 0x40, 0x94, 0x0A, 0xA7, 0x20, 0x00, 0x1B, 0xD7,
+         0x43, 0xBC, 0x0A, 0x95, 0xFE, 0x00, 0x1A, 0xD5, 0x32, 0xBC, 0x53, 0x94, 0x1A, 0xD5, 0x8E, 0xBC, 0x0A, 0x95, 0x83, 0x00, 0x1A, 0xD5, 0x9E, 0xBC, 0x1C, 0xD9, 0x44, 0xBC, 0x1B, 0xD7, 0x45, 0xBC,
+         0x0B, 0x97, 0xFF, 0x00, 0x1B, 0xD7, 0x33, 0xBC, 0x44, 0x94, 0x1A, 0xD5, 0x8F, 0xBC, 0x19, 0xD3, 0x9F, 0xBC, 0x40, 0x96, 0x1B, 0xD7, 0x67, 0xBC, 0x1C, 0xD9, 0x66, 0xBC, 0x0A, 0x65, 0xB9, 0x43,
+         0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x9F, 0xFF, 0xC3, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x95, 0x09, 0xEC, 0x02, 0x97, 0xC3, 0x92, 0x71, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x6E, 0xEF, 0x02, 0x8E, 0x0F, 0x9F, 0x3B, 0xEF, 0x70, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x41, 0xEF, 0x0F, 0x9F, 0x96, 0xEF, 0x72, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x60, 0xEF, 0x0F, 0x9F,
+         0x96, 0xEF, 0x0A, 0x03, 0x03, 0x00, 0xC1, 0x96, 0x1B, 0xD7, 0x0E, 0xEC, 0x0A, 0x03, 0x01, 0x00, 0xC1, 0x94, 0x1A, 0xD5, 0x0D, 0xEC, 0x0A, 0x45, 0xFF, 0xED, 0x02, 0x8E, 0x0F, 0x9F, 0x5B, 0xEF,
+         0x0B, 0x03, 0x01, 0x00, 0x61, 0x93, 0x11, 0x03, 0x4D, 0xEC, 0x19, 0xD3, 0x4D, 0xEC, 0x0A, 0x03, 0x00, 0xDE, 0x19, 0xD3, 0x0D, 0xEC, 0x42, 0x98, 0x1C, 0xD9, 0x11, 0xEC, 0x0F, 0x9F, 0x96, 0xEF,
+         0x0A, 0x03, 0x03, 0x00, 0xC1, 0x92, 0x19, 0xD3, 0x0E, 0xEC, 0x0A, 0x03, 0x01, 0x00, 0xC1, 0x92, 0x19, 0xD3, 0x0D, 0xEC, 0x40, 0xF0, 0x2F, 0xF3, 0x0F, 0x9F, 0x96, 0xEF, 0x41, 0x92, 0x19, 0xD3,
+         0x0C, 0xBC, 0x42, 0x94, 0x1A, 0xD5, 0xF0, 0xBD, 0x19, 0xD3, 0x0B, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x12, 0x95, 0x4D, 0xEC, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x94, 0xEF, 0x02, 0x43,
+         0x02, 0x0E, 0x0F, 0x9F, 0x8F, 0xEF, 0x0B, 0x97, 0x00, 0x10, 0x0A, 0x65, 0x00, 0x12, 0xD2, 0x98, 0xD3, 0xD8, 0x41, 0x02, 0x11, 0x43, 0x4D, 0xEC, 0x02, 0x1E, 0x0F, 0x9F, 0x87, 0xEF, 0x40, 0x92,
+         0x19, 0xD3, 0x4D, 0xEC, 0x0F, 0x9F, 0x96, 0xEF, 0x0F, 0x9F, 0x95, 0xF8, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92,
+         0x09, 0xB3, 0xFD, 0xFF, 0xC2, 0xD2, 0x09, 0x93, 0xFF, 0x00, 0x19, 0xD3, 0x12, 0xBC, 0x19, 0xD3, 0x13, 0xBC, 0x19, 0xD3, 0x14, 0xBC, 0x19, 0xD3, 0x16, 0xBC, 0x19, 0xD3, 0x17, 0xBC, 0x0C, 0x69,
+         0x00, 0x44, 0x04, 0x93, 0xC1, 0x94, 0x0A, 0xB5, 0xEF, 0xFF, 0xC5, 0xD4, 0x41, 0x94, 0x1A, 0xD5, 0x02, 0xBC, 0x0B, 0x67, 0xEF, 0x43, 0x03, 0x95, 0xC2, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC3, 0xD2,
+         0xC5, 0x96, 0x0B, 0xA5, 0x20, 0x00, 0xC4, 0xD4, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x0E, 0xEC, 0x19, 0xD3, 0x11, 0xEC,
+         0x19, 0xD3, 0x00, 0xEC, 0x19, 0xD3, 0x01, 0xEC, 0x19, 0xD3, 0x02, 0xEC, 0x19, 0xD3, 0x0F, 0xEC, 0x19, 0xD3, 0x10, 0xEC, 0x19, 0xD3, 0x1C, 0xEC, 0x40, 0xF0, 0x98, 0xEF, 0x40, 0x92, 0x19, 0xD3,
+         0x08, 0xBC, 0x41, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x12, 0xEC, 0x41, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0x4A, 0xF0, 0x41, 0x94, 0x1A, 0xD5, 0x12, 0xEC, 0x11, 0x93, 0x00, 0xBC, 0x09, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x21, 0xF0, 0x09, 0x93, 0x00, 0x02, 0x19, 0xD3, 0x03, 0xEC,
+         0x09, 0x93, 0x31, 0xF8, 0x19, 0xD3, 0x13, 0xEC, 0x02, 0x97, 0x01, 0x99, 0x03, 0x95, 0x09, 0x93, 0x16, 0xEC, 0x01, 0x05, 0x03, 0x93, 0x04, 0x03, 0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x06, 0x43, 0x46,
+         0x02, 0x9E, 0x0F, 0x9F, 0x06, 0xF0, 0x11, 0x93, 0x39, 0xF8, 0x79, 0x93, 0x79, 0x93, 0x19, 0xD3, 0x1A, 0xEC, 0x09, 0x93, 0x1F, 0xEC, 0x19, 0xD3, 0x14, 0xEC, 0x09, 0x93, 0x36, 0xEC, 0x0F, 0x9F,
+         0x44, 0xF0, 0x09, 0x93, 0x40, 0x00, 0x19, 0xD3, 0x03, 0xEC, 0x09, 0x93, 0x31, 0xF8, 0x19, 0xD3, 0x13, 0xEC, 0x02, 0x97, 0x01, 0x99, 0x03, 0x95, 0x09, 0x93, 0x16, 0xEC, 0x01, 0x05, 0x03, 0x93,
+         0x04, 0x03, 0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x06, 0x43, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0x2B, 0xF0, 0x11, 0x93, 0x39, 0xF8, 0x79, 0x93, 0x79, 0x93, 0x19, 0xD3, 0x1A, 0xEC, 0x09, 0x93, 0x36, 0xEC,
+         0x19, 0xD3, 0x14, 0xEC, 0x09, 0x93, 0x1F, 0xEC, 0x19, 0xD3, 0x15, 0xEC, 0x09, 0x93, 0x0A, 0x06, 0x19, 0xD3, 0x16, 0xEC, 0x13, 0x97, 0x0C, 0xBC, 0x0B, 0xB3, 0x80, 0x00, 0x0A, 0x95, 0x06, 0xEC,
+         0xD2, 0xD2, 0x0B, 0xB3, 0x60, 0x00, 0xC2, 0xD2, 0x09, 0x93, 0x06, 0xEC, 0x09, 0x05, 0x02, 0x00, 0x0B, 0xB3, 0x03, 0x00, 0xC2, 0xD2, 0xC5, 0x92, 0x11, 0x93, 0x0E, 0xBC, 0x19, 0xD3, 0x09, 0xEC,
+         0x14, 0x99, 0x0C, 0xBC, 0x13, 0x97, 0x0E, 0xBC, 0x5B, 0x97, 0x5B, 0x97, 0x1B, 0x09, 0x0A, 0xEC, 0x14, 0x99, 0x0C, 0xBC, 0x13, 0x97, 0x0E, 0xBC, 0x5B, 0x97, 0x5B, 0x97, 0x1B, 0x09, 0x0B, 0xEC,
+         0x14, 0x99, 0x0C, 0xBC, 0x13, 0x97, 0x0E, 0xBC, 0x5B, 0x97, 0x5B, 0x97, 0x1B, 0x09, 0x0C, 0xEC, 0x11, 0x93, 0x07, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x8D, 0xF0, 0x09, 0x43, 0x40, 0x00,
+         0x02, 0x5E, 0x0F, 0x9F, 0x93, 0xF0, 0x11, 0x93, 0x1B, 0xEC, 0x41, 0x22, 0x0A, 0x95, 0x8B, 0xF0, 0x88, 0xD4, 0x88, 0xDC, 0x91, 0x9A, 0x0F, 0x9F, 0x96, 0xF0, 0x40, 0xF0, 0xF5, 0xF0, 0x40, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0x96, 0xF0, 0x42, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0x2F, 0xF3, 0x40, 0x92, 0x19, 0xD3,
+         0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x11, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xAE, 0xF0, 0x40, 0xF0, 0x7A, 0xF3, 0x40, 0x92, 0x19, 0xD3,
+         0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x11, 0xEC, 0x41, 0x92, 0x19, 0xD3, 0x0B, 0xBC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x44, 0x92, 0x19, 0xD3, 0x0B, 0xBC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFD, 0xFF, 0xC2, 0xD2,
+         0x40, 0x92, 0x19, 0xD3, 0x12, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x09, 0x93,
+         0x70, 0x00, 0x19, 0xD3, 0x05, 0x84, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xF7, 0xFF, 0xC2, 0xD2, 0x09, 0x93,
+         0x6D, 0x00, 0x19, 0xD3, 0x05, 0x84, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x09, 0xEC, 0x4B, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x49, 0xF1, 0x09, 0x03, 0x34, 0xEE,
+         0xC1, 0x9E, 0x40, 0xF0, 0x4C, 0xF1, 0x0F, 0x9F, 0x4A, 0xF1, 0x40, 0xF0, 0x62, 0xF1, 0x0F, 0x9F, 0x4A, 0xF1, 0x40, 0xF0, 0x76, 0xF1, 0x0F, 0x9F, 0x4A, 0xF1, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0x49, 0xF1, 0x40, 0xF0, 0xEE, 0xF1, 0x0F, 0x9F, 0x4A, 0xF1, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x49, 0xF1, 0x40, 0xF0, 0x02, 0xF2, 0x0F, 0x9F,
+         0x4A, 0xF1, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x49, 0xF1, 0x40, 0xF0, 0x7E, 0xF2, 0x0F, 0x9F, 0x4A, 0xF1, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F,
+         0x49, 0xF1, 0x40, 0xF0, 0x8D, 0xF2, 0x0F, 0x9F, 0x4A, 0xF1, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x49, 0xF1, 0x40, 0xF0, 0xCE, 0xF2, 0x0F, 0x9F, 0x4A, 0xF1, 0x11, 0x93,
+         0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x49, 0xF1, 0x40, 0xF0, 0xF4, 0xF2, 0x0F, 0x9F, 0x4A, 0xF1, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93,
+         0x08, 0xEC, 0x4F, 0xB2, 0x09, 0x03, 0x1C, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x0C, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x0E, 0xBC, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC,
+         0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x0A, 0xEC, 0x41, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x73, 0xF1, 0x40, 0x92, 0x19, 0xD3, 0x1E, 0xEC, 0x41, 0x92, 0x19, 0xD3,
+         0x10, 0xEC, 0x0F, 0x9F, 0x74, 0xF1, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x0A, 0xEC, 0x01, 0x95, 0xC2, 0x96, 0x41, 0x46, 0x02, 0x4E, 0x0F, 0x9F,
+         0x8F, 0xF1, 0x02, 0x1E, 0x0F, 0x9F, 0x8A, 0xF1, 0x42, 0x46, 0x02, 0x4E, 0x0F, 0x9F, 0x99, 0xF1, 0x0F, 0x9F, 0xE0, 0xF1, 0x41, 0x96, 0x1B, 0xD7, 0x10, 0xEC, 0x0F, 0x9F, 0xE3, 0xF1, 0x0A, 0x65,
+         0x00, 0x44, 0x02, 0x99, 0xC4, 0x92, 0x41, 0xA2, 0xC2, 0xD2, 0x1B, 0xD7, 0x10, 0xEC, 0x0F, 0x9F, 0xE3, 0xF1, 0x41, 0x02, 0xC1, 0x92, 0x79, 0x93, 0x79, 0x93, 0x44, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0xB8, 0xF1, 0x02, 0x9E, 0x0F, 0x9F, 0xAA, 0xF1, 0x45, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xE3, 0xF1, 0x0F, 0x9F, 0xE0, 0xF1, 0x41, 0x42, 0x02, 0x1E, 0x0F, 0x9F, 0xE0, 0xF1, 0x09, 0x03, 0x4D, 0xEC,
+         0xC1, 0x92, 0x19, 0xD3, 0x08, 0xBC, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x0F, 0x9F, 0xE3, 0xF1, 0x0A, 0x65, 0xF8, 0x43, 0x50, 0x98, 0x02, 0x97, 0xC3, 0xD8, 0x09, 0x63, 0xF5, 0x43, 0x41, 0x98,
+         0x01, 0x97, 0xC3, 0xD8, 0x40, 0x94, 0x02, 0x93, 0x0C, 0x99, 0x51, 0xEC, 0x04, 0x03, 0x01, 0x97, 0xC3, 0x96, 0x1B, 0xD7, 0x0C, 0xBC, 0xC1, 0x92, 0x79, 0x93, 0x79, 0x93, 0x19, 0xD3, 0x0E, 0xBC,
+         0x41, 0x04, 0x5A, 0x44, 0x02, 0x9E, 0x0F, 0x9F, 0xC3, 0xF1, 0x0C, 0x99, 0x7E, 0x00, 0x1C, 0xD9, 0x0C, 0xBC, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x19, 0xD3, 0x0B, 0xBC, 0x0F, 0x9F, 0xE3, 0xF1,
+         0x40, 0x92, 0x0F, 0x9F, 0xEC, 0xF1, 0x11, 0x93, 0x10, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xEB, 0xF1, 0x19, 0xD3, 0x1E, 0xEC, 0x41, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x11, 0x93, 0x0A, 0xEC, 0x09, 0x43, 0xFF, 0x00, 0x02, 0x8E, 0x0F, 0x9F, 0xFF, 0xF1, 0x19, 0xD3, 0x01, 0xBC, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x0F, 0x9F, 0x00, 0xF2, 0x40, 0x92,
+         0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x14, 0xEC, 0x0A, 0x95, 0x09, 0x02, 0xC1, 0xD4, 0x11, 0x93, 0x15, 0xEC, 0x0B, 0x97, 0x09, 0x07, 0xC1, 0xD6, 0x0A, 0x95,
+         0x0A, 0xEC, 0x02, 0x97, 0xC3, 0x92, 0x79, 0x93, 0x79, 0x93, 0x09, 0x03, 0xFF, 0xFF, 0x46, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x6C, 0xF2, 0x09, 0x03, 0x40, 0xEE, 0xC1, 0x9E, 0x11, 0x93, 0x13, 0xEC,
+         0x0F, 0x9F, 0x59, 0xF2, 0xC2, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x6C, 0xF2, 0x11, 0x93, 0x14, 0xEC, 0x0F, 0x9F, 0x64, 0xF2, 0xC2, 0x92, 0x09, 0xB3, 0xFF, 0x00,
+         0x50, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x49, 0xF2, 0x02, 0x8E, 0x0F, 0x9F, 0x3D, 0xF2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x43, 0xF2, 0x0F, 0x9F, 0x6C, 0xF2, 0x60, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0x4F, 0xF2, 0x0F, 0x9F, 0x6C, 0xF2, 0x09, 0x93, 0x3A, 0xF8, 0x19, 0xD3, 0x0D, 0xEC, 0x0F, 0x9F, 0x53, 0xF2, 0x0A, 0x95, 0x6F, 0xF8, 0x1A, 0xD5, 0x0D, 0xEC, 0x0F, 0x9F, 0x53, 0xF2, 0x0B, 0x97,
+         0x7A, 0xF8, 0x1B, 0xD7, 0x0D, 0xEC, 0x11, 0x93, 0x0D, 0xEC, 0x0F, 0x9F, 0x5B, 0xF2, 0x09, 0x93, 0x16, 0xEC, 0x19, 0xD3, 0x0D, 0xEC, 0xC1, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x19, 0xD3, 0x0E, 0xEC,
+         0x0F, 0x9F, 0x6F, 0xF2, 0x11, 0x93, 0x15, 0xEC, 0x19, 0xD3, 0x0D, 0xEC, 0x41, 0x02, 0xC1, 0x92, 0x19, 0xD3, 0x0E, 0xEC, 0x0F, 0x9F, 0x6F, 0xF2, 0x40, 0x92, 0x0F, 0x9F, 0x7C, 0xF2, 0x11, 0x93,
+         0x0E, 0xEC, 0x12, 0x95, 0x0C, 0xEC, 0x02, 0x43, 0x02, 0x9E, 0x0F, 0x9F, 0x79, 0xF2, 0x1A, 0xD5, 0x0E, 0xEC, 0x40, 0xF0, 0x2F, 0xF3, 0x41, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x11, 0x93, 0x00, 0xEC, 0x19, 0xD3, 0x0C, 0xBC, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00,
+         0x11, 0x93, 0x0A, 0xEC, 0x09, 0xB5, 0xFF, 0x00, 0x40, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0xA3, 0xF2, 0x1A, 0xD5, 0x00, 0xEC, 0x0A, 0x65, 0xFF, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x7F, 0xFF,
+         0xC2, 0xD2, 0x0F, 0x9F, 0xC9, 0xF2, 0x11, 0x93, 0x00, 0xBC, 0x09, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xB8, 0xF2, 0x41, 0x44, 0x02, 0x9E, 0x0F, 0x9F, 0xB2, 0xF2, 0x40, 0x92,
+         0x0F, 0x9F, 0xCC, 0xF2, 0x1A, 0xD5, 0x00, 0xEC, 0x40, 0xF0, 0x49, 0xEE, 0x0F, 0x9F, 0xC0, 0xF2, 0x41, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0xCC, 0xF2, 0x1A, 0xD5, 0x00, 0xEC, 0x40, 0xF0, 0xBA, 0xEE,
+         0x0A, 0x65, 0xFF, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x80, 0x00, 0xC2, 0xD2, 0x40, 0xF0, 0xC7, 0xF3, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x11, 0x93, 0x01, 0xBC, 0x09, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xF2, 0xF2, 0x12, 0x95, 0x00, 0xEC, 0x41, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0xE5, 0xF2, 0x11, 0x93,
+         0x0B, 0xEC, 0x41, 0x42, 0x02, 0x9E, 0x0F, 0x9F, 0xE8, 0xF2, 0x40, 0x92, 0x0F, 0x9F, 0xF2, 0xF2, 0x11, 0x93, 0x02, 0xEC, 0x19, 0xD3, 0x0C, 0xBC, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x1A, 0xD5,
+         0x10, 0xEC, 0x02, 0x93, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x01, 0xBC, 0x09, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x2C, 0xF3, 0x13, 0x97,
+         0x0B, 0xEC, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0x2C, 0xF3, 0x11, 0x93, 0x0A, 0xEC, 0x09, 0xB5, 0xFF, 0x00, 0x11, 0x93, 0x14, 0xEC, 0x46, 0x02, 0xC1, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x01, 0x45,
+         0x02, 0x5E, 0x0F, 0x9F, 0x2C, 0xF3, 0x1B, 0xD7, 0x01, 0xEC, 0x1A, 0xD5, 0x02, 0xEC, 0x11, 0x93, 0x00, 0xBC, 0x09, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x23, 0xF3, 0x40, 0xF0,
+         0x49, 0xEE, 0x0F, 0x9F, 0x25, 0xF3, 0x40, 0xF0, 0xBA, 0xEE, 0x40, 0xF0, 0xC7, 0xF3, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x0F, 0x9F, 0x2D, 0xF3, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x0E, 0xEC, 0x09, 0x93, 0x40, 0x00, 0x7F, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x3C, 0xF3, 0x02, 0x93, 0x1A, 0x23, 0x0E, 0xEC, 0x40, 0x98, 0x61, 0x95,
+         0x02, 0xD4, 0x09, 0xB7, 0x01, 0x00, 0xC5, 0xD6, 0x43, 0xB2, 0x01, 0xD2, 0x0F, 0x9F, 0x56, 0xF3, 0x12, 0x95, 0x0D, 0xEC, 0x02, 0x93, 0xC1, 0x92, 0x19, 0xD3, 0x0C, 0xBC, 0xD2, 0x92, 0x79, 0x93,
+         0x79, 0x93, 0x19, 0xD3, 0x0E, 0xBC, 0x1A, 0xD5, 0x0D, 0xEC, 0x41, 0x08, 0x02, 0x48, 0x02, 0x1E, 0x0F, 0x9F, 0x48, 0xF3, 0xC5, 0x94, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x64, 0xF3, 0x11, 0x93,
+         0x0D, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x0C, 0xBC, 0x01, 0x96, 0x40, 0x46, 0x02, 0x4E, 0x0F, 0x9F, 0x6C, 0xF3, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x11, 0x93, 0x0E, 0xEC, 0x40, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0x77, 0xF3, 0x19, 0xD3, 0x11, 0xEC, 0x41, 0x94, 0x1A, 0xD5, 0x10, 0xEC, 0x43, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x0E, 0xEC,
+         0x0A, 0x95, 0x40, 0x00, 0x7F, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x87, 0xF3, 0x01, 0x95, 0x19, 0x25, 0x0E, 0xEC, 0x40, 0x98, 0x0A, 0x03, 0x01, 0x00, 0x01, 0xD2, 0x43, 0xB4, 0xC5, 0xD4, 0x0F, 0x9F,
+         0xAB, 0xF3, 0x11, 0x93, 0x0D, 0xEC, 0x12, 0x95, 0x0C, 0xBC, 0xC1, 0xD4, 0x12, 0x95, 0x0D, 0xEC, 0x11, 0x93, 0x0E, 0xBC, 0x59, 0x93, 0x59, 0x93, 0x02, 0x97, 0xC3, 0x02, 0xC2, 0xD2, 0x11, 0x93,
+         0x05, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAA, 0xF3, 0x11, 0x93, 0x0D, 0xEC, 0x41, 0x02, 0x19, 0xD3, 0x0D, 0xEC, 0x41, 0x08, 0x01, 0x94, 0x62, 0x93, 0x01, 0x49, 0x02, 0x1E, 0x0F, 0x9F,
+         0x91, 0xF3, 0xC5, 0x96, 0x40, 0x46, 0x02, 0x4E, 0x0F, 0x9F, 0xB9, 0xF3, 0x41, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x11, 0x93, 0x0E, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xC4, 0xF3, 0x19, 0xD3,
+         0x11, 0xEC, 0x41, 0x94, 0x1A, 0xD5, 0x10, 0xEC, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x41, 0x96, 0x0A, 0x65, 0xBF, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3,
+         0xEF, 0xFF, 0xC4, 0xD2, 0x42, 0x04, 0x41, 0x06, 0x4A, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0xCD, 0xF3, 0x41, 0x96, 0x0A, 0x65, 0x9F, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0xEF, 0xFF, 0xC4, 0xD2,
+         0x42, 0x04, 0x41, 0x06, 0x4A, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0xDB, 0xF3, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x08, 0x14, 0x19, 0xD3, 0x01, 0x84, 0x0A, 0x65,
+         0xFE, 0x7B, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFF, 0xE0, 0xC2, 0xD2, 0x0A, 0x65, 0xC0, 0x7A, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x09, 0x93, 0x00, 0x02, 0x19, 0xD3, 0x44, 0x96, 0x0A, 0x65, 0x80, 0x69, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x7F, 0xFF, 0xC2, 0xD2, 0x55, 0x92, 0x19, 0xD3, 0x2C, 0x90, 0x0B, 0x97,
+         0xFE, 0x00, 0x1B, 0xD7, 0x40, 0x85, 0x09, 0x93, 0x4C, 0x00, 0x19, 0xD3, 0x05, 0x84, 0x09, 0x63, 0x00, 0x14, 0x40, 0x94, 0xD1, 0xD4, 0x09, 0x43, 0xFF, 0xEC, 0x02, 0x9E, 0x0F, 0x9F, 0x1A, 0xF4,
+         0x40, 0x96, 0x1B, 0xD7, 0x12, 0xEC, 0x40, 0xF0, 0xC7, 0xEF, 0x09, 0x93, 0x47, 0xEE, 0x19, 0xD3, 0x1B, 0xEC, 0x41, 0x96, 0x1B, 0xD7, 0x05, 0xEC, 0x11, 0x93, 0x20, 0xBC, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x2C, 0xF4, 0xC8, 0xD2, 0x40, 0xF0, 0x3A, 0xF4, 0x41, 0x00, 0x0F, 0x9F, 0x2C, 0xF4, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x05, 0x92, 0xC5, 0xD2,
+         0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x88, 0xF4, 0x12, 0x95, 0x21, 0xBC, 0x01, 0xD4, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x50, 0xF4, 0x40, 0xF0, 0x99, 0xF0,
+         0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x59, 0xF4, 0x40, 0xF0, 0xA3, 0xF0, 0x01, 0x94, 0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x64, 0xF4,
+         0x40, 0xF0, 0xE7, 0xEF, 0x0F, 0x9F, 0x6D, 0xF4, 0x01, 0x94, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x6D, 0xF4, 0x40, 0xF0, 0xB3, 0xF0, 0x01, 0x94, 0x0A, 0xB3, 0x10, 0x00,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x76, 0xF4, 0x40, 0xF0, 0xBE, 0xF0, 0x11, 0x93, 0x10, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x7F, 0xF4, 0x44, 0x92, 0x0F, 0x9F, 0x83, 0xF4, 0x41, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0x85, 0xF4, 0x19, 0xD3, 0x0B, 0xBC, 0x40, 0x94, 0x1A, 0xD5, 0x10, 0xEC, 0xC5, 0x94, 0x0A, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAB, 0xF4, 0x11, 0x93,
+         0x28, 0xBC, 0x01, 0xD2, 0x42, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x99, 0xF4, 0x40, 0xF0, 0xC6, 0xF0, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xA2, 0xF4,
+         0x40, 0xF0, 0xD5, 0xF0, 0x01, 0x94, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAB, 0xF4, 0x40, 0xF0, 0xE5, 0xF0, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x40, 0xF0, 0xE8, 0xF3, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+ };
+#elif defined(ZD1211B)
+={
+         0x08, 0x91, 0xFF, 0xED, 0x09, 0x93, 0x1D, 0xEE, 0xD1, 0x94, 0x11, 0xEE, 0x88, 0xD4, 0xD1, 0x96, 0xD1, 0x98, 0x5C, 0x99, 0x5C, 0x99, 0x4C, 0x99, 0x04, 0x9D, 0xD1, 0x98, 0xD1, 0x9A, 0x03, 0xEE,
+         0xF4, 0x94, 0xD3, 0xD4, 0x41, 0x2A, 0x40, 0x4A, 0x45, 0xBE, 0x88, 0x92, 0x41, 0x24, 0x40, 0x44, 0x53, 0xBE, 0x40, 0xF0, 0xFE, 0xF3, 0x41, 0xEE, 0x98, 0x9A, 0x01, 0x00, 0x1F, 0xEC, 0x00, 0x00,
+         0xB2, 0xF8, 0x4D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A,
+         0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x98, 0x9A, 0x01, 0xF1, 0x05, 0xF1, 0x49, 0xF1, 0x09, 0xF1, 0x49, 0xF1, 0x0D, 0xF1, 0x17, 0xF1, 0x49, 0xF1, 0x21, 0xF1, 0x2B, 0xF1, 0x35, 0xF1, 0x3F, 0xF1,
+         0x1E, 0xF2, 0x22, 0xF2, 0x2D, 0xF2, 0x6C, 0xF2, 0x6C, 0xF2, 0x57, 0xF2, 0x62, 0xF2, 0x00, 0x00, 0x27, 0xEF, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x00, 0xEC, 0x41, 0x44, 0x02, 0x5E,
+         0x0F, 0x9F, 0xB8, 0xEE, 0x11, 0x93, 0x01, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xB8, 0xEE, 0x11, 0x93, 0x02, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xB8, 0xEE, 0x4F, 0x96, 0x1B, 0xD7,
+         0x30, 0xBC, 0x1A, 0xD5, 0x80, 0xBC, 0x0C, 0x99, 0x86, 0x00, 0x1C, 0xD9, 0x90, 0xBC, 0x46, 0x94, 0x0C, 0x69, 0x6F, 0x43, 0x01, 0x97, 0xD4, 0xD4, 0x0B, 0x07, 0xFF, 0xFF, 0x40, 0x46, 0x02, 0x3E,
+         0x0F, 0x9F, 0x6B, 0xEE, 0x42, 0x96, 0x1B, 0xD7, 0x61, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x60, 0xBC, 0x0A, 0x65, 0xBF, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0x9F, 0xFF, 0xC4, 0xD2, 0x0A, 0x95,
+         0xF2, 0x00, 0x1A, 0xD5, 0x31, 0xBC, 0x52, 0x98, 0x1C, 0xD9, 0x82, 0xBC, 0x09, 0x93, 0x82, 0x00, 0x19, 0xD3, 0x92, 0xBC, 0x40, 0x94, 0x1A, 0xD5, 0x42, 0xBC, 0x0B, 0xA3, 0x20, 0x00, 0x19, 0xD3,
+         0x43, 0xBC, 0x0B, 0x97, 0xFE, 0x00, 0x1B, 0xD7, 0x32, 0xBC, 0x53, 0x98, 0x1C, 0xD9, 0x8E, 0xBC, 0x09, 0x93, 0x83, 0x00, 0x19, 0xD3, 0x9E, 0xBC, 0x0A, 0x95, 0x40, 0x00, 0x1A, 0xD5, 0x44, 0xBC,
+         0x60, 0x96, 0x1B, 0xD7, 0x45, 0xBC, 0x0C, 0x99, 0xFF, 0x00, 0x1C, 0xD9, 0x33, 0xBC, 0x44, 0x96, 0x1B, 0xD7, 0x8F, 0xBC, 0x19, 0xD3, 0x9F, 0xBC, 0x40, 0x98, 0x1C, 0xD9, 0x67, 0xBC, 0x1A, 0xD5,
+         0x66, 0xBC, 0x0A, 0x65, 0xB9, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x9F, 0xFF, 0xC3, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x00, 0xEC, 0x41, 0x44,
+         0x02, 0x5E, 0x0F, 0x9F, 0x25, 0xEF, 0x11, 0x93, 0x01, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x25, 0xEF, 0x11, 0x93, 0x02, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x25, 0xEF, 0x4F, 0x96,
+         0x1B, 0xD7, 0x30, 0xBC, 0x1A, 0xD5, 0x80, 0xBC, 0x0A, 0x95, 0x86, 0x00, 0x1A, 0xD5, 0x90, 0xBC, 0x46, 0x94, 0x0B, 0x67, 0x6F, 0x43, 0xD3, 0xD4, 0x09, 0x03, 0xFF, 0xFF, 0x40, 0x42, 0x02, 0x3E,
+         0x0F, 0x9F, 0xDB, 0xEE, 0x40, 0x96, 0x1B, 0xD7, 0x61, 0xBC, 0x0C, 0x99, 0x40, 0x00, 0x1C, 0xD9, 0x60, 0xBC, 0x0A, 0x65, 0xBF, 0x43, 0xC2, 0x92, 0x09, 0xB3, 0x9F, 0xFF, 0xC2, 0xD2, 0x0A, 0x95,
+         0xF2, 0x00, 0x1A, 0xD5, 0x31, 0xBC, 0x52, 0x96, 0x1B, 0xD7, 0x82, 0xBC, 0x09, 0x93, 0x82, 0x00, 0x19, 0xD3, 0x92, 0xBC, 0x1C, 0xD9, 0x42, 0xBC, 0x40, 0x94, 0x0A, 0xA7, 0x20, 0x00, 0x1B, 0xD7,
+         0x43, 0xBC, 0x0A, 0x95, 0xFE, 0x00, 0x1A, 0xD5, 0x32, 0xBC, 0x53, 0x94, 0x1A, 0xD5, 0x8E, 0xBC, 0x0A, 0x95, 0x83, 0x00, 0x1A, 0xD5, 0x9E, 0xBC, 0x1C, 0xD9, 0x44, 0xBC, 0x1B, 0xD7, 0x45, 0xBC,
+         0x0B, 0x97, 0xFF, 0x00, 0x1B, 0xD7, 0x33, 0xBC, 0x44, 0x94, 0x1A, 0xD5, 0x8F, 0xBC, 0x19, 0xD3, 0x9F, 0xBC, 0x40, 0x96, 0x1B, 0xD7, 0x67, 0xBC, 0x1C, 0xD9, 0x66, 0xBC, 0x0A, 0x65, 0xB9, 0x43,
+         0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x9F, 0xFF, 0xC3, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x95, 0x09, 0xEC, 0x02, 0x97, 0xC3, 0x92, 0x71, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x6E, 0xEF, 0x02, 0x8E, 0x0F, 0x9F, 0x3B, 0xEF, 0x70, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x41, 0xEF, 0x0F, 0x9F, 0x96, 0xEF, 0x72, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x60, 0xEF, 0x0F, 0x9F,
+         0x96, 0xEF, 0x0A, 0x03, 0x03, 0x00, 0xC1, 0x96, 0x1B, 0xD7, 0x0E, 0xEC, 0x0A, 0x03, 0x01, 0x00, 0xC1, 0x94, 0x1A, 0xD5, 0x0D, 0xEC, 0x0A, 0x45, 0xFF, 0xED, 0x02, 0x8E, 0x0F, 0x9F, 0x5B, 0xEF,
+         0x0B, 0x03, 0x01, 0x00, 0x61, 0x93, 0x11, 0x03, 0x4D, 0xEC, 0x19, 0xD3, 0x4D, 0xEC, 0x0A, 0x03, 0x00, 0xDE, 0x19, 0xD3, 0x0D, 0xEC, 0x42, 0x98, 0x1C, 0xD9, 0x11, 0xEC, 0x0F, 0x9F, 0x96, 0xEF,
+         0x0A, 0x03, 0x03, 0x00, 0xC1, 0x92, 0x19, 0xD3, 0x0E, 0xEC, 0x0A, 0x03, 0x01, 0x00, 0xC1, 0x92, 0x19, 0xD3, 0x0D, 0xEC, 0x40, 0xF0, 0x2F, 0xF3, 0x0F, 0x9F, 0x96, 0xEF, 0x41, 0x92, 0x19, 0xD3,
+         0x0C, 0xBC, 0x42, 0x94, 0x1A, 0xD5, 0xF0, 0xBD, 0x19, 0xD3, 0x0B, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x12, 0x95, 0x4D, 0xEC, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x94, 0xEF, 0x02, 0x43,
+         0x02, 0x0E, 0x0F, 0x9F, 0x8F, 0xEF, 0x0B, 0x97, 0x00, 0x10, 0x0A, 0x65, 0x00, 0x12, 0xD2, 0x98, 0xD3, 0xD8, 0x41, 0x02, 0x11, 0x43, 0x4D, 0xEC, 0x02, 0x1E, 0x0F, 0x9F, 0x87, 0xEF, 0x40, 0x92,
+         0x19, 0xD3, 0x4D, 0xEC, 0x0F, 0x9F, 0x96, 0xEF, 0x0F, 0x9F, 0x95, 0xF8, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92,
+         0x09, 0xB3, 0xFD, 0xFF, 0xC2, 0xD2, 0x09, 0x93, 0xFF, 0x00, 0x19, 0xD3, 0x12, 0xBC, 0x19, 0xD3, 0x13, 0xBC, 0x19, 0xD3, 0x14, 0xBC, 0x19, 0xD3, 0x16, 0xBC, 0x19, 0xD3, 0x17, 0xBC, 0x0C, 0x69,
+         0x00, 0x44, 0x04, 0x93, 0xC1, 0x94, 0x0A, 0xB5, 0xEF, 0xFF, 0xC5, 0xD4, 0x41, 0x94, 0x1A, 0xD5, 0x02, 0xBC, 0x0B, 0x67, 0xEF, 0x43, 0x03, 0x95, 0xC2, 0x92, 0x09, 0xA3, 0x40, 0x00, 0xC3, 0xD2,
+         0xC5, 0x96, 0x0B, 0xA5, 0x20, 0x00, 0xC4, 0xD4, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x0E, 0xEC, 0x19, 0xD3, 0x11, 0xEC,
+         0x19, 0xD3, 0x00, 0xEC, 0x19, 0xD3, 0x01, 0xEC, 0x19, 0xD3, 0x02, 0xEC, 0x19, 0xD3, 0x0F, 0xEC, 0x19, 0xD3, 0x10, 0xEC, 0x19, 0xD3, 0x1C, 0xEC, 0x40, 0xF0, 0x98, 0xEF, 0x40, 0x92, 0x19, 0xD3,
+         0x08, 0xBC, 0x41, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x41, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x12, 0xEC, 0x41, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0x4A, 0xF0, 0x41, 0x94, 0x1A, 0xD5, 0x12, 0xEC, 0x11, 0x93, 0x00, 0xBC, 0x09, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x21, 0xF0, 0x09, 0x93, 0x00, 0x02, 0x19, 0xD3, 0x03, 0xEC,
+         0x09, 0x93, 0x31, 0xF8, 0x19, 0xD3, 0x13, 0xEC, 0x02, 0x97, 0x01, 0x99, 0x03, 0x95, 0x09, 0x93, 0x16, 0xEC, 0x01, 0x05, 0x03, 0x93, 0x04, 0x03, 0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x06, 0x43, 0x46,
+         0x02, 0x9E, 0x0F, 0x9F, 0x06, 0xF0, 0x11, 0x93, 0x39, 0xF8, 0x79, 0x93, 0x79, 0x93, 0x19, 0xD3, 0x1A, 0xEC, 0x09, 0x93, 0x1F, 0xEC, 0x19, 0xD3, 0x14, 0xEC, 0x09, 0x93, 0x36, 0xEC, 0x0F, 0x9F,
+         0x44, 0xF0, 0x09, 0x93, 0x40, 0x00, 0x19, 0xD3, 0x03, 0xEC, 0x09, 0x93, 0x31, 0xF8, 0x19, 0xD3, 0x13, 0xEC, 0x02, 0x97, 0x01, 0x99, 0x03, 0x95, 0x09, 0x93, 0x16, 0xEC, 0x01, 0x05, 0x03, 0x93,
+         0x04, 0x03, 0xC1, 0x92, 0xC2, 0xD2, 0x41, 0x06, 0x43, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0x2B, 0xF0, 0x11, 0x93, 0x39, 0xF8, 0x79, 0x93, 0x79, 0x93, 0x19, 0xD3, 0x1A, 0xEC, 0x09, 0x93, 0x36, 0xEC,
+         0x19, 0xD3, 0x14, 0xEC, 0x09, 0x93, 0x1F, 0xEC, 0x19, 0xD3, 0x15, 0xEC, 0x09, 0x93, 0x0A, 0x06, 0x19, 0xD3, 0x16, 0xEC, 0x13, 0x97, 0x0C, 0xBC, 0x0B, 0xB3, 0x80, 0x00, 0x0A, 0x95, 0x06, 0xEC,
+         0xD2, 0xD2, 0x0B, 0xB3, 0x60, 0x00, 0xC2, 0xD2, 0x09, 0x93, 0x06, 0xEC, 0x09, 0x05, 0x02, 0x00, 0x0B, 0xB3, 0x03, 0x00, 0xC2, 0xD2, 0xC5, 0x92, 0x11, 0x93, 0x0E, 0xBC, 0x19, 0xD3, 0x09, 0xEC,
+         0x14, 0x99, 0x0C, 0xBC, 0x13, 0x97, 0x0E, 0xBC, 0x5B, 0x97, 0x5B, 0x97, 0x1B, 0x09, 0x0A, 0xEC, 0x14, 0x99, 0x0C, 0xBC, 0x13, 0x97, 0x0E, 0xBC, 0x5B, 0x97, 0x5B, 0x97, 0x1B, 0x09, 0x0B, 0xEC,
+         0x14, 0x99, 0x0C, 0xBC, 0x13, 0x97, 0x0E, 0xBC, 0x5B, 0x97, 0x5B, 0x97, 0x1B, 0x09, 0x0C, 0xEC, 0x11, 0x93, 0x07, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x8D, 0xF0, 0x09, 0x43, 0x40, 0x00,
+         0x02, 0x5E, 0x0F, 0x9F, 0x93, 0xF0, 0x11, 0x93, 0x1B, 0xEC, 0x41, 0x22, 0x0A, 0x95, 0x8B, 0xF0, 0x88, 0xD4, 0x88, 0xDC, 0x91, 0x9A, 0x0F, 0x9F, 0x96, 0xF0, 0x40, 0xF0, 0xF5, 0xF0, 0x40, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0x96, 0xF0, 0x42, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x41, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0xF0, 0x2F, 0xF3, 0x40, 0x92, 0x19, 0xD3,
+         0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x11, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xAE, 0xF0, 0x40, 0xF0, 0x7A, 0xF3, 0x40, 0x92, 0x19, 0xD3,
+         0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x40, 0x92, 0x19, 0xD3, 0x11, 0xEC, 0x41, 0x92, 0x19, 0xD3, 0x0B, 0xBC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x44, 0x92, 0x19, 0xD3, 0x0B, 0xBC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFD, 0xFF, 0xC2, 0xD2,
+         0x40, 0x92, 0x19, 0xD3, 0x12, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFB, 0xFF, 0xC2, 0xD2, 0x09, 0x93,
+         0x70, 0x00, 0x19, 0xD3, 0x05, 0x84, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x0A, 0x65, 0xD8, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xF7, 0xFF, 0xC2, 0xD2, 0x09, 0x93,
+         0x6D, 0x00, 0x19, 0xD3, 0x05, 0x84, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x09, 0xEC, 0x4B, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x49, 0xF1, 0x09, 0x03, 0x34, 0xEE,
+         0xC1, 0x9E, 0x40, 0xF0, 0x4C, 0xF1, 0x0F, 0x9F, 0x4A, 0xF1, 0x40, 0xF0, 0x62, 0xF1, 0x0F, 0x9F, 0x4A, 0xF1, 0x40, 0xF0, 0x76, 0xF1, 0x0F, 0x9F, 0x4A, 0xF1, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0x49, 0xF1, 0x40, 0xF0, 0xEE, 0xF1, 0x0F, 0x9F, 0x4A, 0xF1, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x49, 0xF1, 0x40, 0xF0, 0x02, 0xF2, 0x0F, 0x9F,
+         0x4A, 0xF1, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x49, 0xF1, 0x40, 0xF0, 0x7E, 0xF2, 0x0F, 0x9F, 0x4A, 0xF1, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F,
+         0x49, 0xF1, 0x40, 0xF0, 0x8D, 0xF2, 0x0F, 0x9F, 0x4A, 0xF1, 0x11, 0x93, 0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x49, 0xF1, 0x40, 0xF0, 0xCE, 0xF2, 0x0F, 0x9F, 0x4A, 0xF1, 0x11, 0x93,
+         0x0F, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x49, 0xF1, 0x40, 0xF0, 0xF4, 0xF2, 0x0F, 0x9F, 0x4A, 0xF1, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93,
+         0x08, 0xEC, 0x4F, 0xB2, 0x09, 0x03, 0x1C, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x0C, 0xBC, 0x40, 0x92, 0x19, 0xD3, 0x0E, 0xBC, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC,
+         0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x0A, 0xEC, 0x41, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x73, 0xF1, 0x40, 0x92, 0x19, 0xD3, 0x1E, 0xEC, 0x41, 0x92, 0x19, 0xD3,
+         0x10, 0xEC, 0x0F, 0x9F, 0x74, 0xF1, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x0A, 0xEC, 0x01, 0x95, 0xC2, 0x96, 0x41, 0x46, 0x02, 0x4E, 0x0F, 0x9F,
+         0x8F, 0xF1, 0x02, 0x1E, 0x0F, 0x9F, 0x8A, 0xF1, 0x42, 0x46, 0x02, 0x4E, 0x0F, 0x9F, 0x99, 0xF1, 0x0F, 0x9F, 0xE0, 0xF1, 0x41, 0x96, 0x1B, 0xD7, 0x10, 0xEC, 0x0F, 0x9F, 0xE3, 0xF1, 0x0A, 0x65,
+         0x00, 0x44, 0x02, 0x99, 0xC4, 0x92, 0x41, 0xA2, 0xC2, 0xD2, 0x1B, 0xD7, 0x10, 0xEC, 0x0F, 0x9F, 0xE3, 0xF1, 0x41, 0x02, 0xC1, 0x92, 0x79, 0x93, 0x79, 0x93, 0x44, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0xB8, 0xF1, 0x02, 0x9E, 0x0F, 0x9F, 0xAA, 0xF1, 0x45, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xE3, 0xF1, 0x0F, 0x9F, 0xE0, 0xF1, 0x41, 0x42, 0x02, 0x1E, 0x0F, 0x9F, 0xE0, 0xF1, 0x09, 0x03, 0x4D, 0xEC,
+         0xC1, 0x92, 0x19, 0xD3, 0x08, 0xBC, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x0F, 0x9F, 0xE3, 0xF1, 0x0A, 0x65, 0xF8, 0x43, 0x50, 0x98, 0x02, 0x97, 0xC3, 0xD8, 0x09, 0x63, 0xF5, 0x43, 0x41, 0x98,
+         0x01, 0x97, 0xC3, 0xD8, 0x40, 0x94, 0x02, 0x93, 0x0C, 0x99, 0x51, 0xEC, 0x04, 0x03, 0x01, 0x97, 0xC3, 0x96, 0x1B, 0xD7, 0x0C, 0xBC, 0xC1, 0x92, 0x79, 0x93, 0x79, 0x93, 0x19, 0xD3, 0x0E, 0xBC,
+         0x41, 0x04, 0x5A, 0x44, 0x02, 0x9E, 0x0F, 0x9F, 0xC3, 0xF1, 0x0C, 0x99, 0x7E, 0x00, 0x1C, 0xD9, 0x0C, 0xBC, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x19, 0xD3, 0x0B, 0xBC, 0x0F, 0x9F, 0xE3, 0xF1,
+         0x40, 0x92, 0x0F, 0x9F, 0xEC, 0xF1, 0x11, 0x93, 0x10, 0xEC, 0x41, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xEB, 0xF1, 0x19, 0xD3, 0x1E, 0xEC, 0x41, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x11, 0x93, 0x0A, 0xEC, 0x09, 0x43, 0xFF, 0x00, 0x02, 0x8E, 0x0F, 0x9F, 0xFF, 0xF1, 0x19, 0xD3, 0x01, 0xBC, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x0F, 0x9F, 0x00, 0xF2, 0x40, 0x92,
+         0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x14, 0xEC, 0x0A, 0x95, 0x09, 0x02, 0xC1, 0xD4, 0x11, 0x93, 0x15, 0xEC, 0x0B, 0x97, 0x09, 0x07, 0xC1, 0xD6, 0x0A, 0x95,
+         0x0A, 0xEC, 0x02, 0x97, 0xC3, 0x92, 0x79, 0x93, 0x79, 0x93, 0x09, 0x03, 0xFF, 0xFF, 0x46, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x6C, 0xF2, 0x09, 0x03, 0x40, 0xEE, 0xC1, 0x9E, 0x11, 0x93, 0x13, 0xEC,
+         0x0F, 0x9F, 0x59, 0xF2, 0xC2, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x6C, 0xF2, 0x11, 0x93, 0x14, 0xEC, 0x0F, 0x9F, 0x64, 0xF2, 0xC2, 0x92, 0x09, 0xB3, 0xFF, 0x00,
+         0x50, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x49, 0xF2, 0x02, 0x8E, 0x0F, 0x9F, 0x3D, 0xF2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x43, 0xF2, 0x0F, 0x9F, 0x6C, 0xF2, 0x60, 0x42, 0x02, 0x4E, 0x0F, 0x9F,
+         0x4F, 0xF2, 0x0F, 0x9F, 0x6C, 0xF2, 0x09, 0x93, 0x3A, 0xF8, 0x19, 0xD3, 0x0D, 0xEC, 0x0F, 0x9F, 0x53, 0xF2, 0x0A, 0x95, 0x6F, 0xF8, 0x1A, 0xD5, 0x0D, 0xEC, 0x0F, 0x9F, 0x53, 0xF2, 0x0B, 0x97,
+         0x7A, 0xF8, 0x1B, 0xD7, 0x0D, 0xEC, 0x11, 0x93, 0x0D, 0xEC, 0x0F, 0x9F, 0x5B, 0xF2, 0x09, 0x93, 0x16, 0xEC, 0x19, 0xD3, 0x0D, 0xEC, 0xC1, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x19, 0xD3, 0x0E, 0xEC,
+         0x0F, 0x9F, 0x6F, 0xF2, 0x11, 0x93, 0x15, 0xEC, 0x19, 0xD3, 0x0D, 0xEC, 0x41, 0x02, 0xC1, 0x92, 0x19, 0xD3, 0x0E, 0xEC, 0x0F, 0x9F, 0x6F, 0xF2, 0x40, 0x92, 0x0F, 0x9F, 0x7C, 0xF2, 0x11, 0x93,
+         0x0E, 0xEC, 0x12, 0x95, 0x0C, 0xEC, 0x02, 0x43, 0x02, 0x9E, 0x0F, 0x9F, 0x79, 0xF2, 0x1A, 0xD5, 0x0E, 0xEC, 0x40, 0xF0, 0x2F, 0xF3, 0x41, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x11, 0x93, 0x00, 0xEC, 0x19, 0xD3, 0x0C, 0xBC, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00,
+         0x11, 0x93, 0x0A, 0xEC, 0x09, 0xB5, 0xFF, 0x00, 0x40, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0xA3, 0xF2, 0x1A, 0xD5, 0x00, 0xEC, 0x0A, 0x65, 0xFF, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x7F, 0xFF,
+         0xC2, 0xD2, 0x0F, 0x9F, 0xC9, 0xF2, 0x11, 0x93, 0x00, 0xBC, 0x09, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xB8, 0xF2, 0x41, 0x44, 0x02, 0x9E, 0x0F, 0x9F, 0xB2, 0xF2, 0x40, 0x92,
+         0x0F, 0x9F, 0xCC, 0xF2, 0x1A, 0xD5, 0x00, 0xEC, 0x40, 0xF0, 0x49, 0xEE, 0x0F, 0x9F, 0xC0, 0xF2, 0x41, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0xCC, 0xF2, 0x1A, 0xD5, 0x00, 0xEC, 0x40, 0xF0, 0xBA, 0xEE,
+         0x0A, 0x65, 0xFF, 0x43, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xA3, 0x80, 0x00, 0xC2, 0xD2, 0x40, 0xF0, 0xC7, 0xF3, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x11, 0x93, 0x01, 0xBC, 0x09, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xF2, 0xF2, 0x12, 0x95, 0x00, 0xEC, 0x41, 0x44, 0x02, 0x5E, 0x0F, 0x9F, 0xE5, 0xF2, 0x11, 0x93,
+         0x0B, 0xEC, 0x41, 0x42, 0x02, 0x9E, 0x0F, 0x9F, 0xE8, 0xF2, 0x40, 0x92, 0x0F, 0x9F, 0xF2, 0xF2, 0x11, 0x93, 0x02, 0xEC, 0x19, 0xD3, 0x0C, 0xBC, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x1A, 0xD5,
+         0x10, 0xEC, 0x02, 0x93, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x01, 0xBC, 0x09, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x2C, 0xF3, 0x13, 0x97,
+         0x0B, 0xEC, 0x40, 0x46, 0x02, 0x5E, 0x0F, 0x9F, 0x2C, 0xF3, 0x11, 0x93, 0x0A, 0xEC, 0x09, 0xB5, 0xFF, 0x00, 0x11, 0x93, 0x14, 0xEC, 0x46, 0x02, 0xC1, 0x92, 0x09, 0xB3, 0xFF, 0x00, 0x01, 0x45,
+         0x02, 0x5E, 0x0F, 0x9F, 0x2C, 0xF3, 0x1B, 0xD7, 0x01, 0xEC, 0x1A, 0xD5, 0x02, 0xEC, 0x11, 0x93, 0x00, 0xBC, 0x09, 0xB3, 0x40, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x23, 0xF3, 0x40, 0xF0,
+         0x49, 0xEE, 0x0F, 0x9F, 0x25, 0xF3, 0x40, 0xF0, 0xBA, 0xEE, 0x40, 0xF0, 0xC7, 0xF3, 0x41, 0x92, 0x19, 0xD3, 0x10, 0xEC, 0x0F, 0x9F, 0x2D, 0xF3, 0x40, 0x92, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA,
+         0x43, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x12, 0x95, 0x0E, 0xEC, 0x09, 0x93, 0x40, 0x00, 0x7F, 0x44, 0x02, 0x8E, 0x0F, 0x9F, 0x3C, 0xF3, 0x02, 0x93, 0x1A, 0x23, 0x0E, 0xEC, 0x40, 0x98, 0x61, 0x95,
+         0x02, 0xD4, 0x09, 0xB7, 0x01, 0x00, 0xC5, 0xD6, 0x43, 0xB2, 0x01, 0xD2, 0x0F, 0x9F, 0x56, 0xF3, 0x12, 0x95, 0x0D, 0xEC, 0x02, 0x93, 0xC1, 0x92, 0x19, 0xD3, 0x0C, 0xBC, 0xD2, 0x92, 0x79, 0x93,
+         0x79, 0x93, 0x19, 0xD3, 0x0E, 0xBC, 0x1A, 0xD5, 0x0D, 0xEC, 0x41, 0x08, 0x02, 0x48, 0x02, 0x1E, 0x0F, 0x9F, 0x48, 0xF3, 0xC5, 0x94, 0x40, 0x44, 0x02, 0x4E, 0x0F, 0x9F, 0x64, 0xF3, 0x11, 0x93,
+         0x0D, 0xEC, 0xC1, 0x92, 0x19, 0xD3, 0x0C, 0xBC, 0x01, 0x96, 0x40, 0x46, 0x02, 0x4E, 0x0F, 0x9F, 0x6C, 0xF3, 0x42, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x11, 0x93, 0x0E, 0xEC, 0x40, 0x42, 0x02, 0x5E,
+         0x0F, 0x9F, 0x77, 0xF3, 0x19, 0xD3, 0x11, 0xEC, 0x41, 0x94, 0x1A, 0xD5, 0x10, 0xEC, 0x43, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x11, 0x93, 0x0E, 0xEC,
+         0x0A, 0x95, 0x40, 0x00, 0x7F, 0x42, 0x02, 0x8E, 0x0F, 0x9F, 0x87, 0xF3, 0x01, 0x95, 0x19, 0x25, 0x0E, 0xEC, 0x40, 0x98, 0x0A, 0x03, 0x01, 0x00, 0x01, 0xD2, 0x43, 0xB4, 0xC5, 0xD4, 0x0F, 0x9F,
+         0xAB, 0xF3, 0x11, 0x93, 0x0D, 0xEC, 0x12, 0x95, 0x0C, 0xBC, 0xC1, 0xD4, 0x12, 0x95, 0x0D, 0xEC, 0x11, 0x93, 0x0E, 0xBC, 0x59, 0x93, 0x59, 0x93, 0x02, 0x97, 0xC3, 0x02, 0xC2, 0xD2, 0x11, 0x93,
+         0x05, 0xEC, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAA, 0xF3, 0x11, 0x93, 0x0D, 0xEC, 0x41, 0x02, 0x19, 0xD3, 0x0D, 0xEC, 0x41, 0x08, 0x01, 0x94, 0x62, 0x93, 0x01, 0x49, 0x02, 0x1E, 0x0F, 0x9F,
+         0x91, 0xF3, 0xC5, 0x96, 0x40, 0x46, 0x02, 0x4E, 0x0F, 0x9F, 0xB9, 0xF3, 0x41, 0x92, 0x19, 0xD3, 0xF0, 0xBD, 0x11, 0x93, 0x0E, 0xEC, 0x40, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0xC4, 0xF3, 0x19, 0xD3,
+         0x11, 0xEC, 0x41, 0x94, 0x1A, 0xD5, 0x10, 0xEC, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x41, 0x96, 0x0A, 0x65, 0xBF, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3,
+         0xEF, 0xFF, 0xC4, 0xD2, 0x42, 0x04, 0x41, 0x06, 0x4A, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0xCD, 0xF3, 0x41, 0x96, 0x0A, 0x65, 0x9F, 0x43, 0x02, 0x99, 0xC4, 0x92, 0x09, 0xB3, 0xEF, 0xFF, 0xC4, 0xD2,
+         0x42, 0x04, 0x41, 0x06, 0x4A, 0x46, 0x02, 0x9E, 0x0F, 0x9F, 0xDB, 0xF3, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x09, 0x93, 0x08, 0x14, 0x19, 0xD3, 0x01, 0x84, 0x0A, 0x65,
+         0xFE, 0x7B, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0xFF, 0xE0, 0xC2, 0xD2, 0x0A, 0x65, 0xC0, 0x7A, 0x02, 0x97, 0xC3, 0x92, 0x48, 0xA2, 0xC2, 0xD2, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x09, 0x93, 0x00, 0x02, 0x19, 0xD3, 0x44, 0x96, 0x0A, 0x65, 0x80, 0x69, 0x02, 0x97, 0xC3, 0x92, 0x09, 0xB3, 0x7F, 0xFF, 0xC2, 0xD2, 0x55, 0x92, 0x19, 0xD3, 0x2C, 0x90, 0x0B, 0x97,
+         0xFE, 0x00, 0x1B, 0xD7, 0x40, 0x85, 0x09, 0x93, 0x4C, 0x00, 0x19, 0xD3, 0x05, 0x84, 0x09, 0x63, 0x00, 0x14, 0x40, 0x94, 0xD1, 0xD4, 0x09, 0x43, 0xFF, 0xEC, 0x02, 0x9E, 0x0F, 0x9F, 0x1A, 0xF4,
+         0x40, 0x96, 0x1B, 0xD7, 0x12, 0xEC, 0x40, 0xF0, 0xC7, 0xEF, 0x09, 0x93, 0x47, 0xEE, 0x19, 0xD3, 0x1B, 0xEC, 0x41, 0x96, 0x1B, 0xD7, 0x05, 0xEC, 0x11, 0x93, 0x20, 0xBC, 0x40, 0x42, 0x02, 0x4E,
+         0x0F, 0x9F, 0x2C, 0xF4, 0xC8, 0xD2, 0x40, 0xF0, 0x3A, 0xF4, 0x41, 0x00, 0x0F, 0x9F, 0x2C, 0xF4, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x42, 0x20, 0x08, 0x0B, 0x01, 0x00, 0x05, 0x92, 0xC5, 0xD2,
+         0x41, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x88, 0xF4, 0x12, 0x95, 0x21, 0xBC, 0x01, 0xD4, 0x0A, 0xB3, 0x02, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x50, 0xF4, 0x40, 0xF0, 0x99, 0xF0,
+         0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x59, 0xF4, 0x40, 0xF0, 0xA3, 0xF0, 0x01, 0x94, 0x0A, 0xB3, 0x01, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x64, 0xF4,
+         0x40, 0xF0, 0xE7, 0xEF, 0x0F, 0x9F, 0x6D, 0xF4, 0x01, 0x94, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x6D, 0xF4, 0x40, 0xF0, 0xB3, 0xF0, 0x01, 0x94, 0x0A, 0xB3, 0x10, 0x00,
+         0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x76, 0xF4, 0x40, 0xF0, 0xBE, 0xF0, 0x11, 0x93, 0x10, 0xEC, 0x42, 0x42, 0x02, 0x5E, 0x0F, 0x9F, 0x7F, 0xF4, 0x44, 0x92, 0x0F, 0x9F, 0x83, 0xF4, 0x41, 0x42,
+         0x02, 0x5E, 0x0F, 0x9F, 0x85, 0xF4, 0x19, 0xD3, 0x0B, 0xBC, 0x40, 0x94, 0x1A, 0xD5, 0x10, 0xEC, 0xC5, 0x94, 0x0A, 0xB3, 0x80, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAB, 0xF4, 0x11, 0x93,
+         0x28, 0xBC, 0x01, 0xD2, 0x42, 0xB2, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0x99, 0xF4, 0x40, 0xF0, 0xC6, 0xF0, 0x01, 0x94, 0x0A, 0xB3, 0x04, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xA2, 0xF4,
+         0x40, 0xF0, 0xD5, 0xF0, 0x01, 0x94, 0x0A, 0xB3, 0x08, 0x00, 0x40, 0x42, 0x02, 0x4E, 0x0F, 0x9F, 0xAB, 0xF4, 0x40, 0xF0, 0xE5, 0xF0, 0x42, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B,
+         0x01, 0x00, 0x40, 0xF0, 0xE8, 0xF3, 0x88, 0x98, 0x90, 0x9A, 0x88, 0xDA, 0x08, 0x0B, 0x01, 0x00, 0x88, 0x98, 0x90, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+ };
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/menu_drv_macro.h linux-2.4.35.3-mct/drivers/usb/zd1211/menu_drv_macro.h
--- linux-2.4.35.3/drivers/usb/zd1211/menu_drv_macro.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/menu_drv_macro.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,22 @@
+#ifndef __MENU_DRV_MACRO_H
+#define __MENU_DRV_MACRO_H
+
+#define	RDPhy		1
+#define WRPhy		2
+#define	RDMAC		3
+#define WRMAC		4
+#define RDCNT		5
+#define BUF_LEN		2048
+
+#define	T_bcnCnt		0
+#define T_dtimCnt		1
+#define T_txCmpCnt		2
+#define T_rxCnt			3
+#define T_retryFailCnt	4
+#define T_txCnt			5
+#define T_txIdleCnt		6
+#define T_rxIdleCnt		7
+#define T_rxDupCnt		8
+
+#define ZD_MENU_DBG		ZDAPIOCTL+4
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zd1205.c linux-2.4.35.3-mct/drivers/usb/zd1211/zd1205.c
--- linux-2.4.35.3/drivers/usb/zd1211/zd1205.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zd1205.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,10329 @@
+/* src/zd1205.c
+*
+* 
+*
+* Copyright (C) 2004 ZyDAS Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* 
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* -------------------------------------------------------------------- */
+#define __KERNEL_SYSCALLS__
+
+#include <linux/config.h>
+#include <net/checksum.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+
+#include <linux/fs.h>
+#include <linux/stat.h>
+
+#include "zd1205.h"
+#include "zdinlinef.h"
+#include "zddebug.h"
+#include "zddebug2.h"
+#include "menu_drv_macro.h"
+#include "zdhw.h"
+#include "zdsorts.h"
+#include "zdglobal.h"
+#include "zdutils.h"
+#include "zdpsmon.h"
+#ifdef HOST_IF_USB
+	#include "zd1211.h"
+#endif
+#include "zdhci.h"
+
+
+#if WIRELESS_EXT > 12
+    #include <net/iw_handler.h>
+#endif
+extern U16 mTmRetryConnect;
+extern BOOLEAN mProbeWithSsid;
+extern u8 mMacMode;
+extern U8 mBssType;
+extern Element mSsid;
+extern Element dot11DesiredSsid;
+int errno;
+extern u8 mCurrConnUser;
+extern U8 mNumBOnlySta;
+
+extern u8 mBssNum;
+extern U8 mKeyFormat; //Init value: WEP64_USED(1)
+extern BOOLEAN mPrivacyInvoked; // Init value: FALSE
+extern U8 mKeyVector[4][16]; // Store WEP key
+extern U8 mWepKeyLen;
+extern U8 mKeyId;  // Init value: 0
+extern U16 mCap;   // Init value: CAP_ESS(1);
+extern u16 CurrScanCH;
+extern MacAddr_t dot11MacAddress;
+
+extern BOOLEAN zd_CmdProbeReq(U8 bWithSSID);
+extern Hash_t *HashSearch(MacAddr_t *pMac);
+extern void re_initFdescBuf(void);
+/******************************************************************************
+*						   C O N S T A N T S
+*******************************************************************************
+*/
+
+
+static u8	ZD_SNAP_HEADER[6] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
+static u8	ZD_SNAP_BRIDGE_TUNNEL[6] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
+static u8  zd_Snap_Apple_Type[] = {0xAA,0xAA,0x03,0x08,0x00,0x07,0x80,0x9b};
+
+static u16 IPX=0x8137;
+//static u16 NOVELL=0xe0e0; // currently not used
+static u16 APPLE_TALK=0x80f3;
+static u16 EAPOL=0x888e;
+
+
+#define MAX_MULTICAST_ADDRS     32
+#define NUM_WEPKEYS     4
+
+#define bGroup(pWlanHdr)			(pWlanHdr->Address1[0] & BIT_0)
+#define getSeq(pWlanHdr)			(((u16)pWlanHdr->SeqCtrl[1] << 4) + (u16)((pWlanHdr->SeqCtrl[0] & 0xF0) >> 4))
+#define getFrag(pWlanHdr)			(pWlanHdr->SeqCtrl[0] & 0x0F)
+#define	getTA(pWlanHdr)				(&pWlanHdr->Address2[0])
+#define isWDS(pWlanHdr)				(((pWlanHdr->FrameCtrl[1] & TO_DS_FROM_DS) == TO_DS_FROM_DS) ? 1 : 0)
+#define bRetryBit(pWlanHdr)			(pWlanHdr->FrameCtrl[1] & RETRY_BIT)
+#define bWepBit(pWlanHdr)			(pWlanHdr->FrameCtrl[1] & ENCRY_BIT)
+#define bMoreFrag(pWlanHdr)			(pWlanHdr->FrameCtrl[1] & MORE_FRAG)
+#define bMoreData(pWlanHdr)			(pWlanHdr->FrameCtrl[1] & MORE_DATA)
+#define BaseFrameType(pWlanHdr)		(pWlanHdr->FrameCtrl[0] & 0x0C)
+#define SubFrameType(pWlanHdr)		(pWlanHdr->FrameCtrl[0])
+#define bDataMgtFrame(pWlanHdr)		(((pWlanHdr->FrameCtrl[0] & 0x04) == 0))
+#ifndef HOST_IF_USB
+    #define nowT()					(zd_readl(TSF_LowPart))  //us unit
+#else
+    #define nowT()					(jiffies) //tick (10ms) unit
+#endif
+/******************************************************************************
+*			   F U N C T I O N	 D E C L A R A T I O N S
+*******************************************************************************
+*/
+#ifdef CONFIG_PROC_FS
+
+extern int zd1205_create_proc_subdir(struct zd1205_private *);
+extern void zd1205_remove_proc_subdir(struct zd1205_private *);
+#else
+    #define zd1205_create_proc_subdir(X) 0
+    #define zd1205_remove_proc_subdir(X) do {} while(0)
+#endif
+static u32 channel_11A_to_Freq(const u32 channel);
+//static u32 Freq_11A_to_channel(const u32 freq);
+
+
+static unsigned char zd1205_alloc_space(struct zd1205_private *);
+unsigned char zd1205_init(struct zd1205_private *);
+static void zd1205_setup_tcb_pool(struct zd1205_private *macp);
+static void zd1205_config(struct zd1205_private *macp);
+static void zd1205_rd_eaddr(struct zd1205_private *);
+int zd1205_open(struct net_device *);
+int zd1205_close(struct net_device *);
+int zd1205_change_mtu(struct net_device *, int);
+int zd1205_set_mac(struct net_device *, void *);
+void zd1205_set_multi(struct net_device *);
+struct net_device_stats *zd1205_get_stats(struct net_device *);
+static int zd1205_alloc_tcb_pool(struct zd1205_private *);
+static void zd1205_free_tcb_pool(struct zd1205_private *);
+static int zd1205_alloc_rfd_pool(struct zd1205_private *);
+static void zd1205_free_rfd_pool(struct zd1205_private *);
+static void zd1205_clear_pools(struct zd1205_private *macp);
+zd1205_SwTcb_t * zd1205_first_txq(struct zd1205_private *macp, zd1205_SwTcbQ_t *Q);
+void zd1205_qlast_txq(struct zd1205_private *macp, zd1205_SwTcbQ_t *Q, zd1205_SwTcb_t *signal);
+static void zd1205_init_txq(struct zd1205_private *macp, zd1205_SwTcbQ_t *Q);
+
+#ifndef HOST_IF_USB
+
+static u8 zd1205_pci_setup(struct pci_dev *, struct zd1205_private *);
+static void zd1205_intr(int, void *, struct pt_regs *);
+static void zd1205_retry_failed(struct zd1205_private *);
+static void zd1205_dtim_notify(struct zd1205_private *);
+void zd1205_start_ru(struct zd1205_private *);
+u8 zd1205_RateAdaption(u16 aid, u8 CurrentRate, u8 gear);
+#else
+
+struct rx_list_elem *zd1205_start_ru(struct zd1205_private *);
+#endif
+
+u32 zd1205_rx_isr(struct zd1205_private *macp);
+void zd1205_tx_isr(struct zd1205_private *);
+static void zd1205_transmit_cleanup(struct zd1205_private *, zd1205_SwTcb_t *sw_tcb);
+static int zd1205_validate_frame(struct zd1205_private *macp, zd1205_RFD_t *rfd);
+int zd1205_xmit_frame(struct sk_buff *, struct net_device *);
+static void zd1205_dealloc_space(struct zd1205_private *macp);
+void zd1205_disable_int(void);
+void zd1205_enable_int(void);
+void zd1205_config_wep_keys(struct zd1205_private *macp);
+void HKeepingCB(struct net_device *dev);
+void zd1205_mgt_mon_cb(struct net_device *dev);
+void zd1205_process_wakeup(struct zd1205_private *macp);
+void zd1205_device_reset(struct zd1205_private *macp);
+int zd1205_DestPowerSave(struct zd1205_private *macp, u8 *pDestAddr);
+
+void zd1205_recycle_rx(struct zd1205_private *macp);
+
+//for 1211
+u8 CalculateStrength(struct zd1205_private *macp, zd1205_RFD_t *rfd);
+u8 CalculateQuality(struct zd1205_private *macp, zd1205_RFD_t *rfd, u8 *pQualityIndB);
+void zd1205_initCAM(struct zd1205_private *macp);
+int zd1205_CheckOverlapBss(struct zd1205_private *macp, plcp_wla_Header_t *pWlanHdr, u8 *pMacBody, u32 bodyLen);
+void zd1205_HandleQosRequest(struct zd1205_private *macp);
+void zd1205_SetRatesInfo(struct zd1205_private *macp);
+
+u8 X_To_dB(u32 X, u8 rate);
+u16 ZDLog10multiply100(int data);
+void zd1205_connect_mon(struct zd1205_private *macp);
+
+//wireless extension helper functions
+void zd1205_lock(struct zd1205_private *macp);
+void zd1205_unlock(struct zd1205_private *macp);
+static int zd1205_ioctl_setiwencode(struct net_device *dev, struct iw_point *erq, char* key);
+static int zd1205_ioctl_getiwencode(struct net_device *dev, struct iw_point *erq, char* key);
+static int zd1205_ioctl_setessid(struct net_device *dev, struct iw_point *erq);
+static int zd1205_ioctl_setbssid(struct net_device *dev, struct iwreq *wrq);
+
+static int zd1205_ioctl_getessid(struct net_device *dev, struct iw_point *erq);
+static int zd1205_ioctl_setfreq(struct net_device *dev, struct iw_freq *frq);
+//static int zd1205_ioctl_setsens(struct net_device *dev, struct iw_param *srq);
+static int zd1205_ioctl_setrts(struct net_device *dev, struct iw_param *rrq);
+static int zd1205_ioctl_setfrag(struct net_device *dev, struct iw_param *frq);
+
+static int zd1205_ioctl_getfrag(struct net_device *dev, struct iw_param *frq);
+static int zd1205_ioctl_setrate(struct net_device *dev, struct iw_param *frq);
+static int zd1205_ioctl_getrate(struct net_device *dev, struct iw_param *frq);
+//static int zd1205_ioctl_settxpower(struct net_device *dev, struct iw_param *prq);
+//static int zd1205_ioctl_gettxpower(struct net_device *dev, struct iw_param *prq);
+static int zd1205_ioctl_setpower(struct net_device *dev, struct iw_param *prq);
+static int zd1205_ioctl_getpower(struct net_device *dev, struct iw_param *prq);
+static int zd1205_ioctl_setmode(struct net_device *dev, __u32 *mode);
+
+/* Wireless Extension Handler functions */
+static int zd1205wext_giwfreq(struct net_device *dev, struct iw_request_info *info, struct iw_freq *freq, char *extra);
+static int zd1205wext_siwmode(struct net_device *dev, struct iw_request_info *info, __u32 *mode, char *extra);
+static int zd1205wext_giwmode(struct net_device *dev, struct iw_request_info *info, __u32 *mode, char *extra);
+static int zd1205wext_giwrate(struct net_device *dev, struct iw_request_info *info, struct iw_param *rrq, char *extra);
+static int zd1205wext_giwrts(struct net_device *dev, struct iw_request_info *info, struct iw_param *rts, char *extra);
+static int zd1205wext_giwfrag(struct net_device *dev, struct iw_request_info *info, struct iw_param *frag, char *extra);
+//static int zd1205wext_giwtxpow(struct net_device *dev, struct iw_request_info *info, struct iw_param *rrq, char *extra);
+//static int zd1205wext_siwtxpow(struct net_device *dev, struct iw_request_info *info, struct iw_param *rrq, char *extra);
+static int zd1205wext_giwrange(struct net_device *dev, struct iw_request_info *info, struct iw_point *data, char *extra);
+/* ath_desc: use new get_wireless_stats in 2.6.10+ */
+struct iw_statistics *zd1205wext_iw_get_stats(struct net_device *dev);
+
+
+
+#if WIRELESS_EXT > 13
+static int zd1205wext_siwscan(struct net_device *dev, struct iw_request_info *info, struct iw_point *data, char *extra);
+static int zd1205wext_giwscan(struct net_device *dev, struct iw_request_info *info, struct iw_point *data, char *extra);
+#endif
+
+/* functions to support 802.11 protocol stack */
+void zdcb_rx_ind(U8 *pData, U32 length, void *buf);
+void zdcb_release_buffer(void *buf);
+void zdcb_tx_completed(void);
+void zdcb_start_timer(U32 timeout, U32 event);
+void zdcb_stop_timer(U32 TimerId);
+void zd1205_set_zd_cbs(zd_80211Obj_t *pObj);
+void zdcb_set_reg(void *reg, U32 offset, U32 value);
+void chal_tout_cb(unsigned long ptr);
+U32 zdcb_dis_intr(void);
+void zdcb_set_intr_mask(U32 flags);
+BOOLEAN zdcb_check_tcb_avail(U8	num_of_frag);
+BOOLEAN zdcb_setup_next_send(fragInfo_t *frag_info);
+
+
+void zd_CmdScanReq(u16 channel);
+void zd_ScanBegin(void);
+void zd_ScanEnd(void);
+
+U16 zdcb_status_notify(U16 status, U8 *StaAddr);
+U32 zdcb_vir_to_phy_addr(U32 virtAddr);
+U32 zdcb_get_reg(void *reg, U32 offset);
+void zdcb_delay_us(U16 ustime);
+int zdcb_Rand(U32 seed);
+
+/* For WPA supported functions */
+void zd1205_notify_join_event(struct zd1205_private *macp);
+void zd1205_notify_disjoin_event(struct zd1205_private *macp);
+void zd1205_notify_scan_done(struct zd1205_private *macp);
+BOOLEAN zd_CmdProbeReq(U8 ProbeWithSsid);
+
+
+/******************************************************************************
+ 
+*						 P U B L I C   D A T A
+*******************************************************************************
+*/
+/* Global Data structures and variables */
+#ifndef HOST_IF_USB
+char zd1205_copyright[] __devinitdata = "Copyright (c) 2002 Zydas Corporation";
+char zd1205_driver_version[]="0.0.1";
+const char *zd1205_full_driver_name = "Zydas ZD1205 Network Driver";
+char zd1205_short_driver_name[] = "zd1205";
+#endif
+
+const char config_filename[] = "/etc/zd1211.conf";
+static BOOLEAN CustomMACSet = FALSE;
+static u8 CustomMAC[ETH_ALEN];
+static BOOLEAN AsocTimerStat = FALSE; //If the Asoc Timer is enabled
+
+zd1205_SwTcbQ_t free_txq_buf, active_txq_buf;
+struct net_device *g_dev;
+u8 *mTxOFDMType;
+zd_80211Obj_t dot11Obj = {0};
+/* ath_desc: fix for unaligned writes to skbs on bigendian platform */
+/* ath_old: #define RX_COPY_BREAK       0//1518 //we do bridge, don't care IP header alignment */
+#define RX_COPY_BREAK       MAX_WLAN_SIZE
+#define BEFORE_BEACON       25
+/* Definition of Wireless Extension */
+
+/*
+ * Structures to export the Wireless Handlers
+ 
+ */
+typedef enum
+{
+        ZD_REGION_Default   = 0x00,//All channel
+        ZD_REGION_USA    = 0x10,//G channel->ch1-11;
+        ZD_REGION_Canada   = 0x20,//G channel->ch1-11;
+        ZD_REGION_Argentina         = 0x21,//G channel->ch1-11;
+        ZD_REGION_Brazil            = 0x22,//G channel->ch1-11;
+        ZD_REGION_Europe         = 0x30,//G channel->ETSI ch1-13;
+        ZD_REGION_Spain    = 0x31,//G channel->ETSI ch1-13;
+        ZD_REGION_France   = 0x32,//G channel->ch10-13;
+        ZD_REGION_Ukraine           = 0x33,//G channel->ch1-11;
+        ZD_REGION_AustriaBelgium    = 0x34,//Austria and Belgium G channel->ch1-13;;
+        ZD_REGION_Switzerland       = 0x35,//G channel->ch1-13;
+        ZD_REGION_Japan    = 0x40,//G channel->ch1-14;
+        ZD_REGION_Australia         = 0x42,//G channel->ch1-13;
+        ZD_REGION_China             = 0x43,//G channel->ch1-11;
+        ZD_REGION_HongKong          = 0x44,//G channel->ch1-11;
+        ZD_REGION_Korea             = 0x45,//G channel->ch1-11;
+        ZD_REGION_NewZealand        = 0x46,//G channel->ch1-11;
+        ZD_REGION_Singapore         = 0x47,//G channel->ch10-13;
+        ZD_REGION_Taiwan            = 0x48,//G channel->ch1-13;
+        ZD_REGION_Israel   = 0x50,//G channel->ch3-9;
+        ZD_REGION_Mexico   = 0x51 //G channel->ch10,11;
+} ZD_REGION;
+
+
+struct iw_priv_args zd1205_private_args[] =
+        {
+                {
+                        SIOCIWFIRSTPRIV + 0x0, 0, 0, "list_bss"
+                },
+                { SIOCIWFIRSTPRIV + 0x1, 0, 0, "card_reset" },
+                { SIOCIWFIRSTPRIV + 0x2, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_auth" },  /* 0 - open, 1 - shared key */
+                { SIOCIWFIRSTPRIV + 0x3, 0, IW_PRIV_TYPE_CHAR | 12, "get_auth" },
+                { SIOCIWFIRSTPRIV + 0x4, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_preamble" },  /* 0 - long, 1 - short */
+                { SIOCIWFIRSTPRIV + 0x5, 0, IW_PRIV_TYPE_CHAR | 6, "get_preamble" },
+                { SIOCIWFIRSTPRIV + 0x6, 0, 0, "cnt" },
+                { SIOCIWFIRSTPRIV + 0x7, 0, 0, "regs" },
+                { SIOCIWFIRSTPRIV + 0x8, 0, 0, "probe" },
+                /* ath_desc: reenable iwpriv dbg_flag */
+                { SIOCIWFIRSTPRIV + 0x10, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "dbg_flag" },
+                { SIOCIWFIRSTPRIV + 0xA, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "connect" },
+                { SIOCIWFIRSTPRIV + 0xB, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_mac_mode" },
+                { SIOCIWFIRSTPRIV + 0xC, 0, IW_PRIV_TYPE_CHAR | 12, "get_mac_mode" },
+                { SIOCIWFIRSTPRIV + 0xD, 0, 0, "save_conf" /* has been removed */ },
+                { SIOCIWFIRSTPRIV + 0xE, 0, 0, "load_conf" /* has been removed */ },
+                { SIOCIWFIRSTPRIV + 0xF, 0, IW_PRIV_TYPE_CHAR | 14, "get_Region" },
+                { SIOCIWFIRSTPRIV + 0x9,IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_Region" },
+        };
+
+
+#if WIRELESS_EXT > 12
+static iw_handler zd1205wext_handler[] = {
+                        (iw_handler) NULL,                              /* SIOCSIWCOMMIT */
+
+                        (iw_handler) NULL,                              /* SIOCGIWNAME */
+                        (iw_handler) NULL,                              /* SIOCSIWNWID */
+                        (iw_handler) NULL,                              /* SIOCGIWNWID */
+                        (iw_handler) NULL,                              /* SIOCSIWFREQ */
+                        (iw_handler) zd1205wext_giwfreq,                /* SIOCGIWFREQ */
+
+
+                        (iw_handler) NULL,                              /* SIOCSIWMODE */
+                        (iw_handler) zd1205wext_giwmode,                /* SIOCGIWMODE */
+
+                        (iw_handler) NULL,                              /* SIOCSIWSENS */
+                        (iw_handler) NULL,                              /* SIOCGIWSENS */
+                        (iw_handler) NULL, /* not used */               /* SIOCSIWRANGE */
+                        (iw_handler) zd1205wext_giwrange,               /* SIOCGIWRANGE */
+                        (iw_handler) NULL, /* not used */               /* SIOCSIWPRIV */
+                        (iw_handler) NULL, /* kernel code */            /* SIOCGIWPRIV */
+                        (iw_handler) NULL, /* not used */               /* SIOCSIWSTATS */
+                        (iw_handler) NULL, /* kernel code */            /* SIOCGIWSTATS */
+
+                        (iw_handler) NULL,                              /* SIOCSIWSPY */
+                        (iw_handler) NULL,                              /* SIOCGIWSPY */
+                        (iw_handler) NULL,                              /* -- hole -- */
+                        (iw_handler) NULL,                              /* -- hole -- */
+                        (iw_handler) NULL,                              /* SIOCSIWAP */
+                        (iw_handler) NULL,                              /* SIOCGIWAP */
+                        (iw_handler) NULL,				                /* -- hole -- */
+                        (iw_handler) NULL,                              /* SIOCGIWAPLIST */
+#if WIRELESS_EXT > 13
+                        (iw_handler) zd1205wext_siwscan,                /* SIOCSIWSCAN */
+                        (iw_handler) zd1205wext_giwscan,                /* SIOCGIWSCAN */
+#else /* WIRELESS_EXT > 13 */
+                        (iw_handler) NULL,      /* null */              /* SIOCSIWSCAN */
+                        (iw_handler) NULL,      /* null */              /* SIOCGIWSCAN */
+#endif /* WIRELESS_EXT > 13 */
+                        (iw_handler) NULL,                              /* SIOCSIWESSID */
+                        (iw_handler) NULL,                              /* SIOCGIWESSID */
+                        (iw_handler) NULL,                              /* SIOCSIWNICKN */
+                        (iw_handler) NULL,                              /* SIOCGIWNICKN */
+                        (iw_handler) NULL,                              /* -- hole -- */
+                        (iw_handler) NULL,                              /* -- hole -- */
+                        (iw_handler) NULL,                              /* SIOCSIWRATE */
+                        (iw_handler) zd1205wext_giwrate,                /* SIOCGIWRATE */
+                        (iw_handler) NULL,                              /* SIOCSIWRTS */
+
+                        (iw_handler) zd1205wext_giwrts,                 /* SIOCGIWRTS */
+                        (iw_handler) NULL,                              /* SIOCSIWFRAG */
+                        (iw_handler) zd1205wext_giwfrag,                /* SIOCGIWFRAG */
+                        (iw_handler) NULL,                              /* SIOCSIWTXPOW */
+                        (iw_handler) NULL,                              /* SIOCGIWTXPOW */
+                        (iw_handler) NULL,                              /* SIOCSIWRETRY */
+                        (iw_handler) NULL,                              /* SIOCGIWRETRY */
+                        (iw_handler) NULL,                              /* SIOCSIWENCODE */
+                        (iw_handler) NULL,                              /* SIOCGIWENCODE */
+                        (iw_handler) NULL,                              /* SIOCSIWPOWER */
+                        (iw_handler) NULL,                              /* SIOCGIWPOWER */
+                };
+
+static const iw_handler		zd1205_private_handler[] =
+        {
+                NULL,				/* SIOCIWFIRSTPRIV */
+        };
+
+
+struct iw_handler_def p80211wext_handler_def =
+        {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10)
+		.get_wireless_stats = &zd1205wext_iw_get_stats,
+#endif
+        num_standard:
+                sizeof(zd1205wext_handler) / sizeof(iw_handler),
+        num_private:
+                sizeof(zd1205_private_handler)/sizeof(iw_handler),
+
+        num_private_args:
+                sizeof(zd1205_private_args)/sizeof(struct iw_priv_args),
+        standard: zd1205wext_handler,
+        private: (iw_handler *) zd1205_private_handler,
+        private_args: (struct iw_priv_args *) zd1205_private_args
+        };
+#endif
+
+#if 0//(LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+#define do_div(n,base) ({ \
+	unsigned long __upper, __low, __high, __mod; \
+	asm("":"=a" (__low), "=d" (__high):"A" (n)); \
+	__upper = __high; \
+	if (__high) { \
+		__upper = __high % (base); \
+		__high = __high / (base); \
+	} \
+	asm("divl %2":"=a" (__low), "=d" (__mod):"rm" (base), "0" (__low), "1" (__upper)); \
+	asm("":"=A" (n):"a" (__low),"d" (__high)); \
+	__mod; \
+})
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,6))
+static void wait_ms(unsigned int ms)
+{
+        if(!in_interrupt()) {
+                current->state = TASK_UNINTERRUPTIBLE;
+                schedule_timeout(1 + ms * HZ / 1000);
+        } else
+                mdelay(ms);
+}
+#endif
+const U16 dot11A_Channel[]=
+        {
+                36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,184,188,192,196,8,12,16,34,38,42,46,149,153,157,161,165
+        };
+const U16 dot11A_Channel_Amount=sizeof(dot11A_Channel)/sizeof(U16);
+
+
+
+
+#if defined(OFDM)
+u8 OfdmRateTbl[12] = {
+                             0x00,  //1M
+                             0x01,  //2M
+                             0x02,  //5.5M
+                             0x03,  //11M
+                             0x1b,  //6M
+                             0x1f,  //9M
+                             0x1a,  //12M
+                             0x1e,  //18M
+                             0x19,  //24M
+                             0x1d,  //36M
+                             0x18,  //48M
+                             0x1c   //54M
+                     };
+//Rate > 6M, the bit Long/Short preamble is 1 for 802.11a
+//While it's 0 for 802.11g
+u8 OfdmRateTbl_11A[12]= {
+                                0x00,  //Useless
+                                0x01,  //Useless
+                                0x02,  //Useless
+                                0x03,  //Useless
+                                0x3b,  //6M
+                                0x3f,  //9M
+                                0x3a,  //12M
+                                0x3e,  //18M
+                                0x39,  //24M
+                                0x3d,  //36M
+                                0x38,  //48M
+                                0x3c   //54M
+
+                        };
+#endif
+//The Order is meaningful, Do not Change
+static	u8 a_ChannelMap[] = {
+                                   184,196,16,
+                                   36,36,
+                                   40,48,
+                                   52,64,
+                                   100,112,
+                                   128,140,
+                                   149,165};
+
+typedef struct _a_InterpolationStruc
+{
+        u8	a_Channel;
+        u8	Left_Most_Channel;
+        u8	Right_Most_Channel;
+        u8	TotalDivisionNum;
+        u8	Position;	// starting from left.
+}
+a_InterpolationStruc;
+
+static	a_InterpolationStruc a_InterpolationTbl[] = {
+                        //a_Channel,  Left_Most_Channel, Right_Most_Channel,TotalDivisionNum,Position
+                        {188,            184,                196,                 3,                  1},
+                        {192,            184,                196,                 3,                  2},
+                        {  8,             16,                 16,                 3,                  3},
+                        { 12,             16,                 16,                 3,                  3},
+                        { 34,             36,                 36,                 3,                  3},
+                        { 38,             36,                 36,                 3,                  3},
+                        { 42,             40,                 48,                 4,                  1},
+                        { 44,             40,                 48,                 4,                  2},
+                        { 46,             40,                 48,                 4,                  3},
+                        { 56,             52,                 64,                 3,                  1},
+                        { 60,             52,                 64,                 3,                  2},
+                        {104,            100,                112,                 3,                  1},
+                        {108,            100,                112,                 3,                  2},
+                        {116,            112,                128,                 4,                  1},
+                        {120,            112,                128,                 4,                  2},
+                        {124,            112,                128,                 4,                  3},
+                        {132,            128,                140,                 3,                  1},
+                        {136,            128,                140,                 3,                  2},
+                        {153,            149,                165,                 4,                  1},
+                        {157,            149,                165,                 4,                  2},
+                        {161,            149,                165,                 4,                  3}
+
+                };
+#define	a_CALIBRATED_CH_NUM		sizeof(a_ChannelMap)
+#define	a_INTERPOLATION_CH_NUM	(sizeof(a_InterpolationTbl) / sizeof(a_InterpolationStruc))
+#define a_MAX_CALIBRATION_CH_NUM 16
+#define a_MAX_INTERPOLATION_CH_NUM 32
+#define cPWR_INT_VALUE_GUARD 8
+u8      a_Calibration_Data[4][a_MAX_CALIBRATION_CH_NUM];
+u8      a_Interpolation_Data[4][a_MAX_INTERPOLATION_CH_NUM];
+//	[0][]:CH,
+//	[1][]:Integration Value
+//	[2][]:SetPoint_36M
+//	[3][]:SetPoint_48M_54M
+
+
+//Find the array index of certain Channel
+u8 a_get_cal_int_val( u8 index)
+{
+        u32	tmpvalue;
+
+        if (index < a_CALIBRATED_CH_NUM) {
+                tmpvalue=zd_readl(ZD_E2P_11A_INT_VALUE1+((index>>2)<<2));
+                return ((u8)(tmpvalue >> (index%4*8)));
+        } else {
+                printk("Error in a_get_cal_int_val\n");
+                return FALSE;
+        }
+}
+
+u8	a_get_cal_36M_setpoint_val( u8 index)
+{
+        u32	tmpvalue;
+
+        if (index < 16) {
+                tmpvalue=zd_readl(ZD_E2P_A36M_CAL_VALUE+((index>>2)<<2));
+                return ((u8)(tmpvalue >> (index%4*8)));
+        } else {
+                printk("Error in a_get_cal_36M_setpoint_val\n");
+                return FALSE;
+        }
+}
+
+u8 a_get_cal_48M_54M_setpoint_val( u8 index)
+{
+        u32 tmpvalue;
+
+        if (index < a_CALIBRATED_CH_NUM ) {
+                tmpvalue=zd_readl(ZD_E2P_A54M_CAL_VALUE+((index>>2)<<2));
+                return ((u8)(tmpvalue >> (index%4*8)));
+        } else {
+                printk("Error in a_get_cal_54M_setpoint_val\n");
+                return FALSE;
+        }
+}
+u8 a_find_index_in_a_Calibration_Data( u8 ch)
+{
+        u8 i;
+        for (i=0;i<a_CALIBRATED_CH_NUM;i++) {
+                if (ch == a_Calibration_Data[0][i]) {
+                        return i;
+                }
+        }
+        return (u8)0xff;
+}
+u8 a_find_index_in_a_Interpolation_Data( u8 ch)
+{
+        u8 i;
+        for (i=0;i<a_INTERPOLATION_CH_NUM;i++) {
+                if (ch == a_Interpolation_Data[0][i]) {
+                        return i;
+                }
+        }
+        return (u8)0xff;
+}
+
+BOOLEAN a_get_interpolation_value(
+        u8 index,
+        u8 *pIntVal,
+        u8 *pSetPoint_36M,
+        u8 *pSetPoint_48M_54M)
+{
+        u8 lm_index; //Left Most Index
+        u8 rm_index; //Right Most Index
+        // Find Left-Most CH in a_ChannelMap
+        lm_index = a_find_index_in_a_Calibration_Data( a_InterpolationTbl[index].Left_Most_Channel);
+        if (lm_index == 0xff) {
+                printk("Get lm_index error in a_get_inter..\n");
+                return FALSE;
+        }
+        // Find Right-Most CH in a_ChannelMap
+        rm_index = a_find_index_in_a_Calibration_Data( a_InterpolationTbl[index].Right_Most_Channel);
+        if (rm_index == 0xff) {
+                printk("Get rm_index error in a_get_inter..\n");
+                return FALSE;
+        }
+
+        *pIntVal = (u8)(a_Calibration_Data[1][lm_index] +
+                        (u32)ABS(a_Calibration_Data[1][rm_index],a_Calibration_Data[1][lm_index])*
+                        a_InterpolationTbl[index].Position / a_InterpolationTbl[index].TotalDivisionNum);
+
+        *pSetPoint_36M = (u8)(a_Calibration_Data[2][lm_index] +
+                              (u32)ABS(a_Calibration_Data[2][rm_index],a_Calibration_Data[2][lm_index])*
+                              a_InterpolationTbl[index].Position / a_InterpolationTbl[index].TotalDivisionNum);
+        *pSetPoint_48M_54M = (u8)(a_Calibration_Data[3][lm_index] +
+                                  (u32)ABS(a_Calibration_Data[3][rm_index],a_Calibration_Data[3][lm_index])*
+                                  a_InterpolationTbl[index].Position / a_InterpolationTbl[index].TotalDivisionNum);
+
+        return TRUE;
+}
+//Channel A, One Stop Call to get cal & int
+u8 a_OSC_get_cal_int( u8 ch, u32 rate, u8 *intValue, u8 *calValue)
+{
+
+        u8 idx;
+        idx = a_find_index_in_a_Calibration_Data(ch);
+        if(0xff == idx) {//Error code, we can't found the channel in calibration data
+                idx = a_find_index_in_a_Interpolation_Data(ch);
+                if(0xff != idx) {
+                        *intValue = a_Interpolation_Data[1][idx];
+                        if(rate <= RATE_36M)
+                                *calValue = a_Interpolation_Data[2][idx];
+                        else  //rate >=48
+                                *calValue = a_Interpolation_Data[3][idx];
+                } else
+                        return 0xff;
+        } else {//Channel is in Calibration Data
+                *intValue = a_Calibration_Data[1][idx];
+                if(rate <= RATE_36M)
+                        *calValue = a_Calibration_Data[2][idx];
+                else  //rate >=48
+                        *calValue = a_Calibration_Data[3][idx];
+        }
+
+        return 0;
+
+}
+
+
+/* ath: gcc4 needs inline function bodies in the declaration */
+inline void zd_writel(u32 value, u32 offset)
+{
+	struct zd1205_private *macp = g_dev->priv;
+	void *regp = macp->regp;
+	u32 RegWait = 0;
+
+#ifdef HOST_IF_USB
+#if fPROG_FLASH
+
+	if (!macp->bAllowAccessRegister)
+		return;
+
+#endif
+
+	zd1211_writel(offset, value, true);
+
+
+	return;
+#endif
+
+
+	atomic_inc(&macp->DoNotSleep);
+	if (dot11Obj.bDeviceInSleep) {
+		while((readl(regp+ZD_MAC_PS_STATE) & 0x7) != MAC_OPERATION) {
+			udelay(1000);
+			RegWait++;
+			if ((RegWait > REG_MAX_WAIT) || macp->bSurpriseRemoved) {
+				dot11Obj.bDeviceInSleep = 0;
+				ZD1211DEBUG(0, "zd_writel Sleep to die!!!");
+				break;
+			}
+
+		}
+	}
+
+	writel(value, regp+offset);
+	atomic_dec(&macp->DoNotSleep);
+}
+
+
+inline u32 zd_readl(u32 offset)
+{
+	struct zd1205_private *macp = g_dev->priv;
+	void *regp = macp->regp;
+	u32	value;
+	u32	RegWait = 0;
+
+#ifdef HOST_IF_USB
+#if fPROG_FLASH
+
+	if (!macp->bAllowAccessRegister)
+
+		return 0xffffffff;
+#endif
+
+	value = zd1211_readl(offset, true);
+	return value;
+#endif
+
+	atomic_inc(&macp->DoNotSleep);
+	if (dot11Obj.bDeviceInSleep) {
+		while((readl(regp+ZD_MAC_PS_STATE) & 0x7) != MAC_OPERATION) {
+			udelay(1000);
+			RegWait++;
+			if ((RegWait > REG_MAX_WAIT) || macp->bSurpriseRemoved) {
+
+				dot11Obj.bDeviceInSleep = 0;
+				ZD1211DEBUG(0, "zd_readl Sleep to die!!!");
+				break;
+			}
+		}
+	}
+
+	value = readl(regp+offset);
+	atomic_dec(&macp->DoNotSleep);
+
+	return value;
+}
+
+
+#ifdef HOST_IF_USB
+#define fDISABLE_LED            0
+void iLED_ON(struct zd1205_private *macp, u32 LEDn)
+{
+#if !fDISABLE_LED
+
+        u32   tmpvalue;
+
+        tmpvalue = zd_readl(rLED_CTRL);
+        tmpvalue |= LEDn;
+        zd_writel(tmpvalue, rLED_CTRL);
+
+#ifdef ROBIN_KAO
+
+        tmpvalue = zd_readl(FW_LINK_STATUS);
+        tmpvalue |= 0x1;
+        zd_writel(tmpvalue, FW_LINK_STATUS);
+#endif
+
+#endif
+}
+
+
+void iLED_OFF(struct zd1205_private *macp, u32 LEDn)
+{
+#if !fDISABLE_LED
+
+        u32   tmpvalue;
+
+
+        tmpvalue = zd_readl(rLED_CTRL);
+        tmpvalue &= ~LEDn;
+        zd_writel(tmpvalue, rLED_CTRL);
+
+
+#ifdef ROBIN_KAO
+
+        zd_writel(0x0, FW_LINK_STATUS);
+#endif
+
+#endif
+}
+
+
+void iLED_SWITCH(struct zd1205_private *macp, u32 LEDn)
+{
+#if !fDISABLE_LED
+        u32   tmpvalue;
+
+        tmpvalue = zd_readl(rLED_CTRL);
+        tmpvalue ^= LEDn;
+        zd_writel(tmpvalue, rLED_CTRL);
+#endif
+}
+
+#else
+void iLED_ON(struct zd1205_private	*macp, u32 LEDn)
+{
+        zd_writel(0x1, LEDn);
+}
+
+
+
+
+
+void iLED_OFF(struct zd1205_private *macp, u32 LEDn)
+{
+        zd_writel(0x0, LEDn);
+}
+
+
+void iLED_SWITCH(struct zd1205_private	*macp, u32 LEDn)
+{
+        u32   tmpvalue;
+
+        tmpvalue = zd_readl(LEDn);
+        tmpvalue ^= 0x1;
+        zd_writel(tmpvalue, LEDn);
+
+}
+#endif
+
+
+void zd1205_disable_int(void)
+{
+
+        /* Disable interrupts on our PCI board by setting the mask bit */
+        zd_writel(0, InterruptCtrl);
+}
+
+
+
+
+void zd1205_enable_int(void)
+{
+        struct zd1205_private *macp = g_dev->priv;
+
+        zd_writel(macp->intrMask, InterruptCtrl);
+}
+
+
+void zd1205_start_download(u32 phyAddr)
+{
+#ifdef HOST_IF_USB
+        return;
+#endif
+
+        if (!dot11Obj.bDeviceInSleep)
+                zd_writel(phyAddr, ZD_PCI_TxAddr_p1);
+}
+
+
+void zd1205_start_upload(u32 phyAddr)
+{
+#ifdef HOST_IF_USB
+
+        return;
+#endif
+
+
+        if (!dot11Obj.bDeviceInSleep) {
+                zd_writel(phyAddr, ZD_PCI_RxAddr_p1);
+
+
+                zd_writel(0, ZD_PCI_RxAddr_p2);
+
+        }
+}
+
+
+int zd1205_DestPowerSave(struct zd1205_private *macp, u8 *pDestAddr)
+
+{
+        u32	tmpvalue;
+
+        if ((macp->cardSetting.ATIMWindow != 0) && (macp->bAssoc))
+        {
+                // We must make sure that Device has been in IBSS mode and PwrMgt mode.
+                tmpvalue = zd_readl(ZD_BCNInterval);
+                if ((tmpvalue & IBSS_MODE) && (tmpvalue & POWER_MNT)) {
+
+
+                        // ATIM could be sent only when BCNController is active.
+                        if ((*(pDestAddr) & BIT_0) || (macp->bIBSS_Wakeup_Dest)) { // We should issue ATIM for multicast frame.
+                                macp->bIBSS_Wakeup_Dest = 0;
+                                return 1;
+                        }
+                }
+        }
+
+
+        return 0;
+}
+
+
+
+static void zd1205_action(unsigned long parm)
+{
+        zd_SigProcess();  //process management frame queue in mgtQ
+}
+
+
+static void zd1205_ps_action(unsigned long parm)
+{
+        zd_CleanupAwakeQ();
+}
+
+
+static void zd1205_tx_action(unsigned long parm)
+{
+        zd_CleanupTxQ();
+
+}
+
+#ifndef HOST_IF_USB
+u8 zd1205_RateAdaption(u16 aid, u8 CurrentRate, u8 gear)
+{
+
+        u8	NewRate;
+
+
+        RATEDEBUG("***** zd1205_RateAdaption");
+        RATEDEBUG_V("aid", aid);
+
+
+        RATEDEBUG_V("CurrentRate", CurrentRate);
+
+        if (gear == FALL_RATE) {
+
+
+                if (CurrentRate >= RATE_2M) {
+                        NewRate = CurrentRate - 1;
+                        zd_EventNotify(EVENT_UPDATE_TX_RATE, (U32)NewRate, (U32)aid, 0);
+                } else {
+                        NewRate = CurrentRate;
+                }
+                return (NewRate);
+        }
+
+        return 0;
+}
+#endif
+
+void zd1205_ClearTupleCache(struct zd1205_private *macp)
+{
+        int i;
+        tuple_Cache_t *pCache = &macp->cache;
+
+        pCache->freeTpi = 0;
+        for (i=0; i<TUPLE_CACHE_SIZE; i++)
+        {
+                pCache->cache[i].full = 0;
+        }
+}
+
+
+u8 zd1205_SearchTupleCache(struct zd1205_private *macp, u8 *pAddr, u16 seq, u8 frag)
+{
+        int k;
+        tuple_Cache_t *pCache = &macp->cache;
+
+        for (k=0; k<TUPLE_CACHE_SIZE; k++)
+        {
+                if ((memcmp((char *)&pCache->cache[k].ta[0], (char *)pAddr, 6) == 0)
+                                && (pCache->cache[k].sn == seq) && (pCache->cache[k].fn == frag)
+                                && (pCache->cache[k].full))
+                        return 1;
+        }
+
+        return 0;
+}
+
+
+void zd1205_UpdateTupleCache(struct zd1205_private *macp, u8 *pAddr, u16 seq ,u8 frag)
+{
+        int k;
+        tuple_Cache_t *pCache = &macp->cache;
+
+        for (k=0; k<TUPLE_CACHE_SIZE; k++)
+        {
+                if (pCache->cache[k].full) {
+                        if ((memcmp((char *)&pCache->cache[k].ta[0], (char *)pAddr, 6) == 0)
+                                        && (pCache->cache[k].sn == seq) ) {
+                                pCache->cache[k].fn = frag;
+
+                                return;
+                        }
+                }
+        }
+
+        pCache->freeTpi &= (TUPLE_CACHE_SIZE-1);
+        memcpy(&pCache->cache[pCache->freeTpi].ta[0], (char *)pAddr, 6);
+        pCache->cache[pCache->freeTpi].sn = seq;
+        pCache->cache[pCache->freeTpi].fn = frag;
+        pCache->cache[pCache->freeTpi].full = 1;
+
+        pCache->freeTpi++;
+
+}
+
+
+void zd1205_ArReset(struct zd1205_private *macp)
+{
+        u8 i;
+        defrag_Array_t *pArray = &macp->defragArray;
+
+        for (i=0; i<MAX_DEFRAG_NUM; i++)
+                pArray->mpdu[i].inUse = 0;
+}
+
+
+void zd1205_ArAge(struct zd1205_private *macp, u32 age)
+{
+        u8 i;
+        defrag_Array_t *pArray = &macp->defragArray;
+
+        for (i=0; i<MAX_DEFRAG_NUM; i++)
+        {
+                if (pArray->mpdu[i].inUse) {
+                        if ((age - pArray->mpdu[i].eol) > MAX_RX_TIMEOUT) {
+                                DFDEBUG("***** zd1205_ArAged");
+                                macp->ArAgedCnt++;
+
+
+
+
+                                dot11Obj.ReleaseBuffer(pArray->mpdu[i].buf);
+                                pArray->mpdu[i].inUse = 0;
+                        }
+                }
+        }
+}
+
+
+
+
+int	zd1205_ArFree(struct zd1205_private *macp)
+{
+        u8 i;
+        defrag_Array_t *pArray = &macp->defragArray;
+
+        for (i=0; i<MAX_DEFRAG_NUM; i++)
+        {
+                if (!pArray->mpdu[i].inUse)
+
+                        return i;
+        }
+
+        macp->ArFreeFailCnt++;
+        return -1;
+}
+
+
+int	zd1205_ArSearch(struct zd1205_private *macp, u8 *pAddr, u16 seq, u8 frag)
+{
+        u8 i;
+        defrag_Array_t *pArray = &macp->defragArray;
+        defrag_Mpdu_t *pDeMpdu;
+
+
+        for (i=0; i<MAX_DEFRAG_NUM; i++)
+        {
+                pDeMpdu = &pArray->mpdu[i];
+                if (pDeMpdu->inUse) {
+                        if ((memcmp((char *)&pDeMpdu->ta[0], pAddr, 6) == 0)
+                                        && (pDeMpdu->sn == seq)) {
+                                if (pDeMpdu->fn == (frag-1)) {
+                                        return i;
+                                } else {
+                                        dot11Obj.ReleaseBuffer(pDeMpdu->buf);
+                                        pDeMpdu->inUse = 0;
+                                        return -1;
+                                }
+                        }
+                }
+        }
+
+        return -1;
+}
+
+
+
+void zd1205_ArUpdate(struct zd1205_private *macp, u8 *pAddr, u16 seq, u8 frag, int i)
+{
+
+        defrag_Array_t *pArray = &macp->defragArray;
+
+
+        pArray->mpdu[i].inUse = 1;
+        memcpy(&pArray->mpdu[i].ta[0], (char*)pAddr, 6);
+        pArray->mpdu[i].sn = seq;
+        pArray->mpdu[i].fn = frag;
+        pArray->mpdu[i].eol = nowT();
+}
+
+
+void zd1205_IncreaseTxPower(struct zd1205_private *macp, u8 TxPwrType)
+{
+        u8   *pTxGain;
+
+#if fTX_GAIN_OFDM
+
+        if (TxPwrType != cTX_OFDM)
+                pTxGain = &(dot11Obj.TxGainSetting);
+
+        else
+                pTxGain = &(dot11Obj.TxGainSetting2);
+#else
+
+        pTxGain = &(dot11Obj.TxGainSetting);
+#endif
+
+        switch(macp->RF_Mode)
+        {
+        case MAXIM_NEW_RF:
+                if (*pTxGain < MAXIM2_MAX_TX_PWR_SET)
+
+                        (*pTxGain)++;
+                break;
+
+        case RFMD_RF:
+                if (*pTxGain < RFMD_MAX_TX_PWR_SET)
+                        (*pTxGain) ++;
+                break;
+
+        case AL2230_RF:
+        case AL7230B_RF:
+                if (*pTxGain < AL2230_MAX_TX_PWR_SET)
+                        (*pTxGain) += 2;
+                break;
+
+        default:
+                break;
+        }
+
+        HW_Write_TxGain2(&dot11Obj, TxPwrType);
+}
+
+
+void zd1205_DecreaseTxPower(struct zd1205_private *macp, u8 TxPwrType)
+{
+        u8   *pTxGain;
+
+#if fTX_GAIN_OFDM
+
+        if (TxPwrType != cTX_OFDM)
+                pTxGain = &(dot11Obj.TxGainSetting);
+        else
+                pTxGain = &(dot11Obj.TxGainSetting2);
+#else
+
+        pTxGain = &(dot11Obj.TxGainSetting);
+
+#endif
+
+
+        switch(macp->RF_Mode)
+        {
+        case MAXIM_NEW_RF:
+                if (*pTxGain > MAXIM2_MIN_TX_PWR_SET)
+
+                        (*pTxGain)--;
+                break;
+
+        case RFMD_RF:
+                if (*pTxGain > RFMD_MIN_TX_PWR_SET)
+
+                        (*pTxGain) --;
+
+                break;
+
+        case AL2230_RF:
+        case AL7230B_RF:
+                if (*pTxGain > AL2230_MIN_TX_PWR_SET)
+                        (*pTxGain) -= 2;
+                break;
+
+        default:
+                break;
+        }
+
+        HW_Write_TxGain2(&dot11Obj, TxPwrType);
+
+}
+
+
+
+int
+zd1205_AnyActivity(struct zd1205_private *macp)
+{
+        unsigned long flags;
+
+        // Any frame wait for transmission.
+        spin_lock_irqsave(&macp->q_lock, flags);
+        if (macp->activeTxQ->count)
+        {
+                spin_unlock_irqrestore(&macp->q_lock, flags);
+
+
+
+                return 1;
+        }
+        spin_unlock_irqrestore(&macp->q_lock, flags);
+
+
+        if ((dot11Obj.QueueFlag & MGT_QUEUE_SET) || (dot11Obj.QueueFlag & TX_QUEUE_SET))
+                return 1;
+
+        if (macp->bAnyActivity)
+                return 1;
+
+        // No any activity.
+        return 0;
+}
+
+
+void zd1205_connect_mon(struct zd1205_private *macp)
+{
+        static u16 IdleLoop_Under_Seq1 = 0;
+
+        zd_ConnectMon();
+        //    if (dot11Obj.bDeviceInSleep)
+        // 	printk(KERN_ERR "mon\n");
+        if ((macp->cardSetting.BssType == INFRASTRUCTURE_BSS) && (macp->bPSMSupported))
+        {
+                if ((!dot11Obj.bChScanning) && (macp->PwrState) && (!dot11Obj.bDeviceInSleep) && (macp->bAssoc)) {
+                        // Solve Sequence number duplication problem after wakeup.
+                        if (!zd1205_AnyActivity(macp)) {
+                                if ((macp->SequenceNum != 1) || (IdleLoop_Under_Seq1 > 20)) {
+                                        //zd1205_sleep_reset(macp);
+                                        IdleLoop_Under_Seq1 = 0;
+                                        // Avoid accessing Registers to save computation power.
+                                } else {
+                                        IdleLoop_Under_Seq1++;
+                                }
+                                //ZD1211DEBUG(2, "IdleLoop_Under_Seq1= %d\n", IdleLoop_Under_Seq1);
+                        }
+                }
+        }
+
+
+}
+
+
+void zd1205_mgt_mon_cb(struct net_device *dev)
+{
+        struct zd1205_private *macp = dev->priv;
+
+
+#ifdef HOST_IF_USB
+
+        defer_kevent(macp, KEVENT_MGT_MON_TIMEOUT);
+        mod_timer(&(macp->tm_mgt_id), jiffies+ (1*HZ)/50); //20ms
+
+
+#else
+
+        zd1205_connect_mon(macp);
+        mod_timer(&(macp->tm_mgt_id), jiffies+ (1*HZ)/50); //20ms
+#endif
+
+}
+
+
+void zd1205_SwAntennaDiv(struct zd1205_private *macp)
+{
+#if fANT_DIVERSITY
+        static u32 loop = 0;
+        loop++;
+
+        // Software Antenna Diversity Mechanism
+        if (macp->bEnableSwAntennaDiv)
+        {
+                switch(AccState) {
+                case ACC_1:
+                        if ((loop % macp->Ant_MonitorDur1) == 0) {
+                                if (macp->Acc_Num_OFDM)
+                                        Avg1_SQ_OFDM = macp->Acc_SQ_OFDM / macp->Acc_Num_OFDM;
+                                else {
+                                        Avg1_SQ_OFDM = 0;
+
+                                        if (macp->Acc_Num)
+                                                Avg1_SQ = macp->Acc_SQ / macp->Acc_Num;
+                                        else
+                                                Avg1_SQ = 0;
+                                }
+
+                                // Higher SQ is better
+                                if (((Avg1_SQ_OFDM < macp->NiceSQThr_OFDM) && (Avg1_SQ_OFDM > 0))
+                                                || ((Avg1_SQ_OFDM == 0)
+                                                    && ((Avg1_SQ < macp->NiceSQThr) && (Avg1_SQ > 0)))
+                                                || (!macp->bAssoc)) { // disconnected
+                                        SwitchAntenna(macp);
+                                        AccState = ACC_2;
+                                }
+
+                                macp->Acc_SQ = 0;
+
+
+                                macp->Acc_Num = 0;
+
+                                macp->Acc_SQ_OFDM = 0;
+                                macp->Acc_Num_OFDM = 0;
+                        }
+                        break;
+
+                case ACC_2:
+                        if ((loop % macp->Ant_MonitorDur2) == 0)
+                        {
+                                if (macp->Acc_Num_OFDM)
+                                        Avg2_SQ_OFDM = macp->Acc_SQ_OFDM / macp->Acc_Num_OFDM;
+                                else {
+                                        Avg2_SQ_OFDM = 0;
+                                        if (macp->Acc_Num)
+                                                Avg2_SQ = macp->Acc_SQ / macp->Acc_Num;
+                                        else
+                                                Avg2_SQ = 0;
+                                }
+
+                                // Higher SQ is better
+                                if ((Avg2_SQ_OFDM < Avg1_SQ_OFDM)
+
+
+                                                || (((Avg2_SQ_OFDM == 0) && (Avg1_SQ_OFDM == 0))
+                                                    && (Avg2_SQ < Avg1_SQ))
+                                                || (!macp->bAssoc)) { // disconnected
+                                        SwitchAntenna(macp);
+
+
+                                }
+
+                                AccState = ACC_1;
+                                macp->Acc_SQ = 0;
+                                macp->Acc_Num = 0;
+                                macp->Acc_SQ_OFDM = 0;
+                                macp->Acc_Num_OFDM = 0;
+                        }
+
+                        break;
+
+                default:
+                        break;
+                }
+        }
+#endif
+}
+
+
+void zd1205_CollectHwTally(struct zd1205_private *macp)
+{
+        macp->hwTotalRxFrm += zd_readl(TotalRxFrm);
+        macp->hwCRC32Cnt += zd_readl(CRC32Cnt);
+
+        macp->hwCRC16Cnt += zd_readl(CRC16Cnt);
+        //macp->hwDecrypErr_UNI += zd_readl(DecrypErr_UNI);
+        //macp->hwDecrypErr_Mul += zd_readl(DecrypErr_Mul);
+        macp->hwRxFIFOOverrun += zd_readl(RxFIFOOverrun);
+        macp->hwTotalTxFrm += zd_readl(TotalTxFrm);
+
+
+        macp->hwUnderrunCnt += zd_readl(UnderrunCnt);
+        macp->hwRetryCnt += zd_readl(RetryCnt);
+}
+
+
+#define	TOLERANCE		2
+
+int zd1205_IbssPsCheck(struct zd1205_private *macp)
+{
+        u32 ul_BcnItvl, ul_atimwnd;
+        u64 TSFTimer;
+        u32 tmpvalue;
+
+
+        // Make sure that we have passed (ATIM-Window+TOLERANCE)
+        ul_BcnItvl = zd_readl(ZD_BCNInterval);
+        ul_BcnItvl &= 0xffff;
+
+        ul_atimwnd = zd_readl(ZD_ATIMWndPeriod);
+        tmpvalue = zd_readl(ZD_TSF_LowPart);
+        TSFTimer = tmpvalue;
+
+        tmpvalue = zd_readl(ZD_TSF_HighPart);
+        TSFTimer += (((u64)tmpvalue) << 32);
+        TSFTimer = TSFTimer >> 10; // in unit of TU
+
+        //printk("TSF(TU) %d \n", TSFTimer);
+        //printk("BeaconInterval = %d\n", ul_BcnItvl);
+        //printk("TSF mod BeaconInterval = %d\n", (TSFTimer % ul_BcnItvl));
+
+        if ((do_div(TSFTimer, ul_BcnItvl)) > (ul_atimwnd + TOLERANCE))
+        {
+                // Make sure no traffic before (ATIMWnd+TOLERANCE)
+                if ((!macp->bFrmRxed1) && (macp->SuggestionMode == PS_PSM)) {
+                        // Any frame wait for transmission.
+                        if (!macp->activeTxQ->count) {
+
+                                //zd1205_sleep_reset(macp);
+                                return 1;
+                        }
+                }
+        }
+
+        return 0;
+}
+
+
+
+void zd1205_InfraPsCheck(struct zd1205_private *macp)
+{
+        u32 tmpvalue;
+
+        // Now, we assure that no any power-save related operation performing.
+        // That's because all power-save related operations are either
+        // Mutexed by Adapter->Lock or Notified by Adapter->Notification.
+        if ((macp->SuggestionMode == PS_PSM) && (macp->PwrState == PS_CAM))
+        {
+                down(&macp->bcn_sem);
+                tmpvalue = zd_readl(ZD_BCNInterval);
+
+                tmpvalue |= POWER_MNT;
+
+
+                zd_writel(tmpvalue, ZD_BCNInterval);
+                up(&macp->bcn_sem);
+
+                macp->PwrState = PS_PSM;
+                zd_EventNotify(EVENT_PS_CHANGE, (U8)macp->PwrState, 0, 0);
+                ZD1211DEBUG(0, "=====CAM --> PSM\n");
+        } else if ((macp->SuggestionMode == PS_CAM) && (macp->PwrState == PS_PSM) &&
+                        (!dot11Obj.bDeviceInSleep))
+        {
+                down(&macp->bcn_sem);
+
+                tmpvalue = zd_readl(ZD_BCNInterval);
+                tmpvalue &= ~POWER_MNT;
+                zd_writel(tmpvalue, ZD_BCNInterval);
+                up(&macp->bcn_sem);
+
+                macp->PwrState = PS_CAM;
+                zd_EventNotify(EVENT_PS_CHANGE, (U8)macp->PwrState, 0, 0);
+                ZD1211DEBUG(0, "=====PSM --> CAM\n");
+        }
+
+        return;
+}
+
+//Normally, house keeping routine is run every 100ms.
+void zd1205_house_keeping(struct zd1205_private *macp)
+{
+
+        static u32 loop = 0;
+        card_Setting_t *pSetting = &macp->cardSetting;
+        u8 BssType = pSetting->BssType;
+        u8 bAssoc = macp->bAssoc;
+
+#if 0
+
+        if (dot11Obj.QueueFlag & TX_QUEUE_SET)
+        {
+                macp->txQueSetCnt++;
+                //tasklet_schedule(&macp->zd1205_tx_tasklet);
+                zd_CleanupTxQ();
+        }
+#endif
+        loop++;
+
+#ifndef HOST_IF_USB
+
+        while (dot11Obj.bDeviceInSleep)
+        {
+                // If device is in sleep, do not access device register often to
+                // prevent host from slowing down.
+                wait_ms(10);
+        }
+#else
+        if (dot11Obj.bDeviceInSleep)
+                return;
+#endif
+
+        // Software Antenna Diversity Mechanism
+        if (macp->bEnableSwAntennaDiv)
+        {
+                zd1205_SwAntennaDiv(macp);
+        }
+
+        // IBSS power-save monitor
+        if ((BssType == INDEPENDENT_BSS) && (bAssoc))
+        {
+                if ((!dot11Obj.bChScanning) && macp->bPSMSupported) {
+                        if (zd1205_IbssPsCheck(macp))
+                                return;
+                }
+        }
+
+#if 1
+        // Infrasture AP mode beacon generation
+        if (BssType == AP_BSS)
+        {
+                down(&macp->bcn_sem);
+                zd_EventNotify(EVENT_TBCN, 0, 0, 0);
+                up(&macp->bcn_sem);
+
+                if (macp->dtimCount == 0)
+                        macp->dtimCount = macp->cardSetting.DtimPeriod;
+                macp->dtimCount--;
+        }
+#endif
+
+
+        //++ Recovery mechanism for ZD1202 ASIC Phy-Bus arbitration fault.
+        //   We combined tx-power-tracking/Sw Antenna diversity code here to
+        //   reduce the frequence of
+        //   calling ReleaseCtrOfPhyReg. It's harmful to throughput.
+
+        if ((loop % 1) == 0)
+        { //every 100 ms
+                //Collect HW Tally
+                //zd1205_CollectHwTally(macp);  //This will make us lose CfgNextBcn interrupt
+
+#ifdef HOST_IF_USB
+
+                //tmpvalue = zd_readl(0x6e4);
+                //macp->REG_6e4_Add += tmpvalue;
+                //printk(KERN_ERR "Detect Strong Signal:%lu\n",jiffies);
+                zd1211_StrongSignalDect(macp);
+#endif
+
+                // Infrastructure Power-State momitor
+
+                if ((!dot11Obj.bChScanning) && (BssType == INFRASTRUCTURE_BSS) && (bAssoc) &&  (macp->bPSMSupported)) {
+                        zd1205_InfraPsCheck(macp);
+                }
+        }
+
+#ifdef HOST_IF_USB
+	#ifndef ZD1211B
+        zd1211_TxCalibration(macp);
+#endif
+
+        zd1211_CheckWithIPC(macp);
+#endif
+
+}
+
+void HKeepingCB(struct net_device *dev)
+{
+        struct zd1205_private *macp = dev->priv;
+
+#ifdef HOST_IF_USB
+
+        defer_kevent(macp, KEVENT_HOUSE_KEEPING);
+        mod_timer(&(macp->tm_hking_id), jiffies+ (1*HZ)/10);
+#else
+
+        zd1205_house_keeping(macp);
+        mod_timer(&(macp->tm_hking_id), jiffies+ (1*HZ)/10);
+#endif
+
+}
+
+void zd1205_CollectBssInfo(struct zd1205_private *macp, plcp_wla_Header_t *pWlanHdr, u8 *pMacBody, u32 bodyLen)
+{
+        u8 bssidmatched = 0;
+        u8 i, j;
+        u8 *pBssid;
+        u8 *pByte;
+        u32 currPos = 0;
+        u8 elemId, elemLen;
+
+        if ((*(pMacBody+CAP_OFFSET)) & BIT_1) //IBSS
+                pBssid = pWlanHdr->Address3;
+        else
+                pBssid = pWlanHdr->Address2;
+
+        for (i=0; i<macp->bss_index; i++)
+        {
+                for (j=0; j<6; j++) {
+                        if (macp->BSSInfo[i].bssid[j] != pBssid[j]) {
+                                break;
+                        }
+                }
+
+                if (j==6) {
+                        bssidmatched = 1;
+                        break;
+                }
+        }
+
+        if (bssidmatched)
+                return;
+
+        //get bssid
+        for (i=0; i<6; i++)
+        {
+                macp->BSSInfo[macp->bss_index].bssid[i] = pBssid[i];
+        }
+
+
+        //get beacon interval
+        pByte = pMacBody+BCN_INTERVAL_OFFSET;
+        macp->BSSInfo[macp->bss_index].beaconInterval = ((*pByte) + ((u16)(*(pByte+1))<<8));
+
+        //get capability
+        pByte = pMacBody+CAP_OFFSET;
+        macp->BSSInfo[macp->bss_index].cap = ((*pByte) + ((u16)(*(pByte+1))<<8) );
+
+        //get element
+        pByte = pMacBody+SSID_OFFSET;
+        currPos = SSID_OFFSET;
+
+        while(currPos < bodyLen)
+        {
+                elemId = *pByte;
+                elemLen = *(pByte+1);
+
+                switch(elemId) {
+                case ELEID_SSID: //ssid
+                        for (i=0; i<elemLen+2; i++) {
+                                macp->BSSInfo[macp->bss_index].ssid[i] = *pByte;
+                                pByte++;
+                        }
+                        break;
+
+                case ELEID_SUPRATES: //supported rateS
+
+                        for (i=0; i<elemLen+2; i++) {
+                                macp->BSSInfo[macp->bss_index].supRates[i] = *pByte;
+                                pByte++;
+                        }
+                        break;
+
+
+                case ELEID_DSPARMS: //ds parameter
+                        macp->BSSInfo[macp->bss_index].channel = *(pByte+2);
+                        pByte += (elemLen+2);
+                        break;
+
+                case ELEID_EXT_RATES:
+
+                        pByte += (elemLen+2);
+                        break;
+
+                default:
+
+                        pByte += (elemLen+2);
+                        break;
+                }
+
+                currPos += elemLen+2;
+        }
+
+        macp->BSSInfo[macp->bss_index].signalStrength = macp->rxSignalStrength;
+        macp->BSSInfo[macp->bss_index].signalQuality = macp->rxSignalQuality;
+
+        if (macp->bss_index < (BSS_INFO_NUM-1))
+        {
+                macp->bss_index ++;
+        }
+
+        return;
+}
+
+void zd1205_dump_rfds(struct zd1205_private *macp)
+{
+        struct rx_list_elem *rx_struct = NULL;
+        struct list_head *entry_ptr = NULL;
+        zd1205_RFD_t *rfd = 0;
+        struct sk_buff *skb;
+
+        int i = 0;
+
+        list_for_each(entry_ptr, &(macp->active_rx_list))
+        {
+
+                rx_struct = list_entry(entry_ptr, struct rx_list_elem, list_elem);
+                if (!rx_struct)
+                        return;
+#ifndef HOST_IF_USB
+
+                pci_dma_sync_single(macp->pdev, rx_struct->dma_addr,
+                                    macp->rfd_size, PCI_DMA_FROMDEVICE);
+#endif
+
+                skb = rx_struct->skb;
+                rfd = RFD_POINTER(skb, macp);	/* locate RFD within skb */
+#if 0
+
+                printk(KERN_DEBUG "zd1205: i = %x\n", i);
+                printk(KERN_DEBUG "zd1205: rx_struct = %x\n", (u32)rx_struct);
+
+                printk(KERN_DEBUG "zd1205: rx_struct->dma_addr = %x\n", (u32)rx_struct->dma_addr);
+                printk(KERN_DEBUG "zd1205: rx_struct->skb = %x\n", (u32)rx_struct->skb);
+                printk(KERN_DEBUG "zd1205: rfd = %x\n", (u32)rfd);
+                printk(KERN_DEBUG "zd1205: CbStatus = %x\n", le32_to_cpu(rfd->CbStatus));
+
+                printk(KERN_DEBUG "zd1205: CbCommand = %x\n", le32_to_cpu(rfd->CbCommand));
+                printk(KERN_DEBUG "zd1205: NextCbPhyAddrLowPart = %x\n", le32_to_cpu(rfd->NextCbPhyAddrLowPart));
+                printk(KERN_DEBUG "zd1205: NextCbPhyAddrHighPart = %x\n", le32_to_cpu(rfd->NextCbPhyAddrHighPart));
+#endif
+
+                zd1205_dump_data("rfd", (u8 *)rfd, 24);
+                i++;
+
+        }
+
+}
+
+void zd1205_dump_data(char *info, u8 *data, u32 data_len)
+{
+        int i;
+        printk(KERN_DEBUG "%s data [%d]: \n", info, data_len);
+
+        /* ath_desc: fix printks */
+        // printk parses KERN_* macros only after newlines
+        printk(KERN_DEBUG "");
+        for (i=0; i<data_len; i++) {
+                printk("%02x ", data[i]);
+                if ((i>0) && ((i+1)%16 == 0))
+                        printk("\n" KERN_DEBUG);
+        }
+
+        printk("\n");
+}
+
+
+
+/**
+ * zd1205_get_rx_struct - retrieve cell to hold skb buff from the pool
+ * @macp: atapter's private data struct
+ 
+ *
+ * Returns the new cell to hold sk_buff or %NULL.
+ */
+
+static struct rx_list_elem *
+                        zd1205_get_rx_struct(struct zd1205_private *macp)
+{
+        struct rx_list_elem *rx_struct = NULL;
+
+        if (!list_empty(&(macp->rx_struct_pool)))
+        {
+
+                rx_struct = list_entry(macp->rx_struct_pool.next,
+                                       struct rx_list_elem, list_elem);
+                list_del(&(rx_struct->list_elem));
+        }
+
+        return rx_struct;
+}
+
+
+/**
+ * zd1205_alloc_skb - allocate an skb for the adapter
+ * @macp: atapter's private data struct
+ *
+ * Allocates skb with enough room for rfd, and data, and reserve non-data space.
+ * Returns the new cell with sk_buff or %NULL.
+ */
+
+static struct rx_list_elem *
+                        zd1205_alloc_skb(struct zd1205_private *macp)
+{
+        struct sk_buff *new_skb;
+
+        u32 skb_size = sizeof (zd1205_RFD_t);
+        struct rx_list_elem *rx_struct;
+
+        ZENTER(4);
+
+        new_skb = (struct sk_buff *) dev_alloc_skb(skb_size);
+        if (new_skb)
+        {
+                /* The IP data should be
+                   DWORD aligned. since the ethernet header is 14 bytes long, 
+                   we need to reserve 2 extra bytes so that the TCP/IP headers
+
+                   will be DWORD aligned. */
+                //skb_reserve(new_skb, 2); //for zd1202, rx dma must be 4-bytes aligmnebt
+                if ((rx_struct = zd1205_get_rx_struct(macp)) == NULL)
+                        goto err;
+
+                /* ath_desc: AMD64 support */
+                ZD1211DEBUG(4, "zd1211: rx_struct = %p\n", (void *)rx_struct);
+
+
+                rx_struct->skb = new_skb;
+
+                //Rx DMA address  must be 4 bytes alignment
+#ifndef HOST_IF_USB
+
+                rx_struct->dma_addr = pci_map_single(macp->pdev, new_skb->data, sizeof (zd1205_RFD_t), PCI_DMA_FROMDEVICE);
+
+#endif
+
+                ZD1211DEBUG(4, "zd1211: rx_struct->dma_addr = %p\n", (void *)rx_struct->dma_addr);
+
+#ifndef HOST_IF_USB
+
+                if (!rx_struct->dma_addr)
+                        goto err;
+#endif
+
+
+                skb_reserve(new_skb, macp->rfd_size); //now skb->data point to RxBuffer
+
+#ifdef HOST_IF_USB
+
+                rx_struct->dma_addr = (dma_addr_t)new_skb->data;
+                rx_struct->UnFinishFrmLen = 0;
+#endif
+
+                ZEXIT(4);
+                return rx_struct;
+        } else
+        {
+                macp->AllocSkbFailCnt++;
+                printk(KERN_DEBUG "zd1205: dev_alloc_skb fail\n");
+                return NULL;
+        }
+
+err:
+        printk(KERN_DEBUG "zd1205: ****** err\n");
+        dev_kfree_skb_irq(new_skb);
+
+        return NULL;
+}
+
+
+/**
+ * zd1205_add_skb_to_end - add an skb to the end of our rfd list
+ 
+ * @macp: atapter's private data struct
+ * @rx_struct: rx_list_elem with the new skb
+ *
+ * Adds a newly allocated skb to the end of our rfd list.
+ */
+
+
+
+void
+zd1205_add_skb_to_end(struct zd1205_private *macp, struct rx_list_elem *rx_struct)
+{
+        zd1205_RFD_t *rfdn;	/* The new rfd */
+
+        zd1205_RFD_t *rfd;		/* The old rfd */
+        struct rx_list_elem *rx_struct_last;
+
+        ZENTER(4);
+
+
+        (rx_struct->skb)->dev = macp->device;
+        rfdn = RFD_POINTER(rx_struct->skb, macp);
+
+        rfdn->CbCommand = __constant_cpu_to_le32(RFD_EL_BIT);
+        wmb();
+        rfdn->CbStatus = 0xffffffff;
+
+        rfdn->ActualCount = 0;
+        rfdn->MaxSize = __constant_cpu_to_le32(MAX_WLAN_SIZE);
+
+#ifndef __LP64__
+        rfdn->NextCbPhyAddrHighPart = 0;
+
+        rfdn->NextCbPhyAddrLowPart = 0;
+
+#else
+        rfdn->NextCbPhyAddr = 0;
+#endif
+
+#ifndef HOST_IF_USB
+
+        wmb();
+
+        pci_dma_sync_single(macp->pdev, rx_struct->dma_addr, macp->rfd_size,
+                            PCI_DMA_TODEVICE);
+#endif
+
+        if (!list_empty(&(macp->active_rx_list)))
+        {
+                rx_struct_last = list_entry(macp->active_rx_list.prev,
+
+                                            struct rx_list_elem, list_elem);
+
+
+                rfd = RFD_POINTER(rx_struct_last->skb, macp);
+                ZD1211DEBUG(4, "zd1211: rfd = %p\n", (unsigned long *)rfd);
+
+#ifndef HOST_IF_USB
+
+                pci_dma_sync_single(macp->pdev, rx_struct_last->dma_addr,
+
+                                    4, PCI_DMA_FROMDEVICE);
+#endif
+
+#ifndef __LP64__
+                put_unaligned(cpu_to_le32(rx_struct->dma_addr),
+                              ((u32 *) (&(rfd->NextCbPhyAddrLowPart))));
+#else
+                put_unaligned(cpu_to_le64(rx_struct->dma_addr),&(rfd->NextCbPhyAddr));
+#endif
+#ifndef HOST_IF_USB
+
+                wmb();
+                pci_dma_sync_single(macp->pdev, rx_struct_last->dma_addr,
+                                    8, PCI_DMA_TODEVICE);
+
+#endif
+
+                rfd->CbCommand = 0;
+
+
+#ifndef HOST_IF_USB
+
+                wmb();
+                pci_dma_sync_single(macp->pdev, rx_struct_last->dma_addr,
+                                    4, PCI_DMA_TODEVICE);
+
+#endif
+
+        }
+
+        list_add_tail(&(rx_struct->list_elem), &(macp->active_rx_list)); //add elem to active_rx_list
+        ZEXIT(4);
+}
+
+
+void zd1205_alloc_skbs(struct zd1205_private *macp)
+{
+        for (; macp->skb_req > 0; macp->skb_req--)
+        {
+                struct rx_list_elem *rx_struct;
+
+                if ((rx_struct = zd1205_alloc_skb(macp)) == NULL) {
+                        printk(KERN_DEBUG "zd1205: zd1205_alloc_skb fail\n");
+                        return;
+
+                }
+                zd1205_add_skb_to_end(macp, rx_struct);
+        }
+
+}
+
+
+void zd1205_transmit_cleanup(struct zd1205_private *macp, zd1205_SwTcb_t *sw_tcb)
+{
+        zd1205_HwTCB_t *hw_tcb;
+        u32 tbd_cnt;
+        zd1205_TBD_t *tbd_arr = sw_tcb->pFirstTbd;
+
+        ZENTER(2);
+
+        hw_tcb = sw_tcb->pTcb;
+        tbd_cnt = le32_to_cpu(hw_tcb->TxCbTbdNumber);
+        tbd_arr += 2; //CtrlSetting and MacHeader
+
+        ZD1211DEBUG(2, "zd1211: umap tbd cnt = %x\n", tbd_cnt-2);
+
+#ifndef HOST_IF_USB
+
+        for (i=0; i<tbd_cnt-2; i++, tbd_arr++)
+        {
+                ZD1211DEBUG(2, "zd1211: umap body_dma = %x\n", le32_to_cpu(tbd_arr->TbdBufferAddrLowPart));
+                pci_unmap_single(macp->pdev,
+                                 le32_to_cpu(tbd_arr->TbdBufferAddrLowPart),
+                                 le32_to_cpu(tbd_arr->TbdCount),
+                                 PCI_DMA_TODEVICE);
+        }
+#endif
+
+        ZD1211DEBUG(2, "zd1211: Free TcbPhys = %x\n", (u32)sw_tcb->TcbPhys);
+        zd1205_qlast_txq(macp, macp->freeTxQ, sw_tcb);
+        ZD1211DEBUG(2, "zd1211: Cnt of freeTxQ = %x\n", macp->freeTxQ->count);
+
+        //sw_tcb->HangDur = 0;
+        hw_tcb->CbStatus = 0xffffffff;
+        hw_tcb->TxCbTbdNumber = cpu_to_le32(0xaaaaaaaa);	/* for debug */
+        hw_tcb->CbCommand = cpu_to_le32(CB_S_BIT);
+
+        if ((netif_running(macp->device)) && (macp->bAssoc))
+        {
+                netif_carrier_on(macp->device);
+                netif_wake_queue(macp->device);   //resume tx
+        }
+
+        ZEXIT(2);
+        return;
+}
+
+void zd1205_tx_isr(struct zd1205_private *macp)
+{
+        zd1205_SwTcb_t *sw_tcb;
+
+#ifndef HOST_IF_USB
+
+        zd1250_SwTcb_t *next_sw_tcb;
+#endif
+
+        u16 aid;
+
+#ifdef HOST_IF_USB
+
+        int bRunOnce = false;
+#endif
+
+        ZD1211DEBUG(2, "***** zd1205_tx_isr enter *****\n");
+
+        if (!macp->activeTxQ->count)
+        {
+                printk(KERN_DEBUG "No element in activeQ\n");
+                return;
+        }
+
+        /* Look at the TCB at the head of the queue.  If it has been completed
+           then pop it off and place it at the tail of the completed list.
+           Repeat this process until all the completed TCBs have been moved to the
+           completed list */
+        while (macp->activeTxQ->count)
+        {
+                sw_tcb = macp->activeTxQ->first;
+
+#ifdef HOST_IF_USB
+                // in USB modem, only run once
+                if (bRunOnce)
+                        break;
+                bRunOnce = true;
+#endif
+                // check to see if the TCB has been DMA'd
+
+                // Workaround for hardware problem that seems leap over a TCB
+                // and then fill completion token in the next TCB.
+                ZD1211DEBUG(2, "zd1211: hw_tcb = %p\n", (unsigned long *)sw_tcb->pTcb);
+                ZD1211DEBUG(2, "zd1211: CbStatus = %x\n", (u16)le32_to_cpu(sw_tcb->pTcb->CbStatus));
+
+#ifndef HOST_IF_USB
+
+                rmb();
+
+                if ((u16)le32_to_cpu(sw_tcb->pTcb->CbStatus) != CB_STATUS_COMPLETE) {
+                        next_sw_tcb = sw_tcb;
+
+                        while(1) {
+                                next_sw_tcb = next_sw_tcb->next;
+                                if (!next_sw_tcb)
+                                        break;
+
+                                if ((u16)le32_to_cpu(next_sw_tcb->pTcb->CbStatus) == CB_STATUS_COMPLETE)
+                                        break;
+                        }
+
+                        if (!next_sw_tcb)
+                                break;
+                }
+#endif
+
+                /* Remove the TCB from the active queue. */
+                sw_tcb = zd1205_first_txq(macp, macp->activeTxQ);
+                ZD1211DEBUG(2, "zd1211: Cnt of activeQ = %x\n", macp->activeTxQ->count);
+
+                aid = sw_tcb->aid;
+                zd1205_transmit_cleanup(macp, sw_tcb);
+                macp->txCmpCnt++;
+
+                if (!sw_tcb->LastFrag)
+                        continue;
+
+                zd_EventNotify(EVENT_TX_COMPLETE, ZD_TX_CONFIRM, (U32)sw_tcb->MsgID, (U32)aid);
+                macp->SequenceNum++;
+                macp->bDataTrafficLight = 1;
+        }
+
+#ifdef HOST_IF_USB
+        if(sw_tcb->CalMIC[MIC_LNG] == TRUE)
+                zd1211_submit_tx_urb(macp,TRUE);
+        else
+                zd1211_submit_tx_urb(macp,FALSE);
+#endif
+
+        ZD1211DEBUG(2, "***** zd1205_tx_isr exit *****\n");
+        return;
+}
+
+
+#ifndef HOST_IF_USB
+static void zd1205_retry_failed(struct zd1205_private *macp)
+{
+        zd1205_SwTcb_t *sw_tcb;
+        zd1205_SwTcb_t *next_sw_tcb = NULL;
+
+        zd1205_HwTCB_t *hw_tcb;
+        zd1205_Ctrl_Set_t *ctrl_set;
+
+        u8 CurrentRate, NewRate;
+        u8 ShortPreambleFg;
+        u16 Len;
+        u16 NextLen;
+        u16 LenInUs;
+        u16 NextLenInUs;
+        u8 Service;
+        u16 aid;
+
+        ZD1211DEBUG(2, "+++++ zd1205_retry_failed enter +++++\n");
+
+        if (!macp->activeTxQ->count)
+        {
+                ZD1211DEBUG(1, "**********empty activeTxQ, got retry failed");
+                sw_tcb = macp->freeTxQ->first;
+                zd1205_start_download(sw_tcb->TcbPhys | BIT_0);
+                return;
+        }
+
+
+        // Feature: Rate Adaption
+        // - During the procedure of processing a transmitting frame, we must keep
+        //   the TaRate consistent.
+        // - When to fall OppositeContext.CurrentTxRate:
+        //   Whenever RetryFail occurs, change OppositeContext.CurrentTxRate by a value
+        //   ((Rate of this TCB) minus a degree) and modify this TCB's control-setting
+        //   with the OppositeContext.CurrentTxRate and then Restart this TCB.
+        //	 (Set RetryMAX = 2).
+        //   Once the TxRate is 1M and still RetryFail, abandon this frame.
+        // - When to rise TxRate:
+        //   If there are 10 frames transmitted successfully
+        //   (OppositeContext.ConsecutiveSuccessFrames >= 10), change
+        //   OppositeContext.CurrentTxRate by a value
+        //   ((Rate of this TCB) plus a degree).
+
+
+        // - Adjust OppositeContext.CurrentTxRate manually. (by application tool)
+        sw_tcb = macp->activeTxQ->first;
+        aid = sw_tcb->aid;
+        ctrl_set = sw_tcb->pHwCtrlPtr;
+
+        if (ctrl_set->CtrlSetting[11] & BIT_3)
+        { //management frame
+                goto no_rate_adaption;
+        }
+
+        //CurrentRate = (ctrl_set->CtrlSetting[0] & 0x1f);
+
+        CurrentRate = sw_tcb->Rate;
+
+        ShortPreambleFg = (ctrl_set->CtrlSetting[0] & 0x20);
+
+        if (((!ShortPreambleFg) && (CurrentRate > RATE_1M)) ||
+                        ((ShortPreambleFg) && (CurrentRate > RATE_2M)))
+        {
+                // Fall TxRate a degree
+
+                NewRate = zd1205_RateAdaption(aid, CurrentRate, FALL_RATE);
+                sw_tcb->Rate = NewRate;
+
+                // Modify Control-setting
+                ctrl_set->CtrlSetting[0] = (ShortPreambleFg | NewRate);
+                ctrl_set->CtrlSetting[11] |= BIT_0; // Set need backoff
+
+                // LenInUs, Service
+                Len = (ctrl_set->CtrlSetting[1] + ((u16)ctrl_set->CtrlSetting[2] << 8));
+                Cal_Us_Service(NewRate, Len, &LenInUs, &Service);
+                ctrl_set->CtrlSetting[20] = (u8)LenInUs;
+                ctrl_set->CtrlSetting[21] = (u8)(LenInUs >> 8);
+                ctrl_set->CtrlSetting[22] = Service;
+
+
+                // NextLenInUs
+#if defined(OFDM)
+
+                NextLen = (ctrl_set->CtrlSetting[25+1] + ((u16)ctrl_set->CtrlSetting[25+2] << 8));
+#else
+
+                NextLen = (ctrl_set->CtrlSetting[18] + ((u16)ctrl_set->CtrlSetting[19] << 8));
+#endif
+
+
+
+
+
+                Cal_Us_Service(NewRate, NextLen, &NextLenInUs, &Service);
+                ctrl_set->CtrlSetting[23] = (u8)NextLenInUs;
+                ctrl_set->CtrlSetting[24] = (u8)(NextLenInUs >> 8);
+
+#if defined(OFDM)
+
+                if (NewRate > RATE_11M) {
+                        NewRate = OfdmRateTbl[NewRate];
+                }
+
+                macp->retryFailCnt++;
+
+                ctrl_set->CtrlSetting[0] = (ShortPreambleFg | NewRate);
+                ctrl_set->CtrlSetting[11] |= BIT_0; // Set need backoff
+
+#endif
+                // Re-Start Tx-Bus master with a lower Rate
+
+                zd1205_start_download(sw_tcb->TcbPhys | BIT_0);
+                return;
+
+
+        }
+
+        /* Look at the TCB at the head of the queue.  If it has been completed
+
+            then pop it off and place it at the tail of the completed list.
+            Repeat this process until all the completed TCBs have been moved to the
+            completed list */
+
+no_rate_adaption:
+        while (macp->activeTxQ->count)
+        {
+                //ZD1211DEBUG(1, "zd1211: sw_tcb = %x\n", (u32)sw_tcb);
+                ZD1211DEBUG(2, "zd1211: hw_tcb = %x\n", (u32)sw_tcb->pTcb);
+
+
+                /* Remove the TCB from the active queue. */
+                sw_tcb = zd1205_first_txq(macp, macp->activeTxQ);
+
+                ZD1211DEBUG(2, "zd1211: Cnt of activeQ = %x\n", macp->activeTxQ->count);
+
+                zd1205_transmit_cleanup(macp, sw_tcb);
+                macp->retryFailCnt++;
+                if (!sw_tcb->LastFrag)
+                        continue;
+
+
+                zd_EventNotify(EVENT_TX_COMPLETE, ZD_RETRY_FAILED, (U32)sw_tcb->MsgID, aid);
+
+                if (!macp->activeTxQ->count) {
+                        // Re-Start Tx-Bus master with an suspend TCB
+                        hw_tcb = (zd1205_HwTCB_t *)sw_tcb->pTcb;
+                        // Set BIT_0 to escape from Retry-Fail-Wait State.
+                        zd1205_start_download((cpu_to_le32(hw_tcb->NextCbPhyAddrLowPart) | BIT_0));
+                } else {
+                        next_sw_tcb = macp->activeTxQ->first;
+                        // Re-Start Tx bus master
+                        // Set BIT_0 to escape from Retry-Fail-Wait state.
+
+                        zd1205_start_download(next_sw_tcb->TcbPhys | BIT_0);
+                }
+                break;
+        }
+
+        macp->bIBSS_Wakeup_Dest = 1;
+
+
+
+        ZD1211DEBUG(2, "+++++ zd1205_retry_failed exit +++++\n");
+
+        return;
+}
+#endif
+
+
+static void zd1205_config(struct zd1205_private *macp)
+{
+        u32 tmpValue;
+        int i, jj;
+
+        ZENTER(1);
+
+
+        // Retrieve Feature BitMap
+        zd_writel(macp->cardSetting.EncryMode, EncryptionType);
+        macp->dtimCount = 0;
+
+
+        /* Setup Physical Address */
+        zd_writel(cpu_to_le32(*(u32 *)&macp->macAdr[0]), MACAddr_P1);
+        zd_writel(cpu_to_le32(*(u32 *)&macp->macAdr[4]), MACAddr_P2);
+        if (macp->cardSetting.BssType == AP_BSS)
+        {
+                /* Set bssid = MacAddress */
+                macp->BSSID[0] = macp->macAdr[0];
+                macp->BSSID[1] = macp->macAdr[1];
+                macp->BSSID[2] = macp->macAdr[2];
+                macp->BSSID[3] = macp->macAdr[3];
+                macp->BSSID[4] = macp->macAdr[4];
+                macp->BSSID[5] = macp->macAdr[5];
+                zd_writel(cpu_to_le32(*(u32 *)&macp->macAdr[0]), BSSID_P1);
+                zd_writel(cpu_to_le32(*(u32 *)&macp->macAdr[4]), BSSID_P2);
+        } else
+        {
+                zd_writel(STA_RX_FILTER, ZD_Rx_Filter);
+        }
+
+
+        macp->intrMask = ZD1205_INT_MASK;
+
+        if (macp->intrMask & DTIM_NOTIFY_EN)
+                macp->dtim_notify_en = 1;
+        else
+                macp->dtim_notify_en = 0;
+
+
+        if (macp->intrMask & CFG_NEXT_BCN_EN)
+
+                macp->config_next_bcn_en = 1;
+        else
+                macp->config_next_bcn_en = 0;
+
+
+
+        zd1205_ClearTupleCache(macp);
+        zd1205_ArReset(macp);
+
+        macp->bTraceSetPoint = 1;
+        macp->bFixedRate = 0;
+        dot11Obj.bDeviceInSleep = 0;
+
+        macp->bGkInstalled = 0;
+        macp->PwrState = PS_CAM;
+
+        // Get Allowed Channel and Default Channel
+        dot11Obj.AllowedChannel = zd_readl(ZD_E2P_ALLOWED_CHANNEL);
+
+#ifndef HOST_IF_USB
+
+        dot11Obj.AllowedChannel = 0x3FFF;
+#endif
+
+        ZD1211DEBUG(0, "AllowedChannel = %08x\n", (u32)dot11Obj.AllowedChannel);
+
+        if (!(dot11Obj.AllowedChannel & 0xFFFF0000))
+        {
+                dot11Obj.AllowedChannel |= 0x10000;
+        }
+
+
+#ifdef HOST_IF_USB
+        tmpValue = zd_readl(E2P_SUBID);
+        macp->RegionCode = (u16)(tmpValue >> 16);
+
+        dot11Obj.RegionCode = macp->RegionCode;
+        macp->LinkLEDn = LED1;
+        if (macp->RF_Mode & BIT_4)
+        {
+
+
+                macp->LinkLEDn = LED2;
+                ZD1211DEBUG(0, "LED2\n");
+        }
+        ZD1211DEBUG(0, "LinkLEDn = %x\n", macp->LinkLEDn);
+
+        if (macp->RF_Mode & BIT_8)
+        {
+
+                dot11Obj.bOverWritePhyRegFromE2P = 1;
+                ZD1211DEBUG(0, "OverWritePhyRegFromE2P\n");
+
+
+        }
+
+
+        if (macp->RF_Mode & BIT_9)
+        {
+                dot11Obj.bIsNormalSize = 1;
+                ZD1211DEBUG(0, "NormalSize\n");
+        }
+
+        macp->LinkLED_OnDur = 2;
+        macp->LinkLED_OffDur = 1;
+        macp->DataLED = 0;
+        if (macp->RF_Mode & BIT_24)
+        {
+
+                macp->LinkLED_OnDur = ((macp->RF_Mode) >> 25) & 0x3;
+                macp->LinkLED_OffDur = ((macp->RF_Mode) >> 27) & 0x3;
+                if (macp->RF_Mode & BIT_29)
+                        macp->DataLED = 1;
+        }
+        ZD1211DEBUG(1, "LinkLED_OnDur = %d\n", macp->LinkLED_OnDur);
+
+        ZD1211DEBUG(1, "LinkLED_OffDur = %d\n", macp->LinkLED_OffDur);
+
+        if (!(macp->RF_Mode & BIT_10))
+        { // The IPC protection: the default is disablesd
+                macp->IPCFlag = 4;
+        }
+
+        macp->RF_Mode &= 0x0f;
+
+        tmpValue = zd_readl(FW_USB_SPEED);
+        dot11Obj.IsUSB2_0 = (u8) tmpValue;
+#else
+
+        dot11Obj.bIsNormalSize = 1;
+        dot11Obj.IsUSB2_0 = 1;
+#endif
+
+        printk("AllowedChannel = %08x\n", (u32)dot11Obj.AllowedChannel);
+        printk("Region:%u\n",(unsigned)dot11Obj.RegionCode);
+
+
+        ZD1211DEBUG(1, "IsUSB2_0 = %d\n", dot11Obj.IsUSB2_0);
+        // read Set Point from EEPROM
+
+        tmpValue = zd_readl(ZD_E2P_PWR_INT_VALUE1);
+        tmpValue -= cPWR_INT_VALUE_GUARD;
+        dot11Obj.IntValue[0] = (u8)tmpValue;
+        dot11Obj.IntValue[1] = (u8)(tmpValue >> 8);
+
+        dot11Obj.IntValue[2] = (u8)(tmpValue >> 16);
+        dot11Obj.IntValue[3] = (u8)(tmpValue >> 24);
+
+        tmpValue = zd_readl(ZD_E2P_PWR_INT_VALUE2);
+        tmpValue -= cPWR_INT_VALUE_GUARD;
+        dot11Obj.IntValue[4] = (u8)tmpValue;
+        dot11Obj.IntValue[5] = (u8)(tmpValue >> 8);
+        dot11Obj.IntValue[6] = (u8)(tmpValue >> 16);
+        dot11Obj.IntValue[7] = (u8)(tmpValue >> 24);
+
+        tmpValue = zd_readl(ZD_E2P_PWR_INT_VALUE3);
+        tmpValue -= cPWR_INT_VALUE_GUARD;
+        dot11Obj.IntValue[8] = (u8)tmpValue;
+        dot11Obj.IntValue[9] = (u8)(tmpValue >> 8);
+        dot11Obj.IntValue[10] = (u8)(tmpValue >> 16);
+        dot11Obj.IntValue[11] = (u8)(tmpValue >> 24);
+
+        tmpValue = zd_readl(ZD_E2P_PWR_INT_VALUE4);
+        tmpValue -= cPWR_INT_VALUE_GUARD;
+        dot11Obj.IntValue[12] = (u8)tmpValue;
+        dot11Obj.IntValue[13] = (u8)(tmpValue >> 8);
+
+        //Initiate a_Calibration_Data CH field
+        for (i=0;i<a_CALIBRATED_CH_NUM;i++)
+        {
+                if((i == 0) || ((i != 0) && (a_ChannelMap[i-1] != a_ChannelMap[i]))) {
+                        a_Calibration_Data[0][i] = a_ChannelMap[i];
+                } else {
+                        a_Calibration_Data[0][i] = 0xff;
+                }
+        }
+        //Initiate a_Interpolation_Data CH field
+        for (i=0;i<a_INTERPOLATION_CH_NUM;i++)
+                a_Interpolation_Data[0][i] = a_InterpolationTbl[i].a_Channel;
+
+        for (i=0;i<a_CALIBRATED_CH_NUM;i++)
+        {
+                //Adapter->a_Calibration_Data[0][i] = a_ChannelMap[i];
+                if(a_Calibration_Data[0][i] != 0xff) {
+                        a_Calibration_Data[1][i] = a_get_cal_int_val((u8)i) - cPWR_INT_VALUE_GUARD;
+                        a_Calibration_Data[2][i] = a_get_cal_36M_setpoint_val((u8)i);
+                        a_Calibration_Data[3][i] = a_get_cal_48M_54M_setpoint_val((u8)i);
+                } else {
+                        a_Calibration_Data[1][i] = 0xff;
+                        a_Calibration_Data[2][i] = 0xff;
+                        a_Calibration_Data[3][i] = 0xff;
+
+                }
+        }
+
+        //Calculate Interpolation SetPoints(For 802.11a)
+        for (i=0;i<a_INTERPOLATION_CH_NUM;i++)
+        {
+                //Adapter->a_Interpolation_Data[0][i] = a_InterpolationTbl[i].a_Channel;
+                if(a_InterpolationTbl[i].Left_Most_Channel == a_InterpolationTbl[i].Right_Most_Channel) {
+                        for (jj=0;jj<a_CALIBRATED_CH_NUM;jj++) {
+                                if(a_Calibration_Data[0][jj] == a_InterpolationTbl[i].Left_Most_Channel) {
+                                        a_Interpolation_Data[1][i] = a_Calibration_Data[1][jj];
+                                        a_Interpolation_Data[2][i] = a_Calibration_Data[2][jj];
+                                        a_Interpolation_Data[3][i] = a_Calibration_Data[3][jj];
+                                }//Directly used certain calibrated channel values
+                        }
+                } else {
+                        if(0xff == a_get_interpolation_value((u8)i, &a_Interpolation_Data[1][i],
+                                                             &a_Interpolation_Data[2][i], &a_Interpolation_Data[3][i]))
+                                printk("Get Int/Cal wrong in Interpolation Tbl(%d)\n",i);
+                }
+        }
+        //End Calculate Interpolation SetPoints(For 802.11a)
+
+
+
+#if fTX_PWR_CTRL
+        for (jj = 0; jj < 3; jj ++)
+        {
+
+                for (i = 0; i < 4; i++) {
+                        tmpValue = zd_readl(E2P_36M_CAL_VALUE + jj*0x20 + i*4);
+                        macp->SetPointOFDM[jj][i*4] = (u8) tmpValue;
+                        macp->SetPointOFDM[jj][i*4+1] = (u8) (tmpValue >> 8);
+                        if (i != 3) {
+                                macp->SetPointOFDM[jj][i*4+2] = (u8) (tmpValue >> 16);
+                                macp->SetPointOFDM[jj][i*4+3] = (u8) (tmpValue >> 24);
+                        }
+                }
+        }
+#endif
+
+
+        zd_writel(0x00000064,ZD_BCNInterval);
+        HW_UpdateBcnInterval(&dot11Obj, 0x00000064);
+
+        // read Set Point from EEPROM
+        tmpValue = zd_readl(ZD_E2P_PWR_CAL_VALUE1);
+        macp->EepSetPoint[0] = (u8)tmpValue;
+        macp->EepSetPoint[1] = (u8)(tmpValue >> 8);
+        macp->EepSetPoint[2] = (u8)(tmpValue >> 16);
+        macp->EepSetPoint[3] = (u8)(tmpValue >> 24);
+
+        tmpValue = zd_readl(ZD_E2P_PWR_CAL_VALUE2);
+
+        macp->EepSetPoint[4] = (u8)tmpValue;
+
+        macp->EepSetPoint[5] = (u8)(tmpValue >> 8);
+        macp->EepSetPoint[6] = (u8)(tmpValue >> 16);
+        macp->EepSetPoint[7] = (u8)(tmpValue >> 24);
+
+
+        tmpValue = zd_readl(ZD_E2P_PWR_CAL_VALUE3);
+        macp->EepSetPoint[8] = (u8)tmpValue;
+
+        macp->EepSetPoint[9] = (u8)(tmpValue >> 8);
+        macp->EepSetPoint[10] = (u8)(tmpValue >> 16);
+        macp->EepSetPoint[11] = (u8)(tmpValue >> 24);
+
+        tmpValue = zd_readl(ZD_E2P_PWR_CAL_VALUE4);
+        macp->EepSetPoint[12] = (u8)tmpValue;
+        macp->EepSetPoint[13] = (u8)(tmpValue >> 8);
+
+        HW_SetRfChannel(&dot11Obj, (dot11Obj.AllowedChannel >> 16), 0, MIXED_MODE);
+        // For Antenna Diversity Parameters
+        macp->bEnableSwAntennaDiv = 0;
+        macp->Ant_MonitorDur1 = 10;//100;
+        macp->Ant_MonitorDur2 = 1;
+        macp->NiceSQThr = 48;
+
+        macp->rxOffset = ZD_RX_OFFSET;
+
+        macp->bPSMSupported = 0;
+        macp->NormalBackoff = 0x7f047f;
+        macp->UrgentBackoff = 0x7f0407;
+        macp->LooseBackoff = 0x7f107f;
+        macp->WorseSQThr = 0x48;
+        macp->MulticastAddr[0] = 0;
+        macp->iv16 = 0;
+        macp->iv32 = 0;
+        macp->EnableTxPwrCtrl = 1;
+        macp->PSThreshhold = 10000;
+
+#if fANT_DIVERSITY
+        //    macp->NiceSQThr_OFDM = 12 * 4;    // 12 dB --> 48 %
+        macp->NiceSQThr_OFDM = 48;       // 48 %
+        macp->bEnableSwAntennaDiv = 1;
+#endif
+
+#if fWRITE_WORD_REG
+
+        macp->FlashType = 0xFF;
+
+#endif
+
+
+        macp->PHYTestIndex = 5;
+        macp->PHYTestRssiBound = 0x3a;
+        macp->PHYTestTimer = 30;
+        macp->TrafficBound = 200;
+
+        macp->PHYLowPower = 3;  // Tx/Rx enable
+        dot11Obj.CR122Flag = 2; // initial value
+
+        dot11Obj.CR31Flag = 2; // initial value
+        dot11Obj.CR203Flag = 2; // initial value
+        dot11Obj.PhyTest = 4;
+        macp->AdapterMaxRate = 0x0B;  // initail max rate = 54M
+        ZEXIT(0);
+}
+
+
+int zd1205_dis_connect(struct zd1205_private *macp)
+{
+        u32 tmpvalue;
+
+        ZD1211DEBUG(0, "zd1205_dis_connect\n");
+
+        netif_carrier_off(macp->device);
+        netif_stop_queue(macp->device);
+
+        // Note: The following sequence is important, do not change it arbitrarily.
+        macp->bAssoc = 0;
+        macp->PwrState = PS_CAM;
+
+        // PwrMgt = 0
+        down(&macp->bcn_sem);
+        tmpvalue = zd_readl(ZD_BCNInterval);
+        tmpvalue &= ~POWER_MNT;
+        zd_writel(tmpvalue, ZD_BCNInterval);
+        up(&macp->bcn_sem);
+
+
+#ifndef HOST_IF_USB
+
+        while (dot11Obj.bDeviceInSleep)
+        {
+                wait_ms(1);
+                //if (macp->Notification & RQ_TERMINATION){
+                //	break;
+                //}
+        }
+#else
+
+
+        if (dot11Obj.bDeviceInSleep)
+        {
+                ZD1211DEBUG(1, "Device in sleep\n");
+
+                return 1;
+
+        }
+#endif
+
+        // After all pending packets are served, then notify NDIS with
+        // DISCONNECT.
+        // Otherwise, it might cause IP Address = 0.0.0.0
+
+#ifndef HOST_IF_USB
+        while (macp->activeTxQ->count)
+        {
+                // After this step, we can make sure that no ATIM pended.
+                wait_ms(1);
+                //if (macp->Notification & RQ_TERMINATION){
+                //	break;
+                //}
+        }
+#else
+        //if (macp->activeTxQ->count){
+        //    ZD1211DEBUG(1, "activeTxQ not empty\n");
+
+        //    return 1;
+        //}
+
+#endif
+
+        // Notice PS_Change
+        zd_EventNotify(EVENT_PS_CHANGE, (u8)macp->PwrState, 0, 0);
+
+        // IBSS = 0, i.e, stop sending beacon.
+        down(&macp->bcn_sem);
+        tmpvalue = zd_readl(ZD_BCNInterval);
+        tmpvalue &= ~IBSS_MODE;
+        zd_writel(tmpvalue, ZD_BCNInterval);
+        up(&macp->bcn_sem);
+        zd1205_notify_disjoin_event(macp);
+
+
+        // We may need issue disassociate frame.
+        // Issue notification
+
+        return 0;
+}
+
+
+
+#ifndef HOST_IF_USB
+
+static void zd1205_dtim_notify(
+        struct zd1205_private *macp
+
+)
+
+{
+        zd1205_SwTcb_t *sw_tcb;
+        u32 tmp_value;
+
+        zd_EventNotify(EVENT_DTIM_NOTIFY, 0, 0, 0);
+        if (!macp->activeTxQ->count)
+                sw_tcb = macp->freeTxQ->first;
+        else
+                sw_tcb = macp->activeTxQ->first;
+
+
+        tmp_value = zd_readl(DeviceState);
+        tmp_value &= 0xf;
+        zd1205_start_download(sw_tcb->TcbPhys | BIT_0);
+
+}
+#endif
+
+void zd1205_config_wep_keys(struct zd1205_private *macp)
+{
+        card_Setting_t *pSetting = &macp->cardSetting;
+
+        u8 encryMode = pSetting->EncryMode;
+        u8 i, j;
+        u8 DynKeyMode = pSetting->DynKeyMode;
+        u8 keyLength;
+
+        if ((encryMode == 0) || (DynKeyMode != 0))
+        {
+                HW_CAM_Write(&dot11Obj, DEFAULT_ENCRY_TYPE, NO_WEP);
+                return;
+        }
+
+        if (pSetting->OperationMode != CAM_AP_VAP)
+        {
+                HW_CAM_ResetRollTbl(&dot11Obj); //force CAM to use default encry type
+
+                switch(encryMode) {
+                case WEP64:
+                        ZD1211DEBUG(0, "WEP64 Mode\n");
+                        keyLength = 5;
+                        break;
+
+                case WEP128:
+                        ZD1211DEBUG(0, "WEP128 Mode\n");
+                        keyLength = 13;
+                        break;
+
+                case WEP256:
+                        ZD1211DEBUG(0, "WEP256 Mode\n");
+                        keyLength = 29;
+                        break;
+
+                default:
+                        ZD1211DEBUG(0, "Not supported Mode\n");
+                        ZD1211DEBUG(0, "encryMode = %d\n", encryMode);
+
+                        return;
+                }
+
+                HW_CAM_Write(&dot11Obj, DEFAULT_ENCRY_TYPE, encryMode);
+
+                for (i=0, j=0; i<4; i++, j+=8) { //one key occupy 32 bytes space
+                        HW_ConfigStatKey(&dot11Obj, &pSetting->keyVector[i][0], keyLength, STA_KEY_START_ADDR+j);
+                }
+        }
+        return;
+}
+#if 0
+void zd1205_config_dyn_key(u8 DynKeyMode, u8 *pkey, int idx)
+{
+        u8 keyLength;
+        u8 encryMode;
+        u32 offset;
+
+        HW_CAM_ResetRollTbl(&dot11Obj); //force CAM to use default encry type
+
+        switch(DynKeyMode) {
+        case DYN_KEY_TKIP:
+                WPADEBUG("Dynamic key TKIP mode\n");
+                keyLength = 32;
+                encryMode = TKIP;
+                break;
+
+        case DYN_KEY_AES:
+                WPADEBUG("Dynamic key AES mode\n");
+                keyLength = 16;
+                encryMode = AES;
+                break;
+
+        default:
+                WPADEBUG("Do not support the Dynamic key mode = %d\n", DynKeyMode);
+                return;
+        }
+
+        /* The size for each key is 256 bits (32 bytes) */
+        offset = idx * 8;
+
+        HW_CAM_Write(&dot11Obj, DEFAULT_ENCRY_TYPE, encryMode);
+        HW_ConfigStatKey(&dot11Obj, pkey, keyLength, STA_KEY_START_ADDR+offset);
+
+        return;
+}
+#endif
+static int zd1205_validate_frame(
+        struct zd1205_private *macp,
+        zd1205_RFD_t *rfd
+)
+{
+        plcp_wla_Header_t *wla_hdr;
+        u32	min_length;
+        u32 frame_len;
+
+        u32 len, len1,tot_len;
+        u8	bOfdmFrm = 0;
+        u8	PlcpRate;
+        //u8	rx_offset = macp->rxOffset;
+
+        u8	FrameEndInd;
+#if ZDCONF_WE_STAT_SUPPORT == 1
+
+        U32 Tmp=0;
+        static U8  Qual[10]={0,0,0,0,0,0,0,0,0,0};
+        static U8   Str[10]={0,0,0,0,0,0,0,0,0,0};
+        static U32  Qidx=0;
+#elif !defined(ZDCONF_WE_STAT_SUPPORT)
+	#error "Undefine ZDCONF_WE_STAT_SUPPORT"
+#endif
+
+        u32 idx;
+
+
+        // Extension Info
+        /*********************************************************************/
+        /* Signal Quality | Signal Strength | Signal Quality2 | Noise Report */
+        /*********************************************************************/
+
+        /*****************************************************/
+        /* DA Index | SA Index | Rx Decrypt Type | Rx Status */
+        /*****************************************************/
+
+        // Accept Data/Management frame only.
+        wla_hdr = (plcp_wla_Header_t *)&rfd->RxBuffer[macp->rxOffset];
+
+        tot_len=(le32_to_cpu(rfd->ActualCount) & 0x3fff);
+        len = tot_len - EXTRA_INFO_LEN;
+        frame_len = tot_len - macp->rxOffset;
+
+        PlcpRate = wla_hdr->PlcpHdr[0];
+
+        if (frame_len == 0)
+        {
+                macp->ErrZeroLenFrmCnt++;
+                return false;
+        }
+
+        //pSwRfd->pRfd->RxBuffer[frameLen+rxOffset-1]
+        //bit7:	error frame
+        //bit6:	crc16 error
+        //bit5:	address not match
+        //bit4: crc32 error
+        //bit3:	decrypt error
+
+        //bit2: overrun
+
+        //bit1: Rx Timeout
+        //bit0:	OFDM modulation
+
+        macp->rxDecryType = rfd->RxBuffer[tot_len-2];
+        FrameEndInd = rfd->RxBuffer[tot_len-1];
+        if (FrameEndInd & BIT_7)
+        {
+                macp->ErrToHostFrmCnt++;
+                return FALSE;
+        }
+
+        if (bWepBit(wla_hdr))
+        {
+                //if (macp->cardSetting.EncryMode == ENCRY_TKIP)
+                //    min_length = 48;
+                //else
+                min_length = 44;
+                if (frame_len < min_length) {
+                        //printk(KERN_DEBUG "frame_len = %x\n", frame_len);
+                        macp->ErrShortFrmCnt++;
+                        return false;
+                }
+        } else
+        {
+                // Minimum Length = PLCP(5)+MACHeader(24)+EXTINFO(5)+CRC(4)
+                if (frame_len < 36) {
+                        //printk(KERN_DEBUG "frame_len = %x\n", frame_len);
+                        macp->ErrShortFrmCnt++;
+                        return false;
+                }
+        }
+
+        // Check if frame_len > MAX_WLAN_SIZE.
+        if (frame_len > ZD_MAX_WLAN_SIZE)
+        {
+                // Do not worry about the corruption of HwRfd.
+                // If the frame_len > 2410, the Rx-Bus-Master skip the bytes that exceed
+                // 2410 to protect the structure of HwRfd.
+                // However, the Rx-Bus-Master still reports this frame to host if the frame
+                // is recognized as good by the FA(Frame Analyzer).
+                macp->ErrLongFrmCnt++;
+                return false;
+        }
+
+        // Check if the SwRfd->frame_len matched the length derived from PLCP.
+        bOfdmFrm = (FrameEndInd & BIT_0);
+
+        if (bOfdmFrm)
+        {
+                // it's OFDM
+                macp->rxOFDMDataFrame++;
+#ifdef HOST_IF_USB
+
+                macp->PHYFreOFDMframe = 1;
+#endif
+
+                switch(PlcpRate & 0xF) {
+                case 0x0B:	//6M
+
+                        macp->rxInfo.rate = RATE_6M;
+                        break;
+
+                case 0x0F:	//9M
+                        macp->rxInfo.rate = RATE_9M;
+                        break;
+
+
+                case 0x0A:	//12M
+                        macp->rxInfo.rate = RATE_12M;
+
+                        break;
+
+                case 0x0E:	//18M
+                        macp->rxInfo.rate = RATE_18M;
+                        break;
+
+
+                case 0x09:	//24M
+                        macp->rxInfo.rate = RATE_24M;
+                        break;
+
+                case 0x0D:	//36M
+                        macp->rxInfo.rate = RATE_36M;
+                        break;
+
+                case 0x08:	//48M
+                        macp->rxInfo.rate = RATE_48M;
+                        break;
+
+                case 0x0C:	//54M
+                        macp->rxInfo.rate = RATE_54M;
+                        break;
+
+                default:
+                        break;
+                }
+
+        } else
+        {
+                // it's CCK
+                macp->rx11bDataFrame++;
+                // the value from PHY is in scale from Max is 0 and Min is 0xb5
+                switch(PlcpRate) {
+                case 0x0A:
+
+                        macp->rxInfo.rate = RATE_1M;
+                        break;
+
+                case 0x14:
+                        macp->rxInfo.rate = RATE_2M;
+                        break;
+
+                case 0x37:
+                        macp->rxInfo.rate = RATE_5M;
+                        break;
+
+                case 0x6E:
+                        macp->rxInfo.rate = RATE_11M;
+                        break;
+
+                default:
+                        break;
+                }
+        }
+
+
+        macp->rxSignalQuality = rfd->RxBuffer[len];
+        macp->rxSignalQuality1 = macp->rxSignalQuality;
+        macp->rxSignalStrength = rfd->RxBuffer[len+1];
+        macp->rxSignalQuality2 = rfd->RxBuffer[len+2];
+        //macp->rxNoiseReport = rfd->RxBuffer[len+3]; //3d31
+
+#ifdef HOST_IF_USB
+
+        macp->rxSignalQuality = CalculateQuality(macp, rfd, &macp->rxSignalQualityIndB);
+        macp->rxSignalStrength = CalculateStrength(macp, rfd);
+#endif
+#if ZDCONF_WE_STAT_SUPPORT == 1
+
+        Qual[Qidx++ % 10] = macp->rxSignalQuality;
+        Str[Qidx % 10] = macp->rxSignalStrength;
+
+        if(Qidx % 100 == 0)
+        {
+                Tmp = 0;
+                for(idx=0;idx<10;idx++)
+                        Tmp += Qual[idx];
+                macp->iwstats.qual.qual=Tmp/10;
+
+                Tmp = 0;
+                for(idx=0;idx<10;idx++)
+                        Tmp += Str[idx];
+                Tmp/=10;
+
+                Tmp = -(100 - Tmp);
+                Tmp = Tmp >  -40 ?  -40: Tmp;
+                Tmp = Tmp < -105 ? -105: Tmp;
+                Tmp = (Tmp + 105)*100/65;
+                macp->iwstats.qual.level= Tmp;
+
+                Tmp = -(100 - rfd->RxBuffer[len+3]);
+                Tmp = Tmp >  -40 ?  -40: Tmp;
+                Tmp = Tmp < -105 ? -105: Tmp;
+                Tmp = (Tmp + 105)*100/65;
+                macp->iwstats.qual.noise= Tmp;
+
+        }
+#elif !defined(ZDCONF_WE_STAT_SUPPORT)
+	#error "Undefine ZDCONF_WE_STAT_SUPPORT"
+#endif
+
+        macp->rxInfo.signalQuality = macp->rxSignalQuality;
+        macp->rxInfo.signalStrength = macp->rxSignalStrength;
+
+        return true;
+}
+
+/**
+ * zd1205_alloc_tcb_pool - allocate TCB circular list
+ * @macp: atapter's private data struct
+ *
+ * This routine allocates memory for the circular list of transmit descriptors.
+ *
+ * Returns:
+ *       0: if allocation has failed.
+ *       1: Otherwise.
+ */
+
+int
+zd1205_alloc_tcb_pool(struct zd1205_private *macp)
+{
+        /* deal with Tx uncached memory */
+        /* Allocate memory for the shared transmit resources with enough extra mem
+         * to paragraph align (4-byte alignment) everything  */
+
+        macp->txUnCachedSize = (macp->numTcb *
+                                (sizeof(zd1205_HwTCB_t)+ sizeof(zd1205_Ctrl_Set_t)+sizeof(zd1205_Header_t)))
+                               + (macp->numTbd * sizeof(zd1205_TBD_t));
+
+#ifndef HOST_IF_USB
+
+        if (!(macp->txUnCached = pci_alloc_consistent(macp->pdev,
+                                 macp->txUnCachedSize, &(macp->txUnCachedPhys))))
+        {
+                return 0;
+        }
+#else
+        macp->txUnCached = kmalloc(macp->txUnCachedSize, GFP_ATOMIC);
+        if (!macp->txUnCached)
+        {
+                printk(KERN_ERR "zd1205: kmalloc txCached failed\n");
+                return 0;
+        }
+#endif
+
+        memset(macp->txUnCached, 0x00, macp->txUnCachedSize);
+        return 1;
+}
+
+void
+zd1205_free_tcb_pool(struct zd1205_private *macp)
+{
+#ifndef HOST_IF_USB
+
+        pci_free_consistent(macp->pdev, macp->txUnCachedSize,
+
+                            macp->txUnCached, macp->txUnCachedPhys);
+#else
+
+        if (macp->txUnCached)
+                kfree(macp->txUnCached);
+#endif
+
+        macp->txUnCachedPhys = 0;
+
+}
+
+
+
+static void
+zd1205_free_rfd_pool(struct zd1205_private *macp)
+{
+        struct rx_list_elem *rx_struct;
+
+        while (!list_empty(&(macp->active_rx_list)))
+        {
+                rx_struct = list_entry(macp->active_rx_list.next,
+                                       struct rx_list_elem, list_elem);
+                list_del(&(rx_struct->list_elem));
+
+
+#ifndef HOST_IF_USB
+
+                pci_unmap_single(macp->pdev, rx_struct->dma_addr,
+
+                                 sizeof (zd1205_RFD_t), PCI_DMA_TODEVICE);
+                dev_kfree_skb(rx_struct->skb);
+#else
+
+                dev_kfree_skb(rx_struct->skb);
+#endif
+
+                kfree(rx_struct);
+        }
+
+
+        while (!list_empty(&(macp->rx_struct_pool)))
+        {
+                rx_struct = list_entry(macp->rx_struct_pool.next,
+                                       struct rx_list_elem, list_elem);
+                list_del(&(rx_struct->list_elem));
+                kfree(rx_struct);
+        }
+
+}
+
+
+
+/**
+ * zd1205_alloc_rfd_pool - allocate RFDs
+ * @macp: atapter's private data struct
+ 
+ *
+ * Allocates initial pool of skb which holds both rfd and data,
+ * and return a pointer to the head of the list
+ */
+
+
+
+static int
+zd1205_alloc_rfd_pool(struct zd1205_private *macp)
+{
+        struct rx_list_elem *rx_struct;
+        int i;
+
+
+
+        INIT_LIST_HEAD(&(macp->active_rx_list));
+        INIT_LIST_HEAD(&(macp->rx_struct_pool));
+        macp->skb_req = macp->numRfd;
+
+
+        for (i = 0; i < macp->skb_req; i++)
+        {
+                rx_struct = kmalloc(sizeof (struct rx_list_elem), GFP_ATOMIC);
+                list_add(&(rx_struct->list_elem), &(macp->rx_struct_pool));
+        }
+
+        zd1205_alloc_skbs(macp);
+        return !list_empty(&(macp->active_rx_list));
+}
+
+
+void
+
+zd1205_clear_pools(struct zd1205_private *macp)
+{
+        zd1205_dealloc_space(macp);
+        zd1205_free_rfd_pool(macp);
+
+        zd1205_free_tcb_pool(macp);
+}
+
+
+/**
+ * zd1205_start_ru - start the RU if needed
+ * @macp: atapter's private data struct
+ *
+ * This routine checks the status of the receive unit(RU),
+ * and starts the RU if it was not already active.  However,
+ * before restarting the RU, the driver gives the RU the buffers
+ * it freed up during the servicing of the ISR. If there are
+ * no free buffers to give to the RU, (i.e. we have reached a
+ * no resource condition) the RU will not be started till the
+  * next ISR.
+ */
+#ifndef HOST_IF_USB
+void zd1205_start_ru(struct zd1205_private *macp)
+#else
+struct rx_list_elem *zd1205_start_ru(struct zd1205_private *macp)
+#endif
+{
+#ifndef HOST_IF_USB
+        u32 tmp_value;
+        u32 loopCnt = 0;
+#endif
+
+        struct rx_list_elem *rx_struct = NULL;
+        struct list_head *entry_ptr = NULL;
+
+        zd1205_RFD_t *rfd = 0;
+        int buffer_found = 0;
+        struct sk_buff *skb;
+
+        ZENTER(4);
+
+        list_for_each(entry_ptr, &(macp->active_rx_list))
+        {
+                rx_struct = list_entry(entry_ptr, struct rx_list_elem, list_elem);
+
+                if (!rx_struct)
+#ifndef HOST_IF_USB
+
+                        return;
+#else
+
+                        return NULL;
+#endif
+
+#ifndef HOST_IF_USB
+
+                pci_dma_sync_single(macp->pdev, rx_struct->dma_addr,
+
+                                    macp->rfd_size, PCI_DMA_FROMDEVICE);
+#endif
+
+                skb = rx_struct->skb;
+                rfd = RFD_POINTER(skb, macp);	/* locate RFD within skb */
+
+                if (SKB_RFD_STATUS(rx_struct->skb, macp) !=  __constant_cpu_to_le32(RFD_STATUS_COMPLETE)) {
+                        buffer_found = 1;
+                        break;
+                }
+
+        }
+
+
+        /* No available buffers */
+        if (!buffer_found)
+        {
+                printk(KERN_ERR "zd1205: No available buffers\n");
+#ifndef HOST_IF_USB
+
+                return;
+#else
+
+                return NULL;
+#endif
+
+        }
+
+
+#ifndef HOST_IF_USB
+        while(1)
+        {
+                tmp_value = zd_readl(DeviceState);
+                tmp_value &= 0xf0;
+                if ((tmp_value == RX_READ_RCB) || (tmp_value == RX_CHK_RCB)) {
+                        /* Device is now checking suspend or not.
+                         Keep watching until it finished check. */
+                        loopCnt++;
+                        if (loopCnt > 10000000)
+                                break;
+
+                        udelay(1);
+                        continue;
+                } else {
+                        break;
+                }
+
+
+
+
+        }
+        if (loopCnt > 10000000)
+                ZD1211DEBUG(0, "I am in zd1205_start_ru loop\n");
+
+
+        if (tmp_value == RX_IDLE)
+        {
+                /* Rx bus master is in idle state. */
+                if ((u16)le32_to_cpu(rfd->CbStatus) != RFD_STATUS_COMPLETE) {
+                        zd1205_start_upload(rx_struct->dma_addr);
+
+                }
+        }
+
+        ZEXIT(4);
+
+        return;
+#else
+
+
+        return rx_struct;
+
+
+#endif
+}
+
+void zd1205_recycle_rx(struct zd1205_private *macp)
+{
+        struct rx_list_elem *rx_struct = NULL;
+        struct list_head *entry_ptr = NULL;
+        zd1205_RFD_t *rfd = 0;
+        struct sk_buff *skb;
+        ZENTER(4);
+
+        list_for_each(entry_ptr, &(macp->active_rx_list))
+        {
+                rx_struct = list_entry(entry_ptr, struct rx_list_elem, list_elem);
+                if (!rx_struct)
+                        return;
+
+                rx_struct->UnFinishFrmLen = 0;
+                skb = rx_struct->skb;
+                rfd = RFD_POINTER(skb, macp);	/* locate RFD within skb */
+                rfd->CbStatus = 0xffffffff;
+        }
+}
+
+
+void zd1205_CheckBeaconInfo(struct zd1205_private *macp, plcp_wla_Header_t *pWlanHdr, u8 *pMacBody, u32 bodyLen)
+{
+        u8 *pBssid;
+        u8 *pByte;
+        u32 currPos = 0;
+        u8 elemId, elemLen;
+        u8 Zd1202Detected = 0;
+        u8 BitmapCtrl;
+        u16 N1;
+        u16 N2;
+        u16 quotient;
+        u16 remainder;
+        u8 BssType = macp->cardSetting.BssType;
+        u8 erp;
+        u16 cap;
+        u8 preamble = 0;
+        u16 basicRateMap = 0;
+        u16 supRateMap = 0;
+        u8 bErpSta = 0;
+        int i;
+        u8 tmpMaxRate = 0x02;
+        u8 rate;
+        //u16 sequence_number;
+
+        cap =  (*(pMacBody + CAP_OFFSET)) + ((*(pMacBody + CAP_OFFSET +1)) << 8);
+
+        if (cap & BIT_1) //IBSS
+                pBssid = pWlanHdr->Address3;
+        else
+        {
+                pBssid = pWlanHdr->Address2;
+                if (BssType == INDEPENDENT_BSS)
+                        return;
+        }
+        //sequence_number = (*(u16*)(&pWlanHdr->SeqCtrl[0])) >> 4;
+
+        if (cap & BIT_5)
+                preamble = 1;
+        else
+                preamble = 0;
+
+        //get element
+        pByte = pMacBody + SSID_OFFSET;
+
+        currPos = SSID_OFFSET;
+
+        while(currPos < bodyLen)
+        {
+                elemId = *pByte;
+                elemLen = *(pByte+1);
+
+                switch (elemId) {
+                case ELEID_DSPARMS:
+                        if (BssType==INFRASTRUCTURE_BSS && macp->bAssoc && dot11Obj.Channel != *(pByte+2)) {
+                                macp->bAssoc=0;
+                                printk("Channel changed:%u to %u\n",dot11Obj.Channel,*(pByte+2));
+                                zd_CmdProcess(CMD_ROAMING,0,0);
+                        }
+                        pByte += (elemLen+2);
+                        break;
+                case ELEID_SSID:
+                        //printk("Get ssid\n");
+                        if (BssType == INFRASTRUCTURE_BSS && macp->bAssoc &&(dot11DesiredSsid.buf[1]==0)) // Any ssid
+                        {
+                                //printk("Rx ssidlen=%d\n",elemLen);
+
+                                if (memcmp((pByte+2),&dot11Obj.CurrSsid[2],elemLen)==0 && dot11Obj.CurrSsid[1]==elemLen)
+                                {
+                                        //   printk("SSID Same\n");
+                                } else
+                                {
+                                        macp->bAssoc=0;
+                                        printk("SSID Changed\n");
+                                        zd_CmdProcess(CMD_ROAMING,0,0);
+                                }
+                        }
+                        pByte += (elemLen+2);
+                        break;
+
+
+                case 0xfe:	//ZyDAS Extended Supported Rate (16.5M)
+                case 0xff:	//ZyDAS Extended Supported Rate (27.5M)
+                        Zd1202Detected = 1;
+
+                        if (elemLen != 0) { //For possible future compatibility issue,
+                                //we adopt "length = 0", which will not
+                                //disturb others.
+                        }
+                        pByte += (elemLen+2);
+                        break;
+
+                case ELEID_TIM:
+                        if ((BssType == INFRASTRUCTURE_BSS) && (macp->bAssoc)) {
+                                if (elemLen >= 3) {
+                                        BitmapCtrl = *(pByte+4);
+                                        N1 = (BitmapCtrl & ~BIT_0);
+                                        N2 = (elemLen + N1 - 4);
+                                        quotient = (dot11Obj.Aid >> 3);
+                                        remainder = (dot11Obj.Aid & 0x7);
+
+                                        if ((quotient < N1) || (quotient > N2)) {
+                                                macp->bAnyActivity = 0;
+                                                pByte += (elemLen+2);
+                                                break;
+                                        }
+
+                                        if ((*(pByte+5+quotient-N1) >> remainder) & BIT_0) {
+                                                //ZD1211DEBUG(1, "TIM: More data at SequNum=%u\n",sequence_number);
+                                                zd_EventNotify(EVENT_MORE_DATA, 0, 0, 0);
+                                                macp->bAnyActivity = 1;
+                                                //ZD1211DEBUG(2, "EVENT_MORE_DATA!\n");
+                                                //zd1205_dump_data("TIM", pByte, elemLen+2);
+                                                //zd1205_dump_data("pMacBody", (u8 *)pMacBody, bodyLen);
+                                        } else {
+                                                macp->bAnyActivity = 0;
+                                        }
+
+                                        // Multicast frames queued in AP
+                                        if (BitmapCtrl & BIT_0) {
+                                                ZD1211DEBUG(1, "Got multicast framed queued information!\n");
+                                                macp->bAnyActivity = 1;
+                                        }
+                                }
+                        }
+                        pByte += (elemLen+2);
+                        break;
+
+
+                case ELEID_ERP_INFO:
+                        if (macp->bAssoc) {
+                                erp = *(pByte+2);
+
+                                if (erp & USE_PROTECTION_BIT) {
+                                        if (!(dot11Obj.ConfigFlag & ENABLE_PROTECTION_SET))
+                                                defer_kevent(macp, KEVENT_EN_PROTECTION);
+                                } else {
+                                        if (dot11Obj.ConfigFlag & ENABLE_PROTECTION_SET)
+                                                defer_kevent(macp, KEVENT_DIS_PROTECTION);
+                                }
+
+                                // check Barker_Preamble_Mode
+                                if (erp & BARKER_PREAMBLE_BIT) {
+                                        if (!(dot11Obj.ConfigFlag & BARKER_PREAMBLE_SET))
+                                                defer_kevent(macp, KEVENT_EN_BARKER);
+                                } else {
+                                        if (dot11Obj.ConfigFlag & BARKER_PREAMBLE_SET)
+                                                defer_kevent(macp, KEVENT_DIS_BARKER);
+                                }
+
+                                // check B-STA
+                                if (erp & NON_ERP_PRESENT_BIT) {
+                                        if (dot11Obj.ConfigFlag & SHORT_SLOT_TIME_SET) {
+                                                defer_kevent(macp, KEVENT_DIS_SHORT_SLOT);
+                                        }
+                                } else {
+                                        if (!(dot11Obj.ConfigFlag & SHORT_SLOT_TIME_SET)) {
+                                                defer_kevent(macp, KEVENT_EN_SHORT_SLOT);
+                                        }
+                                }
+                        }
+
+                        pByte += (elemLen+2);
+                        break;
+
+                case ELEID_SUPRATES:
+                        if ((BssType == INDEPENDENT_BSS) && (macp->bAssoc)) {
+                                zd_makeRateInfoMAP(pByte, &basicRateMap, &supRateMap);
+                                for (i=0; i<elemLen; i++) {
+                                        rate = *(pByte+2+i);
+                                        if ((rate & 0x7f) > tmpMaxRate)
+                                                tmpMaxRate = (rate & 0x7f);
+                                }
+                        }
+                        pByte += (elemLen+2);
+                        break;
+
+                case ELEID_EXT_RATES:
+                        if ((BssType == INDEPENDENT_BSS) && (macp->bAssoc)) {
+                                zd_makeRateInfoMAP(pByte, &basicRateMap, &supRateMap);
+
+                                for (i=0; i<elemLen; i++) {
+                                        rate = *(pByte+2+i);
+                                        if ((rate & 0x7f) > tmpMaxRate)
+                                                tmpMaxRate = (rate & 0x7f);
+                                }
+                        }
+
+                        pByte += (elemLen+2);
+                        break;
+
+                default:
+                        pByte += (elemLen+2);
+                        break;
+
+                }
+
+                currPos += (elemLen+2);
+        }
+
+
+        if (Zd1202Detected)
+        {
+                macp->BSS_Members |= MEMBER_ZD1202;
+        } else
+        {
+                macp->BSS_Members |= MEMBER_OTHERS;
+        }
+
+        if ((BssType == INDEPENDENT_BSS) && (macp->bAssoc))
+        {
+                if (supRateMap > 0x0f) {  //support rates include OFDM rates
+                        if (basicRateMap & ~0xf) // basic rates include OFDM rates
+                                bErpSta = 1;
+                        else
+                                bErpSta = 1;
+                } else
+                        bErpSta = 0;
+
+                zd_UpdateIbssInfo(pWlanHdr->Address2, tmpMaxRate, preamble, bErpSta);
+                if ((macp->cardSetting.MacMode != PURE_A_MODE) &&(macp->cardSetting.MacMode != PURE_B_MODE) &&  (!bErpSta)) {
+                        if (!(dot11Obj.ConfigFlag & ENABLE_PROTECTION_SET)) {
+#ifdef HOST_IF_USB
+                                defer_kevent(macp, KEVENT_EN_PROTECTION);
+                                ZD1211DEBUG(2, "KEVENT_EN_PROTECTION\n");
+#else
+
+                                zd_EventNotify(EVENT_ENABLE_PROTECTION, 1, 0, 0);
+#endif
+
+                        }
+                }
+        }
+
+        macp->Bcn_Acc_Num++;
+        macp->Bcn_Acc_SQ += macp->rxInfo.signalQuality;
+        return;
+}
+
+
+
+#define ETH_P_80211_RAW     (ETH_P_ECONET + 1)
+
+/**
+ * zd1205_rx_isr - service RX queue
+ * @macp: atapter's private data struct
+ * @max_number_of_rfds: max number of RFDs to process
+ * @rx_congestion: flag pointer, to inform the calling function of congestion.
+ *
+ * This routine processes the RX interrupt & services the RX queues.
+ * For each successful RFD, it allocates a new msg block, links that
+ 
+ * into the RFD list, and sends the old msg upstream.
+ * The new RFD is then put at the end of the free list of RFD's.
+ * It returns the number of serviced RFDs.
+ */
+
+u32 zd1205_rx_isr(struct zd1205_private *macp)
+{
+        zd1205_RFD_t *rfd;		/* new rfd, received rfd */
+        int i;
+        u32 rfd_status;
+        struct sk_buff *skb;
+        struct net_device *dev;
+        u32 data_sz;
+        struct rx_list_elem *rx_struct;
+        u32 rfd_cnt = 0;
+        plcp_wla_Header_t *wla_hdr;
+        u8 *pHdr;
+        u8 *pIv;
+        u8 *pBody = NULL;
+        u32 bodyLen = 0;
+        u32 hdrLen = WLAN_HEADER;
+        u16 seq = 0;
+        u8 frag = 0;
+        u8 *pTa = NULL;
+        defrag_Array_t *pDefArray = &macp->defragArray;
+        u8 EthHdr[12];
+        card_Setting_t *pSetting = &macp->cardSetting;
+        u8 bDataFrm = 0;
+        u8 BaseFrmType = 0;
+        int SaIndex = 0;
+        u8 BssType=pSetting->BssType;
+        u8 bSwCheckMIC=0;
+        u8 rxDecryType = 0;
+
+#ifdef HOST_IF_USB
+    #if fMERGE_RX_FRAME
+
+        int rx_cnt;
+        struct rx_list_elem **rx_struct_array = macp->rx_struct_array;
+        int total_rx_cnt = macp->total_rx_cnt;
+#else
+
+        u8 RunOnce = 0;
+#endif
+#endif
+
+        ZENTER(4);
+        dev = macp->device;
+        /* current design of rx is as following:
+         * 1. socket buffer (skb) used to pass network packet to upper layer
+         * 2. all HW host memory structures (like RFDs, RBDs and data buffers)
+         *    are placed in a skb's data room
+         * 3. when rx process is complete, we change skb internal pointers to exclude
+         *    from data area all unrelated things (RFD, RDB) and to leave
+         *    just rx'ed packet netto
+         * 4. for each skb passed to upper layer, new one is allocated instead.
+         * 5. if no skb left, in 2 sec another atempt to allocate skbs will be made
+         *    (watchdog trigger SWI intr and isr should allocate new skbs)
+         */
+
+
+#if fMERGE_RX_FRAME //USB
+
+        for (rx_cnt=0; rx_cnt<total_rx_cnt; rx_cnt++)
+        {
+#else //PCI
+        for (i=0; i<macp->numRfd; i++) {
+#endif
+
+#if fMERGE_RX_FRAME
+                rx_struct = rx_struct_array[rx_cnt];
+                skb = rx_struct->skb;
+                rfd = RFD_POINTER(skb, macp);
+                rfd_status = SKB_RFD_STATUS(rx_struct->skb, macp);
+
+                if (rfd_status != __constant_cpu_to_le32(RFD_STATUS_COMPLETE))	/* does not contains data yet - exit */
+                        break;
+                macp->DriverRxFrmCnt ++;
+#else   //end of fMERGE_RX_FRAME
+
+                if (list_empty(&(macp->active_rx_list))) {
+                        printk(KERN_ERR "zd1205: list_empty\n");
+                        break;
+                }
+
+                rmb();
+
+                rx_struct = list_entry(macp->active_rx_list.next,
+                                       struct rx_list_elem, list_elem);
+
+                ZD1211DEBUG(4, "zd1211: rx_struct = %x\n", (u32)rx_struct);
+                skb = rx_struct->skb;
+                rfd = RFD_POINTER(skb, macp);	/* locate RFD within skb */
+
+                // sync only the RFD header
+#ifndef HOST_IF_USB
+
+                pci_dma_sync_single(macp->pdev, rx_struct->dma_addr,
+                                    macp->rfd_size+PLCP_HEADER+WLAN_HEADER, PCI_DMA_FROMDEVICE);
+#endif
+
+                rfd_status = SKB_RFD_STATUS(rx_struct->skb, macp);	/* get RFD's status */
+
+                ZD1211DEBUG(4, "zd1211: rfd_status = %x\n", rfd_status);
+                if (rfd_status != __constant_cpu_to_le32(RFD_STATUS_COMPLETE))	/* does not contains data yet - exit */
+                        break;
+
+#ifdef HOST_IF_USB
+
+                if (RunOnce)
+                        break;
+                RunOnce = 1;
+#endif
+
+                macp->DriverRxFrmCnt ++;
+                /* to allow manipulation with current skb we need to unlink it */
+                list_del(&(rx_struct->list_elem));
+
+#ifdef HOST_IF_USB
+
+                zd1211_submit_rx_urb(macp);
+#endif
+
+#endif //end of !fMERGE_RX_FRAME
+
+                bSwCheckMIC=0;
+
+                data_sz = (u16)(le32_to_cpu(rfd->ActualCount) & 0x3fff);
+                data_sz -= macp->rxOffset;
+                ZD1211DEBUG(4, "zd1211: data_sz = %x\n", data_sz);
+#if 0
+                //for debug only
+                if (macp->bPSMSupported)
+                        zd1205_dump_data("RxBuffer", (u8 *)rfd->RxBuffer, data_sz);
+
+                //zd1205_add_skb_to_end(macp, rx_struct);
+                //continue;
+#endif
+
+                wla_hdr = (plcp_wla_Header_t *)&rfd->RxBuffer[macp->rxOffset];
+                pHdr = (u8 *)wla_hdr + PLCP_HEADER;
+
+                /*
+                		u8 *mb = hdrLen+ pHdr;
+                		if(mb[0] == 0xf0 && mb[1] == 0xf0)
+                			printk("Get NETBIOS\n");
+                */
+
+                if (SubFrameType(wla_hdr) != BEACON) {
+                        macp->bFrmRxed1 = 1;
+                }
+
+                        /* ath_desc: add monitor mode */
+                        BaseFrmType = BaseFrameType(wla_hdr);
+
+                        if ((BaseFrmType == DATA) || (BaseFrmType == MANAGEMENT)) { //Data or Management Frames
+                                /* do not free & unmap badly recieved packet.
+                                 * move it to the end of skb list for reuse */
+
+#ifndef HOST_IF_USB
+                                //sync for access correctly
+                                pci_dma_sync_single(macp->pdev, rx_struct->dma_addr,
+                                                    data_sz + macp->rfd_size, PCI_DMA_FROMDEVICE);
+#endif
+
+                                if (zd1205_validate_frame(macp, rfd) == false) {
+                                        //int i;
+                                        //int frame_len=(le32_to_cpu(rfd->ActualCount)&0x3fff)-macp->rxOffset;
+                                        ZD1211DEBUG(4, "zd1211: invalid frame\n");
+                                        //plcp_wla_Header_t *wla_hdrb;
+                                        //printk("zd1211: invalid frame\n");
+                                        //printk("\nAddr1: ");
+                                        //for(i=0;i<6;i++)
+                                        //	printk("%02x ",	wla_hdr->Address1[i]);
+                                        //printk("\nAddr2: ");
+                                        //for(i=0;i<6;i++)
+                                        //    printk("%02x ", wla_hdr->Address2[i]);
+                                        //printk("\nAddr3: ");
+                                        //for(i=0;i<6;i++)
+                                        //    printk("%02x ", wla_hdr->Address3[i]);
+                                        //printk("\nDuration:%d",*(u16 *)wla_hdr->Duration);
+                                        //printk("\nFrmCtl:%d",*(u16 *)wla_hdr->FrameCtrl);
+                                        //printk("\nLength:%d\n",frame_len);
+
+
+                                        macp->invalid_frame_good_crc ++;
+                                        zd1205_add_skb_to_end(macp, rx_struct);
+                                        continue;
+                                }
+                        }
+
+                        if (!macp->sniffer_on && (BssType != IW_MODE_MONITOR)) {
+                            if ((BaseFrmType == DATA) || (BaseFrmType == MANAGEMENT)) {
+                                seq = getSeq(wla_hdr);
+                                frag = getFrag(wla_hdr);
+                                pTa = getTA(wla_hdr);
+
+                                if (!bGroup(wla_hdr)) { //unicast
+                                        if (memcmp(&wla_hdr->Address1[0], &macp->macAdr[0], 6) != 0) {
+                                                zd1205_add_skb_to_end(macp, rx_struct);
+                                                continue;
+                                        } else { //check dupicated frame
+                                                //if (BaseFrmType == DATA)
+                                                //zd1205_dump_data("RxBuffer", (u8 *)rfd->RxBuffer, data_sz);
+
+                                                if ((bRetryBit(wla_hdr))
+                                                                && (zd1205_SearchTupleCache(macp, pTa, seq, frag))) { //dupicated
+                                                        zd1205_UpdateTupleCache(macp, pTa, seq, frag);
+                                                        zd1205_add_skb_to_end(macp, rx_struct);
+                                                        macp->rxDupCnt ++;
+                                                        continue;
+                                                }
+                                                zd1205_UpdateTupleCache(macp, pTa, seq, frag);
+                                        }
+                                } else { //group address
+                                        // check if the address1 of the multicast frame is in the multicast list
+                                        if (wla_hdr->Address1[0] != 0xff) {
+                                                int tmpvalue = -1;
+                                                //zd1205_dump_data("address1", (u8 *)wla_hdr->Address1, 6);
+
+                                                for(i=0; i<macp->MulticastAddr[0]; i++) {
+                                                        tmpvalue = memcmp(&macp->MulticastAddr[6*i+1], wla_hdr->Address1, 6);
+
+                                                        if (tmpvalue == 0)
+                                                                break;
+                                                }
+
+                                                //If the address is not registerd multicast addr.
+                                                //and not if promisc || All multicast mode.Drop It.
+                                                if ((tmpvalue != 0) &&
+                                                                !(dev->flags & IFF_PROMISC) &&
+                                                                !(dev->flags & IFF_ALLMULTI)) {
+
+                                                        zd1205_add_skb_to_end(macp, rx_struct);
+                                                        ZD1211DEBUG(1, " - address1 is not in the multicast list\n");
+                                                        continue;
+                                                }
+                                        }
+
+                                        if (BaseFrameType(wla_hdr) == DATA) {
+                                                if (BssType == INFRASTRUCTURE_BSS) {
+                                                        if (memcmp(&macp->BSSID[0], &wla_hdr->Address2[0], 6) != 0) {
+                                                                //BSSID filter
+                                                                zd1205_add_skb_to_end(macp, rx_struct);
+                                                                continue;
+                                                        }
+                                                } else if ((BssType == INDEPENDENT_BSS) || (BssType == PSEUDO_IBSS)) {
+                                                        if (memcmp(&macp->BSSID[0], &wla_hdr->Address3[0], 6) != 0) {
+                                                                //BSSID filter
+                                                                zd1205_add_skb_to_end(macp, rx_struct);
+                                                                continue;
+                                                        }
+                                                } else {
+                                                        zd1205_add_skb_to_end(macp, rx_struct);
+                                                        continue;
+                                                }
+                                        } else {
+                                                ;//ZD1211DEBUG(3, "Group Mgt Frame\n");
+                                        }
+                                }
+
+                                hdrLen = WLAN_HEADER;
+                                pBody = (u8 *)pHdr + WLAN_HEADER;
+                                bodyLen = data_sz - PLCP_HEADER - WLAN_HEADER - EXTRA_INFO_LEN - CRC32_LEN;
+
+                                //frame with WEP
+                                if (bWepBit(wla_hdr)) {
+                                        u16 RxIv16 = 0;
+                                        u32 RxIv32 = 0;
+                                        ZD1211DEBUG(4, "zd1205: wep frame\n");
+
+                                        pIv =  pHdr +  hdrLen;
+                                        pBody += IV_SIZE;
+                                        bodyLen =  bodyLen - IV_SIZE - ICV_SIZE;
+                                        hdrLen += IV_SIZE;
+                                        rxDecryType = (macp->rxDecryType & 0x0f);
+
+                                        switch(rxDecryType) {
+                                        case WEP64:
+                                        case WEP128:
+                                        case WEP256:
+                                                break;
+
+                                        case TKIP:
+                                                bSwCheckMIC=1;// zd1211 always use sw-mic regardless of fragmentation.
+                                                bodyLen -= EXTEND_IV_LEN;
+                                                pBody += EXTEND_IV_LEN;
+                                                hdrLen += EXTEND_IV_LEN;
+#if 0 // zd1211 does not have hw-mic feature.
+
+                                                if (macp->rxDecryType & RX_MIC_ERROR_IND) {
+                                                        printk("hw mic error!\n");
+                                                        if (dot11Obj.MicFailure) {//For hostapd
+                                                                //dot11Obj.MicFailure(&wla_hdr->Address2[0]);
+                                                        }
+                                                        //SDMichaelFailureDetected((UCHAR*) &wla_hdr->Address2[0]);// For hostapd
+                                                        //		        hostap_michael_mic_failure((zd1205_private_t *)g_dev->priv, (struct hostap_ieee80211_hdr *)pHdr, (int)pIv[3] & KEYID_MASK); // For Xsupplicant.
+
+                                                }
+
+#endif
+                                                RxIv16 = ((u16)pIv[0] << 8) + pIv[2];
+                                                RxIv32 = pIv[4] + ((u32)pIv[5] << 8) + ((u32)pIv[6] << 16) + ((u32)pIv[7] << 24);
+                                                // check iv sequence
+                                                break;
+
+                                        case AES:
+                                                ZD1211DEBUG(2, "Got AES frame !!!\n");
+                                                bodyLen -= (MIC_LENGTH);
+                                                pBody += EXTEND_IV_LEN;
+                                                hdrLen += EXTEND_IV_LEN;
+                                                break;
+                                        default:
+                                                break;
+                                        }
+                                }//end of wep bit
+                                if (BssType == AP_BSS) {
+                                        memcpy(EthHdr, &wla_hdr->Address3[0], 6); 		// copy DA
+                                        memcpy(&EthHdr[6], &wla_hdr->Address2[0], 6);	// copy SA
+                                } else if (BssType == INFRASTRUCTURE_BSS) {
+                                        memcpy(EthHdr, &wla_hdr->Address1[0], 6); 		// copy DA
+                                        memcpy(&EthHdr[6], &wla_hdr->Address3[0], 6);	// copy SA
+                                        //If we got a broadcast frame with Add3 is ourself. Drop it.
+                                        // This kind of packet is from our broadcast reqest to AP . 					// And AP rebroadcast it .
+                                        if( bGroup(wla_hdr) &&
+                                                        memcmp(macp->macAdr,wla_hdr->Address3, 6) == 0)  {
+                                                zd1205_add_skb_to_end(macp, rx_struct);
+                                                continue;
+
+                                        }
+
+                                } else if ((BssType == INDEPENDENT_BSS) || (BssType == PSEUDO_IBSS)) {
+                                        memcpy(EthHdr, &wla_hdr->Address1[0], 6); 		// copy DA
+                                        memcpy(&EthHdr[6], &wla_hdr->Address2[0], 6);	// copy SA
+                                }
+
+                                if ((BaseFrmType == DATA)) {
+                                        bDataFrm = 1;
+
+                                        if (isWDS(wla_hdr)) {
+                                                //ZD1211DEBUG(3, "***** WDS or group\n");
+                                                zd1205_add_skb_to_end(macp, rx_struct);
+                                                continue;
+                                        }
+                                        if (frag == 0) { //No fragment or first fragment
+                                                if (!bMoreFrag(wla_hdr)) { //No more fragment
+                                                        //ZD1211DEBUG(2, "***** No Frag\n");
+                                                        //if (rxDecryType == TKIP)
+                                                        //	    bodyLen -= MIC_LENGTH;
+                                                        goto defrag_ind;
+                                                } else {	//First fragment
+                                                        DFDEBUG("***** First Frag");
+                                                        macp->rxNeedFragCnt++;
+                                                        i = zd1205_ArFree(macp); //Get a free one
+
+                                                        if (i < 0) {
+                                                                zd1205_ArAge(macp, nowT());
+                                                                i = zd1205_ArFree(macp);
+                                                                if (i < 0) {
+                                                                        DFDEBUG("***** ArFree fail");
+                                                                        macp->DropFirstFragCnt++;
+                                                                        zd1205_add_skb_to_end(macp, rx_struct);
+                                                                        continue;
+                                                                }
+                                                        }
+
+                                                        zd1205_ArUpdate(macp, pTa, seq, frag, i);
+                                                        pDefArray->mpdu[i].dataStart = pBody;
+                                                        skb->len = bodyLen;
+                                                        pDefArray->mpdu[i].buf = (void *)skb; //save skb
+
+#ifndef HOST_IF_USB
+
+                                                        pci_unmap_single(macp->pdev, rx_struct->dma_addr,
+                                                                         sizeof (zd1205_RFD_t), PCI_DMA_FROMDEVICE);
+#endif
+
+                                                        list_add(&(rx_struct->list_elem), &(macp->rx_struct_pool));
+                                                        macp->skb_req++;	/* incr number of requested skbs */
+#ifndef HOST_IF_USB
+
+                                                        zd1205_alloc_skbs(macp);	/* and get them */
+#else
+
+                                                        tasklet_schedule(&macp->rx_buff_tasklet);
+#endif
+
+                                                        rfd_cnt++;
+                                                        zd1205_ArAge(macp, nowT());
+                                                        continue;
+                                                }
+                                        }//end of farg == 0
+                                        else { //more frag
+                                                struct sk_buff *defrag_skb;
+                                                u8 *pStart;
+
+                                                i = zd1205_ArSearch(macp, pTa, seq, frag); //Get exist one
+                                                if (i < 0) {
+                                                        DFDEBUG("***** ArSearch fail");
+                                                        macp->ArSearchFailCnt++;
+                                                        zd1205_ArAge(macp, nowT());
+                                                        zd1205_add_skb_to_end(macp, rx_struct); //discard this one
+                                                        continue;
+                                                }
+
+                                                defrag_skb = (struct sk_buff *)pDefArray->mpdu[i].buf;
+                                                pStart = (u8 *)pDefArray->mpdu[i].dataStart;
+                                                pDefArray->mpdu[i].fn = frag;
+
+                                                memcpy((pStart+defrag_skb->len), pBody, bodyLen); //copy to reassamble buffer
+                                                defrag_skb->len += bodyLen;
+
+                                                if (!bMoreFrag(wla_hdr)) { //Last fragment
+                                                        DFDEBUG("***** Last Frag");
+                                                        zd1205_add_skb_to_end(macp, rx_struct);
+                                                        pDefArray->mpdu[i].inUse = 0;
+                                                        skb = defrag_skb;
+                                                        skb->data = (u8 *)pDefArray->mpdu[i].dataStart; //point mac body
+                                                        pBody = skb->data;
+                                                        bodyLen = skb->len;
+                                                        macp->rxCompFragCnt++;
+                                                        //if (rxDecryType == TKIP)
+                                                        //	    bSwCheckMIC = 1;
+
+                                                        //goto defrag_ind; //bug
+                                                        goto defrag_comp;
+                                                } else {
+                                                        DFDEBUG("***** More Frag");
+                                                        zd1205_ArAge(macp, nowT());
+                                                        zd1205_add_skb_to_end(macp, rx_struct);
+                                                        continue;
+                                                }
+                                        }
+                                }//end of data frame
+                                else if (BaseFrameType(wla_hdr) == MANAGEMENT) {
+                                        if (SubFrameType(wla_hdr) == BEACON) {
+                                                if (BssType == AP_BSS) {
+                                                        if (dot11Obj.ConfigFlag & PASSIVE_CHANNEL_SCAN_SET) {
+                                                                zd1205_CollectBssInfo(macp, wla_hdr, pBody, bodyLen);
+                                                        }
+#if defined(OFDM)
+                                                        if (pSetting->MacMode != PURE_B_MODE &&	pSetting->MacMode != PURE_A_MODE) {
+                                                                if (!dot11Obj.ConfigFlag & ENABLE_PROTECTION_SET) {
+                                                                        if (zd1205_CheckOverlapBss(macp, wla_hdr, pBody, bodyLen)) {
+                                                                                // ebable protection mode
+                                                                                macp->bOLBC++;
+                                                                                if (!(dot11Obj.ConfigFlag & ENABLE_PROTECTION_SET) && (macp->bOLBC >= 3)) {
+#ifdef HOST_IF_USB
+                                                                                        defer_kevent(macp, KEVENT_EN_PROTECTION);
+#else
+
+                                                                                        zd_EventNotify(EVENT_ENABLE_PROTECTION, 1, 0, 0);
+#endif
+                                                                                }
+                                                                        }
+                                                                }
+                                                        }
+#endif
+                                                        zd1205_add_skb_to_end(macp, rx_struct);
+                                                        continue;
+                                                } else { //STA mode
+                                                        if (dot11Obj.ConfigFlag & ACTIVE_CHANNEL_SCAN_SET) //path through
+                                                                goto defrag_ind;
+                                                        else {
+                                                                if (memcmp(&macp->BSSID[0], &wla_hdr->Address3[0], 6) == 0) { //BSSID filter
+                                                                        macp->bcnCnt++;
+                                                                        zd1205_CheckBeaconInfo(macp, wla_hdr, pBody, bodyLen);
+                                                                        if (macp->bPSMSupported) {
+                                                                                ZD1211DEBUG(0, "AP is alive due to Bcn Rcvd\n");
+                                                                        }
+                                                                        macp->bAPAlive = 1;
+                                                                }
+#if 0
+                                                                else {
+                                                                        if ((pSetting->MacMode != PURE_B_MODE) && (BssType == INDEPENDENT_BSS)) {
+                                                                                if (!dot11Obj.ConfigFlag & ENABLE_PROTECTION_SET) {
+                                                                                        if (zd1205_CheckOverlapBss(macp, wla_hdr, pBody, bodyLen)) {
+                                                                                                // ebable protection mode
+#ifdef HOST_IF_USB
+
+                                                                                                defer_kevent(macp, KEVENT_EN_PROTECTION);
+#else
+
+                                                                                                zd_EventNotify(EVENT_ENABLE_PROTECTION, 1, 0, 0);
+#endif
+
+                                                                                        }
+                                                                                }
+                                                                        }
+                                                                }
+
+#endif
+                                                                //discard Beacon
+                                                                zd1205_add_skb_to_end(macp, rx_struct); /* discard Beacon frames */
+                                                                continue;
+                                                        }
+                                                }
+                                        } else {
+                                                if (bGroup(wla_hdr)) {
+                                                        if ((BssType != AP_BSS) || (BssType != INDEPENDENT_BSS)) {
+                                                                zd1205_add_skb_to_end(macp, rx_struct);
+                                                                continue;
+                                                        }
+                                                }
+                                        }
+
+                                        goto defrag_ind;
+                                } //end of management frame
+                        } else if (SubFrameType(wla_hdr) == PS_POLL) {
+                                if (BssType==AP_BSS && memcmp(&wla_hdr->Address1[0], &macp->macAdr[0], 6) == 0) //Ps-Poll for me
+                                        zd_CmdProcess(CMD_PS_POLL, (void *)pHdr, 0);
+                                zd1205_add_skb_to_end(macp, rx_struct);
+                                continue;
+                        } else {
+                                zd1205_add_skb_to_end(macp, rx_struct);
+                                continue;
+                        }
+                }//end of not sniffer_on and not monitor mode
+
+
+defrag_ind:
+                macp->rxCnt++;
+#ifndef HOST_IF_USB
+
+                pci_unmap_single(macp->pdev, rx_struct->dma_addr,
+                                 sizeof (zd1205_RFD_t), PCI_DMA_FROMDEVICE);
+
+#endif
+
+                list_add(&(rx_struct->list_elem), &(macp->rx_struct_pool));
+                /* end of dma access to rfd */
+                macp->skb_req++;	/* incr number of requested skbs */
+#ifndef HOST_IF_USB
+
+                zd1205_alloc_skbs(macp);	/* and get them */
+
+#else
+
+                tasklet_schedule(&macp->rx_buff_tasklet);
+#endif
+
+defrag_comp:
+                macp->rxInfo.bSwCheckMIC = bSwCheckMIC;
+
+                rfd_cnt++;
+                if ((!macp->sniffer_on) && (BssType != IW_MODE_MONITOR)) {
+                        if (BaseFrmType == DATA)
+                                macp->TotalRxDataFrmBytes += (hdrLen+bodyLen);
+
+                        macp->rxInfo.bDataFrm = BaseFrmType;
+                        macp->rxInfo.SaIndex = SaIndex;
+
+                        if ((BssType == INFRASTRUCTURE_BSS) && (macp->bAssoc)) {
+                                if (memcmp(&macp->BSSID[0], &wla_hdr->Address2[0], 6) == 0) {
+
+                                        macp->bAPAlive = 1;
+
+                                        if ((macp->bPSMSupported) && (macp->PwrState) && (!dot11Obj.bDeviceInSleep)) {
+                                                if (bMoreData(wla_hdr)) {
+                                                        // More date in AP
+                                                        zd_EventNotify(EVENT_MORE_DATA, 0, 0, 0);
+                                                }
+                                        }
+                                }
+                        }
+
+                        zd_ReceivePkt(pHdr, hdrLen, pBody, bodyLen, (void *)skb, EthHdr, &macp->rxInfo);
+                        macp->bDataTrafficLight = 1;
+                } else {
+                        skb->tail = skb->data = pHdr;
+                        /* ath_desc: fix monitor mode frame length */
+                        skb_put(skb, data_sz - PLCP_HEADER - EXTRA_INFO_LEN - CRC32_LEN);
+                        skb->mac.raw = skb->data;
+                        skb->pkt_type = PACKET_OTHERHOST;
+                        skb->protocol = __constant_htons(ETH_P_802_2);
+                        skb->dev = dev;
+                        skb->ip_summed = CHECKSUM_NONE;
+                        memset(skb->cb, 0, sizeof(skb->cb));
+                        netif_rx(skb);
+                }
+        }/* end of rfd loop */
+
+#ifdef HOST_IF_USB
+    #if !fMERGE_RX_FRAME
+        if (!RunOnce)
+                zd1211_submit_rx_urb(macp);
+#endif
+
+        if (dot11Obj.QueueFlag & TX_QUEUE_SET) {
+                macp->txQueSetCnt++;
+                //tasklet_schedule(&macp->zd1205_tx_tasklet);
+                zd_CleanupTxQ();
+        }
+
+#else
+        /* restart the RU if it has stopped */
+        zd1205_start_ru(macp);
+#endif
+
+        ZEXIT(4);
+        return rfd_cnt;
+}
+
+/**
+ * zd1205_intr - interrupt handler
+ * @irq: the IRQ number
+ * @dev_inst: the net_device struct
+ * @regs: registers (unused)
+ *
+ * This routine is the ISR for the zd1205 board. It services
+ * the RX & TX queues & starts the RU if it has stopped due
+ * to no resources.
+ */
+
+#ifndef HOST_IF_USB
+void
+zd1205_intr(int irq, void *dev_inst, struct pt_regs *regs)
+{
+        struct net_device *dev;
+        struct zd1205_private *macp;
+        void *regp;
+        u32 intr_status;
+        dev = dev_inst;
+        macp = dev->priv;
+        regp = macp->regp;
+
+        intr_status = zd_readl(InterruptCtrl);
+
+        if (!intr_status)
+
+                return;
+
+
+        /* disable intr before we ack & after identifying the intr as ours */
+        zd1205_disable_int();
+
+
+        /* the device is closed, don't continue or else bad things may happen. */
+
+        if (!netif_running(dev))
+        {
+                zd1205_enable_int();
+                return;
+
+        }
+
+        if (macp->driver_isolated)
+        {
+                goto exit;
+
+        }
+
+
+
+        {
+                /* Then, do Rx as soon as possible */
+                if (intr_status & RX_COMPLETE) {
+                        zd_writel((intr_status | RX_COMPLETE), InterruptCtrl);
+                        macp->drv_stats.rx_intr_pkts += zd1205_rx_isr(macp);
+                }
+
+                /* Then, recycle Tx chain/descriptors */
+                if (intr_status & TX_COMPLETE) {
+                        zd_writel((intr_status | TX_COMPLETE), InterruptCtrl);
+                        zd1205_tx_isr(macp);
+                        macp->TxStartTime = 0;
+                }
+
+
+                if (intr_status & RETRY_FAIL) {
+                        zd_writel((intr_status | RETRY_FAIL), InterruptCtrl);
+                        zd1205_retry_failed(macp);
+                        macp->TxStartTime = 0;
+                }
+
+
+                if (intr_status & CFG_NEXT_BCN) {
+                        zd_writel((intr_status | CFG_NEXT_BCN), InterruptCtrl);
+
+                        if (macp->config_next_bcn_en) {
+                                macp->bcnCnt++;
+                                zd_EventNotify(EVENT_TBCN, 0, 0, 0);
+
+                                if (macp->cardSetting.BssType == INDEPENDENT_BSS) {
+                                        macp->bFrmRxed1 = 0;
+                                } else if (macp->cardSetting.BssType == AP_BSS) {
+                                        if (macp->dtimCount == 0)
+
+                                                macp->dtimCount = macp->cardSetting.DtimPeriod;
+                                        macp->dtimCount--;
+                                }
+                        }
+
+                }
+
+
+                if (intr_status & DTIM_NOTIFY) {
+                        zd_writel((intr_status | DTIM_NOTIFY), InterruptCtrl);
+
+                        if (macp->dtim_notify_en) {
+                                macp->dtimCnt++;
+                                zd1205_dtim_notify(macp);
+                        }
+                }
+
+
+                if (intr_status & BUS_ABORT) {
+                        if (!dot11Obj.bDeviceInSleep)
+                                ZD1211DEBUG(0, "******Bus Abort!!!\n");
+                        zd_writel(0xff, InterruptCtrl);
+                        //zd1205_sleep_reset(macp);
+                }
+
+
+                if (intr_status & WAKE_UP) {
+                        //ZD1211DEBUG(1, "******WAKE_UP!!!\n");
+                        zd_writel((intr_status | WAKE_UP), InterruptCtrl);
+
+                        if (dot11Obj.bDeviceInSleep) {
+                                //++ After wake up, we should ignore all interrupt except for Wakeup Interrupt.
+                                //	 This is very important!
+                                //	 If, we do not obey this, the following bug might occurs:
+                                //
+                                //	-------------------------------------------------------------------> time
+                                //	^		^			^			^			^			^
+                                //	|		|			|			|			|			|
+                                //	Sleep	|			Process		Process		GetReturn	|
+                                //			Wakeup		WakeupInt	RxComplete	Packet		RxComplet
+
+                                //			&			(ReStart	(NotifyNdis (Rfd1)		(due to
+                                //			RxComplete	 Rx(Rfd1))	 Rfd1)		Chain Rfd1	 ReStartRx
+                                //												at last of	 in Process
+                                //												RfdList		 WakeupInt)
+                                //	This problem cause Rx-master stays in Idle
+                                //	state, and we did not restart it again!
+                                zd_writel(0xff, InterruptCtrl);
+                                zd1205_process_wakeup(macp);
+
+                        }
+                }
+        }
+
+        if (macp->dtimCount == macp->cardSetting.DtimPeriod - 1)
+        {
+                if (dot11Obj.QueueFlag & AWAKE_QUEUE_SET)
+                        tasklet_schedule(&macp->zd1205_ps_tasklet);
+        }
+
+        if (dot11Obj.QueueFlag & MGT_QUEUE_SET)
+                tasklet_schedule(&macp->zd1205_tasklet);
+
+
+        if (dot11Obj.QueueFlag & TX_QUEUE_SET)
+
+                tasklet_schedule(&macp->zd1205_tx_tasklet);
+
+exit:
+
+
+        zd1205_enable_int();
+}
+#endif
+
+int
+zd1205_open(struct net_device *dev)
+{
+        struct zd1205_private *macp = dev->priv;
+        int rc = 0;
+
+        ZENTER(0);
+
+        //This is used before previous up stat only,So we clear it.
+        clear_bit(CTX_FLAG_ESSID_WAS_SET, (void*)&macp->flags);
+        //read_lock(&(macp->isolate_lock));
+        if (macp->driver_isolated)
+        {
+                rc = -EBUSY;
+                goto exit;
+        }
+
+        //macp->bUSBDeveiceAttached = 1;
+
+        if ((rc = zd1205_alloc_space(macp)) != 0)
+        {
+                rc = -ENOMEM;
+                goto exit;
+        }
+
+        /* setup the tcb pool */
+        if (!zd1205_alloc_tcb_pool(macp))
+        {
+                printk(KERN_ERR "zd1205: failed to zd1205_alloc_tcb_pool\n");
+                rc = -ENOMEM;
+                goto err_exit;
+        }
+
+        zd1205_setup_tcb_pool(macp);
+
+        if (!zd1205_alloc_rfd_pool(macp))
+        {
+                printk(KERN_ERR "zd1205: failed to zd1205_alloc_rfd_pool\n");
+                rc = -ENOMEM;
+                goto err_exit;
+        }
+
+
+        mod_timer(&(macp->watchdog_timer), jiffies + (1*HZ));  //1 sec
+        mod_timer(&(macp->tm_hking_id), jiffies + (1*HZ)/10);  //100 ms
+        mod_timer(&(macp->tm_mgt_id), jiffies + (1*HZ)/50);   //20 ms
+
+#ifndef HOST_IF_USB
+
+        if ((rc = request_irq(dev->irq, &zd1205_intr, SA_SHIRQ, dev->name, dev)) != 0)
+        {
+                printk(KERN_ERR "zd1205: failed to request_irq\n");
+                del_timer_sync(&macp->watchdog_timer);
+                del_timer_sync(&macp->tm_hking_id);
+                del_timer_sync(&macp->tm_mgt_id);
+                goto err_exit;
+        }
+
+        zd1205_start_ru(macp);
+#endif
+
+        if (macp->cardSetting.BssType == AP_BSS)
+        {
+                netif_start_queue(dev);
+                zd_writel(0x1, LED1);
+        }
+
+        zd_UpdateCardSetting(&macp->cardSetting);
+        zd_CmdProcess(CMD_ENABLE, &dot11Obj, 0);  //AP start send beacon , STA start scan
+        zd1205_enable_int();
+
+        if (zd1211_submit_rx_urb(macp))
+                goto err_exit;
+
+        set_bit(ZD1211_RUNNING, &macp->flags);
+
+        if(CustomMACSet)
+        {
+                zd_writel(cpu_to_le32(*(u32 *)macp->macAdr), MACAddr_P1);
+                zd_writel(cpu_to_le32(*(u32 *)(macp->macAdr+4)), MACAddr_P2);
+        }
+
+        goto exit;
+
+err_exit:
+        zd1205_clear_pools(macp);
+
+exit:
+        //read_unlock(&(macp->isolate_lock));
+        ZEXIT(0);
+
+        return rc;
+}
+void zd1205_monitor_mode_enable(struct zd1205_private *macp)
+{
+        struct net_device *dev = macp->device;
+
+        if (netif_running(dev))
+                netif_stop_queue(dev);
+
+        dev->type = ARPHRD_IEEE80211;
+        zd_writel(0x01, SnifferOn);
+        zd_writel(0xffffffff, Rx_Filter);
+        zd_writel(0x08, EncryptionType);
+        macp->intrMask = RX_COMPLETE_EN;
+}
+
+void zd1205_monitor_mode_disable(struct zd1205_private *macp)
+{
+        struct net_device *dev = macp->device;
+
+        dev->type = ARPHRD_ETHER;
+        zd_writel(0x00, SnifferOn);
+        //zd_writel(0x00000000, Rx_Filter); /* will be set for the new mode */
+        zd_writel(NO_WEP, EncryptionType);
+        macp->intrMask = ZD1205_INT_MASK;
+
+        if (!netif_running(dev))
+                netif_start_queue(dev);
+}
+
+void zd1205_init_txq(struct zd1205_private *macp, zd1205_SwTcbQ_t *Q)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&macp->q_lock, flags);
+        Q->first = NULL;
+        Q->last = NULL;
+
+
+
+        Q->count = 0;
+        spin_unlock_irqrestore(&macp->q_lock, flags);
+
+}
+
+
+
+void zd1205_qlast_txq(struct zd1205_private *macp, zd1205_SwTcbQ_t *Q, zd1205_SwTcb_t *signal)
+{
+        unsigned long flags;
+        spin_lock_irqsave(&macp->q_lock, flags);
+
+        signal->next = NULL;
+        if (Q->last == NULL)
+        {
+                Q->first = signal;
+                Q->last = signal;
+        } else
+        {
+                Q->last->next = signal;
+
+
+
+                Q->last = signal;
+        }
+
+        Q->count++;
+        spin_unlock_irqrestore(&macp->q_lock, flags);
+}
+
+
+
+
+
+zd1205_SwTcb_t * zd1205_first_txq(struct zd1205_private *macp, zd1205_SwTcbQ_t *Q)
+{
+        zd1205_SwTcb_t *p = NULL;
+
+        unsigned long flags;
+
+        spin_lock_irqsave(&macp->q_lock, flags);
+
+        if (Q->first != NULL)
+        {
+                Q->count--;
+                p = Q->first;
+                Q->first = (Q->first)->next;
+                if (Q->first == NULL)
+                        Q->last = NULL;
+
+        }
+
+
+
+        spin_unlock_irqrestore(&macp->q_lock, flags);
+
+        return p;
+
+}
+
+
+static void
+zd1205_setup_tcb_pool(struct zd1205_private *macp)
+{
+
+        /* TCB local variables */
+        zd1205_SwTcb_t  *sw_tcb;         /* cached TCB list logical pointers */
+
+        zd1205_HwTCB_t	*hw_tcb;         /* uncached TCB list logical pointers */
+        unsigned long	HwTcbPhys;       /* uncached TCB list physical pointer */
+        u32      	    TcbCount;
+
+        /* TBD local variables */
+        zd1205_TBD_t  		*pHwTbd;         /* uncached TBD list pointers */
+        unsigned long		HwTbdPhys;       /* uncached TBD list physical pointer */
+        zd1205_Ctrl_Set_t	*pHwCtrlPtr;
+        unsigned long		HwCtrlPhys;
+        zd1205_Header_t	    *pHwHeaderPtr;
+        unsigned long		HwHeaderPhys;
+
+        macp->freeTxQ = &free_txq_buf;
+        macp->activeTxQ = &active_txq_buf;
+        zd1205_init_txq(macp, macp->freeTxQ);
+        zd1205_init_txq(macp, macp->activeTxQ);
+
+#if 0
+        /* print some basic sizing debug info */
+        printk(KERN_DEBUG "sizeof(SwTcb) = %04x\n", sizeof(zd1205_SwTcb_t));
+        printk(KERN_DEBUG "sizeof(HwTcb) = %04x\n", sizeof(zd1205_HwTCB_t));
+
+        printk(KERN_DEBUG "sizeof(HwTbd)= %04x\n", sizeof(zd1205_TBD_t));
+        printk(KERN_DEBUG "sizeof(CTRL_STRUC) = %04x\n", sizeof(zd1205_Ctrl_Set_t));
+        printk(KERN_DEBUG "sizeof(HEADER_STRUC) = %04x\n", sizeof(zd1205_Header_t));
+        printk(KERN_DEBUG "macp->numTcb = %04x\n", macp->numTcb);
+        printk(KERN_DEBUG "macp->numTbdPerTcb = %04x\n", macp->numTbdPerTcb);
+        printk(KERN_DEBUG "macp->numTbd = %04x\n", macp->numTbd);
+#endif
+
+
+        /* Setup the initial pointers to the HW and SW TCB data space */
+        sw_tcb = (zd1205_SwTcb_t *) macp->txCached;
+        hw_tcb = (zd1205_HwTCB_t *) macp->txUnCached;
+
+
+
+#ifndef HOST_IF_USB
+
+        HwTcbPhys = macp->txUnCachedPhys;
+#else
+
+        HwTcbPhys = (unsigned long)macp->txUnCached;
+#endif
+
+        /* Setup the initial pointers to the TBD data space.
+          TBDs are located immediately following the TCBs */
+        pHwTbd = (zd1205_TBD_t *) &hw_tcb[macp->numTcb];
+        HwTbdPhys = HwTcbPhys + (sizeof(zd1205_HwTCB_t) * macp->numTcb);
+
+        /* Setup yhe initial pointers to the Control Setting space
+        CTRLs are located immediately following the TBDs */
+        pHwCtrlPtr = (zd1205_Ctrl_Set_t *) &pHwTbd[macp->numTbd];
+        HwCtrlPhys = HwTbdPhys + (sizeof(zd1205_TBD_t) * macp->numTbd);
+
+        /* Setup the initial pointers to the Mac Header space
+         MACHEADERs are located immediately following the CTRLs */
+        pHwHeaderPtr = (zd1205_Header_t *) &pHwCtrlPtr[macp->numTcb];
+        HwHeaderPhys = HwCtrlPhys + (sizeof(zd1205_Ctrl_Set_t) * macp->numTcb);
+
+
+
+        /* Go through and set up each TCB */
+        for (TcbCount = 0; TcbCount < macp->numTcb;
+
+
+                        TcbCount++, sw_tcb++, hw_tcb++, HwTcbPhys += sizeof(zd1205_HwTCB_t),
+                        pHwTbd = (zd1205_TBD_t *) (((u8 *) pHwTbd) + ((sizeof(zd1205_TBD_t) * macp->numTbdPerTcb))),
+                        HwTbdPhys += (sizeof(zd1205_TBD_t) * macp->numTbdPerTcb),
+                        pHwCtrlPtr++, HwCtrlPhys += sizeof(zd1205_Ctrl_Set_t),
+                        pHwHeaderPtr++, HwHeaderPhys += sizeof(zd1205_Header_t))
+        {
+                /* point the cached TCB to the logical address of the uncached one */
+                sw_tcb->TcbCount = TcbCount;
+
+                sw_tcb->skb = 0;
+                sw_tcb->pTcb = hw_tcb;
+                sw_tcb->TcbPhys = HwTcbPhys;
+                sw_tcb->pFirstTbd = pHwTbd;
+                sw_tcb->FirstTbdPhys = HwTbdPhys;
+                sw_tcb->pHwCtrlPtr = pHwCtrlPtr;
+                sw_tcb->HwCtrlPhys = HwCtrlPhys;
+
+#if 0
+
+                // Pre-init control setting
+                {
+                        zd1205_Ctrl_Set_t	*ctrl_set = sw_tcb->pHwCtrlPtr;
+
+
+                        ctrl_set->CtrlSetting[3] = (u8)(sw_tcb->TcbPhys);
+
+                        ctrl_set->CtrlSetting[4] = (u8)(sw_tcb->TcbPhys >> 8);
+                        ctrl_set->CtrlSetting[5] = (u8)(sw_tcb->TcbPhys >> 16);
+                        ctrl_set->CtrlSetting[6] = (u8)(sw_tcb->TcbPhys >> 24);
+                        ctrl_set->CtrlSetting[18] = 0; //default for fragment
+                        ctrl_set->CtrlSetting[19] = 0;
+                        ctrl_set->CtrlSetting[23] = 0; //default for fragment
+
+                        ctrl_set->CtrlSetting[24] = 0;
+                        ctrl_set->CtrlSetting[26] = 0;
+                        ctrl_set->CtrlSetting[27] = 0;
+                }
+#endif
+
+                sw_tcb->pHwHeaderPtr = pHwHeaderPtr;
+                sw_tcb->HwHeaderPhys = HwHeaderPhys;
+
+
+
+                /* initialize the uncached TCB contents -- status is zeroed */
+                hw_tcb->CbStatus = 0xffffffff;
+                hw_tcb->CbCommand = cpu_to_le32(CB_S_BIT);
+#ifndef __LP64__
+                hw_tcb->TxCbFirstTbdAddrLowPart = cpu_to_le32(HwTbdPhys);
+                hw_tcb->TxCbFirstTbdAddrHighPart = 0;
+#else
+                hw_tcb->TxCbFirstTbdAddr = cpu_to_le64(HwTbdPhys);
+
+#endif
+                hw_tcb->TxCbTbdNumber = 0;
+                if (TcbCount == (macp->numTcb -1)) {
+                        /* Turn around TBD */
+
+#ifndef __LP64__
+#ifndef HOST_IF_USB
+                        hw_tcb->NextCbPhyAddrLowPart =  cpu_to_le32(macp->txUnCachedPhys);
+#else
+
+
+                        hw_tcb->NextCbPhyAddrLowPart =	cpu_to_le32((u32)macp->txUnCached);
+#endif
+
+                        hw_tcb->NextCbPhyAddrHighPart = 0;
+#else
+#ifndef HOST_IF_USB
+                        hw_tcb->NextCbPhyAddr = cpu_to_le64(macp->txUnCachedPhys);
+#else
+
+                        hw_tcb->NextCbPhyAddr = cpu_to_le64(macp->txUnCached);
+#endif
+
+#endif
+                } else {
+#ifndef __LP64__
+                        hw_tcb->NextCbPhyAddrLowPart = cpu_to_le32(HwTcbPhys + sizeof(zd1205_HwTCB_t));
+                        hw_tcb->NextCbPhyAddrHighPart = 0;
+#else
+                        hw_tcb->NextCbPhyAddr = cpu_to_le64(HwTcbPhys + sizeof(zd1205_HwTCB_t));
+#endif
+                }
+
+
+
+                /* add this TCB to the free list */
+                zd1205_qlast_txq(macp, macp->freeTxQ, sw_tcb);
+        }
+
+        return;
+}
+
+
+
+
+/**
+ * zd1205_get_stats - get driver statistics
+ 
+ * @dev: adapter's net_device struct
+ *
+ * This routine is called when the OS wants the adapter's stats returned.
+ * It returns the address of the net_device_stats stucture for the device.
+ * If the statistics are currently being updated, then they might be incorrect
+ * for a short while. However, since this cannot actually cause damage, no
+ * locking is used.
+ */
+
+struct net_device_stats *
+                        zd1205_get_stats(struct net_device *dev)
+{
+        struct zd1205_private *macp = dev->priv;
+
+        macp->drv_stats.net_stats.tx_errors =
+                macp->drv_stats.net_stats.tx_carrier_errors +
+                macp->drv_stats.net_stats.tx_aborted_errors;
+
+        macp->drv_stats.net_stats.rx_errors =
+                macp->drv_stats.net_stats.rx_crc_errors +
+                macp->drv_stats.net_stats.rx_frame_errors +
+
+                macp->drv_stats.net_stats.rx_length_errors +
+
+
+                macp->drv_stats.rcv_cdt_frames;
+
+
+        return &(macp->drv_stats.net_stats);
+}
+
+/* ath_desc: added iw_get_stats */
+/**
+ * zd1205wext_iw_get_stats - get driver wireless statistics
+ * @dev: adapter's net_device struct
+ *
+ * This routine is called when the OS wants the adapter's wireless
+ * stats returned. It returns the address of the iw_statistics
+ * stucture for the device. If the statistics are currently being
+ * updated, then they might be incorrect for a short while. However,
+ * since this cannot actually cause damage, no locking is used.
+ */
+#if WIRELESS_EXT > 12
+struct iw_statistics *zd1205wext_iw_get_stats(struct net_device *dev)
+{
+	struct zd1205_private *macp = dev->priv;
+	struct iw_statistics *iw_stats = &macp->drv_stats.iw_stats;
+
+	iw_stats->qual.noise = 161;
+	iw_stats->qual.qual = macp->rxSignalQuality;
+	iw_stats->qual.level = macp->rxSignalStrength;
+	iw_stats->qual.updated = 7;
+
+	iw_stats->discard.nwid = 0;
+	iw_stats->discard.code = 0;
+	iw_stats->discard.fragment = 0;
+	iw_stats->discard.retries = macp->retryFailCnt;
+	iw_stats->discard.misc = macp->DropFirstFragCnt + macp->ErrLongFrmCnt +
+				 macp->ErrShortFrmCnt + macp->ErrZeroLenFrmCnt;
+
+	iw_stats->miss.beacon = 0;
+
+	return iw_stats;
+}
+#endif
+
+/**
+ * zd1205_set_mac - set the MAC address
+ * @dev: adapter's net_device struct
+ 
+ * @addr: the new address
+ *
+ * This routine sets the ethernet address of the board
+ 
+ 
+ * Returns:
+ * 0  - if successful
+ * -1 - otherwise
+ */
+int
+
+zd1205_set_mac(struct net_device *dev, void *addr)
+{
+        struct zd1205_private *macp;
+
+        int rc = -1;
+        struct sockaddr *p_sockaddr = (struct sockaddr *) addr;
+
+
+        macp = dev->priv;
+        read_lock(&(macp->isolate_lock));
+
+        if (macp->driver_isolated)
+        {
+                goto exit;
+        }
+
+        {
+                memcpy(&(dev->dev_addr[0]), p_sockaddr->sa_data, ETH_ALEN);
+                zd_writel(cpu_to_le32(*(u32 *)p_sockaddr->sa_data), MACAddr_P1);
+                zd_writel(cpu_to_le32(*(u32 *)(p_sockaddr->sa_data+4)), MACAddr_P2);
+                memcpy(macp->macAdr,p_sockaddr->sa_data,ETH_ALEN);
+                memcpy(CustomMAC,p_sockaddr->sa_data,ETH_ALEN);
+                memcpy(macp->cardSetting.MacAddr,macp->macAdr,ETH_ALEN);
+
+                if (macp->cardSetting.BssType == AP_BSS) {
+                        // Set bssid = MacAddress
+                        memcpy(macp->BSSID,macp->macAdr,ETH_ALEN);
+
+                        zd_writel(cpu_to_le32(*(u32 *)&macp->macAdr[0]), BSSID_P1);
+                        zd_writel(cpu_to_le32(*(u32 *)&macp->macAdr[4]), BSSID_P2);
+                } else {
+                        zd_writel(STA_RX_FILTER, ZD_Rx_Filter);
+                }
+                CustomMACSet = TRUE;
+
+                rc = 0;
+        }
+
+exit:
+        read_unlock(&(macp->isolate_lock));
+        return rc;
+
+}
+
+
+
+void
+zd1205_isolate_driver(struct zd1205_private *macp)
+{
+        write_lock_irq(&(macp->isolate_lock));
+        macp->driver_isolated = true;
+        write_unlock_irq(&(macp->isolate_lock));
+        del_timer_sync(&macp->watchdog_timer);
+        del_timer_sync(&macp->tm_hking_id);
+        del_timer_sync(&macp->tm_mgt_id);
+        del_timer_sync(&macp->tm_scan_id);
+
+
+        if (netif_running(macp->device))
+        {
+                netif_carrier_off(macp->device);
+                netif_stop_queue(macp->device);
+        }
+}
+
+
+int
+zd1205_change_mtu(struct net_device *dev, int new_mtu)
+
+{
+        if ((new_mtu < 68) || (new_mtu > (ETH_DATA_LEN + VLAN_SIZE)))
+                return -EINVAL;
+
+        dev->mtu = new_mtu;
+
+        return 0;
+}
+
+
+int
+zd1205_close(struct net_device *dev)
+{
+        struct zd1205_private *macp = dev->priv;
+
+        ZENTER(0);
+
+        netif_carrier_off(macp->device);
+
+
+#if 0
+
+        while (dot11Obj.bDeviceInSleep)
+        {
+                wait_ms(10);
+        }
+#endif
+
+        zd1205_isolate_driver(macp);
+
+        macp->intrMask = 0;
+        macp->bAssoc = 0;
+        mCounterMeasureState = 0;
+        macp->bGkInstalled = 0;
+        mGkInstalled=0;
+        macp->cardSetting.DynKeyMode=0;
+        mPrivacyInvoked=0;
+        dot11Obj.MIC_CNT=FALSE;
+
+        //zd_writel(0x01, Pre_TBTT);
+
+
+#ifndef HOST_IF_USB
+
+        zd_writel(0x0, BCNInterval);
+        zd_writel(0x0, LED1);
+        zd_writel(0x0, LED2);
+        free_irq(dev->irq, dev);
+        zd1205_device_reset(macp);
+#else
+
+        if (!test_bit(ZD1211_UNPLUG, &macp->flags))
+        {
+                iLED_OFF(macp, macp->LinkLEDn);
+                zd_writel(0x0, FW_LINK_STATUS);
+                //zd1211_disable_net_traffic(macp);
+                //zd1205_device_reset(macp);
+        }
+
+        clear_bit(ZD1211_RUNNING, &macp->flags);
+
+        //tasklet_kill(&macp->zd1211_rx_tasklet);
+        //tasklet_kill(&macp->zd1211_tx_tasklet);
+        //tasklet_kill(&macp->rx_buff_tasklet);
+
+
+        zd1211_unlink_all_urbs(macp);
+#endif
+
+
+
+        zd1205_clear_pools(macp);
+        macp->bPSMSupported = 0;
+        dot11Obj.bDeviceInSleep = 0;
+
+
+        //set FdescBuf unused
+        re_initFdescBuf();
+
+        /* set the isolate flag to false, so zd1205_open can be called */
+        macp->driver_isolated = false;
+        ZEXIT(0);
+        return 0;
+}
+
+
+
+
+u8 CalNumOfFrag(struct zd1205_private *macp, u32 length)
+
+{
+
+        u8 FragNum = 1;
+        u32 pdusize;
+
+
+
+        pdusize = macp->cardSetting.FragThreshold;
+
+        if ((length + CRC32_LEN) > pdusize)
+        { //Need fragment
+                pdusize -= WLAN_HEADER + CRC32_LEN;
+
+                FragNum = ((length - WLAN_HEADER)+ (pdusize-1)) / pdusize;
+                if (FragNum == 0)
+                        FragNum = 1;
+        }
+
+        return FragNum;
+}
+
+int
+zd1205_xmit_frame(struct sk_buff *skb, struct net_device *dev)
+{
+        int rc = 0;
+        int notify_stop = false;
+        struct zd1205_private *macp = dev->priv;
+
+        u16 TypeLen;
+        u8 *pHdr = skb->data;
+
+        u32 bodyLen;
+        u32 TotalLen;
+        u8 *pBody;
+        u8 NumOfFrag = 1;
+        u8 EtherHdr[12];
+        u8 bEapol = 0;
+        u8 *pMac = NULL;
+        Hash_t *pHash = NULL;
+        u8 bGroupAddr = 0;
+        card_Setting_t *pSetting = &macp->cardSetting;
+        u8 bEthType2 = 0;
+        u8 *pSkbData = skb->data;
+        u32 SkbLength = skb->len;
+        BOOLEAN bHashSearchResult;
+        ZENTER(2);
+
+        //zd1205_dump_data("tx packet", (u8 *)skb->data, skb->len);
+        if (pHdr[0] & BIT_0)
+                bGroupAddr = 1;
+
+        read_lock(&(macp->isolate_lock));
+        if (macp->driver_isolated)
+        {
+                rc = -EBUSY;
+                goto exit2;
+        }
+
+        if (!spin_trylock(&macp->bd_non_tx_lock))
+        {
+                notify_stop = true;
+                rc = 1;
+                goto exit2;
+        }
+
+        TypeLen = (((u16) pHdr[12]) << 8) + (pHdr[13]);
+        if ((pSetting->BssType == INFRASTRUCTURE_BSS) || (pSetting->BssType == INDEPENDENT_BSS))
+        {
+                if (dot11Obj.bDeviceInSleep) {
+                        //queue to upper layer
+                        notify_stop = true;
+                        rc = 1;
+                        //dev_kfree_skb_irq(skb);
+                        //rc = 0;
+                        goto exit1;
+                }
+
+                if (pSetting->BssType == INFRASTRUCTURE_BSS)
+                        pMac = macp->BSSID;
+                else if (pSetting->BssType == INDEPENDENT_BSS)
+                        pMac = pHdr;
+
+                bHashSearchResult = zd_QueryStaTable(pMac, (void**)&pHash);
+                if ((!macp->bAssoc) || ((!bHashSearchResult) && (!bGroupAddr))) {
+                        //Not Associated to AP
+                        //printk(KERN_ERR "*** Not associated to AP\n");
+                        dev_kfree_skb_irq(skb);
+                        rc = 0;
+                        goto exit1;
+                }
+                if (macp->cardSetting.WPASupport==1 && pSetting->BssType==INFRASTRUCTURE_BSS) {
+                        if (TypeLen != 0x888e && pHash->pkInstalled==0) {
+                                printk(KERN_DEBUG "**** Block Non-EAPol packet before key installed\n");
+                                dev_kfree_skb_irq(skb);
+                                rc=0;
+                                goto exit1;
+                        }
+                }
+
+        } else if	(pSetting->BssType == AP_BSS)
+        {
+                if (!bGroupAddr) { //da is unicast
+                        if (!zd_QueryStaTable(pHdr,(void**)&pHash)) {
+                                dev_kfree_skb_irq(skb);
+                                rc = 0;
+                                goto exit1;
+                        }
+                } else {
+                        if (mCurrConnUser==0 || ((pSetting->DynKeyMode) && (mGkInstalled == 0))) {
+                                dev_kfree_skb_irq(skb);
+                                rc = 0;
+                                goto exit1;
+                        }
+                }
+        }
+
+        //TypeLen = (((u16) pHdr[12]) << 8) + (pHdr[13]);
+
+        //WPADEBUG("TypeLen: 0x%04x\n", TypeLen);
+
+        if (TypeLen > 1500)
+        {	/* Ethernet 2 frame */
+                bEthType2 = 1;
+                bodyLen = skb->len - 6;
+        } else
+        {
+                bEthType2 = 0;
+                bodyLen = TypeLen;
+        }
+
+        TotalLen = bodyLen + WLAN_HEADER; //Mac Header(24)
+        NumOfFrag = CalNumOfFrag(macp, TotalLen);
+
+        if (macp->freeTxQ->count < (NumOfFrag+1))
+        {
+                //printk(KERN_DEBUG "********Queue to upper layer************\n");
+                macp->txQueToUpCnt++;
+                notify_stop = true;
+                rc = 1;
+                goto exit1;
+        }
+
+        memcpy(&EtherHdr[0], pHdr, 12); //save ethernet header
+
+
+        if (bEthType2)
+        {	/* Ethernet 2 frame */
+                /* DA(6) SA(6) Type(2) Data....(reserved array) */
+                if (TypeLen == IPX) {
+                        memcpy(pHdr+6, ZD_SNAP_BRIDGE_TUNNEL, sizeof(ZD_SNAP_BRIDGE_TUNNEL));
+                } else if(TypeLen == APPLE_TALK) {
+                        memcpy(pHdr+6, zd_Snap_Apple_Type, sizeof(zd_Snap_Apple_Type));
+                }
+                else
+                        memcpy(pHdr+6, (void *)ZD_SNAP_HEADER, sizeof(ZD_SNAP_HEADER));
+
+                if (TypeLen == EAPOL ) {
+                        WPADEBUG("Transmit EAPOL packet\n");
+                        bEapol = 1;
+                }
+
+                skb->len -= 6;  /* Minus DA, SA; Plus 802.2LLC Header */
+                bodyLen = skb->len;
+                skb->data += 6;
+        } else
+        {	/* 802.3 frame */
+                /* DA(6) SA(6) Len(2) 802.2_LLC(3) 802.2_SNAP(3+2) Data.... */
+                skb->len -= 14;
+                bodyLen = TypeLen;
+                skb->data += 14;
+        }
+
+        pBody = skb->data;
+
+#if 0
+        //force release for debug only
+        dev_kfree_skb_irq(skb);
+        rc = 0;
+        goto exit1;
+#endif
+
+        if (!zd_SendPkt(EtherHdr, pBody, bodyLen, (void *)skb, bEapol, pHash))
+        {
+                notify_stop = true;
+                rc = 1;
+                //restore skb data structure
+                skb->data = pSkbData;
+                skb->len = SkbLength;
+                goto exit1;
+        }
+
+        macp->drv_stats.net_stats.tx_bytes += skb->len;
+        macp->drv_stats.net_stats.tx_packets++;
+
+exit1:
+        spin_unlock(&macp->bd_non_tx_lock);
+
+exit2:
+        read_unlock(&(macp->isolate_lock));
+
+        if (notify_stop)
+        {
+                //netif_carrier_off(dev);
+                netif_stop_queue(dev);
+        }
+
+        ZEXIT(2);
+        return rc;
+}
+
+void zd1205_sw_release(void)
+{
+        zd_EventNotify(EVENT_BUF_RELEASE, 0, 0, 0);
+}
+
+void zd1205_sleep_reset(struct zd1205_private *macp)
+{
+        u32 tmpvalue;
+        u32 ul_pretbtt;
+        u32 ul_BcnItvl;
+        u64 TSFTimer;
+        u32     ul_Rem;
+
+
+#ifndef HOST_IF_USB
+
+        unsigned long flags;
+#endif
+
+        //return; //for debug only, test SW
+
+        ZD1211DEBUG(1, "Prepare to enter sleep mode\n");
+        netif_stop_queue(macp->device);
+        netif_carrier_off(macp->device);
+        //HW_RadioOnOff(&dot11Obj, 0);
+
+#if 1
+
+        ul_BcnItvl = zd_readl(ZD_BCNInterval) & 0xFFFF;
+        HW_UpdatePreTBTT(&dot11Obj, ul_BcnItvl-BEFORE_BEACON);
+        ul_pretbtt = zd_readl(ZD_Pre_TBTT);
+#else
+
+        ul_BcnItvl = dot11Obj.BeaconInterval;
+        if (ul_BcnItvl < (BEFORE_BEACON))
+                ul_BcnItvl=100;
+        ul_pretbtt = ul_BcnItvl-BEFORE_BEACON;//Adjust Pre-TBTT occur before TBTT */
+#endif
+        //ZD1211DEBUG(1, "Pre_TBTT = %u\n", ul_pretbtt);
+
+
+        while(1)
+        {
+                // Make sure that the time issued sleep-command is not too close to Pre_TBTT.
+                // Also make sure that sleep-command is out of Beacon-Tx duration.
+                tmpvalue = zd_readl(ZD_TSF_LowPart);
+                TSFTimer = tmpvalue;
+                tmpvalue = zd_readl(ZD_TSF_HighPart);
+                TSFTimer += (((u64)tmpvalue) << 32);
+                TSFTimer = TSFTimer >> 10; // in unit of TU
+                //printk("TSF(TU) %d \n", TSFTimer);
+                //printk("BeaconInterval = %d\n", ul_BcnItvl);
+                //printk("TSF mod BeaconInterval = %d\n", (TSFTimer % ul_BcnItvl));
+
+                ul_Rem=do_div(TSFTimer, ul_BcnItvl);
+                if ((ul_pretbtt > ul_Rem) || (macp->bSurpriseRemoved)) {
+                        //++ Ensure the following is an atomic operation.
+                        ZD1211DEBUG(1, "Rem=%u\n",ul_Rem);
+                        if ( (((ul_pretbtt - ul_Rem) >= 3) && (ul_Rem > BEACON_TIME) && (!atomic_read(&macp->DoNotSleep))) || (macp->bSurpriseRemoved)) {
+                                down(&macp->ps_sem); // for zd1211
+#if 0
+
+                                tmpvalue = zd_readl(ZD_PS_Ctrl); //Because readout value is always zero in zd1211, no need perform read operation before modifying.
+                                zd_writel((tmpvalue | BIT_0), ZD_PS_Ctrl);
+#else
+
+                                zd_writel(BIT_28 | BIT_0, ZD_PS_Ctrl); // Keep Power on of 44MHz Osc while in sleep.
+#endif
+
+                                dot11Obj.bDeviceInSleep = 1;
+                                up(&macp->ps_sem);
+                                macp->sleepCnt++;
+                                break;
+                        }
+                }
+                mdelay(1);
+        }
+
+        macp->TxStartTime = 0;
+
+}
+
+
+void update_beacon_interval(struct zd1205_private *macp, int val)
+{
+        int BcnInterval;
+        int ul_PreTBTT;
+        int tmpvalue;
+
+        BcnInterval = val;
+
+
+        /* One thing must be sure that BcnInterval > Pre_TBTT > ATIMWnd >= 0 */
+        if(BcnInterval < 5)
+        {
+                BcnInterval = 5;
+        }
+
+
+        ul_PreTBTT = zd_readl(Pre_TBTT);
+
+        if(ul_PreTBTT < 4)
+        {
+                ul_PreTBTT = 4;
+        }
+
+
+        if(ul_PreTBTT >= BcnInterval)
+        {
+                ul_PreTBTT = BcnInterval - 1;
+        }
+
+        zd_writel(ul_PreTBTT, Pre_TBTT);
+
+        tmpvalue = zd_readl(BCNInterval);
+        tmpvalue &= ~0xffffffff;
+        tmpvalue |= BcnInterval;
+        zd_writel(tmpvalue, BCNInterval);
+}
+
+
+
+void zd1205_device_reset(struct zd1205_private *macp)
+{
+        u32  tmp_value;
+
+
+        /* Update the value of Beacon Interval and Pre TBTT */
+        update_beacon_interval(macp, 0x2);
+        zd_writel(0x01, Pre_TBTT);
+
+        tmp_value = zd_readl(PS_Ctrl);
+        zd_writel(tmp_value | BIT_0, PS_Ctrl);
+        dot11Obj.bDeviceInSleep = 1;
+        /* Sleep for 5 msec */
+        wait_ms(5);
+
+}
+
+
+
+void zd1205_recycle_tx(struct zd1205_private *macp)
+
+{
+        zd1205_SwTcb_t *sw_tcb;
+
+
+#if 0
+
+        while (macp->activeTxQ->count)
+        {
+                sw_tcb = zd1205_first_txq(macp, macp->activeTxQ);
+                zd1205_transmit_cleanup(macp, sw_tcb);
+                macp->txCmpCnt++;
+                if (!sw_tcb->LastFrag)
+                        continue;
+
+                zd_EventNotify(EVENT_TX_COMPLETE, ZD_RETRY_FAILED, (U32)sw_tcb->MsgID, sw_tcb->aid);
+        }
+#else
+        if (macp->activeTxQ->count)
+        {
+                sw_tcb = macp->activeTxQ->first;
+                zd1205_start_download(sw_tcb->TcbPhys);
+        }
+#endif
+}
+
+void zd1205_process_wakeup(struct zd1205_private *macp)
+{
+        card_Setting_t *pSetting = &macp->cardSetting;
+
+#ifndef HOST_IF_USB
+
+        u32 tmpvalue;
+        u64 TSFTimer;
+#endif
+
+        ZENTER(1);
+
+        if (pSetting->BssType == AP_BSS)
+        {
+                HW_EnableBeacon(&dot11Obj, pSetting->BeaconInterval, pSetting->DtimPeriod, AP_BSS);
+                HW_SetRfChannel(&dot11Obj, pSetting->Channel, 0,macp->cardSetting.MacMode);
+        }
+#if 0
+        else if (pSetting->BssType == INFRASTRUCTURE_BSS)
+        {
+                //HW_SetRfChannel(&dot11Obj, dot11Obj.Channel, 0);
+
+                if ((netif_running(macp->device)) && (macp->bAssoc)) {
+                        netif_wake_queue(macp->device);   //resume tx
+                }
+        }
+#endif
+        printk(KERN_ERR "Bf RF ON: %lu\n",jiffies);
+        //HW_RadioOnOff(&dot11Obj, 1);
+        printk(KERN_ERR "After RF ON: %lu\n", jiffies);
+
+#ifndef HOST_IF_USB
+
+        tmpvalue = zd_readl(ZD_TSF_LowPart);
+        TSFTimer = tmpvalue;
+        tmpvalue = zd_readl(ZD_TSF_HighPart);
+        TSFTimer += (((u64)tmpvalue) << 32);
+        TSFTimer = TSFTimer >> 10; // in unit of TU
+
+        //printk("TSF(TU) %d \n", TSFTimer);
+        //printk("BeaconInterval = %d\n", dot11Obj.BeaconInterval);
+        //printk("TSF mod BeaconInterval = %d\n", (TSFTimer % dot11Obj.BeaconInterval));
+        //printk("Now, Device had been waken up\n");
+
+        tmpvalue = zd_readl(ZD_DeviceState);
+        //printk("DeviceState == %x\n", tmpvalue);
+
+        // In IBSS mode, BCNATIM is now operating, therefore, the Tx-State will not
+        // stay in idle state. So, we change form 0xffff to 0xff, ie, we just make
+
+        // sure that bus-masters, both Tx and Rx, are in idle-state.
+#endif
+
+
+        dot11Obj.bDeviceInSleep = 0;
+
+        // Solve Sequence number duplication problem after wakeup.
+        macp->SequenceNum = 0;
+
+#ifndef HOST_IF_USB
+
+        zd1205_recycle_tx(macp);
+#endif
+
+#ifndef HOST_IF_USB
+
+        zd1205_start_ru(macp);
+#else
+        //zd1205_recycle_rx(macp);
+#endif
+
+        macp->wakeupCnt++;
+
+        if ((netif_running(macp->device)) && (macp->bAssoc))
+        {
+                netif_carrier_on(macp->device);
+                netif_wake_queue(macp->device);
+        }
+
+
+
+}
+
+
+
+void zd1205_sw_reset(struct zd1205_private *macp)
+{
+        zd1205_disable_int();
+        zd1205_tx_isr(macp);
+        memset(macp->txUnCached, 0x00, macp->txUnCachedSize);
+
+        zd1205_setup_tcb_pool(macp);
+        zd1205_sleep_reset(macp);
+        zd1205_start_ru(macp);
+        zd_EventNotify(EVENT_SW_RESET, 0, 0, 0);
+        zd1205_enable_int();
+
+        if(netif_running(macp->device))
+        {
+                netif_carrier_on(macp->device);
+                netif_wake_queue(macp->device);
+        }
+}
+
+
+
+/**
+ * zd1205_sw_init - initialize software structs
+ * @macp: atapter's private data struct
+ * 
+ * This routine initializes all software structures. Sets up the
+ * circular structures for the RFD's & TCB's. Allocates the per board
+ * structure for storing adapter information. The CSR is also memory 
+  * mapped in this routine.
+ *
+ * Returns :
+ *      true: if S/W was successfully initialized
+ 
+ *      false: otherwise
+ */
+
+
+static unsigned char
+
+zd1205_sw_init(struct zd1205_private *macp)
+{
+
+        //ZENTER(0);
+        zd1205_init_card_setting(macp);
+        zd1205_set_zd_cbs(&dot11Obj);
+        zd_CmdProcess(CMD_RESET_80211, &dot11Obj, 0);
+
+        /* Initialize our spinlocks */
+        spin_lock_init(&(macp->bd_lock));
+        spin_lock_init(&(macp->bd_non_tx_lock));
+        //spin_lock_init(&(macp->q_lock));
+        spin_lock_init(&(macp->conf_lock));
+
+        tasklet_init(&macp->zd1205_tasklet, zd1205_action, 0);
+        tasklet_init(&macp->zd1205_ps_tasklet, zd1205_ps_action, 0);
+        tasklet_init(&macp->zd1205_tx_tasklet, zd1205_tx_action, 0);
+
+#ifdef HOST_IF_USB
+        //spin_lock_init(&(macp->intr_lock));
+        spin_lock_init(&(macp->rx_pool_lock));
+        tasklet_init(&macp->zd1211_rx_tasklet, zd1211_rx_isr, (unsigned long)macp);
+        tasklet_init(&macp->zd1211_tx_tasklet, zd1211_tx_isr, (unsigned long)macp);
+        tasklet_init(&macp->rx_buff_tasklet, zd1211_alloc_rx, (unsigned long)macp);
+#endif
+
+
+        macp->isolate_lock = RW_LOCK_UNLOCKED;
+
+        macp->driver_isolated = false;
+
+        //ZEXIT(0);
+        return 1;
+
+}
+
+
+/**
+ * zd1205_hw_init - initialized tthe hardware
+ * @macp: atapter's private data struct
+ 
+ 
+ * @reset_cmd: s/w reset or selective reset
+ *
+ 
+ * This routine performs a reset on the adapter, and configures the adapter.
+ * This includes configuring the 82557 LAN controller, validating and setting
+ 
+ 
+ * the node address, detecting and configuring the Phy chip on the adapter,
+ * and initializing all of the on chip counters.
+ *
+ * Returns:
+ *      true - If the adapter was initialized
+ *      false - If the adapter failed initialization
+ */
+unsigned char
+zd1205_hw_init(struct zd1205_private *macp)
+
+{
+
+        //ZENTER(0);
+        HW_ResetPhy(&dot11Obj);
+        HW_InitHMAC(&dot11Obj);
+        zd1205_config(macp);
+
+        //ZEXIT(0);
+        return true;
+}
+
+
+
+void zd1211_set_multicast(struct zd1205_private *macp)
+{
+        struct net_device *dev = macp->device;
+        struct dev_mc_list *mc_list;
+        unsigned int i;
+
+        u8 *pKey;
+        u32 tmpValue;
+        u8  mcBuffer[192];
+        u16 mcLen;
+
+
+        if (!(dev->flags & IFF_UP))
+                return;
+
+        if (macp->cardSetting.BssType == AP_BSS)
+                return;
+
+
+        zd_writel(0, GroupHash_P1);
+        zd_writel(0x80000000, GroupHash_P2);
+        macp->MulticastAddr[0] = dev->mc_count;
+        mcLen = dev->mc_count*ETH_ALEN ;
+
+
+        for (i = 0, mc_list = dev->mc_list;
+                        (i < dev->mc_count) && (i < MAX_MULTICAST_ADDRS);
+
+                        i++, mc_list = mc_list->next)
+        {
+
+
+                //zd1205_dump_data("mc addr", (u8 *)&(mc_list->dmi_addr), ETH_ALEN);
+                memcpy(&macp->MulticastAddr[1+i * ETH_ALEN], (u8 *) &(mc_list->dmi_addr), ETH_ALEN);
+        }
+        macp->MulticastAddr[mcLen +1] = 0;
+        //zd1205_dump_data("MulticastAddr", (u8 *)macp->MulticastAddr, mcLen +2);
+
+        memcpy(mcBuffer, &macp->MulticastAddr[1], mcLen);
+
+        //zd1205_dump_data("mcBuffer", (u8 *)mcBuffer, mcLen);
+        pKey = mcBuffer;
+
+        for (i=0; i<mcLen; i++)
+        {
+                if ((i%6) == 5) {
+                        *(pKey+i) = (*(pKey+i)) >> 2;
+                        if (*(pKey+i) >= 32) {
+                                tmpValue = zd_readl(GroupHash_P2);
+
+                                tmpValue |= (0x01 << (*(pKey+i)-32));
+                                zd_writel(tmpValue, GroupHash_P2);
+                        }
+
+                        else {
+                                tmpValue = zd_readl(GroupHash_P1);
+                                tmpValue |= (0x01 << (*(pKey+i)));
+                                zd_writel(tmpValue, GroupHash_P1);
+                        }
+                }
+        }
+
+        if(dev->flags & IFF_PROMISC)
+                printk("Promiscuous mode enabled.\n");
+
+        if(dev->flags & IFF_PROMISC)
+        {
+                zd_writel(0xffffffff,GroupHash_P1);
+                zd_writel(0xffffffff,GroupHash_P2);
+        } else if( dev->flags & IFF_ALLMULTI)
+        {
+                zd_writel(0xffffffff,GroupHash_P1);
+                zd_writel(0xffffffff,GroupHash_P2);
+        }
+
+
+
+        macp->GroupHashP1 = zd_readl(GroupHash_P1);
+
+
+        macp->GroupHashP2 = zd_readl(GroupHash_P2);
+
+        ZD1211DEBUG(1, "GroupHashP1 = %x\n", macp->GroupHashP1);
+        ZD1211DEBUG(1, "GroupHashP2 = %x\n", macp->GroupHashP2);
+
+        //for debug only
+        //zd_writel(0xffffffff, GroupHash_P1);
+
+        //zd_writel(0xffffffff, GroupHash_P2);
+}
+
+
+void zd1205_set_multi(struct net_device *dev)
+{
+        struct zd1205_private *macp = dev->priv;
+
+#ifdef HOST_IF_USB
+
+        defer_kevent(macp, KEVENT_SET_MULTICAST);
+#else
+
+        zd1211_set_multicast(macp);
+#endif
+}
+
+
+
+#ifdef HOST_IF_USB
+    #define  TX_TIMEOUT     (4*100) //4sec
+#else
+    #define  TX_TIMEOUT     (4*1000*1000) //4sec
+#endif
+
+/**
+ * zd1205_watchdog
+ 
+ * @dev: adapter's net_device struct
+ *
+ * This routine runs every 1 seconds and updates our statitics and link state,
+ * and refreshs txthld value.
+ */
+void
+zd1205_watchdog(struct zd1205_private *macp)
+{
+
+
+        card_Setting_t *pSetting = &macp->cardSetting;
+        u32 TxBytes, RxBytes;
+
+#ifndef HOST_IF_USB
+
+        u32 diffTime;
+        u32 tmpvalue;
+#endif
+
+        //read_lock(&(macp->isolate_lock));
+
+        if (macp->driver_isolated)
+        {
+                //goto pexit;
+                return;
+        }
+
+        if (!netif_running(macp->device))
+        {
+
+                //goto pexit;
+                return;
+        }
+
+        rmb();
+
+        macp->CheckForHangLoop++;
+
+        zd_PerSecTimer();
+
+        TxBytes = macp->TotalTxDataFrmBytes;
+        RxBytes = macp->TotalRxDataFrmBytes;
+
+        // Check if AP(Access Point) still alive in the current channel
+
+        if (pSetting->BssType == INFRASTRUCTURE_BSS)
+        {
+                if(macp->bAssoc) { // We thought the Station is still associated with AP.
+                        // dump dot11DesiredSsid
+                        //U8 cbTemp;
+                        //U8 ssidLenToDump=dot11DesiredSsid.buf[1];
+                        //for (cbTemp=0; cbTemp<ssidLenToDump; cbTemp++)
+                        //   printk("%c", dot11DesiredSsid.buf[2+cbTemp]);
+                        //printk("\n");
+                        mTmRetryConnect=0;
+                        if (!macp->bAPAlive) {  // The AP-exist flag is not set by any received Mgt or Data frame yet, so we increase the lost-Beacon counter.
+                                macp->NoBcnDetectedCnt++;
+                                if (dot11Obj.bChScanning)
+                                        macp->NoBcnDetectedCnt = 0;
+
+                                if (macp->activeTxQ->count > 12)
+                                        macp->NoBcnDetectedCnt = 0;
+
+                                if (macp->NoBcnDetectedCnt > 5) {
+                                        printk(KERN_ERR "******We Lose AP for 5 seconds\n");
+                                        if(!mCounterMeasureState) {
+                                                zd1205_dis_connect(macp);
+                                                //zd_CmdProcess(CMD_DIS_CONNECT, 0, 0);
+                                                if (macp->cardSetting.ap_scan != 1)
+                                                        zd_CmdProcess(CMD_ROAMING, 0, 0);
+                                                else {
+                                                        zdcb_status_notify(STA_DISASSOCIATED, &macp->BSSID[0]);
+                                                }
+                                        }
+                                        macp->NoBcnDetectedCnt = 0;
+                                        //defer_kevent(macp, KEVENT_DIS_CONNECT);
+                                }
+                        } else { // We have received at least one Mgt or Data frame from AP, so we reset the lost-Beacon counter.
+                                macp->NoBcnDetectedCnt = 0;
+                        }
+
+                        macp->bAPAlive = 0; // Clear AP-exist flag, it will be Set when a Mgt or Data frame is received.
+                } else { // macp->bAssoc ==0, we are in disconnected state.
+
+                        //printk(KERN_ERR "***** We are disconnected\n");
+                        mTmRetryConnect++;
+                        if (mTmRetryConnect >= 6) {
+                                if (macp->cardSetting.ap_scan != 1) { //when wpa_supplicant takes care of scanning and AP selection, it is not necessary for driver attempt to reconnect.
+                                        if (zd_CmdProcess(CMD_ROAMING,0,0)) {
+                                                mTmRetryConnect=0;
+                                        }
+                                } else {// ap_scan=1 in wpa_supplicant.conf
+                                        ZD1211DEBUG(0, "wpa_supplicant takes care of scanning and AP selection, no need to roam driver itself\n");
+                                        mTmRetryConnect = 0;
+                                }
+
+                        }
+                }
+        } else if (pSetting->BssType == AP_BSS)
+        {
+                if((pSetting->MacMode==MIXED_MODE || pSetting->MacMode==PURE_G_MODE)) {// Try to disable protection mechanism if OLBC not exist any more.
+                        if (dot11Obj.ConfigFlag & ENABLE_PROTECTION_SET) {
+                                if (macp->bOLBC==0) // The bOLBC will be incremented after checking OLBC by calling zd1205_CheckOverlapBss.
+                                {
+                                        if(++macp->nOLBC_CounterInSec > 2)
+                                        {
+                                                if (mNumBOnlySta==0) {
+                                                        zd_EventNotify(EVENT_ENABLE_PROTECTION, 0,0,0);//Disable protection mode.
+                                                }
+                                                macp->nOLBC_CounterInSec=0;
+                                        }
+                                }
+                                else {// OLBC condition exist.
+                                        macp->nOLBC_CounterInSec=0;
+                                }
+                        }
+                        macp->bOLBC=0;
+                }
+        }// End of AP_BSS condition
+
+        if ((macp->bPSMSupported) && (macp->bAssoc))
+        {
+
+                // Check if we need to enter the PSM (power-save mode), CAM mode or no-change
+
+                if ((TxBytes < macp->PSThreshhold) && (RxBytes < macp->PSThreshhold)) {
+                        macp->SuggestionMode = PS_PSM;
+                }
+                else
+                        macp->SuggestionMode = PS_CAM;
+        }
+
+        macp->TotalTxDataFrmBytes = 0;
+        macp->TotalRxDataFrmBytes = 0;
+
+
+}
+
+
+void
+zd1205_watchdog_cb(struct net_device *dev)
+{
+        struct zd1205_private *macp = dev->priv;
+
+#ifdef HOST_IF_USB
+
+        defer_kevent(macp, KEVENT_WATCH_DOG);
+        mod_timer(&(macp->watchdog_timer), jiffies+(1*HZ));
+#else
+
+        zd1205_watchdog(macp);
+        mod_timer(&(macp->watchdog_timer), jiffies+(1*HZ));
+#endif
+}
+
+
+/**
+ * zd1205_pci_setup - setup the adapter's PCI information
+ 
+ * @pcid: adapter's pci_dev struct
+ * @macp: atapter's private data struct
+ 
+ *
+ * This routine sets up all PCI information for the adapter. It enables the bus
+ * master bit (some BIOS don't do this), requests memory ans I/O regions, and
+ * calls ioremap() on the adapter's memory region.
+ 
+ *
+ * Returns:
+ 
+ *      true: if successfull
+ *      false: otherwise
+ */
+#ifndef HOST_IF_USB
+static unsigned char
+zd1205_pci_setup(struct pci_dev *pcid, struct zd1205_private *macp)
+
+{
+        struct net_device *dev = macp->device;
+
+
+        int rc = 0;
+
+        ZENTER(0);
+        if ((rc = pci_enable_device(pcid)) != 0)
+        {
+                goto err;
+        }
+
+        if (!pci_set_dma_mask(pcid, 0xffffffffffffffff))
+        {
+                macp->using_dac = 1;
+                printk(KERN_DEBUG "zd1205: support 64-bit DMA.\n");
+        }
+
+
+
+        else if (!pci_set_dma_mask(pcid, 0xffffffff))
+        {
+
+                macp->using_dac = 0;
+                printk(KERN_DEBUG "zd1205: support 32-bit DMA.\n");
+
+        } else
+        {
+
+
+                printk(KERN_ERR "zd1205: No suitable DMA available.\n");
+                goto err;
+        }
+
+
+        /* dev and ven ID have already been checked so it is our device */
+        pci_read_config_byte(pcid, PCI_REVISION_ID, (u8 *) &(macp->rev_id));
+
+        /* address #0 is a memory region */
+
+        dev->mem_start = pci_resource_start(pcid, 0);
+        dev->mem_end = dev->mem_start + ZD1205_REGS_SIZE;
+
+        /* address #1 is a IO region */
+        dev->base_addr = pci_resource_start(pcid, 1);
+        if ((rc = pci_request_regions(pcid, zd1205_short_driver_name)) != 0)
+        {
+                goto err_disable;
+        }
+
+        pci_enable_wake(pcid, 0, 0);
+
+        /* if Bus Mastering is off, turn it on! */
+        pci_set_master(pcid);
+
+        /* address #0 is a memory mapping */
+        macp->regp = (void *)ioremap_nocache(dev->mem_start, ZD1205_REGS_SIZE);
+        dot11Obj.reg = macp->regp;
+        //printk(KERN_DEBUG "zd1205: dot11Obj.reg = %x\n", (u32)dot11Obj.reg);
+
+
+        if (!macp->regp)
+        {
+                printk(KERN_ERR "zd1205: %s: Failed to map PCI address 0x%lX\n",
+                       dev->name, pci_resource_start(pcid, 0));
+                rc = -ENOMEM;
+                goto err_region;
+        } else
+                printk(KERN_DEBUG "zd1205: mapping base addr = %x\n", (u32)macp->regp);
+
+        ZEXIT(0);
+        return 0;
+
+err_region:
+        pci_release_regions(pcid);
+
+
+err_disable:
+        pci_disable_device(pcid);
+
+err:
+
+        return rc;
+}
+#endif
+
+
+
+
+/**
+ * zd1205_alloc_space - allocate private driver data
+ * @macp: atapter's private data struct
+ *
+ 
+ * This routine allocates memory for the driver. Memory allocated is for the
+ * selftest and statistics structures.
+ *
+ * Returns:
+ *      0: if the operation was successful
+ *      %-ENOMEM: if memory allocation failed
+ */
+
+
+
+
+unsigned char
+zd1205_alloc_space(struct zd1205_private *macp)
+{
+        /* deal with Tx cached memory */
+        macp->txCachedSize = (macp->numTcb * sizeof(zd1205_SwTcb_t));
+        macp->txCached = kmalloc(macp->txCachedSize, GFP_ATOMIC);
+
+        if (!macp->txCached)
+        {
+                printk(KERN_ERR "zd1205: kmalloc txCached failed\n");
+                return 1;
+
+
+        }
+        else
+        {
+                memset(macp->txCached, 0, macp->txCachedSize);
+                return 0;
+        }
+
+}
+
+
+
+static void
+zd1205_dealloc_space(struct zd1205_private *macp)
+{
+        if (macp->txCached)
+                kfree(macp->txCached);
+
+
+}
+
+
+/* Read the permanent ethernet address from the eprom. */
+void
+zd1205_rd_eaddr(struct zd1205_private *macp)
+{
+        u32 tmpValue;
+
+
+        //ZENTER(0);
+        //The MAC is set by User. We don't load it from EEPROM.
+
+        tmpValue = zd_readl(E2P_MACADDR_P1);
+        ZD1211DEBUG(1, "E2P_MACADDR_P1 = %08x\n", tmpValue);
+
+
+
+
+        macp->device->dev_addr[0] =	macp->macAdr[0] = (u8)tmpValue;//0x00;
+        macp->device->dev_addr[1] =	macp->macAdr[1] = (u8)(tmpValue >> 8);//0xA0;
+        macp->device->dev_addr[2] =	macp->macAdr[2] = (u8)(tmpValue >> 16);//0xC5;
+        macp->device->dev_addr[3] =	macp->macAdr[3] = (u8)(tmpValue >> 24);//0x11;
+        tmpValue = zd_readl(E2P_MACADDR_P2);
+        ZD1211DEBUG(1, "E2P_MACADDR_P2 = %08x\n", tmpValue);
+        macp->device->dev_addr[4] =	macp->macAdr[4] = (u8)tmpValue;//0x22;
+        macp->device->dev_addr[5] =	macp->macAdr[5] = (u8)(tmpValue >> 8);//0x33;
+
+        ZD1211DEBUG(0, "MAC address = %02x:%02x:%02x:%02x:%02x:%02x\n",
+                    macp->device->dev_addr[0], macp->device->dev_addr[1], macp->device->dev_addr[2],
+                    macp->device->dev_addr[3], macp->device->dev_addr[4], macp->device->dev_addr[5]);
+
+
+        macp->cardSetting.MacAddr[0] = macp->macAdr[0];
+
+        macp->cardSetting.MacAddr[1] = macp->macAdr[1];
+
+        macp->cardSetting.MacAddr[2] = macp->macAdr[2];
+        macp->cardSetting.MacAddr[3] = macp->macAdr[3];
+
+        macp->cardSetting.MacAddr[4] = macp->macAdr[4];
+        macp->cardSetting.MacAddr[5] = macp->macAdr[5];
+        //ZEXIT(0);
+}
+
+void
+zd1205_lock(struct zd1205_private *macp)
+{
+#ifndef HOST_IF_USB
+        spin_lock_bh(&macp->conf_lock);
+#else
+
+        spin_lock(&macp->conf_lock);
+#endif
+}
+
+void
+zd1205_unlock(struct zd1205_private *macp)
+{
+#ifndef HOST_IF_USB
+        spin_unlock_bh(&macp->conf_lock);
+#else
+
+        spin_unlock(&macp->conf_lock);
+#endif
+}
+
+//wireless extension helper functions
+/* taken from orinoco.c ;-) */
+const u32 channel_frequency[] =
+        {
+                2412, 2417, 2422, 2427, 2432, 2437, 2442,
+                2447, 2452, 2457, 2462, 2467, 2472, 2484
+
+        };
+const u32 channel_frequency_11A[] =
+        {
+                //Even element for Channel Number, Odd for Frequency
+                36,5180,
+                40,5200,
+                44,5220,
+                48,5240,
+                52,5260,
+                56,5280,
+                60,5300,
+                64,5320,
+                100,5500,
+                104,5520,
+                108,5540,
+                112,5560,
+                116,5580,
+                120,5600,
+                124,5620,
+                128,5640,
+                132,5660,
+                136,5680,
+                140,5700,
+                //
+                184,4920,
+                188,4940,
+                192,4960,
+                196,4980,
+                8,5040,
+                12,5060,
+                16,5080,
+                34,5170,
+                38,5190,
+                42,5210,
+                46,5230,
+                //
+                149,5745,
+                153,5765,
+                157,5785,
+                161,5805,
+                165,5825
+                //
+        };
+
+
+
+
+#define NUM_CHANNELS ( sizeof(channel_frequency) / sizeof(channel_frequency[0]) )
+#define NUM_CHANNELS_11A ( (sizeof(channel_frequency_11A)/2) / sizeof(u32))
+
+#define MAX_KEY_SIZE    13
+//Find the Channel Frequency in channel_frequency_11A
+static u32 channel_11A_to_Freq(const u32 channel)
+{
+        u32 i;
+
+        for(i=0;i<NUM_CHANNELS_11A;i++) {
+                if(channel == channel_frequency_11A[i*2])
+                        return channel_frequency_11A[i*2 + 1];
+        }
+        printk("\n\nWarnning channel_11A_to_Freq fail(CH:%d)\n\n",channel);
+        printk("\n\nZero Return\n\n");
+        return 0;
+}
+#if 0
+static u32 Freq_11A_to_channel(const u32 freq)
+{
+        u32 i;
+
+        for(i=0;i<NUM_CHANNELS_11A;i++) {
+                if(freq == channel_frequency_11A[i*2 + 1])
+                        return channel_frequency_11A[i*2];
+        }
+        printk("\n\nWarnning Freq_11A_to_channel fail(CH:%d)\n\n",freq);
+        printk("\n\nZero Return\n\n");
+        return 0;
+
+}
+#endif
+#define MIN_KEY_SIZE    5
+
+static int
+zd1205_ioctl_setiwencode(struct net_device *dev, struct iw_point *erq, char *key)
+{
+        //BOOLEAN bReconnect=FALSE;
+        struct zd1205_private *macp = dev->priv;
+        card_Setting_t *pSetting = &macp->cardSetting;
+
+        if (erq->length > 0)
+        {
+                int index = (erq->flags & IW_ENCODE_INDEX) - 1;
+                int current_index =  pSetting->EncryKeyId;
+
+                //	ZD1211DEBUG(1, "index = %d\n", index);
+                //	ZD1211DEBUG(1, "erq->length = %d\n", erq->length);
+
+                if (erq->length > MAX_KEY_SIZE)
+                        return -EINVAL;
+
+                if ((index < 0) || (index >= 4))
+                        index = current_index;
+
+                /* Set the length */
+                if (erq->length > MIN_KEY_SIZE) {
+                        pSetting->WepKeyLen = MAX_KEY_SIZE;
+                        pSetting->EncryMode = WEP128;
+                } else {
+                        //	if (erq->length > 0){
+                        pSetting->WepKeyLen = MIN_KEY_SIZE;
+                        pSetting->EncryMode = WEP64;
+                        //	}
+                        //	else {
+                        //		pSetting->WepKeyLen = 0;   /* Disable the key */
+                        //		pSetting->EncryMode = NO_WEP;
+                        //	}
+                }
+
+                /* Check if the key is not marked as invalid */
+                if (!(erq->flags & IW_ENCODE_NOKEY)) {  // for command: key xxxxxxxxxx [n]
+                        //		ZD1211DEBUG(0, "Set contents of key %d\n", index+1);
+                        pSetting->EncryKeyId = index;
+                        memcpy(&pSetting->keyVector[index][0], key, pSetting->WepKeyLen);
+                        zd1205_config_wep_keys(macp);
+                } else { // For command: key on
+                        //			ZD1211DEBUG(0, "key %d is enabled\n", index+1);
+                }
+
+                /* WE specify that if a valid key is set, encryption
+                 * should be enabled (user may turn it off later)
+                 * This is also how "iwconfig ethX key on" works */
+                /*if ((index == current_index) && (pSetting->WepKeyLen > 0) &&
+                	(pSetting->EncryOnOff == 0)) {
+                	pSetting->EncryOnOff = 1;
+                } */
+                pSetting->EncryOnOff=1;
+        } else if(erq->flags & IW_ENCODE_DISABLED)
+        {       // for command: key off
+                //	ZD1211DEBUG(0, "Disable Encryption\n");
+                pSetting->EncryOnOff=0;
+        } else
+        {
+                /* Do we want to just set the transmit key index ? */
+                // For command: (erq->length==0)
+                //              key on (If no key ever set)
+                //              key [n] , change current active key
+                int index = (erq->flags & IW_ENCODE_INDEX) - 1;
+                //ZD1211DEBUG(0, "change key %d as active key\n", index+1);
+                if ((index >= 0) && (index < 4)) {
+                        //			ZD1211DEBUG(0, "Active key id=%d\n", index+1);
+                        pSetting->EncryKeyId = index; // Because pSetting->WepKeyLen has been set, it is not necessary to set it again!
+                        pSetting->EncryOnOff = 1;
+                } else	/* Don't complain if only change the mode */
+                {
+                        if(!(erq->flags & IW_ENCODE_MODE)) {
+                                //				ZD1211DEBUG(0, "change mode for invalid key id:%d\n",index+1);
+                                return -EINVAL;
+                        }
+                }
+        }
+        if(erq->flags & IW_ENCODE_RESTRICTED)
+        {
+                pSetting->EncryOnOff = 1;
+        }
+
+        if(erq->flags & IW_ENCODE_OPEN)
+        {
+                pSetting->EncryOnOff = 1;	// Only Wep
+        }
+
+        //	ZD1211DEBUG(0,"pSetting->EncryOnOff: %d\n", pSetting->EncryOnOff);
+        if (mPrivacyInvoked == pSetting->EncryOnOff)
+        { // Privacy setting is the same as before one, No need do reconnect, just update some global parameters.
+
+                mKeyFormat = pSetting->EncryMode;
+                mKeyId = pSetting->EncryKeyId;
+                mPrivacyInvoked = pSetting->EncryOnOff;
+                if (mPrivacyInvoked)
+                        mCap |= CAP_PRIVACY;
+                else
+                        mCap &= ~CAP_PRIVACY;
+                memcpy(&mKeyVector[0][0], &pSetting->keyVector[0][0],sizeof(mKeyVector));
+                mWepKeyLen = pSetting->WepKeyLen;
+                printk(KERN_DEBUG "Just Update WEP key\n");
+                return 0;
+        }
+        printk(KERN_DEBUG "Update CardSetting\n");
+
+
+#ifdef HOST_IF_USB
+
+        defer_kevent(macp, KEVENT_UPDATE_SETTING);
+#else
+
+        zd_UpdateCardSetting(pSetting);
+#endif
+
+        return 0;
+}
+
+
+
+static int
+zd1205_ioctl_getiwencode(struct net_device *dev, struct iw_point *erq, char *key)
+
+
+{
+        struct zd1205_private *macp = dev->priv;
+        card_Setting_t *pSetting = &macp->cardSetting;
+
+
+
+        int index = (erq->flags & IW_ENCODE_INDEX) - 1;
+
+        zd1205_lock(macp);
+        if (pSetting->EncryOnOff)
+        {
+                erq->flags = IW_ENCODE_OPEN;
+        }
+        else
+        {
+                erq->flags = IW_ENCODE_DISABLED;
+        }
+
+        /* We can't return the key, so set the proper flag and return zero */
+        erq->flags |= IW_ENCODE_NOKEY;
+        memset(key, 0, 16);
+
+        /* Which key do we want ? -1 -> tx index */
+
+        if((index < 0) || (index >= 4))
+                index = pSetting->EncryKeyId;
+
+
+        erq->flags |= index + 1;
+        /* Copy the key to the user buffer */
+
+        erq->length = pSetting->WepKeyLen;
+        if (erq->length > 16)
+        {
+                erq->length = 0;
+
+
+        }
+        zd1205_unlock(macp);
+
+
+        return 0;
+}
+
+static int
+zd1205_ioctl_setessid(struct net_device *dev, struct iw_point *erq)
+{
+        struct zd1205_private *macp = dev->priv;
+        char essidbuf[IW_ESSID_MAX_SIZE+1];
+
+
+        memset(&essidbuf, 0, sizeof(essidbuf));
+
+
+        if (erq->flags)
+        {
+                if (erq->length > (IW_ESSID_MAX_SIZE+1))
+                        return -E2BIG;
+
+                if (copy_from_user(&essidbuf, erq->pointer, erq->length))
+                        return -EFAULT;
+        }
+
+        zd1205_lock(macp);
+
+        //essidbuf[erq->length] = '\0';
+        memcpy(&macp->cardSetting.Info_SSID[2], essidbuf, erq->length);
+        macp->cardSetting.Info_SSID[1] = strlen(essidbuf);
+
+        //memcpy(&macp->cardSetting.Info_SSID[2], essidbuf, erq->length-1);
+        //macp->cardSetting.Info_SSID[1] = erq->length-1;
+        zd1205_unlock(macp);
+
+        return 0;
+}
+static int
+zd1205_ioctl_setbssid(struct net_device *dev, struct iwreq *wrq)
+{
+        //struct zd1205_private *macp = dev->priv;
+        memcpy(dot11DesiredBssid, &wrq->u.ap_addr.sa_data, ETH_ALEN);
+        //ZD1211DEBUG(0,"set AP BSSID=" MACSTR "\n",MAC2STR(dot11DesiredBssid));
+        return 0;
+
+}
+
+static int
+zd1205_ioctl_getessid(struct net_device *dev, struct iw_point *erq)
+{
+        struct zd1205_private *macp = dev->priv;
+        char essidbuf[IW_ESSID_MAX_SIZE+1];
+        u8 len;
+
+        zd1205_lock(macp);
+
+        if (macp->bAssoc)
+        {
+                len = dot11Obj.CurrSsid[1];
+                memcpy(essidbuf, &dot11Obj.CurrSsid[2], len);
+        } else
+        {
+                len = macp->cardSetting.Info_SSID[1];
+                memcpy(essidbuf, &macp->cardSetting.Info_SSID[2], len);
+        }
+
+        essidbuf[len] = 0;
+        zd1205_unlock(macp);
+
+        erq->flags = 1;
+        erq->length = strlen(essidbuf);
+
+        WPADEBUG("zd1205_ioctl_getessid: %s\n", essidbuf);
+
+        //erq->length = strlen(essidbuf) + 1;
+        //zd1205_dump_data("essidbuf", (u8 *)essidbuf, erq->length);
+
+        if (erq->pointer)
+                if ( copy_to_user(erq->pointer, essidbuf, erq->length) )
+                        return -EFAULT;
+        return 0;
+}
+
+static int
+zd1205_ioctl_setfreq(struct net_device *dev, struct iw_freq *frq)
+{
+        struct zd1205_private *macp = dev->priv;
+        int chan = -1;
+        int fflag=0; //Found Flag
+
+        if (macp->cardSetting.BssType == INFRASTRUCTURE_BSS)
+                return -EINVAL;
+
+        if ( (frq->e == 0) && (frq->m <= 1000) )
+        {
+                /* Setting by channel number */
+                chan = frq->m;
+                fflag=1;
+        } else
+        {
+                /* Setting by frequency - search the table */
+                int mult = 1;
+                int i;
+
+                for (i = 0; i < (6 - frq->e); i++)
+                        mult *= 10;
+
+                if(PURE_A_MODE != mMacMode ) {
+                        for (i = 0; i < NUM_CHANNELS; i++)
+                                if (frq->m == (channel_frequency[i] * mult)) {
+                                        chan = i+1;
+                                        fflag=1;
+                                        break;
+                                }
+                } else {
+                        for (i = 0; i < NUM_CHANNELS_11A; i++)
+                                if (frq->m == (channel_frequency_11A[i*2+1] * mult)) {
+                                        chan = channel_frequency_11A[i*2];
+                                        fflag=1;
+                                        break;
+                                }
+                }
+
+        }
+
+        if(PURE_A_MODE != mMacMode)
+        {
+                if ( (chan < 1) || (14 < chan) ) {
+                        printk("We Can't Found Required Channel in ioctl_setfreq(2.4G)\n");
+                        return -EINVAL;
+                }
+        } else
+        {
+                if ( (chan < 1) || (0 == fflag) ) {
+                        printk("We Can't Found Required Channel in ioctl_setfreq(5G)\n");
+                        return -EINVAL;
+                }
+                if( 0 == channel_11A_to_Freq(chan) ) {
+                        printk("The channel isn't exist(%d)\n",chan);
+                        return -EINVAL;
+                }
+
+        }
+
+        zd1205_lock(macp);
+        macp->cardSetting.Channel = chan;
+        zd1205_unlock(macp);
+
+        return 0;
+}
+
+static int
+zd1205_ioctl_setrts(struct net_device *dev, struct iw_param *rrq)
+{
+        struct zd1205_private *macp = dev->priv;
+        int val = rrq->value;
+
+        if (rrq->disabled)
+                val = 2347;
+
+        if ( (val < 0) || (val > 2347) )
+                return -EINVAL;
+
+        zd1205_lock(macp);
+
+        macp->cardSetting.RTSThreshold = val;
+        zd1205_unlock(macp);
+
+        return 0;
+
+}
+
+static int
+zd1205_ioctl_setfrag(struct net_device *dev, struct iw_param *frq)
+{
+        struct zd1205_private *macp = dev->priv;
+
+        int err = 0;
+
+        zd1205_lock(macp);
+
+        if (frq->disabled)
+        {
+                macp->cardSetting.FragThreshold = 2346;
+        } else
+        {
+                if ( (frq->value < 256) || (frq->value > 2346) ) {
+                        err = -EINVAL;
+                } else {
+                        macp->cardSetting.FragThreshold= frq->value & ~0x1; /* must be even */
+                }
+        }
+
+        zd1205_unlock(macp);
+        return err;
+}
+
+static int
+zd1205_ioctl_getfrag(struct net_device *dev, struct iw_param *frq)
+{
+        struct zd1205_private *macp = dev->priv;
+
+        u16 val;
+
+        zd1205_lock(macp);
+        val = macp->cardSetting.FragThreshold;
+        frq->value = val;
+        frq->disabled = (val >= 2346);
+        frq->fixed = 1;
+        zd1205_unlock(macp)
+        ;
+
+        return 0;
+}
+
+static int
+zd1205_ioctl_setrate(struct net_device *dev, struct iw_param *frq)
+{
+        return 0;
+}
+
+static int
+zd1205_ioctl_getrate(struct net_device *dev, struct iw_param *frq)
+{
+        struct zd1205_private *macp = dev->priv;
+
+
+        frq->fixed = 0;
+        frq->disabled = 0;
+        frq->value = 0;
+
+        switch(macp->cardSetting.CurrTxRate)
+        {
+        case RATE_1M:
+                frq->value = 1000000;
+                break;
+
+        case RATE_2M:
+
+                frq->value = 2000000;
+                break;
+
+        case RATE_5M:
+                frq->value = 5500000;
+                break;
+
+        case RATE_11M:
+                frq->value = 11000000;
+                break;
+
+        case RATE_6M:
+                frq->value = 6000000;
+                break;
+
+        case RATE_9M:
+                frq->value = 9000000;
+                break;
+
+        case RATE_12M:
+                frq->value = 12000000;
+                break;
+
+        case RATE_18M:
+                frq->value = 18000000;
+                break;
+
+        case RATE_24M:
+                frq->value = 24000000;
+                break;
+
+        case RATE_36M:
+                frq->value = 36000000;
+                break;
+
+        case RATE_48M:
+                frq->value = 48000000;
+                break;
+
+        case RATE_54M:
+                frq->value = 54000000;
+                break;
+
+        default:
+                return -EINVAL;
+        }
+
+        return 0;
+}
+#if 0 // not used
+static int
+zd1205_ioctl_settxpower(struct net_device *dev, struct iw_param *prq)
+{
+        struct zd1205_private *macp = dev->priv;
+        int ret = 0;
+
+#define TX_17dbm        0x00
+#define TX_14dbm        0x01
+#define TX_11dbm        0x02
+
+        if(prq->value >= TX_17dbm && prq->value <= TX_11dbm)
+                macp->cardSetting.TxPowerLevel = prq->value;
+        else
+                ret = -EINVAL;
+
+        return ret;
+}
+
+static int
+zd1205_ioctl_gettxpower(struct net_device *dev, struct iw_param *prq)
+{
+        struct zd1205_private *macp = dev->priv;
+
+
+#define TX_17dbm        0x00
+#define TX_14dbm        0x01
+#define TX_11dbm        0x02
+
+        prq->flags = 0;
+        prq->disabled = 0;
+        prq->fixed = 0;
+
+        switch(macp->cardSetting.TxPowerLevel)
+        {
+        case TX_17dbm:
+                prq->value = 17;
+                break;
+
+        case TX_14dbm:
+                prq->value = 14;
+                break;
+
+        case TX_11dbm:
+                prq->value = 11;
+                break;
+
+        default:
+                return -EINVAL;
+        }
+
+        return 0;
+}
+#endif
+
+static int
+zd1205_ioctl_setpower(struct net_device *dev, struct iw_param *frq)
+{
+        struct zd1205_private *macp = dev->priv;
+
+        int err = 0;
+
+        zd1205_lock(macp);
+
+        if (frq->disabled)
+        {
+                printk(KERN_ERR "power save disabed\n");
+                macp->cardSetting.ATIMWindow = 0x0;
+                macp->bPSMSupported = 0;
+                macp->PwrState = PS_CAM;
+                zd_EventNotify(EVENT_PS_CHANGE, (U8)macp->PwrState, 0, 0);
+        } else
+        {
+                printk(KERN_ERR "power save enabled\n");
+                macp->cardSetting.ATIMWindow = 0x5;
+                macp->bPSMSupported = 1;
+        }
+
+        zd1205_unlock(macp);
+        HW_UpdatePreTBTT(&dot11Obj, dot11Obj.BeaconInterval-BEFORE_BEACON);
+
+        return err;
+}
+
+static int
+zd1205_ioctl_getpower(struct net_device *dev, struct iw_param *frq)
+{
+        struct zd1205_private *macp = dev->priv;
+
+        zd1205_lock(macp);
+        if (macp->bPSMSupported)
+                frq->disabled = 0;
+        else
+                frq->disabled = 1;
+        zd1205_unlock(macp);
+
+        return 0;
+}
+
+static long
+zd1205_hw_get_freq(struct zd1205_private *macp)
+{
+        u32 freq;
+        zd1205_lock(macp);
+        if(PURE_A_MODE != mMacMode)
+                freq = channel_frequency[dot11Obj.Channel-1] * 100000;
+        else if(PURE_A_MODE == mMacMode)
+                //for PURE_A_MODE the Channel Number is not required to sub one.
+                //Because the channel is get from setting not the order in array
+                freq =  channel_11A_to_Freq(dot11Obj.Channel) * 100000;
+        zd1205_unlock(macp);
+        return freq;
+
+}
+
+static int zd1205_ioctl_setmode(struct net_device *dev, __u32 *mode)
+{
+        struct zd1205_private *macp = dev->priv;
+
+        zd1205_lock(macp);
+        
+        if (macp->cardSetting.BssType == IW_MODE_MONITOR)
+                  zd1205_monitor_mode_disable(macp);
+        
+        switch(*mode)
+        {
+        case IW_MODE_ADHOC:
+                ZD1211DEBUG(0, "Switch to Ad-Hoc mode\n");
+                macp->cardSetting.BssType = INDEPENDENT_BSS;
+
+                if (macp->bDefaultIbssMacMode==0)
+                        macp->cardSetting.MacMode=PURE_B_MODE;
+
+                zd_writel(STA_RX_FILTER, Rx_Filter);
+                break;
+
+        case IW_MODE_INFRA:
+                ZD1211DEBUG(0, "Switch to Infra mode\n");
+                macp->cardSetting.BssType = INFRASTRUCTURE_BSS;
+                macp->cardSetting.AuthMode = 0;
+
+                if (macp->bDefaultIbssMacMode==0) {
+                        macp->cardSetting.MacMode=MIXED_MODE;
+                }
+
+                zd_writel(STA_RX_FILTER, Rx_Filter);
+                break;
+
+
+        case IW_MODE_MASTER:
+                ZD1211DEBUG(0, "Switch to AP mode\n");
+                macp->cardSetting.BssType = AP_BSS;
+
+                /* Set bssid = MacAddress */
+
+                macp->BSSID[0] = macp->macAdr[0];
+                macp->BSSID[1] = macp->macAdr[1];
+                macp->BSSID[2] = macp->macAdr[2];
+
+                macp->BSSID[3] = macp->macAdr[3];
+                macp->BSSID[4] = macp->macAdr[4];
+                macp->BSSID[5] = macp->macAdr[5];
+
+                zd_writel(cpu_to_le32(*(u32 *)&macp->macAdr[0]), BSSID_P1);
+                zd_writel(cpu_to_le32(*(u32 *)&macp->macAdr[4]), BSSID_P2);
+                macp->cardSetting.AuthMode = 2; 	//auto auth
+                zd_writel(AP_RX_FILTER, Rx_Filter);
+                netif_start_queue(dev);
+                break;
+
+        case IW_MODE_MONITOR:
+                ZD1211DEBUG(0, "Switch to Monitor mode\n");
+                macp->cardSetting.BssType = IW_MODE_MONITOR;
+                zd1205_monitor_mode_enable(macp);
+                break;
+
+        default:
+                ZD1211DEBUG(0, "Switch to PSEUDO_IBSS mode\n");
+                macp->cardSetting.BssType = PSEUDO_IBSS;
+                zd_writel(STA_RX_FILTER, Rx_Filter);
+                break;
+
+        }
+
+        macp->bAssoc = 0;
+        if (macp->usb->speed != USB_SPEED_HIGH)
+                macp->cardSetting.MacMode = PURE_B_MODE;
+        else
+        {
+#if 0
+                if (macp->cardSetting.BssType == INDEPENDENT_BSS)
+                        macp->cardSetting.MacMode = PURE_B_MODE;
+                else
+                        macp->cardSetting.MacMode = MIXED_MODE;
+#endif
+
+        }
+
+        zd1205_SetRatesInfo(macp);
+        zd1205_unlock(macp);
+        return 0;
+}
+
+
+/////////////////////////
+
+static int
+zd1205_ioctl_getretry(struct net_device *dev, struct iw_param *prq)
+{
+        return 0;
+}
+
+/* For WIRELESS_EXT > 12 */
+static int zd1205wext_giwfreq(struct net_device *dev, struct iw_request_info *info, struct iw_freq *freq, char *extra)
+{
+        struct zd1205_private *macp;
+        if(!netif_running(dev))
+                return -EINVAL;
+
+        macp = dev->priv;
+        freq->m = zd1205_hw_get_freq(macp);
+        freq->e = 1;
+        return 0;
+}
+
+static int zd1205wext_siwmode(struct net_device *dev, struct iw_request_info *info, __u32 *mode, char *extra)
+{
+        int err;
+        err = zd1205_ioctl_setmode(dev, mode);
+        return err;
+}
+
+
+static int zd1205wext_giwmode(struct net_device *dev, struct iw_request_info *info, __u32 *mode, char *extra)
+{
+        struct zd1205_private *macp = dev->priv;
+        u8 BssType = macp->cardSetting.BssType;
+
+        if(!netif_running(dev))
+                return -EINVAL;
+
+        zd1205_lock(macp);
+
+        switch(BssType)
+        {
+        case AP_BSS:
+                *mode = IW_MODE_MASTER;
+                break;
+
+        case INFRASTRUCTURE_BSS:
+                *mode = IW_MODE_INFRA;
+                break;
+
+        case INDEPENDENT_BSS:
+                *mode = IW_MODE_ADHOC;
+                break;
+
+        case IW_MODE_MONITOR:
+                *mode = IW_MODE_MONITOR;
+                break;
+
+        default:
+                *mode = IW_MODE_ADHOC;
+                break;
+        }
+
+        zd1205_unlock(macp);
+        return 0;
+}
+
+static int zd1205wext_giwrate(struct net_device *dev, struct iw_request_info *info, struct iw_param *rrq, char *extra)
+{
+        if(!netif_running(dev))
+                return -EINVAL;
+
+        return zd1205_ioctl_getrate(dev, rrq);
+}
+
+static int zd1205wext_giwrts(struct net_device *dev, struct iw_request_info *info, struct iw_param *rts, char *extra)
+{
+        struct zd1205_private *macp;
+        macp = dev->priv;
+
+        if(!netif_running(dev))
+                return -EINVAL;
+
+        rts->value = macp->cardSetting.RTSThreshold;
+        rts->disabled = (rts->value == 2347);
+        rts->fixed = 1;
+
+        return 0;
+}
+
+static int zd1205wext_giwfrag(struct net_device *dev, struct iw_request_info *info, struct iw_param *frag, char *extra)
+{
+        if(!netif_running(dev))
+                return -EINVAL;
+
+        return zd1205_ioctl_getfrag(dev, frag);
+}
+#if 0 // not used
+static int zd1205wext_giwtxpow(struct net_device *dev, struct iw_request_info *info, struct iw_param *rrq, char *extra)
+{
+        if(!netif_running(dev))
+                return -EINVAL;
+
+        return zd1205_ioctl_gettxpower(dev, rrq);
+}
+
+static int zd1205wext_siwtxpow(struct net_device *dev, struct iw_request_info *info, struct iw_param *rrq, char *extra)
+{
+        return zd1205_ioctl_settxpower(dev, rrq);
+}
+#endif
+
+static int zd1205wext_giwrange(struct net_device *dev, struct iw_request_info *info, struct iw_point *data, char *extra)
+{
+        struct iw_range *range = (struct iw_range *) extra;
+        int i, val;
+        if(!netif_running(dev))
+                return -EINVAL;
+
+
+#if WIRELESS_EXT > 9
+
+        range->txpower_capa = IW_TXPOW_DBM;
+        // XXX what about min/max_pmp, min/max_pmt, etc.
+#endif
+
+#if WIRELESS_EXT > 10
+
+        range->we_version_compiled = WIRELESS_EXT;
+        range->we_version_source = 13;
+        range->retry_capa = IW_RETRY_LIMIT;
+        range->retry_flags = IW_RETRY_LIMIT;
+        range->min_retry = 0;
+        range->max_retry = 255;
+
+#endif /* WIRELESS_EXT > 10 */
+
+
+
+        /* XXX need to filter against the regulatory domain &| active set */
+        val = 0;
+        if(PURE_A_MODE != mMacMode )
+        {
+                for (i = 0; i < NUM_CHANNELS ; i++) {
+                        range->freq[val].i = i + 1;
+                        range->freq[val].m = channel_frequency[i] * 100000;
+                        range->freq[val].e = 1;
+                        val++;
+                }
+        } else if(PURE_A_MODE == mMacMode)
+        {
+                for (i = 0; i < NUM_CHANNELS_11A && i < 32; i++) {
+                        range->freq[val].i = channel_frequency_11A[i*2];
+                        ;
+                        range->freq[val].m = channel_frequency_11A[i*2+1] * 100000;
+                        range->freq[val].e = 1;
+                        val++;
+                        //For 802.11a, there are too more frequency. We can't return them all
+                }
+
+        }
+
+
+        range->num_frequency = val;
+
+        /* Max of /proc/net/wireless */
+        range->max_qual.qual = 100;
+        range->max_qual.level = 100;
+
+        range->max_qual.noise = 100;
+        range->sensitivity = 3;
+
+        // XXX these need to be nsd-specific!
+        range->min_rts = 256;
+        range->max_rts = 2346;
+
+        range->min_frag = 256;
+        range->max_frag = 2346;
+        range->max_encoding_tokens = NUM_WEPKEYS;
+        range->num_encoding_sizes = 2;
+        range->encoding_size[0] = 5;
+        range->encoding_size[1] = 13;
+
+        // XXX what about num_bitrates/throughput?
+        range->num_bitrates = 0;
+
+        /* estimated max throughput */
+        // XXX need to cap it if we're running at ~2Mbps..
+        range->throughput = 5500000;
+
+        return 0;
+}
+
+#if WIRELESS_EXT > 13
+static int zd1205wext_siwscan(struct net_device *dev, struct iw_request_info *info, struct iw_point *data, char *extra)
+{
+        //    u8 i;
+        //  u8 oldMacMode;
+        //u32 ul_mac_ps_state;
+        //u16 channel;
+        //BOOLEAN ProbeWithSsid_bak;
+        struct zd1205_private *macp = g_dev->priv;
+        u32 wait_cnt = 0;
+
+        if(!netif_running(dev))
+                return -EINVAL;
+
+        goto scanning_done;
+#if 0
+        // If the device is scanning when user issue site survey request, we use the result of it directly.
+        if (dot11Obj.bChScanning)
+        { // Use the result of driver-driven scan.
+                while (dot11Obj.bChScanning) {
+                        int cnt=0;
+                        cnt++;
+                        if(cnt>500) {
+                                printk("Locked in waitting bChScanning for 5s. Exit!\n");
+                                dot11Obj.bChScanning=FALSE;
+                                CurrScanCH=1;
+                                return 0;
+                        }
+                        wait_ms(10);
+                }
+                goto scanning_done;
+        } else
+        {
+                // Set Scanning flag firstly to prevent device from entering sleeping state again before complete of site survey.
+                dot11Obj.bChScanning=1;
+                while (dot11Obj.bDeviceInSleep) { // busy wait until the device is awaken.
+                        wait_ms(1);
+                }
+        }
+
+        //***********************************************************************
+        // Execute site survey request only bChScanning flag is FALSE.
+        { // Execute user's site survey request.
+                ProbeWithSsid_bak=mProbeWithSsid;
+                mProbeWithSsid=0;  // Send Probe request with broadcast ssid.
+                zd_ScanBegin();
+                for (channel=1; channel <= 14; channel++)
+                {
+                        zd_CmdScanReq(channel);//Set RF channel then send ProbeRequest
+                        wait_ms(100);
+                }
+                zd_ScanEnd();
+                dot11Obj.bChScanning=0;
+                mProbeWithSsid=ProbeWithSsid_bak;
+        }
+#endif
+scanning_done:
+        if(!dot11Obj.bChScanning)
+        {
+                if(1 || mAssoc) {
+                        dot11Obj.ConfigFlag |= JUST_CHANNEL_SCAN;
+                        zd_CmdProbeReq(0);
+                } else
+                        ;// This mean there is one just done scanning.
+        }
+        while(dot11Obj.bChScanning)
+        {
+                if(wait_cnt++ > 100) {
+                        int i;
+                        for(i=0;i<10;i++)
+                                printk(KERN_ERR "UnStoppable Scanning\n");
+                        dot11Obj.bChScanning=0;
+                        break;
+                }
+                wait_ms(50);
+        }
+
+        zd1205_notify_scan_done(macp);
+        set_bit(CTX_FLAG_ESSID_WAS_SET, (void *)&macp->flags);
+
+
+        return 0;
+
+}
+
+#if WIRELESS_EXT > 14
+/*
+ * Encode a WPA or RSN information element as a custom
+ * element using the hostap format.
+ */
+static u_int
+encode_ie(void *buf, size_t bufsize,
+          const u_int8_t *ie, size_t ielen,
+          const char *leader, size_t leader_len)
+{
+        u8 *p;
+        int i;
+
+        if (bufsize < leader_len)
+                return 0;
+        p = buf;
+        memcpy(p, leader, leader_len);
+        bufsize -= leader_len;
+        p += leader_len;
+        for (i = 0; i < ielen && bufsize > 2; i++)
+                p += sprintf(p, "%02x", ie[i]);
+        return (i == ielen ? p - (u8 *)buf : 0);
+}
+#endif /* WIRELESS_EXT > 14 */
+
+/*------------------------------------------------------------------*/
+/*
+ * Translate scan data returned from the card to a card independent
+ * format that the Wireless Tools will understand 
+ */
+static char *zd1205_translate_scan(struct net_device *dev,
+                                   char *current_ev,
+                                   char *end_buf,
+                                   bss_info_t *list)
+{
+        struct iw_event	iwe;		/* Temporary buffer */
+        u16	capabilities;
+
+#if WIRELESS_EXT > 14
+
+        char buf[64*2 + 30];
+#endif
+
+        char *current_val;	/* For rates */
+        U32 Tmp;
+        int	i;
+
+        /* First entry *MUST* be the AP MAC address */
+        iwe.cmd = SIOCGIWAP;
+        iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+        memcpy(iwe.u.ap_addr.sa_data, list->bssid, ETH_ALEN);
+        current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_ADDR_LEN);
+
+        /* Other entries will be displayed in the order we give them */
+
+        /* Add the ESSID */
+        iwe.u.data.length = list->ssid[1];
+        if(iwe.u.data.length > 32)
+                iwe.u.data.length = 32;
+        iwe.cmd = SIOCGIWESSID;
+        iwe.u.data.flags = 1;
+        current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, &list->ssid[2]);
+
+        /* Add mode */
+        iwe.cmd = SIOCGIWMODE;
+        capabilities = list->cap;
+        if(capabilities & (0x01 | 0x02))
+        {
+                if(capabilities & 0x01)
+                        iwe.u.mode = IW_MODE_MASTER;
+
+                else
+                        iwe.u.mode = IW_MODE_ADHOC;
+                current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_UINT_LEN);
+        }
+
+        /* Add frequency */
+        iwe.cmd = SIOCGIWFREQ;
+        iwe.u.freq.m = list->channel;
+        if(list->apMode != PURE_A_AP)
+                iwe.u.freq.m = channel_frequency[iwe.u.freq.m-1] * 100000;
+        else
+        {
+                iwe.u.freq.m = channel_11A_to_Freq(iwe.u.freq.m) * 100000;
+        }
+        iwe.u.freq.e = 1;
+        current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_FREQ_LEN);
+
+#if WIRELESS_EXT < 15
+        /* Add quality statistics */
+        iwe.cmd = IWEVQUAL;
+
+        Tmp = -(100 - list->signalStrength);
+        Tmp = Tmp >  -40 ?  -40: Tmp;
+        Tmp = Tmp < -105 ? -105: Tmp;
+        Tmp = (Tmp + 105)*100/65;
+        iwe.u.qual.level = Tmp;
+        iwe.u.qual.noise = 0;
+        iwe.u.qual.qual = list->signalQuality;
+        current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_QUAL_LEN);
+#else
+        // Transform Signal quality from level to percentage
+        memset(&iwe, 0, sizeof(iwe));
+        iwe.cmd = IWEVCUSTOM;
+        Tmp = -(100 - list->signalStrength);
+        Tmp = Tmp >  -40 ?  -40: Tmp;
+        Tmp = Tmp < -105 ? -105: Tmp;
+        Tmp = (Tmp + 105)*100/65;
+
+        snprintf(buf, sizeof(buf), "SignalStrength=%d\%,LinkQuality:%d\%", Tmp,list->signalQuality);
+        iwe.u.data.length = strlen(buf);
+        current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, buf);
+#endif
+        //
+        /* Add encryption capability */
+
+        iwe.cmd = SIOCGIWENCODE;
+        if(capabilities & 0x10)
+                iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+        else
+                iwe.u.data.flags = IW_ENCODE_DISABLED;
+        iwe.u.data.length = 0;
+        current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, list->ssid);
+
+        /* Rate : stuffing multiple values in a single event require a bit
+         * more of magic */
+        current_val = current_ev + IW_EV_LCP_LEN;
+
+
+        iwe.cmd = SIOCGIWRATE;
+
+
+        /* Those two flags are ignored... */
+        iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
+
+        for(i = 0 ; i < list->supRates[1] ; i++)
+        {
+                /* Bit rate given in 500 kb/s units (+ 0x80) */
+                iwe.u.bitrate.value = ((list->supRates[i+2] & 0x7f) * 500000);
+                /* Add new value to event */
+                current_val = iwe_stream_add_value(current_ev, current_val, end_buf, &iwe, IW_EV_PARAM_LEN);
+        }
+
+        if (list->apMode != PURE_B_AP)
+        {
+                for (i = 0 ; i < list->extRates[1] ; i++) {
+                        /* Bit rate given in 500 kb/s units (+ 0x80) */
+                        iwe.u.bitrate.value = ((list->extRates[i+2] & 0x7f) * 500000);
+                        /* Add new value to event */
+                        current_val = iwe_stream_add_value(current_ev, current_val, end_buf, &iwe, IW_EV_PARAM_LEN);
+                }
+        }
+
+        /* Check if we added any event */
+        if((current_val - current_ev) > IW_EV_LCP_LEN)
+                current_ev = current_val;
+
+#if WIRELESS_EXT > 14
+
+#define	IEEE80211_ELEMID_RSN	0x30
+
+        memset(&iwe, 0, sizeof(iwe));
+        iwe.cmd = IWEVCUSTOM;
+        snprintf(buf, sizeof(buf), "bcn_int=%d", list->beaconInterval);
+        iwe.u.data.length = strlen(buf);
+        current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, buf);
+
+        if (list->WPAIe[1] != 0)
+        {
+                static const char rsn_leader[] = "rsn_ie=";
+                static const char wpa_leader[] = "wpa_ie=";
+
+                memset(&iwe, 0, sizeof(iwe));
+                iwe.cmd = IWEVCUSTOM;
+                if (list->WPAIe[0] == IEEE80211_ELEMID_RSN)
+                        iwe.u.data.length = encode_ie(buf, sizeof(buf),
+                                                      list->WPAIe, list->WPAIe[1]+2,
+                                                      rsn_leader, sizeof(rsn_leader)-1);
+                else
+                        iwe.u.data.length = encode_ie(buf, sizeof(buf),
+                                                      list->WPAIe, list->WPAIe[1]+2,
+                                                      wpa_leader, sizeof(wpa_leader)-1);
+                if (iwe.u.data.length != 0)
+                        current_ev = iwe_stream_add_point(current_ev, end_buf,
+                                                          &iwe, buf);
+        }
+        if (list->RSNIe[1] != 0)
+        {
+                static const char rsn_leader[] = "rsn_ie=";
+                memset(&iwe, 0, sizeof(iwe));
+                iwe.cmd = IWEVCUSTOM;
+                if (list->RSNIe[0] == IEEE80211_ELEMID_RSN) {
+                        iwe.u.data.length = encode_ie(buf, sizeof(buf),
+                                                      list->RSNIe, list->RSNIe[1]+2,
+                                                      rsn_leader, sizeof(rsn_leader)-1);
+                        if (iwe.u.data.length != 0)
+                                current_ev = iwe_stream_add_point(current_ev, end_buf,	&iwe, buf);
+                }
+        }
+
+#endif /* WIRELESS_EXT > 14 */
+
+        /* The other data in the scan result are not really
+         * interesting, so for now drop it */
+        return current_ev;
+}
+
+
+static int zd1205wext_giwscan(struct net_device *dev, struct iw_request_info *info, struct iw_point *data, char *extra)
+{
+        struct zd1205_private *macp = dev->priv;
+        char *current_ev = extra;
+        int i;
+
+        if(!netif_running(dev))
+                return -EINVAL;
+
+
+        //ZENTER(0);
+
+        macp->bss_index = zd_GetBssList(&macp->BSSInfo[0]);
+        //ZD1211DEBUG(0, "macp->bss_index = %x\n", macp->bss_index);
+
+        /* Read and parse all entries */
+        for (i=0; i<macp->bss_index; i++)
+        {
+                /* Translate to WE format this entry */
+                current_ev = zd1205_translate_scan(dev, current_ev,
+                                                   extra + IW_SCAN_MAX_DATA,
+                                                   &macp->BSSInfo[i]);
+
+        }
+
+        /* Length of data */
+        data->length = (current_ev - extra);
+        data->flags = 0;	/* todo */
+
+        return 0;
+}
+
+#endif
+#ifdef ZDCONF_APDBG
+void zd1205_dumpEEPROM(struct zd1205_private *macp)
+{
+        int i,ret;
+        u8 int54,int36,cal54,cal36;
+
+        if(AL7230B_RF == dot11Obj.rfMode)
+        {
+                printk("802.11a Integration & SetPoint Values:\n");
+                printk("-----------------------------------------\n");
+        }
+
+        for(i=0;i<dot11A_Channel_Amount && AL7230B_RF == dot11Obj.rfMode ;i++)
+        {
+                ret = a_OSC_get_cal_int(dot11A_Channel[i], RATE_36M, &int36, &cal36);
+                if( 0xff == ret	) {
+                        printk("Channel %d doesn't exist in zd1205_dumpEEPROM\n",i);
+                }
+                ret = a_OSC_get_cal_int(dot11A_Channel[i], RATE_54M, &int54, &cal54);
+
+                printk("Channel:%3d Int:%x Set36:%x Set54:%x\n",
+                       dot11A_Channel[i],int36,cal36,cal54);
+
+        }
+        printk("\n802.11b/g Integration & SetPoint Values:\n");
+        printk("-----------------------------------------\n");
+
+        for(i=1;i<=14;i++)
+        {
+                printk("Channel:%3d Int:%x Set11:%x Set36:%x Set48:%x Set54:%x\n",
+                       i,
+                       dot11Obj.IntValue[i-1],
+                       macp->EepSetPoint[i-1],
+                       macp->SetPointOFDM[0][i-1],
+                       macp->SetPointOFDM[1][i-1],macp->SetPointOFDM[2][i-1]);
+        }
+
+}
+#endif
+
+void zd1205_list_bss(struct zd1205_private *macp)
+{
+        int i, j;
+        U32 Tmp;
+
+        u16 cap;
+        bss_info_t *pBssInfo;
+
+        printk("\nSSID          BSSID            CH  Signal  Mode     Basic-Rates  Ext-Rates    b/g AP");
+        printk("\n------------------------------------------------------------------------------------");
+
+        for (i=0; i<macp->bss_index; i++)
+        {
+                pBssInfo = &macp->BSSInfo[i];
+                printk("\n");
+
+                for (j=0; j<pBssInfo->ssid[1]; j++) {
+                        printk("%c", pBssInfo->ssid[2+j]);
+                }
+
+                for (j=pBssInfo->ssid[1]; j<12; j++) {
+                        printk(" ");
+                }
+
+                printk("%02x:%02x:%02x:%02x:%02x:%02x",
+                       pBssInfo->bssid[0], pBssInfo->bssid[1], pBssInfo->bssid[2],
+                       pBssInfo->bssid[3], pBssInfo->bssid[4], pBssInfo->bssid[5]);
+                printk("  %2d", pBssInfo->channel);
+                Tmp = -(100 - pBssInfo->signalStrength);
+                Tmp = Tmp >  -40 ?  -40: Tmp;
+                Tmp = Tmp < -105 ? -105: Tmp;
+                Tmp = (Tmp + 105)*100/65;
+
+                printk("   %2d %", Tmp);
+
+                cap = pBssInfo->cap;
+                cap &= (0x10 | 0x02 | 0x01);
+
+                switch(cap) {
+                case 0x01:
+
+                        printk("   Infra   ");
+                        break;
+
+                case 0x02:
+                        printk("   Ad_Hoc  ");
+                        break;
+
+                case 0x11:
+                        printk("   Infra, W");
+                        break;
+
+                case 0x12:
+                        printk("   Ad_Hoc,W");
+                        break;
+
+                default :
+                        break;
+                }
+
+
+                printk("  ");
+
+                for (j=0; j<pBssInfo->supRates[1]; j++) {
+                        printk(" %x", pBssInfo->supRates[2+j]);
+                }
+
+                printk("  ");
+                for (j=0; j<pBssInfo->extRates[1]; j++) {
+                        printk(" %x", pBssInfo->extRates[2+j]);
+
+                }
+
+                if (pBssInfo->apMode == PURE_B_AP)
+                        printk("   B-AP");
+                else if (pBssInfo->apMode == PURE_G_AP)
+                        printk("   G-AP");
+                else if  (pBssInfo->apMode == MIXED_AP)
+                        printk("   M-AP");
+                else if (pBssInfo->apMode == PURE_A_AP)
+                        printk(" A-AP");
+                else {
+                        VerAssert();
+                }
+        }
+        printk("\n");
+}
+
+
+/* ath_desc: support for unpatched wpasupplicant */
+static void zd1211_print_auth_alg_desc(const u32 auth_alg) {
+	if (auth_alg & IW_AUTH_ALG_OPEN_SYSTEM)
+		printk("  Open system");
+	if (auth_alg & IW_AUTH_ALG_SHARED_KEY)
+		printk("  Shared key");
+	if (auth_alg & IW_AUTH_ALG_LEAP)
+		printk("  LEAP");
+	printk("\n");
+}
+
+static const char * zd1211_print_enabled_disabled(const u32 value) {
+	return (value ? "enabled" : "disabled");
+}
+
+static void zd1211_print_cipher(const u32 cipher) {
+	switch (cipher) {
+	case IW_AUTH_CIPHER_NONE:
+		printk(" NONE");
+		break;
+	case IW_AUTH_CIPHER_WEP40:
+		printk(" WEP40");
+		break;
+	case IW_AUTH_CIPHER_TKIP:
+		printk(" TKIP");
+		break;
+	case IW_AUTH_CIPHER_CCMP:
+		printk(" CCMP");
+		break;
+	case IW_AUTH_CIPHER_WEP104:
+		printk(" WEP104");
+		break;
+	default:
+		printk(" unsupported cipher '0x%0X8'", cipher);
+	}
+	printk("\n");
+}
+
+static void zd1211_print_key_mgmt(const u32 key_mgmt) {
+	switch (key_mgmt) {
+	case IW_AUTH_KEY_MGMT_802_1X:
+		printk(" IEEE802.1X");
+		break;
+	case IW_AUTH_KEY_MGMT_PSK:
+		printk(" PSK");
+		break;
+	default:
+		printk(" unsupported key mgmt '0x%0X8'", key_mgmt);
+	}
+	printk("\n");
+}
+
+static void zd1211_print_roaming(const u32 roaming) {
+	switch (roaming) {
+	case IW_AUTH_ROAMING_ENABLE:
+		printk(" driver/firmware based");
+		break;
+	case IW_AUTH_ROAMING_DISABLE:
+		printk(" done in user space");
+		break;
+	default:
+		printk(" unsupported roaming strategy '0x%0X8'", roaming);
+	}
+	printk("\n");
+}
+
+static void zd1211_print_wpa_version(const u32 wpa_version) {
+	switch (wpa_version) {
+	case IW_AUTH_WPA_VERSION_DISABLED:
+		printk(" WPA disabled");
+		break;
+	case IW_AUTH_WPA_VERSION_WPA:
+		printk(" WPA");
+		break;
+	case IW_AUTH_WPA_VERSION_WPA2:
+		printk(" WPA2");
+		break;
+	default:
+		printk(" unsupported version '0x%0X8'", wpa_version);
+	}
+	printk("\n");
+}
+
+static const int zd1211_set_auth_param(struct net_device *net_dev, const int idx, const u32 value) {
+	int result;
+	struct zd1205_private *macp;
+
+	macp = net_dev->priv;
+	result = -EINVAL;
+	switch(idx) {
+	case IW_AUTH_WPA_VERSION:
+		printk(KERN_INFO "%s: WPA version: ", net_dev->name);
+		zd1211_print_wpa_version(value);
+		result = 0;
+		break;
+	case IW_AUTH_CIPHER_PAIRWISE:
+		printk(KERN_INFO "%s: pairwise cipher: ", net_dev->name);
+		zd1211_print_cipher(value);
+		result = 0;
+		break;
+	case IW_AUTH_CIPHER_GROUP:
+		printk(KERN_INFO "%s: group cipher: ", net_dev->name);
+		zd1211_print_cipher(value);
+		result = 0;
+		break;
+	case IW_AUTH_KEY_MGMT:
+		printk(KERN_INFO "%s: key mgmt: ", net_dev->name);
+		zd1211_print_key_mgmt(value);
+		result = 0;
+		break;
+	case IW_AUTH_80211_AUTH_ALG:
+		printk(KERN_INFO "%s: Configured authentication algorithms:", net_dev->name);
+		zd1211_print_auth_alg_desc(value);
+		result = 0;
+		break;
+	case IW_AUTH_DROP_UNENCRYPTED:
+		printk(KERN_INFO "%s: Drop encrypted: %s\n", net_dev->name, zd1211_print_enabled_disabled(value) );
+		result = 0;
+		break;
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+		if (value) {
+			mCounterMeasureState = dot11Obj.MIC_CNT ? 1 : 0;
+			printk(KERN_INFO "%s: TKIP counter measures: %s\n", net_dev->name, zd1211_print_enabled_disabled(mCounterMeasureState) );
+		}
+		result = 0;
+		break;
+	case IW_AUTH_WPA_ENABLED:
+		if (value) {
+			macp->cardSetting.WPASupport = 1;
+		} else {
+			/* Reset the WPA related variables */
+			macp->cardSetting.WPASupport = 0;
+			/* Now we only set the length in the WPA IE
+			 * field to zero.                         */
+			macp->cardSetting.WPAIe[1] = 0;
+		}
+		printk(KERN_INFO "%s: WPA: %s\n", net_dev->name, zd1211_print_enabled_disabled(value) );
+		result = 0;
+		break;
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		printk(KERN_INFO "%s: Allow Rx unencrypted EAPOL: %s\n", net_dev->name, zd1211_print_enabled_disabled(value) );
+		result = 0;
+		break;
+	case IW_AUTH_ROAMING_CONTROL:
+		printk(KERN_INFO "%s: roaming: ", net_dev->name);
+		macp->cardSetting.ap_scan=(U8)value;
+		zd1211_print_roaming(value);
+		result = 0;
+		break;
+	case IW_AUTH_PRIVACY_INVOKED:
+		/* Turn on/off the privacy invoke flag */
+		macp->cardSetting.EncryOnOff = value ? 1 : 0;
+		printk(KERN_INFO "%s: privacy: %s\n", net_dev->name, zd1211_print_enabled_disabled(value) );
+		result = 0;
+		break;
+	default:
+		printk(KERN_INFO "%s(): unsupported function/value pair: %d %u\n", __FUNCTION__, idx, value);
+		break;
+	}
+	return result;
+}
+
+static U8 zero_mac[]={0,0,0,0,0,0};
+// SIOCSIWENCODEEXT
+static const int zd1211_set_encode_ext(struct zd1205_private *macp, struct iwreq *wrq) {
+	int i_key;
+	u8 *key;
+	size_t key_len;
+	struct iw_encode_ext *ext;
+        card_Setting_t *pSetting = &macp->cardSetting;
+        u8 CamEncryType=0;
+        u8 tmpDynKeyMode;
+
+	ext = wrq->u.encoding.pointer;
+	key = ext->key;
+	i_key = wrq->u.encoding.flags - 1;
+	key_len = ext->key_len;
+	switch (ext->alg) {
+	case IW_ENCODE_ALG_CCMP:
+		CamEncryType = AES;
+		//if (idx == 0)
+		{// Pairwise key
+			mKeyFormat = CamEncryType;
+			mDynKeyMode = pSetting->DynKeyMode = DYN_KEY_AES;
+		}
+		break;
+	case IW_ENCODE_ALG_TKIP:
+		CamEncryType = TKIP;
+		//if (idx == 0)
+		{// Pairwise key
+			mKeyFormat = CamEncryType;
+			mDynKeyMode = pSetting->DynKeyMode = DYN_KEY_TKIP;
+		}
+		break;
+	case IW_ENCODE_ALG_WEP:
+		if (key_len == 5) { // WEP 64
+			CamEncryType = WEP64;
+			tmpDynKeyMode=DYN_KEY_WEP64;
+		} else {//keylen=13, WEP 128
+			CamEncryType = WEP128;
+			tmpDynKeyMode=DYN_KEY_WEP128;
+		}
+		// For Dynamic WEP key (Non-WPA Radius), the key ID range: 0-3
+		// In WPA/RSN mode, the key ID range: 1-3, usually, a broadcast key.
+		// For WEP key setting: we set mDynKeyMode and mKeyFormat in following case:
+		//   1. For 802.1x dynamically generated WEP key method.
+		//   2. For WPA/RSN mode, but key id == 0. (But this is an impossible case)
+		// So, only check case 1.
+		if (pSetting->WPAIeLen==0) {
+			mKeyFormat = CamEncryType;
+			mDynKeyMode = pSetting->DynKeyMode = tmpDynKeyMode;
+			mPrivacyInvoked=TRUE;
+			mCap |= CAP_PRIVACY;
+			pSetting->EncryOnOff=1;
+		}
+		break;
+	case IW_ENCODE_ALG_NONE:
+	default:
+		CamEncryType = NO_WEP;
+		//	pSetting->DynKeyMode = 0;
+		//      pSetting->EncryMode=0;
+		//    mKeyFormat=0;
+
+		zd_SetKeyInfo(ext->addr.sa_data, CamEncryType, key_len, i_key, key);
+		if (ext->addr.sa_data[0] & 1)//del group key
+		{
+			if (pSetting->WPAIeLen==0)
+			{//802.1x dynamic WEP
+				mDynKeyMode = 0;
+				mKeyFormat = 0;
+				mPrivacyInvoked=FALSE;
+				mCap &= ~CAP_PRIVACY;
+				pSetting->EncryOnOff=0;
+			}
+			mWpaBcKeyLen = mGkInstalled = 0;
+		} else {
+			if (memcmp(zero_mac, ext->addr.sa_data, 6)==0) {
+				mDynKeyMode=0;
+				mKeyFormat=0;
+				pSetting->DynKeyMode=0;
+				pSetting->EncryMode=0;
+				mDynKeyMode=0;
+			}
+		}
+		goto exit_zd1211_set_encode_ext;
+		break;
+	}
+	zd_SetKeyInfo(ext->addr.sa_data, CamEncryType, key_len, i_key, key);
+exit_zd1211_set_encode_ext:
+	return 0;
+}
+
+// SIOCSIWGENIE
+static const int zd1211_set_wpa_ie(struct zd1205_private *macp, struct iwreq *wrq) {
+        card_Setting_t *pSetting = &macp->cardSetting;
+
+	/* Copy the WPA IE */
+	pSetting->WPAIeLen = wrq->u.data.length;
+	memcpy(&pSetting->WPAIe, wrq->u.data.pointer, pSetting->WPAIeLen);
+#ifdef HOSTAPD_SUPPORT
+	if (pSetting->BssType == AP_BSS) {// Update Beacon FIFO in the next TBTT.
+		memcpy(&mWPAIe, pSetting->WPAIe, pSetting->WPAIeLen);
+		WPADEBUG("Copy WPA IE into mWPAIe\n");
+	}
+#endif
+	return 0;
+}
+
+
+const int zd1211_mlme(struct zd1205_private *macp) {
+	int result;
+#ifdef HOSTAPD_SUPPORT
+	u8 mac_addr[80];
+#endif
+
+	result = -ENOTSUPP;
+	/* Translate STA's address */
+	sprintf(mac_addr, "%02x:%02x:%02x:%02x:%02x:%02x", 
+		(u8)macp->mlme_req.addr.sa_data[0], (u8)macp->mlme_req.addr.sa_data[1],
+		(u8)macp->mlme_req.addr.sa_data[2], (u8)macp->mlme_req.addr.sa_data[3], 
+		(u8)macp->mlme_req.addr.sa_data[4], (u8)macp->mlme_req.addr.sa_data[5]);
+	switch(macp->mlme_req.cmd) {
+	case MLME_STA_DEAUTH:
+		if (zd_CmdDeauth((MacAddr_t *) macp->mlme_req.addr.sa_data, macp->mlme_req.reason_code) == FALSE) {
+			printk(KERN_ERR "Can't deauthencate STA: %s\n", mac_addr);
+			result = -EIO;
+		} else {
+			printk(KERN_INFO "Deauthenticate STA: %s with reason code: %d\n", mac_addr, macp->mlme_req.reason_code);
+			result = 0;
+		}
+		break;
+	case MLME_STA_DISASSOC:
+		if (zd_CmdDisasoc((MacAddr_t *) macp->mlme_req.addr.sa_data, macp->mlme_req.reason_code) == FALSE) {
+			printk(KERN_ERR "Can't disassociate STA: %s\n", mac_addr);
+			result = -EIO;
+		} else {
+			printk(KERN_INFO "Disassociate STA: %s with reason code: %d\n", mac_addr, macp->mlme_req.reason_code);
+			result = 0;
+		}
+		break;
+	default:
+		printk(KERN_ERR "MLME command: 0x%04x not support\n", macp->mlme_req.cmd);
+		break;
+	}
+	return result;
+}
+
+
+/////////////////////////////////////////
+int
+zd1205_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+        struct zd1205_private *macp;
+        void *regp;
+        struct zdap_ioctl zdreq;
+        struct iwreq *wrq = (struct iwreq *)ifr;
+        int err = 0;
+        int changed = 0;
+
+        macp = dev->priv;
+        regp = macp->regp;
+
+        /* ath_desc: ifconfig up fix */
+        /* ath_old: if(!netif_running(dev)) return -EINVAL; */
+
+        switch (cmd)
+        {
+	case SIOCSIWMLME:
+		//ZD1211DEBUG(0, "%s: SIOCSIWMLME\n", dev->name);
+		if (copy_from_user(&macp->mlme_req, wrq->u.data.pointer, sizeof(macp->mlme_req))) {
+			err = -EFAULT;
+		} else {
+			zd1205_lock(macp);
+#ifdef HOST_IF_USB
+			defer_kevent(macp, KEVENT_ZD_MLME_IOCTL);
+			err = 0;
+#else
+			err = zd1211_mlme(macp);
+#endif
+			zd1205_unlock(macp);
+		}
+		break;
+
+	case SIOCSIWAUTH:
+		//ZD1211DEBUG(0, "%s: SIOCSIWAUTH\n", dev->name);
+		err = zd1211_set_auth_param(dev, wrq->u.param.flags, wrq->u.param.value);
+		break;
+
+	case SIOCSIWENCODEEXT:
+		//ZD1211DEBUG(0, "%s: SIOCSIWENCODEEXT\n", dev->name);
+		err = zd1211_set_encode_ext(macp, wrq);
+		break;
+
+	case SIOCSIWGENIE:
+		//ZD1211DEBUG(0, "%s: SIOCSIWGENIE\n", dev->name);
+		err = zd1211_set_wpa_ie(macp, wrq);
+		break;
+
+        case SIOCGIWNAME:
+                //ZD1211DEBUG(1, "%s: SIOCGIWNAME\n", dev->name);
+                //strcpy(wrq->u.name, "IEEE 802.11-DS");
+                strcpy(wrq->u.name, "802.11b/g NIC");
+                break;
+
+        case SIOCGIWAP:
+                ZD1211DEBUG(1, "%s: SIOCGIWAP\n", dev->name);
+                wrq->u.ap_addr.sa_family = ARPHRD_ETHER;
+
+                if (macp->cardSetting.BssType == AP_BSS)
+                        memcpy(wrq->u.ap_addr.sa_data, macp->macAdr, 6);
+                else {
+                        if(macp->bAssoc)
+                                memcpy(wrq->u.ap_addr.sa_data, macp->BSSID, 6);
+                        else
+                                memset(wrq->u.ap_addr.sa_data, 0, 6);
+                }
+                break;
+
+        case SIOCGIWRANGE:
+                ZD1211DEBUG(1, "%s: SIOCGIWRANGE\n", dev->name);
+                if ( wrq->u.data.pointer != NULL) {
+                        struct iw_range range;
+                        err = zd1205wext_giwrange(dev, NULL, &wrq->u.data, (char *) &range);
+
+                        /* Push that up to the caller */
+                        if (copy_to_user(wrq->u.data.pointer, &range, sizeof(range)))
+                                err = -EFAULT;
+                }
+                break;
+
+        case SIOCSIWMODE:
+                ZD1211DEBUG(1, "%s: SIOCSIWMODE\n", dev->name);
+                err = zd1205wext_siwmode(dev, NULL, &wrq->u.mode, NULL);
+
+                if (!err)
+                        changed = 1;
+                break;
+
+        case SIOCGIWMODE:
+                ZD1211DEBUG(1, "%s: SIOCGIWMODE\n", dev->name);
+                err = zd1205wext_giwmode(dev, NULL, &wrq->u.mode, NULL);
+                break;
+
+        case SIOCSIWENCODE: {
+                        char keybuf[MAX_KEY_SIZE];
+                        ZD1211DEBUG(1, "%s: SIOCSIWENCODE\n", dev->name);
+
+                        if (wrq->u.encoding.pointer) {
+                                if (wrq->u.encoding.length > MAX_KEY_SIZE) {
+                                        err = -E2BIG;
+                                        break;
+                                }
+
+                                if (copy_from_user(keybuf, wrq->u.encoding.pointer, wrq->u.encoding.length)) {
+                                        err = -EFAULT;
+                                        break;
+                                }
+                        }
+
+                        zd1205_dump_data("keybuf", keybuf, wrq->u.encoding.length);
+                        err = zd1205_ioctl_setiwencode(dev, &wrq->u.encoding, keybuf);
+
+                        if (!err)
+                                changed = 0;
+                }
+                break;
+
+        case SIOCGIWENCODE: {
+                        char keybuf[MAX_KEY_SIZE];
+
+                        ZD1211DEBUG(1, "%s: SIOCGIWENCODE\n", dev->name);
+                        err = zd1205_ioctl_getiwencode(dev, &wrq->u.encoding, keybuf);
+
+                        if (wrq->u.encoding.pointer) {
+                                if (copy_to_user(wrq->u.encoding.pointer, keybuf, wrq->u.encoding.length))
+                                        err = -EFAULT;
+                        }
+                }
+                break;
+
+        case SIOCSIWESSID:
+                ZD1211DEBUG(1, "%s: SIOCSIWESSID\n", dev->name);
+                err = zd1205_ioctl_setessid(dev, &wrq->u.essid);
+                if (!err && macp->cardSetting.ap_scan != 1)
+                        changed = 1;
+                break;
+        case SIOCSIWAP:
+                ZD1211DEBUG(1, "%s: SIOCSIWAP\n", dev->name);
+                err = zd1205_ioctl_setbssid(dev, wrq);
+                if (!err && macp->cardSetting.ap_scan == 1) {
+                        //set_bit(CTX_FLAG_ESSID_WAS_SET,(void*)&macp->flags);
+                        changed = 1;
+                }
+
+                break;
+
+        case SIOCGIWESSID:
+                ZD1211DEBUG(1, "%s: SIOCGIWESSID\n", dev->name);
+                err = zd1205_ioctl_getessid(dev, &wrq->u.essid);
+                break;
+
+        case SIOCGIWFREQ:
+                ZD1211DEBUG(1, "%s: SIOCGIWFREQ\n", dev->name);
+                wrq->u.freq.m = zd1205_hw_get_freq(macp);
+                wrq->u.freq.e = 1;
+                break;
+
+        case SIOCSIWFREQ:
+                ZD1211DEBUG(1, "%s: SIOCSIWFREQ\n", dev->name);
+
+                err = zd1205_ioctl_setfreq(dev, &wrq->u.freq);
+                if (!err)
+                        changed = 1;
+                break;
+
+        case SIOCGIWRTS:
+                ZD1211DEBUG(1, "%s: SIOCGIWRTS\n", dev->name);
+                zd1205wext_giwrts(dev, NULL, &wrq->u.rts, NULL);
+                break;
+
+        case SIOCSIWRTS:
+                ZD1211DEBUG(1, "%s: SIOCSIWRTS\n", dev->name);
+
+
+                err = zd1205_ioctl_setrts(dev, &wrq->u.rts);
+                if (! err)
+                        changed = 1;
+                break;
+
+        case SIOCSIWFRAG:
+                ZD1211DEBUG(1, "%s: SIOCSIWFRAG\n", dev->name);
+
+                err = zd1205_ioctl_setfrag(dev, &wrq->u.frag);
+                if (! err)
+                        changed = 1;
+                break;
+
+        case SIOCGIWFRAG:
+                ZD1211DEBUG(1, "%s: SIOCGIWFRAG\n", dev->name);
+                err = zd1205_ioctl_getfrag(dev, &wrq->u.frag);
+                break;
+
+        case SIOCSIWRATE:
+                ZD1211DEBUG(1, "%s: SIOCSIWRATE\n", dev->name);
+
+                err = zd1205_ioctl_setrate(dev, &wrq->u.bitrate);
+                if (! err)
+                        changed = 1;
+
+                break;
+
+        case SIOCGIWRATE:
+                ZD1211DEBUG(1, "%s: SIOCGIWRATE\n", dev->name);
+                err = zd1205_ioctl_getrate(dev, &wrq->u.bitrate);
+                break;
+
+        case SIOCSIWPOWER:
+                ZD1211DEBUG(1, "%s: SIOCSIWPOWER\n", dev->name);
+
+                err = zd1205_ioctl_setpower(dev, &wrq->u.power);
+                if (!err)
+                        changed = 0;
+                break;
+
+
+        case SIOCGIWPOWER:
+                ZD1211DEBUG(1, "%s: SIOCGIWPOWER\n", dev->name);
+                err = zd1205_ioctl_getpower(dev, &wrq->u.power);
+                break;
+
+#if WIRELESS_EXT > 10
+
+        case SIOCSIWRETRY:
+                ZD1211DEBUG(1, "%s: SIOCSIWRETRY\n", dev->name);
+                err = -EOPNOTSUPP;
+                break;
+
+
+        case SIOCGIWRETRY:
+                ZD1211DEBUG(1, "%s: SIOCGIWRETRY\n", dev->name);
+                err = zd1205_ioctl_getretry(dev, &wrq->u.retry);
+                break;
+#endif /* WIRELESS_EXT > 10 */
+
+        case SIOCGIWPRIV:
+                if (wrq->u.data.pointer) {
+                        struct iw_priv_args privtab[] = {
+                                                                {
+                                                                        SIOCIWFIRSTPRIV + 0x0, 0, 0, "list_bss"
+                                                                },
+                                                                { SIOCIWFIRSTPRIV + 0x1, 0, 0, "card_reset" },
+                                                                { SIOCIWFIRSTPRIV + 0x2, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_auth" },  /* 0 - open, 1 - shared key */
+                                                                { SIOCIWFIRSTPRIV + 0x3, 0, IW_PRIV_TYPE_CHAR | 12, "get_auth" },
+                                                                { SIOCIWFIRSTPRIV + 0x4, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_preamble" },  /* 0 - long, 1 - short */
+                                                                { SIOCIWFIRSTPRIV + 0x5, 0, IW_PRIV_TYPE_CHAR | 6, "get_preamble" },
+                                                                { SIOCIWFIRSTPRIV + 0x6, 0, 0, "cnt" },
+                                                                { SIOCIWFIRSTPRIV + 0x7, 0, 0, "regs" },
+                                                                { SIOCIWFIRSTPRIV + 0x8, 0, 0, "probe" },
+                                                                /* ath_desc: reenable iwpriv dbg_flag */
+                                                                { SIOCIWFIRSTPRIV + 0x10, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "dbg_flag" },
+                                                                { SIOCIWFIRSTPRIV + 0xA, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "connect" },
+                                                                { SIOCIWFIRSTPRIV + 0xB, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_mac_mode" },
+                                                                { SIOCIWFIRSTPRIV + 0xC, 0, IW_PRIV_TYPE_CHAR | 12, "get_mac_mode" },
+                                                                { SIOCIWFIRSTPRIV + 0xD, 0, 0, "save_conf" },
+                                                                { SIOCIWFIRSTPRIV + 0xF, 0, IW_PRIV_TYPE_CHAR | 14, "get_Region" },
+                                                                { SIOCIWFIRSTPRIV + 0x9,IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_Region" },
+                                                        };
+
+                        /* ath_desc: use access_ok() instead of deprecated verify_area() */
+                        err = access_ok(VERIFY_WRITE, wrq->u.data.pointer, sizeof(privtab));
+                        if (err)
+                                break;
+
+                        wrq->u.data.length = sizeof(privtab) / sizeof(privtab[0]);
+                        if (copy_to_user(wrq->u.data.pointer, privtab, sizeof(privtab)))
+                                err = -EFAULT;
+                }
+                break;
+
+        case SIOCIWFIRSTPRIV + 0x0: /* list_bss */
+                ZD1211DEBUG(1, "%s: SIOCIWFIRSTPRIV + 0x0 (list_bss)\n", dev->name);
+                macp->bss_index = zd_GetBssList(&macp->BSSInfo[0]);
+                zd1205_list_bss(macp);
+                break;
+
+        case SIOCIWFIRSTPRIV + 0x1: /* card_reset */
+                ZD1211DEBUG(1, "%s: SIOCIWFIRSTPRIV + 0x1 (card_reset)\n", dev->name);
+                if (! capable(CAP_NET_ADMIN)) {
+                        err = -EPERM;
+                        break;
+                }
+
+                printk(KERN_DEBUG "%s: Force scheduling reset!\n", dev->name);
+                zd1205_lock(macp);
+                zd1205_device_reset(macp);
+                zd1205_unlock(macp);
+                err = 0;
+                break;
+
+        case SIOCIWFIRSTPRIV + 0x2: /* set_auth */
+                ZD1211DEBUG(1, "%s: SIOCIWFIRSTPRIV + 0x2 (set_auth)\n", dev->name);
+                if (! capable(CAP_NET_ADMIN)) {
+                        err = -EPERM;
+                        break;
+                }
+                {
+                        int val = *( (int *) wrq->u.name );
+                        if ((val < 0) || (val > 1)) {
+                                err = -EINVAL;
+                                break;
+                        } else {
+                                zd1205_lock(macp);
+                                macp->cardSetting.AuthMode = val;
+                                zd1205_unlock(macp);
+                                err = 0;
+                                changed = 1;
+                        }
+                }
+                break;
+
+        case SIOCIWFIRSTPRIV + 0x3: /* get_auth */
+                ZD1211DEBUG(1, "%s: SIOCIWFIRSTPRIV + 0x3 (get_auth)\n", dev->name);
+
+                if (wrq->u.data.pointer) {
+                        wrq->u.data.flags = 1;
+
+                        if (macp->cardSetting.AuthMode == 0) {
+                                wrq->u.data.length = 12;
+
+                                if (copy_to_user(wrq->u.data.pointer, "open system", 12)) {
+                                        return -EFAULT;
+                                }
+                        } else if (macp->cardSetting.AuthMode == 1) {
+                                wrq->u.data.length = 11;
+
+                                if (copy_to_user(wrq->u.data.pointer, "shared key", 11)) {
+                                        return -EFAULT;
+                                }
+                        } else if (macp->cardSetting.AuthMode == 2) {
+                                wrq->u.data.length = 10;
+
+                                if (copy_to_user(wrq->u.data.pointer, "auto mode", 10)) {
+                                        return -EFAULT;
+                                }
+                        } else {
+                                return -EFAULT;
+                        }
+                }
+                break;
+
+        case SIOCIWFIRSTPRIV + 0x4: /* set_preamble */
+                ZD1211DEBUG(1, "%s: SIOCIWFIRSTPRIV + 0x4 (set_preamble)\n", dev->name);
+
+                if (! capable(CAP_NET_ADMIN)) {
+                        err = -EPERM;
+                        break;
+                }
+                {
+                        int val = *( (int *) wrq->u.name );
+
+                        if ((val < 0) || (val > 1)) {
+                                err = -EINVAL;
+                                break;
+                        } else {
+                                zd1205_lock(macp);
+
+                                if (val)
+                                        macp->cardSetting.PreambleType = 1;
+                                else
+                                        macp->cardSetting.PreambleType = 0;
+
+                                zd1205_unlock(macp);
+                                err = 0;
+                                changed = 1;
+                        }
+                }
+                break;
+
+
+        case SIOCIWFIRSTPRIV + 0x5: /* get_preamble */
+                ZD1211DEBUG(1, "%s: SIOCIWFIRSTPRIV + 0x5 (get_preamble)\n", dev->name);
+
+                if (wrq->u.data.pointer) {
+                        wrq->u.data.flags = 1;
+
+                        if (macp->cardSetting.PreambleType) {
+                                wrq->u.data.length = 6;
+
+                                if (copy_to_user(wrq->u.data.pointer, "short", 6)) {
+                                        return -EFAULT;
+                                }
+                        } else {
+                                wrq->u.data.length = 5;
+
+                                if (copy_to_user(wrq->u.data.pointer, "long", 5)) {
+                                        return -EFAULT;
+                                }
+                        }
+                }
+                break;
+
+        case SIOCIWFIRSTPRIV + 0x6: /* dump_cnt */
+                ZD1211DEBUG(1, "%s: SIOCIWFIRSTPRIV + 0x6 (dump_cnt)\n", dev->name);
+                zd1205_dump_cnters(macp);
+                break;
+
+        case SIOCIWFIRSTPRIV + 0x7: /* dump_reg */
+                ZD1211DEBUG(1, "%s: SIOCIWFIRSTPRIV + 0x7 (dump_cnt)\n", dev->name);
+                zd1205_dump_regs(macp);
+                break;
+
+        case SIOCIWFIRSTPRIV + 0x8: /* probe */
+                ZD1211DEBUG(1, "%s: SIOCIWFIRSTPRIV + 0x8 (probe)\n", dev->name);
+                zd_CmdProcess(CMD_PROBE_REQ, 0, 0);
+                break;
+
+        /* ath_desc: reenable iwpriv dbg_flag */
+        case SIOCIWFIRSTPRIV + 0x10: /* set_dbgflag */
+                ZD1211DEBUG(1, "%s: SIOCIWFIRSTPRIV + 0x10 (set_dbgflag)\n", dev->name);
+
+                if (! capable(CAP_NET_ADMIN)) {
+                        err = -EPERM;
+                        break;
+                }
+                {
+                        int val = *( (int *) wrq->u.name );
+
+                        if ((val < 0) || (val > 5)){
+                                err = -EINVAL;
+                                break;
+                        }
+                        else {
+                                zd1205_lock(macp);
+                                macp->dbg_flag = val;
+                                zd1205_unlock(macp);
+                                err = 0;
+                        }
+                }
+                break;
+
+        case SIOCIWFIRSTPRIV + 0xA: /* connect */
+                ZD1211DEBUG(1, "%s: SIOCIWFIRSTPRIV + 0xA (connect)\n", dev->name);
+
+                if (! capable(CAP_NET_ADMIN)) {
+                        err = -EPERM;
+                        break;
+                }
+                {
+                        int val = *( (int *) wrq->u.name );
+
+                        if ((val < 1) || (val >macp->bss_index)) {
+                                err = -EINVAL;
+                                break;
+                        } else {
+                                U8  bssTypeToConnect;
+                                U16 capabilities;
+                                u8 ChangeToMacMode=MIXED_MODE;
+                                capabilities = macp->BSSInfo[val-1].cap;
+                                //If you connect to non-A AP while in 5G Band, or
+                                //you connect to A AP while in 2.4G, you need to
+                                //do mac_mode change first
+                                if((PURE_A_AP == macp->BSSInfo[val-1].apMode  &&
+                                                PURE_A_MODE != mMacMode) ||
+                                                (PURE_A_AP != macp->BSSInfo[val-1].apMode  &&
+                                                 PURE_A_MODE == mMacMode) ) {
+                                        if(PURE_A_AP == macp->BSSInfo[val-1].apMode)
+                                                ChangeToMacMode = PURE_A_MODE;
+
+                                        printk("Changed macmode in connect\n");
+                                        macp->cardSetting.Channel = 8;//Default Channel to 8
+                                        macp->cardSetting.MacMode = ChangeToMacMode;
+                                        macp->bDefaultIbssMacMode=1;
+                                        //set_mac_mode command has been issued by the user.
+                                        zd1205_SetRatesInfo(macp);
+                                        err = 0;
+                                        zd_UpdateCardSetting(&macp->cardSetting);
+                                }
+                                if (capabilities & (CAP_IBSS | CAP_ESS)) {
+                                        zd1205_lock(macp);
+                                        memcpy((U8*)&mSsid,(U8*)macp->BSSInfo[val-1].ssid,34+1);
+                                        memcpy((U8*)&dot11DesiredSsid, &mSsid, 34+1);
+                                        macp->BSSInfo[val-1].ssid[mSsid.buf[1]+2]=0;
+                                        mProbeWithSsid=TRUE;
+                                        if (capabilities & CAP_IBSS) {
+                                                if (macp->bDefaultIbssMacMode==0)
+                                                        mMacMode=macp->cardSetting.MacMode=PURE_B_MODE;
+                                                bssTypeToConnect=INDEPENDENT_BSS;
+                                        } else {
+                                                if (macp->bDefaultIbssMacMode==0)
+                                                        mMacMode=macp->cardSetting.MacMode=MIXED_MODE;
+                                                bssTypeToConnect=INFRASTRUCTURE_BSS;
+                                        }
+                                        mBssType=macp->cardSetting.BssType=bssTypeToConnect;
+                                        zd_CmdProcess(CMD_CONNECT, &bssTypeToConnect, val);
+                                        zd1205_unlock(macp);
+                                }
+                                err = 0;
+                        }
+                }
+                break;
+
+
+        case SIOCIWFIRSTPRIV + 0xB: /* set_mac_mode */
+                ZD1211DEBUG(1, "%s: SIOCIWFIRSTPRIV + 0xB (set_mac_mode)\n", dev->name);
+
+                if (! capable(CAP_NET_ADMIN)) {
+                        err = -EPERM;
+                        break;
+                }
+                {
+                        int val = *( (int *) wrq->u.name );
+                        int mac_mode_limit;
+
+                        if(AL7230B_RF == dot11Obj.rfMode)
+                                mac_mode_limit = 4; //4 = A,B,G
+                        else if (AL2230_RF == dot11Obj.rfMode)
+                                mac_mode_limit = 3; //3 = B,G
+                        else {
+                                printk("Unknown RF Module. You are not allowed to set mac mode\n");
+                                mac_mode_limit = 0;
+                        }
+                        if ((val < 1) || (val > mac_mode_limit)) {
+                                err = -EINVAL;
+                                break;
+                        } else {
+                                //If Band changed from 2.4G <-> 5G, we need
+                                //to set default channel
+                                if( (macp->cardSetting.MacMode != PURE_A_MODE &&
+                                                val == PURE_A_MODE)) {
+                                        macp->cardSetting.Channel = 36;
+                                } else if(macp->cardSetting.MacMode == PURE_A_MODE &&
+                                                val != PURE_A_MODE) {
+                                        macp->cardSetting.Channel = 1;
+                                }
+
+                                macp->cardSetting.MacMode = val;
+                                macp->bDefaultIbssMacMode=1;// Indicates that the set_mac_mode command has been issued by the user.
+                                zd1205_SetRatesInfo(macp);
+                                err = 0;
+                                changed = 1;
+                        }
+                }
+                break;
+
+        case SIOCIWFIRSTPRIV + 0xC: /* get_mac_mode */
+                ZD1211DEBUG(1, "%s: SIOCIWFIRSTPRIV + 0xC (get_mac_mode)\n", dev->name);
+
+
+                if (wrq->u.data.pointer) {
+                        wrq->u.data.flags = 1;
+
+                        if (macp->cardSetting.MacMode == MIXED_MODE) {
+                                wrq->u.data.length = 11;
+                                if (copy_to_user(wrq->u.data.pointer, "Mixed Mode", 11)) {
+                                        return -EFAULT;
+                                }
+                        } else if (macp->cardSetting.MacMode == PURE_G_MODE) {
+                                wrq->u.data.length = 12;
+                                if (copy_to_user(wrq->u.data.pointer, "Pure G Mode", 12)) {
+                                        return -EFAULT;
+                                }
+                        } else if (macp->cardSetting.MacMode == PURE_B_MODE) {
+                                wrq->u.data.length = 12;
+                                if (copy_to_user(wrq->u.data.pointer, "Pure B Mode", 12)) {
+                                        return -EFAULT;
+                                }
+                        } else if (macp->cardSetting.MacMode == PURE_A_MODE) {
+                                wrq->u.data.length = 12;
+                                if (copy_to_user(wrq->u.data.pointer, "Pure A Mode", 12)) {
+                                        return -EFAULT;
+                                }
+                        } else
+                                return -EFAULT;
+                }
+                break;
+
+        case SIOCIWFIRSTPRIV + 0xF: //get_Region
+                //zd1205_dumpEEPROM(macp);
+                if (wrq->u.data.pointer) {
+                        wrq->u.data.flags = 1;
+
+                        if (ZD_REGION_USA == dot11Obj.RegionCode) {
+                                wrq->u.data.length = 3;
+                                if (copy_to_user(wrq->u.data.pointer, "USA", 4))
+                                        return -EFAULT;
+                        } else if (ZD_REGION_Europe == dot11Obj.RegionCode) {
+                                wrq->u.data.length = 13;
+                                if (copy_to_user(wrq->u.data.pointer, "Taiwan/Europe", 14))
+                                        return -EFAULT;
+                        } else if (ZD_REGION_France == dot11Obj.RegionCode) {
+                                wrq->u.data.length = 6;
+                                if (copy_to_user(wrq->u.data.pointer, "France", 7))
+                                        return -EFAULT;
+                        } else if (ZD_REGION_Japan == dot11Obj.RegionCode) {
+                                wrq->u.data.length = 5;
+
+                                if (copy_to_user(wrq->u.data.pointer, "Japan", 6))
+                                        return -EFAULT;
+                        } else if (ZD_REGION_Israel == dot11Obj.RegionCode) {
+                                wrq->u.data.length = 6;
+                                if (copy_to_user(wrq->u.data.pointer, "Israel", 7))
+                                        return -EFAULT;
+                        } else if (ZD_REGION_Mexico == dot11Obj.RegionCode) {
+                                wrq->u.data.length = 6;
+                                if (copy_to_user(wrq->u.data.pointer, "Mexico", 7))
+                                        return -EFAULT;
+                        } else
+                                return -EFAULT;
+                }
+
+                break;
+        case SIOCIWFIRSTPRIV + 0x9 : //set_Region
+                {
+                        int val = *( (int *) wrq->u.name );
+
+                        if ((val < 1) || (val > 6))
+                        {
+                                err = -EINVAL;
+                                break;
+                        } else
+                        {
+                                switch(val) {
+                                case 1 :
+                                        macp->RegionCode = ZD_REGION_USA;
+                                        break;
+                                case 2 :
+                                        macp->RegionCode = ZD_REGION_Europe;
+                                        break;
+                                case 3 :
+                                        macp->RegionCode = ZD_REGION_France;
+                                        break;
+                                case 4 :
+                                        macp->RegionCode = ZD_REGION_Japan;
+                                        break;
+                                case 5 :
+                                        macp->RegionCode = ZD_REGION_Israel;
+                                        break;
+                                case 6 :
+                                        macp->RegionCode = ZD_REGION_Mexico;
+                                        break;
+                                }
+                        }
+                        dot11Obj.RegionCode = macp->RegionCode;
+                        switch(val)
+                        {
+                        case 1 :
+                                dot11Obj.AllowedChannel = 0x107ff;
+                                break;//1-11
+                        case 2 :
+                                dot11Obj.AllowedChannel = 0x11fff;
+                                break;//1-13
+                        case 3 :
+                                dot11Obj.AllowedChannel = 0xa1e00;
+                                break;//10-13
+                        case 4 :
+                                dot11Obj.AllowedChannel = 0x13fff;
+                                break;//1-14
+                        case 5 :
+                                dot11Obj.AllowedChannel = 0x301fc;
+                                break;//3-9
+                        case 6 :
+                                dot11Obj.AllowedChannel = 0xa0600;
+                                break;//10,11
+                        }
+
+                        break;
+                }
+                ////////////////////////////
+#ifdef ZDCONF_MENUDBG
+        case ZD_MENU_DBG:
+                {
+                        u32 in=0,ret=0;
+                        if (copy_from_user(&zdreq, ifr->ifr_data, sizeof(zdreq))) {
+                                return -EFAULT;
+                        }
+                        zd1205_lock(macp);
+                        zd1205_zd_dbg2_ioctl(macp, &zdreq,&ret);
+                        copy_from_user(&in,((struct zdap_ioctl *)(ifr->ifr_data))->data,4);
+                        copy_to_user(((struct zdap_ioctl *)(ifr->ifr_data))->data, &ret, sizeof(ret));
+                        zd1205_unlock(macp);
+                        err = 0;
+                }
+                break;
+#endif
+
+        case ZDAPIOCTL:    //ZD1202 debug command
+                if (copy_from_user(&zdreq, ifr->ifr_data, sizeof (zdreq))) {
+                        printk(KERN_ERR "ZDAPIOCTL: copy_from_user error\n");
+                        return -EFAULT;
+                }
+
+                printk(KERN_DEBUG "zd1211: cmd = %2x, reg = 0x%04x, value = 0x%08x\n", zdreq.cmd, zdreq.addr, zdreq.value);
+
+                zd1205_lock(macp);
+#ifdef HOST_IF_USB
+
+                memcpy(&macp->zdreq, &zdreq, sizeof(zdreq));
+                defer_kevent(macp, KEVENT_ZD_IOCTL);
+#else
+
+                zd1205_zd_dbg_ioctl(macp, &zdreq);
+#endif
+
+                zd1205_unlock(macp);
+                err = 0;
+                break;
+
+        default:
+                ZD1211DEBUG(0, "zd1205: cmd = %2x\n", cmd);
+                err = -EOPNOTSUPP;
+                break;
+        }
+
+        if ((!err) && changed)
+        {
+#ifdef HOST_IF_USB
+                defer_kevent(macp, KEVENT_UPDATE_SETTING);
+#else
+
+                zd_UpdateCardSetting(&macp->cardSetting);
+#endif
+
+        }
+
+        return err;
+}
+
+
+
+
+
+/**
+ * zd1205init - initialize the adapter
+ * @macp: atapter's private data struct
+ *
+ * This routine is called when this driver is loaded. This is the initialization
+ * routine which allocates memory, configures the adapter and determines the
+ * system resources.
+ *
+ * Returns:
+ 
+ 
+ *      true: if successful
+ *      false: otherwise
+ */
+
+unsigned char
+zd1205_init(struct zd1205_private *macp)
+{
+        u32 tmpValue;
+
+        //ZENTER(0);
+#if fPROG_FLASH
+
+        macp->bAllowAccessRegister = 1;
+#endif
+        /* read the MAC address from the eprom */
+        mTxOFDMType = &(((struct zd1205_private *)g_dev->priv)->TxOFDMType);
+        zd1205_rd_eaddr(macp);
+
+        zd_writel(0x01, AfterPNP);
+
+#if fWRITE_WORD_REG || fREAD_MUL_REG
+
+        // Must get this information before any register write
+
+
+        tmpValue = zd1211_readl(cADDR_ENTRY_TABLE, false);
+        macp->AddrEntryTable = (u16) tmpValue;
+        ZD1211DEBUG(0, "AddrEntryTable = %04x\n", macp->AddrEntryTable);
+#endif
+
+        macp->RF_Mode = zd_readl(E2P_POD);
+        ZD1211DEBUG(0, "RF_Mode = %08x\n", macp->RF_Mode);
+        macp->PA_Type = ((macp->RF_Mode) >> 16) & 0xF;//hardware type 2, bit0-3
+        printk(KERN_ERR "PA type: %01x\n", macp->PA_Type);
+        dot11Obj.rfMode = (macp->RF_Mode & 0x0f);
+
+        if ((dot11Obj.rfMode == 0x04) || (dot11Obj.rfMode == 0x07))
+                printk("AiroHa RF\n");
+        else if (dot11Obj.rfMode == 0x09)
+                printk("GCT RF\n");
+        else if (dot11Obj.rfMode == 0x0d)
+                printk("RFMD RF\n");
+        else if (dot11Obj.rfMode == 0x05)
+                printk("AIroHa 7230B_RF\n");
+        else
+                printk("RF_Mode = %x\n", (u8)dot11Obj.rfMode);
+
+
+
+        zd_writel(0x00, GPI_EN);
+
+        zd1205_sw_init(macp);
+        zd1205_hw_init(macp);
+        zd1205_disable_int();
+
+        ZEXIT(0);
+        return true;
+}
+
+
+
+void zd1205_init_card_setting(struct zd1205_private *macp)
+{
+        card_Setting_t *pSetting = &macp->cardSetting;
+
+        pSetting->BssType = INFRASTRUCTURE_BSS;
+        //pSetting->BssType = AP_BSS;
+        //pSetting->BssType = INDEPENDENT_BSS;
+        //pSetting->BssType = PSEUDO_IBSS;
+        pSetting->HiddenSSID = 0; 	//disable hidden essid
+        pSetting->LimitedUser = 32;
+        pSetting->RadioOn = 1;
+
+        pSetting->BlockBSS = 0;
+        pSetting->EncryOnOff = 0;
+        //pSetting->PreambleType = 0; //long preamble
+        pSetting->PreambleType = 1; //short preamble
+        pSetting->Channel = 6;
+        pSetting->EncryMode = NO_WEP;
+        pSetting->EncryKeyId = 0;
+        pSetting->TxPowerLevel = 0;
+
+        if (pSetting->BssType == AP_BSS)
+        {
+                pSetting->AuthMode = 2; 	//auto auth
+                pSetting->Info_SSID[0] = 0;
+                pSetting->Info_SSID[1] = 0x08;
+                pSetting->Info_SSID[2] = 'Z';
+                pSetting->Info_SSID[3] = 'D';
+                pSetting->Info_SSID[4] = '1';
+                pSetting->Info_SSID[5] = '2';
+                pSetting->Info_SSID[6] = '1';
+                pSetting->Info_SSID[7] = '1';
+                pSetting->Info_SSID[8] = 'A';
+                pSetting->Info_SSID[9] = 'P';
+        } else if (pSetting->BssType == INFRASTRUCTURE_BSS)
+        {
+                pSetting->AuthMode = 0; 	//open syatem
+
+                pSetting->Info_SSID[0] = 0;
+                //pSetting->Info_SSID[1] = 0x05;
+                pSetting->Info_SSID[1] = 0x00;
+                pSetting->Info_SSID[2] = 'G';
+                pSetting->Info_SSID[3] = '1';
+                pSetting->Info_SSID[4] = '0';
+                pSetting->Info_SSID[5] = '0';
+                pSetting->Info_SSID[6] = '0';
+                //pSetting->Info_SSID[7] = 'A';
+                //pSetting->Info_SSID[8] = 'B';
+        } else if (pSetting->BssType == INDEPENDENT_BSS)
+        {
+                pSetting->AuthMode = 0; 	//open syatem
+                pSetting->Info_SSID[0] = 0;
+                pSetting->Info_SSID[1] = 0x09;
+                pSetting->Info_SSID[2] = '1';
+                pSetting->Info_SSID[3] = '2';
+
+                pSetting->Info_SSID[4] = '1';
+                pSetting->Info_SSID[5] = '1';
+                pSetting->Info_SSID[6] = 'A';
+                pSetting->Info_SSID[7] = 'd';
+                pSetting->Info_SSID[8] = 'H';
+                pSetting->Info_SSID[9] = 'o';
+                pSetting->Info_SSID[10] = 'c';
+        }
+
+#if	!(defined(GCCK) && defined(OFDM))
+        pSetting->Info_SupportedRates[0] = 0x01;
+        pSetting->Info_SupportedRates[1] = 0x05;
+        pSetting->Info_SupportedRates[2] = 0x82;
+        pSetting->Info_SupportedRates[3] = 0x84;
+        pSetting->Info_SupportedRates[4] = 0x8B;
+        pSetting->Info_SupportedRates[5] = 0x96;
+        pSetting->Info_SupportedRates[6] = 0x21;
+
+
+
+        if ((dot11Obj.rfMode == AL2210MPVB_RF) || (dot11Obj.rfMode == AL2210_RF))
+        {
+                pSetting->Rate275 = 1;
+                pSetting->Info_SupportedRates[7] = 0x2C;//22
+                pSetting->Info_SupportedRates[8] = 0x37;//27.5
+                pSetting->Info_SupportedRates[1] = 0x07;
+        } else
+                pSetting->Rate275 = 0;
+#else
+
+        if (macp->usb->speed != USB_SPEED_HIGH)
+                pSetting->MacMode = PURE_B_MODE;
+        else
+        {
+
+                //if (pSetting->BssType == INDEPENDENT_BSS)
+                //pSetting->MacMode = PURE_B_MODE;
+                //else
+                pSetting->MacMode = MIXED_MODE;
+        }
+        zd1205_SetRatesInfo(macp);
+        //pCardSetting->UartEnable = 1;
+        //pCardSetting->BaudRate = BAUD_RATE_115200;
+
+
+#endif
+
+
+        pSetting->FragThreshold = 0x980;
+        pSetting->RTSThreshold = 0x980;
+
+        pSetting->BeaconInterval = 100;
+        pSetting->DtimPeriod = 3;
+        pSetting->SwCipher = 0;
+
+
+        pSetting->DynKeyMode = 0;
+        pSetting->WpaBcKeyLen = 32; // Tmp key(16) + Tx Mic key(8) + Rx Mic key(8)
+
+
+        //dot11Obj.MicFailure = NULL;
+        //dot11Obj.AssocRequest = NULL;
+        //dot11Obj.WpaIe =  NULL;
+}
+
+
+
+#ifndef HOST_IF_USB
+int
+zd1205_found1(struct pci_dev *pcid, const struct pci_device_id *ent)
+{
+        static int first_time = true;
+        struct net_device *dev = NULL;
+        struct zd1205_private *macp = NULL;
+
+        int rc = 0;
+
+
+        ZENTER(0);
+
+        dev = alloc_etherdev(sizeof (struct zd1205_private));
+
+
+        if (dev == NULL)
+        {
+                printk(KERN_ERR "zd1205: Not able to alloc etherdev struct\n");
+                rc = -ENODEV;
+                goto out;
+
+        }
+
+
+
+        g_dev = dev;  //save this for CBs use
+        SET_MODULE_OWNER(dev);
+
+        if (first_time)
+        {
+                first_time = false;
+
+                printk(KERN_NOTICE "%s - version %s\n",
+                       zd1205_full_driver_name, zd1205_driver_version);
+
+                printk(KERN_NOTICE "%s\n", zd1205_copyright);
+                printk(KERN_NOTICE "\n");
+        }
+
+        macp = dev->priv;
+        macp->pdev = pcid;
+        macp->device = dev;
+
+        pci_set_drvdata(pcid, dev);
+        macp->numTcb = NUM_TCB;
+
+        macp->numTbd = NUM_TBD;
+        macp->numRfd = NUM_RFD;
+
+        macp->numTbdPerTcb = NUM_TBD_PER_TCB;
+        macp->regp = 0;
+        macp->rxOffset  = ZD_RX_OFFSET;
+        macp->rfd_size = 24; // form CbStatus to NextCbPhyAddrHighPart
+
+
+        init_timer(&macp->watchdog_timer);
+
+
+        macp->watchdog_timer.data = (unsigned long) dev;
+        macp->watchdog_timer.function = (void *) &zd1205_watchdog_cb;
+        init_timer(&macp->tm_hking_id);
+        macp->tm_hking_id.data = (unsigned long) dev;
+
+        macp->tm_hking_id.function = (void *) &HKeepingCB;
+
+        init_timer(&macp->tm_mgt_id);
+        macp->tm_mgt_id.data = (unsigned long) dev;
+        macp->tm_mgt_id.function = (void *) &zd1205_mgt_mon_cb;
+
+
+        if ((rc = zd1205_pci_setup(pcid, macp)) != 0)
+        {
+                goto err_dev;
+        }
+
+
+
+        if (!zd1205_init(macp))
+        {
+                printk(KERN_ERR "zd1025: Failed to initialize, instance \n");
+
+                rc = -ENODEV;
+
+                goto err_pci;
+        }
+
+
+        dev->irq = pcid->irq;
+        dev->open = &zd1205_open;
+        dev->hard_start_xmit = &zd1205_xmit_frame;
+
+        dev->stop = &zd1205_close;
+        dev->change_mtu = &zd1205_change_mtu;
+        dev->get_stats = &zd1205_get_stats;
+        dev->set_multicast_list = &zd1205_set_multi;
+
+        dev->set_mac_address = &zd1205_set_mac;
+
+        dev->do_ioctl = &zd1205_ioctl;
+        dev->features |= NETIF_F_SG | NETIF_F_HW_CSUM;
+
+        if ((rc = register_netdev(dev)) != 0)
+        {
+                goto err_pci;
+        }
+
+
+
+
+        memcpy(macp->ifname, dev->name, IFNAMSIZ);
+        macp->ifname[IFNAMSIZ-1] = 0;
+
+
+
+        if (netif_carrier_ok(macp->device))
+                macp->cable_status = "Cable OK";
+        else
+                macp->cable_status = "Not Available";
+
+        if (zd1205_create_proc_subdir(macp) < 0)
+        {
+                printk(KERN_ERR "zd1205: Failed to create proc dir for %s\n",
+                       macp->device->name);
+
+        }
+
+
+        printk(KERN_NOTICE "\n");
+        goto out;
+
+err_pci:
+
+        iounmap(macp->regp);
+        pci_release_regions(pcid);
+        pci_disable_device(pcid);
+
+
+err_dev:
+
+        pci_set_drvdata(pcid, NULL);
+
+
+        kfree(dev);
+
+out:
+        ZEXIT(0);
+        return rc;
+}
+#endif
+
+
+
+/**
+ * zd1205_clear_structs - free resources
+  * @dev: adapter's net_device struct
+ 
+ *
+ * Free all device specific structs, unmap i/o address, etc.
+ */
+
+void
+
+zd1205_clear_structs(struct net_device *dev)
+{
+#ifndef HOST_IF_USB
+        struct zd1205_private *macp = dev->priv;
+#endif
+
+        zd1205_sw_release();
+#ifndef HOST_IF_USB
+
+        iounmap(macp->regp);
+        pci_release_regions(macp->pdev);
+        pci_disable_device(macp->pdev);
+        pci_set_drvdata(macp->pdev, NULL);
+#endif
+
+        //kfree(dev);
+        /* ath_desc: fix module deregistering */
+        /* ath_old: free_netdev(dev); */
+}
+
+#ifndef HOST_IF_USB
+void
+zd1205_remove1(struct pci_dev *pcid)
+{
+        struct net_device *dev;
+        struct zd1205_private *macp;
+
+
+        ZENTER(0);
+
+        if (!(dev = (struct net_device *) pci_get_drvdata(pcid)))
+
+                return;
+
+        macp = dev->priv;
+        unregister_netdev(dev);
+        zd1205_remove_proc_subdir(macp);
+        zd1205_clear_structs(dev);
+
+
+        ZEXIT(0);
+}
+#endif
+
+
+#if 0  //move codes to zdpci_hotplug.c
+static struct pci_device_id zd1205_id_table[] __devinitdata =
+        {
+
+
+                {
+                        0x167b, 0x2102, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ZD_1202
+                },
+                {0x167b, 0x2100, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ZD_1202},
+                {0x167b, 0x2105, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ZD_1205},
+
+                {0,}
+        };
+
+
+
+MODULE_DEVICE_TABLE(pci, zd1205_id_table);
+
+
+
+static struct pci_driver zd1205_driver =
+        {
+                .name         = "zd1205",
+                                .id_table     = zd1205_id_table,
+                                                .probe        = zd1205_found1,
+
+                                                                .remove       = __devexit_p(zd1205_remove1),
+                                                                        };
+
+
+static int __init
+zd1205_init_module(void)
+{
+
+        int ret;
+
+        ret = pci_module_init(&zd1205_driver);
+        return ret;
+}
+
+
+static void __exit
+zd1205_cleanup_module(void)
+{
+        pci_unregister_driver(&zd1205_driver);
+}
+
+module_init(zd1205_init_module);
+
+module_exit(zd1205_cleanup_module);
+#endif
+
+/*************************************************************************/
+BOOLEAN zdcb_setup_next_send(fragInfo_t *frag_info)
+{
+        struct zd1205_private *macp = g_dev->priv;
+        struct sk_buff *skb = (struct sk_buff *)frag_info->buf;
+        U8 bIntraBss =  frag_info->bIntraBss;
+        U8 MsgID = frag_info->msgID;
+        U8 numOfFrag = frag_info->totalFrag;
+
+        U16 aid = frag_info->aid;
+        U8 hdrLen = frag_info->hdrLen;
+        zd1205_SwTcb_t 	*sw_tcb;
+        zd1205_HwTCB_t	*hw_tcb;
+        zd1205_TBD_t	*pTbd;
+        U8		*hdr, *pBody;
+        U32		bodyLen, length;
+        U32 		tcb_tbd_num = 0;
+        int 		i;
+        U16 		pdu_size = 0;
+
+        void 		*addr;
+        wla_Header_t	*wla_hdr;
+        U32		CurrFragLen;
+        U32		NextFragLen;
+
+        skb_frag_t *frag = NULL;
+        ctrl_Set_parm_t ctrl_setting_parms;
+        U32 TotalLength = 0;
+
+#ifndef HOST_IF_USB
+
+        zd1205_SwTcb_t 	*next_sw_tcb;
+        U32 		tmp_value, tmp_value3;
+        unsigned long lock_flag;
+        U32 loopCnt = 0;
+#endif
+
+#ifdef HOST_IF_USB
+
+        U32 PrvFragLen = 0;
+
+        if (!test_bit(ZD1211_RUNNING, &macp->flags))
+                return FALSE;
+#endif
+
+        ZD1211DEBUG(2, "===== zdcb_setup_next_send enter =====\n");
+        ZD1211DEBUG(2, "zd1211: bIntraBss = %x\n", bIntraBss);
+        ZD1211DEBUG(2, "zd1211: numOfFrag = %x\n", numOfFrag);
+        ZD1211DEBUG(2, "zd1211: skb = %p\n", (void *)skb);
+        ZD1211DEBUG(2, "zd1211: aid = %x\n", aid);
+
+#ifndef HOST_IF_USB
+
+        spin_lock_irqsave(&macp->bd_non_tx_lock, lock_flag);
+#endif
+
+
+        if ((skb) && (!bIntraBss)) {   //data frame from upper layer
+                if (skb_shinfo(skb)->nr_frags) {   //got frag buffer
+                        frag = &skb_shinfo(skb)->frags[0];
+
+                        if (skb->len > macp->cardSetting.FragThreshold) {  //need fragment
+                                pdu_size = macp->cardSetting.FragThreshold - 24 - 4; //mac header and crc32 length
+                                numOfFrag = (skb->len + (pdu_size-1) ) / pdu_size;
+
+                                if (numOfFrag == 0)
+                                        numOfFrag = 1;
+                                ZD1211DEBUG(2, "zd1211: numOfFrag = %x\n", numOfFrag);
+                        }
+                }
+        }
+
+        if (macp->freeTxQ->count -1 < numOfFrag) {
+                printk(KERN_ERR "zd1205: Not enough freeTxQ\n");
+                //printk(KERN_ERR "zd1205: Cnt of freeTxQ = %x\n", macp->freeTxQ->count);
+                zd_EventNotify(EVENT_TX_COMPLETE, ZD_RETRY_FAILED, (U32)MsgID, aid);
+#ifndef HOST_IF_USB
+
+                spin_unlock_irqrestore(&macp->bd_non_tx_lock, lock_flag);
+#endif
+
+                return FALSE;
+        }
+
+        ctrl_setting_parms.Rate = frag_info->rate;
+        ctrl_setting_parms.Preamble = frag_info->preamble;
+        ctrl_setting_parms.encryType = frag_info->encryType;
+        //ctrl_setting_parms.vapId = frag_info->vapId;
+
+        for (i=0; i<numOfFrag; i++) {
+                ZD1211DEBUG(2, "zd1211: Cnt of freeTxQ = %x\n", macp->freeTxQ->count);
+                ZD1211DEBUG(2, "zd1211: Frag Num = %x\n", i);
+
+                sw_tcb = zd1205_first_txq(macp, macp->freeTxQ);
+
+#ifdef HOST_IF_USB
+                //sw_tcb->bHasCompleteBeforeSend = 0;
+                //sw_tcb->bHasBeenDelayedBefore = 0;
+#endif
+
+                hdr = frag_info->macHdr[i];
+
+                if (macp->dbg_flag > 4)
+                        zd1205_dump_data("header part", (U8 *)hdr, 24);
+
+
+                if (skb) {
+                        if ((bIntraBss) || (!frag)) {  //wireless forwarding or tx data from upper layer and no linux frag
+                                ZD1211DEBUG(2, "zd1211: Wireless forwarding or no linux frag\n");
+                                pBody = frag_info->macBody[i];
+                                bodyLen = frag_info->bodyLen[i];
+                                CurrFragLen = bodyLen;
+                                NextFragLen = frag_info->nextBodyLen[i];
+                                if (i == (numOfFrag - 1))
+                                        sw_tcb->LastFrag = 1;
+                                else
+                                        sw_tcb->LastFrag = 0;
+                        } else { //tx data from upper layer with linux frag
+                                ZD1211DEBUG(2, "zd1211: tx data from upper layer with linux frag\n");
+                                pBody = skb->data;
+                                bodyLen = skb->len;
+
+                                if (i == (numOfFrag - 1)) {
+                                        CurrFragLen = bodyLen - i*pdu_size;
+                                        NextFragLen = 0;
+                                        sw_tcb->LastFrag = 1;
+                                } else {
+                                        CurrFragLen = pdu_size;
+                                        sw_tcb->LastFrag = 0;
+
+                                        if (i == (numOfFrag-2))
+                                                NextFragLen = bodyLen - (i+1)*pdu_size;
+                                        else
+                                                NextFragLen = pdu_size;
+
+                                }
+                        }
+                } else {  //mgt frame
+                        //ZD1211DEBUG(2, "zd1211: mgt frame\n");
+
+                        pBody = frag_info->macBody[i];
+                        bodyLen = frag_info->bodyLen[i];
+                        CurrFragLen = bodyLen;
+                        NextFragLen = frag_info->nextBodyLen[i];
+                        sw_tcb->LastFrag = 1;
+                }
+
+                wla_hdr = (wla_Header_t *)hdr;
+                hw_tcb = sw_tcb->pTcb;
+                pTbd = sw_tcb->pFirstTbd;
+                tcb_tbd_num = 0;
+                hw_tcb->TxCbTbdNumber = 0;
+
+                sw_tcb->FrameType = hdr[0];
+                sw_tcb->MsgID = MsgID;
+                sw_tcb->aid = aid;
+                sw_tcb->skb = skb;
+                sw_tcb->bIntraBss = bIntraBss;
+                sw_tcb->Rate = frag_info->rate;
+
+                //ZD1211DEBUG(2, "zd1211: sw_tcb = %x\n", sw_tcb);
+                ZD1211DEBUG(2, "zd1211: hw_tcb = %p\n", (void *)hw_tcb);
+                ZD1211DEBUG(2, "zd1211: first tbd = %p\n", (void *)pTbd);
+
+                ctrl_setting_parms.CurrFragLen = CurrFragLen;
+                ctrl_setting_parms.NextFragLen = NextFragLen;
+
+                /* Control Setting */
+                length = Cfg_CtrlSetting(macp, sw_tcb, wla_hdr, &ctrl_setting_parms);
+                TotalLength = length;
+
+#ifndef __LP64__
+                pTbd->TbdBufferAddrHighPart = 0;
+                pTbd->TbdBufferAddrLowPart = cpu_to_le32(sw_tcb->HwCtrlPhys);
+#else
+                pTbd->TbdBufferAddr = cpu_to_le64(sw_tcb->HwCtrlPhys);
+#endif
+                pTbd->TbdCount = cpu_to_le32(length);
+                pTbd++;
+                tcb_tbd_num++;
+
+                /* MAC Header */
+                if (ctrl_setting_parms.encryType == TKIP) {
+                        length = Cfg_MacHeader(macp, sw_tcb, wla_hdr, hdrLen);
+#ifndef __LP64__
+                        pTbd->TbdBufferAddrLowPart = cpu_to_le32(sw_tcb->HwHeaderPhys);
+#else
+                        pTbd->TbdBufferAddr = cpu_to_le64(sw_tcb->HwHeaderPhys);
+#endif
+                } else { //WPA will failed, why??
+                        length = hdrLen;
+#ifndef __LP64__
+                        pTbd->TbdBufferAddrLowPart = cpu_to_le32(hdr);
+#else
+                        pTbd->TbdBufferAddr = cpu_to_le64(hdr);
+#endif
+                }
+
+                TotalLength += length;
+                pTbd->TbdCount = cpu_to_le32(length);
+                pTbd++;
+                tcb_tbd_num++;
+
+#if defined(AMAC)
+
+                TotalLength += CurrFragLen;
+#ifdef ZD1211
+
+                sw_tcb->pHwCtrlPtr->CtrlSetting[18] = (u8)TotalLength;
+                sw_tcb->pHwCtrlPtr->CtrlSetting[19] = (u8)(TotalLength >> 8);
+#endif
+#endif
+
+                /* Frame Body */
+                if ((!skb) || ((skb) && (!frag)) ) {
+                        U8 * body_dma;
+
+                        ZD1211DEBUG(2, "zd1211: Management frame body or No linux frag\n");
+
+                        if (macp->dbg_flag > 4)
+                                zd1205_dump_data("data part", (U8 *)pBody, 14);
+
+#ifndef __LP64__
+                        pTbd->TbdBufferAddrHighPart = 0;
+#endif
+#ifndef HOST_IF_USB
+
+                        body_dma =  pci_map_single(macp->pdev, pBody, bodyLen, PCI_DMA_TODEVICE);
+#else
+
+                        body_dma = pBody;
+#endif
+
+                        ZD1211DEBUG(2, "zd1211: body_dma = %p\n", body_dma);
+
+#ifndef __LP64__
+                        pTbd->TbdBufferAddrLowPart =  cpu_to_le32(body_dma);
+#else
+                        pTbd->TbdBufferAddr =  cpu_to_le64(body_dma);
+#endif
+                        pTbd->TbdCount = cpu_to_le32(CurrFragLen);
+                        pBody += CurrFragLen;
+
+#ifdef HOST_IF_USB
+
+                        pTbd->PrvFragLen = PrvFragLen;
+                        PrvFragLen += CurrFragLen;
+#endif
+
+                        pTbd++;
+                        tcb_tbd_num++;
+                } else {
+                        while(CurrFragLen ) {
+                                void * body_dma;
+
+
+                                if (CurrFragLen >= frag->size ) {
+                                        printk(KERN_DEBUG "zd1205: linux more frag skb\n");
+                                        addr = ((void *) page_address(frag->page) + frag->page_offset);
+#ifndef __LP64__
+                                        pTbd->TbdBufferAddrHighPart = 0;
+#endif
+#ifndef HOST_IF_USB
+
+                                        body_dma = pci_map_single(macp->pdev, addr, frag->size, PCI_DMA_TODEVICE);
+#else
+
+                                        body_dma = addr;
+#endif
+
+#ifndef __LP64__
+                                        pTbd->TbdBufferAddrLowPart =  cpu_to_le32(body_dma);
+#else
+                                        pTbd->TbdBufferAddr =  cpu_to_le64(body_dma);
+#endif
+                                        pTbd->TbdCount = cpu_to_le32(frag->size);
+                                        tcb_tbd_num++;
+#ifdef HOST_IF_USB
+
+                                        pTbd->PrvFragLen = PrvFragLen;
+                                        PrvFragLen += CurrFragLen;
+#endif
+
+                                        CurrFragLen -= frag->size;
+                                        frag++;
+                                } else {
+                                        printk(KERN_DEBUG "zd1205: linux last frag skb\n");
+                                        addr = ((void *) page_address(frag->page) + frag->page_offset);
+#ifndef __LP64__
+                                        pTbd->TbdBufferAddrHighPart = 0;
+#endif
+#ifndef HOST_IF_USB
+
+                                        body_dma = cpu_to_le32(pci_map_single(macp->pdev, addr, pdu_size, PCI_DMA_TODEVICE));
+#else
+
+                                        body_dma =  addr;
+#endif
+
+#ifndef __LP64__
+                                        pTbd->TbdBufferAddrLowPart =  cpu_to_le32(body_dma);
+#else
+                                        pTbd->TbdBufferAddr =  cpu_to_le64(body_dma);
+#endif
+                                        frag->page_offset += CurrFragLen;
+                                        frag->size -= CurrFragLen;
+#ifdef HOST_IF_USB
+
+                                        pTbd->PrvFragLen = PrvFragLen;
+                                        PrvFragLen += CurrFragLen;
+#endif
+
+                                        CurrFragLen = 0;
+                                }
+
+                                printk(KERN_DEBUG "zd1205: page_address = %p\n", addr);
+                                printk(KERN_DEBUG "zd1205: body_dma = %p\n", body_dma);
+                                pTbd++;
+                                tcb_tbd_num++;
+                        }
+                }
+
+                hw_tcb->TxCbTbdNumber = cpu_to_le32(tcb_tbd_num);
+                macp->txCnt++;
+
+#ifndef HOST_IF_USB
+
+                hw_tcb->CbCommand = 0; /* set this TCB belong to bus master */
+                wmb();
+
+                while(1) {
+                        tmp_value = zd_readl(DeviceState);
+                        tmp_value &= 0xf;
+
+                        if ((tmp_value == TX_READ_TCB) || (tmp_value == TX_CHK_TCB)) {
+                                /* Device is now checking suspend or not.
+                                 Keep watching until it finished check. */
+                                loopCnt++;
+
+                                if (loopCnt > 1000000)
+                                        break;
+
+                                udelay(1);
+                                continue;
+                        } else
+                                break;
+                }
+
+                if (loopCnt > 1000000)
+                        ZD1211DEBUG(0, "I am in zdcb_setup_next_send loop\n") ;
+
+                ZD1211DEBUG(1, "zd1211: Device State = %x\n", (u32)tmp_value);
+
+                if (tmp_value == TX_IDLE) { /* bus master get suspended TCB */
+                        macp->txIdleCnt++;
+
+                        /* Tx bus master is in idle state. */
+                        //tmpValue1 = zd_readl(InterruptCtrl);
+                        /* No retry fail happened */
+                        tmp_value3 = zd_readl(ReadTcbAddress);
+                        next_sw_tcb = macp->freeTxQ->first;
+
+                        if (tmp_value3 != le32_to_cpu(next_sw_tcb->pTcb->NextCbPhyAddrLowPart)) {
+                                /* Restart Tx again */
+                                zd1205_start_download(sw_tcb->TcbPhys);
+                                ZD1211DEBUG(1, "zd1211: Write  PCI_TxAddr_p1 = %x\n", sw_tcb->TcbPhys);
+                        }
+                }
+                else if (tmp_value == 0xA) { //Dtim Notify Int happened
+                        zd1205_start_download(sw_tcb->TcbPhys | BIT_0);
+                }
+
+                ZD1211DEBUG(2, "zd1211: NAV_CCA = %x\n", zd_readl(NAV_CCA));
+                ZD1211DEBUG(2, "zd1211: NAC_CNT = %x\n", zd_readl(NAV_CNT));
+
+#endif
+
+                zd1205_qlast_txq(macp, macp->activeTxQ, sw_tcb);
+
+#ifdef HOST_IF_USB
+                //The following code is to handle cross fragment MIC
+                memcpy(sw_tcb->CalMIC,frag_info->CalSwMic, MIC_LNG+1);
+                sw_tcb->MIC_Start=0;
+                sw_tcb->MIC_Len=0;
+                if(i==numOfFrag-1 && sw_tcb->CalMIC[MIC_LNG]==TRUE) {
+                        if(frag_info->bodyLen[i] < MIC_LNG) {
+                                sw_tcb->MIC_Start=MIC_LNG-frag_info->bodyLen[i];
+                                sw_tcb->MIC_Len=frag_info->bodyLen[i];
+                        } else {
+                                sw_tcb->MIC_Start=0;
+                                sw_tcb->MIC_Len=MIC_LNG;
+                        }
+                        zd1211_submit_tx_urb(macp,TRUE);
+                } else if(sw_tcb->CalMIC[MIC_LNG] == TRUE && (i == numOfFrag-2)) {
+                        if(frag_info->bodyLen[i+1] < MIC_LNG) {
+                                sw_tcb->MIC_Start=0;
+                                sw_tcb->MIC_Len=MIC_LNG-frag_info->bodyLen[i+1];
+                        } else {
+                                sw_tcb->MIC_Start=0;
+                                sw_tcb->MIC_Len=0;
+                        }
+                        zd1211_submit_tx_urb(macp,TRUE);
+                } else
+                        zd1211_submit_tx_urb(macp,FALSE);
+                //zd1205_tx_isr(macp); //for debug only
+#endif
+
+                g_dev->trans_start = jiffies;
+                macp->TxStartTime = nowT();
+                ZD1211DEBUG(2, "zd1211: Cnt of activeQ = %x\n", macp->activeTxQ->count);
+        }
+
+#ifndef HOST_IF_USB
+        spin_unlock_irqrestore(&macp->bd_non_tx_lock, lock_flag);
+#endif
+
+        ZD1211DEBUG(2, "===== zdcb_setup_next_send exit =====\n");
+        return TRUE;
+}
+
+void zdcb_release_buffer(void *buf)
+{
+        struct sk_buff *skb = (struct sk_buff *)buf;
+
+        if (skb)
+                dev_kfree_skb_any(skb);
+        //dev_kfree_skb_irq(skb);
+}
+
+void zdcb_rx_ind(U8 *pData, U32 length, void *buf)
+{
+        struct zd1205_private *macp = g_dev->priv;
+        struct sk_buff *skb = (struct sk_buff *)buf;
+
+        ZENTER(3);
+
+        //copy packet for IP header is located on 4-bytes alignment
+        if (length < RX_COPY_BREAK) {
+                dev_kfree_skb_irq(skb);
+                skb = dev_alloc_skb(length+2);
+
+                if (skb) {
+                        skb->dev = g_dev;
+                        skb_reserve(skb, 2);
+                        eth_copy_and_sum(skb, pData, length, 0);
+
+                        skb_put(skb, length);
+                }
+        } else {
+                skb->tail = skb->data = pData;
+                skb_put(skb, length);
+        }
+
+        //zd1205_dump_data("rx_ind", (U8 *)skb->data, skb->len);
+
+        ZD1211DEBUG(2, "zd1211: rx_ind length = %x\n", (u32)length);
+
+        /* set the protocol */
+        skb->protocol = eth_type_trans(skb, g_dev);
+        skb->ip_summed = CHECKSUM_NONE;	//TBD
+        g_dev->last_rx = jiffies;
+
+        switch(netif_rx(skb)) {
+        case NET_RX_BAD:
+        case NET_RX_DROP:
+        case NET_RX_CN_MOD:
+        case NET_RX_CN_HIGH:
+                break;
+
+        default:
+                macp->drv_stats.net_stats.rx_packets++;
+                macp->drv_stats.net_stats.rx_bytes += skb->len;
+                break;
+        }
+        ZEXIT(3);
+}
+
+U16 zdcb_status_notify(U16 status, U8 *StaAddr)
+{
+        struct zd1205_private *macp = g_dev->priv;
+        U16 result = 0;
+        int newassoc = 0;
+
+        switch (status) {
+        case STA_AUTH_REQ:
+                break;
+
+        case STA_ASOC_REQ:
+                break;
+
+        case STA_REASOC_REQ:
+                break;
+
+        case STA_ASSOCIATED:
+        case STA_REASSOCIATED:
+                macp->bAssoc = 1;
+                mTmRetryConnect=0;
+                iLED_ON(macp, macp->LinkLEDn);
+#ifdef HOST_IF_USB
+
+                macp-> LinkTimer = 0;
+
+                if (macp->DataLED == 0) {
+#ifdef ROBIN_KAO
+                        zd_writel(0x03, FW_LINK_STATUS);
+#else
+
+                        zd_writel(0x01, FW_LINK_STATUS);
+#endif
+
+                } else
+                        zd_writel(0x00, FW_LINK_STATUS);
+#endif
+
+                memcpy(&macp->BSSID[0], StaAddr, 6);
+
+                //if (macp->cardSetting.BssType == INFRASTRUCTURE_BSS)
+                if (macp->cardSetting.BssType != AP_BSS) {
+                        netif_wake_queue(macp->device);
+                        netif_carrier_on(macp->device);
+                }
+
+                if (status == STA_ASSOCIATED) {
+                        ZD1211DEBUG(0, "STA_ASSOCIATED with " MACSTR "\n", MAC2STR(StaAddr));
+                        newassoc = 1;
+                } else {
+                        ZD1211DEBUG(0, "STA_REASSOCIATED with " MACSTR "\n", MAC2STR(StaAddr));
+                }
+                /* Generate a wireless event to the upper layer */
+                if(test_and_clear_bit(CTX_FLAG_ESSID_WAS_SET, (void*)&macp->flags)) {
+                        zd1205_notify_join_event(macp);
+                }
+
+                break;
+
+        case STA_DISASSOCIATED:
+        case STA_DEAUTHED:
+#ifndef HOST_IF_USB
+
+                iLED_OFF(macp, LED1);
+#else
+
+                zd_writel(0x0, FW_LINK_STATUS);
+#endif
+
+                macp->bAssoc = 0;
+
+                if (macp->cardSetting.BssType == INFRASTRUCTURE_BSS) {
+                        union iwreq_data wreq;
+                        memset(&wreq, 0, sizeof(wreq));
+                        wreq.addr.sa_family=ARPHRD_ETHER;
+                        wireless_send_event(macp->device, SIOCGIWAP,&wreq, NULL);
+                        memset(&macp->BSSID[0], 0, 6);
+                        netif_stop_queue(macp->device);
+                        //zd1205_dis_connect(macp);
+                        netif_carrier_off(macp->device);
+                }
+                if (status == STA_DISASSOCIATED)
+                        ZD1211DEBUG(0, "STA_DISASSOCIATED:" MACSTR "\n",MAC2STR(StaAddr));
+                else
+                        ZD1211DEBUG(0, "STA_DEAUTHED:" MACSTR "\n",MAC2STR(StaAddr));
+
+                break;
+
+        default:
+                break;
+        }
+
+        return result;
+}
+
+
+void zdcb_tx_completed(void)
+{
+}
+
+void chal_tout_cb(unsigned long ptr)
+{
+#ifdef HOST_IF_USB
+        struct zd1205_private *macp = g_dev->priv;
+        defer_kevent(macp, KEVENT_TCHAL_TIMEOUT);
+#else
+
+        zd_EventNotify(EVENT_TCHAL_TIMEOUT, 0, 0, 0);
+#endif
+}
+
+void scan_tout_cb(unsigned long ptr)
+{
+#ifdef HOST_IF_USB
+        struct zd1205_private *macp = g_dev->priv;
+        defer_kevent(macp, KEVENT_SCAN_TIMEOUT);
+#else
+
+        zd_EventNotify(EVENT_SCAN_TIMEOUT, 0, 0, 0);
+#endif
+}
+
+void asoc_tout_cb(unsigned long ptr)
+{
+#ifdef HOST_IF_USB
+        struct zd1205_private *macp = g_dev->priv;
+        defer_kevent(macp, KEVENT_AUTH_TIMEOUT);
+#else
+
+        zd_EventNotify(EVENT_ASOC_TIMEOUT, 0, 0, 0);
+#endif
+}
+
+void auth_tout_cb(unsigned long ptr)
+{
+#ifdef HOST_IF_USB
+        struct zd1205_private *macp = g_dev->priv;
+        defer_kevent(macp, KEVENT_AUTH_TIMEOUT);
+#else
+
+        zd_EventNotify(EVENT_AUTH_TIMEOUT, 0, 0, 0);
+#endif
+}
+
+void zdcb_start_timer(U32 timeout, U32 event)
+{
+        struct zd1205_private *macp = g_dev->priv;
+        u32	timeout_in_jiffies;
+        if (!macp->bUSBDeveiceAttached)
+                return;
+        timeout_in_jiffies= (timeout*HZ)/1000; // Conver ms to jiffies
+
+        switch (event) {
+        case DO_CHAL:
+                /* ath_desc: fix timer-related race conditions */
+                macp->tm_chal_id.data = (unsigned long) g_dev;
+                macp->tm_chal_id.function = chal_tout_cb;
+                mod_timer(&macp->tm_chal_id, jiffies + timeout_in_jiffies);
+                break;
+
+        case DO_SCAN:
+                macp->tm_scan_id.data = (unsigned long) g_dev;
+                macp->tm_scan_id.function = scan_tout_cb;
+                mod_timer(&macp->tm_scan_id, jiffies + timeout_in_jiffies);
+                break;
+
+
+        case DO_AUTH:
+                macp->tm_auth_id.data = (unsigned long) g_dev;
+                macp->tm_auth_id.function = auth_tout_cb;
+                mod_timer(&macp->tm_auth_id, jiffies + timeout_in_jiffies);
+                break;
+
+        case DO_ASOC:
+                if(AsocTimerStat) {
+                        del_timer_sync(&macp->tm_asoc_id);
+                        AsocTimerStat = FALSE;
+                }
+                init_timer(&macp->tm_asoc_id);
+                macp->tm_asoc_id.data = (unsigned long) g_dev;
+                macp->tm_asoc_id.function = asoc_tout_cb;
+                mod_timer(&macp->tm_asoc_id, jiffies + timeout_in_jiffies);
+                AsocTimerStat = TRUE;
+                break;
+
+        default:
+                break;
+        }
+}
+
+
+void zdcb_stop_timer(U32 TimerId)
+{
+        struct zd1205_private *macp = g_dev->priv;
+
+        switch (TimerId) {
+        case DO_CHAL:
+                del_timer_sync(&macp->tm_chal_id);
+                break;
+
+        case DO_AUTH:
+                del_timer_sync(&macp->tm_auth_id);
+                break;
+
+
+        case DO_ASOC:
+                del_timer_sync(&macp->tm_asoc_id);
+                AsocTimerStat = FALSE;
+                break;
+
+        default:
+                break;
+
+        }
+}
+
+U32
+zdcb_dis_intr(void)
+{
+        struct zd1205_private *macp = g_dev->priv;
+        U32 flags = 0;
+
+#if 1//ndef HOST_IF_USB
+
+        spin_lock_irqsave(&macp->cs_lock, flags);
+#else
+
+        spin_lock(&macp->cs_lock);
+#endif
+
+        return flags;
+}
+
+void
+zdcb_set_intr_mask(U32 flags)
+{
+        struct zd1205_private *macp = g_dev->priv;
+
+#if 1//ndef HOST_IF_USB
+
+        spin_unlock_irqrestore(&macp->cs_lock, flags);
+#else
+
+        spin_unlock(&macp->cs_lock);
+#endif
+}
+
+U32 zdcb_vir_to_phy_addr(U32 virtAddr) //TBD
+{
+        return virtAddr;
+}
+
+void zdcb_set_reg(void *reg, U32 offset, U32 value)
+{
+        zd_writel(value, offset);
+}
+
+U32 zdcb_get_reg(void *reg, U32 offset)
+{
+        return zd_readl(offset);
+}
+
+BOOLEAN
+zdcb_check_tcb_avail(U8	num_of_frag)
+{
+        struct zd1205_private *macp = g_dev->priv;
+        BOOLEAN ret;
+
+        U32 flags;
+
+        spin_lock_irqsave(&macp->q_lock, flags);
+
+        /* ath_desc: fix oops when performing scan without invoking ifconfig up first */
+        if (!macp->freeTxQ) {
+                printk(KERN_WARNING "zd1211: FIXME: frames cannot be sent when the iface is down\n");
+                ret = FALSE;
+        } else if (macp->freeTxQ->count < (num_of_frag+1))
+                ret = FALSE;
+        else
+                ret = TRUE;
+
+        spin_unlock_irqrestore(&macp->q_lock, flags);
+        return ret;
+}
+
+
+void zdcb_delay_us(U16 ustime)
+{
+        struct zd1205_private *macp=g_dev->priv;
+        interruptible_sleep_on_timeout(&macp->msdelay, ustime/1000);
+        //udelay(ustime);
+}
+
+void * zdcb_AllocBuffer(U16 dataSize, U8 **pData)
+{
+        struct sk_buff *new_skb = NULL;
+
+        new_skb = (struct sk_buff *) dev_alloc_skb(dataSize);
+        if (new_skb) {
+                *pData = new_skb->data;
+        }
+
+        return (void *)new_skb;
+}
+
+unsigned long int next = 1;
+
+int zdcb_Rand(U32 seed)
+{
+        static int first = 1;
+
+        if (first) {
+                next = seed;
+                first = 0;
+        }
+
+        next = next * 1103515245 + 12345;
+        return ((unsigned int)(next/65535)%32768);
+}
+
+void zdcb_AcquireDoNotSleep(void)
+{
+        struct zd1205_private *macp = g_dev->priv;
+        atomic_inc(&macp->DoNotSleep);
+}
+
+void zdcb_ReleaseDoNotSleep(void)
+{
+        struct zd1205_private *macp = g_dev->priv;
+        atomic_dec(&macp->DoNotSleep);
+}
+#ifdef HOSTAPD_SUPPORT
+/*
+   In this callback function, we just copy the WPA IE into the
+   field of each STA's hash_t entry. The behavior is for the hostapd.
+ */
+
+int zdcb_AssocRequest(U8 *addr, U8 *WPAIE, U16 size)
+{
+        Hash_t *pHash;
+        (void)size; /* unused callback param */
+
+        if (mCounterMeasureState) {
+#ifdef WPA_DEBUG
+                printk(KERN_DEBUG "---------In CounterMeasure state, fail AssocReqest\n");
+#endif
+
+                return 1;
+        }
+        pHash = HashSearch((MacAddr_t *)addr);
+
+        /* Can't search the MAC address in the hash table. */
+        if (pHash == NULL)
+                return 1;
+        else {
+                memcpy(&pHash->WPAIE, WPAIE, sizeof(pHash->WPAIE));
+        }
+        return 0;
+}
+
+void zdcb_MicFailure(unsigned char *addr)
+{
+        union iwreq_data wrqu;
+        char buf[128];
+
+        /* TODO: needed parameters: count, keyid, key type, src address, TSC */
+#ifdef WPA_DEBUG
+
+        printk(KERN_ERR "MLME-MICHAELMICFAILURE.indication addr=" MACSTR "\n", MAC2STR(addr));
+#endif
+
+        memset(&wrqu, 0, sizeof(wrqu));
+        wrqu.data.length = strlen(buf);
+        wireless_send_event(g_dev, IWEVCUSTOM, &wrqu, buf);
+}
+
+#endif
+
+//setup callback functions for protocol stack
+void zd1205_set_zd_cbs(zd_80211Obj_t *pObj)
+{
+        pObj->QueueFlag = 0;
+        pObj->ConfigFlag = 0;
+        pObj->SetReg = zdcb_set_reg;
+        pObj->GetReg = zdcb_get_reg;
+
+        pObj->ReleaseBuffer = zdcb_release_buffer;
+        pObj->RxInd = zdcb_rx_ind;
+        pObj->TxCompleted = zdcb_tx_completed;
+        pObj->StartTimer = zdcb_start_timer;
+        pObj->StopTimer = zdcb_stop_timer;
+        pObj->SetupNextSend = zdcb_setup_next_send;
+
+        pObj->StatusNotify = zdcb_status_notify;
+        pObj->ExitCS = zdcb_set_intr_mask;
+        pObj->EnterCS = zdcb_dis_intr;
+        pObj->Vir2PhyAddr = zdcb_vir_to_phy_addr;
+        pObj->CheckTCBAvail = zdcb_check_tcb_avail;
+        pObj->DelayUs = zdcb_delay_us;
+        pObj->AllocBuffer = zdcb_AllocBuffer;
+        pObj->Rand = zdcb_Rand;
+        pObj->AcquireDoNotSleep = zdcb_AcquireDoNotSleep;
+        pObj->ReleaseDoNotSleep = zdcb_ReleaseDoNotSleep;
+        pObj->bChScanning=0;
+
+        // wpa support
+#ifdef HOSTAPD_SUPPORT
+
+        pObj->MicFailure = zdcb_MicFailure;
+        pObj->AssocRequest = zdcb_AssocRequest;
+        pObj->WpaIe = NULL;
+#else
+        // wpa support
+        pObj->MicFailure = NULL;
+        pObj->AssocRequest = NULL;
+        pObj->WpaIe = NULL;
+#endif
+
+}
+
+void zd1205_SetRatesInfo(struct zd1205_private *macp)
+{
+
+        u8 bRatesSet = 1;
+        card_Setting_t *pCardSetting;
+
+        pCardSetting = &macp->cardSetting;
+
+        if (pCardSetting->MacMode == MIXED_MODE)
+        {
+                ZD1211DEBUG(0, "Mixed Mode\n");
+                zd_writel(CW_SHORT_SLOT, CWmin_CWmax);
+                pCardSetting->ShortSlotTime = 1;
+                pCardSetting->PreambleType = 1; //short preamble
+                bRatesSet = 1;
+        } else if (pCardSetting->MacMode == PURE_G_MODE)
+        {
+                ZD1211DEBUG(0, "Pure G-Mode\n");
+                zd_writel(CW_SHORT_SLOT, CWmin_CWmax);
+                pCardSetting->ShortSlotTime = 1;
+                pCardSetting->PreambleType = 1; //short preamble
+                bRatesSet = 2;
+        } else if (pCardSetting->MacMode == PURE_A_MODE)
+        {
+                ZD1211DEBUG(0, "Pure A-Mode\n");
+                zd_writel(CW_SHORT_SLOT, CWmin_CWmax);
+                pCardSetting->ShortSlotTime = 1;
+                pCardSetting->PreambleType = 1; //short preamble
+                bRatesSet = 4;
+
+        } else if (pCardSetting->MacMode == PURE_B_MODE)
+        { // pure B mode
+                ZD1211DEBUG(0, "Pure B-Mode\n");
+                zd_writel(CW_NORMAL_SLOT, CWmin_CWmax);
+                pCardSetting->ShortSlotTime = 0;
+                pCardSetting->PreambleType = 1; //short preamble
+                bRatesSet = 3;
+        } else
+                VerAssert();
+
+        if (bRatesSet == 1)
+        { //wi-fi set1
+                // supported rates
+                pCardSetting->Info_SupportedRates[0] = 0x01;
+                pCardSetting->Info_SupportedRates[1] = 0x04;
+                pCardSetting->Info_SupportedRates[2] = 0x82; //basic rate
+                pCardSetting->Info_SupportedRates[3] = 0x84; //basic rate
+                pCardSetting->Info_SupportedRates[4] = 0x8B; //basic rate
+                pCardSetting->Info_SupportedRates[5] = 0x96; //basic rate
+
+                //Extended supported rates
+                pCardSetting->Ext_SupportedRates[0] = 0x32;
+                pCardSetting->Ext_SupportedRates[1] = 0x08;
+                pCardSetting->Ext_SupportedRates[2] = 0x0c;
+                pCardSetting->Ext_SupportedRates[3] = 0x12;
+                pCardSetting->Ext_SupportedRates[4] = 0x18;
+                pCardSetting->Ext_SupportedRates[6] = 0x24;
+                pCardSetting->Ext_SupportedRates[7] = 0x30;
+                pCardSetting->Ext_SupportedRates[8] = 0x48;
+                pCardSetting->Ext_SupportedRates[5] = 0x60;
+                pCardSetting->Ext_SupportedRates[9] = 0x6c;
+                zd_writel(0x150f, MandatoryRateTbl); //1,2,5.5,11,6,12,24
+        } else if (bRatesSet == 2)
+        { //wi-fi set2
+                // supported rates
+                pCardSetting->Info_SupportedRates[0] = 0x01;
+                pCardSetting->Info_SupportedRates[1] = 0x04;
+                pCardSetting->Info_SupportedRates[2] = 0x82; //basic rate
+                pCardSetting->Info_SupportedRates[3] = 0x84; //basic rate
+                pCardSetting->Info_SupportedRates[4] = 0x8B; //basic rate
+                pCardSetting->Info_SupportedRates[5] = 0x96; //basic rate
+
+                //Extended supported rates
+                pCardSetting->Ext_SupportedRates[0] = 0x32;
+                pCardSetting->Ext_SupportedRates[1] = 0x08;
+                pCardSetting->Ext_SupportedRates[2] = 0x8c; //basic rate
+                pCardSetting->Ext_SupportedRates[3] = 0x12;
+                pCardSetting->Ext_SupportedRates[4] = 0x98; //basic rate
+                pCardSetting->Ext_SupportedRates[6] = 0x24;
+                pCardSetting->Ext_SupportedRates[7] = 0xb0; //basic rate
+                pCardSetting->Ext_SupportedRates[8] = 0x48;
+                pCardSetting->Ext_SupportedRates[5] = 0x60;
+                pCardSetting->Ext_SupportedRates[9] = 0x6c;
+
+                zd_writel(0x150f, MandatoryRateTbl); //1,2,5.5,11,6,12,24
+        } else if (bRatesSet == 3)
+        { //pure b mode
+                // supported rates
+                pCardSetting->Info_SupportedRates[0] = 0x01;
+                pCardSetting->Info_SupportedRates[1] = 0x04;
+                pCardSetting->Info_SupportedRates[2] = 0x82; //basic rate
+                pCardSetting->Info_SupportedRates[3] = 0x84; //basic rate
+                pCardSetting->Info_SupportedRates[4] = 0x8B; //basic rate
+                pCardSetting->Info_SupportedRates[5] = 0x96; //basic rate
+                zd_writel(0x0f, MandatoryRateTbl); //1,2,5.5,11
+        } else if (bRatesSet == 4)
+        {//Pure A
+                pCardSetting->Info_SupportedRates[0] = 0x01; //Element ID
+                pCardSetting->Info_SupportedRates[1] = 0x08; //Rates Amount
+                pCardSetting->Info_SupportedRates[2] = 0x80+12 ; //RateByte = Mandatory Bit + 500k x 12
+                pCardSetting->Info_SupportedRates[3] = 0x00+18; //Supported Rate
+                pCardSetting->Info_SupportedRates[4] = 0x80+24; //basic rate
+                pCardSetting->Info_SupportedRates[5] = 0x00+36;
+                pCardSetting->Info_SupportedRates[6] = 0x80+48; //basic rate
+                pCardSetting->Info_SupportedRates[7] = 0x00+72;
+                pCardSetting->Info_SupportedRates[8] = 0x00+96;
+                pCardSetting->Info_SupportedRates[9] = 0x00+108;
+
+                zd_writel(0x0f, MandatoryRateTbl); //6,9,12,18,24,36,48,54
+
+        }
+
+}
+
+
+u16 ZDLOGTEN[] = {0,
+                  0   ,  30 ,  47 ,  60 ,  69 ,  77 ,  84 ,  90 ,  95 , 100 ,
+                  104 , 107 , 111 , 114 , 117 , 120 , 123 , 125 , 127 , 130 ,
+                  132 , 134 , 136 , 138 , 139 , 141 , 143 , 144 , 146 , 147 ,
+                  149 , 150 , 151 , 153 , 154 , 155 , 156 , 157 , 159 , 160 ,
+                  161 , 162 , 163 , 164 , 165 , 166 , 167 , 168 , 169 , 169 ,
+                  170 , 171 , 172 , 173 , 174 , 174 , 175 , 176 , 177 , 177 ,
+                  178 , 179 , 179 , 180 , 181 , 181 , 182 , 183 , 183 , 184 ,
+                  185 , 185 , 186 , 186 , 187 , 188 , 188 , 189 , 189 , 190 ,
+                  190 , 191 , 191 , 192 , 192 , 193 , 193 , 194 , 194 , 195 ,
+                  195 , 196 , 196 , 197 , 197 , 198 , 198 , 199 , 199 , 200 ,
+                  200 , 200 , 210 , 210 , 220 , 220 , 220 , 230 , 230 , 240 ,
+                  240 , 240 , 250 , 250 , 260 , 260 , 260 , 270 , 270 , 270 ,
+                  280 , 280 , 280 , 290 , 290 , 210 , 210 , 210 , 211 , 211 ,
+                  211 , 212 , 212 , 212 , 213 , 213 , 213 , 213 , 214 , 214 ,
+                  214 , 215 , 215 , 215 , 216 , 216 , 216 , 217 , 217 , 217 ,
+                  217 , 218 , 218 , 218 , 219 , 219 , 219 , 219 , 220 , 220 ,
+                  220 , 220 , 221 , 221 , 221 , 222 , 222 , 222 , 222 , 223 ,
+                  223 , 223 , 223 , 224 , 224 , 224 , 224 , 225 , 225 , 225 ,
+                  225
+                 };
+
+u16
+ZDLog10multiply100(int data)
+{
+        if ((data >= 0) && (data <= 0xb5))
+                return ZDLOGTEN[data];
+        else
+                return 225;
+}
+
+
+
+u32 X_Constant[] = {
+                           715, 655, 585, 540, 470, 410, 360, 315,
+                           270, 235, 205, 175, 150, 125, 105, 85,
+                           65, 50, 40, 25, 15
+
+                   };
+
+
+u8 X_To_dB(u32 X, u8 rate)
+{
+        u8 ret = 0;
+        int i;
+
+        int SizeOfX_Con = sizeof(X_Constant);
+
+        switch (rate) {
+        case 0x0B:  // 6M
+        case 0x0A:  // 12M
+        case 0x09:  // 24M
+                X /= 2;
+                break;
+        case 0x0F:  // 9M
+        case 0x0E:  // 18M
+        case 0x0D:  // 36M
+        case 0x0C:  // 54M
+                X *= 3;
+                X /= 4;
+                break;
+        case 0x08:  // 48M
+                X *= 2;
+                X /= 3;
+                break;
+        default:
+                break;
+        }
+        for (i=0; i<SizeOfX_Con; i++) {
+                if (X > X_Constant[i])
+                        break;
+        }
+
+        switch (rate) {
+        case 0x0B:  // 6M
+        case 0x0F:  // 9M
+                ret = i + 3;
+                break;
+        case 0x0A:  // 12M
+        case 0x0E:  // 18M
+                ret = i + 5;
+                break;
+        case 0x09:  // 24M
+        case 0x0D:  // 36M
+                ret = i + 9;
+                break;
+        case 0x08:  // 48M
+        case 0x0C:  // 54M
+                ret = i + 15;
+                break;
+        default:
+                break;
+        }
+        return ret;
+}
+
+u8 CalculateQuality(struct zd1205_private *macp, zd1205_RFD_t *rfd, u8 *pQualityIndB)
+{
+        u8 CorrectQuality = 0;
+        plcp_wla_Header_t *wla_hdr;
+        u32 frame_len,tot_len;
+        u8 SignalQuality2 = macp->rxSignalQuality2;
+        u32 X;
+        u16	tmpf;
+        u8 rxOffset = macp->rxOffset;
+
+        wla_hdr = (plcp_wla_Header_t *)&rfd->RxBuffer[macp->rxOffset];
+        tot_len = (le32_to_cpu(rfd->ActualCount) & 0x3fff);
+        frame_len = tot_len - EXTRA_INFO_LEN;
+        SignalQuality2 = rfd->RxBuffer[frame_len+2];
+
+
+
+        if (rfd->RxBuffer[tot_len-1] & 0x01)
+        {
+                // it's OFDM
+                macp->rxOFDMDataFrame++;
+
+                X = 10000 * SignalQuality2 / (frame_len - macp->rxOffset);
+                CorrectQuality = X_To_dB(X, wla_hdr->PlcpHdr[0] & 0xF);
+
+                if (pQualityIndB)
+                        *pQualityIndB = CorrectQuality;
+
+                CorrectQuality = (CorrectQuality +0)* 4;
+                if (CorrectQuality > 100)
+                        CorrectQuality = 100;
+        } else
+        {
+                // it's CCK
+                macp->rx11bDataFrame++;
+
+                // the value from PHY is in scale from Max is 0 and Min is 0xb5
+                switch(wla_hdr->PlcpHdr[0]) {
+                case 0x0A: //1M
+                case 0x14: //2M
+                case 0x37: //5.5M
+                case 0x6E: //11M
+                        tmpf = 0;
+
+                        if (macp->rxSignalQuality1 > 0)
+                                tmpf = (u16)(ZDLog10multiply100(macp->rxSignalQuality1) * 20 /100);
+                        CorrectQuality = 45 - (u8)(tmpf);
+
+                        if (pQualityIndB)
+                                *pQualityIndB = CorrectQuality;
+
+                        CorrectQuality = (CorrectQuality+5) * 4;
+
+                        if (CorrectQuality > 100)
+                                CorrectQuality = 100;
+                        break;
+
+                default:
+                        break;
+
+
+                }
+        }
+
+        return CorrectQuality;
+}
+
+u8 CalculateStrength(struct zd1205_private *macp, zd1205_RFD_t *rfd)
+{
+        // return in ? , the Value-105 = dB
+        // the value from PHY is in ?
+        u32 frame_len;
+        u32 tot_len;
+        u8 i, rssi, tmp;
+        u32 tmpvalue = 2;
+        plcp_wla_Header_t *wla_hdr;
+        //u8 rxOffset = macp->rxOffset;
+
+        wla_hdr = (plcp_wla_Header_t *)&rfd->RxBuffer[macp->rxOffset];
+        tot_len = (le32_to_cpu(rfd->ActualCount) & 0x3fff);
+        frame_len = tot_len - EXTRA_INFO_LEN;
+        rssi = rfd->RxBuffer[frame_len+1];
+
+        if ( (((macp->cardSetting.BssType == INFRASTRUCTURE_BSS)&&
+                        (!memcmp(wla_hdr->Address2, macp->BSSID, 6))) ||
+                        ((macp->cardSetting.BssType == INDEPENDENT_BSS)&&
+                         (!memcmp(wla_hdr->Address3, macp->BSSID, 6))) ||
+                        (macp->cardSetting.BssType == PSEUDO_IBSS)) &&
+                        (macp->bAssoc) )
+        {
+                for(i=0; i<macp->PHYTestIndex-1; i++)
+                        tmpvalue *= 2;
+
+                //if ( (dot11Obj.CR122Flag == 1)||(dot11Obj.CR203Flag == 1) )
+                //	rssi += 22;
+                tmp = macp->PHYTestRssi;
+                macp->PHYTestTotal = macp->PHYTestTotal
+                                     - (macp->PHYTestTotal/tmpvalue)
+                                     + rssi;
+                macp->PHYTestRssi = (u8) (macp->PHYTestTotal/tmpvalue);
+        }
+
+        return rssi;
+}
+
+void zd1205_initCAM(struct zd1205_private *macp)
+{
+        int i;
+
+        zd_writel(0, CAM_ROLL_TB_LOW);
+        zd_writel(0, CAM_ROLL_TB_HIGH);
+
+        for (i=0; i<445; i++)
+        {
+                HW_CAM_Write(&dot11Obj, i, 0);
+        }
+}
+
+int zd1205_CheckOverlapBss(struct zd1205_private *macp, plcp_wla_Header_t *pWlanHdr, u8 *pMacBody, u32 bodyLen)
+{
+        u8 *pByte;
+        u32 currPos = 0;
+        u8 elemId, elemLen;
+        u8 gAP = 0;
+
+        u8 ErpInfo = 0;
+
+        //get element
+        pByte = pMacBody+SSID_OFFSET;
+        currPos = SSID_OFFSET;
+
+        while(currPos < bodyLen)
+        {
+                elemId = *pByte;
+                elemLen = *(pByte+1);
+
+                switch(elemId) {
+                case ELEID_ERP_INFO: //ERP info
+                        gAP = 1;
+                        ErpInfo = *(pByte+2);
+                        pByte += (elemLen+2);
+                        break;
+
+                default:
+                        pByte += (elemLen+2);
+                        break;
+
+                }
+
+                currPos += elemLen+2;
+        }
+
+        if (gAP)
+        {
+                if (ErpInfo & NON_ERP_PRESENT_BIT) { //with B sta associated
+                        return 1;
+                } else
+                        return 0;
+        } else // B AP exist, enable protection mode
+                return 1;
+}
+
+void zd1205_HandleQosRequest(struct zd1205_private *macp)
+{
+        zd1205_SwTcb_t *sw_tcb;
+
+        if (!macp->activeTxQ->count)
+                sw_tcb = macp->freeTxQ->first;
+        else
+                sw_tcb = macp->activeTxQ->first;
+        zd1205_start_download(sw_tcb->TcbPhys | BIT_0);
+}
+
+/**
+ * zd1205_notify_join_event - Notify wireless join event to the upper layer
+ * @macp: atapter's private data struct
+ * @newassoc: new associate or not
+ *
+ */
+
+void zd1205_notify_join_event(struct zd1205_private *macp)
+{
+        union iwreq_data wreq;
+
+        memset(&wreq, 0, sizeof(wreq));
+        memcpy(wreq.addr.sa_data, &macp->BSSID[0], 6);
+        wreq.addr.sa_family = ARPHRD_ETHER;
+
+        {
+                ZD1211DEBUG(0, "Notify_join_event:" MACSTR "\n",MAC2STR(macp->BSSID));
+                /*	int ii;
+
+                	WPADEBUG("zd1205_notfiy_join_event: MAC= ");
+                	for(ii = 0; ii < 6; ii++)
+                		WPADEBUG("%02x ", macp->BSSID[ii] & 0xff);
+                	WPADEBUG("\n");*/
+        }
+
+        if(macp->cardSetting.BssType == INFRASTRUCTURE_BSS)
+        {
+                wireless_send_event(macp->device, SIOCGIWAP, &wreq, NULL);
+        }
+#if WIRELESS_EXT >= 15
+        else if(macp->cardSetting.BssType == AP_BSS)
+        {
+                wireless_send_event(macp->device, IWEVREGISTERED, &wreq, NULL);
+        }
+#endif
+}
+void zd1205_notify_disjoin_event(struct zd1205_private *macp)
+{
+        union iwreq_data wreq;
+
+        memset(&wreq, 0, sizeof(wreq));
+        //memcpy(wreq.addr.sa_data, &macp->BSSID[0], 6);
+        wreq.addr.sa_family = ARPHRD_ETHER;
+        printk(KERN_DEBUG "zd1205_notify_disjoin_event\n");
+        /*{
+        	int ii;
+
+        	WPADEBUG("zd1205_notfiy_join_event: MAC= ");
+        	for(ii = 0; ii < 6; ii++)
+        		WPADEBUG("%02x ", macp->BSSID[ii] & 0xff);
+        	WPADEBUG("\n");
+        }*/
+
+        if(macp->cardSetting.BssType == INFRASTRUCTURE_BSS)
+        {
+                //wireless_send_event(macp->device, SIOCGIWSCAN, &wreq, NULL);
+                wireless_send_event(macp->device, SIOCGIWAP, &wreq, NULL);
+        }
+        /*#if WIRELESS_EXT >= 15
+        	else if(macp->cardSetting.BssType == AP_BSS) {
+        		wireless_send_event(macp->device, IWEVREGISTERED, &wreq, NULL);
+        	}
+        #endif*/
+}
+void zd1205_notify_scan_done(struct zd1205_private *macp)
+{
+        union iwreq_data wreq;
+        wreq.data.length = 0;
+        wreq.data.flags = 0;
+        wireless_send_event(macp->device, SIOCGIWSCAN, &wreq, NULL);
+}
+#if WIRELESS_EXT >= 18
+void hostap_michael_mic_failure(struct zd1205_private *macp,
+                                struct hostap_ieee80211_hdr *hdr,
+                                int keyidx)
+{
+        union iwreq_data wrqu;
+        struct iw_michaelmicfailure ev;
+
+        /* TODO: needed parameters: count, keyid, key type, TSC */
+        memset(&ev, 0, sizeof(ev));
+        ev.flags = keyidx & IW_MICFAILURE_KEY_ID;
+        if (hdr->addr1[0] & 0x01)
+                ev.flags |= IW_MICFAILURE_GROUP;
+        else
+                ev.flags |= IW_MICFAILURE_PAIRWISE;
+        ev.src_addr.sa_family = ARPHRD_ETHER;
+        memcpy(ev.src_addr.sa_data, hdr->addr2, ETH_ALEN);
+        memset(&wrqu, 0, sizeof(wrqu));
+        wrqu.data.length = sizeof(ev);
+        wireless_send_event(g_dev, IWEVMICHAELMICFAILURE, &wrqu, (char *) &ev);
+}
+#elif WIRELESS_EXT >= 15
+// For kernel 2.6.5(FC2), WIRELESS_EXT is 16
+void hostap_michael_mic_failure(struct zd1205_private *macp,
+                                struct hostap_ieee80211_hdr *hdr,
+                                int keyidx)
+{
+        union iwreq_data wrqu;
+        char buf[128];
+
+        /* TODO: needed parameters: count, keyid, key type, TSC */
+        sprintf(buf, "MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr="
+                MACSTR ")", keyidx, hdr->addr1[0] & 0x01 ? "broad" : "uni",
+                MAC2STR(hdr->addr2));
+        memset(&wrqu, 0, sizeof(wrqu));
+        wrqu.data.length = strlen(buf);
+        printk("MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr="
+               MACSTR ")", keyidx, hdr->addr1[0] & 0x01 ? "broad" : "uni",
+               MAC2STR(hdr->addr2));
+        wireless_send_event(g_dev, IWEVCUSTOM, &wrqu, buf);
+}
+#else /* WIRELESS_EXT >= 15 */
+void hostap_michael_mic_failure(struct zd1205_private *macp,
+                                struct hostap_ieee80211_hdr *hdr,
+                                int keyidx)
+{}
+#endif /* WIRELESS_EXT >= 15 */
+void ChangeMacMode(u8 MAC_Mode, u8 Channel)
+{
+        struct zd1205_private *macp;
+
+        if(NULL != g_dev && NULL != g_dev->priv)
+                macp = (struct zd1205_private *)g_dev->priv;
+        else {
+                LongPrint("NULL macp in ChnageMacMode\n",1);
+                return;
+        }
+
+
+        zd1205_lock(macp);
+        macp->cardSetting.Channel = Channel; //Default Channel to 8
+        dot11Obj.Channel = Channel;
+        macp->cardSetting.MacMode = MAC_Mode ;
+        macp->bDefaultIbssMacMode=1;
+        zd1205_unlock(macp);
+
+        //set_mac_mode command has been issued by the user.
+        zd1205_SetRatesInfo(macp);
+        //zd_UpdateCardSetting(&(macp->cardSetting));
+}
+#if ZDCONF_WE_STAT_SUPPORT == 1
+struct iw_statistics *
+                        zd1205_iw_getstats(struct net_device *dev)
+{
+        struct zd1205_private *macp = (struct zd1205_private *)dev->priv;
+
+        macp->iwstats.discard.fragment = macp->ArAgedCnt
+                                         + macp->ArFreeFailCnt;
+
+        macp->iwstats.discard.retries = macp->retryFailCnt;
+        macp->iwstats.discard.misc = macp->invalid_frame_good_crc
+                                     + macp->rxDupCnt;
+
+        return &macp->iwstats;
+
+}
+#elif !defined(ZDCONF_WE_STAT_SUPPORT)
+	#error "Undefine ZDCONF_WE_STAT_SUPPORT"
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zd1205.h linux-2.4.35.3-mct/drivers/usb/zd1211/zd1205.h
--- linux-2.4.35.3/drivers/usb/zd1211/zd1205.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zd1205.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,1340 @@
+#ifndef _ZD1205_H_
+#define _ZD1205_H_
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+
+#ifdef HOST_IF_USB
+	#include <linux/usb.h>
+#endif
+
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/wait.h>
+#include <linux/reboot.h>
+#include <asm/io.h>
+#include <asm/unaligned.h>
+#include <asm/processor.h>
+#include <linux/ethtool.h>
+#include <linux/inetdevice.h>
+#include <linux/bitops.h>
+#include <linux/if.h>
+#include <asm/uaccess.h>
+#include <linux/proc_fs.h>
+#include <linux/ip.h>
+#include <linux/wireless.h>
+#include <linux/if_arp.h>
+#include <linux/unistd.h>
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
+	#include <linux/workqueue.h>
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+    #include <asm/div64.h>
+#endif
+
+#include "zdcompat.h"
+#include "zdequates.h"
+#include "zdapi.h"
+#include "zydas_common.h"
+
+#include "zd1211_wext.h"
+
+#ifdef HOST_IF_USB
+#define fANT_DIVERSITY          0
+#define fTX_PWR_CTRL            1
+#define fZD1211_LOOPBACK        1
+#define fDUMP_LOOPBACK_DATA     (0 && fZD1211_LOOPBACK)
+#define fLOAD_BOOTCODE          1
+#define fPROG_FLASH             (1 && fWRITE_WORD_REG)
+#define fPROG_FLASH_BY_FW       (1 && fPROG_FLASH)
+#define fDRV_WRITE_RF_REG       (1 && fWRITE_WORD_REG)
+#define fMERGE_RX_FRAME         (ENHANCE_RX && fDRV_WRITE_RF_REG)
+#define fDRV_UPDATE_EEP         (1 && fWRITE_WORD_REG)
+//#define fQuickPhySet			0 //(fREAD_MUL_REG && fWRITE_WORD_REG)
+#endif
+enum zd1205_device_type {
+        ZD_1202 = 1,
+        ZD_1205,
+};
+
+
+#define	ASOC_RSP				0x10
+#define REASOC_RSP 				0x30
+#define PROBE_RSP 				0x50
+#define DISASOC 				0xA0
+#define AUTH 					0xB0
+#define DEAUTH 					0xC0
+#define DATA 					0x08
+#define PS_POLL					0xA4
+#define MANAGEMENT				0x00
+#define PROBE_REQ				0x40
+#define BEACON					0x80
+#define ACK					0xD4
+#define CONTROL					0x04
+#define NULL_FUNCTION				0x48
+#define LB_DATA					0x88
+
+#define VLAN_SIZE   	4
+#define CHKSUM_SIZE 	2
+
+#define false		(0)
+#define true		(1)
+
+
+
+/**************************************************************************
+**		Register Offset Definitions
+***************************************************************************
+*/
+
+#define		ZD1205_CR0			0x0000
+#define		ZD1205_CR1			0x0004
+#define		ZD1205_CR2			0x0008
+#define		ZD1205_CR3			0x000C
+#define		ZD1205_CR5			0x0010
+#define		ZD1205_CR6			0x0014
+#define		ZD1205_CR7			0x0018
+#define		ZD1205_CR8			0x001C
+#define		ZD1205_CR4			0x0020
+#define		ZD1205_CR9			0x0024
+#define		ZD1205_CR10			0x0028
+#define		ZD1205_CR11			0x002C
+#define		ZD1205_CR12			0x0030
+#define		ZD1205_CR13			0x0034
+#define		ZD1205_CR14			0x0038
+#define		ZD1205_CR15			0x003C
+#define		ZD1205_CR16			0x0040
+#define		ZD1205_CR17			0x0044
+#define		ZD1205_CR18			0x0048
+#define		ZD1205_CR19			0x004C
+#define		ZD1205_CR20			0x0050
+#define		ZD1205_CR21			0x0054
+#define		ZD1205_CR22			0x0058
+#define		ZD1205_CR23			0x005C
+
+
+
+#define		ZD1205_CR24			0x0060
+#define		ZD1205_CR25			0x0064
+#define		ZD1205_CR26			0x0068
+#define		ZD1205_CR27			0x006C
+#define		ZD1205_CR28			0x0070
+#define		ZD1205_CR29			0x0074
+#define		ZD1205_CR30			0x0078
+#define		ZD1205_CR31			0x007C
+#define		ZD1205_CR32			0x0080
+#define		ZD1205_CR33			0x0084
+#define		ZD1205_CR34			0x0088
+#define		ZD1205_CR35			0x008C
+#define		ZD1205_CR36			0x0090
+#define		ZD1205_CR37			0x0094
+#define		ZD1205_CR38			0x0098
+#define		ZD1205_CR39			0x009C
+#define		ZD1205_CR40			0x00A0
+#define		ZD1205_CR41			0x00A4
+#define		ZD1205_CR42			0x00A8
+#define		ZD1205_CR43			0x00AC
+#define		ZD1205_CR44			0x00B0
+#define		ZD1205_CR45			0x00B4
+#define		ZD1205_CR46			0x00B8
+#define		ZD1205_CR47			0x00BC
+#define		ZD1205_CR48			0x00C0
+#define		ZD1205_CR49			0x00C4
+
+#define		ZD1205_CR50			0x00C8
+#define		ZD1205_CR51			0x00CC
+#define		ZD1205_CR52			0x00D0
+#define		ZD1205_CR53			0x00D4
+#define		ZD1205_CR54			0x00D8
+#define		ZD1205_CR55			0x00DC
+#define		ZD1205_CR56			0x00E0
+#define		ZD1205_CR57			0x00E4
+#define		ZD1205_CR58			0x00E8
+#define		ZD1205_CR59			0x00EC
+#define		ZD1205_CR60			0x00F0
+#define		ZD1205_CR61			0x00F4
+#define		ZD1205_CR62			0x00F8
+#define		ZD1205_CR63			0x00FC
+#define		ZD1205_CR64			0x0100
+#define		ZD1205_CR65			0x0104
+#define		ZD1205_CR66			0x0108
+#define		ZD1205_CR67			0x010C
+#define		ZD1205_CR68			0x0110
+#define		ZD1205_CR69			0x0114
+#define		ZD1205_CR70			0x0118
+#define		ZD1205_CR71			0x011C
+#define		ZD1205_CR72			0x0120
+#define		ZD1205_CR73			0x0124
+#define		ZD1205_CR74			0x0128
+#define		ZD1205_CR75			0x012C
+#define		ZD1205_CR76			0x0130
+#define		ZD1205_CR77			0x0134
+#define		ZD1205_CR78			0x0138
+#define		ZD1205_CR79			0x013C
+#define		ZD1205_CR80			0x0140
+#define		ZD1205_CR81			0x0144
+#define		ZD1205_CR82			0x0148
+#define		ZD1205_CR83			0x014C
+#define		ZD1205_CR84			0x0150
+#define		ZD1205_CR85			0x0154
+#define		ZD1205_CR86			0x0158
+#define		ZD1205_CR87			0x015C
+#define		ZD1205_CR88			0x0160
+#define		ZD1205_CR89			0x0164
+
+#define		ZD1205_CR90			0x0168
+#define		ZD1205_CR91			0x016C
+#define		ZD1205_CR92			0x0170
+#define		ZD1205_CR93			0x0174
+#define		ZD1205_CR94			0x0178
+#define		ZD1205_CR95			0x017C
+#define		ZD1205_CR96			0x0180
+#define		ZD1205_CR97			0x0184
+#define		ZD1205_CR98			0x0188
+#define		ZD1205_CR99			0x018C
+#define		ZD1205_CR100			0x0190
+#define		ZD1205_CR101			0x0194
+#define		ZD1205_CR102			0x0198
+#define		ZD1205_CR103			0x019C
+#define		ZD1205_CR104			0x01A0
+#define		ZD1205_CR105			0x01A4
+#define		ZD1205_CR106			0x01A8
+#define		ZD1205_CR107			0x01AC
+#define		ZD1205_CR108			0x01B0
+#define		ZD1205_CR109			0x01B4
+#define		ZD1205_CR110			0x01B8
+#define		ZD1205_CR111			0x01BC
+#define		ZD1205_CR112			0x01C0
+#define		ZD1205_CR113			0x01C4
+#define		ZD1205_CR114			0x01C8
+#define		ZD1205_CR115			0x01CC
+#define		ZD1205_CR116			0x01D0
+#define		ZD1205_CR117			0x01D4
+#define		ZD1205_CR118			0x01D8
+#define		ZD1205_CR119			0x01EC
+#define		ZD1205_CR120			0x01E0
+#define		ZD1205_CR121			0x01E4
+#define		ZD1205_CR122			0x01E8
+#define		ZD1205_CR123			0x01EC
+#define		ZD1205_CR124			0x01F0
+#define		ZD1205_CR125			0x01F4
+#define		ZD1205_CR126			0x01F8
+#define		ZD1205_CR127			0x01FC
+#define		ZD1205_CR128			0x0200
+#define		ZD1205_CR129			0x0204
+#define		ZD1205_CR130			0x0208
+#define		ZD1205_CR131			0x020C
+#define		ZD1205_CR132			0x0210
+#define		ZD1205_CR133			0x0214
+#define		ZD1205_CR134			0x0218
+#define		ZD1205_CR135			0x021C
+#define		ZD1205_CR136			0x0220
+#define		ZD1205_CR137			0x0224
+#define		ZD1205_CR138			0x0228
+#define		ZD1205_CR139			0x022C
+#define		ZD1205_CR140			0x0230
+#define		ZD1205_CR141			0x0234
+#define		ZD1205_CR142			0x0238
+#define		ZD1205_CR143			0x023C
+#define		ZD1205_CR144			0x0240
+#define		ZD1205_CR145			0x0244
+#define		ZD1205_CR146			0x0248
+#define		ZD1205_CR147			0x024C
+#define		ZD1205_CR148			0x0250
+#define		ZD1205_CR149			0x0254
+#define		ZD1205_CR150			0x0258
+#define		ZD1205_CR151			0x025C
+#define		ZD1205_CR152			0x0260
+#define		ZD1205_CR153			0x0264
+#define		ZD1205_CR154			0x0268
+#define		ZD1205_CR155			0x026C
+#define		ZD1205_CR156			0x0270
+#define		ZD1205_CR157			0x0274
+#define		ZD1205_CR158			0x0278
+#define		ZD1205_CR159			0x027C
+#define		ZD1205_CR160			0x0280
+#define		ZD1205_CR161			0x0284
+#define		ZD1205_CR162			0x0288
+#define		ZD1205_CR163			0x028C
+#define		ZD1205_CR164			0x0290
+#define		ZD1205_CR165			0x0294
+
+
+
+#define		ZD1205_CR166			0x0298
+#define		ZD1205_CR167			0x029C
+#define		ZD1205_CR168			0x02A0
+#define		ZD1205_CR169			0x02A4
+#define		ZD1205_CR170			0x02A8
+#define		ZD1205_CR171			0x02AC
+#define		ZD1205_CR172			0x02B0
+#define		ZD1205_CR173			0x02B4
+#define		ZD1205_CR174			0x02B8
+#define		ZD1205_CR175			0x02BC
+#define		ZD1205_CR176			0x02C0
+#define		ZD1205_CR177			0x02C4
+#define		ZD1205_CR178			0x02C8
+#define		ZD1205_CR179			0x02CC
+#define		ZD1205_CR180			0x02D0
+#define		ZD1205_CR181			0x02D4
+#define		ZD1205_CR182			0x02D8
+#define		ZD1205_CR183			0x02DC
+#define		ZD1205_CR184			0x02E0
+#define		ZD1205_CR185			0x02E4
+#define		ZD1205_CR186			0x02E8
+#define		ZD1205_CR187			0x02EC
+#define		ZD1205_CR188			0x02F0
+#define		ZD1205_CR189			0x02F4
+#define		ZD1205_CR190			0x02F8
+#define		ZD1205_CR191			0x02FC
+#define		ZD1205_CR192			0x0300
+#define		ZD1205_CR193			0x0304
+#define		ZD1205_CR194			0x0308
+#define		ZD1205_CR195			0x030C
+#define		ZD1205_CR196			0x0310
+#define		ZD1205_CR197			0x0314
+#define		ZD1205_CR198			0x0318
+#define		ZD1205_CR199			0x031C
+#define		ZD1205_CR200			0x0320
+#define		ZD1205_CR201			0x0324
+#define		ZD1205_CR202			0x0328
+#define		ZD1205_CR203			0x032C
+#define		ZD1205_CR204			0x0330
+#define		ZD1205_CR205			0x0334
+#define		ZD1205_CR206			0x0338
+#define		ZD1205_CR207			0x033C
+#define		ZD1205_CR208			0x0340
+#define		ZD1205_CR209			0x0344
+#define		ZD1205_CR210			0x0348
+#define		ZD1205_CR211			0x034C
+#define		ZD1205_CR212			0x0350
+#define		ZD1205_CR213			0x0354
+#define		ZD1205_CR214			0x0358
+#define		ZD1205_CR215			0x035C
+#define		ZD1205_CR216			0x0360
+#define		ZD1205_CR217			0x0364
+#define		ZD1205_CR218			0x0368
+#define		ZD1205_CR219			0x036C
+#define		ZD1205_CR220			0x0370
+#define		ZD1205_CR221			0x0374
+
+#define		ZD1205_CR222			0x0378
+#define		ZD1205_CR223			0x037C
+#define		ZD1205_CR224			0x0380
+#define		ZD1205_CR225			0x0384
+#define		ZD1205_CR226			0x0388
+#define		ZD1205_CR227			0x038C
+#define		ZD1205_CR228			0x0390
+#define		ZD1205_CR229			0x0394
+#define		ZD1205_CR230			0x0398
+#define		ZD1205_CR231			0x039C
+
+#define		ZD1205_CR232			0x03A0
+#define		ZD1205_CR233			0x03A4
+#define		ZD1205_CR234			0x03A8
+#define		ZD1205_CR235			0x03AC
+#define		ZD1205_CR236			0x03B0
+
+#define		ZD1205_CR240			0x03C0
+#define		ZD1205_CR241			0x03C4
+#define		ZD1205_CR242			0x03C8
+#define		ZD1205_CR243			0x03CC
+#define		ZD1205_CR244			0x03D0
+#define		ZD1205_CR245			0x03D4
+
+#define		ZD1205_CR251			0x03EC
+#define		ZD1205_CR252			0x03F0
+#define		ZD1205_CR253			0x03F4
+#define		ZD1205_CR254			0x03F8
+#define		ZD1205_CR255			0x03FC
+
+
+#define		ZD1205_PHY_END		0x03fc
+#define		RF_IF_CLK		0x0400
+#define		RF_IF_DATA		0x0404
+#define		PE1_PE2			0x0408
+#define		PE2_DLY			0x040C
+#define		LE1			0x0410
+#define		LE2			0x0414
+#define		GPI_EN			0x0418
+#define		RADIO_PD		0x042C
+#define		RF2948_PD		0x042C
+
+#ifndef HOST_IF_USB
+	#define		LED1		0x0430
+	#define		LED2		0x0434
+#else
+	#define     rLED_CTRL           0x0644
+	#define     LED2                BIT_8   // Note: this is really LED1
+	#define     LED1                BIT_9   // Note: this is really LED2
+#endif
+
+
+#define		EnablePSManualAGC	0x043C	// 1: enable
+#define		CONFIGPhilips		0x0440
+#define		SA2400_SER_AP		0x0444
+#define		I2C_WRITE		0x0444	// Same as SA2400_SER_AP (for compatible with ZD1201)
+#define		SA2400_SER_RP		0x0448
+
+#define		RADIO_PE		0x0458
+#define		RstBusMaster		0x045C
+
+#define		RFCFG			0x0464
+
+#define		HSTSCHG			0x046C
+
+#define		PHY_ON			0x0474
+#define		RX_DELAY		0x0478
+#define		RX_PE_DELAY		0x047C
+
+
+#define		GPIO_1			0x0490
+#define		GPIO_2			0x0494
+
+
+#define		EncryBufMux		0x04A8
+
+
+#define		PS_Ctrl			0x0500
+
+#define		ADDA_MBIAS_WarmTime	0x0508
+
+#define		InterruptCtrl		0x0510
+#define		TSF_LowPart		0x0514
+#define		TSF_HighPart		0x0518
+#define		ATIMWndPeriod		0x051C
+#define		BCNInterval		0x0520
+#define		Pre_TBTT		0x0524	//In unit of TU(1024us)
+
+#define		PCI_TxAddr_p1		0x0600
+#define		PCI_TxAddr_p2		0x0604
+#define		PCI_RxAddr_p1		0x0608
+#define		PCI_RxAddr_p2		0x060C
+#define		MACAddr_P1		0x0610
+#define		MACAddr_P2		0x0614
+#define		BSSID_P1		0x0618
+#define		BSSID_P2		0x061C
+#define		BCNPLCPCfg		0x0620
+#define		GroupHash_P1		0x0624
+#define		GroupHash_P2		0x0628
+#define		WEPTxIV			0x062C
+
+#define		BasicRateTbl		0x0630
+#define		MandatoryRateTbl	0x0634
+#define		RTS_CTS_Rate		0x0638
+
+#define		Wep_Protect		0x063C
+#define		RX_THRESHOLD		0x0640
+#define		TX_PE_CTRL		0x0644
+
+#if defined(AMAC)
+	#define	AfterPNP		0x0648
+#endif
+
+#if defined(OFDM)
+	#define	AckTime80211		0x0658
+#endif
+
+#define		Rx_OFFSET		0x065c
+
+
+#define		PHYDelay		0x066C
+#define		BCNFIFO			0x0670
+#define		SnifferOn		0x0674
+#define		EncryptionType		0x0678
+#define		RetryMAX		0x067C
+#define		CtlReg1			0x0680	//Bit0:		IBSS mode
+//Bit1:		PwrMgt mode
+//Bit2-4 :	Highest basic Rate
+//Bit5:		Lock bit
+//Bit6:		PLCP weight select
+//Bit7:		PLCP switch
+#define		DeviceState		0x0684
+#define		UnderrunCnt		0x0688
+#define		Rx_Filter		0x068c
+#define		Ack_Timeout_Ext		0x0690
+#define		BCN_FIFO_Semaphore	0x0694
+#define		IFS_Value		0x0698
+#define		RX_TIME_OUT		0x069C
+#define		TotalRxFrm		0x06A0
+#define		CRC32Cnt		0x06A4
+#define		CRC16Cnt		0x06A8
+#define		DecrypErr_UNI		0x06AC
+#define		RxFIFOOverrun		0x06B0
+
+#define		DecrypErr_Mul		0x06BC
+
+#define		NAV_CNT			0x06C4
+#define		NAV_CCA			0x06C8
+#define		RetryCnt		0x06CC
+
+#define		ReadTcbAddress		0x06E8
+
+#define		ReadRfdAddress		0x06EC
+#define		CWmin_CWmax		0x06F0
+#define		TotalTxFrm		0x06F4
+#define		RX_OFFSET_BYTE		0x06F8
+
+#define		CAM_MODE		0x0700
+#define		CAM_ROLL_TB_LOW		0x0704
+#define		CAM_ROLL_TB_HIGH	0x0708
+#define		CAM_ADDRESS		0x070C
+#define		CAM_DATA		0x0710
+#define 	DECRY_ERR_FLG_LOW	0x0714
+#define 	DECRY_ERR_FLG_HIGH	0x0718
+#define		WEPKey0			0x0720
+#define		WEPKey1			0x0724
+#define		WEPKey2			0x0728
+#define		WEPKey3			0x072C
+#define		CAM_DEBUG		0x0728
+#define		CAM_STATUS		0x072c
+#define		WEPKey4				0x0730
+#define		WEPKey5				0x0734
+#define		WEPKey6				0x0738
+#define		WEPKey7				0x073C
+#define		WEPKey8				0x0740
+#define		WEPKey9				0x0744
+#define		WEPKey10			0x0748
+#define		WEPKey11			0x074C
+#define		WEPKey12			0x0750
+#define		WEPKey13			0x0754
+#define		WEPKey14			0x0758
+#define		WEPKey15			0x075c
+#define		TKIP_MODE			0x0760
+
+#define		Dbg_FIFO_Rd			0x0800
+#define		Dbg_Select			0x0804
+#define		FIFO_Length			0x0808
+
+
+//#define		RF_Mode					0x080C
+
+#define		RSSI_MGC			0x0810
+
+#define		PON					0x0818
+#define		Rx_ON				0x081C
+#define		Tx_ON				0x0820
+#define		CHIP_EN				0x0824
+#define		LO_SW				0x0828
+#define		TxRx_SW				0x082C
+#define		S_MD				0x0830
+
+#define		USB_DEBUG_PORT		0x0888
+
+// EEPROM Memmory Map Region
+#define		E2P_SUBID			0x0900
+#define		E2P_POD				0x0904
+#define		E2P_MACADDR_P1		0x0908
+#define		E2P_MACADDR_P2		0x090C
+
+#ifndef HOST_IF_USB
+#define		E2P_PWR_CAL_VALUE	0x0910
+
+#define		E2P_PWR_INT_VALUE	0x0920
+
+#define		E2P_ALLOWED_CHANNEL	0x0930
+#define		E2P_PHY_REG			0x0934
+
+#define		E2P_REGION_CODE		0x0960
+#define		E2P_FEATURE_BITMAP	0x0964
+#endif
+
+//-------------------------------------------------------------------------
+// Command Block (CB) Field Definitions
+//-------------------------------------------------------------------------
+//- RFD Command Bits
+#define RFD_EL_BIT              BIT_0	        // RFD EL Bit
+
+//- CB Command Word
+#define CB_S_BIT                0x1          // CB Suspend Bit
+
+//- CB Status Word
+#define CB_STATUS_COMPLETE      0x1234          // CB Complete Bit
+
+#define RFD_STATUS_COMPLETE     0x1234   //0x34120000       // RFD Complete Bit
+
+
+/**************************************************************************
+**		MAC Register Bit Definitions
+***************************************************************************
+*/
+// Interrupt STATUS
+#define	TX_COMPLETE		BIT_0
+#define	RX_COMPLETE		BIT_1
+#define	RETRY_FAIL		BIT_2
+#define WAKE_UP			BIT_3
+#define	DTIM_NOTIFY		BIT_5
+#define	CFG_NEXT_BCN		BIT_6
+#define BUS_ABORT		BIT_7
+#define TX_FIFO_READY		BIT_8
+#define UART_INT		BIT_9
+
+#define	TX_COMPLETE_EN		BIT_16
+#define	RX_COMPLETE_EN		BIT_17
+#define	RETRY_FAIL_EN		BIT_18
+#define WAKE_UP_EN		BIT_19
+#define	DTIM_NOTIFY_EN		BIT_21
+#define	CFG_NEXT_BCN_EN		BIT_22
+#define BUS_ABORT_EN		BIT_23
+#define TX_FIFO_READY_EN	BIT_24
+#define UART_INT_EN		BIT_25
+
+#define	FILTER_BEACON		0xFEFF //mask bit 8
+#define	UN_FILTER_PS_POLL	0x0400
+
+#define RX_LEN_THRESHOLD	0x640	//1600
+
+#define	DBG_MSG_SHOW		0x1
+#define	DBG_MSG_HIDE		0x0
+
+
+#define	RFD_POINTER(skb, macp)      ((zd1205_RFD_t *) (((unsigned char *)((skb)->data))-((macp)->rfd_size)))
+#define	SKB_RFD_STATUS(skb, macp)   ((RFD_POINTER((skb),(macp)))->CbStatus)
+
+
+/**************************************************************************
+**		Descriptor Data Structure
+***************************************************************************/
+struct driver_stats
+{
+        struct net_device_stats net_stats;
+/* ath_desc: added iw_get_stats */
+#ifdef CONFIG_NET_WIRELESS
+        struct iw_statistics iw_stats;
+#endif
+        unsigned long tx_late_col;
+        unsigned long tx_ok_defrd;
+        unsigned long tx_one_retry;
+        unsigned long tx_mt_one_retry;
+        unsigned long rcv_cdt_frames;
+        unsigned long xmt_fc_pkts;
+        unsigned long rcv_fc_pkts;
+        unsigned long rcv_fc_unsupported;
+        unsigned long xmt_tco_pkts;
+        unsigned long rcv_tco_pkts;
+
+        unsigned long rx_intr_pkts;
+};
+
+//-------------------------------------------------------------------------
+// Transmit Command Block (TxCB)
+//-------------------------------------------------------------------------
+typedef struct zd1205_HwTCB_s
+{
+        u32	CbStatus;					// Bolck status
+        u32	CbCommand;					// Block command
+/* ath_desc: AMD64 support */
+#ifndef __LP64__
+        u32	NextCbPhyAddrLowPart; 		// Next TCB address(low part)
+        u32	NextCbPhyAddrHighPart;		// Next TCB address(high part)
+        u32 TxCbFirstTbdAddrLowPart; 	// First TBD address(low part)
+        u32 TxCbFirstTbdAddrHighPart;	// First TBD address(high part)
+#else
+        u64 NextCbPhyAddr;		// Next TCB address
+        u64 TxCbFirstTbdAddr;		// First TBD address
+#endif
+        u32 TxCbTbdNumber;				// Number of TBDs for this TCB
+}
+zd1205_HwTCB_t;
+
+//-------------------------------------------------------------------------
+// Transmit Buffer Descriptor (TBD)
+//-------------------------------------------------------------------------
+typedef struct zd1205_TBD_s
+{
+#ifndef __LP64__
+        u32 TbdBufferAddrLowPart;		// Physical Transmit Buffer Address
+        u32 TbdBufferAddrHighPart;		// Physical Transmit Buffer Address
+#else
+        u64 TbdBufferAddr;
+#endif
+        u32 TbdCount;		// Data length
+#ifdef HOST_IF_USB
+
+        u32 PrvFragLen;
+#endif
+}
+zd1205_TBD_t;
+
+//-------------------------------------------------------------------------
+// Receive Frame Descriptor (RFD)
+//-------------------------------------------------------------------------
+struct zd1205_RFD_s
+{
+        u32	CbStatus;				// Bolck status
+        u32	ActualCount;			// Rx buffer length
+        u32	CbCommand;				// Block command
+        u32	MaxSize;				//
+#ifndef __LP64__
+        u32	NextCbPhyAddrLowPart;		// Next RFD address(low part)
+        u32	NextCbPhyAddrHighPart;		// Next RFD address(high part)
+#else
+        u64	NextCbPhyAddr;		// Next RFD address
+#endif
+        u8	RxBuffer[MAX_WLAN_SIZE];	// Rx buffer
+        u32	Pad[2];			// Pad to 16 bytes alignment - easy view for debug
+} __attribute__ ((__packed__));
+typedef struct zd1205_RFD_s zd1205_RFD_t;
+
+
+typedef struct zd1205_Ctrl_Set_s
+{
+        u8	CtrlSetting[40];
+}
+zd1205_Ctrl_Set_t;
+
+typedef struct zd1205_Header_s
+{
+        u8	MacHeader[32];
+
+}
+zd1205_Header_t;
+
+//-------------------------------------------------------------------------
+// ZD1205SwTcb -- Software Transmit Control Block.  This structure contains
+// all of the variables that are related to a specific Transmit Control
+// block (TCB)
+//-------------------------------------------------------------------------
+typedef struct zd1205_SwTcb_s
+{
+        // Link to the next SwTcb in the list
+        struct zd1205_SwTcb_s *next;
+        struct sk_buff *skb;
+
+        // physical and virtual pointers to the hardware TCB
+        zd1205_HwTCB_t *pTcb;
+        unsigned long TcbPhys;
+
+        // Physical and virtual pointers to the TBD array for this TCB
+        zd1205_TBD_t *pFirstTbd;
+        unsigned long FirstTbdPhys;
+
+        zd1205_Ctrl_Set_t *pHwCtrlPtr;
+        unsigned long HwCtrlPhys;
+
+        zd1205_Header_t *pHwHeaderPtr;
+        unsigned long HwHeaderPhys;
+        u32 TcbCount;
+        u8 LastFrag;
+        u8 MsgID;
+        u8 FrameType;
+        u8 Rate;
+        u16 aid;
+        u8 bIntraBss;
+        //u8 encryType;
+
+#ifdef HOST_IF_USB
+
+        u8 bHasCompleteBeforeSend;
+        u8 bHasBeenDelayedBefore;
+#endif
+
+        u8 CalMIC[MIC_LNG+1];
+        u8 MIC_Start;
+        u8 MIC_Len;
+        u32 LengthDiff;
+}
+zd1205_SwTcb_t;
+
+
+typedef struct SwTcbQ_s
+{
+        zd1205_SwTcb_t 	*first;		/* first zd1205_SwTcb_t in Q */
+        zd1205_SwTcb_t 	*last;		/* last zd1205_SwTcb_t in Q */
+        u16			count;		/* number of zd1205_SwTcb_t in Q */
+}
+zd1205_SwTcbQ_t;
+
+//- Wireless 24-byte Header
+typedef struct wla_Header_s
+{
+        u8		FrameCtrl[2];
+        u8		Duration[2];
+        u8		DA[6];
+        u8		BSSID[6];
+        u8		SA[6];
+        u8		SeqCtrl[2];
+}
+wla_Header_t;
+struct hostap_ieee80211_hdr
+{
+        u16 frame_control;
+        u16 duration_id;
+        u8 addr1[6];
+        u8 addr2[6];
+        u8 addr3[6];
+        u16 seq_ctrl;
+        u8 addr4[6];
+}
+__attribute__ ((packed));
+
+//from station
+typedef struct plcp_wla_Header_s
+{
+        u8		PlcpHdr[PLCP_HEADER];    //Oh! shit!!!
+        u8		FrameCtrl[2];
+        u8		Duration[2];
+        u8		Address1[6];
+        u8		Address2[6];
+        u8		Address3[6];
+        u8		SeqCtrl[2];
+}
+plcp_wla_Header_t;
+
+typedef struct ctrl_Set_parm_s
+{
+        u8			Rate;
+        u8			Preamble;
+        u8			encryType;
+        u8			vapId;
+        //u8			bHwAppendMic;
+        u32			CurrFragLen;
+        u32			NextFragLen;
+}
+ctrl_Set_parm_t;
+
+typedef struct tuple_s
+{
+        u8		ta[6]; //TA (Address 2)
+        u16		sn;
+        u8		fn;
+        u8		full;
+}
+tuple_t;
+
+typedef struct tuple_Cache_s
+{
+        tuple_t cache[TUPLE_CACHE_SIZE];
+        u8 freeTpi;
+}
+tuple_Cache_t;
+
+typedef struct defrag_Mpdu_s
+{
+        u8	ta[6];
+        u8	inUse;
+        u8	fn;
+        u32	eol;
+        u16	sn;
+        void 	*buf;
+        void	*dataStart;
+}
+defrag_Mpdu_t;
+
+
+typedef struct defrag_Array_s
+{
+        defrag_Mpdu_t mpdu[MAX_DEFRAG_NUM];
+}
+defrag_Array_t;
+
+/*Rx skb holding structure*/
+struct rx_list_elem
+{
+        struct list_head list_elem;
+        dma_addr_t dma_addr;
+        struct sk_buff *skb;
+#ifdef HOST_IF_USB
+
+        u32 UnFinishFrmLen;
+#endif
+}
+__attribute__ ((__packed__));
+
+
+#define ZD1211_MAX_MTU		2400
+#define MAX_EPINT_BUFFER	64
+#define NUM_TCB				64//32
+#define NUM_TBD_PER_TCB		(2+MAX_SKB_FRAGS)	//3
+#define NUM_TBD				(NUM_TCB * NUM_TBD_PER_TCB)
+#define NUM_RFD				32
+#ifdef HOST_IF_USB
+//    #define ZD1205_INT_MASK		CFG_NEXT_BCN_EN | DTIM_NOTIFY_EN | WAKE_UP_EN
+#define ZD1205_INT_MASK		0x4F0000
+#else
+    #define ZD1205_INT_MASK		TX_COMPLETE_EN | RX_COMPLETE_EN | RETRY_FAIL_EN | CFG_NEXT_BCN_EN | DTIM_NOTIFY_EN | WAKE_UP_EN | BUS_ABORT_EN
+#endif
+#define TX_RING_BYTES		(NUM_TCB * (sizeof(zd1205_HwTCB_t) + sizeof(zd1205_Ctrl_Set_t) + sizeof(zd1205_Header_t)))+ (NUM_TBD * sizeof(zd1205_TBD_t))
+#define ZD1205_REGS_SIZE	4096
+#define ZD_RX_OFFSET        0x03
+
+struct zdap_ioctl
+{
+        u16 cmd;                /* Command to run */
+        u32 addr;                /* Length of the data buffer */
+        u32 value;              /* Pointer to the data buffer */
+        u8  data[0x100];
+};
+
+struct zd1205_private
+{
+        //linux used
+        struct net_device 	*device;
+
+#ifdef HOST_IF_USB
+
+        struct usb_device	*usb;
+        int			dev_index;
+        struct urb		*ctrl_urb, *rx_urb, *tx_urb, *intr_urb, *reg_urb;
+        struct urb		*read_urb, *write_urb; /* tmp urb pointer for rx_tasklet, tx_tasklet */
+        wait_queue_head_t	regSet_wait;
+        wait_queue_head_t	iorwRsp_wait;
+        wait_queue_head_t	term_wait;
+        wait_queue_head_t	msdelay;
+        struct semaphore	ps_sem;
+        struct semaphore	bcn_sem;
+        struct semaphore	reg_sem;
+        struct semaphore	config_sem;
+        struct usb_interface	*interface;		/* the interface for this device */
+        spinlock_t 		intr_lock;
+        spinlock_t		rx_pool_lock;
+        u8          		tx_buff[ZD1211_MAX_MTU];
+#if 1//(LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+
+        u8			IntEPBuffer[MAX_EPINT_BUFFER];
+#else
+
+        u8			*IntEPBuffer;
+        dma_addr_t		IntBufferHandle;
+#endif
+
+        u8			IntEPBuffer2[MAX_EPINT_BUFFER];
+        u8			IntEPBuffer3[MAX_EPINT_BUFFER];
+        u8			num_interrupt_in;
+        u8			num_interrupt_out;
+        u8			num_bulk_in;
+        u8			num_bulk_out;
+        u8			in_interval;
+        u8			out_interval;
+        u8			ep4isIntOut;
+        u8			cmd_end;
+        u8			read_end;
+        u16			wMaxPacketSize;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+
+        unsigned int		flags;
+        unsigned int		kevent_flags;
+#else
+
+        unsigned long		flags;
+        unsigned long		kevent_flags;
+#endif
+
+        int 			release;			/* release number */
+        int			total_rx_cnt;
+        int			end;
+        u32			usbTxCnt;
+        u32			usbTxCompCnt;
+        struct rx_list_elem **rx_struct_array;
+        struct tasklet_struct zd1211_rx_tasklet;
+        struct tasklet_struct zd1211_tx_tasklet;
+        struct tasklet_struct rx_buff_tasklet;
+        struct work_struct      scan_tout_event;
+
+        struct work_struct	kevent;
+        struct zdap_ioctl	zdreq;
+        /* ath_desc: support for unpatched wpasupplicant */
+        struct iw_mlme		mlme_req;
+        struct ifreq		ifreq;
+        struct zydas_wlan_param	zd_wpa_req;
+        int			ifcmd;
+
+        //debug counter
+        u32			regWaitRCompCnt;
+        u32			regWaitWCompCnt;
+        u32			regRWCompCnt;
+        u32			regWaitRspCnt;
+        u32			regRspCompCnt;
+        u32			regUnCompCnt;
+        u32			regRdSleepCnt;
+#else
+
+        struct pci_dev 		*pdev;
+#endif
+
+        struct driver_stats	drv_stats;
+#if ZDCONF_WE_STAT_SUPPORT == 1
+
+        struct iw_statistics iwstats;
+#elif !defined(ZDCONF_WE_STAT_SUPPORT)
+	#error "Undefine ZDCONF_WE_STAT_SUPPORT"
+#endif
+
+        struct timer_list 	watchdog_timer;		/* watchdog timer id */
+        struct timer_list 	tm_chal_id;
+        struct timer_list	tm_scan_id;
+        struct timer_list	tm_auth_id;
+        struct timer_list	tm_asoc_id;
+        struct timer_list	tm_hking_id;
+        struct timer_list	tm_mgt_id;
+        char			ifname[IFNAMSIZ];
+        spinlock_t 		bd_lock;		/* board lock */
+        spinlock_t 		bd_non_tx_lock;		/* Non transmit command lock  */
+        spinlock_t		q_lock;
+        spinlock_t		cs_lock;
+        spinlock_t		conf_lock;
+        int	                using_dac;
+        struct tasklet_struct zd1205_tasklet;
+        struct tasklet_struct zd1205_ps_tasklet;
+        struct tasklet_struct zd1205_tx_tasklet;
+        struct proc_dir_entry *proc_parent;
+        struct list_head 	active_rx_list;		/* list of rx buffers */
+        struct list_head 	rx_struct_pool;		/* pool of rx buffer struct headers */
+        u16 			rfd_size;
+        u8			rev_id;			/* adapter PCI revision ID */
+        u8	                sniffer_on;
+        int			skb_req;		/* number of skbs neede by the adapter */
+
+        rwlock_t 		isolate_lock;
+
+        int			driver_isolated;
+        char			*cable_status;
+        void			*regp;
+        u8			macAdr[8];
+        u8			mcastAdr[8];
+        u32			intrMask;
+        zd1205_SwTcbQ_t 	*freeTxQ;
+        zd1205_SwTcbQ_t 	*activeTxQ;
+        u32  		        txCachedSize;
+        u8			*txCached;
+        u16			dtimCount;
+        u8			numTcb;
+        u16			numTbd;
+        u8			numRfd;
+        u8			numTbdPerTcb;
+        u32			rxOffset;
+        u32 			debugflag;
+        card_Setting_t		cardSetting;
+        u8			BSSID[8];
+        u32			dbg_flag;
+
+        //debug counter
+        u32			bcnCnt;
+        u32			dtimCnt;
+        u32			txCmpCnt;
+        u32			rxCnt;
+        u32			retryFailCnt;
+        u32			txCnt;
+        u32			txIdleCnt;
+        u32			rxIdleCnt;
+        u32 			rxDupCnt;
+
+        u32			DriverDiscardedFrmCauseByMulticastList;
+        u32			DriverDiscardedFrmCauseByFrmCtrl;
+        u32			DriverReceivedFrm;
+        u32			DriverRxMgtFrmCnt;
+        u32			ErrLongFrmCnt;
+        u32			ErrShortFrmCnt;
+
+        u32			ErrToHostFrmCnt;
+        u32			ErrZeroLenFrmCnt;
+        u32			ArFreeFailCnt;
+        u32			ArSearchFailCnt;
+        u32			ArAgedCnt;
+
+        u32			DropFirstFragCnt;
+        u32			rxNeedFragCnt;
+        u32			rxCompFragCnt;
+        u32			AllocSkbFailCnt;
+        u32			txQueToUpCnt;
+        u32			txQueSetCnt;
+        u32			sleepCnt;
+        u32			wakeupCnt;
+
+        //HMAC counter
+        u32			hwTotalRxFrm;
+        u32			hwCRC32Cnt;
+        u32			hwCRC16Cnt;
+        u32			hwDecrypErr_UNI;
+        u32			hwDecrypErr_Mul;
+        u32			hwRxFIFOOverrun;
+        u32			hwTotalTxFrm;
+        u32			hwUnderrunCnt;
+
+        u32			hwRetryCnt;
+        u32			TxStartTime;
+        u32			HMAC_TxTimeout;
+
+        u8			bTraceSetPoint;
+        u8			bEnableTxPwrCtrl;
+        u8			TxOFDMCnt;
+        u8			TxOFDMType;
+        u8			TxPwrCCK;
+        u8			TxPwrOFDM;          // 6M - 36M
+        u8			bFixedRate;
+        u8			bDataTrafficLight;
+        u8			NoBcnDetectedCnt;
+        u8			LinkTimer;
+        u32			LinkLEDn;
+        u32			LinkLED_OnDur;
+        u32			LinkLED_OffDur;
+        u32			DataLED;
+
+        u16			AddrEntryTable;
+        u8			bAllowAccessRegister;
+        U8			FlashType;
+        u16			ReadRegCount;
+        u16			SetPoint;
+        u8			dtim_notify_en;
+        u8			config_next_bcn_en;
+
+        u32			invalid_frame_good_crc;
+        u8			bGkInstalled;
+        u8			rxSignalQuality;
+
+        u8			rxSignalStrength;
+        u8			rxSignalQualityIndB;
+        u8			rxSignalQuality1;
+        u8			rxSignalQuality2;
+        u16			EepSetPoint[14];
+        u16              	SetPointOFDM[3][14];//JWEI 2003/12/31
+        u32			RegionCode;
+        u32			RF_Mode;
+        u8			PA_Type;
+        u8			MaxTxPwrSet;
+        u8			MinTxPwrSet;
+        u8			bss_index;
+        bss_info_t 		BSSInfo[BSS_INFO_NUM];
+        tuple_Cache_t 		cache;
+
+        defrag_Array_t 		defragArray;
+        rxInfo_t 		rxInfo;
+
+        //added for STA
+        atomic_t		DoNotSleep;
+        u8			bSurpriseRemoved;
+        u8			bAssoc;
+        u8			PwrState;
+        u8			SuggestionMode;
+        u8			bPSMSupported;
+        u8			bAPAlive;
+        u8			BSS_Members;
+        u8			Notification;
+        u8			WorseSQThr;
+        u8			bIBSS_Wakeup_Dest;
+        u8			bFrmRxed1;
+        u8			bAnyActivity;
+        u8			NiceSQThr;
+        u8               	NiceSQThr_OFDM;
+        u8			bEnableSwAntennaDiv;
+        u8			Ant_MonitorDur1;
+        u8			Ant_MonitorDur2;
+        u8			CR138Flag;
+        u8   			MulticastAddr[194]; // the first byte is the number of multicast addresses
+        u32			TotalTxDataFrmBytes;
+
+        u32			TotalRxDataFrmBytes;
+        u32			txMulticastFrm;
+        u32			txMulticastOctets;
+        u32			txUnicastFrm;
+        u32			txUnicastOctets;
+        u32			NormalBackoff;
+        u32			UrgentBackoff;
+        u32			LooseBackoff;
+        u32			Acc_Num_OFDM;
+        u32			Acc_SQ_OFDM;
+        u32			Bcn_Acc_Num;
+        u32			Bcn_Acc_SQ;
+        u32			CheckForHangLoop;
+        u16			SequenceNum;
+        u16			iv16;
+        u32			iv32;
+        u32			Acc_Num;
+        u32			Acc_SQ;
+        u32			GroupHashP1;
+        u32			GroupHashP2;
+        u32			PSThreshhold;
+        u8			rxDecryType;
+        u32  			rx11bDataFrame;
+        u32  			rxOFDMDataFrame;
+
+#ifdef OFDM
+
+        u8			bTxBurstEnable;
+        int			TxBurstCount;
+#endif
+
+#ifdef HOST_IF_USB
+
+        u32			USBCSRAddress;
+        u8			bUSBDeveiceAttached;
+        u8			bUSBDeveiceResetting;
+        u8			bHandleNonRxTxRunning;
+        u32			REG_6e4_Add;
+        u32 			Continue2Rx;
+        u8			LastZDContinuousTxRate;
+        u32			WaitLenInfoCnt;
+        u32			CompLenInfoCnt;
+        u32			NoMergedRxCnt;
+        u8			bFlashable;
+#endif
+
+        u8			bDisableTx;
+        u8			PHYSettingFlag;
+        u8			PHYTestIndex;
+        u8			PHYTestTimer;
+        u8			PHYTestTimerCount;
+        u8			PHYTestRssiBound;
+        u8			PHYTestRssi;
+        u8			PHYLowPower;
+        u8			IPCFlag;
+        u8			AdapterMaxRate;
+
+        u8			PHYFreOFDMframe;
+        u8			EnableTxPwrCtrl;
+
+        u32			PHYTestTotal;
+        u32			TrafficBound;
+        u32			DriverRxFrmCnt;
+        u64			rxDataPerSec;
+        u64			txDataPerSec;
+
+        u32			txUnCachedSize;
+        dma_addr_t		txUnCachedPhys;
+        void			*txUnCached;
+        //Modified for Supplicant
+        int			bDefaultIbssMacMode;
+        u32	bOLBC;
+        u32	nOLBC_CounterInSec;
+
+};
+
+typedef struct zd1205_private	zd1205_private_t;
+
+
+struct usb_eth_dev
+{
+        char	*name;
+        __u16	vendor;
+
+        __u16	device;
+        __u32	private; /* LSB is gpio reset value */
+};
+
+#define ZD_IOCTL_REG_READ			0x01
+#define ZD_IOCTL_REG_WRITE			0x02
+#define ZD_IOCTL_MEM_DUMP			0x03
+#define ZD_IOCTL_RATE       			0x04
+#define ZD_IOCTL_SNIFFER    			0x05
+#define ZD_IOCTL_CAM_DUMP   			0x06
+#define ZD_IOCTL_DUMP_PHY   			0x07
+#define ZD_IOCTL_CARD_SETTING 			0x08
+#define ZD_IOCTL_HASH_DUMP			0x09
+#define ZD_IOCTL_RFD_DUMP			0x0A
+#define ZD_IOCTL_MEM_READ			0x0B
+#define ZD_IOCTL_MEM_WRITE			0x0C
+
+//for STA
+#define ZD_IOCTL_TX_RATE			0x0D
+#define ZD_IOCTL_EEPROM				0x0E
+
+//for debug purposes
+#define ZD_IOCTL_BCN				0x10
+#define ZD_IOCTL_REG_READ16			0x11
+#define ZD_IOCTL_REG_WRITE16			0x12
+
+//for CAM Test
+#define	ZD_IOCTL_CAM_READ			0x13
+#define ZD_IOCTL_CAM_WRITE			0x14
+#define ZD_IOCTL_CAM_RESET			0x15
+#define ZD_IOCTL_READ_PHY			0x16
+#define ZD_IOCTL_WRITE_PHY			0x17
+#define ZD_IOCTL_CONT_TX			0x18
+#define ZD_IOCTL_SET_MIC_CNT_ENABLE 0x19
+#define ZD_IOCTL_GET_MIC_CNT_ENABLE 0x1A
+#define ZD_IOCTL_DEBUG_FLAG	0x21
+
+#define	ZDAPIOCTL	SIOCDEVPRIVATE
+
+
+/**************************************************************************
+**		Function Declarations
+***************************************************************************
+*/
+void zd1205_sleep_reset(struct zd1205_private *macp);
+void update_beacon_interval(struct zd1205_private *macp, int val);
+void zd1205_sw_reset(struct zd1205_private *macp);
+void zd1205_watchdog_cb(struct net_device *);
+void zd1205_dump_data(char *info, u8 *data, u32 data_len);
+void zd1205_init_card_setting(struct zd1205_private *macp);
+/* ath: loading/saving files from kernel is a hack */
+//void zd1205_load_card_setting(struct zd1205_private *macp, u8 bInit);
+//void zd1205_save_card_setting(struct zd1205_private *macp);
+zd1205_SwTcb_t * zd1205_first_txq(struct zd1205_private *macp, zd1205_SwTcbQ_t *Q);
+/* ath: gcc4 needs inline function bodies in the declaration */
+u32 zd_readl(u32 offset);
+void zd_writel(u32 value, u32 offset);
+void zd1205_disable_int(void);
+void zd1205_enable_int(void);
+void zd1205_lock(struct zd1205_private *macp);
+void zd1205_unlock(struct zd1205_private *macp);
+void zd1205_device_reset(struct zd1205_private *macp);
+void zd1205_config_wep_keys(struct zd1205_private *macp);
+void zd1205_config_dyn_key(u8 DynKeyMode, u8 *pkey, int idx);
+struct sk_buff* zd1205_prepare_tx_data(struct zd1205_private *macp, u16 bodyLen);
+void zd1205_tx_test(struct zd1205_private *macp, u16 size);
+void zd1205_qlast_txq(struct zd1205_private *macp, zd1205_SwTcbQ_t *Q, zd1205_SwTcb_t *signal);
+int zd1205_DestPowerSave(struct zd1205_private *macp, u8 *pDestAddr);
+int zd1205_found1(struct pci_dev *pcid, const struct pci_device_id *ent);
+void zd1205_remove1(struct pci_dev *pcid);
+BOOLEAN a_OSC_get_cal_int( u8 ch, u32 rate, u8 *intValue, u8 *calValue);
+void zd1205_tx_isr(struct zd1205_private *);
+u32 zd1205_rx_isr(struct zd1205_private *macp);
+void  zd1205_clear_structs(struct net_device *dev);
+unsigned char zd1205_init(struct zd1205_private *);
+int zd1205_open(struct net_device *);
+int zd1205_close(struct net_device *);
+int zd1205_change_mtu(struct net_device *, int);
+int zd1205_set_mac(struct net_device *, void *);
+void zd1205_set_multi(struct net_device *);
+void zd1205_IncreaseTxPower(struct zd1205_private *macp, u8 TxPwrType);
+void zd1205_DecreaseTxPower(struct zd1205_private *macp, u8 TxPwrType);
+void iLED_ON(struct zd1205_private *macp, u32 LEDn);
+void iLED_OFF(struct zd1205_private *macp, u32 LEDn);
+void iLED_SWITCH(struct zd1205_private *macp, u32 LEDn);
+void HKeepingCB(struct net_device *dev);
+void zd1205_mgt_mon_cb(struct net_device *dev);
+int zd1205_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
+int zd1205_xmit_frame(struct sk_buff *skb, struct net_device *dev);
+struct net_device_stats *zd1205_get_stats(struct net_device *);
+void hostap_michael_mic_failure(struct zd1205_private *macp,
+                                struct hostap_ieee80211_hdr *hdr, int keyidx);
+#ifndef HOST_IF_USB
+
+void zd1205_start_ru(struct zd1205_private *);
+#else
+
+struct rx_list_elem *zd1205_start_ru(struct zd1205_private *);
+#endif
+void zd1205_process_wakeup(struct zd1205_private *macp);
+void zd1205_connect_mon(struct zd1205_private *macp);
+
+void zd1205_watchdog(struct zd1205_private *macp);
+void zd1205_house_keeping(struct zd1205_private *macp);
+void zd1211_set_multicast(struct zd1205_private *macp);
+int zd1205_dis_connect(struct zd1205_private *macp);
+void ChangeMacMode(u8 MAC_Mode, u8 Channel);
+void zd1205_alloc_skbs(struct zd1205_private *macp);
+const int zd1211_mlme(struct zd1205_private *macp);
+#if ZDCONF_WE_STAT_SUPPORT == 1
+
+struct iw_statistics * zd1205_iw_getstats(struct net_device *dev);
+#elif !defined(ZDCONF_WE_STAT_SUPPORT)
+	#error "Undefine ZDCONF_WE_STAT_SUPPORT"
+#endif
+#endif	/* _ZD1205_H_ */
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zd1205_proc.c linux-2.4.35.3-mct/drivers/usb/zd1211/zd1205_proc.c
--- linux-2.4.35.3/drivers/usb/zd1211/zd1205_proc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zd1205_proc.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,379 @@
+/* src/zd1205_proc.c
+*
+*
+*
+* Copyright (C) 2004 ZyDAS Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+*
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* -------------------------------------------------------------------- */
+
+#include <linux/config.h>
+
+#ifdef CONFIG_PROC_FS
+#include "zd1205.h"
+
+/***************************************************************************/
+/*       /proc File System Interaface Support Functions                    */
+/***************************************************************************/
+
+static struct proc_dir_entry *adapters_proc_dir = 0;
+
+/* externs from zd1205.c */
+extern char zd1205_short_driver_name[];
+extern char zd1205_driver_version[];
+extern struct net_device_stats *zd1205_get_stats(struct net_device *dev);
+
+
+static void zd1205_proc_cleanup(void);
+static unsigned char zd1205_init_proc_dir(void);
+
+#define ADAPTERS_PROC_DIR   "zd1205"
+#define WRITE_BUF_MAX_LEN   20
+#define READ_BUF_MAX_LEN    256
+#define ZD1205_PE_LEN       25
+
+#define bdp_drv_off(off) (unsigned long)(offsetof(struct zd1205_private, drv_stats.off))
+#define bdp_prm_off(off) (unsigned long)(offsetof(struct zd1205_private, params.off))
+
+typedef struct _zd1205_proc_entry
+{
+        char *name;
+        read_proc_t *read_proc;
+        write_proc_t *write_proc;
+
+        unsigned long offset;	/* offset into bdp. ~0 means no value, pass NULL. */
+}
+zd1205_proc_entry;
+
+
+static int
+generic_read(char *page, char **start, off_t off, int count, int *eof, int len)
+{
+        if (len <= off + count)
+                *eof = 1;
+
+        *start = page + off;
+        len -= off;
+        if (len > count)
+                len = count;
+
+        if (len < 0)
+                len = 0;
+
+        return len;
+}
+
+#if 0
+static int
+read_ulong(char *page, char **start, off_t off,
+           int count, int *eof, unsigned long l)
+{
+        int len;
+
+        len = sprintf(page, "%lu\n", l);
+
+        return generic_read(page, start, off, count, eof, len);
+}
+
+static int
+read_gen_ulong(char *page, char **start, off_t off,
+
+               int count, int *eof, void *data)
+{
+        unsigned long val = 0;
+
+        if (data)
+                val = *((unsigned long *) data);
+
+        return read_ulong(page, start, off, count, eof, val);
+}
+#endif
+
+static int
+read_hwaddr(char *page, char **start, off_t off,
+            int count, int *eof, unsigned char *hwaddr)
+{
+        int len;
+
+        len = sprintf(page, "%02X:%02X:%02X:%02X:%02X:%02X\n",
+                      hwaddr[0], hwaddr[1], hwaddr[2],
+                      hwaddr[3], hwaddr[4], hwaddr[5]);
+
+        return generic_read(page, start, off, count, eof, len);
+}
+
+
+static int
+read_permanent_hwaddr(char *page, char **start, off_t off,
+                      int count, int *eof, void *data)
+{
+        struct zd1205_private *macp = data;
+        unsigned char *hwaddr = macp->macAdr;
+
+        return read_hwaddr(page, start, off, count, eof, hwaddr);
+}
+
+
+static zd1205_proc_entry zd1205_proc_list[] = {
+                        {"Permanent_HWaddr",      read_permanent_hwaddr, 0, 0},
+                        {"\n",},
+                        {"", 0, 0, 0}
+                };
+
+
+static int
+read_info(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+
+        struct zd1205_private *macp = data;
+        zd1205_proc_entry *pe;
+        int tmp;
+        void *val;
+        int len = 0;
+
+        for (pe = zd1205_proc_list; pe->name[0]; pe++) {
+                if (pe->name[0] == '\n') {
+                        len += sprintf(page + len, "\n");
+                        continue;
+                }
+
+                if (pe->read_proc) {
+                        if ((len + READ_BUF_MAX_LEN + ZD1205_PE_LEN + 1) >=
+                                        PAGE_SIZE)
+                                break;
+
+                        if (pe->offset != ~0)
+                                val = ((char *) macp) + pe->offset;
+                        else
+                                val = NULL;
+
+                        len += sprintf(page + len, "%-"
+                                       __MODULE_STRING(ZD1205_PE_LEN)
+                                       "s ", pe->name);
+                        len += pe->read_proc(page + len, start, 0,
+                                             READ_BUF_MAX_LEN + 1, &tmp, val);
+                }
+        }
+
+        return generic_read(page, start, off, count, eof, len);
+}
+
+
+static struct proc_dir_entry *
+                        create_proc_rw(char *name, void *data, struct proc_dir_entry *parent,
+                                       read_proc_t * read_proc, write_proc_t * write_proc)
+{
+        struct proc_dir_entry *pdep;
+        mode_t mode = S_IFREG;
+
+        if (write_proc)
+        {
+                mode |= S_IWUSR;
+                if (read_proc) {
+                        mode |= S_IRUSR;
+                }
+
+        } else if (read_proc)
+        {
+                mode |= S_IRUGO;
+        }
+
+        if (!(pdep = create_proc_entry(name, mode, parent)))
+                return NULL;
+
+        pdep->read_proc = read_proc;
+        pdep->write_proc = write_proc;
+        pdep->data = data;
+        return pdep;
+}
+
+
+void
+zd1205_remove_proc_subdir(struct zd1205_private *macp, char *name)
+{
+        zd1205_proc_entry *pe;
+        char info[256];
+        int len;
+
+        /* If our root /proc dir was not created, there is nothing to remove */
+        if (adapters_proc_dir == NULL)
+        {
+                return;
+        }
+
+        len = strlen(macp->ifname);
+        strncpy(info, macp->ifname, sizeof (info));
+        strncat(info + len, ".info", sizeof (info) - len);
+
+        if (macp->proc_parent)
+        {
+                for (pe = zd1205_proc_list; pe->name[0]; pe++) {
+                        if (pe->name[0] == '\n')
+                                continue;
+
+                        remove_proc_entry(pe->name, macp->proc_parent);
+                }
+
+                remove_proc_entry(macp->ifname, adapters_proc_dir);
+                macp->proc_parent = NULL;
+        }
+
+        remove_proc_entry(info, adapters_proc_dir);
+
+        /* try to remove the main /proc dir, if it's empty */
+        zd1205_proc_cleanup();
+}
+
+
+int
+zd1205_create_proc_subdir(struct zd1205_private *macp)
+{
+        struct proc_dir_entry *dev_dir;
+        zd1205_proc_entry *pe;
+        char info[256];
+        int len;
+        void *data;
+
+        /* create the main /proc dir if needed */
+        if (!adapters_proc_dir)
+        {
+                if (!zd1205_init_proc_dir())
+                        return -ENOMEM;
+        }
+
+        strncpy(info, macp->ifname, sizeof (info));
+        len = strlen(info);
+        strncat(info + len, ".info", sizeof (info) - len);
+
+        /* info */
+        if (!(create_proc_rw(info, macp, adapters_proc_dir, read_info, 0)))
+        {
+                zd1205_proc_cleanup();
+                return -ENOMEM;
+        }
+
+        dev_dir = create_proc_entry(macp->ifname, S_IFDIR,
+                                    adapters_proc_dir);
+        macp->proc_parent = dev_dir;
+
+        if (!dev_dir)
+        {
+                zd1205_remove_proc_subdir(macp, macp->ifname);
+                return -ENOMEM;
+        }
+
+        for (pe = zd1205_proc_list; pe->name[0]; pe++)
+        {
+                if (pe->name[0] == '\n')
+                        continue;
+
+                if (pe->offset != ~0)
+                        data = ((char *) macp) + pe->offset;
+                else
+                        data = NULL;
+
+                if (!(create_proc_rw(pe->name, data, dev_dir,
+                                     pe->read_proc, pe->write_proc))) {
+                        zd1205_remove_proc_subdir(macp, macp->ifname);
+                        return -ENOMEM;
+                }
+        }
+
+        return 0;
+}
+
+/****************************************************************************
+ * Name:          zd1205_init_proc_dir
+ *
+ * Description:   This routine creates the top-level /proc directory for the
+ *                driver in /proc/net
+ *
+ * Arguments:     none
+ *
+ * Returns:       true on success, false on fail
+ *
+ ***************************************************************************/
+static unsigned char
+zd1205_init_proc_dir(void)
+{
+        int len;
+
+        /* first check if adapters_proc_dir already exists */
+        len = strlen(ADAPTERS_PROC_DIR);
+        for (adapters_proc_dir = proc_net->subdir;
+                        adapters_proc_dir; adapters_proc_dir = adapters_proc_dir->next) {
+
+                if ((adapters_proc_dir->namelen == len) &&
+                                (!memcmp(adapters_proc_dir->name, ADAPTERS_PROC_DIR, len)))
+                        break;
+        }
+
+        if (!adapters_proc_dir)
+                adapters_proc_dir =
+                        create_proc_entry(ADAPTERS_PROC_DIR, S_IFDIR, proc_net);
+
+        if (!adapters_proc_dir)
+                return false;
+
+        return true;
+}
+
+
+/****************************************************************************
+ * Name:          zd1205_proc_cleanup
+ *
+ * Description:   This routine clears the top-level /proc directory, if empty.
+ *
+ * Arguments:     none
+ *
+ * Returns:       none
+ *
+ ***************************************************************************/
+static void
+zd1205_proc_cleanup(void)
+{
+        struct proc_dir_entry *de;
+
+        if (adapters_proc_dir == NULL) {
+                return;
+        }
+
+        /* check if subdir list is empty before removing adapters_proc_dir */
+        for (de = adapters_proc_dir->subdir; de; de = de->next) {
+                /* ignore . and .. */
+                if (*(de->name) != '.')
+                        break;
+        }
+
+        if (de)
+                return;
+
+        remove_proc_entry(ADAPTERS_PROC_DIR, proc_net);
+        adapters_proc_dir = NULL;
+}
+
+#endif /* CONFIG_PROC_FS */
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zd1211.c linux-2.4.35.3-mct/drivers/usb/zd1211/zd1211.c
--- linux-2.4.35.3/drivers/usb/zd1211/zd1211.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zd1211.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,3427 @@
+/* src/zd1211.c
+*
+*                                            
+*
+* Copyright (C) 2004 ZyDAS Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+*
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* -------------------------------------------------------------------- */
+
+#include <linux/config.h>
+#include <net/checksum.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+
+
+#include "zddebug.h"
+#include "zdhw.h"
+#include "zd1211.h"
+#include "zdcompat.h"
+
+u8 WS11UPh[]
+#if fMERGE_RX_FRAME
+	#include "WS11UPhR.h"
+u8 WS11UPhm[]
+#include "WS11UPhm.h"
+#else
+    #include "WS11UPhm.h"
+#endif
+
+u8 WS11Ur[]
+#include "WS11Ur.h"
+
+u8 WS11Ub[]
+#include "WS11Ub.h"
+
+
+u8 WS11Ur2[(0xEE00 - 0xEC00) * 2] = { 0x0F, 0x9F, 0x00, 0xEE };  // JMP 0xEE00
+
+
+extern zd_80211Obj_t dot11Obj;
+extern struct net_device *g_dev;
+
+/* ath_desc: use usb_kill_urb() instead of usb_unlink_urb() in 2.6.8+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,8)
+#  define ZD_USB_KILL_URB(u)       usb_kill_urb(u)
+#else
+#  define ZD_USB_KILL_URB(u)       usb_unlink_urb(u)
+#endif
+
+/* ath_desc: URB_ASYNC_UNLINK has been removed in Linux 2.6.14 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
+#  define URB_ASYNC_UNLINK 0
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) /* tune me! */
+#  define SUBMIT_URB(u,f)       usb_submit_urb(u,f)
+#  define USB_ALLOC_URB(u,f)    usb_alloc_urb(u,f)
+#else
+#  define SUBMIT_URB(u,f)       usb_submit_urb(u)
+#  define USB_ALLOC_URB(u,f)    usb_alloc_urb(u)
+#endif
+
+
+inline void zd1211_DumpErrorCode(struct zd1205_private *macp, int err)
+{
+        switch (err)
+        {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+        case USB_ST_CRC:
+                ZD1211DEBUG(0, "USB_ST_CRC\n");
+                break;
+
+                //case USB_ST_BITSTUFF:
+                //ZD1211DEBUG(0, "USB_ST_BITSTUFF\n");
+                //break;
+
+                //case USB_ST_NORESPONSE:
+                //ZD1211DEBUG(0, "USB_ST_NORESPONSE\n");
+                //break;
+
+        case USB_ST_DATAOVERRUN:
+                ZD1211DEBUG(0, "USB_ST_DATAOVERRUN\n");
+                break;
+
+        case USB_ST_DATAUNDERRUN:
+                ZD1211DEBUG(0, "USB_ST_DATAUNDERRUN\n");
+                break;
+
+        case USB_ST_BUFFEROVERRUN:
+                ZD1211DEBUG(0, "USB_ST_BUFFEROVERRUN\n");
+                break;
+
+        case USB_ST_BUFFERUNDERRUN:
+                ZD1211DEBUG(0, "USB_ST_BUFFERUNDERRUN\n");
+                break;
+
+        case USB_ST_INTERNALERROR:
+                ZD1211DEBUG(0, "USB_ST_INTERNALERROR\n");
+                break;
+
+                //case USB_ST_SHORT_PACKET:
+                //ZD1211DEBUG(0, "USB_ST_SHORT_PACKET\n");
+                //break;
+
+        case USB_ST_PARTIAL_ERROR:
+                ZD1211DEBUG(0, "USB_ST_PARTIAL_ERROR\n");
+                break;
+
+        case USB_ST_URB_KILLED:
+                ZD1211DEBUG(0, "USB_ST_URB_KILLED\n");
+                break;
+
+        case USB_ST_URB_PENDING:
+                ZD1211DEBUG(0, "USB_ST_URB_PENDING\n");
+                break;
+
+        case USB_ST_REMOVED:
+                ZD1211DEBUG(0, "USB_ST_REMOVED\n");
+                break;
+
+        case USB_ST_TIMEOUT:
+                ZD1211DEBUG(0, "USB_ST_TIMEOUT\n");
+                break;
+
+        case USB_ST_NOTSUPPORTED:
+                ZD1211DEBUG(0, "USB_ST_NOTSUPPORTED\n");
+                break;
+
+
+
+
+
+        case USB_ST_BANDWIDTH_ERROR:
+                ZD1211DEBUG(0, "USB_ST_BANDWIDTH_ERROR\n");
+                break;
+
+        case USB_ST_URB_INVALID_ERROR:
+                ZD1211DEBUG(0, "USB_ST_URB_INVALID_ERROR\n");
+                break;
+
+        case USB_ST_URB_REQUEST_ERROR:
+                ZD1211DEBUG(0, "USB_ST_URB_REQUEST_ERROR\n");
+                break;
+
+        case USB_ST_STALL:
+                ZD1211DEBUG(0, "USB_ST_STALL\n");
+                break;
+
+        case -ENOMEM:
+                ZD1211DEBUG(0, "ENOMEM\n");
+                break;
+#endif
+
+        default:
+                ZD1211DEBUG(0, "USB ST Code = %d\n",err);
+
+                break;
+        }
+        /* ath_desc: reenable iwpriv dbg_flag */
+        /* ath_old: macp->dbg_flag=0; */
+        /* do not reset dbg_flag on USB error */
+
+}
+
+
+void zd1211_DumpReadMultipleReg(struct zd1205_private *macp, u16 adr0)
+{
+        u16  ReadAddr[cMAX_MULTI_READ_REG_NUM];
+        u16  ReadData[cMAX_MULTI_READ_REG_NUM];
+        u16  ReadIndex = 0;
+
+        FPRINT_V("adr0", adr0);
+
+        for (ReadIndex = 0; ReadIndex < cMAX_MULTI_READ_REG_NUM;)
+
+
+
+                mFILL_READ_REGISTER(adr0++);
+
+        zd1211_USB_PACKAGE_READ_REGISTER(ReadAddr, ReadData, ReadIndex, false);
+
+        for (ReadIndex = 0; ReadIndex < 8; ReadIndex ++)
+                printk("%04X, ", ReadData[ReadIndex]);
+
+        printk("\n");
+        printk("      ");
+
+        for (; ReadIndex < cMAX_MULTI_READ_REG_NUM; ReadIndex ++)
+                printk("%04X, ", ReadData[ReadIndex]);
+        printk("\n");
+}
+
+
+
+// len0: in word, adr: word offset
+void zd1211_WriteEEPROM(struct zd1205_private *macp, u16 rom_adr, u16 ram_adr, u16 len0)
+{
+        u32  tmpvalue;
+        u16  WriteAddr[cMAX_MULTI_WRITE_REG_NUM];
+        u16  WriteData[cMAX_MULTI_WRITE_REG_NUM];
+        u16  WriteIndex = 0;
+
+        tmpvalue = zd1211_readl(ZD1211_CLOCK_CTRL, false);
+        mFILL_WRITE_REGISTER(ZD1211_CLOCK_CTRL, mSET_BIT((u16) tmpvalue, bZD1211_CLOCK_EEPROM));
+        mFILL_WRITE_REGISTER(UMAC_EPROM_ROM_ADDR, rom_adr);
+        mFILL_WRITE_REGISTER(UMAC_EPROM_RAM_ADDR, ram_adr);
+        mFILL_WRITE_REGISTER(UMAC_EPROM_DMA_LEN_DIR, bmEPROM_XFER_DIR | len0);
+        mFILL_WRITE_REGISTER(ZD1211_CLOCK_CTRL, mCLR_BIT((u16) tmpvalue, bZD1211_CLOCK_EEPROM));
+        zd1211_WriteMultiRegister(WriteAddr, WriteData, WriteIndex, false);
+}
+
+
+#if fMERGE_RX_FRAME
+int zd1211_ChangeToFlashAble(struct zd1205_private *macp)
+{
+        u32 tmpvalue;
+
+        if (!macp->bFlashable)
+        {
+                int	LoadRet;
+
+                zd_writel(0x01, FW_SOFT_RESET);
+
+                macp->bDisableTx = 1;
+                //USB_StopTxEP(macp);
+
+                macp->bAllowAccessRegister = 0;
+
+                LoadRet = zd1211_LoadUSBSpecCode(macp, WS11UPhm, sizeof(WS11UPhm),
+                                                 cFIRMWARE_START_ADDR, true);
+                if (LoadRet) {
+                        FPRINT("Load WS11UPhm fail");
+                        return 1;
+                }
+
+                ZD1211DEBUG(0, "Load WS11UPhm Done\n");
+
+                //macp->bAllowAccessRegister = 1;
+                macp->bFlashable = 1;
+
+#if fWRITE_WORD_REG || fREAD_MUL_REG
+                // Must get this information before any register write
+                tmpvalue = zd1211_readl(cADDR_ENTRY_TABLE, FALSE);
+                macp->AddrEntryTable = (u16) tmpvalue;
+#endif
+
+        }
+
+        return 0;
+}
+#endif
+
+
+int zd1211_UpdateBootCode(struct zd1205_private *macp, u16 *pCheckSum, u16 *pEEPROMData,
+                          u32 EEPROMLen)
+{
+        u32 i;
+        //int ret;
+        u16  WriteAddr[cMAX_MULTI_WRITE_REG_NUM];
+        u16  WriteData[cMAX_MULTI_WRITE_REG_NUM];
+        u16  WriteIndex = 0;
+        u16  ROMBufAdr = cBOOTCODE_START_ADDR;
+
+        ZD1211DEBUG(0, "UpdateBootCode\n");
+
+        for (i=0; i<EEPROMLen; i+=(2*WRITE_WORD_TO_EEPROM_PER_TIME))
+        {
+                for (WriteIndex=0; WriteIndex<WRITE_WORD_TO_EEPROM_PER_TIME/2; ) {
+                        u16 WriteValue;
+                        if (ROMBufAdr >= cINT_VECT_ADDR) {
+                                FPRINT("Exceed max address");
+                                break;
+                        }
+                        /* ath: fixed ambiguous statement */
+                        WriteValue = pEEPROMData[WriteIndex * 2] | (pEEPROMData[WriteIndex * 2 + 1] << 8);
+                        mFILL_WRITE_REGISTER(ROMBufAdr ++, WriteValue);
+                }
+
+                if (WriteIndex)
+                        zd1211_WriteMultiRegister(WriteAddr, WriteData, WriteIndex, false);
+
+                if (ROMBufAdr >= cINT_VECT_ADDR) {
+                        FPRINT("Exceed max address1");
+                        return 0;
+                }
+
+                pEEPROMData += WRITE_WORD_TO_EEPROM_PER_TIME;
+        }
+
+        if (EEPROMLen % (2*WRITE_WORD_TO_EEPROM_PER_TIME))
+        {
+                for (WriteIndex = 0; WriteIndex < (EEPROMLen % (2 * WRITE_WORD_TO_EEPROM_PER_TIME)) / 2;) {
+                        u16 WriteValue;
+                        if (ROMBufAdr >= cINT_VECT_ADDR) {
+                                FPRINT("Exceed max address2");
+                                break;
+                        }
+                        /* ath: fixed ambiguous statement */
+                        WriteValue = pEEPROMData[WriteIndex * 2] | (pEEPROMData[WriteIndex * 2 + 1] << 8);
+                        mFILL_WRITE_REGISTER(ROMBufAdr ++, WriteValue);
+                                             
+                }
+
+                if (WriteIndex)
+                        zd1211_WriteMultiRegister(WriteAddr, WriteData, WriteIndex, false);
+        }
+
+        return 0;
+}
+
+
+
+
+int zd1211_USB_Write_EEPROM(struct zd1205_private *macp, u16 *pEEPROMData, u32 EEPROMLen) //in bytes
+{
+        u16 CheckSum = 0;
+        int ret;
+
+        ZD1211DEBUG(0, "USB_Write_EEPROM\n");
+
+        macp->bDisableTx = 1;
+
+        //USB_StopTxEP(macp);
+
+        ret = zd1211_UpdateBootCode(macp, &CheckSum, pEEPROMData, EEPROMLen);
+        if (ret != 0)
+                return ret;
+
+        zd1211_WriteEEPROM(macp, 0, cBOOTCODE_START_ADDR, cEEPROM_SIZE - cLOAD_VECT_LEN);
+        //macp->bDisableTx = 0;
+
+        return 0;
+
+}
+
+
+
+int zd1211_USB_WRITE_EEPROM_DATA(struct zd1205_private *macp, PUSB_EEPROM_DATA	pData, int DataLen)
+{
+        int ret;
+        u8 *pBuffer;
+        //int memflags = GFP_KERNEL;
+
+        ZD1211DEBUG(0, "USB_WRITE_EEPROM_DATA\n");
+
+        if (!macp->bUSBDeveiceAttached)
+        {
+                return 1;
+        }
+
+        down(&macp->reg_sem);
+
+        pBuffer = kmalloc(DataLen, GFP_KERNEL);
+
+        if (!pBuffer)
+        {
+                up(&macp->reg_sem);
+                return -ENOMEM;
+        } else
+                memcpy(pBuffer, (u8 *)pData, DataLen);
+
+        if (macp->ep4isIntOut)
+                usb_fill_int_urb(macp->reg_urb, macp->usb,
+                                 usb_sndintpipe(macp->usb, EP_REG_OUT),
+                                 pBuffer, DataLen,
+                                 zd1211_reg_cb, macp, 1);
+        else
+                usb_fill_bulk_urb(macp->reg_urb, macp->usb,
+                                  usb_sndbulkpipe(macp->usb, EP_REG_OUT),
+                                  pBuffer, DataLen,
+                                  zd1211_reg_cb, macp);
+
+        macp->reg_urb->transfer_flags |= URB_ASYNC_UNLINK;
+
+        if ((ret = SUBMIT_URB(macp->reg_urb, GFP_ATOMIC)))
+        {
+                printk(KERN_ERR "zd1211: failed reg_urb\n");
+                zd1211_DumpErrorCode(macp, ret);
+                goto out;
+        }
+
+        wait_event(macp->regSet_wait, test_bit(ZD1211_CMD_FINISH, &macp->flags));
+        clear_bit(ZD1211_CMD_FINISH, &macp->flags);
+
+out:
+        kfree(pBuffer);
+        up(&macp->reg_sem);
+        return ret;
+}
+
+#if fPROG_FLASH_BY_FW
+int zd1211_USB_ProgramFlash(struct zd1205_private *macp, u16 *Value, u16 RegCount)
+{
+        u8 *pRegBuffer = NULL;
+
+        int ret;
+        u16 size = sizeof(USB_WRITE_REG);
+
+        u16 bufSize;
+        int ii;
+
+        ZD1211DEBUG(0, "USB_ProgramFlash\n");
+
+        if ((RegCount == 0) || (!macp->bUSBDeveiceAttached))
+                return 0;
+
+        down(&macp->reg_sem);
+        pRegBuffer = kmalloc(size, GFP_KERNEL);
+
+        if (!pRegBuffer)
+        {
+                up(&macp->reg_sem);
+                return -ENOMEM;
+        } else
+                memset(pRegBuffer, 0x0, size);
+
+        /* ath_desc: bigendian support */
+        ((PUSB_WRITE_REG)pRegBuffer)->RequestID = cpu_to_le16(REGID_PROG_FLSH);
+        ((PUSB_SET_RF) pRegBuffer)->Value       = cpu_to_le16(Value[0]);
+        ((PUSB_SET_RF) pRegBuffer)->Index       = cpu_to_le16(Value[1]);
+
+        for (ii = 2; ii < RegCount; ii ++)
+                ((PUSB_SET_RF)pRegBuffer)->Data[ii - 2] = cpu_to_le16(Value[ii]);
+
+        bufSize = sizeof(u16) * (1+RegCount);
+
+        if (macp->ep4isIntOut)
+                usb_fill_int_urb(macp->reg_urb, macp->usb,
+                                 usb_sndintpipe(macp->usb, EP_REG_OUT),
+                                 pRegBuffer, bufSize,
+                                 zd1211_reg_cb, macp, 1);
+        else
+                usb_fill_bulk_urb(macp->reg_urb, macp->usb,
+                                  usb_sndbulkpipe(macp->usb, EP_REG_OUT),
+                                  pRegBuffer, bufSize,
+                                  zd1211_reg_cb, macp);
+
+        macp->reg_urb->transfer_flags |= URB_ASYNC_UNLINK;
+
+        if ((ret = SUBMIT_URB(macp->reg_urb, GFP_KERNEL)))
+        {
+                printk(KERN_ERR "zd1211: failed reg_urb\n");
+                zd1211_DumpErrorCode(macp, ret);
+                goto out;
+        }
+
+        wait_event(macp->regSet_wait, test_bit(ZD1211_CMD_FINISH, &macp->flags));
+        clear_bit(ZD1211_CMD_FINISH, &macp->flags);
+
+out:
+        kfree(pRegBuffer);
+        up(&macp->reg_sem);
+        return ret;
+}
+#endif
+
+
+// return 0: success
+int zd1211_USB_PACKAGE_READ_REGISTER(u16 *Address, u16 *pValue, u16 RegCount, u8 bAddUSBCSRAddress)
+{
+        struct zd1205_private *macp = g_dev->priv;
+        u8 *pRegBuffer = NULL;
+        int ret = 0;
+        u16 size = sizeof(USB_READ_REG_REQ);
+        u16 bufSize;
+        int ii;
+        //int memflags = GFP_KERNEL;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+
+        if (in_interrupt()) {
+#else
+
+        if (in_atomic()) {
+#endif
+                printk(KERN_ERR "********zd1211_USB_PACKAGE_READ_REGISTER in_interrupt*********\n");
+                return 0;
+        }
+        down(&macp->reg_sem);
+
+        if ((RegCount == 0) || (!macp->bUSBDeveiceAttached) || (!test_bit(ZD1211_RUNNING, &macp->flags))) {
+                up(&macp->reg_sem);
+                return 0;
+        }
+
+        pRegBuffer = kmalloc(size, GFP_KERNEL);
+
+        if (!pRegBuffer) {
+                up(&macp->reg_sem);
+                return -ENOMEM;
+        } else
+                memset(pRegBuffer, 0x0, size);
+
+        ((PUSB_READ_REG_REQ)pRegBuffer)->RequestID  = cpu_to_le16(REGID_READ);
+
+        for (ii = 0; ii < RegCount; ii ++) {
+                if ((Address[ii] & BASE_ADDR_MASK_HOST) == USB_BASE_ADDR_HOST)
+                        Address[ii] = Address[ii] - USB_BASE_ADDR_HOST + macp->AddrEntryTable;
+                else if ((Address[ii] & BASE_ADDR_MASK_HOST) == USB_BASE_ADDR_EEPROM)
+                        Address[ii] = ((Address[ii] - USB_BASE_ADDR_EEPROM) / 2) + cFIRMWARE_EEPROM_OFFSET;
+                //0x9900                     //0xF817
+                ((PUSB_READ_REG_REQ) pRegBuffer)->Address[ii] = cpu_to_le16(Address[ii]);
+        }
+
+        bufSize = sizeof(u16) * (1+RegCount);
+
+        if (macp->ep4isIntOut)
+                usb_fill_int_urb(macp->reg_urb, macp->usb,
+                                 usb_sndintpipe(macp->usb, EP_REG_OUT),
+                                 pRegBuffer, bufSize,
+                                 zd1211_reg_cb, macp, 1);
+        else
+                usb_fill_bulk_urb(macp->reg_urb, macp->usb,
+                                  usb_sndbulkpipe(macp->usb, EP_REG_OUT),
+                                  pRegBuffer, bufSize,
+                                  zd1211_reg_cb, macp);
+
+        macp->reg_urb->transfer_flags |= URB_ASYNC_UNLINK;
+
+        if ((ret = SUBMIT_URB(macp->reg_urb, GFP_ATOMIC))) {
+                printk(KERN_ERR "zd1211: failed reg_urb\n");
+                zd1211_DumpErrorCode(macp, ret);
+                up(&macp->reg_sem);
+                kfree(pRegBuffer);
+                return ret;
+        }
+
+        //wait command complete
+        macp->regWaitRCompCnt++;
+        //printk(KERN_ERR "before wait 4\n");
+        wait_event(macp->regSet_wait, test_bit(ZD1211_CMD_FINISH, &macp->flags));
+        //printk(KERN_ERR "after wait 4\n");
+        macp->regRWCompCnt++;
+
+        clear_bit(ZD1211_CMD_FINISH, &macp->flags);
+        kfree(pRegBuffer);
+
+        if (ret != 0)
+                goto out;
+
+        //wait response complete
+        macp->regWaitRspCnt++;
+
+#if 0//(LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+
+        if (wait_event_interruptible_timeout(macp->iorwRsp_wait, test_bit(ZD1211_REQ_COMP, &macp->flags), HZ/2)) { //use it, we may can't wake up
+
+                //interrupt by a signal
+                memset(macp->IntEPBuffer, 0, MAX_EPINT_BUFFER);
+                macp->regUnCompCnt++;
+                ret = -ERESTARTSYS;
+                goto out;
+        } else
+                macp->regRspCompCnt++;
+#else
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+
+        interruptible_sleep_on_timeout(&macp->iorwRsp_wait, 1); //magic delay
+#else
+
+        interruptible_sleep_on_timeout(&macp->iorwRsp_wait, 1); //magic delay
+#endif
+
+        //interruptible_sleep_on_timeout(&macp->iorwRsp_wait, HZ/40); //magic delay
+        if (!test_bit(ZD1211_REQ_COMP, &macp->flags)) {
+                //check if Rsp has completed, race condition may happen,
+                macp->regRdSleepCnt++;
+                //we waste time_out time
+                //printk(KERN_ERR "before wait 2\n");
+                interruptible_sleep_on_timeout(&macp->iorwRsp_wait, HZ/10);
+                //wake up, check if timeout or ompleted
+
+        }
+        if (test_bit(ZD1211_REQ_COMP, &macp->flags))
+                macp->regRspCompCnt++;
+        else {
+                memset(macp->IntEPBuffer, 0x0, MAX_EPINT_BUFFER);
+                macp->regUnCompCnt++;
+                ret = -1;
+                goto out;
+        }
+#endif
+
+        // Get data
+        if ((macp->ReadRegCount == 0) || (macp->ReadRegCount > MAX_EPINT_BUFFER)) {
+                ret = 1;
+        } else {
+                for (ii = 0; ii < (macp->ReadRegCount-2) / 4; ii++) {
+                        pValue[ii] = cpu_to_le16(*((u16 *) macp->IntEPBuffer2 + 1 + ii * 2 + 1));
+                }
+                ret = 0;
+        }
+
+out:
+        clear_bit(ZD1211_REQ_COMP, &macp->flags);
+        up(&macp->reg_sem);
+        return ret;
+}
+
+u32 zd1211_readl(u32 Address, u8 bAddUSBCSRAddress) {
+        struct zd1205_private *macp = g_dev->priv;
+
+        u16  ReadAddr[2];
+        u16  ReadData[2];
+        int bRet = 1;
+        u32 value;
+        int count = 0;
+
+        if (bAddUSBCSRAddress) {
+                Address += macp->USBCSRAddress;
+
+                if ((Address & BASE_ADDR_MASK_HOST) == USB_BASE_ADDR_HOST)
+                        ReadAddr[1] = (u16) Address + 1;
+                else
+                        ReadAddr[1] = (u16) Address + 2;
+        } else
+                ReadAddr[1] = (u16) Address + 1;
+
+        ReadAddr[0] = (u16) Address;    // Read Low Word first
+
+        while (bRet != 0) {
+                bRet = zd1211_USB_PACKAGE_READ_REGISTER(ReadAddr, ReadData, 2, false);
+                count++;
+
+                if (count > 5) {
+                        printk(KERN_ERR "1211_readl failed for 5 attempts...Very Serious");
+                        break;
+                }
+        }
+
+        value = (((u32) ReadData[1]) << 16) + ReadData[0];
+        return value;
+}
+
+//return 0: success
+int zd1211_USB_PACKAGE_WRITE_REGISTER(u16 *Address, u16 *Value, u16 RegCount, u8 bAddUSBCSRAddress) {
+        struct zd1205_private *macp = g_dev->priv;
+        u8 *pRegBuffer = NULL;
+        int ret;
+        u16 size = sizeof(USB_WRITE_REG);
+        u16 bufSize;
+        int i;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+
+        if (in_interrupt()) {
+#else
+        if (in_atomic()) {
+#endif
+                FPRINT("********zd1211_USB_PACKAGE_WRITE_REGISTER in_interrupt*********");
+                return 0;
+        }
+
+        down(&macp->reg_sem);
+
+        if ((RegCount == 0) || (!macp->bUSBDeveiceAttached) || !test_bit(ZD1211_RUNNING, &macp->flags)) {
+                up(&macp->reg_sem);
+                return 0;
+        }
+
+        pRegBuffer = kmalloc(size, GFP_KERNEL);
+        if (!pRegBuffer) {
+                up(&macp->reg_sem);
+                return -ENOMEM;
+        } else
+                memset(pRegBuffer, 0x0, size);
+
+        ((PUSB_WRITE_REG)pRegBuffer)->RequestID	= cpu_to_le16(REGID_WRITE);
+
+        if (RegCount > cMIN_MULTI_WRITE_REG_NUM) {
+                for (i=cMIN_MULTI_WRITE_REG_NUM; i<RegCount; i++) {
+                        if (bAddUSBCSRAddress)
+                                Address[i] += macp->USBCSRAddress;
+
+                        if ((Address[i] & BASE_ADDR_MASK_HOST) == USB_BASE_ADDR_HOST)
+                                Address[i] = Address[i] - USB_BASE_ADDR_HOST + macp->AddrEntryTable;
+                        else if ((Address[i] & BASE_ADDR_MASK_HOST) == USB_BASE_ADDR_EEPROM)
+                                Address[i] = ((Address[i] - USB_BASE_ADDR_EEPROM) / 2) + cFIRMWARE_EEPROM_OFFSET;
+
+                        ((PUSB_WRITE_REG)pRegBuffer)->WritePackage[i].Address = cpu_to_le16(Address[i]);
+                        ((PUSB_WRITE_REG)pRegBuffer)->WritePackage[i].WriteData_low = cpu_to_le16(Value[i]);
+                }
+        }
+
+        bufSize = sizeof(u16) * (1+RegCount*2);
+
+        if (macp->ep4isIntOut)
+                usb_fill_int_urb(macp->reg_urb, macp->usb,
+                                 usb_sndintpipe(macp->usb, EP_REG_OUT),
+                                 pRegBuffer, bufSize,
+                                 zd1211_reg_cb, macp, 1);
+        else
+                usb_fill_bulk_urb(macp->reg_urb, macp->usb,
+                                  usb_sndbulkpipe(macp->usb, EP_REG_OUT),
+                                  pRegBuffer, bufSize,
+                                  zd1211_reg_cb, macp);
+
+        macp->reg_urb->transfer_flags |= URB_ASYNC_UNLINK;
+
+        if ((ret = SUBMIT_URB(macp->reg_urb, GFP_ATOMIC))) {
+                printk(KERN_ERR "zd1211: failed reg_urb\n");
+                zd1211_DumpErrorCode(macp, ret);
+                goto out;
+        }
+
+        macp->regWaitWCompCnt++;
+        wait_event(macp->regSet_wait, test_bit(ZD1211_CMD_FINISH, &macp->flags));
+
+        macp->regRWCompCnt++;
+        clear_bit(ZD1211_CMD_FINISH, &macp->flags);
+
+out:
+        kfree(pRegBuffer);
+        up(&macp->reg_sem);
+        return ret;
+}
+
+int zd1211_WriteMultiRegister(u16 *Address, u16 *Value, u16 RegCount, u8 bAddUSBCSRAddress) {
+        int ret = 1;
+        int count = 0;
+
+        while (ret != 0) {
+                ret = zd1211_USB_PACKAGE_WRITE_REGISTER(Address, Value, RegCount, bAddUSBCSRAddress);
+
+                count++;
+                if (count > 5) {
+                        FPRINT("zd1211_WriteMultiRegister failed");
+                        break;
+                }
+        }
+
+        return ret;
+}
+
+
+//return 0: success
+int zd1211_writel(u32 Address, u32 Value, u8 bAddUSBCSRAddress) {
+        struct zd1205_private *macp = g_dev->priv;
+#ifdef fQuickPhySet
+
+        u8	bIsPhyReg = 0;
+#endif
+
+
+        u16  WriteAddr[6];
+        u16  WriteData[6];
+        int ret = 1;
+        int count = 0;
+
+#ifdef fQuickPhySet
+
+        if (bAddUSBCSRAddress && (Address <= ZD1205_PHY_END))
+
+                bIsPhyReg = 1;
+#endif
+
+
+#ifdef fQuickPhySet
+
+        if (bIsPhyReg) {
+                u32	tmpvalue;
+
+                tmpvalue = zd_readl(CtlReg1);
+                tmpvalue &= ~0x80;
+                {
+                        if (((macp->USBCSRAddress+CtlReg1) & BASE_ADDR_MASK_HOST) == USB_BASE_ADDR_HOST)
+                                WriteAddr[0] = (u16) (macp->USBCSRAddress+CtlReg1) + 1;
+                        else
+
+                                // must write High word first
+                                WriteAddr[0] = (u16) (macp->USBCSRAddress+CtlReg1) + 2;
+                }
+                WriteData[0] = (u16) (tmpvalue >> 16);
+
+                WriteAddr[1] = (u16) (macp->USBCSRAddress+CtlReg1);
+
+                WriteData[1] = (u16) (tmpvalue & 0xFFFF);
+
+                if (bAddUSBCSRAddress) {
+                        Address += (u16) (macp->USBCSRAddress);
+                        if ((Address & BASE_ADDR_MASK_HOST) == USB_BASE_ADDR_HOST)
+                                WriteAddr[2] = (u16) Address + 1;
+                        else
+                                // must write High word first
+                                WriteAddr[2] = (u16) Address + 2;
+                } else
+                        WriteAddr[2] = (u16) Address + 1;
+
+                WriteData[2] = (u16) (Value >> 16);
+                WriteAddr[3] = (u16) Address;
+
+                WriteData[3] = (u16) (Value & 0xFFFF);
+
+
+                tmpvalue |= 0x80;
+                {
+
+                        if (((macp->USBCSRAddress+CtlReg1) & BASE_ADDR_MASK_HOST) == USB_BASE_ADDR_HOST)
+
+                                WriteAddr[4] = (u16) (macp->USBCSRAddress+CtlReg1) + 1;
+                        else
+                                // must write High word first
+                                WriteAddr[4] = (u16) (macp->USBCSRAddress+CtlReg1) + 2;
+                }
+                WriteData[4] = (u16) (tmpvalue >> 16);
+                WriteAddr[5] = (u16) (macp->USBCSRAddress+CtlReg1);
+                WriteData[5] = (u16) (tmpvalue & 0xFFFF);
+
+                return zd1211_USB_PACKAGE_WRITE_REGISTER(WriteAddr, WriteData, 6, false);
+        } else {
+#endif
+                if (bAddUSBCSRAddress) {
+                        Address += macp->USBCSRAddress;
+                        if ((Address & BASE_ADDR_MASK_HOST) == USB_BASE_ADDR_HOST)
+                                WriteAddr[0] = (u16) Address + 1;
+                        else
+                                // must write High word first
+                                WriteAddr[0] = (u16) Address + 2;
+                } else
+                        WriteAddr[0] = (u16) Address + 1;
+
+                WriteAddr[1] = (u16) Address;
+                WriteData[0] = (u16) (Value >> 16);
+                WriteData[1] = (u16) (Value & 0xFFFF);
+
+
+                while (ret != 0) {
+                        ret = zd1211_USB_PACKAGE_WRITE_REGISTER(WriteAddr, WriteData, 2, false);
+                        count++;
+                        if (count > 5) {
+
+                                printk(KERN_ERR "zd1211_writel failed for 5 attempts\n");
+                                break;
+                        }
+                }
+
+#ifdef fQuickPhySet
+
+        }
+#endif
+
+        return ret;
+}
+
+
+
+void zd1211_StrongSignalDect(struct zd1205_private *macp) {
+        u32 tmpvalue;
+
+        if ( (macp->PHYTestTimerCount >= macp->PHYTestTimer)&&
+                        (macp->PHYTestTimer) && (macp->PHYLowPower & BIT_0)	&&
+                        (!dot11Obj.bContinueTx) &&
+
+                        (macp->bAssoc))
+        {
+                macp->PHYTestTimerCount = 0;
+                if (macp->RF_Mode == RFMD_RF) {
+                        if ( (macp->PHYTestRssi >= macp->PHYTestRssiBound) &&
+
+                                        ((!dot11Obj.CR122Flag) || (dot11Obj.CR122Flag == 2))) {
+                                LockPhyReg(&dot11Obj);
+                                zd_writel(0xff, ZD1205_CR122);
+
+                                if ( (macp->PHYLowPower & BIT_1)&&
+                                                ((!dot11Obj.CR31Flag) || (dot11Obj.CR31Flag == 2)) ) {
+
+
+                                        macp->bTraceSetPoint = 0;
+
+                                        tmpvalue = dot11Obj.IntValue[dot11Obj.Channel-1] - cPWR_STRONG_SIG_DROP;
+
+                                        zd_writel(tmpvalue, ZD1205_CR31);
+
+                                        dot11Obj.CR31Flag = 1;
+                                }
+
+
+                                UnLockPhyReg(&dot11Obj);
+
+                                dot11Obj.CR122Flag = 1;
+
+                        } else if ( (macp->PHYTestRssi < macp->PHYTestRssiBound) &&
+                                        ((dot11Obj.CR122Flag) || (dot11Obj.CR122Flag == 2)) ) {
+                                LockPhyReg(&dot11Obj);
+                                zd_writel(0x00, ZD1205_CR122);
+                                UnLockPhyReg(&dot11Obj);
+
+                                if ( (macp->PHYLowPower & BIT_1) &&
+
+                                                ((dot11Obj.CR31Flag) || (dot11Obj.CR31Flag == 2)) ) {
+                                        macp->bTraceSetPoint = 1;
+
+                                        HW_UpdateIntegrationValue(&dot11Obj, dot11Obj.Channel, macp->cardSetting.MacMode);
+
+                                        dot11Obj.CR31Flag = 0;
+
+                                }
+
+
+                                dot11Obj.CR122Flag = 0;
+                        }
+
+                } else if (macp->RF_Mode == AL2230_RF) {
+                        if ( (macp->PHYTestRssi >= macp->PHYTestRssiBound)&&
+                                        ((!dot11Obj.CR203Flag) || (dot11Obj.CR203Flag == 2)) ) {
+
+                                LockPhyReg(&dot11Obj);
+
+                                zd_writel(0x0a, ZD1205_CR203);
+                                if ( (macp->PHYLowPower & BIT_1)&&
+                                                ((!dot11Obj.CR31Flag) || (dot11Obj.CR31Flag == 2)) ) {
+
+
+
+                                        macp->bTraceSetPoint = 0;
+
+                                        tmpvalue = dot11Obj.IntValue[dot11Obj.Channel-1] - cPWR_STRONG_SIG_DROP;
+                                        zd_writel(tmpvalue, ZD1205_CR31);
+                                        dot11Obj.CR31Flag = 1;
+                                }
+
+                                UnLockPhyReg(&dot11Obj);
+                                dot11Obj.CR203Flag = 1;
+                        } else if ( (macp->PHYTestRssi < macp->PHYTestRssiBound)&&
+                                        ((dot11Obj.CR203Flag) || (dot11Obj.CR203Flag == 2)) ) {
+                                LockPhyReg(&dot11Obj);
+                                zd_writel(0x06, ZD1205_CR203);
+                                UnLockPhyReg(&dot11Obj);
+
+
+
+
+                                if ( (macp->PHYLowPower & BIT_1)&&
+                                                ((dot11Obj.CR31Flag) || (dot11Obj.CR31Flag == 2)) ) {
+
+                                        macp->bTraceSetPoint = 1;
+
+
+                                        HW_UpdateIntegrationValue(&dot11Obj, dot11Obj.Channel, macp->cardSetting.MacMode);
+                                        dot11Obj.CR31Flag = 0;
+                                }
+
+
+                                dot11Obj.CR203Flag = 0;
+                        }
+                }
+        } else
+        {
+                macp->PHYTestTimerCount++;
+
+        }
+}
+
+
+//================================================================
+// Housekeeping Every 0.5 s
+//================================================================
+
+
+void zd1211_TxCalibration(struct zd1205_private *macp) {
+        static u32 loop = 0;
+
+        static u16 TrackingLoop = 0;
+        static u32 accumulate  = 0;
+        u8 setpoint;
+        u16 channel;
+        u32	average = 0;
+        u32	tmpvalue;
+        static u16 TrackingCnt = 0;
+        static u32 accumulate_OFDM = 0;
+        static u16 TrackingCnt_OFDM = 0;
+        u8  PreTxOFDMType = cTX_CCK;
+
+        loop++;
+
+
+#if fTX_PWR_CTRL
+
+        if ((loop % 64) == 0)
+        {
+                if (macp->bTraceSetPoint) {
+
+
+                        LockPhyReg(&dot11Obj);
+                        if (TrackingLoop == TRACKING_NUM) {
+                                TrackingLoop = 0;
+
+
+                                if (TrackingCnt && PURE_A_MODE != macp->cardSetting.MacMode ) {
+                                        average = (u32) (accumulate / TrackingCnt);
+                                        channel = dot11Obj.Channel;
+                                        setpoint = macp->EepSetPoint[channel-1];
+                                        if (macp->EnableTxPwrCtrl) {
+                                                if (average < (u32) (setpoint - cPWR_CTRL_GUARD))
+                                                        zd1205_IncreaseTxPower(macp, cTX_CCK);
+                                                else if (average > setpoint)
+
+                                                        zd1205_DecreaseTxPower(macp, cTX_CCK);
+                                        }
+                                        accumulate = 0;
+                                        TrackingCnt = 0;
+                                }
+
+                                if (TrackingCnt_OFDM) {
+                                        average = (u32) (accumulate_OFDM / TrackingCnt_OFDM);
+                                        channel = dot11Obj.Channel;
+                                        if(PURE_A_MODE != macp->cardSetting.MacMode) {
+                                                setpoint = macp->SetPointOFDM[macp->TxOFDMType - cTX_OFDM][channel - 1];
+                                        } else if (PURE_A_MODE == macp->cardSetting.MacMode) {
+                                                u8 UselessInt;//Only for store return Integration value that we don't need
+                                                int ret;
+                                                ret = a_OSC_get_cal_int(
+                                                              channel,
+                                                              macp->cardSetting.LastSentTxRate ,
+                                                              &UselessInt, &setpoint);
+                                                if(0 != ret)
+                                                        printk("a_OSC_get_cal_int can't found the channel\n");
+                                        }
+                                        //printk("Enter TrackingCnt_OFDM(CH:%d)(SET:%d)(avg:%d)\n",channel,setpoint,average);
+                                        if (macp->EnableTxPwrCtrl) {
+                                                if (average < (u32) (setpoint - cPWR_CTRL_GUARD))
+                                                        zd1205_IncreaseTxPower(macp, cTX_OFDM);
+                                                else if (average > setpoint)
+                                                        zd1205_DecreaseTxPower(macp, cTX_OFDM);
+                                        }
+                                        accumulate_OFDM = 0;
+                                        TrackingCnt_OFDM = 0;
+                                }
+                        } else {
+
+                                TrackingLoop ++;
+                                tmpvalue = zd_readl(rLED_CTRL);
+                                if (tmpvalue & BIT_0) {   // Continuous Tx
+                                        if (tmpvalue & BIT_2) {   // Tx OFDM
+
+                                                macp->TxPwrOFDM ++;
+                                                macp->TxOFDMCnt = cTX_SENT_LEN + 1;
+                                                tmpvalue = zd_readl(ZD1205_CR132);
+                                                tmpvalue &= 0xFF;
+                                                macp->TxOFDMType = cTX_OFDM;
+                                                if (tmpvalue == 0xC)
+                                                        macp->TxOFDMType = cTX_54M;
+
+                                                else if (tmpvalue == 0x8)
+
+
+
+                                                        macp->TxOFDMType = cTX_48M;
+                                        } else
+                                                macp->TxPwrCCK ++;   // Tx CCK
+                                }
+
+                                if (macp->TxPwrCCK) {  // New sent after last read
+                                        tmpvalue = zd_readl(ZD1205_CR58);
+                                        tmpvalue &= 0xFF;
+                                        accumulate += tmpvalue;
+                                        TrackingCnt ++;
+
+                                        macp->TxPwrCCK = 0;
+
+                                }
+
+
+                                if (macp->TxPwrOFDM) {
+                                        if (macp->TxOFDMCnt > cTX_SENT_LEN) { // make sure Tx by HMAC (for UMAC)
+                                                tmpvalue = zd_readl(ZD1205_CR57);
+                                                tmpvalue &= 0xFF;
+                                                accumulate_OFDM += tmpvalue;
+                                                TrackingCnt_OFDM ++;
+                                                PreTxOFDMType = macp->TxOFDMType;
+                                        } else {
+                                                if (PreTxOFDMType != macp->TxOFDMType) {
+
+                                                        accumulate_OFDM = 0;
+                                                        TrackingCnt_OFDM = 0;
+                                                }
+
+                                        }
+                                        macp->TxPwrOFDM = 0;
+                                }
+                        }
+                        UnLockPhyReg(&dot11Obj);
+                }
+        }
+
+
+#endif
+
+}
+
+
+//================================================================
+// Housekeeping Every 1s
+
+
+//================================================================
+void zd1211_CheckWithIPC(struct zd1205_private *macp) {
+        static u32 loop = 0;
+        u8 BssType = macp->cardSetting.BssType;
+
+        loop++;
+
+        if ((loop % 10) == 0)
+        {
+                // bypass the weak signal in BSS and AP mode
+                if ( (macp->bAssoc) &&
+                                (macp->PHYTestRssi <= 0x18) &&
+                                ((BssType == INDEPENDENT_BSS) ||
+                                 (BssType == PSEUDO_IBSS)) ) {
+                        if (!macp->CR138Flag) {
+
+                                LockPhyReg(&dot11Obj);
+                                zd_writel(0xa8, ZD1205_CR138);
+
+
+                                UnLockPhyReg(&dot11Obj);
+                                macp->CR138Flag = 1;
+                        }
+                }
+                else if (macp->CR138Flag) {
+                        LockPhyReg(&dot11Obj);
+                        zd_writel(0x28, ZD1205_CR138);
+                        UnLockPhyReg(&dot11Obj);
+                        macp->CR138Flag = 0;
+                }
+
+#if 0
+                // solve the throughput problem when communicate with the IPC card
+                if ( ((macp->rxDataPerSec + macp->txDataPerSec) > 50000) &&
+
+                                (macp->RF_Mode == RFMD_RF) &&
+                                (BssType != PSEUDO_IBSS) &&
+                                (macp->IPCFlag != 4) ) {
+
+
+                        if ( (macp->rxDataPerSec > 3*macp->txDataPerSec) &&
+                                        (macp->PHYTestRssi <= 0x24) ) {
+                                if ((!macp->IPCFlag) || (macp->IPCFlag!=1)) {
+                                        LockPhyReg(&dot11Obj);
+                                        zd_writel(0x0a, ZD1205_CR87);
+                                        zd_writel(0x04, ZD1205_CR89);
+                                        UnLockPhyReg(&dot11Obj);
+                                        macp->AdapterMaxRate = 8;  // MAX = 24M
+                                        macp->IPCFlag = 1;
+                                }
+                        } else if ( 3*macp->rxDataPerSec < macp->txDataPerSec ) {
+                                if ((!macp->IPCFlag) || (macp->IPCFlag != 3)) {
+                                        LockPhyReg(&dot11Obj);
+                                        zd_writel(0x2A, ZD1205_CR87);
+                                        zd_writel(0x24, ZD1205_CR89);
+                                        UnLockPhyReg(&dot11Obj);
+                                        macp->AdapterMaxRate = 0x0B;  // MAX = 54M
+
+                                        macp->IPCFlag = 3;
+                                }
+                        } else {
+                                if ((!macp->IPCFlag) || (macp->IPCFlag != 2)) {
+                                        LockPhyReg(&dot11Obj);
+                                        zd_writel(0x10, ZD1205_CR87);
+                                        zd_writel(0x0C, ZD1205_CR89);
+                                        UnLockPhyReg(&dot11Obj);
+                                        macp->AdapterMaxRate = 9;  // MAX = 36M
+                                        macp->IPCFlag = 2;
+
+                                }
+                        }
+
+                } else if ((macp->RF_Mode == RFMD_RF) &&
+
+                                (BssType == PSEUDO_IBSS) &&
+                                (macp->IPCFlag != 4)) {
+                        if ((!macp->IPCFlag) || (macp->IPCFlag != 3)) {
+                                LockPhyReg(&dot11Obj);
+                                zd_writel(0x2A, ZD1205_CR87);
+                                zd_writel(0x24, ZD1205_CR89);
+                                UnLockPhyReg(&dot11Obj);
+                                macp->AdapterMaxRate = 0x0B;  // MAX = 54M
+                                macp->IPCFlag = 3;
+                        }
+                }
+
+                else if ((macp->RF_Mode == RFMD_RF) &&
+                                (macp->IPCFlag != 4) ) {
+                        if ( (!macp->IPCFlag) || (macp->IPCFlag != 2)) {
+                                LockPhyReg(&dot11Obj);
+                                zd_writel(0x10, ZD1205_CR87);
+                                zd_writel(0x0C, ZD1205_CR89);
+
+                                UnLockPhyReg(&dot11Obj);
+                                macp->AdapterMaxRate = 9;  // MAX = 36M
+                                macp->IPCFlag = 2;
+                        }
+                }
+
+                macp->rxDataPerSec = 0;
+                macp->txDataPerSec = 0;
+#endif
+
+                if (macp->LinkLEDn == LED2)
+                        iLED_OFF(macp, LED1);
+
+                if (!macp->bAssoc) {
+                        macp->LinkTimer ++;
+
+                        if ((macp->LinkTimer == 1) && (macp->LinkLED_OnDur != 0)) {
+                                iLED_ON(macp, macp->LinkLEDn);
+
+                        }
+
+                        if (macp->LinkTimer == (macp->LinkLED_OnDur + 1)) {
+                                iLED_OFF(macp, macp->LinkLEDn);
+                        }
+
+
+                        if (macp->LinkTimer >= (macp->LinkLED_OnDur + macp->LinkLED_OffDur))
+                                macp->LinkTimer = 0;
+                }
+
+#if 0
+                if (dot11Obj.PhyTest & BIT_8) {
+
+                        u32 tmpvalue;
+                        LockPhyReg(&dot11Obj);
+                        tmpvalue = zd_readl(ZD1205_CR122);
+                        if ((tmpvalue & 0xFF) != 0xFF)
+                                zd_writel(0xFF, ZD1205_CR122);
+
+                        else
+                                zd_writel(0x00, ZD1205_CR122);
+                        UnLockPhyReg(&dot11Obj);
+                }
+#endif
+
+        }// end of (loop % 10)
+}
+
+
+// Switch to another antenna
+void zd1211_SwitchAntenna(struct zd1205_private *macp) {
+        u32   tmpvalue;
+
+        LockPhyReg(&dot11Obj);
+
+        tmpvalue = zd_readl(ZD1205_CR10);
+        tmpvalue ^= BIT_1;
+        zd_writel(tmpvalue, ZD1205_CR10);
+
+        tmpvalue = zd_readl(ZD1205_CR9);
+        tmpvalue ^= BIT_2;
+        zd_writel(tmpvalue, ZD1205_CR9);
+
+        UnLockPhyReg(&dot11Obj);
+}
+
+//-----------------------------------------------------------------------------
+#if fPROG_FLASH
+// 1:Intel Flash;   0: MXIC, Winbond, AMD, Atmel...
+#define cFLASH_MXIC             0
+#define cFLASH_INTEL            1
+
+u16 zd1211_SetHighAddr(struct zd1205_private *macp, u16 high_addr) {
+        u16  tmp_cr203;
+        u16  WriteAddr[cMAX_MULTI_WRITE_REG_NUM];
+        u16  WriteData[cMAX_MULTI_WRITE_REG_NUM];
+        u16  WriteIndex = 0;
+
+        tmp_cr203 = ((high_addr << 1) & ~mMASK(2)) + (high_addr & mBIT(0));
+
+        if (macp->FlashType == cFLASH_INTEL)
+        {
+                mFILL_WRITE_REGISTER(rLED_CTRL, 0);
+                if (mTEST_BIT(high_addr, 7))
+                        mFILL_WRITE_REGISTER(rLED_CTRL, LED2);
+        }
+
+
+        mFILL_WRITE_REGISTER(ZD1205_CR203, tmp_cr203);
+        zd1211_WriteMultiRegister(WriteAddr, WriteData, WriteIndex, true);
+        return tmp_cr203;
+}
+
+
+/* abs_addr: in word */
+u16 zd1211_SetAbsAddr(struct zd1205_private *macp, u32 abs_addr, u16 *get_cr203)
+{
+        static u16 pre_high_addr = 0, pre_cr203 = 0;
+
+        u16 high_addr;
+
+        high_addr = (u16) (abs_addr >> 14);
+        if (pre_high_addr != high_addr)
+        {
+                pre_cr203 = zd1211_SetHighAddr(macp, high_addr);
+                pre_high_addr = high_addr;
+        }
+
+
+        if (get_cr203 != NULL)
+                *get_cr203 = pre_cr203;
+
+        return ((u16) (abs_addr & mMASK(14)));
+}
+
+void zd1211_FlashCmdWrite(struct zd1205_private *macp, u8 Cmd) {
+        u32   tmpvalue;
+        u16  WriteAddr[cMAX_MULTI_WRITE_REG_NUM];
+        u16  WriteData[cMAX_MULTI_WRITE_REG_NUM];
+        u16  WriteIndex = 0;
+
+        tmpvalue = zd1211_readl(ZD1205_CR203, true);
+        if (macp->FlashType == cFLASH_MXIC)
+        {
+                mFLASH_WRITE_EVEN_ADDR(0xAAA, 0xAA, tmpvalue);
+                mFLASH_WRITE_ODD_ADDR(0x555, 0x55, tmpvalue);
+                mFLASH_WRITE_EVEN_ADDR(0xAAA, Cmd, tmpvalue);
+        } else
+
+                mFLASH_WRITE_EVEN_ADDR(0, Cmd, tmpvalue);
+        zd1211_WriteMultiRegister(WriteAddr, WriteData, WriteIndex, false);
+}
+
+void zd1211_FlashResetCmd(struct zd1205_private *macp) {
+        if (macp->FlashType == cFLASH_MXIC)
+                zd1211_writel(0, 0xF0, false);
+        else
+                zd1211_FlashCmdWrite(macp, 0xFF);
+}
+
+
+
+void zd1211_InitHighAddr(struct zd1205_private *macp) {
+        u16  WriteAddr[cMAX_MULTI_WRITE_REG_NUM];
+
+        u16  WriteData[cMAX_MULTI_WRITE_REG_NUM];
+        u16  WriteIndex = 0;
+
+        mFILL_WRITE_REGISTER(UMAC_WAIT_STATE, 0x022);   // 25ns * 2
+        mFILL_WRITE_REGISTER(ZD1205_CR11 + (u16) (macp->USBCSRAddress), 0x15);
+        // Use AntSel to control VPEN for Intel Flash
+        mFILL_WRITE_REGISTER(ZD1205_CR10 + (u16) (macp->USBCSRAddress), 0x82);
+
+        mFILL_WRITE_REGISTER(ZD1205_CR9 + (u16) (macp->USBCSRAddress), 0x24);
+        mFILL_WRITE_REGISTER(ZD1205_CR204 + (u16) (macp->USBCSRAddress), 0x7C);
+        mFILL_WRITE_REGISTER(ZD1205_CR203 + (u16) (macp->USBCSRAddress), 0);
+        zd1211_WriteMultiRegister(WriteAddr, WriteData, WriteIndex, false);
+        if (macp->FlashType == 0xFF)
+        {
+                u32  tmpvalue;
+
+
+                macp->FlashType = cFLASH_INTEL;
+                zd1211_FlashCmdWrite(macp, 0x90);       // Read Chip ID
+
+                tmpvalue = zd1211_readl(0, false);
+                if ((tmpvalue & 0xFFFF) != 0x8989)  // Intel Manufacture Code
+                        macp->FlashType = cFLASH_MXIC;
+        }
+        zd1211_SetAbsAddr(macp, 0, NULL);
+        zd1211_FlashResetCmd(macp);
+
+
+}
+
+
+/* Top: 8k byte / sector ==> 0 - 0x1000 (word address) */
+/*   ==> sec0 address = 0; sec1 address = 0x1000 ... */
+void zd1211_FlashSecErase(struct zd1205_private *macp, u16 Sec0) {
+        u32  tmpvalue;
+        u16  WriteAddr[cMAX_MULTI_WRITE_REG_NUM];
+        u16  WriteData[cMAX_MULTI_WRITE_REG_NUM];
+        u16  WriteIndex = 0;
+
+        LockPhyReg(&dot11Obj);
+        tmpvalue = zd1211_readl(ZD1205_CR203, true);
+        if (macp->FlashType == cFLASH_MXIC)
+        {
+                zd1211_FlashCmdWrite(macp, 0x80);
+                mFLASH_WRITE_EVEN_ADDR(0xAAA, 0xAA, tmpvalue);
+                mFLASH_WRITE_ODD_ADDR(0x555, 0x55, tmpvalue);
+                mFLASH_WRITE_EVEN_ADDR(Sec0 << 1, 0x30, tmpvalue);
+        } else
+        {
+                mFLASH_SET_EVEN_ADDR(tmpvalue);
+                mFILL_WRITE_REGISTER(Sec0, 0x20);
+
+                mFILL_WRITE_REGISTER(Sec0, 0xD0);
+        }
+
+        zd1211_WriteMultiRegister(WriteAddr, WriteData, WriteIndex, false);
+        UnLockPhyReg(&dot11Obj);
+}
+
+
+
+
+
+void zd1211_EraseFlash(struct zd1205_private *macp) {
+        u32  ii;
+        u32  tmpvalue;
+        u16  low_addr, jj;
+
+        macp->bDisableTx = 1;
+        //USB_StopTxEP(Adapter);
+        LockPhyReg(&dot11Obj);
+        macp->bAllowAccessRegister = 0;
+
+
+        zd1211_InitHighAddr(macp);
+
+        if (macp->FlashType == cFLASH_MXIC)
+
+        {
+                zd1211_FlashCmdWrite(macp, 0x80);
+                zd1211_FlashCmdWrite(macp, 0x10);
+        } else
+        {
+                for (ii = 0; ii < 0x400000L; ii += 0x10000L) {
+                        low_addr = zd1211_SetAbsAddr(macp, ii, NULL);
+                        zd1211_FlashSecErase(macp, low_addr);
+                        for (jj = 0; jj < 100; jj ++) {
+                                tmpvalue = zd1211_readl(0, false);
+                                if (tmpvalue & 0x8000)
+                                        break;
+
+                                mdelay(10);            // Sleep 10ms
+                        }
+                }
+
+        }
+
+
+        //macp->bAllowAccessRegister = 1;
+
+
+
+        UnLockPhyReg(&dot11Obj);
+
+        //macp->bDisableTx = 0;
+}
+
+
+#if !fPROG_FLASH_BY_FW
+void FlashProgram(struct zd1205_private *macp, u16 addr0, u8 *pbuf, u16 tmpvalue) {
+        u16  WriteAddr[cMAX_MULTI_WRITE_REG_NUM];
+        u16  WriteData[cMAX_MULTI_WRITE_REG_NUM];
+        u16  WriteIndex = 0;
+        u16  jj;
+
+        if (macp->FlashType == cFLASH_MXIC)
+        {
+                for (jj = 0; jj < 16; jj ++) {
+                        WriteIndex = 0;
+                        mFLASH_SET_EVEN_ADDR(tmpvalue);
+                        zd1211_FlashCmdWrite(macp, 0xA0);
+                        mFILL_WRITE_REGISTER(addr0 + jj, pbuf[jj * 2]);
+                        zd1211_WriteMultiRegister(WriteAddr, WriteData, WriteIndex, false;
+                                          }
+
+                                          for (jj = 0; jj < 16; jj ++) {
+                                                  WriteIndex = 0;
+                                                  mFLASH_SET_ODD_ADDR(tmpvalue);
+                                                  zd1211_FlashCmdWrite(macp, 0xA0);
+                                                  mFILL_WRITE_REGISTER(addr0 + jj, pbuf[jj * 2 + 1]);
+
+                                                  if (jj == 15) {
+                                                          // Read Word Addr
+
+                                                          mFLASH_SET_EVEN_ADDR(tmpvalue);
+                                                  }
+
+                                                  zd1211_WriteMultiRegister(WriteAddr, WriteData, WriteIndex, false);
+                                          }
+                                  } else
+                                  {
+                                          mFLASH_SET_EVEN_ADDR(tmpvalue);
+                                          mFILL_WRITE_REGISTER(addr0, 0xE8);
+                                          mFILL_WRITE_REGISTER(addr0, 0x0F);
+                                          for (jj = 0; jj < 8; jj ++)
+                                                  mFILL_WRITE_REGISTER(addr0 + jj, pbuf[jj * 2]);
+                                          zd1211_WriteMultiRegister(WriteAddr, WriteData, WriteIndex, false);
+
+
+                                          WriteIndex = 0;
+                                          for (jj = 8; jj < 16; jj ++)
+
+                                                  mFILL_WRITE_REGISTER(addr0 + jj, pbuf[jj * 2]);
+
+                                          mFILL_WRITE_REGISTER(0, 0xD0);
+                                          zd1211_WriteMultiRegister(WriteAddr, WriteData, WriteIndex, false);
+
+                                          WriteIndex = 0;
+                                          mFLASH_SET_ODD_ADDR(tmpvalue);
+                                          mFILL_WRITE_REGISTER(addr0, 0xE8);
+                                          mFILL_WRITE_REGISTER(addr0, 0x0F);
+                                          for (jj = 0; jj < 8; jj ++)
+                                                  mFILL_WRITE_REGISTER(addr0 + jj, pbuf[jj * 2 + 1]);
+                                          zd1211_WriteMultiRegister(WriteAddr, WriteData, WriteIndex, false);
+
+                                          WriteIndex = 0;
+                                          for (jj = 8; jj < 16; jj ++)
+                                                  mFILL_WRITE_REGISTER(addr0 + jj, pbuf[jj * 2 + 1]);
+                                          mFILL_WRITE_REGISTER(0, 0xD0);
+                                          zd1211_WriteMultiRegister(WriteAddr, WriteData, WriteIndex, false);
+                                  }
+
+                          }
+#endif
+
+
+
+                          int zd1211_ProgFlash(struct zd1205_private *macp, u32 StartAddr,
+                                               u32 BufLenInBytes, u8 *pDownloadBuffer) {
+                                  int i;
+                                  u32   ii;
+                                  u16  low_addr, jj;
+                                  int chk_flg = 1;
+                                  u16  tmpvalue;
+#if fPROG_FLASH_BY_FW
+
+                                  u16  WriteData[cMAX_MULTI_RF_REG_NUM];
+                                  u16  WriteIndex = 0;
+#endif
+
+#if fVERIFY_FLASH
+
+                                  u16  ReadAddr[cMAX_MULTI_READ_REG_NUM];
+                                  u16  ReadData[cMAX_MULTI_READ_REG_NUM];
+                                  u16  ReadIndex = 0;
+                                  u16  chk_cnt = 0;
+#endif
+
+                                  macp->bDisableTx = 1;
+                                  //USB_StopTxEP(Adapter);
+
+                                  LockPhyReg(&dot11Obj);
+                                  macp->bAllowAccessRegister = 0;
+
+                                  zd1211_InitHighAddr(macp);
+                                  StartAddr /= 2;                         // Convert Byte Addr to Word Addr
+
+                                  for (ii = 0; ii < BufLenInBytes / 2; ii += 16)
+                                  {
+                                          if (macp->FlashType == cFLASH_MXIC) {
+                                                  if ((ii + StartAddr) >= 0x200000)   // 2M Word = 4M Byte
+                                                          break;
+                                          } else {
+                                                  if ((ii + StartAddr) >= 0x400000)   // 4M Word = 8M Byte
+                                                          break;
+                                          }
+
+                                          low_addr = zd1211_SetAbsAddr(macp, ii + StartAddr, &tmpvalue);
+
+#if fPROG_FLASH_BY_FW
+
+                                          WriteIndex = 0;
+                                          tmpvalue &= 0x00FF;
+                                          tmpvalue |= ((macp->FlashType) << 8);
+                                          mFILL_RF_REGISTER(mCLR_BIT((tmpvalue), bmFLASH_A0));
+                                          mFILL_RF_REGISTER(low_addr);
+
+                                          for (jj = 0; jj < 16; jj ++)
+                                                  mFILL_RF_REGISTER((u16) pDownloadBuffer[(ii + jj) * 2]);
+
+                                          zd1211_USB_ProgramFlash(macp, WriteData, WriteIndex);
+                                          WriteIndex = 0;
+                                          mFILL_RF_REGISTER(mSET_BIT((tmpvalue), bmFLASH_A0));
+                                          mFILL_RF_REGISTER(low_addr);
+
+                                          for (jj = 0; jj < 16; jj ++)
+                                                  mFILL_RF_REGISTER((u16) pDownloadBuffer[(ii + jj) * 2 + 1]);
+
+                                          for (i=0; i<5; i++) {
+                                                  if (zd1211_USB_ProgramFlash(macp, WriteData, WriteIndex))
+                                                          break;
+                                          }
+#else
+                                          zd1211_FlashProgram(macp, low_addr, pDownloadBuffer + 2 * ii, tmpvalue);
+#endif
+
+                                  }
+
+                                  //macp->bAllowAccessRegister = 1;
+                                  UnLockPhyReg(&dot11Obj);
+                                  //macp->bDisableTx = 0;
+
+                                  return chk_flg;
+                          }
+
+#endif
+
+                          int zd1211_USB_SET_RF_REG(u16 *InputValue, int bIs3683A) {
+                                  struct zd1205_private *macp = g_dev->priv;
+
+                                  u8 *pRegBuffer = NULL;
+                                  int ret;
+                                  u16 size = sizeof(USB_SET_RF);
+                                  u16 bufSize;
+                                  u32	S_bit_cnt = dot11Obj.S_bit_cnt;
+                                  u16 i;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+
+                                  if (in_interrupt()) {
+#else
+                                  if (in_atomic()) {
+#endif
+                                          FPRINT("********zd1211_USB_SET_RF_REG in_interrupt*********");
+                                          return 0;
+                                  }
+
+                                  down(&macp->reg_sem);
+
+                                  if (!(macp->bUSBDeveiceAttached)) {
+                                          up(&macp->reg_sem);
+                                          return 0;
+                                  }
+
+                                  pRegBuffer = kmalloc(size, GFP_KERNEL);
+
+                                  if (!pRegBuffer) {
+                                          up(&macp->reg_sem);
+                                          return -ENOMEM;
+                                  } else
+                                          memset(pRegBuffer, 0x0, size);
+
+                                  ((PUSB_SET_RF)pRegBuffer)->RequestID = cpu_to_le16(REGID_RFOFDMSET);
+
+                                  if (bIs3683A)
+                                          ((PUSB_SET_RF)pRegBuffer)->Value = cpu_to_le16(1);
+                                  else
+                                          ((PUSB_SET_RF)pRegBuffer)->Value = cpu_to_le16(2);
+
+                                  ((PUSB_SET_RF)pRegBuffer)->Index = cpu_to_le16((u16)S_bit_cnt);
+
+                                  for (i = 0; i < S_bit_cnt; i ++)
+                                          ((PUSB_SET_RF)pRegBuffer)->Data[i] = cpu_to_le16(InputValue[i]);
+
+                                  bufSize = sizeof(u16) * (3+S_bit_cnt);
+
+                                  if (macp->ep4isIntOut)
+                                          usb_fill_int_urb(macp->reg_urb, macp->usb,
+                                                           usb_sndintpipe(macp->usb, EP_REG_OUT),
+                                                           pRegBuffer, bufSize,
+                                                           zd1211_reg_cb, macp, 1);
+                                  else
+                                          usb_fill_bulk_urb(macp->reg_urb, macp->usb,
+                                                            usb_sndbulkpipe(macp->usb, EP_REG_OUT),
+                                                            pRegBuffer, bufSize,
+                                                            zd1211_reg_cb, macp);
+
+                                  macp->reg_urb->transfer_flags |= URB_ASYNC_UNLINK;
+
+                                  if ((ret = SUBMIT_URB(macp->reg_urb, GFP_ATOMIC))) {
+                                          printk(KERN_ERR "zd1211: failed rf reg_urb\n");
+                                          zd1211_DumpErrorCode(macp, ret);
+                                          goto out;
+                                  }
+
+                                  macp->regWaitWCompCnt++;
+                                  wait_event(macp->regSet_wait, test_bit(ZD1211_CMD_FINISH, &macp->flags));
+                                  macp->regRWCompCnt++;
+                                  clear_bit(ZD1211_CMD_FINISH, &macp->flags);
+
+                          out:
+                                  kfree(pRegBuffer);
+                                  up(&macp->reg_sem);
+                                  return ret;
+                          }
+
+#define bmZD_IF_LE              1
+#define bmZD_RF_CLK             2
+#define bmZD_RF_DATA            3
+                          void
+                          HW_Set_IF_Synthesizer(zd_80211Obj_t *pObj, U32 InputValue) {
+                                  u32	S_bit_cnt;
+                                  u32	tmpvalue;
+                                  u16 WriteData[cMAX_MULTI_RF_REG_NUM];
+                                  u16 WriteIndex = 0;
+
+                                  S_bit_cnt = pObj->S_bit_cnt;
+                                  InputValue = InputValue << (31 - S_bit_cnt);
+
+                                  //to avoid un-necessary register read/write
+                                  //LockPhyReg(pObj);
+                                  tmpvalue = zd_readl(ZD_CR203);
+                                  tmpvalue = mCLR_BIT(tmpvalue, bmZD_IF_LE);
+
+                                  // Configure RF by Software
+                                  tmpvalue = mCLR_BIT(tmpvalue, bmZD_RF_CLK);
+
+                                  while (S_bit_cnt) {
+                                          InputValue = InputValue << 1;
+
+                                          if (InputValue & 0x80000000) {
+                                                  tmpvalue = mSET_BIT(tmpvalue, bmZD_RF_DATA);
+                                                  mFILL_RF_REGISTER((u16) tmpvalue);
+                                          } else {
+                                                  tmpvalue = mCLR_BIT(tmpvalue, bmZD_RF_DATA);
+                                                  mFILL_RF_REGISTER((u16) tmpvalue);
+                                          }
+
+                                          if (WriteIndex >= cMAX_MULTI_RF_REG_NUM) {
+                                                  FPRINT_V("S_bit_cnt over range! ", (u32)pObj->S_bit_cnt);
+                                                  break;
+                                          }
+
+                                          S_bit_cnt --;
+                                  }
+
+                                  zd1211_USB_SET_RF_REG(WriteData, 0);
+                                  //UnLockPhyReg(pObj);
+                          }
+
+                          /* ath_desc: Defer tx kill_urb on Linux 2.6.8+ */
+                          static void zd1211_kill_tx_urb(void *_macp) {
+                                  struct zd1205_private *macp = (struct zd1205_private *)_macp;
+                                  ZENTER(1);
+                                  macp->tx_urb->transfer_flags |= URB_ASYNC_UNLINK;
+                                  ZD_USB_KILL_URB(macp->tx_urb);
+                          }
+
+                          static void zd1211_tx_timeout(struct net_device *dev) {
+                                  struct zd1205_private *macp = dev->priv;
+
+                                  if (!macp)
+                                          return;
+
+                                  /* ath_desc: added Tx timeout reset */
+                                  printk("%s: Tx timed out, trying reset\n", dev->name);
+                                  macp->drv_stats.net_stats.tx_carrier_errors++;
+                                  dev->trans_start = jiffies;
+                                  defer_kevent(macp, KEVENT_UPDATE_SETTING);
+                                  /* ath: On Linux 2.6.8+ usb_kill_urb() cannot be called from an interrupt context, so defer it */
+                                  defer_kevent(macp, KEVENT_KILL_TX_URB);
+                          }
+
+                          int zd1211_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd) {
+                                  struct zd1205_private *macp = dev->priv;
+
+                                  memcpy(&macp->ifreq, ifr, sizeof(struct ifreq));
+                                  macp->ifcmd = cmd;
+                                  defer_kevent(macp, KEVENT_STD_IOCTL);
+                                  return 0;
+                          }
+
+#define	ZD1211_TX_TIMEOUT		(HZ*10)
+#define	ZD1211_MTU			1500
+                          extern struct iw_handler_def p80211wext_handler_def;
+
+/* ath_desc: added iw_get_stats */
+#ifdef CONFIG_NET_WIRELESS
+extern struct iw_statistics *zd1205wext_iw_get_stats(struct net_device *);
+#endif
+
+
+u8 zd1211_InitSetup(struct net_device *dev, struct zd1205_private *macp) {
+        int res;
+
+        //return true; //for debug
+        ZENTER(1);
+
+        init_MUTEX(&macp->ps_sem);
+        init_MUTEX(&macp->reg_sem);
+        init_MUTEX(&macp->bcn_sem);
+        init_MUTEX(&macp->config_sem);
+
+        spin_lock_init(&(macp->intr_lock));
+        spin_lock_init(&(macp->q_lock));
+        spin_lock_init(&(macp->cs_lock));
+
+        INIT_WORK(&macp->kevent, kevent, macp);
+        INIT_WORK(&macp->scan_tout_event, kevent, macp);
+
+        macp->numTcb = NUM_TCB;
+        macp->numTbd = NUM_TBD;
+        macp->numRfd = NUM_RFD;
+        macp->numTbdPerTcb = NUM_TBD_PER_TCB;
+        macp->rxOffset  = ZD_RX_OFFSET;
+        macp->rfd_size = 24; // form CbStatus to NextCbPhyAddrHighPart
+
+        init_timer(&macp->watchdog_timer);
+        macp->watchdog_timer.data = (unsigned long) dev;
+
+        macp->watchdog_timer.function = (void *) &zd1205_watchdog_cb;
+
+        init_timer(&macp->tm_hking_id);
+        macp->tm_hking_id.data = (unsigned long) dev;
+        macp->tm_hking_id.function = (void *) &HKeepingCB;
+
+        init_timer(&macp->tm_mgt_id);
+        macp->tm_mgt_id.data = (unsigned long) dev;
+        macp->tm_mgt_id.function = (void *) &zd1205_mgt_mon_cb;
+
+        /* ath_desc: AMD64 support */
+        macp->USBCSRAddress = 0x9000;
+        dot11Obj.reg = macp->regp=(void *)0x9000;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+
+        macp->in_interval = 10;
+#else
+
+        macp->in_interval = 10;
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+
+        usb_fill_int_urb(macp->intr_urb, macp->usb,
+                         usb_rcvintpipe(macp->usb, EP_INT_IN),
+                         macp->IntEPBuffer, MAX_EPINT_BUFFER,
+                         zd1211_intr_cb, macp, macp->in_interval);
+#else  //fake it
+
+        usb_fill_bulk_urb(macp->intr_urb, macp->usb,
+                          usb_rcvbulkpipe(macp->usb, EP_INT_IN),
+                          macp->IntEPBuffer, MAX_EPINT_BUFFER,
+                          zd1211_intr_cb, macp);
+#endif
+
+#if 1//(LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+
+        macp->intr_urb->transfer_flags |= URB_ASYNC_UNLINK;
+#else
+
+        macp->intr_urb->transfer_dma = macp->IntBufferHandle;
+        macp->intr_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+#endif
+
+        if ((res = SUBMIT_URB(macp->intr_urb, GFP_KERNEL)))
+        {
+                printk(KERN_ERR "zd1211: failed intr_urb\n");
+                zd1211_DumpErrorCode(macp, res);
+                return false;
+        }
+        zd1205_init(macp);
+
+        dev->open = zd1205_open;
+        dev->stop = zd1205_close;
+        dev->watchdog_timeo = ZD1211_TX_TIMEOUT;
+        dev->do_ioctl = zd1205_ioctl;
+
+#if WIRELESS_EXT > 12
+
+        dev->wireless_handlers = (struct iw_handler_def *)&p80211wext_handler_def;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+        /* ath_desc: added iw_get_stats */
+        /* ath: using p80211wext_handler_def.get_wireless_stats in 2.6.10+ */
+        dev->get_wireless_stats = &zd1205wext_iw_get_stats;
+#endif
+#endif
+
+        dev->hard_start_xmit = zd1205_xmit_frame;
+        dev->set_multicast_list = zd1205_set_multi;
+        dev->get_stats = zd1205_get_stats;
+#if ZDCONF_WE_STAT_SUPPORT == 1
+
+        dev->get_wireless_stats = zd1205_iw_getstats;
+#elif !defined(ZDCONF_WE_STAT_SUPPORT)
+	#error "Undefine ZDCONF_WE_STAT_SUPPORT"
+#endif
+
+        dev->mtu = ZD1211_MTU;
+        dev->set_mac_address = zd1205_set_mac;
+        dev->tx_timeout = &zd1211_tx_timeout;
+
+        //dev->features |= NETIF_F_SG | NETIF_F_HW_CSUM;
+        dev->flags |= IFF_MULTICAST;
+
+        //memcpy(macp->ifname, dev->name, IFNAMSIZ);
+        //macp->ifname[IFNAMSIZ-1] = 0;
+
+        ZEXIT(1);
+        return true;
+}
+
+int zd1211_alloc_all_urbs(struct zd1205_private *macp) {
+        struct usb_interface *interface = macp->interface;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+
+        struct usb_interface_descriptor *iface_desc = &interface->altsetting[0];
+#else
+
+        struct usb_host_interface *iface_desc = &interface->altsetting[0];
+#endif
+
+        struct usb_endpoint_descriptor *endpoint;
+        struct usb_endpoint_descriptor *interrupt_in_endpoint[MAX_NUM_PORTS];
+        struct usb_endpoint_descriptor *interrupt_out_endpoint[MAX_NUM_PORTS];
+        struct usb_endpoint_descriptor *bulk_in_endpoint[MAX_NUM_PORTS];
+
+        struct usb_endpoint_descriptor *bulk_out_endpoint[MAX_NUM_PORTS];
+
+        u8 num_bulk_in = 0;
+        u8 num_bulk_out = 0;
+
+        u8 num_interrupt_in = 0;
+        u8 num_interrupt_out = 0;
+
+        int i;
+
+
+        /* descriptor matches, let's find the endpoints needed */
+        /* check out the endpoints */
+        //ZD1211DEBUG(2, "bNumEndpoints = %d\n", iface_desc->bNumEndpoints);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+
+        for (i = 0; i < iface_desc->bNumEndpoints; ++i)
+        {
+
+                endpoint = &iface_desc->endpoint[i];
+#else
+
+        for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
+                endpoint = &iface_desc->endpoint[i].desc;
+#endif
+
+                if ((endpoint->bEndpointAddress & 0x80) &&
+
+
+                                ((endpoint->bmAttributes & 3) == 0x02)) {
+
+                        /* we found a bulk in endpoint */
+                        bulk_in_endpoint[num_bulk_in] = endpoint;
+                        ++num_bulk_in;
+
+
+/* ath: USB config fields are le16 on kernels >= 2.6.11 only */
+/* ath: see Greg Kroah-Hartman, http://kernel.org/pub/linux/kernel/v2.6/testing/ChangeLog-2.6.11-rc1 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11))
+                        macp->wMaxPacketSize = le16_to_cpu(endpoint->wMaxPacketSize);
+                        ZD1211DEBUG(0, "bulk in: wMaxPacketSize = %x\n", le16_to_cpu(endpoint->wMaxPacketSize));
+#else
+                        macp->wMaxPacketSize = endpoint->wMaxPacketSize;
+                        ZD1211DEBUG(0, "bulk in: wMaxPacketSize = %x\n", endpoint->wMaxPacketSize);
+#endif
+                }
+
+
+
+                if (((endpoint->bEndpointAddress & 0x80) == 0x00) &&
+                                ((endpoint->bmAttributes & 3) == 0x02)) {
+                        /* we found a bulk out endpoint */
+                        bulk_out_endpoint[num_bulk_out] = endpoint;
+                        ++num_bulk_out;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11))
+                        ZD1211DEBUG(0, "bulk out: wMaxPacketSize = %x\n", le16_to_cpu(endpoint->wMaxPacketSize));
+#else
+                        ZD1211DEBUG(0, "bulk out: wMaxPacketSize = %x\n", endpoint->wMaxPacketSize);
+#endif
+
+                }
+
+                if ((endpoint->bEndpointAddress & 0x80) &&
+
+
+                                ((endpoint->bmAttributes & 3) == 0x03)) {
+                        /* we found a interrupt in endpoint */
+                        interrupt_in_endpoint[num_interrupt_in] = endpoint;
+                        ++num_interrupt_in;
+                        macp->in_interval = endpoint->bInterval;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11))
+                        ZD1211DEBUG(0, "interrupt in: wMaxPacketSize = %x\n", le16_to_cpu(endpoint->wMaxPacketSize));
+#else
+                        ZD1211DEBUG(0, "interrupt in: wMaxPacketSize = %x\n", endpoint->wMaxPacketSize);
+#endif
+
+                        ZD1211DEBUG(0, "interrupt in: int_interval = %d\n", endpoint->bInterval);
+
+                }
+
+                if (((endpoint->bEndpointAddress & 0x80) == 0x00) &&
+                                ((endpoint->bmAttributes & 3) == 0x03)) {
+                        /* we found a interrupt out endpoint */
+                        interrupt_out_endpoint[num_interrupt_out] = endpoint;
+                        ++num_interrupt_out;
+                        macp->ep4isIntOut = 0;//1;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11))
+                        ZD1211DEBUG(0, "interrupt out: wMaxPacketSize = %x\n", le16_to_cpu(endpoint->wMaxPacketSize));
+#else
+                        ZD1211DEBUG(0, "interrupt out: wMaxPacketSize = %x\n", endpoint->wMaxPacketSize);
+#endif
+                        macp->out_interval = endpoint->bInterval;
+                }
+        }
+
+
+        macp->num_bulk_in = num_bulk_in;
+        macp->num_bulk_out = num_bulk_out;
+        macp->num_interrupt_in = num_interrupt_in;
+
+        macp->num_interrupt_out = num_interrupt_out;
+
+
+        macp->rx_urb = USB_ALLOC_URB(0, GFP_KERNEL);
+        if (!macp->rx_urb)
+                return 0;
+
+        macp->tx_urb = USB_ALLOC_URB(0, GFP_KERNEL);
+        if (!macp->tx_urb) {
+                usb_free_urb(macp->rx_urb);
+                return 0;
+        }
+
+
+        macp->intr_urb = USB_ALLOC_URB(0, GFP_KERNEL);
+        if (!macp->intr_urb) {
+
+                usb_free_urb(macp->rx_urb);
+                usb_free_urb(macp->tx_urb);
+                return 0;
+        }
+
+        macp->ctrl_urb = USB_ALLOC_URB(0, GFP_KERNEL);
+        if (!macp->ctrl_urb) {
+                usb_free_urb(macp->rx_urb);
+                usb_free_urb(macp->tx_urb);
+                usb_free_urb(macp->intr_urb);
+                return 0;
+
+
+        }
+
+
+        macp->reg_urb = USB_ALLOC_URB(0, GFP_KERNEL);
+        if (!macp->reg_urb) {
+                usb_free_urb(macp->rx_urb);
+                usb_free_urb(macp->tx_urb);
+                usb_free_urb(macp->intr_urb);
+                usb_free_urb(macp->ctrl_urb);
+                return 0;
+        }
+
+#if 0//(LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+    #if 1
+        macp->IntEPBuffer = kmalloc(MAX_EPINT_BUFFER, GFP_KERNEL);
+
+#else //always failed? why???
+
+        macp->IntEPBuffer = usb_buffer_alloc(macp->device,
+                                             MAX_EPINT_BUFFER,
+                                             GFP_KERNEL,
+                                             &macp->IntBufferHandle);
+#endif
+
+        if (!macp->IntEPBuffer) {
+                FPRINT("usb_buffer_alloc failed");
+                usb_free_urb(macp->rx_urb);
+                usb_free_urb(macp->tx_urb);
+                usb_free_urb(macp->intr_urb);
+                usb_free_urb(macp->ctrl_urb);
+
+                usb_free_urb(macp->reg_urb);
+                return 0;
+        }
+#endif
+
+        return 1;
+}
+
+
+
+
+void zd1211_free_all_urbs(struct zd1205_private *macp)
+
+{
+
+
+        if (macp->rx_urb)
+                usb_free_urb(macp->rx_urb);
+        if (macp->tx_urb)
+
+                usb_free_urb(macp->tx_urb);
+        if (macp->intr_urb)
+
+                usb_free_urb(macp->intr_urb);
+        if 	(macp->ctrl_urb)
+                usb_free_urb(macp->ctrl_urb);
+        if 	(macp->reg_urb)
+                usb_free_urb(macp->reg_urb);
+
+#if 0//(LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+
+        if (macp->IntEPBuffer)
+#if 1
+
+                kfree(macp->IntEPBuffer);
+#else
+
+                usb_buffer_free(macp->device,
+                                MAX_EPINT_BUFFER,
+                                (void *)macp->IntEPBuffer,
+
+                                macp->IntBufferHandle);
+#endif
+#endif
+}
+
+
+void zd1211_unlink_all_urbs(struct zd1205_private *macp)
+{
+        ZD_USB_KILL_URB(macp->rx_urb);
+        ZD_USB_KILL_URB(macp->tx_urb);
+        ZD_USB_KILL_URB(macp->ctrl_urb);
+        ZD_USB_KILL_URB(macp->reg_urb);
+
+        if (test_bit(ZD1211_UNPLUG, &macp->flags))
+                ZD_USB_KILL_URB(macp->intr_urb);
+}
+
+#define MAX_RX_MERGE_PACKET_NUM		3
+void zd1211_rx_isr(unsigned long parm)
+{
+        struct zd1205_private *macp = (struct zd1205_private *)parm;
+        struct urb *urb = macp->read_urb;
+        struct rx_list_elem *rx_struct;
+#if fMERGE_RX_FRAME
+
+        struct rx_list_elem *rx_struct_array[MAX_RX_MERGE_PACKET_NUM];
+        int total_rx_struct = 1, rx_array_cnt = 0;
+        int i;
+        u32 tmpLen = 0;
+        u16 last_pkt_len;
+#endif
+
+        u32 TotalLength = urb->actual_length;
+        u8 *pRxBuffer;
+        struct sk_buff *skb;
+        zd1205_RFD_t *rfd = NULL;
+
+        spin_lock(&macp->intr_lock);
+
+        ZD1211DEBUG(4, "actual_length = %x\n", urb->actual_length);
+        rx_struct = list_entry(macp->active_rx_list.next,
+                               struct rx_list_elem, list_elem);
+
+        skb = rx_struct->skb;
+        rfd = RFD_POINTER(skb, macp);
+        pRxBuffer = &rfd->RxBuffer[macp->rxOffset];
+
+#if 0
+        //for debug only
+        zd1205_dump_data("pRxBuffer", (u8 *)pRxBuffer, TotalLength);
+        //zd1211_submit_rx_urb(macp);
+        //return;
+#endif
+
+#if fMERGE_RX_FRAME
+
+        if (rx_struct->UnFinishFrmLen) {
+                TotalLength += rx_struct->UnFinishFrmLen;
+                rx_struct->UnFinishFrmLen = 0;
+                macp->CompLenInfoCnt++;
+                //ZD1211DEBUG(0, "Got Rx Frames Length Info!!\n");
+        }
+
+        last_pkt_len = TotalLength & (macp->wMaxPacketSize - 1);
+
+        if (last_pkt_len <= (macp->wMaxPacketSize - 4)) {
+                if (le16_to_cpu(((u16 *) pRxBuffer)[TotalLength / sizeof(u16) - 1]) == 0x697E) {
+                        total_rx_struct = 3;
+                        //ZD1211DEBUG(0, "Got merged Rx Frames!!\n");
+                        //zd1205_dump_data("pRxBuffer", (u8 *)pRxBuffer, TotalLength);
+                        macp->Continue2Rx++;
+                } else
+                        macp->NoMergedRxCnt++;
+
+                //ZD1211DEBUG(3, "last_pkt_len = %x\n", last_pkt_len);
+                //zd1205_dump_data("pRxBuffer", (u8 *)pRxBuffer, TotalLength);
+
+                for (i=0; i<total_rx_struct; i++) {
+                        int CurFrmLen;
+
+                        if (total_rx_struct> 1) {
+                                CurFrmLen = cpu_to_le16(((u16 *) pRxBuffer)[TotalLength / sizeof(u16) + i - 4]);
+                                //ZD1211DEBUG(2, "CurFrmLen = %x\n", CurFrmLen);
+                        } else
+                                CurFrmLen = TotalLength;
+
+                        if (CurFrmLen == 0) {
+                                break;
+                        }
+
+                        rx_struct_array[i] = list_entry(macp->active_rx_list.next,
+                                                        struct rx_list_elem, list_elem);
+                        list_del(&(rx_struct_array[i]->list_elem));
+                        rx_array_cnt++;
+
+                        ZD1211DEBUG(2, "CurFrmLen = %x\n", CurFrmLen);
+
+                        skb = rx_struct_array[i]->skb;
+                        rfd = RFD_POINTER(skb, macp);
+
+                        rfd->CbStatus = cpu_to_le32(RFD_STATUS_COMPLETE);
+                        rfd->ActualCount = cpu_to_le32(CurFrmLen);
+
+                        if (i > 0) {
+                                memcpy(&rfd->RxBuffer[macp->rxOffset],
+                                       pRxBuffer + tmpLen,
+                                       CurFrmLen);
+                        }
+
+                        tmpLen += (CurFrmLen & ~0x03);
+
+                        if (CurFrmLen & 0x03)
+                                tmpLen += 4;
+                        rfd->ActualCount += macp->rxOffset;
+                }
+        } else {
+                // last_pkt_len = 509, 510, 511
+                // wait next Rx
+                //ZD1211DEBUG(0, "Wait Rx Frames Length Info!!\n");
+                //ZD1211DEBUG(2, "last_pkt_len = %x\n", last_pkt_len);
+                macp->WaitLenInfoCnt++;
+                rx_struct->UnFinishFrmLen = ((TotalLength / macp->wMaxPacketSize) + 1)
+                                            * (macp->wMaxPacketSize);
+                //zd1205_dump_data("pRxBuffer", (u8 *)pRxBuffer, TotalLength);
+        }
+
+
+        zd1211_submit_rx_urb(macp);
+
+        if (!rx_struct->UnFinishFrmLen) {
+                macp->total_rx_cnt = rx_array_cnt;
+                macp->rx_struct_array = rx_struct_array;
+                zd1205_rx_isr(macp);
+        }
+
+
+#else
+        rfd->CbStatus = cpu_to_le32(RFD_STATUS_COMPLETE);
+        rfd->ActualCount = cpu_to_le32(TotalLength + macp->rxOffset);
+        zd1205_rx_isr(macp);
+#endif
+
+        if (dot11Obj.QueueFlag & MGT_QUEUE_SET)
+                defer_kevent(macp, KEVENT_PROCESS_SIGNAL);
+        spin_unlock(&macp->intr_lock);
+}
+
+
+
+
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+void zd1211_rx_comp_cb(struct urb *urb)
+#else
+void zd1211_rx_comp_cb(struct urb *urb, struct pt_regs *regs)
+#endif
+
+
+
+
+{
+        struct zd1205_private *macp = urb->context;
+
+
+
+        if ((!macp) || !test_bit(ZD1211_RUNNING, &macp->flags))
+
+                return;
+
+
+        if (!netif_device_present(macp->device))
+                return;
+
+        if (urb->status != 0)
+        {
+                zd1211_DumpErrorCode(macp, urb->status);
+                if ((urb->status != -ENOENT) &&
+
+                                (urb->status != -ECONNRESET) &&
+
+                                (urb->status != -ESHUTDOWN)) {
+                        //printk("nonzero read bulk status received: %d\n", urb->status);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+                        if (urb->status == USB_ST_INTERNALERROR)
+
+                                return;
+
+#else
+
+                        if (urb->status == -EPIPE) {
+                                printk("nonzero read bulk status received: -EPIPE\n");
+                                return;
+                        }
+
+                        if (urb->status == -EPROTO) {
+                                printk("nonzero read bulk status received: -EPROTO\n");
+                                return;
+                        }
+
+
+
+#endif
+
+
+                        zd1211_submit_rx_urb(macp);
+                        return;
+                }
+                return;
+
+        }
+
+
+        if (urb->actual_length == 0)
+        {
+                FPRINT("Got Length = 0");
+
+                zd1211_submit_rx_urb(macp);
+                return;
+        }
+
+
+        macp->read_urb = urb;
+        zd1211_rx_isr((unsigned long) macp);
+
+}
+
+
+
+
+
+//callback function for interrupt or response
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+void zd1211_intr_cb(struct urb *urb)
+#else
+void zd1211_intr_cb(struct urb *urb, struct pt_regs *regs)
+#endif
+{
+        struct zd1205_private *macp = urb->context;
+        u16 intNum;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+        int status;
+#endif
+        u32 actual_length = urb->actual_length;
+
+        if (!macp)
+                return;
+
+        spin_lock(&macp->intr_lock);
+
+        if (urb->status != 0)
+        {
+                zd1211_DumpErrorCode(macp, urb->status);
+
+                if (urb->status == -ENODEV) { //device was removed
+                        FPRINT("Device was removed!!!");
+                        macp->bUSBDeveiceAttached = 0;
+
+                        wake_up(&macp->regSet_wait);
+                        wake_up_interruptible(&macp->iorwRsp_wait);
+
+                        spin_unlock(&macp->intr_lock);
+                        return;
+                }
+
+                switch (urb->status) {
+                case -ECONNRESET:
+                case -ENOENT:
+                case -ESHUTDOWN:
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+
+                case -EPROTO:
+#endif
+
+                        macp->bUSBDeveiceAttached = 0;
+                        FPRINT("Device was down!!!");
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+
+                        spin_unlock(&macp->intr_lock);
+                        return;
+#endif
+
+                        break;
+
+                default:
+                        //printk("nonzero intr status received: %d\n", urb->status);
+                        break;
+                }
+
+        } else
+        {
+                if (macp->IntEPBuffer[0] != 0x01)
+                        FPRINT("Got unknown packet");
+
+                switch (macp->IntEPBuffer[1]) {
+                case EPINT_IORDRsp:
+
+                        // this is USB_READ_REGISTER response
+                        macp->ReadRegCount = (u16)actual_length;
+
+                        intNum = le16_to_cpu(*(u16 *)(macp->IntEPBuffer+2));
+                        //intNum = macp->IntEPBuffer[2] + (((u16)macp->IntEPBuffer[3]) << 8);
+
+                        if (intNum == (InterruptCtrl | macp->USBCSRAddress)) {
+                                // Handle non-RxTx interrupt
+                                if (macp->bHandleNonRxTxRunning) {
+                                        printk("Impossible, interrupt happen!!!!! %x\n", intNum);
+                                        break;
+                                }
+
+                                // disable non-RxTx interrupt
+                                // No needed to diable interrupt, firmware will do it.
+                                macp->bHandleNonRxTxRunning = 1;
+                                memcpy(macp->IntEPBuffer3, macp->IntEPBuffer, MAX_EPINT_BUFFER);
+                                defer_kevent(macp, KEVENT_NON_TX_RX_INT);
+
+                        } else {
+                                // handle read register
+                                memcpy(macp->IntEPBuffer2, macp->IntEPBuffer, MAX_EPINT_BUFFER);
+                                set_bit(ZD1211_REQ_COMP, &macp->flags);
+                                wake_up_interruptible(&macp->iorwRsp_wait);
+                        }
+                        break;
+
+                case EPINT_RetryFial_Event: {
+                                u8 *pMacAddr = macp->IntEPBuffer + 4;
+                                /* ath: not endian safe! u8 NewRate = (u8)(*(u16 *)(macp->IntEPBuffer + 2)); */
+                                //u8 NewRate = macp->IntEPBuffer[2];
+                                u16 aid;
+
+#if fTX_PWR_CTRL
+
+                                if (macp->TxOFDMType >= cTX_48M)
+                                        macp->TxOFDMCnt = 0;
+#endif
+
+                                if ( macp->IntEPBuffer[10] & BIT_0 )
+
+                                        macp->bIBSS_Wakeup_Dest = 1;
+
+
+                                //ZD1211DEBUG(2, "Retry Failed!!!\n");
+                                //ZD1211DEBUG(2, "NewRate = %x\n", NewRate);
+                                aid = zd_AidLookUp(pMacAddr);
+                                zd_EventNotify(EVENT_TX_COMPLETE, ZD_RETRY_FAILED, 0xff, (U32)aid);
+                                macp->retryFailCnt +=  le16_to_cpu(*(u16 *)(macp->IntEPBuffer + 10));
+                                break;
+
+                        }
+
+
+                default:
+                        FPRINT("Got Unknown interrupt!!!");
+                        break;
+                }
+
+        }
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+#if 1
+        //memset(macp->IntEPBuffer, 0x0, MAX_EPINT_BUFFER);
+
+        //use bulk instead of interrupt in
+        usb_fill_bulk_urb(macp->intr_urb, macp->usb,
+                          usb_rcvbulkpipe(macp->usb, EP_INT_IN),
+                          macp->IntEPBuffer, MAX_EPINT_BUFFER,
+                          zd1211_intr_cb, macp);
+
+        macp->intr_urb->transfer_flags |= URB_ASYNC_UNLINK;
+        status = SUBMIT_URB(macp->intr_urb, GFP_ATOMIC);
+#else
+
+        status = SUBMIT_URB(urb, GFP_ATOMIC);
+#endif
+
+        if (status)
+                FPRINT("Can't resubmit interrupt urb!!!");
+#endif
+
+        spin_unlock(&macp->intr_lock);
+
+        return;
+}
+
+
+//callback function for register get/set
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+void zd1211_reg_cb(struct urb *urb)
+#else
+void zd1211_reg_cb(struct urb *urb, struct pt_regs *regs)
+#endif
+{
+        struct zd1205_private *macp = urb->context;
+        set_bit(ZD1211_CMD_FINISH, &macp->flags);
+        wake_up(&macp->regSet_wait);
+}
+
+void zd1211_handle_non_tx_rx(struct zd1205_private *macp)
+{
+        u32	intr_status;
+        // in current design, no need to use spinlock
+
+        intr_status = le16_to_cpu(*(u16 *)(macp->IntEPBuffer3+4));
+        //ZD1211DEBUG(2, "intr_status = %x\n", intr_status);
+
+        if (!intr_status)
+                return;
+
+        if (intr_status & WAKE_UP)
+        {
+                ZD1211DEBUG(1, "WAKE_UP\n");
+                //printk(KERN_ERR "befor1 : %lu\n", jiffies);
+                down(&macp->ps_sem);
+                //printk(KERN_ERR "before2: %lu\n", jiffies);
+                if (dot11Obj.bDeviceInSleep) {
+                        zd1205_process_wakeup(macp);
+                }
+
+                //printk(KERN_ERR "after2: %lu\n", jiffies);
+                up(&macp->ps_sem);
+                //printk(KERN_ERR "after1: %lu\n", jiffies);
+
+        }
+
+        if (intr_status & CFG_NEXT_BCN)
+        {
+                //ZD1211DEBUG(2, "CFG_NEXT_BCN\n");
+                if (macp->config_next_bcn_en) {
+                        if (macp->cardSetting.BssType == AP_BSS)
+                                goto done;
+
+                        macp->bcnCnt++;
+                        down(&macp->bcn_sem);
+                        zd_EventNotify(EVENT_TBCN, 0, 0, 0);
+                        up(&macp->bcn_sem);
+
+                        if (macp->cardSetting.BssType == INDEPENDENT_BSS) {
+                                macp->bFrmRxed1 = 0;
+                        }
+#if 0
+                        else if (macp->cardSetting.BssType == AP_BSS) {
+                                if (macp->dtimCount == 0)
+                                        macp->dtimCount = macp->cardSetting.DtimPeriod;
+                                macp->dtimCount--;
+                        }
+#endif
+
+                }
+        }
+
+        if (intr_status & DTIM_NOTIFY)
+        {
+                ZD1211DEBUG(2, "DTIM_NOTIFY\n");
+                if (macp->dtim_notify_en) {
+                        macp->dtimCnt++;
+                        zd_EventNotify(EVENT_DTIM_NOTIFY, 0, 0, 0);
+                }
+        }
+
+done:
+        macp->bHandleNonRxTxRunning = 0;
+
+        // enable non-RxTx interrupt
+        zd1205_enable_int();
+        return;
+}
+
+int zd1211_submit_rx_urb(struct zd1205_private *macp)
+{
+        struct rx_list_elem *rx_struct = NULL;
+        u8 *rx_buff = NULL;
+        u32 bufLen = MAX_WLAN_SIZE - macp->rxOffset;
+        int res;
+        //int memflags = GFP_KERNEL;
+
+
+
+        rx_struct = zd1205_start_ru(macp);
+
+        if (!rx_struct)
+                return 1;
+
+#if fMERGE_RX_FRAME
+
+        if (rx_struct->UnFinishFrmLen)
+        {
+                rx_buff = (u8 *)(rx_struct->dma_addr)+ macp->rxOffset + (rx_struct->UnFinishFrmLen);
+                bufLen -= (rx_struct->UnFinishFrmLen);
+        } else
+                rx_buff = (u8 *)(rx_struct->dma_addr) + macp->rxOffset;
+
+
+#else
+
+        rx_buff = (u8 *)(rx_struct->dma_addr) + macp->rxOffset;
+#endif
+
+
+        usb_fill_bulk_urb(macp->rx_urb, macp->usb,
+                          usb_rcvbulkpipe(macp->usb, EP_DATA_IN),
+                          rx_buff, bufLen,
+
+                          zd1211_rx_comp_cb, macp);
+
+
+        macp->rx_urb->transfer_flags |= URB_ASYNC_UNLINK;
+        if ((res = SUBMIT_URB(macp->rx_urb, GFP_ATOMIC)))
+        {
+                printk(KERN_ERR "zd1211: failed rx_urb\n");
+                zd1211_DumpErrorCode(macp, res);
+        }
+
+
+
+        return 0;
+}
+
+
+
+void zd1211_tx_isr(unsigned long parm)
+{
+        struct zd1205_private *macp = (struct zd1205_private *)parm;
+        zd1205_SwTcb_t *sw_tcb;
+
+        ZENTER(3);
+
+        spin_lock(&macp->intr_lock);
+
+
+        sw_tcb = macp->activeTxQ->first;
+        if (sw_tcb)
+                sw_tcb->pTcb->CbStatus = cpu_to_le32(CB_STATUS_COMPLETE);
+
+        zd1205_tx_isr(macp);
+
+#if 0
+
+        if (dot11Obj.QueueFlag & TX_QUEUE_SET) {
+                macp->txQueSetCnt++;
+
+                tasklet_schedule(&macp->zd1205_tx_tasklet);
+        }
+#endif
+
+
+        spin_unlock(&macp->intr_lock);
+
+        ZEXIT(3);
+
+}
+
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+void zd1211_tx_comp_cb(struct urb *urb)
+#else
+void zd1211_tx_comp_cb(struct urb *urb, struct pt_regs *regs)
+
+#endif
+{
+        struct zd1205_private *macp = urb->context;
+
+
+        if ((!macp) || !test_bit(ZD1211_RUNNING, &macp->flags))
+        {
+                printk(KERN_ERR "macp is NULL or macp.flags.ZD1211_RUNNING\n");
+                return;
+        }
+
+        if (!netif_device_present(macp->device))
+        {
+                printk(KERN_ERR "netif_device_present return NULL\n");
+                return;
+        }
+
+        if (urb->status)
+        {
+                /* ath_desc: fix printks */
+                printk(KERN_ERR "Tx status: %d\n", urb->status);
+                zd1211_DumpErrorCode(macp, urb->status);
+        }
+
+        macp->usbTxCompCnt++;
+        clear_bit(ZD1211_TX_BUSY, &macp->flags);
+
+        macp->TxStartTime = 0;
+
+        macp->write_urb = urb;
+
+        zd1211_tx_isr((unsigned long) macp);
+
+        return;
+}
+
+
+
+
+
+
+// return send_length
+int zd1211_submit_tx_urb(struct zd1205_private *macp,BOOLEAN LastFrag)
+{
+        u8 *dst = macp->tx_buff;
+
+
+        u32 TotalLength = 0;
+
+        zd1205_Ctrl_Set_t *pCtrlSet;
+        zd1205_TBD_t *Tbd;
+        zd1205_SwTcb_t *sw_tcb;
+        int res;
+        //int memflags = GFP_KERNEL;
+
+
+
+        if (!macp->activeTxQ->count)
+        {
+                return 0;
+
+        }
+
+        if (test_bit(ZD1211_TX_BUSY, &macp->flags))
+                return 0;
+
+        ZENTER(3);
+
+        sw_tcb = macp->activeTxQ->first;
+        pCtrlSet = sw_tcb->pHwCtrlPtr;
+        Tbd = sw_tcb->pFirstTbd;
+
+        // We skip TCB address, Address 1, NextLength = 16 bytes, add 2 bytes for total length
+        //pCtrlSet->CtrlSetting[23]=0;
+        //pCtrlSet->CtrlSetting[24]=0;
+
+        memcpy(dst, (u8 *)(pCtrlSet), 3);
+        dst += 3;
+
+        TotalLength += 3;
+
+        memcpy(dst,	(u8 *)(pCtrlSet)+(3+8),	// 8 mean skip TCB address
+
+               1);					// misc
+
+        dst += 1;
+
+
+        TotalLength += 1;
+
+
+        dst += 2;							// reserver 2 bytes for total length
+
+        TotalLength += 2;
+
+
+
+        memcpy(dst,	(u8 *)(pCtrlSet)+(3+8+1+6+2),	// 6:skip address 1, 2:skip next length
+               5);
+
+        dst += 5;
+
+        TotalLength += 5;
+
+        ZD1211DEBUG(2, "Tx Ctrl Length = %x\n", TotalLength);
+
+        Tbd++;
+
+        /* ath_desc: removed "Non-Zero Duration" debug output */
+        #if 0
+        //Mac Header
+        if(*(u8 *)(le32_to_cpu(Tbd->TbdBufferAddrLowPart)+2)!=0)
+        {
+                if(macp->bPSMSupported != 1)
+                        *(u16 *)(le32_to_cpu(Tbd->TbdBufferAddrLowPart)+2)=0;
+                //printk("Non-Zero Duration,%d\n",*(u16 *)(le32_to_cpu(Tbd->TbdBufferAddrLowPart)+2));
+                //printk("\n OK\n");
+        } else if(*(u8 *)(le32_to_cpu(Tbd->TbdBufferAddrLowPart)+3)!=0)
+        {
+                if(macp->bPSMSupported != 1)
+                        *(u16 *)(le32_to_cpu(Tbd->TbdBufferAddrLowPart)+2)=0;
+                //printk("Non-Zero Duration,%d\n",*(u16 *)(le32_to_cpu(Tbd->TbdBufferAddrLowPart)+2));
+                //printk("\n OK\n");
+        }
+        #endif
+
+
+#ifndef __LP64__
+        memcpy(dst, (u8 *)le32_to_cpu(Tbd->TbdBufferAddrLowPart), le32_to_cpu(Tbd->TbdCount));
+
+#else
+        memcpy(dst, (u8 *)le64_to_cpu(Tbd->TbdBufferAddr), le32_to_cpu(Tbd->TbdCount));
+#endif
+        ZD1211DEBUG(2, "MAC Header Length = %x\n", le32_to_cpu(Tbd->TbdCount));
+        dst += le32_to_cpu(Tbd->TbdCount);
+
+        TotalLength += le32_to_cpu(Tbd->TbdCount);
+
+        Tbd++;
+
+        //MAC Body
+#ifndef __LP64__
+        memcpy(dst, (u8 *)le32_to_cpu(Tbd->TbdBufferAddrLowPart), le32_to_cpu(Tbd->TbdCount));
+
+#else
+        memcpy(dst, (u8 *)le64_to_cpu(Tbd->TbdBufferAddr), le32_to_cpu(Tbd->TbdCount));
+#endif
+        ZD1211DEBUG(2, "Tx DATA Length = %x\n", le32_to_cpu(Tbd->TbdCount));
+        dst += le32_to_cpu(Tbd->TbdCount);
+
+
+        TotalLength += le32_to_cpu(Tbd->TbdCount);
+        Tbd++;
+
+        ZD1211DEBUG(2, "TotalLength = %x\n", TotalLength);
+
+        if(LastFrag == TRUE)
+        {
+                memcpy(dst-sw_tcb->MIC_Len,sw_tcb->CalMIC+sw_tcb->MIC_Start,sw_tcb->MIC_Len);
+
+        }
+
+
+
+        // write down total length
+#ifdef ZD1211
+        *((u16 *)(macp->tx_buff+4)) = cpu_to_le16((u16)TotalLength + 14);
+#elif defined(ZD1211B)
+
+        *((u16 *)(macp->tx_buff+4)) = cpu_to_le16(sw_tcb->LengthDiff);
+#endif
+
+        ZD1211DEBUG(2, "macp->tx_buff+4 = %x\n", le16_to_cpu(*((u16 *)(macp->tx_buff+4))));
+
+
+        usb_fill_bulk_urb(macp->tx_urb, macp->usb,
+                          usb_sndbulkpipe(macp->usb, EP_DATA_OUT),
+                          macp->tx_buff, TotalLength,
+                          zd1211_tx_comp_cb, macp);
+
+
+
+        macp->tx_urb->transfer_buffer_length = TotalLength;
+
+        macp->tx_urb->transfer_flags |= URB_ASYNC_UNLINK;
+        res = SUBMIT_URB(macp->tx_urb, GFP_ATOMIC);
+        if (res)
+        {
+
+                printk("error in tx submit urb: %d", res);
+                zd1211_DumpErrorCode(macp, res);
+                goto err;
+        }
+
+        macp->usbTxCnt++;
+
+        set_bit(ZD1211_TX_BUSY, &macp->flags);
+
+
+
+
+        ZEXIT(3);
+
+        return TotalLength;
+
+
+
+err:
+        return 0;
+}
+
+
+
+void zd1211_disable_net_traffic(struct zd1205_private *macp)
+{
+
+        // When suspend, call this
+        if ( macp->RF_Mode == AL2230_RF )
+                HW_Set_IF_Synthesizer(&dot11Obj, 0x71687);
+
+        LockPhyReg(&dot11Obj);
+        zd_writel(0xFF, ZD_CR252);
+        zd_writel(0xc, ZD_CR253);
+
+
+
+        zd_writel(0x3, ZD_CR255);
+        UnLockPhyReg(&dot11Obj);
+
+
+        zd_writel(0x0, BCNInterval);
+        // Turn off LEDs
+
+        zd_writel(0x0, rLED_CTRL);
+
+        // turn of MAC
+        zd_writel(0x3, PS_Ctrl);
+
+
+
+
+        dot11Obj.PhyTest = 0;
+        macp->LinkTimer = 0;
+
+
+}
+
+
+#if 0
+int zd1211_DownLoadUSBCode(struct zd1205_private *macp, u8* filename, void *ptr, u16 uCodeOfst)
+{
+        int ifp;
+        long bcount;
+        mm_segment_t fs;
+
+        struct stat file_info;
+
+        size_t* file_length;
+
+        u8 *buffer;
+
+        //FPRINT("DownLoadUSBCode");
+
+        // Open the code file
+
+        // for file opening temporarily tell the kernel I am not a user for
+        // memory management segment access
+
+        fs = get_fs();
+        set_fs(KERNEL_DS);
+
+
+        // open the file with the firmware for uploading
+
+        if (ifp = open(filename, O_RDONLY, 0 ), ifp < 0)
+        {
+                // error opening the file
+                FPRINT("ERROR: File opening did not success");
+                set_fs(fs);
+                return -1;
+        }
+
+
+
+
+        /* Get information about the file. */
+        fstat (ifp, &file_info);
+        file_length = file_info.st_size;
+
+
+        buffer = kmalloc(file_length, GFP_ATOMIC);
+
+        /* Read the file into the buffer. */
+        bcount = read(ifp, buffer, file_length);
+
+        if (bcount != file_length)
+                FPRINT("read failed");
+
+
+
+        // close the file
+
+
+
+        close(ifp);
+
+        // switch back the segment setting
+
+        set_fs(fs);
+
+
+
+        ret = zd1211_LoadUSBSpecCode(macp, buffer, file_length, uCodeOfst, true);
+
+
+
+        kfree(buffer);
+
+
+
+
+        return ret;
+
+
+}
+#endif
+void ZD1211_WriteMultiRegister(u16 *Address, u16 *Value, u16 RegCount, BOOLEAN AddUSBCSRAddress)
+{
+        int count = 0;
+        u8 ret = 0xff;
+
+        while (ret != 0) {
+                ret = zd1211_USB_PACKAGE_WRITE_REGISTER(Address, Value, RegCount, AddUSBCSRAddress);
+                count++;
+
+                if (count > 5) {
+                        printk("ZD1211_WriteMultiRegister failed!!\n");
+                        break;
+                }
+        }
+}
+void ZD1211_WRITE_MULTI_REG(u16  *pAddress, u16  *pValue, u16  *pRegCount)
+{
+        u16 TotalRegCount = *pRegCount;
+        u16* pWriteAddr = pAddress;
+        u16* pWriteData = pValue;
+
+        while (TotalRegCount > cMAX_MULTI_WRITE_REG_NUM) {
+                ZD1211_WriteMultiRegister(pWriteAddr, pWriteData, cMAX_MULTI_WRITE_REG_NUM, true);
+
+                TotalRegCount -= cMAX_MULTI_WRITE_REG_NUM;
+                pWriteAddr += cMAX_MULTI_WRITE_REG_NUM;
+                pWriteData += cMAX_MULTI_WRITE_REG_NUM;
+        }
+
+        if (TotalRegCount)
+                ZD1211_WriteMultiRegister(pWriteAddr, pWriteData, TotalRegCount, true);
+
+        *pRegCount = 0;
+
+
+}
+int zd1211_GetUSBSpecData(struct zd1205_private *macp, u8 *pBuffer,
+                          u32 uImgLength, u16 uCodeOfst)
+
+{
+        u32 uCurLength;
+        int result = 0;
+        u8 *image, *ptr;
+        u32 uploadLength = uImgLength;
+
+
+        image = kmalloc(uImgLength, GFP_KERNEL);
+        ptr = image;
+
+        while (uImgLength > 0)
+        {
+                uCurLength = uImgLength;
+                if (uCurLength > 60)
+                        uCurLength = 60;
+
+                // Get data from device
+                result = usb_control_msg(macp->usb, usb_rcvctrlpipe(macp->usb, 0),
+                                         FIRMWARE_READ_DATA, USB_DIR_IN | 0x40, uCodeOfst, 0,
+
+
+
+                                         image, uCurLength, 1000 * HZ);
+
+                //ZD1211DEBUG(3, "result = %d\n", result);
+                if (result < 0) {
+                        printk(KERN_ERR "zd1211: usb_rcvctrlpipe 1 fail: %02X\n", result);
+                        goto exit;
+                }
+
+
+
+
+                /* ath_desc: fix update of uImgLength */
+                uImgLength -= result;
+                image += result;
+
+                uCodeOfst += (u16) (result / 2); // in Word (16 bit)
+                result = 0;
+
+        }
+
+        image -= uploadLength; //move to buffer head
+
+        memcpy(pBuffer, image, uploadLength);
+
+
+exit:
+        //kfree(image);
+        kfree(ptr);
+
+        return result ;
+}
+
+
+
+
+
+
+
+
+//return 0: success, others: fail
+int zd1211_LoadUSBSpecCode(struct zd1205_private *macp, u8 *pBuffer, u32 uImgLength,
+                           u16 uCodeOfst, u8 bReboot)
+{
+        u8 ret;
+        int result = 0;
+        u8 *image, *ptr;
+
+
+        ZD1211DEBUG(1, "uImgLength = %x\n", uImgLength);
+        image = kmalloc(uImgLength, GFP_KERNEL);
+        ptr = image;
+        memcpy(image, pBuffer, uImgLength);
+
+
+        while (uImgLength > 0)
+        {
+                int translen = (uImgLength > 4096) ? 4096 : uImgLength;
+
+                ZD1211DEBUG(1, "translen = %x\n", translen);
+                ZD1211DEBUG(1, "uCodeOfst = %x\n", uCodeOfst);
+
+
+                result = usb_control_msg(macp->usb, usb_sndctrlpipe(macp->usb, 0),
+                                         FIRMWARE_DOWNLOAD, USB_DIR_OUT | 0x40, uCodeOfst, 0,
+
+                                         image, translen, HZ);
+
+
+                ZD1211DEBUG(1, "result = %x\n", result);
+
+
+                if (result < 0) {
+                        printk(KERN_ERR "zd1211: usb_control_msg 1 fail: %02X\n", result);
+                        goto exit;
+                }
+
+
+                uImgLength -= translen;
+                image += translen;
+
+
+                uCodeOfst += (u16) (translen / 2); // in Word (16 bit)
+                result = 0;
+        }
+
+
+
+        if (bReboot)
+        {
+                result = usb_control_msg(macp->usb, usb_rcvctrlpipe(macp->usb, 0),
+                                         FIRMWARE_CONFIRM, USB_DIR_IN | 0x40, 0, 0,
+                                         &ret, sizeof(ret), 1000 * HZ);
+                if (result < 0) {
+
+
+                        printk(KERN_ERR "zd1211: usb_control_msg 2 fail: %02X\n", result);
+
+
+
+                        goto exit;
+
+
+                }
+
+                //ZD1211DEBUG(2, "result = %x\n", result);
+
+                ZD1211DEBUG(1, "FIRMWARE_CONFIRM = %x\n", ret);
+
+
+
+                if (ret & 0x80) {
+                        FPRINT("USB Download Boot code error");
+
+                        goto exit;
+                } else {
+                        ZD1211DEBUG(0, "USB Download Boot code success\n");
+                }
+
+                result = 0;
+
+        }
+
+
+
+
+
+exit:
+        //kfree(image);
+        kfree(ptr);
+        return result;
+
+}
+
+
+
+
+
+int zd1211_Download_IncludeFile(struct zd1205_private *macp)
+
+{
+        int ret;
+        u16 EEPVer;
+
+        //return 0; //for debug
+
+        EEPVer = WS11Ub[cEPDATA_OFFSET * 2] + (WS11Ub[cEPDATA_OFFSET * 2 + 1] << 8);
+        printk(KERN_NOTICE "EEPORM Ver = %x\n", EEPVer);
+
+/* ath_desc: removed superfluous firmware downloading routine */
+/* ath_msgsubj: [zd1211-devs] FW download wierdness (zd1211.c) */
+/* ath_msgdate: 2005-03-20 20:25 */
+/* ath: superfluous routine removed. */
+
+        //for single RX
+        ret = zd1211_LoadUSBSpecCode(macp, WS11UPh, sizeof(WS11UPh), cFIRMWARE_START_ADDR, true);
+
+        if (ret != 0)
+        {
+
+                FPRINT("Load WS11UPh fail\n");
+                return ret;
+        }
+
+        return 0;
+}
+
+// tasklet (work deferred from completions, in_irq) or timer
+void defer_kevent(struct zd1205_private *macp, int flag)
+{
+
+        ZENTER(4);
+
+        if (!macp->bUSBDeveiceAttached)
+        {
+                return;
+        }
+        //   if (macp->kevent_flags != 0)
+        //     printk("macp->kevent_flags=%08x\n",macp->kevent_flags);
+        set_bit(flag, &macp->kevent_flags);
+        if (flag == KEVENT_SCAN_TIMEOUT)
+        {
+                if(!schedule_work(&macp->scan_tout_event)) {
+                        ZD1211DEBUG(4, "schedule_task failed, flag = %x\n", flag);
+                        if(!schedule_work(&macp->scan_tout_event)) {
+                                dot11Obj.bChScanning = FALSE;
+                        }
+                        printk("******* Schedule task fail *********\n");
+                }
+                ZEXIT(4);
+                return;
+        }
+
+
+
+        if (!schedule_work(&macp->kevent))
+        {
+                ZD1211DEBUG(4, "schedule_task failed, flag = %x\n", flag);
+        }
+
+        ZEXIT(4);
+
+}
+
+void kevent(void *data)
+{
+        struct zd1205_private *macp = (struct zd1205_private *) data;
+        if (!macp->bUSBDeveiceAttached) {
+                return;
+        }
+
+        //non tx rx interrupt
+        if (test_bit(KEVENT_NON_TX_RX_INT, &macp->kevent_flags)) {
+                zd1211_handle_non_tx_rx(macp);
+                clear_bit(KEVENT_NON_TX_RX_INT, &macp->kevent_flags);
+        }
+
+        //scan timeout
+        if (test_bit(KEVENT_SCAN_TIMEOUT, &macp->kevent_flags)) {
+                //FPRINT("scan");
+                zd_EventNotify(EVENT_SCAN_TIMEOUT, 0, 0, 0);
+                clear_bit(KEVENT_SCAN_TIMEOUT, &macp->kevent_flags);
+        }
+
+        //mgt_mon timeout
+        if (test_bit(KEVENT_MGT_MON_TIMEOUT, &macp->kevent_flags)) {
+                //FPRINT("connect_mon");
+                zd1205_connect_mon(macp);
+                clear_bit(KEVENT_MGT_MON_TIMEOUT, &macp->kevent_flags);
+        }
+
+        //house keeping timeout
+        if (test_bit(KEVENT_HOUSE_KEEPING, &macp->kevent_flags)) {
+                zd1205_house_keeping(macp);
+                clear_bit(KEVENT_HOUSE_KEEPING, &macp->kevent_flags);
+        }
+
+        //watchdog timeout
+        if (test_bit(KEVENT_WATCH_DOG, &macp->kevent_flags)) {
+                zd1205_watchdog(macp);
+                clear_bit(KEVENT_WATCH_DOG, &macp->kevent_flags);
+        }
+
+        //auth timeout
+        if (test_bit(KEVENT_AUTH_TIMEOUT, &macp->kevent_flags)) {
+                zd_EventNotify(EVENT_AUTH_TIMEOUT, 0, 0, 0);
+                clear_bit(KEVENT_AUTH_TIMEOUT, &macp->kevent_flags);
+        }
+
+        //associate timeout
+        if (test_bit(KEVENT_ASOC_TIMEOUT, &macp->kevent_flags)) {
+                zd_EventNotify(EVENT_ASOC_TIMEOUT, 0, 0, 0);
+                clear_bit(KEVENT_ASOC_TIMEOUT, &macp->kevent_flags);
+        }
+
+        //challenge timeout
+        if (test_bit(KEVENT_TCHAL_TIMEOUT, &macp->kevent_flags)) {
+                zd_EventNotify(EVENT_TCHAL_TIMEOUT, 0, 0, 0);
+                clear_bit(KEVENT_TCHAL_TIMEOUT, &macp->kevent_flags);
+        }
+
+        //zd_ioctl
+        if (test_bit(KEVENT_ZD_IOCTL, &macp->kevent_flags)) {
+                //FPRINT("ioctl");
+                zd1205_zd_dbg_ioctl(macp, &macp->zdreq);
+                clear_bit(KEVENT_ZD_IOCTL, &macp->kevent_flags);
+        }
+/* ath_desc: support for unpatched wpasupplicant */
+        //MLME ioctl handling
+        if (test_bit(KEVENT_ZD_MLME_IOCTL, &macp->kevent_flags)) {
+                zd1211_mlme(macp);
+                clear_bit(KEVENT_ZD_MLME_IOCTL, &macp->kevent_flags);
+        }
+
+        //use protection
+        if (test_bit(KEVENT_EN_PROTECTION, &macp->kevent_flags)) {
+                zd_EventNotify(EVENT_ENABLE_PROTECTION, 1, 0, 0);
+                clear_bit(KEVENT_EN_PROTECTION, &macp->kevent_flags);
+        }
+
+        //disable protection
+        if (test_bit(KEVENT_DIS_PROTECTION, &macp->kevent_flags)) {
+                zd_EventNotify(EVENT_ENABLE_PROTECTION, 0, 0, 0);
+                clear_bit(KEVENT_DIS_PROTECTION, &macp->kevent_flags);
+        }
+
+        //update card setting
+        if (test_bit(KEVENT_UPDATE_SETTING, &macp->kevent_flags)) {
+                zd_UpdateCardSetting(&macp->cardSetting);
+                clear_bit(KEVENT_UPDATE_SETTING, &macp->kevent_flags);
+        }
+
+        //set multicast
+        if (test_bit(KEVENT_SET_MULTICAST, &macp->kevent_flags)) {
+                zd1211_set_multicast(macp);
+                clear_bit(KEVENT_SET_MULTICAST, &macp->kevent_flags);
+        }
+
+        //process signal
+        if (test_bit(KEVENT_PROCESS_SIGNAL, &macp->kevent_flags)) {
+                zd_SigProcess();
+                clear_bit(KEVENT_PROCESS_SIGNAL, &macp->kevent_flags);
+        }
+
+        //enable barker preamble
+        if (test_bit(KEVENT_EN_BARKER, &macp->kevent_flags)) {
+                zd_EventNotify(EVENT_ENABLE_BARKER, 1, 0, 0);
+                clear_bit(KEVENT_EN_BARKER, &macp->kevent_flags);
+        }
+
+        //disable barker preamble
+        if (test_bit(KEVENT_DIS_BARKER, &macp->kevent_flags)) {
+                zd_EventNotify(EVENT_ENABLE_BARKER, 0, 0, 0);
+                clear_bit(KEVENT_DIS_BARKER, &macp->kevent_flags);
+        }
+
+        //enable short slot
+        if (test_bit(KEVENT_EN_SHORT_SLOT, &macp->kevent_flags)) {
+                zd_EventNotify(EVENT_SHORT_SLOT, 1, 0, 0);
+                clear_bit(KEVENT_EN_SHORT_SLOT, &macp->kevent_flags);
+        }
+
+        //disable short slot
+        if (test_bit(KEVENT_DIS_SHORT_SLOT, &macp->kevent_flags)) {
+                zd_EventNotify(EVENT_SHORT_SLOT, 0, 0, 0);
+                clear_bit(KEVENT_DIS_SHORT_SLOT, &macp->kevent_flags);
+        }
+
+        //disable short slot
+        if (test_bit(KEVENT_DIS_CONNECT, &macp->kevent_flags)) {
+                if (!zd1205_dis_connect(macp)) {
+                        zd_CmdProcess(CMD_DIS_CONNECT, 0, 0);
+                        macp->NoBcnDetectedCnt = 0;
+                }
+                clear_bit(KEVENT_DIS_CONNECT, &macp->kevent_flags);
+        }
+
+        //std_ioctl
+        if (test_bit(KEVENT_STD_IOCTL, &macp->kevent_flags)) {
+                //FPRINT("ioctl");
+                zd1205_ioctl(macp->device, &macp->ifreq, macp->ifcmd);
+                clear_bit(KEVENT_STD_IOCTL, &macp->kevent_flags);
+        }
+
+        // kill tx urb (usb_kill_urb cannot be called from interrupt)
+        if (test_bit(KEVENT_KILL_TX_URB, &macp->kevent_flags)) {
+                zd1211_kill_tx_urb(macp);
+                clear_bit(KEVENT_KILL_TX_URB, &macp->kevent_flags);
+        }
+
+        if (test_bit(KEVENT_REGISTER_NET, &macp->kevent_flags)) {
+                register_netdev(macp->device);
+                clear_bit(KEVENT_REGISTER_NET, &macp->kevent_flags);
+        }
+}
+
+void zd1211_alloc_rx(unsigned long parm)
+{
+        struct zd1205_private *macp = (struct zd1205_private *) parm;
+        unsigned long flags;
+
+        spin_lock_irqsave(&macp->rx_pool_lock, flags);
+        zd1205_alloc_skbs(macp);
+        spin_unlock_irqrestore(&macp->rx_pool_lock, flags);
+}
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zd1211.h linux-2.4.35.3-mct/drivers/usb/zd1211/zd1211.h
--- linux-2.4.35.3/drivers/usb/zd1211/zd1211.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zd1211.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,231 @@
+#ifndef _ZD1211_H_
+#define _ZD1211_H_
+
+#include "zd1205.h"
+
+
+#define MAX_NUM_PORTS		8	/* The maximum number of ports one device can grab at once */
+
+#define IOWAITTIME			2
+
+#define EP_DATA_OUT			0x01
+#define EP_DATA_IN			0x02
+#define EP_INT_IN			0x03
+#define EP_REG_OUT			0x04
+
+// EP0 [request, ID] setting.
+#define REGID_WRITE			0x21
+#define REGID_READ			0x22
+#define REGID_RFOFDMSET		0x23
+#define REGID_PROG_FLSH 	0x24
+#define EEPROM_START		0x128
+#define EEPROM_MID			0x28
+#define EEPROM_END			0x228
+
+#define FIRMWARE_DOWNLOAD	0x30
+#define FIRMWARE_CONFIRM	0x31
+#define FIRMWARE_READ_DATA  0x32
+
+#define EPINT_IORDRsp			0x90
+#define EPINT_RetryFial_Event	0xa0
+
+// for macp->flags
+#define	ZD1211_UNPLUG		1
+#define	ZD1211_REQ_COMP		2
+#define ZD1211_RUNNING          3
+#define ZD1211_TX_BUSY          4
+#define ZD1211_CMD_FINISH       5
+#define ZD1211_SCAN_REQUEST     6
+#define ZD1211_SCAN_COMPLETE    7
+#define CTX_FLAG_ESSID_WAS_SET  8
+
+#define KEVENT_SCAN_TIMEOUT     1
+#define KEVENT_MGT_MON_TIMEOUT  2
+#define KEVENT_HOUSE_KEEPING    3
+#define KEVENT_WATCH_DOG        4
+#define KEVENT_AUTH_TIMEOUT     5
+#define KEVENT_ASOC_TIMEOUT     6
+#define KEVENT_TCHAL_TIMEOUT    7
+#define KEVENT_NON_TX_RX_INT    8
+#define KEVENT_ZD_IOCTL         9
+#define KEVENT_EN_PROTECTION	10
+#define KEVENT_DIS_PROTECTION	11
+#define KEVENT_UPDATE_SETTING	12
+#define KEVENT_SET_MULTICAST    13
+#define KEVENT_PROCESS_SIGNAL   14
+#define KEVENT_EN_BARKER        15
+#define KEVENT_DIS_BARKER   	16
+#define KEVENT_EN_SHORT_SLOT    17
+#define KEVENT_DIS_SHORT_SLOT   18
+#define KEVENT_DIS_CONNECT      19
+#define KEVENT_STD_IOCTL        20
+#define KEVENT_REGISTER_NET     21
+#define KEVENT_ZD_MLME_IOCTL    22
+/* ath_desc: Defer tx kill_urb on Linux 2.6.8+ */
+#define KEVENT_KILL_TX_URB      23
+
+
+#define mFILL_WRITE_REGISTER(addr0, value0) \
+{                                           \
+    WriteAddr[WriteIndex] = addr0;          \
+    WriteData[WriteIndex ++] = value0;      \
+}
+
+
+// write 32_bit register ==> write high word first
+#define mFILL_WRITE_REGISTER32(addr0, value32)               \
+{                                                            \
+    WriteAddr[WriteIndex] = (addr0) + 2;                     \
+    WriteData[WriteIndex ++] = (u16) ((value32) >> 16);      \
+    WriteAddr[WriteIndex] = addr0;                           \
+    WriteData[WriteIndex ++] = (u16) ((value32) & 0xFFFF);   \
+}
+
+#define mFILL_READ_REGISTER(addr0)	(ReadAddr[ReadIndex++] = addr0)
+#define mFILL_RF_REGISTER(value0)	(WriteData[WriteIndex++] = value0)
+
+/* Flash interface */
+#define bmFLASH_A0                  1
+
+#define mFLASH_SET_EVEN_ADDR(orgCR203)                              \
+    mFILL_WRITE_REGISTER(ZD1205_CR203 + (u16) (macp->USBCSRAddress), \
+                         mCLR_BIT((u16) (orgCR203), bmFLASH_A0))
+
+#define mFLASH_SET_ODD_ADDR(orgCR203)                               \
+    mFILL_WRITE_REGISTER(ZD1205_CR203 + (u16) (macp->USBCSRAddress), \
+                         mSET_BIT((u16) (orgCR203), bmFLASH_A0))
+
+#define mFLASH_WRITE_EVEN_ADDR(addr0, value0, orgCR203) \
+{                                                       \
+    mFLASH_SET_EVEN_ADDR(orgCR203);                     \
+    mFILL_WRITE_REGISTER(((addr0) >> 1), value0);       \
+}
+
+#define mFLASH_WRITE_ODD_ADDR(addr0, value0, orgCR203)  \
+{                                                       \
+    mFLASH_SET_ODD_ADDR(orgCR203);                      \
+    mFILL_WRITE_REGISTER(((addr0) >> 1), value0);       \
+}
+
+
+//-------------------------------------------------------------------------
+#if !fDRV_UPDATE_EEP
+	#define WRITE_WORD_TO_EEPROM_PER_TIME   8
+
+#else
+	#define WRITE_WORD_TO_EEPROM_PER_TIME   16
+#endif
+
+
+typedef struct _USB_EEPROM_DATA
+{
+        u16  RequestID;
+        u16  Data[WRITE_WORD_TO_EEPROM_PER_TIME];
+}
+USB_EEPROM_DATA, * PUSB_EEPROM_DATA;
+
+
+typedef struct _USB_REG_PACKAGE
+{
+        u16  Address;
+        u16  Data;
+}
+USB_REG_PACKAGE, *PUSB_REG_PACKAGE;
+
+
+typedef struct _USB_READ_REG
+{
+        u16 RequestID;
+        USB_REG_PACKAGE Package[cMAX_MULTI_READ_REG_NUM];
+}
+USB_READ_REG, *PUSB_READ_REG;
+
+
+
+typedef struct _USB_READ_REG_REQ
+{
+        u16  RequestID;
+        u16  Address[cMAX_MULTI_READ_REG_NUM];
+}
+USB_READ_REG_REQ, *PUSB_READ_REG_REQ;
+
+
+typedef struct _USB_WRITE_REG_PACKAGE
+{
+        u16	Address;
+
+        u16	WriteData_low;
+}
+USB_WRITE_REG_PACKAGE, * PUSB_WRITE_REG_PACKAGE;
+
+
+/* ath_desc: bigendian support */
+struct _USB_WRITE_REG
+{
+        u16  RequestID;
+        USB_WRITE_REG_PACKAGE WritePackage[cMAX_MULTI_WRITE_REG_NUM];
+} __attribute__((__packed__));
+typedef struct _USB_WRITE_REG USB_WRITE_REG, * PUSB_WRITE_REG;
+
+
+typedef struct _USB_SET_RF
+{
+        u16  RequestID;
+        u16  Value;
+        u16  Index;
+        u16  Data[cMAX_MULTI_RF_REG_NUM];
+}
+USB_SET_RF, * PUSB_SET_RF;
+
+
+void zd1211_StrongSignalDect(struct zd1205_private *macp);
+void zd1211_TxCalibration(struct zd1205_private *macp);
+void zd1211_CheckWithIPC(struct zd1205_private *macp);
+void zd1211_unlink_all_urbs(struct zd1205_private *macp);
+u16 zd1211_SetHighAddr(struct zd1205_private *macp, u16 high_addr);
+u16 zd1211_SetAbsAddr(struct zd1205_private *macp, u32 abs_addr, u16 *get_cr203);
+void zd1211_InitHighAddr(struct zd1205_private *macp);
+void zd1211_FlashCmdWrite(struct zd1205_private *macp, u8 Cmd);
+void zd1211_FlashSecErase(struct zd1205_private *macp, u16 Sec0);
+void zd1211_FlashProgram(struct zd1205_private *macp, u16 addr0, u16 val0);
+void zd1211_EraseFlash(struct zd1205_private *macp);
+int zd1211_ProgFlash(struct zd1205_private *macp, u32 StartAddr, u32 BufLenInBytes, u8 *pDownloadBuffer);
+u8 zd1211_InitSetup(struct net_device *dev,	struct zd1205_private *macp);
+void zd1211_SwitchAntenna(struct zd1205_private *macp);
+int zd1211_alloc_all_urbs(struct zd1205_private *macp);
+void zd1211_free_all_urbs(struct zd1205_private *macp);
+int zd1211_writel(u32 Address, u32 Value, u8 bAddUSBCSRAddress);
+int zd1211_USB_PACKAGE_WRITE_REGISTER(u16 *Address, u16 *Value, u16 RegCount, u8 bAddUSBCSRAddress);
+u32 zd1211_readl(u32 Address, u8 bAddUSBCSRAddress);
+int zd1211_USB_PACKAGE_READ_REGISTER(u16 *Address, u16 *pValue, u16 RegCount, u8 bAddUSBCSRAddress);
+void zd1211_handle_non_tx_rx(struct zd1205_private *macp);
+void ZD1211_WRITE_MULTI_REG(u16  *pAddress, u16  *pValue, u16 *pRegCount);
+int zd1211_USB_SET_RF_REG(u16 *InputValue, int bIs3683A);
+int zd1211_submit_rx_urb(struct zd1205_private *macp);
+int zd1211_submit_tx_urb(struct zd1205_private *macp,BOOLEAN LastFrag);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+void zd1211_tx_comp_cb(struct urb *urb);
+void zd1211_rx_comp_cb(struct urb *urb);
+void zd1211_intr_cb(struct urb *urb);
+void zd1211_reg_cb(struct urb *urb);
+#else
+void zd1211_tx_comp_cb(struct urb *urb, struct pt_regs *regs);
+void zd1211_rx_comp_cb(struct urb *urb, struct pt_regs *regs);
+void zd1211_intr_cb(struct urb *urb, struct pt_regs *regs);
+void zd1211_reg_cb(struct urb *urb, struct pt_regs *regs);
+#endif
+void zd1211_disable_net_traffic(struct zd1205_private *macp);
+int zd1211_USB_ProgramFlash(struct zd1205_private *macp, u16 *Value, u16 RegCount);
+int zd1211_LoadUSBSpecCode(struct zd1205_private *macp, u8 *pBuffer, u32 uImgLength, u16 uCodeOfst, u8 bReboot);
+int zd1211_Download_IncludeFile(struct zd1205_private *macp);
+int zd1211_GetUSBSpecData(struct zd1205_private *macp, u8 *pBuffer, u32 uImgLength, u16 uCodeOfst);
+int zd1211_DownLoadUSBCode(struct zd1205_private *macp, u8* FileName, void *ptr, u16 uCodeOfst);
+int zd1211_WriteMultiRegister(u16 *Address, u16 *Value, u16 RegCount, u8 bAddUSBCSRAddress);
+void kevent(void *data);
+void defer_kevent(struct zd1205_private *macp, int flag);
+void zd1211_rx_isr(unsigned long parm);
+void zd1211_tx_isr(unsigned long parm);
+void zd1211_alloc_rx(unsigned long parm);
+
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zd1211_wext.h linux-2.4.35.3-mct/drivers/usb/zd1211/zd1211_wext.h
--- linux-2.4.35.3/drivers/usb/zd1211/zd1211_wext.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zd1211_wext.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,152 @@
+#ifndef _zd1211_wext_h_
+#define _zd1211_wext_h_
+
+
+#if WIRELESS_EXT < 18
+
+#define SIOCSIWGENIE	0x8B30
+#define SIOCSIWMLME	0x8B16
+#define SIOCSIWAUTH	0x8B32
+#define SIOCSIWENCODEEXT 0x8B34
+
+#define IW_AUTH_WPA_VERSION		0
+#define IW_AUTH_CIPHER_PAIRWISE		1
+#define IW_AUTH_CIPHER_GROUP		2
+#define IW_AUTH_KEY_MGMT		3
+#define IW_AUTH_TKIP_COUNTERMEASURES	4
+#define IW_AUTH_DROP_UNENCRYPTED	5
+#define IW_AUTH_80211_AUTH_ALG		6
+#define IW_AUTH_WPA_ENABLED		7
+#define IW_AUTH_RX_UNENCRYPTED_EAPOL	8
+#define IW_AUTH_ROAMING_CONTROL		9
+#define IW_AUTH_PRIVACY_INVOKED		10
+
+#define IW_AUTH_WPA_VERSION_DISABLED	0x00000001
+#define IW_AUTH_WPA_VERSION_WPA		0x00000002
+#define IW_AUTH_WPA_VERSION_WPA2	0x00000004
+
+#define IW_AUTH_CIPHER_NONE	0x00000001
+#define IW_AUTH_CIPHER_WEP40	0x00000002
+#define IW_AUTH_CIPHER_TKIP	0x00000004
+#define IW_AUTH_CIPHER_CCMP	0x00000008
+#define IW_AUTH_CIPHER_WEP104	0x00000010
+
+#define IW_AUTH_KEY_MGMT_802_1X	1
+#define IW_AUTH_KEY_MGMT_PSK	2
+
+#define IW_AUTH_ALG_OPEN_SYSTEM	0x00000001
+#define IW_AUTH_ALG_SHARED_KEY	0x00000002
+#define IW_AUTH_ALG_LEAP	0x00000004
+
+#define IW_AUTH_ROAMING_ENABLE	0
+#define IW_AUTH_ROAMING_DISABLE	1
+
+#define IW_ENCODE_SEQ_MAX_SIZE	8
+
+#define IW_ENCODE_ALG_NONE	0
+#define IW_ENCODE_ALG_WEP	1
+#define IW_ENCODE_ALG_TKIP	2
+#define IW_ENCODE_ALG_CCMP	3
+
+
+struct	iw_encode_ext
+{
+	__u32		ext_flags; /* IW_ENCODE_EXT_* */
+	__u8		tx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	__u8		rx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	struct sockaddr	addr; /* ff:ff:ff:ff:ff:ff for broadcast/multicast
+			       * (group) keys or unicast address for
+			       * individual keys */
+	__u16		alg; /* IW_ENCODE_ALG_* */
+	__u16		key_len;
+	__u8		key[0];
+};
+
+
+struct	iw_mlme
+{
+	__u16		cmd; /* IW_MLME_* */
+	__u16		reason_code;
+	struct sockaddr	addr;
+};
+
+#endif // WIRELESS_EXT < 18
+
+
+#endif // _zd1211_wext_h_
+#ifndef _zd1211_wext_h_
+#define _zd1211_wext_h_
+
+
+#if WIRELESS_EXT < 18
+
+#define SIOCSIWGENIE	0x8B30
+#define SIOCSIWMLME	0x8B16
+#define SIOCSIWAUTH	0x8B32
+#define SIOCSIWENCODEEXT 0x8B34
+
+#define IW_AUTH_WPA_VERSION		0
+#define IW_AUTH_CIPHER_PAIRWISE		1
+#define IW_AUTH_CIPHER_GROUP		2
+#define IW_AUTH_KEY_MGMT		3
+#define IW_AUTH_TKIP_COUNTERMEASURES	4
+#define IW_AUTH_DROP_UNENCRYPTED	5
+#define IW_AUTH_80211_AUTH_ALG		6
+#define IW_AUTH_WPA_ENABLED		7
+#define IW_AUTH_RX_UNENCRYPTED_EAPOL	8
+#define IW_AUTH_ROAMING_CONTROL		9
+#define IW_AUTH_PRIVACY_INVOKED		10
+
+#define IW_AUTH_WPA_VERSION_DISABLED	0x00000001
+#define IW_AUTH_WPA_VERSION_WPA		0x00000002
+#define IW_AUTH_WPA_VERSION_WPA2	0x00000004
+
+#define IW_AUTH_CIPHER_NONE	0x00000001
+#define IW_AUTH_CIPHER_WEP40	0x00000002
+#define IW_AUTH_CIPHER_TKIP	0x00000004
+#define IW_AUTH_CIPHER_CCMP	0x00000008
+#define IW_AUTH_CIPHER_WEP104	0x00000010
+
+#define IW_AUTH_KEY_MGMT_802_1X	1
+#define IW_AUTH_KEY_MGMT_PSK	2
+
+#define IW_AUTH_ALG_OPEN_SYSTEM	0x00000001
+#define IW_AUTH_ALG_SHARED_KEY	0x00000002
+#define IW_AUTH_ALG_LEAP	0x00000004
+
+#define IW_AUTH_ROAMING_ENABLE	0
+#define IW_AUTH_ROAMING_DISABLE	1
+
+#define IW_ENCODE_SEQ_MAX_SIZE	8
+
+#define IW_ENCODE_ALG_NONE	0
+#define IW_ENCODE_ALG_WEP	1
+#define IW_ENCODE_ALG_TKIP	2
+#define IW_ENCODE_ALG_CCMP	3
+
+
+struct	iw_encode_ext
+{
+	__u32		ext_flags; /* IW_ENCODE_EXT_* */
+	__u8		tx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	__u8		rx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	struct sockaddr	addr; /* ff:ff:ff:ff:ff:ff for broadcast/multicast
+			       * (group) keys or unicast address for
+			       * individual keys */
+	__u16		alg; /* IW_ENCODE_ALG_* */
+	__u16		key_len;
+	__u8		key[0];
+};
+
+
+struct	iw_mlme
+{
+	__u16		cmd; /* IW_MLME_* */
+	__u16		reason_code;
+	struct sockaddr	addr;
+};
+
+#endif // WIRELESS_EXT < 18
+
+
+#endif // _zd1211_wext_h_
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zd80211.h linux-2.4.35.3-mct/drivers/usb/zd1211/zd80211.h
--- linux-2.4.35.3/drivers/usb/zd1211/zd80211.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zd80211.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,22 @@
+#ifndef __ZD80211_H__
+#define __ZD80211_H__
+
+#include "zdos.h"
+
+#include "zdtypes.h"
+#include "zdsorts.h"
+#include "zdutils.h"
+#include "zdglobal.h"
+#include "zdsm.h"
+#include "zdbuf.h"
+#include "zdhci.h"
+#include "zdpsmon.h"
+#include "zdpmfilter.h"
+#include "zdmmrx.h"
+#include "zdshared.h"
+#include "zdhw.h"
+#include "zdtkipseed.h"
+#include "zdmic.h"
+#include "zdencrypt.h"
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdapi.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdapi.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdapi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdapi.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,515 @@
+#ifndef _ZDAPI_H_
+#define _ZDAPI_H_
+
+#include "zdtypes.h"
+#include "zdsorts.h"
+//#define HMAC_DEBUG
+
+#ifdef HMAC_DEBUG
+#define FPRINT(string)			printk(KERN_DEBUG "%s\n", string)
+#define FPRINT_V(string, i)		printk(KERN_DEBUG "%s = %x\n", string, i)
+#else
+#define FPRINT(string)
+#define FPRINT_V(string, i)
+#define VerAssert(x)	printk("Maybe Unsupport mode in %s(%d)",__FILE__,__LINE__);
+#define LongPrint(x,y)	{int i;for(i=0;i<100*y;i++) printk("%s",x);}
+#endif
+
+
+//#define ZD_DEBUG 	//debug protocol stack
+
+#ifdef ZD_DEBUG
+#define ZDEBUG(string)			FPRINT(string)
+#define ZDEBUG_V(string, i)		FPRINT_V(string, i)
+#else
+#define ZDEBUG(string) 			//do {} while (0)
+#define ZDEBUG_V(string, i)		//do {} while (0)
+#endif
+
+//#define PS_DEBUG		//debug power save function
+
+
+#ifdef PS_DEBUG
+#define PSDEBUG(string)			FPRINT(string)
+#define PSDEBUG_V(string, i)	FPRINT_V(string, i)
+#else
+#define PSDEBUG(string) 		//do {} while (0)
+#define PSDEBUG_V(string, i)	//do {} while (0)
+#endif
+
+
+//#define HASH_DEBUG	//debug hash function
+
+#ifdef HASH_DEBUG
+#define HSDEBUG(string)			FPRINT(string)
+#define HSDEBUG_V(string, i)	FPRINT_V(string, i)
+#else
+#define HSDEBUG(string) 		//do {} while (0)
+#define HSDEBUG_V(string, i)	//do {} while (0)
+#endif
+
+//#define RATE_DEBUG	//debug rate adaption function
+
+#ifdef RATE_DEBUG
+#define RATEDEBUG(string)		FPRINT(string)
+#define RATEDEBUG_V(string, i)	FPRINT_V(string, i)
+#else
+#define RATEDEBUG(string) 		//do {} while (0)
+#define RATEDEBUG_V(string, i)	//do {} while (0)
+#endif
+
+
+//#define DEFRAG_DEBUG	//debug defrag function
+
+#ifdef DEFRAG_DEBUG
+#define DFDEBUG(string)			FPRINT(string)
+#define DFDEBUG_V(string, i)	FPRINT_V(string, i)
+#else
+#define DFDEBUG(string) 		//do {} while (0)
+#define DFDEBUG_V(string, i)	//do {} while (0)
+#endif
+
+
+/* ath_desc: bigendian support */
+/* ath: use cpu_to_le32 instead of zd_cpu_to_le32 */
+/* ath: deleted zd_cpu_to_le32 definition */
+
+#define CMD_RESET_80211			0x0001	//parm1: zd_80211Obj_t *
+#define CMD_ENABLE				0x0002	//parm1: None
+#define CMD_DISASOC				0x0003	//parm1: U8 *MacAddress, parm2: reasonCode
+#define CMD_DEAUTH				0x0004	//parm1: U8 *MacAddress, parm2: reasonCode
+#define CMD_PS_POLL				0x0005	//parm1: U8 *MacHeader
+#define CMD_PASSIVE_SCAN		0x0006	//parm1: None
+#define CMD_DISASOC_ALL			0x0007	//parm1: U8 *MacAddress, parm2: reasonCode
+#define CMD_CONNECT				0x0008	//parm1: None, parm2: BssIndex
+#define CMD_PROBE_REQ			0x0009	//parm1: None, parm2: WithSSID
+#define CMD_DIS_CONNECT			0x000A
+#define	CMD_FLUSH_QUEUE			0x000B
+#define	CMD_ROAMING             0x000C
+
+
+//Event Notify
+
+#define EVENT_TBCN				0x0010
+#define EVENT_DTIM_NOTIFY		0x0011
+#define EVENT_TX_COMPLETE		0x0012 //parm1: tx status, parm2: msgId, parm3: aid
+#define EVENT_TCHAL_TIMEOUT		0x0013
+#define EVENT_SCAN_TIMEOUT		0x0014
+#define EVENT_UPDATE_TX_RATE	0x0015 //parm1: rate, parm2: aid
+#define EVENT_SW_RESET          0x0016
+#define EVENT_BUF_RELEASE       0x0017
+#define EVENT_ENABLE_PROTECTION	0x0018
+#define EVENT_AUTH_TIMEOUT		0x0019
+#define EVENT_ASOC_TIMEOUT		0x001A
+#define EVENT_PS_CHANGE			0x001B //parm1: PwrState
+#define EVENT_MORE_DATA			0x001C
+#define EVENT_ENABLE_BARKER     0x001D
+#define EVENT_SHORT_SLOT        0x001E
+
+
+#define DO_CHAL					0x0001
+#define DO_SCAN					0x0002
+#define DO_AUTH					0x0003
+#define DO_ASOC					0x0004
+
+#define SCAN_TIMEOUT			50   //ms
+#define HOUSE_KEEPING_PERIOD	100	 //ms
+#define AUTH_TIMEOUT			512  //3000 //ms
+#define ASOC_TIMEOUT			512  //2000 //ms
+
+
+//reason code
+#define ZD_UNSPEC_REASON 		1
+#define ZD_AUTH_NOT_VALID		2
+#define ZD_DEAUTH_LEAVE_BSS		3
+
+#define ZD_INACTIVITY			4
+#define ZD_AP_OVERLOAD			5
+#define ZD_CLASS2_ERROR			6
+#define ZD_CLASS3_ERROR			7
+#define ZD_DISAS_LEAVE_CSS		8
+#define ZD_ASOC_NOT_AUTH		9
+#define ZD_INVALID_IE			13
+#define ZD_MIC_FAIL				14
+#define ZD_4WAY_SHAKE_TIMEOUT	15
+#define ZD_GKEY_UPDATE_TIMEOUT	16
+#define ZD_IE_IMCOMPABILITY		17
+#define ZD_MC_CIPHER_INVALID	18
+#define ZD_UNI_CIPHER_INVALID	19
+#define ZD_AKMP_INVALID			20
+#define ZD_UNSUP_RSNE_VERSION	21
+#define ZD_INVALID_RSNE_CAP		22
+#define ZD_8021X_AUTH_FAIL		23
+
+
+/* association_status_notify() <- status */
+#define STA_ASOC_REQ			0x0001
+#define STA_REASOC_REQ			0x0002
+#define STA_ASSOCIATED			0x0003
+#define STA_REASSOCIATED		0x0004
+#define STA_DISASSOCIATED		0x0005
+#define STA_AUTH_REQ			0x0006
+#define STA_DEAUTHED			0x0007
+
+//Tx complete event
+#define ZD_TX_CONFIRM			0x0001
+#define ZD_RETRY_FAILED			0x0002
+
+
+//for Dymanic Key
+#define DYN_KEY_WEP64			1
+#define DYN_KEY_WEP128			2
+#define DYN_KEY_TKIP			4
+#define DYN_KEY_AES			    5
+
+
+//Rate Defintion
+#define RATE_1M		            0
+#define	RATE_2M		            1
+#define	RATE_5M		            2
+#define	RATE_11M	            3
+#define	RATE_16M	            4
+
+#define	RATE_22M	            5
+#define	RATE_27M	            6
+#define RATE_33M		        7
+#define	RATE_38M		        8
+#define	RATE_44M		        9
+#define	RATE_49M	            10
+#define	RATE_55M	            11
+#define	RATE_60M	            12
+
+#define	RATE_6M	                0x04
+#define	RATE_9M	                0x05
+#define	RATE_12M	            0x06
+#define	RATE_18M	            0x07
+#define	RATE_24M	            0x08
+#define	RATE_36M	            0x09
+#define	RATE_48M	            0x0a
+#define	RATE_54M	            0x0b
+
+
+#define NO_WEP                  0x0
+#define AES                     0x4
+#define WEP64                   0x1
+#define WEP128                  0x5
+#define WEP256                  0x6
+#define TKIP                    0x2
+
+
+
+#define	NUM_SUPPORTED_RATE	    32
+
+// pfrmDesc->ConfigSet
+#define INTRA_BSS_SET			0x01
+#define EAPOL_FRAME_SET			0x02
+#define FORCE_WEP_SET			0x04
+
+//BssType
+#define INDEPENDENT_BSS			0x0
+#define INFRASTRUCTURE_BSS		0x1
+#define PSEUDO_IBSS				0x3
+#define	AP_BSS					0x4
+
+//RxFilter
+#define AP_RX_FILTER			0x0400feff
+#define STA_RX_FILTER			0x0000ffff
+
+//pSetting->MacMode
+#define MIXED_MODE		        0x01
+#define PURE_G_MODE		        0x02
+#define PURE_B_MODE 	        0x03
+#define PURE_A_MODE				0x04
+
+
+
+#define CW_SHORT_SLOT		    0x7f043f
+#define CW_NORMAL_SLOT		    0xff043f
+#define CW_LONG_SLOT            0x7f047f
+
+
+
+//for Rate Adaption
+#define RISE_CONDITION_THRESHOLD	5
+#define DOWN_CONDITION_THRESHOLD	3
+#define	LINE1				100
+#define	LINE2				10
+#define	LINE3				5
+
+
+//for CAM
+#define CAM_VAP_START_AID	33
+#define CAM_VAP_END_AID		39
+
+
+#define HW_MIC_FINISH		0x55555555
+#define CAM_ADDR_NOT_MATCH	40
+
+#define PURE_B_AP       0
+#define MIXED_AP        1
+#define PURE_G_AP       2
+#define PURE_A_AP			3
+
+
+enum Operation_Mode {
+        CAM_IBSS = 0,
+        CAM_AP,
+        CAM_STA,
+        CAM_AP_WDS,
+        CAM_AP_CLIENT,
+        CAM_AP_VAP
+};
+
+
+typedef struct card_Setting_s
+{
+        U8		EncryOnOff;		//0: encryption off, 1: encryption on
+        U8		OperationMode;	//0: IBSS, 1: AP, 2: STA, 3: WDS, 4: AP Client, 5: Virtual AP
+        U8		PreambleType;	//0: long preamble, 1: short preamble
+        U8		TxRate;			//0: 1M, 1: 2M, 2: 5.5M, 3: 11M, 4: 16.5M
+        U8		FixedRate;		// fixed Tx Rate
+        U8		CurrTxRate;		//
+        U8		AuthMode;		//0: open system only, 1: shared key only, 2: auto
+        U8		HiddenSSID;		//0: disable, 1:enable
+        U8		LimitedUser;	//limited client number max to 32 user
+        U8		RadioOn;		//0: radio off, 1: radio on
+        U8		BlockBSS;		//0: don't block intra-bss traffic, 1: block
+        U8		TxPowerLevel;	//0: 17dbm, 1: 14dbm, 2: 11dbm
+        U8		BasicRate;		//
+        U8		EncryMode;		//0: no wep, 2: wep63, 3:wep128
+        U8		EncryKeyId;		//encryption key id
+        U8		BcKeyId;		//broadcast key id for dynamic key
+        U8		SwCipher;		//
+        U8		WepKeyLen;		//WEP key length
+        U8		BcKeyLen;		//Broadcast key length
+        U8		DynKeyMode;		//Dynamic key mode, 1: WEP64, 2: WEP128, 4:TKIP
+        U16		Channel;		//channel number
+        U16		FragThreshold;	//fragment threshold, from 256~2432
+        U16		RTSThreshold;	//RTS threshold, from 256~2432
+
+        U16		BeaconInterval;	//default 100 ms
+        U16		DtimPeriod;		//default 1
+        U8		MacAddr[8];
+        // ElementID(1), Len(1), SSID
+        U8		Info_SSID[36];	//include element ID, element Length, and element content
+        // ElementID(1), Len(1), SupportedRates(1-8)
+        U8		Info_SupportedRates[NUM_SUPPORTED_RATE];	//include element ID, element Length, and element content
+        U8		keyVector[4][32];
+        U8		BcKeyVector[16];
+        U8		WPAIe[128];
+        U8		WPAIeLen;
+        U8		WPASupport;
+        U8		Rate275;
+        U8		WpaBcKeyLen;
+        U8		BssType;
+        U16		ATIMWindow;
+
+        //added for G
+        U8		Ext_SupportedRates[NUM_SUPPORTED_RATE];
+        U8		MacMode;
+        U8		ShortSlotTime;
+        U8		BarkerPreamble;
+        // for UART support
+        //U8		UartEnable;
+        //U8		BaudRate;
+
+        U8		LastSentTxRate;
+        U8		ap_scan;
+#ifdef OFDM
+
+        U8		HighestTxRate;
+#endif
+
+}
+card_Setting_t;
+
+
+#define ZD_MAX_FRAG_NUM		8
+
+typedef struct fragInfo_s
+{
+        U8	*macHdr[ZD_MAX_FRAG_NUM];
+        U8	*macBody[ZD_MAX_FRAG_NUM];
+        U32	bodyLen[ZD_MAX_FRAG_NUM];
+        U32	nextBodyLen[ZD_MAX_FRAG_NUM];
+        U8	hdrLen;
+        U8	totalFrag;
+        U8	bIntraBss;
+        U8	msgID;
+        U8	rate;
+        U8	preamble;
+        U8	encryType;
+        U8	burst;
+        U16 	vapId;
+        U16 	aid;
+        U8 	CalSwMic[MIC_LNG+1];
+        //U8	keyInstalled;
+        //U8	bWaitingMIC;
+        //U8	bSwCalcMIC;
+        //U32	HwMicPhys;
+
+
+        void *buf;
+
+}
+fragInfo_t;
+
+
+typedef struct rxInfo_s
+{
+        U8	rate;
+        U8	bDataFrm;
+        U8	SaIndex;
+        U8	signalStrength;
+        U8	signalQuality;
+        U8	bSwCheckMIC;
+}
+rxInfo_t;
+
+
+typedef struct bss_info_s
+{
+        U8	bssid[6];
+        U16	beaconInterval;
+        U16	cap;
+        U16	atimWindow;
+        U8	ssid[36];
+        U8	supRates[NUM_SUPPORTED_RATE];
+        U8	extRates[NUM_SUPPORTED_RATE];
+        U8	WPAIe[128];
+        U8	RSNIe[128];
+        U8	channel;
+        U8	signalStrength;
+        U8 	signalQuality;
+        U8	apMode;
+}
+bss_info_t;
+
+
+//for pdot11Obj->QueueFlag
+#define TX_QUEUE_SET				0x01
+#define MGT_QUEUE_SET				0x02
+#define	AWAKE_QUEUE_SET				0x04
+
+
+//for mRequestFlag
+#define CONNECT_TOUT_SET			0x0001
+#define DIS_CONNECT_SET				0x0002
+#define BSS_CONNECT_SET             0x0004
+#define CHANNEL_SCAN_SET            0x0008
+#define PS_CHANGE_SET				0x0010
+#define PS_POLL_SET					0x0020
+#define IBSS_CONNECT_SET			0x0040
+#define ROAMING_SET                 0x0080
+
+
+//for pdot11Obj->ConfigFlag
+#define ENABLE_PROTECTION_SET 		0x0001
+#define BARKER_PREAMBLE_SET 		0x0002
+#define SHORT_SLOT_TIME_SET         0x0004
+#define NON_ERP_PRESENT_SET         0x0008
+#define PASSIVE_CHANNEL_SCAN_SET	0x0010
+#define ACTIVE_CHANNEL_SCAN_SET		0x0020
+#define IBSS_CHANNEL_SCAN_SET		0x0040
+#define SCAN_AND_CONNECT_SET        0x0080
+#define JUST_CHANNEL_SCAN           0x1000
+
+// Feature Bit Map
+#define	FBM_ANTTENA_DIVERSITY		0x00000001
+#define	FBM_802_11D					0x00000002
+#define	FBM_27_5_MBPS				0x00000004
+#define	FBM_SINGLE_LED				0x00000008
+
+// Define debug command
+#define DBG_CMD_BEACON				0x0001
+
+//driver to provide callback functions for 802.11 protocol stack
+typedef	struct zd_80211Obj_s
+{
+        void		*reg;			//Input
+        U8		QueueFlag;		//Output
+        U16		ConfigFlag; 		//Output
+        U8		BasicRate;
+        U8		bDeviceInSleep;
+        U8		BssType;
+        U8		bOverWritePhyRegFromE2P;
+        U8		bIsNormalSize;
+        U16		BeaconInterval;
+        U16		Channel;
+        U16		Aid;
+        U32		rfMode;
+        U32		RegionCode;
+        U32		S_bit_cnt;
+        U32		AllowedChannel;
+        U32		dbg_cmd;
+        U8		TxGainSetting;
+#if fTX_GAIN_OFDM
+
+        U8      	TxGainSetting2;
+#endif
+
+        U8     	CR31Flag;
+        U8     	CR122Flag;
+        U8     	CR203Flag;
+        U8	PhyTest;
+        U8	IsUSB2_0;
+        U8      bContinueTx;
+        U8      bChScanning;
+        U16    	IntValue[14];
+        U8      CurrSsid[34+1];
+#ifdef ZD1211B
+
+        U8		LengthDiff;
+#endif
+
+        BOOLEAN MIC_CNT;
+
+        void	(* ReleaseBuffer)(void *buf);							// release rx buffer
+        void	(* StartTimer)(U32 timeout, U32 event);					// start a chanllege timer (shared key authentication)
+        void	(* StopTimer)(U32 TimerId);								// stop the challenge timer
+        void	(* RxInd)(U8 *pData, U32 length, void *buf);			// rx indication
+        void	(* TxCompleted)(void);									// tx completed
+        BOOLEAN	(* SetupNextSend)(fragInfo_t *pFragInfo);				// send to HMAC
+        void	(* SetReg)(void *reg, U32 offset, U32 value);			// set HMAC register
+        U32	(* GetReg)(void *reg, U32 offset);						// get HMAC register
+        U16 	(* StatusNotify)(U16 status, U8 *StaAddr);				// association notify for bridge management
+        void 	(* ExitCS)(U32 flags);								// enable interrupt
+        U32	(* EnterCS)(void);								// disable interrupt
+        U32 	(* Vir2PhyAddr)(U32 virtAddr);							// translate virtual address to physical address
+        BOOLEAN	(* CheckTCBAvail)(U8 NumOfFrag);						// check TCB available
+        void	(* DelayUs)(U16 ustime);								// delay function
+        void *	(* AllocBuffer)(U16 dataSize, U8 **pData);				// allocate wireless forwarding buffer
+
+        int	(* Rand)(U32 seed);
+        void    (* AcquireDoNotSleep)(void);
+        void    (* ReleaseDoNotSleep)(void);
+
+        // wpa support
+        void	(* MicFailure)(unsigned char *addr);
+        int	(* AssocRequest)(U8 *addr, U8* data, U16 size);
+        int 	(* WpaIe)(U8 *buffer, int length);
+}
+zd_80211Obj_t;
+
+
+//802.11 export functions for driver use
+extern void zd_SigProcess(void);									// protocol statck entry point
+extern BOOLEAN zd_SendPkt(U8 *pEthHdr, U8 *pBody, U32 bodyLen, void *buf, U8 bEapol, void *pHash);	// tx request
+extern void zd_ReceivePkt(U8 *pHdr, U32 hdrLen, U8 *pBody, U32 bodyLen, void *buf, U8 *pEthHdr, rxInfo_t *pRxInfo); // rx indication
+extern BOOLEAN zd_CmdProcess(U16 CmdId, void *parm1, U32 parm2);	//command process
+extern void zd_EventNotify(U16 EventId, U32 parm1, U32 parm2, U32 parm3);		//event notify
+extern void zd_UpdateCardSetting(card_Setting_t *pSetting);
+extern BOOLEAN zd_CleanupTxQ(void);
+extern BOOLEAN zd_CleanupAwakeQ(void);
+extern int zd_SetKeyInfo(U8 *addr, U8 encryMode, U8 keyLength, U8 KeyId, U8 *pKeyContent);
+extern void zd_PerSecTimer(void);
+extern BOOLEAN zd_CheckIvSeq(U8 aid, U16 iv16, U32 iv32);
+extern void zd_RateMoniter(void);
+extern BOOLEAN zd_QueryStaTable(U8 *sta, void **ppHash);
+extern void zd_ConnectMon(void);
+extern U8 zd_GetBssList(bss_info_t *pBssList);
+extern U16 zd_AidLookUp(U8 *addr);
+extern void zd_makeRateInfoMAP(U8 *pRates, U16 *basicRateMap, U16 *supRateMap);
+extern void zd_UpdateIbssInfo(U8 *addr, U8 maxRate, U8 preamble, U8 erpSta);
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdasocsvc.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdasocsvc.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdasocsvc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdasocsvc.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,592 @@
+#ifndef __ZDASOCSVC_C__
+#define __ZDASOCSVC_C__
+
+#include "zd80211.h"
+#include "zd1205.h"
+
+U8 AsocState = STE_ASOC_IDLE;
+static MacAddr_t AsSta;
+extern struct net_device *g_dev;
+
+
+BOOLEAN Disasoc(Signal_t *signal)
+{
+        FrmDesc_t *pfrmDesc;
+        Frame_t *rdu;
+        MacAddr_t Sta;
+        ReasonCode Rsn;
+        U8 vapId = 0;
+
+        //ZDEBUG("Disasoc");
+        //FPRINT("Disasoc");
+        pfrmDesc = signal->frmInfo.frmDesc;
+        rdu = pfrmDesc->mpdu;
+        memcpy((U8 *)&Sta, (U8 *)(addr2(rdu)), 6); // Get the address of the transmitter.
+        Rsn = (ReasonCode)(reason(rdu));
+
+        if (mBssType == INFRASTRUCTURE_BSS) {// This frame should be come from the associated AP.
+                if ((!mAssoc) || (memcmp(&Sta, (U8*)&mBssId, 6) != 0)) { //Not for this BSSID
+                        //discard this packet
+                        freeFdesc(pfrmDesc);
+                        return TRUE;
+                } else {
+                        freeFdesc(pfrmDesc);
+                        UpdateStaStatus(&Sta, STATION_STATE_DIS_ASOC, vapId);
+                        pdot11Obj->StatusNotify(STA_DISASSOCIATED, (U8 *)&Sta);
+                        mAssoc = FALSE;
+                        memset((U8 *)&mBssId, 0, 6);
+                        printk(KERN_ERR "Rx Disasoc from AP(Rsn:%d),set DIS_CONNECT_SET\n",Rsn);
+                        mRequestFlag |= DIS_CONNECT_SET;
+                        return TRUE;
+                }
+        } else if (mBssType == AP_BSS) {
+                if (memcmp(addr1(rdu), (U8*)&mBssId, 6)) { //Not for this BSSID
+                        freeFdesc(pfrmDesc);
+                        return TRUE;
+                }
+                UpdateStaStatus(&Sta, STATION_STATE_DIS_ASOC, vapId);
+                freeFdesc(pfrmDesc);
+                //here to handle disassoc ind.
+                pdot11Obj->StatusNotify(STA_DISASSOCIATED, (U8 *)&Sta);
+                return TRUE;
+        } else {
+                freeFdesc(pfrmDesc);
+                return TRUE;
+        }
+}
+
+
+BOOLEAN DisasocReq(Signal_t *signal)
+{
+        FrmDesc_t *pfrmDesc;
+        MacAddr_t Sta;
+        ReasonCode Rsn = RC_UNSPEC_REASON;
+        U8 vapId = 0;
+
+        //ZDEBUG("DisasocReq");
+        //FPRINT("DisasocReq");
+
+        memcpy((U8 *)&Sta, (U8 *)&signal->frmInfo.Sta, 6);
+        Rsn = signal->frmInfo.rCode;
+        pdot11Obj->StatusNotify(STA_DISASSOCIATED, (U8 *)&Sta);
+
+        vapId = signal->vapId;
+        UpdateStaStatus(&Sta, STATION_STATE_DIS_ASOC, vapId);
+
+        pfrmDesc = allocFdesc();
+        if(!pfrmDesc) {
+                sigEnque(pMgtQ, (signal));
+                return FALSE;
+        }
+
+        mkDisAssoc_DeAuthFrm(pfrmDesc, ST_DISASOC, &Sta, Rsn, vapId);
+        sendMgtFrame(signal, pfrmDesc);
+
+        if (mBssType == INFRASTRUCTURE_BSS) {
+                if (memcmp((U8 *)&mBssId, (U8 *)&Sta, 6) == 0) { // my AP
+                        mAssoc = FALSE;
+                        memset((U8 *)&mBssId, 0, 6);
+                }
+        }
+
+        return FALSE;
+}
+
+
+BOOLEAN Re_Asociate(Signal_t *signal)
+{
+        struct zd1205_private *macp=g_dev->priv;
+        Hash_t	*pHash;
+        FrmDesc_t *pfrmDesc;
+        Frame_t *rdu;
+        MacAddr_t Sta;
+        U16 aid = 0;
+        StatusCode asStatus;
+        U8 lsInterval;
+        Element WPA;
+        Element asSsid;
+        Element asRates;
+        Element extRates;
+        U16 cap;
+        U8 ZydasMode = 0;
+        int i;
+        U8 tmpMaxRate = 0x02;
+        U8 MaxRate;
+        U16 notifyStatus = STA_ASOC_REQ;
+        U16 notifyStatus1 = STA_ASSOCIATED;
+        TypeSubtype type = ST_ASOC_RSP;
+        U8	Preamble = 0;
+        U8	HigestBasicRate = 0;
+        U8	vapId = 0;
+        U8	Len;
+        Element *pExtRate = NULL;
+
+        BOOLEAN bErpSta = TRUE;
+        pExtRate = &mExtRates;
+
+        ZDEBUG("Re_Asociate");
+        pfrmDesc = signal->frmInfo.frmDesc;
+
+        if (mBssType == INFRASTRUCTURE_BSS) {
+                freeFdesc(pfrmDesc);
+                return TRUE;
+        } else if (mBssType == AP_BSS) {
+                rdu = pfrmDesc->mpdu;
+                lsInterval = listenInt(pfrmDesc->mpdu);
+                //FPRINT_V("lsInterval", lsInterval);
+                cap = cap(rdu);
+                memcpy((U8 *)&Sta, (U8 *)addr2(rdu), 6);
+
+                if ((isGroup(addr2(rdu))) ||  (!getElem(rdu, EID_SSID, &asSsid))
+                                || (!getElem(rdu, EID_SUPRATES, &asRates))) {
+                        freeFdesc(pfrmDesc);
+                        return TRUE;
+                }
+
+                if ((eLen(&asSsid) != eLen(&dot11DesiredSsid) ||
+                                memcmp(&asSsid, &dot11DesiredSsid, eLen(&dot11DesiredSsid)+2) != 0)) {
+                        freeFdesc(pfrmDesc);
+                        return TRUE;
+                }
+
+                //check capability
+                if (cap & CAP_SHORT_PREAMBLE) {
+                        if (mPreambleType == LONG_PREAMBLE) { //we are long preamble, and STA is short preamble capability
+                                freeFdesc(pfrmDesc);
+                                return TRUE;
+                        } else
+                                Preamble = 1;
+                } else {
+                        Preamble = 0;
+                }
+
+
+                // Privacy not match
+                if (cap & CAP_PRIVACY) {
+                        if (!mPrivacyInvoked && macp->cardSetting.WPAIeLen==0) {
+                                //if (!mPrivacyInvoked){
+                                freeFdesc(pfrmDesc);
+                                return TRUE;
+                        }
+                } else {
+                        if (mPrivacyInvoked) {
+                                freeFdesc(pfrmDesc);
+                                return TRUE;
+                        }
+                }
+
+                //check short slot time
+#if 0//defined(OFDM)
+                if (mMacMode != PURE_B_MODE)
+                {
+                        if (cap & CAP_SHORT_SLOT_TIME) {
+                                if (!(mCap & CAP_SHORT_SLOT_TIME)) {
+                                        FPRINT("CAP_SHORT_SLOT_TIME not match!!");
+                                        freeFdesc(pfrmDesc);
+                                        return TRUE;
+                                }
+                        } else {
+                                if (mCap & CAP_SHORT_SLOT_TIME) {
+                                        asStatus = (StatusCode)SC_UNSUP_SHORT_SLOT_TIME;
+                                        goto check_failed;
+                                }
+                        }
+                }
+
+                FPRINT_V("cap", cap);
+#endif
+
+
+                //check supported rates
+                Len = eLen(&asRates);
+                for (i=0; i<Len; i++) {
+                        if ( (asRates.buf[2+i] & 0x7f) > tmpMaxRate ) {
+                                tmpMaxRate = (asRates.buf[2+i] & 0x7f);
+                                if (asRates.buf[2+i] & 0x80)
+                                        HigestBasicRate = asRates.buf[2+i];
+                        }
+
+                        if (((asRates.buf[2+i] & 0x7f) == 0x21) && (!(cap & CAP_PBCC_ENABLE))) { //Zydas 16.5M
+                                ZydasMode = 1;
+                                mZyDasModeClient = TRUE;
+                                //FPRINT("ZydasMode");
+                        }
+                }
+
+                if (!getElem(rdu, EID_EXT_RATES, &extRates)) {
+                        void *reg = pdot11Obj->reg;
+                        // 11b STA
+                        //FPRINT("11b STA");
+                        if (mMacMode == PURE_G_MODE) { // don't support b only sta
+                                MaxRate = RateConvert((tmpMaxRate & 0x7f));
+                                //MaxBasicRate = RateConvert((HigestBasicRate & 0x7f));
+                                if (MaxRate < pdot11Obj->BasicRate) {
+                                        //FPRINT_V("MaxRate", MaxRate);
+                                        //FPRINT_V("pdot11Obj->BasicRate", pdot11Obj->BasicRate);
+                                        asStatus = SC_UNSUP_RATES;
+                                        goto check_failed;
+                                }
+                        }
+                        bErpSta = FALSE;
+                        pdot11Obj->ConfigFlag |= NON_ERP_PRESENT_SET;
+                        pdot11Obj->ConfigFlag &= ~SHORT_SLOT_TIME_SET;
+                        mCap &= ~CAP_SHORT_SLOT_TIME;
+                        pdot11Obj->SetReg(reg, ZD_CWmin_CWmax, CW_NORMAL_SLOT);
+                        if(PURE_A_MODE == mMacMode) {
+                                pdot11Obj->ConfigFlag &= ~NON_ERP_PRESENT_SET;
+                                pdot11Obj->ConfigFlag |= SHORT_SLOT_TIME_SET;
+                                mCap |= CAP_SHORT_SLOT_TIME;
+                                pdot11Obj->SetReg(reg, ZD_CWmin_CWmax, CW_SHORT_SLOT);
+                        }
+
+                } else { //11g STA
+                        if (mMacMode != PURE_B_MODE && mMacMode != PURE_A_MODE) {
+
+                                Len = eLen(&extRates);
+                                for (i=0; i<Len; i++) {
+                                        if ( (extRates.buf[2+i] & 0x7f) > tmpMaxRate ) {
+                                                tmpMaxRate = (extRates.buf[2+i] & 0x7f);
+                                        }
+                                }
+                                bErpSta = TRUE;
+                                //FPRINT("11g STA");
+                        } else {
+                                FPRINT("Pure B mode don't support G sta");
+                                asStatus = SC_UNSUP_RATES;
+                                goto check_failed;
+                        }
+                }
+
+                MaxRate = RateConvert((tmpMaxRate & 0x7f));
+
+                if (MaxRate > mMaxTxRate)
+                        MaxRate = mMaxTxRate;
+
+                if (signal->id == SIG_REASSOC)
+                        notifyStatus = STA_REASOC_REQ;
+
+                if (!pdot11Obj->StatusNotify(notifyStatus, (U8 *)&Sta)) { //Accept it
+                        //if ((mDynKeyMode == DYN_KEY_TKIP) || (mDynKeyMode == DYN_KEY_AES)){
+                        if (macp->cardSetting.WPAIeLen) {
+                                if (getElem(rdu, EID_WPA, &WPA)||getElem(rdu,EID_RSN,&WPA)) {
+                                        //zd1205_OctetDump("AssocRequest = ", asRdu->body, asRdu->bodyLen);
+                                        //zd1205_OctetDump("AssocRequest WPA_IE = ", &WPA.buf[2], WPA.buf[1]);
+                                        if (pdot11Obj->AssocRequest) {
+                                                if (pdot11Obj->AssocRequest((U8 *)&Sta, rdu->body, rdu->bodyLen)) { //reject
+                                                        asStatus = SC_UNSPEC_FAILURE;
+                                                        goto check_failed;
+                                                        //we need reason code here
+                                                }
+                                        }
+                                } else {
+                                        asStatus = SC_UNSPEC_FAILURE;
+                                        goto wpa_check_failed;
+                                }
+                        }
+
+                        //wpa_check_ok:
+                        if (!UpdateStaStatus(&Sta, STATION_STATE_ASOC, vapId)) {
+                                asStatus = SC_AP_FULL;
+                        } else {
+                                AssocInfoUpdate(&Sta, MaxRate, lsInterval, ZydasMode, Preamble, bErpSta, vapId);
+                                aid = AIdLookup(&Sta);
+                                printk(KERN_DEBUG "Re_Asoc: aid=%d\n", aid);
+                                pHash = HashSearch(&Sta);
+                                if (pHash != NULL) {
+                                        if (!pHash->AlreadyIn) {
+                                                pHash->AlreadyIn=1;
+                                                mCurrConnUser++;
+                                                if (bErpSta == FALSE) {
+                                                        printk(KERN_DEBUG "Increment mNumBOnlySta\n");
+                                                        mNumBOnlySta++;
+                                                }
+                                        }
+                                }
+
+                                asStatus = SC_SUCCESSFUL;
+                                if (signal->id == SIG_REASSOC)
+                                        notifyStatus1 = STA_REASSOCIATED;
+                                pdot11Obj->StatusNotify(notifyStatus1, (U8 *)&Sta);
+
+                                if (mMacMode != PURE_B_MODE && mMacMode != PURE_A_MODE) {
+                                        if (pdot11Obj->ConfigFlag & NON_ERP_PRESENT_SET) {
+                                                U32 tmpValue;
+                                                void *reg = pdot11Obj->reg;
+
+                                                // force enabled protection mode for debug
+                                                mErp.buf[2] |= (NON_ERP_PRESENT | USE_PROTECTION);
+                                                tmpValue = pdot11Obj->GetReg(reg, ZD_RTS_CTS_Rate);
+                                                tmpValue &= ~CTS_MOD_TYPE_OFDM;
+                                                tmpValue |= CTS_RATE_11M;
+                                                pdot11Obj->SetReg(reg, ZD_RTS_CTS_Rate, tmpValue);
+
+                                                if (Preamble == 0) { //long preamble
+                                                        mErp.buf[2] |= BARKER_PREAMBLE;
+                                                        tmpValue = pdot11Obj->GetReg(reg, ZD_RTS_CTS_Rate);
+                                                        tmpValue &= ~NON_BARKER_PMB_SET;
+                                                        tmpValue |= CTS_RATE_11M;
+                                                        pdot11Obj->SetReg(reg, ZD_RTS_CTS_Rate, tmpValue);
+                                                        //FPRINT("Enable Barker Preamble");
+                                                }
+                                                pdot11Obj->ConfigFlag |= ENABLE_PROTECTION_SET;
+                                                //FPRINT("Enable Protection Mode");
+                                        }
+                                }
+
+                        }
+                } else {
+                        //wpa_check_failed:
+                        asStatus = SC_UNSPEC_FAILURE;
+                }
+wpa_check_failed:
+
+                aid |= 0xC000;
+                if (aid != 0xC000) {
+                        FPRINT_V("Aid", aid);
+                        FPRINT_V("MaxRate", MaxRate);
+                }
+
+check_failed:
+                if (signal->id == SIG_REASSOC)
+                        type = ST_REASOC_RSP;
+                mkRe_AsocRspFrm(pfrmDesc, type, &Sta, mCap, asStatus, aid, &mBrates, pExtRate, vapId);
+                sendMgtFrame(signal, pfrmDesc);
+
+                return FALSE;
+        } else {
+                freeFdesc(pfrmDesc);
+                return TRUE;
+        }
+}
+
+BOOLEAN Re_AsocReq(Signal_t *signal)
+{
+        FrmDesc_t *pfrmDesc;
+        U8 vapId = 0;
+        TypeSubtype subType = ST_ASOC_REQ;
+        Element *pExtRate = NULL;
+
+        FPRINT("Re_AsocReq");
+        if (memcmp(zeroMacAddress, (u8*)&mBssId, 6)==0) {
+                sigEnque(pMgtQ, (signal));
+                return FALSE;
+        }
+
+        pfrmDesc = allocFdesc();
+        if(!pfrmDesc) {
+                sigEnque(pMgtQ, (signal));
+                return FALSE;
+        }
+
+
+        if (signal->id == SIG_REASSOC_REQ) {
+                subType = ST_REASOC_REQ;
+        }
+
+        pExtRate = &mExtRates;
+
+        memcpy((U8 *)&AsSta, (U8 *)&mBssId, 6);
+
+        mkRe_AsocReqFrm(pfrmDesc, subType, &mBssId, mCap, mListenInterval,
+                        &mOldAP, &mSsid, &mBrates, pExtRate, &mWPAIe, vapId);
+
+        pdot11Obj->StartTimer(ASOC_TIMEOUT, DO_ASOC);
+        AsocState = STE_WAIT_ASOC_RSP;
+        return sendMgtFrame(signal, pfrmDesc);
+}
+
+BOOLEAN Re_AsocRsp(Signal_t *signal)
+{
+        Hash_t	*pHash;
+        FrmDesc_t *pfrmDesc;
+        Frame_t *rdu;
+        U8 vapId = 0;
+        MacAddr_t Sta;
+        U16 status;
+
+        //ZDEBUG("Re_AsocRsp");
+        FPRINT("Re_AsocRsp");
+
+        pfrmDesc = signal->frmInfo.frmDesc;
+        rdu = pfrmDesc->mpdu;
+
+        memcpy((U8 *)&Sta, (U8 *)addr2(rdu), 6);
+        if (memcmp(&AsSta, &Sta, 6) != 0) {
+                //FPRINT("Not for my Assoc AP");
+                goto asoc_release;
+        }
+
+        pdot11Obj->StopTimer(DO_ASOC);
+        AsocState = STE_ASOC_IDLE;
+
+
+        status = status(rdu);
+        if (status == SC_SUCCESSFUL) {
+                U8	Len;
+                U8	tmpMaxRate = 0x02;
+                U8	ZydasMode = 0;
+                U8	Preamble = 0;
+                U8	MaxRate;
+                BOOLEAN bErpSta = FALSE;
+                int i;
+                U8	HigestBasicRate = 0;
+
+                UpdateStaStatus(&Sta, STATION_STATE_ASOC, vapId);
+                pHash = HashSearch(&Sta);
+                if (pHash != NULL) {
+                        if (!pHash->AlreadyIn) {
+                                pHash->AlreadyIn=1;
+                                mCurrConnUser++;
+                        }
+                }
+
+                mAPCap = cap(rdu);
+
+                //check capability
+                if (mAPCap & CAP_SHORT_PREAMBLE) {
+                        Preamble = 1;
+                } else {
+                        Preamble = 0;
+                }
+
+                mAid = (aid(rdu) & 0x3FFF);
+                getElem(rdu, EID_SUPRATES, &mAPBrates);
+                //zd1205_dump_data("mAPBrates", &mAPBrates.buf[2], mAPBrates.buf[1]);
+
+                if (getElem(rdu, EID_EXT_RATES, &mAPErates)) {
+                        //zd1205_dump_data("mAPErates", &mAPErates.buf[2], mAPErates.buf[1]);
+                }
+
+                memcpy((U8 *)&mBssId, (U8 *)addr2(rdu), 6);
+                mAssoc = TRUE;
+
+                //update supported rates
+                HW_SetSupportedRate(pdot11Obj, (U8 *)&mAPBrates);
+                HW_SetSupportedRate(pdot11Obj, (U8 *)&mAPErates);
+
+                Len = eLen(&mAPBrates);
+                for (i=0; i<Len; i++) {
+                        if ((mAPBrates.buf[2+i] & 0x7f) > tmpMaxRate ) {
+                                tmpMaxRate = (mAPBrates.buf[2+i] & 0x7f);
+                                if (mAPBrates.buf[2+i] & 0x80)
+                                        HigestBasicRate = mAPBrates.buf[2+i];
+                        }
+
+                        if (((mAPBrates.buf[2+i] & 0x7f) == 0x21) && (!(mAPCap & CAP_PBCC_ENABLE))) { //Zydas 16.5M
+                                ZydasMode = 1;
+                        }
+                }
+
+
+                Len = eLen(&mAPErates);
+                for (i=0; i<Len; i++) {
+                        if ((mAPErates.buf[2+i] & 0x7f) > tmpMaxRate ) {
+                                tmpMaxRate = (mAPErates.buf[2+i] & 0x7f);
+                                if (mAPErates.buf[2+i] & 0x80)
+                                        HigestBasicRate = mAPErates.buf[2+i];
+                        }
+                }
+
+                //FPRINT_V("tmpMaxRate", tmpMaxRate);
+                //FPRINT_V("mMaxTxRate", mMaxTxRate);
+                MaxRate = RateConvert((tmpMaxRate & 0x7f));
+                //FPRINT_V("MaxRate", MaxRate);
+                if (MaxRate > mMaxTxRate)
+                        MaxRate = mMaxTxRate;
+                memset(mAPBrates.buf, 0, sizeof(Element));
+                memset(mAPErates.buf, 0, sizeof(Element));
+                AssocInfoUpdate(&mBssId, MaxRate, mAid, ZydasMode, Preamble, bErpSta, vapId);
+
+                pdot11Obj->StatusNotify(STA_ASSOCIATED, (U8 *)&mBssId);
+                pdot11Obj->Aid = mAid;
+                mConnRetryCnt = 0;
+
+                FPRINT_V("Aid", mAid);
+                FPRINT_V("MaxRate", MaxRate);
+        } else {
+                FPRINT("Asoc Failed!!!");
+                FPRINT_V("Status Code", status);
+        }
+
+asoc_release:
+        freeFdesc(pfrmDesc);
+        return TRUE;
+}
+
+
+BOOLEAN AsocTimeOut(Signal_t *signal)
+{
+        U8 vapId = 0;
+        FPRINT("AsocTimeOut");
+
+        if (AsocState == STE_WAIT_ASOC_RSP) {
+                AsocState = STE_ASOC_IDLE;
+                UpdateStaStatus(&mBssId, STATION_STATE_DIS_ASOC, vapId);
+        }
+
+        mRequestFlag |= CONNECT_TOUT_SET;
+        return FALSE;
+}
+
+
+BOOLEAN AsocEntry(Signal_t *signal)
+{
+        FrmDesc_t *pfrmDesc;
+
+        if (AsocState == STE_ASOC_IDLE) {
+                switch(signal->id) {
+                case SIG_DIASSOC_REQ:
+                        return DisasocReq(signal);
+
+                case SIG_DISASSOC:
+                        return Disasoc(signal);
+
+                case SIG_ASSOC:
+                case SIG_REASSOC:
+                        return Re_Asociate(signal);
+
+                case SIG_ASSOC_REQ:
+                case SIG_REASSOC_REQ:
+                        return Re_AsocReq(signal);
+
+                default:
+                        goto asoc_discard;
+                }
+        } else if (AsocState == STE_WAIT_ASOC_RSP) {
+                switch(signal->id) {
+                case SIG_DIASSOC_REQ:
+                        return DisasocReq(signal);
+
+                case SIG_DISASSOC:
+                        return Disasoc(signal);
+
+                case SIG_ASSOC:
+                case SIG_REASSOC:
+                        return Re_Asociate(signal);
+
+                case SIG_ASSOC_REQ:
+                case SIG_REASSOC_REQ:
+                        return Re_AsocReq(signal);
+
+                case SIG_ASSOC_RSP:
+                case SIG_REASSOC_RSP:
+                        return Re_AsocRsp(signal);
+
+                case SIG_TO_ASOC:
+
+                        return AsocTimeOut(signal);
+
+                default:
+                        goto asoc_discard;
+                }
+        } else
+                goto asoc_discard;
+
+asoc_discard:
+        pfrmDesc = signal->frmInfo.frmDesc;
+        freeFdesc(pfrmDesc);
+        return TRUE;
+}
+
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdauthreq.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdauthreq.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdauthreq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdauthreq.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,212 @@
+#ifndef __ZDAUTHREQ_C__
+#define __ZDAUTHREQ_C__
+
+#include "zd80211.h"
+
+U8 AuthReqState = STE_AUTH_REQ_IDLE;
+static MacAddr_t AuSta;
+
+
+BOOLEAN DeauthReq(Signal_t *signal)
+{
+        FrmDesc_t *pfrmDesc;
+        MacAddr_t Sta;
+        ReasonCode Rsn = RC_UNSPEC_REASON;
+        U8	vapId = 0;
+
+        ZDEBUG("DeauthReq");
+
+        memcpy((U8 *)&Sta, (U8 *)&signal->frmInfo.Sta, 6);
+        Rsn = signal->frmInfo.rCode;
+        pdot11Obj->StatusNotify(STA_DEAUTHED, (u8 *)&Sta);
+
+        vapId = signal->vapId;
+        UpdateStaStatus(&Sta, STATION_STATE_NOT_AUTH, vapId);
+
+        pfrmDesc = allocFdesc();
+        if(!pfrmDesc) {
+                sigEnque(pMgtQ, (signal));
+                return FALSE;
+        }
+
+        mkDisAssoc_DeAuthFrm(pfrmDesc, ST_DEAUTH, &Sta, Rsn, vapId);
+        sendMgtFrame(signal, pfrmDesc);
+
+        return FALSE;
+}
+
+
+BOOLEAN AuthReq(Signal_t *signal)
+{
+        FrmDesc_t *pfrmDesc;
+        U8 vapId = 0;
+        U16 auSC = SC_SUCCESSFUL;
+
+        //ZDEBUG("AuthReq");
+        FPRINT("AuthReq");
+        pfrmDesc = allocFdesc();
+        if(!pfrmDesc) {
+                FPRINT("allocFdesc failed");
+                sigEnque(pMgtQ, (signal));
+                return FALSE;
+        }
+
+        memcpy((U8 *)&AuSta, (U8 *)&signal->frmInfo.Sta, 6);
+        //memcpy((U8 *)&AuSta, (U8 *)&mBssId, 6);
+        mkAuthFrm(pfrmDesc, &AuSta, mAuthAlg, 1, auSC, NULL, vapId);
+        pdot11Obj->StartTimer(AUTH_TIMEOUT, DO_AUTH);
+        AuthReqState = STE_WAIT_AUTH_SEQ2;
+        return sendMgtFrame(signal, pfrmDesc);
+}
+
+
+BOOLEAN AuthEven(Signal_t *signal)
+{
+        FrmDesc_t *pfrmDesc;
+        Frame_t *rdu;
+        U16 auAlg;
+        U16	auSeq;
+        U16 auSC;
+        U8 vapId = 0;
+        MacAddr_t Sta;
+        U8 ChalText[130];
+
+        //ZDEBUG("AuthEven");
+        FPRINT("AuthEven");
+        pfrmDesc = signal->frmInfo.frmDesc;
+        rdu = pfrmDesc->mpdu;
+        auSeq = authSeqNum(rdu);
+        auAlg = authType(rdu);
+        memcpy((U8 *)&Sta, (U8 *)addr2(rdu), 6);
+        if (memcmp(&AuSta, &Sta, 6) != 0) {
+                //FPRINT("Not for my Auth AP");
+                goto auth_release;
+        }
+
+        if ((AuthReqState == STE_WAIT_AUTH_SEQ2) && (auSeq != 2)) {
+                FPRINT("Seq!= 2");
+                goto auth_release;
+        }
+
+        if ((AuthReqState == STE_WAIT_AUTH_SEQ4) && (auSeq != 4)) {
+                FPRINT("Seq!= 4");
+                goto auth_release;
+        }
+
+        auSC = authStatus(rdu);
+        if (auSC != SC_SUCCESSFUL) {
+                FPRINT("Auth Failed!!!");
+                FPRINT_V("Status Code", auSC);
+                goto auth_release;
+        }
+
+        pdot11Obj->StopTimer(DO_AUTH);
+        //FPRINT_V("auAlg", auAlg);
+
+        if (AuthReqState == STE_WAIT_AUTH_SEQ4) {
+                UpdateStaStatus(&Sta, STATION_STATE_AUTH_KEY, vapId);
+                AuthReqState = STE_AUTH_REQ_IDLE;
+
+                //do Assoicate
+                signal->id = SIG_ASSOC_REQ;
+                signal->block = BLOCK_ASOC;
+                sigEnque(pMgtQ, (signal));
+                freeFdesc(pfrmDesc);
+                return FALSE;
+
+        } else if (AuthReqState == STE_WAIT_AUTH_SEQ2) {
+                if (auAlg == OPEN_SYSTEM) {
+                        FPRINT("Auth Success !!!");
+                        UpdateStaStatus(&Sta, STATION_STATE_AUTH_OPEN, vapId);
+                        AuthReqState = STE_AUTH_REQ_IDLE;
+
+                        //do Assoicate
+                        signal->id = SIG_ASSOC_REQ;
+                        signal->block = BLOCK_ASOC;
+                        sigEnque(pMgtQ, (signal));
+                        freeFdesc(pfrmDesc);
+                        return FALSE;
+                }
+
+                if (auAlg == SHARE_KEY) {
+                        if (!getElem(rdu, EID_CTEXT, (Element *)&ChalText[0])) {
+                                FPRINT("Get ChalText failed");
+                                goto auth_release;
+                        }
+
+                        FPRINT("Send Auth Seq 3 frame");
+                        auSC = SC_SUCCESSFUL;
+                        mkAuthFrm(pfrmDesc, &mBssId, mAuthAlg, 3, auSC, &ChalText[2], vapId);
+                        pdot11Obj->StartTimer(AUTH_TIMEOUT, DO_AUTH);
+                        AuthReqState = STE_WAIT_AUTH_SEQ4;
+                        pfrmDesc->ConfigSet |= FORCE_WEP_SET;
+                        return sendMgtFrame(signal, pfrmDesc);
+                }
+        }
+
+auth_release:
+        FPRINT("auth_release");
+        freeFdesc(pfrmDesc);
+        return TRUE;
+}
+
+
+BOOLEAN AuthTimeOut(Signal_t *signal)
+{
+        U8 vapId = 0;
+        FPRINT("AuthTimeOut");
+
+        if 	((AuthReqState == STE_WAIT_AUTH_SEQ2) ||
+
+
+                        (AuthReqState == STE_WAIT_AUTH_SEQ4)) {
+                UpdateStaStatus(&mBssId, STATION_STATE_NOT_AUTH, vapId);
+                AuthReqState = STE_AUTH_REQ_IDLE;
+        }
+
+        mRequestFlag |= CONNECT_TOUT_SET;
+        return FALSE;
+}
+
+
+BOOLEAN AuthReqEntry(Signal_t *signal)
+{
+        FrmDesc_t *pfrmDesc;
+
+        if (AuthReqState == STE_AUTH_REQ_IDLE) {
+                switch(signal->id) {
+                case SIG_DEAUTH_REQ:
+                        return DeauthReq(signal);
+
+                case SIG_AUTH_REQ:
+                        return AuthReq(signal);
+
+                default:
+                        goto auth_discard;
+                }
+        } else if ((AuthReqState == STE_WAIT_AUTH_SEQ2) || (AuthReqState == STE_WAIT_AUTH_SEQ4)) {
+                switch(signal->id) {
+                case SIG_DEAUTH_REQ:
+                        return TRUE;
+
+                case SIG_AUTH_REQ:
+                        return TRUE;
+
+                case SIG_AUTH_EVEN:
+                        return AuthEven(signal);
+
+                case SIG_TO_AUTH:
+                        return AuthTimeOut(signal);
+
+                default:
+                        goto auth_discard;
+                }
+        } else
+                goto auth_discard;
+
+auth_discard:
+        pfrmDesc = signal->frmInfo.frmDesc;
+        freeFdesc(pfrmDesc);
+        return TRUE;
+}
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdauthrsp.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdauthrsp.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdauthrsp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdauthrsp.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,254 @@
+#ifndef __ZDAUTHRSP_C__
+#define __ZDAUTHRSP_C__
+
+#include "zd80211.h"
+#include "zd1205.h"
+
+U8 AuthRspState = STE_AUTH_RSP_IDLE;
+static U8 arChalng[CHAL_TEXT_LEN]; 	//Challenge text
+static MacAddr_t Sta2;
+static MacAddr_t Sta;
+extern struct net_device *g_dev;
+
+BOOLEAN CheckAlg(U8 alg)
+{
+        int i = 0;
+
+        for (i=0; i<3; i++) {
+                if (i == 2)
+                        return FALSE;
+
+                if (mAuthAlogrithms[i] == alg)
+                        return TRUE;
+        }
+        return FALSE;
+}
+
+
+BOOLEAN AuthOdd_Idle(Signal_t *signal)
+{
+        struct zd1205_private *macp=g_dev->priv;
+        FrmDesc_t *pfrmDesc;
+        Frame_t *rdu;
+        U16 arAlg;
+        U16	arSeq;
+        U16	arSC;
+        U8 vapId = 0;
+
+        ZDEBUG("AuthOdd_Idle");
+        pfrmDesc = signal->frmInfo.frmDesc;
+        rdu = pfrmDesc->mpdu;
+        arSeq = authSeqNum(rdu);
+        arAlg = authType(rdu);
+        memcpy((U8 *)&Sta, (U8 *)addr2(rdu), 6);
+
+        if (arSeq != 1) {
+                arSC = SC_AUTH_OUT_OF_SEQ;
+                UpdateStaStatus(&Sta, STATION_STATE_NOT_AUTH, vapId);
+                mkAuthFrm(pfrmDesc, &Sta, arAlg, arSeq+1, arSC, NULL, vapId);
+                return sendMgtFrame(signal, pfrmDesc);
+        }
+
+        if (!CheckAlg(arAlg)) {
+                arSC = SC_UNSUPT_ALG;
+                UpdateStaStatus(&Sta, STATION_STATE_NOT_AUTH, vapId);
+                mkAuthFrm(pfrmDesc, &Sta, arAlg, arSeq+1, arSC, NULL, vapId);
+                return sendMgtFrame(signal, pfrmDesc);
+        }
+
+        if (pdot11Obj->StatusNotify(STA_AUTH_REQ, (U8 *)&Sta)) { //Reject it
+                arSC = SC_UNSPEC_FAILURE;
+                UpdateStaStatus(&Sta, STATION_STATE_NOT_AUTH, vapId);
+                mkAuthFrm(pfrmDesc, &Sta, arAlg, arSeq+1, arSC, NULL, vapId);
+                return sendMgtFrame(signal, pfrmDesc);
+        }
+
+        if (arAlg == OPEN_SYSTEM) {
+                if (UpdateStaStatus(&Sta, STATION_STATE_AUTH_OPEN, vapId))
+                        arSC = SC_SUCCESSFUL;
+                else
+                        arSC = SC_AP_FULL;
+
+                mkAuthFrm(pfrmDesc, &Sta, arAlg, arSeq+1, arSC, NULL, vapId);
+                return sendMgtFrame(signal, pfrmDesc);
+        }
+
+        if (arAlg == SHARE_KEY) {
+                //WPA
+                if (macp->cardSetting.WPAIeLen) {
+                        //if ((mDynKeyMode == DYN_KEY_TKIP) || (mDynKeyMode == DYN_KEY_AES)){
+                        arSC = SC_UNSUPT_ALG;
+                        UpdateStaStatus(&Sta, STATION_STATE_NOT_AUTH, vapId);
+                        mkAuthFrm(pfrmDesc, &Sta, arAlg, arSeq+1, arSC, NULL, vapId);
+
+                        return sendMgtFrame(signal, pfrmDesc);
+                } else {
+                        if ((mCurrConnUser + 1) > mLimitedUser)
+                                arSC = SC_AP_FULL;
+                        else
+                                arSC = SC_SUCCESSFUL;
+
+                        mkAuthFrm(pfrmDesc, &Sta, arAlg, arSeq+1, arSC, arChalng, vapId);
+                        if (arSC == SC_SUCCESSFUL) {
+                                pdot11Obj->StartTimer(512, DO_CHAL);
+                                AuthRspState = STE_AUTH_RSP_WAIT_CRSP;
+                        }
+                        return sendMgtFrame(signal, pfrmDesc);
+                }
+        }
+
+        freeFdesc(pfrmDesc);
+        return TRUE;
+}
+
+
+BOOLEAN AuthOdd_WaitChalRsp(Signal_t *signal)
+
+{
+        FrmDesc_t *pfrmDesc;
+        Frame_t *rdu;
+        U8 arAlg2;
+        U16	arSeq2;
+        U16	arSC;
+        U8 vapId = 0;
+        U8 ChalText[130];
+
+        ZDEBUG("AuthOdd_WaitChalRsp");
+        pfrmDesc = signal->frmInfo.frmDesc;
+        rdu = pfrmDesc->mpdu;
+
+        arSeq2	= authSeqNum(rdu);
+        arAlg2	= authType(rdu);
+        memcpy((U8 *)&Sta2, (U8 *)addr2(rdu), 6);
+
+        if(arSeq2 == 1) {
+                if (memcmp(&Sta, &Sta2, 6) == 0) { // open system request from a different station
+                        arSC = SC_UNSPEC_FAILURE;
+                        goto fail_sta2;
+                }
+
+                if (arAlg2 == OPEN_SYSTEM) {
+                        arSC = SC_SUCCESSFUL;
+                        UpdateStaStatus(&Sta, STATION_STATE_AUTH_OPEN, vapId);
+                        mkAuthFrm(pfrmDesc, &Sta2, arAlg2, arSeq2+1, arSC, NULL, vapId);
+
+                        return sendMgtFrame(signal, pfrmDesc);
+                } else {
+                        arSC = SC_UNSPEC_FAILURE;
+                        goto fail_sta2;
+                }
+        } else if(arSeq2 == 3) {
+                if (memcmp(&Sta, &Sta2, 6) == 0) {
+                        pdot11Obj->StopTimer(DO_CHAL);
+                        if (wepBit(rdu)) {
+                                if (!getElem(rdu, EID_CTEXT, (Element *)&ChalText[0])) {
+                                        goto chal_failed;
+                                } else {
+                                        //zd1205_OctetDump("ChalText = ", &ChalText[0], CHAL_TEXT_LEN+2);
+                                        if (memcmp(&ChalText[2], arChalng, CHAL_TEXT_LEN) != 0) {
+                                                goto chal_failed;
+                                        }
+                                }
+
+                                if (UpdateStaStatus(&Sta, STATION_STATE_AUTH_KEY, vapId))
+                                        arSC = SC_SUCCESSFUL;
+                                else
+                                        arSC = SC_AP_FULL;
+                        } else {
+chal_failed:
+                                arSC = SC_CHAL_FAIL;
+                                UpdateStaStatus(&Sta2, STATION_STATE_NOT_AUTH, vapId);
+                        }
+                } else {
+                        arSC = SC_UNSPEC_FAILURE;
+                        UpdateStaStatus(&Sta2, STATION_STATE_NOT_AUTH, vapId);
+                }
+                AuthRspState = STE_AUTH_RSP_IDLE;
+                mkAuthFrm(pfrmDesc, &Sta2, arAlg2, arSeq2+1, arSC, NULL, vapId);
+                return sendMgtFrame(signal, pfrmDesc);
+        } else {
+                arSC = SC_UNSPEC_FAILURE;
+                goto fail_sta2;
+        }
+
+fail_sta2:
+        UpdateStaStatus(&Sta2, STATION_STATE_NOT_AUTH, vapId);
+        mkAuthFrm(pfrmDesc, &Sta2, arAlg2, arSeq2+1, arSC, NULL, vapId);
+        return sendMgtFrame(signal, pfrmDesc);
+}
+
+
+BOOLEAN Tchal_WaitChalRsp(Signal_t *signal)
+{
+        U8 vapId = 0;
+
+        ZDEBUG("Tchal_WaitChalRsp");
+        if 	(AuthRspState == STE_AUTH_RSP_WAIT_CRSP) {
+                UpdateStaStatus(&Sta, STATION_STATE_NOT_AUTH, vapId);
+                AuthRspState = STE_AUTH_RSP_IDLE;
+        }
+        return FALSE;
+}
+
+
+BOOLEAN Deauth(Signal_t *signal)
+{
+        FrmDesc_t *pfrmDesc;
+        Frame_t *rdu;
+        U8 vapId = 0;
+
+        ZDEBUG("Deauth");
+        pfrmDesc = signal->frmInfo.frmDesc;
+        rdu = pfrmDesc->mpdu;
+        UpdateStaStatus(addr2(rdu), STATION_STATE_NOT_AUTH, vapId);
+        if (memcmp(&mBssId, addr2(rdu), 6) == 0)
+                pdot11Obj->StatusNotify(STA_DEAUTHED, (U8 *)addr2(rdu));
+
+        if (mBssType == INFRASTRUCTURE_BSS) {
+                //if (memcmp(&mBssId, addr2(rdu), 6) == 0){
+                FPRINT("Deauth");
+                mAssoc = FALSE;
+                memset((U8 *)&mBssId, 0, 6);
+                mRequestFlag |= DIS_CONNECT_SET;
+                //}
+        }
+
+        //here to handle deauth ind.
+        freeFdesc(pfrmDesc);
+        return TRUE;
+}
+
+
+BOOLEAN AuthRspEntry(Signal_t *signal)
+{
+        if (AuthRspState == STE_AUTH_RSP_IDLE) {
+                switch(signal->id) {
+                case SIG_AUTH_ODD:
+                        return AuthOdd_Idle(signal);
+
+                case SIG_DEAUTH:
+                        return Deauth(signal);
+
+                default:
+                        return TRUE;
+                }
+        }
+        else if (AuthRspState == STE_AUTH_RSP_WAIT_CRSP) {
+                switch(signal->id) {
+                case SIG_AUTH_ODD:
+                        return AuthOdd_WaitChalRsp(signal);
+
+                case SIG_DEAUTH:
+                        return Deauth(signal);
+
+                case SIG_TO_CHAL:
+                        return Tchal_WaitChalRsp(signal);
+
+                default:
+                        return TRUE;
+                }
+        } else
+                return TRUE;
+}
+
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdbuf.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdbuf.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdbuf.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdbuf.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,320 @@
+#ifndef __ZDBUF_C__
+#define __ZDBUF_C__
+
+#include "zd80211.h"
+#include <linux/vmalloc.h>
+
+
+#define MAX_SIGNAL_NUM		64
+
+SignalQ_t mgtQ, txQ, awakeQ, psQ[MAX_RECORD];
+SignalQ_t *pMgtQ = &mgtQ, *pTxQ, *pAwakeQ, *pPsQ[MAX_RECORD];
+
+Signal_t *FreeSignalList;
+Signal_t *SignalBuf[MAX_SIGNAL_NUM];
+U32 freeSignalCount;
+
+FrmDesc_t *FreeFdescList;
+FrmDesc_t *FdescBuf[MAX_SIGNAL_NUM];
+U32 freeFdescCount = MAX_SIGNAL_NUM;
+
+U32 allocCnt = 0;
+U32 freeCnt = 0;
+
+void initSigQue(SignalQ_t *Q)
+{
+        U32 flags;
+
+        flags = pdot11Obj->EnterCS();
+        Q->first = NULL;
+        Q->last = NULL;
+        Q->cnt = 0;
+        pdot11Obj->ExitCS(flags);
+}
+
+void releaseSignalBuf(void)
+{
+        int i;
+
+       /* ath_desc: workaround for detecting device multiple times */
+        for (i=0; i<MAX_SIGNAL_NUM; i++) {
+                vfree((void *)SignalBuf[i]);
+                SignalBuf[i] = NULL;
+       }
+
+        /*  Point the the FreeSignalList to NULL */
+        FreeSignalList = NULL;
+}
+
+void initSignalBuf(void)
+{
+        int i;
+        U32 flags;
+
+        initSigQue(pMgtQ);
+        FreeSignalList = NULL;
+        freeSignalCount = MAX_SIGNAL_NUM;
+
+        for (i=0; i<MAX_SIGNAL_NUM; i++) {
+                SignalBuf[i] = (Signal_t *)vmalloc(sizeof(Signal_t));  //can't use for DMA operation
+
+                if (!SignalBuf[i]) {
+                        FPRINT("80211: initSignalBuf failed");
+                        //pdot11Obj->ExitCS(flags);
+                        return;
+                }
+                flags = pdot11Obj->EnterCS();
+                SignalBuf[i]->pNext = FreeSignalList;
+                FreeSignalList = SignalBuf[i];
+                pdot11Obj->ExitCS(flags);
+        }
+}
+
+
+Signal_t *allocSignal(void)
+{
+        U32 flags;
+        Signal_t *signal = NULL;
+
+        flags = pdot11Obj->EnterCS();
+        if (FreeSignalList != NULL) {
+                signal = FreeSignalList;
+                FreeSignalList = FreeSignalList->pNext;
+                signal->pNext = NULL;
+                signal->buf = NULL;
+                signal->frmInfo.frmDesc = NULL;
+                freeSignalCount-- ;
+        }
+
+        pdot11Obj->ExitCS(flags);
+        return signal;
+}
+
+void freeSignal(Signal_t *signal)
+{
+        U32 flags;
+
+        if (!signal) {
+                FPRINT("Free NULL signal");
+                return;
+        }
+
+        flags = pdot11Obj->EnterCS();
+        signal->buf = NULL;
+        signal->vapId=0;
+
+        signal->frmInfo.frmDesc = NULL;
+        signal->pNext = FreeSignalList;
+        FreeSignalList = signal;
+        freeSignalCount++;
+        pdot11Obj->ExitCS(flags);
+}
+
+void re_initFdescBuf(void)
+{
+        int i;
+        for (i=0; i<MAX_SIGNAL_NUM; i++)
+                freeFdesc(FdescBuf[i]);
+        freeFdescCount = MAX_SIGNAL_NUM;
+
+}
+
+void initFdescBuf(void)
+{
+        int i;
+        U32 flags;
+        //FrmDesc_t *pFrmDesc;
+
+        flags = pdot11Obj->EnterCS();
+        FreeFdescList = NULL;
+
+        for (i=0; i<MAX_SIGNAL_NUM; i++) {
+                FdescBuf[i] = (FrmDesc_t *) kmalloc(sizeof (FrmDesc_t), GFP_ATOMIC);  //may use for DMA operation
+
+                if (!FdescBuf[i]) {
+                        FPRINT("80211: initFdescBuf failed");
+                        pdot11Obj->ExitCS(flags);
+                        return;
+                }
+
+                FdescBuf[i]->pNext = FreeFdescList;
+                FreeFdescList = FdescBuf[i];
+        }
+
+#if 0
+        FPRINT_V("FreeFdescList", FreeFdescList);
+        pFrmDesc =  FreeFdescList;
+        for (i=0; i<MAX_SIGNAL_NUM; i++) {
+                FPRINT_V("pFrmDesc", pFrmDesc);
+                FPRINT_V("pFrmDesc->pNext", pFrmDesc->pNext);
+                pFrmDesc = pFrmDesc->pNext;
+        }
+#endif
+
+        pdot11Obj->ExitCS(flags);
+}
+
+
+void releaseFdescBuf(void)
+{
+        int i;
+
+        for (i=0; i<MAX_SIGNAL_NUM; i++)
+                kfree((void *)FdescBuf[i]);
+
+        /*  Point the the FreeFdescList to NULL */
+        FreeFdescList = NULL;
+}
+
+
+FrmDesc_t *allocFdesc(void)
+{
+        U32 flags;
+        FrmDesc_t *pfrmDesc = NULL;
+
+        flags = pdot11Obj->EnterCS();
+
+        if (FreeFdescList != NULL) {
+                pfrmDesc = FreeFdescList;
+                FreeFdescList = FreeFdescList->pNext;
+                //memset(pfrmDesc,0,sizeof(FrmDesc_t));
+                //memset(pfrmDesc->mpdu,0,sizeof(Frame_t)*MAX_FRAG_NUM);
+                pfrmDesc->pNext = NULL;
+                pfrmDesc->ConfigSet = 0;
+                //pfrmDesc->bDataFrm = 0;
+                pfrmDesc->pHash = NULL;
+                pfrmDesc->bValid = TRUE;
+                freeFdescCount--;
+                allocCnt++;
+
+                if (FreeFdescList == NULL) {
+                        FPRINT("FreeFdescList == NULL");
+                        FPRINT_V("freeFdescCount", (U32)freeFdescCount);
+                        FPRINT_V("Cnt of MgtQ", pMgtQ->cnt);
+                }
+        }
+
+        pdot11Obj->ExitCS(flags);
+        //FPRINT_V("alloc pfrmDesc", (U32)pfrmDesc);
+        //FPRINT_V("FreeFdescList", (U32)FreeFdescList);
+
+        return pfrmDesc;
+}
+
+
+void freeFdesc(FrmDesc_t *pfrmDesc)
+{
+        U32 flags;
+        FrmDesc_t *pOldFdesc;
+
+        if (!pfrmDesc) {
+                FPRINT("Free NULL pfrmDesc");
+                return;
+        }
+
+        flags = pdot11Obj->EnterCS();
+#if 0
+
+        if (!pfrmDesc->bValid) {
+                FPRINT_V("pfrmDesc->bValid", pfrmDesc->bValid);
+                pdot11Obj->ExitCS(flags);
+                return;
+        }
+#endif
+
+        //FPRINT_V("FreeFdescList", (U32)FreeFdescList);
+        pOldFdesc =  FreeFdescList;
+        pfrmDesc->ConfigSet = 0;
+        //pfrmDesc->bDataFrm = 0;
+        pfrmDesc->pHash = NULL;
+        pfrmDesc->pNext = FreeFdescList;
+        FreeFdescList = pfrmDesc;
+        pfrmDesc->bValid = FALSE;
+        freeFdescCount++;
+        freeCnt++;
+        //FPRINT_V("free pfrmDesc", (U32)pfrmDesc);
+
+#if 0
+
+        if (FreeFdescList == 0) {
+                FPRINT("xxxxxxxxxx");
+                FPRINT_V("free pfrmDesc", (U32)pfrmDesc);
+                FPRINT_V("freeFdescCount", (U32)freeFdescCount);
+        }
+
+        if (pfrmDesc == pfrmDesc->pNext) {
+                FPRINT("ooooooooooo");
+                FPRINT_V("pOldFdesc", (U32)pOldFdesc);
+                FPRINT_V("free pfrmDesc", (U32)pfrmDesc);
+                FPRINT_V("freeFdescCount", (U32)freeFdescCount);
+        }
+#endif
+        pdot11Obj->ExitCS(flags);
+}
+
+
+Signal_t *sigDeque(SignalQ_t *Q)
+{
+        U32 flags;
+        Signal_t *signal = NULL;
+
+        flags = pdot11Obj->EnterCS();
+        if (Q->first != NULL) {
+                Q->cnt--;
+                signal = Q->first;
+                Q->first = (Q->first)->pNext;
+                if (Q->first == NULL)
+                        Q->last = NULL;
+        }
+        pdot11Obj->ExitCS(flags);
+        return signal;
+}
+
+
+void sigEnque(SignalQ_t *Q, Signal_t *signal)
+{
+        U32 flags;
+
+        flags = pdot11Obj->EnterCS();
+        signal->pNext = NULL;
+        if (Q->last == NULL) {
+                Q->first = signal;
+                Q->last = signal;
+        } else {
+                Q->last->pNext = signal;
+                Q->last = signal;
+        }
+        Q->cnt++;
+
+        if (Q == pMgtQ)
+                pdot11Obj->QueueFlag |= MGT_QUEUE_SET;
+        else if (Q == pTxQ)
+                pdot11Obj->QueueFlag |= TX_QUEUE_SET;
+        else if (Q == pAwakeQ)
+                pdot11Obj->QueueFlag |= AWAKE_QUEUE_SET;
+
+        pdot11Obj->ExitCS(flags);
+}
+
+
+void sigEnqueFirst(SignalQ_t *Q, Signal_t *signal)
+{
+        int i_state;
+
+        FPRINT("sigEnqueFirst");
+
+        i_state = pdot11Obj->EnterCS();
+        signal->pNext = Q->first;
+
+        if (Q->last == NULL) {
+                Q->last = signal;
+        }
+
+        Q->first = signal;
+        Q->cnt++;
+
+        pdot11Obj->ExitCS(i_state);
+}
+
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdbuf.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdbuf.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdbuf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdbuf.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,28 @@
+#ifndef __ZDBUF_H__
+#define __ZDBUF_H__
+
+
+extern SignalQ_t mgtQ, *pMgtQ;
+extern SignalQ_t txQ, *pTxQ;
+extern SignalQ_t awakeQ, *pAwakeQ;
+extern SignalQ_t psQ[MAX_RECORD], *pPsQ[MAX_RECORD];
+extern U32 freeSignalCount;
+extern U32 freeFdescCount;
+
+
+void initSigQue(SignalQ_t *Q);
+void sigEnque(SignalQ_t *Q, Signal_t *signal);
+void sigEnqueFirst(SignalQ_t *Q, Signal_t *signal);
+Signal_t *sigDeque(SignalQ_t* Q);
+void initSignalBuf(void);
+void initFdescBuf(void);
+void freeFdesc(FrmDesc_t *pfrmDesc);
+FrmDesc_t *allocFdesc(void);
+extern Signal_t* allocSignal(void);
+extern void freeSignal(Signal_t *signal);
+void releaseSignalBuf(void);
+void releaseFdescBuf(void);
+void re_initFdescBuf(void);
+
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdcompat.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdcompat.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdcompat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdcompat.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,90 @@
+#ifndef _ZDCOMPAT_H_
+#define _ZDCOMPAT_H_
+
+#ifndef KERNEL_VERSION
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+#ifndef INIT_TQUEUE
+#define INIT_TQUEUE(_tq, _routine, _data)                       \
+        do {                                                    \
+                (_tq)->next = NULL;                             \
+                (_tq)->sync = 0;                                \
+                PREPARE_TQUEUE((_tq), (_routine), (_data));     \
+        } while (0)
+#define PREPARE_TQUEUE(_tq, _routine, _data)                    \
+        do {                                                    \
+                (_tq)->routine = _routine;                      \
+                (_tq)->data = _data;                            \
+        } while (0)
+#endif
+
+#ifndef INIT_WORK
+#define work_struct tq_struct
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+#define schedule_work(a)   queue_task(a, &tq_scheduler)
+#else
+#define schedule_work(a)  schedule_task(a)
+#endif
+
+#define flush_scheduled_work  flush_scheduled_tasks
+#define INIT_WORK(_wq, _routine, _data)  INIT_TQUEUE(_wq, _routine, _data)
+#define PREPARE_WORK(_wq, _routine, _data)  PREPARE_TQUEUE(_wq, _routine, _data)
+#endif
+#endif // < 2.5 kernel
+
+
+#ifndef DECLARE_TASKLET
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+#define tasklet_schedule(a)   queue_task(a, &tq_scheduler)
+#else
+#define tasklet_schedule(a)   schedule_task(a)
+#endif
+#endif
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,38))
+typedef struct device netdevice_t;
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,4))
+typedef struct net_device netdevice_t;
+#else
+#undef netdevice_t
+typedef struct net_device netdevice_t;
+#endif
+
+#ifdef WIRELESS_EXT
+#if (WIRELESS_EXT < 13)
+struct iw_request_info
+{
+        __u16           cmd;            /* Wireless Extension command */
+        __u16           flags;          /* More to come ;-) */
+};
+#endif
+#endif
+
+/* linux < 2.5.69 */
+#ifndef IRQ_NONE
+typedef void irqreturn_t;
+#define IRQ_NONE
+#define IRQ_HANDLED
+#define IRQ_RETVAL(x)
+#endif
+
+#ifndef in_atomic
+#define in_atomic()  0
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))  // fixme
+#define URB_ASYNC_UNLINK  USB_ASYNC_UNLINK
+#else
+#define USB_QUEUE_BULK 0
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+#define free_netdev(x)       kfree(x)
+#endif
+
+
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdconfig linux-2.4.35.3-mct/drivers/usb/zd1211/zdconfig
--- linux-2.4.35.3/drivers/usb/zd1211/zdconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdconfig	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,5 @@
+#CONFIG_CARDBUS=y
+#CONFIG_PCI=y
+#CONFIG_ZD1202=y
+CONFIG_USB=y
+CONFIG_ZD1211=y
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zddebug.c linux-2.4.35.3-mct/drivers/usb/zd1211/zddebug.c
--- linux-2.4.35.3/drivers/usb/zd1211/zddebug.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zddebug.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,925 @@
+#ifndef _ZD_DEBUG_C_
+#define _ZD_DEBUG_C_
+
+#include "zddebug.h"
+#include "zdhw.h"
+#include "zdsm.h"
+#include "zdpmfilter.h"
+#include "zdhci.h"
+#include "zdpsmon.h"
+#include "zdutils.h"
+#ifdef HOST_IF_USB
+    #include "zd1211.h"
+#endif
+
+extern zd_80211Obj_t dot11Obj;
+
+//for debug message show
+extern u32 freeSignalCount;
+extern u32 freeFdescCount;
+extern void zd_ShowQInfo(void);
+extern void zd_ShowState(void);
+extern BOOLEAN mPrivacyInvoked;
+extern U16 mCap;
+extern U8 mWpaBcKeyLen;
+extern U8 mGkInstalled;
+extern U8 mDynKeyMode;
+extern U8 mKeyFormat;
+void zd1205_cont_tx(struct zd1205_private *macp, u8 rate);
+extern int zd_SetKeyContext(U8 *addr, U8 encryMode, U8 keyLength, U8 KeyId, U8 *pKeyContent);
+extern void ConfigBcnFIFO(void);
+extern BOOLEAN zd_CmdDeauth(MacAddr_t *sta, U8 rCode);
+extern BOOLEAN zd_CmdDisasoc(MacAddr_t *sta, U8 rCode);
+extern void update_beacon_interval(struct zd1205_private *macp, int val);
+void zd1205_set_sniffer_mode(struct zd1205_private *macp)
+{
+        struct net_device *dev = macp->device;
+
+        dev->type = ARPHRD_IEEE80211;
+        dev->hard_header_len = ETH_HLEN;
+        dev->addr_len = ETH_ALEN;
+
+        if (netif_running(dev))
+                netif_stop_queue(dev);
+
+        zd_writel(0x01, SnifferOn);
+        zd_writel(0xffffff, Rx_Filter);
+        zd_writel(0x08, EncryptionType);
+        macp->intrMask = RX_COMPLETE_EN;
+}
+
+void zd1205_dump_regs(struct zd1205_private *macp)
+{
+#ifndef HOST_IF_USB
+        spin_lock_irqsave(&macp->q_lock, flags);
+#endif
+
+        printk(KERN_DEBUG "*******************************************************\n");
+        printk(KERN_DEBUG "MACAddr_P1         = %08x  MACAddr_P2    = %08x\n",
+               zd_readl(MACAddr_P1), zd_readl(MACAddr_P2));
+        printk(KERN_DEBUG "BCNInterval        = %08x. BCNPLCPCfg    = %08x\n",
+               zd_readl(BCNInterval), zd_readl(BCNPLCPCfg));
+        printk(KERN_DEBUG "TSF_LowPart        = %08x, TSF_HighPart  = %08x\n",
+               zd_readl(TSF_LowPart), zd_readl(TSF_HighPart));
+        printk(KERN_DEBUG "DeviceState        = %08x, NAV_CCA       = %08x\n",
+               zd_readl(DeviceState), zd_readl(NAV_CCA));
+        printk(KERN_DEBUG "CRC32Cnt           = %08x, CRC16Cnt      = %08x\n",
+               zd_readl(CRC32Cnt), zd_readl(CRC16Cnt));
+        printk(KERN_DEBUG "TotalRxFrm         = %08x, TotalTxFrm    = %08x\n",
+               zd_readl(TotalRxFrm), zd_readl(TotalTxFrm));
+        printk(KERN_DEBUG "RxFIFOOverrun      = %08x, UnderrunCnt   = %08x\n",
+               zd_readl(RxFIFOOverrun), zd_readl(UnderrunCnt));
+        printk(KERN_DEBUG "BSSID_P1           = %08x, BSSID_P2      = %08x\n",
+               zd_readl(BSSID_P1), zd_readl(BSSID_P2));
+        printk(KERN_DEBUG "Pre_TBTT           = %08x, ATIMWndPeriod = %08x\n",
+               zd_readl(Pre_TBTT), zd_readl(ATIMWndPeriod));
+        printk(KERN_DEBUG "RetryCnt           = %08x, IFS_Value     = %08x\n",
+               zd_readl(RetryCnt), zd_readl(IFS_Value));
+        printk(KERN_DEBUG "NAV_CNT            = %08x, CWmin_CWmax   = %08x\n",
+               zd_readl(NAV_CNT), zd_readl(CWmin_CWmax));
+        //printk(KERN_DEBUG "GroupHash_P1       = %08x, GroupHash_P2  = %08x\n",
+        //    zd_readl(GroupHash_P1), zd_readl(GroupHash_P2));
+        printk(KERN_DEBUG "DecrypErr_UNI      = %08x, DecrypErr_Mul = %08x\n",
+               zd_readl(DecrypErr_UNI), zd_readl(DecrypErr_Mul));
+
+#ifndef HOST_IF_USB
+
+        printk(KERN_DEBUG "InterruptCtrl      = %08x, Rx_Filter     = %08x\n",
+               zd_readl(InterruptCtrl), zd_readl(Rx_Filter));
+        printk(KERN_DEBUG "ReadTcbAddress     = %08x, ReadRfdAddress= %08x\n",
+               zd_readl(ReadTcbAddress), zd_readl(ReadRfdAddress));
+        printk(KERN_DEBUG "BCN_FIFO_Semaphore = %08x, CtlReg1       = %08x\n",
+               zd_readl(BCN_FIFO_Semaphore),  zd_readl(CtlReg1));
+        printk(KERN_DEBUG "RX_OFFSET_BYTE     = %08x, RX_TIME_OUT   = %08x\n",
+               zd_readl(RX_OFFSET_BYTE), zd_readl(RX_TIME_OUT));
+        printk(KERN_DEBUG "CAM_DEBUG          = %08x, CAM_STATUS    = %08x\n",
+               zd_readl(CAM_DEBUG), zd_readl(CAM_STATUS));
+        printk(KERN_DEBUG "CAM_ROLL_TB_LOW    = %08x, CAM_ROLL_TB_HIGH = %08x\n",
+               zd_readl(CAM_ROLL_TB_LOW), zd_readl(CAM_ROLL_TB_HIGH));
+        printk(KERN_DEBUG "CAM_MODE           = %08x\n", zd_readl(CAM_MODE));
+#endif
+
+#ifndef HOST_IF_USB
+
+        spin_unlock_irqrestore(&macp->q_lock, flags);
+#endif
+}
+
+void zd1205_dump_cnters(struct zd1205_private *macp)
+{
+        zd1205_lock(macp);
+        printk(KERN_DEBUG "*************************************************\n");
+        printk(KERN_DEBUG "freeTxQ         = %08d, activeTxQ      = %08d\n", macp->freeTxQ->count, macp->activeTxQ->count);
+        printk(KERN_DEBUG "freeSignalCount = %08d, freeFdescCount = %08d\n", freeSignalCount, freeFdescCount);
+        //printk(KERN_DEBUG "hwTotalRxFrm    = %08d, hwTotalTxFrm   = %08d\n", macp->hwTotalRxFrm, macp->hwTotalTxFrm);
+        //printk(KERN_DEBUG "hwRxFIFOOverrun = %08d, hwUnderrunCnt  = %08d\n", macp->hwRxFIFOOverrun, macp->hwUnderrunCnt);
+        //printk(KERN_DEBUG "hwCRC32Cnt      = %08d, hwCRC16Cnt     = %08d\n", macp->hwCRC32Cnt, macp->hwCRC16Cnt);
+
+        //printk(KERN_DEBUG "ErrLongFrmCnt   = %08d, ErrShortFrmCnt = %08d\n", macp->ErrLongFrmCnt, macp->ErrShortFrmCnt);
+        //printk(KERN_DEBUG "ErrToHostFrmCnt = %08d, ErrZeroLenFrmCnt= %08d\n", macp->ErrToHostFrmCnt, macp->ErrZeroLenFrmCnt);
+        printk(KERN_DEBUG "rxOFDMDataFrame = %08d, rx11bDataFrame = %08d\n", macp->rxOFDMDataFrame, macp->rx11bDataFrame);
+        printk(KERN_DEBUG "rxSignalQuality = %08d, rxSignalStrength= %08d\n", macp->rxSignalQuality, macp->rxSignalStrength);
+        printk(KERN_DEBUG "rxRate          = %08d, txRate         = %08dx\n", macp->rxInfo.rate, macp->cardSetting.CurrTxRate);
+
+        //printk(KERN_DEBUG "rxNeedFragCnt   = %08d, rxCompFragCnt  = %08d\n", macp->rxNeedFragCnt, macp->rxCompFragCnt);
+        //printk(KERN_DEBUG "ArFreeFailCnt   = %08d, ArAgedCnt      = %08d\n", macp->ArFreeFailCnt, macp->ArAgedCnt);
+        //printk(KERN_DEBUG "ArSearchFailCnt = %08d, DropFirstFragCnt= %08d\n", macp->ArSearchFailCnt, macp->DropFirstFragCnt);
+        //printk(KERN_DEBUG "skb_req         = %08d, AllocSkbFailCnt= %08d\n", macp->skb_req, macp->AllocSkbFailCnt);
+        printk(KERN_DEBUG "txQueToUpCnt    = %08d, txQueSetCnt    = %08d\n", macp->txQueToUpCnt, macp->txQueSetCnt);
+        printk(KERN_DEBUG "sleepCnt        = %08d, wakeupCnt      = %08d\n", macp->sleepCnt, macp->wakeupCnt);
+        printk(KERN_DEBUG "WaitLenInfoCnt  = %08d, CompLenInfoCnt = %08d\n", macp->WaitLenInfoCnt, macp->CompLenInfoCnt);
+        printk(KERN_DEBUG "Continue2Rx     = %08d, NoMergedRxCnt  = %08d\n", macp->Continue2Rx, macp->NoMergedRxCnt);
+        printk(KERN_DEBUG "bcnCnt          = %08d, dtimCnt        = %08d\n", macp->bcnCnt, macp->dtimCnt);
+        printk(KERN_DEBUG "txCnt           = %08d, txCmpCnt       = %08d\n", macp->txCnt, macp->txCmpCnt);
+        printk(KERN_DEBUG "retryFailCnt    = %08d, rxCnt          = %08d\n", macp->retryFailCnt, macp->rxCnt);
+        printk(KERN_DEBUG "usbTxCnt        = %08d, usbTxCompCnt   = %08d\n", macp->usbTxCnt, macp->usbTxCompCnt);
+
+        printk(KERN_DEBUG "regWaitRCompCnt = %08d, regWaitWCompCnt= %08d\n", macp->regWaitRCompCnt, macp->regWaitWCompCnt);
+        printk(KERN_DEBUG "regRWCompCnt    = %08d, regUnCompCnt   = %08d\n", macp->regRWCompCnt, macp->regUnCompCnt);
+        printk(KERN_DEBUG "regWaitRspCnt   = %08d, regRspCompCnt  = %08d\n", macp->regWaitRspCnt, macp->regRspCompCnt);
+        printk(KERN_DEBUG "regRdSleepCnt   = %08d, regRspCompCnt  = %08d\n", macp->regRdSleepCnt, macp->regRspCompCnt);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+        printk(KERN_DEBUG "macp.flags = %08x\n", macp->flags);
+#else
+        printk(KERN_DEBUG "macp.flags = %08lx\n", macp->flags);
+#endif
+
+        zd_ShowQInfo();
+        zd_ShowState();
+        macp->bcnCnt = 0;
+        macp->dtimCnt = 0;
+        macp->rxCnt = 0;
+        macp->txCmpCnt = 0;
+        macp->txCnt = 0;
+        macp->retryFailCnt = 0;
+        macp->txIdleCnt = 0;
+        macp->rxIdleCnt = 0;
+        macp->hwTotalRxFrm = 0;
+        macp->hwTotalTxFrm = 0;
+
+        macp->hwRxFIFOOverrun = 0;
+        macp->hwUnderrunCnt = 0;
+        macp->hwCRC32Cnt =0;
+        macp->hwCRC16Cnt =0;
+
+        macp->ErrLongFrmCnt = 0;
+        macp->ErrShortFrmCnt = 0;
+        macp->ErrToHostFrmCnt = 0;
+        macp->ErrZeroLenFrmCnt = 0;
+        macp->rxOFDMDataFrame = 0;
+        macp->rx11bDataFrame = 0;
+
+        macp->ArFreeFailCnt = 0;
+        macp->ArAgedCnt = 0;
+        macp->ArSearchFailCnt = 0;
+        macp->DropFirstFragCnt = 0;
+        macp->rxNeedFragCnt = 0;
+        macp->rxCompFragCnt = 0;
+        macp->txQueToUpCnt = 0;
+        macp->txQueSetCnt = 0;
+        //macp->sleepCnt = 0;
+        //macp->wakeupCnt = 0;
+        macp->Continue2Rx = 0;
+        macp->NoMergedRxCnt = 0;
+#ifdef WPA_DEBUG
+
+        printk("cardSet.WPAIeLen=%d\n",macp->cardSetting.WPAIeLen);
+        printk("mDynKeyMode:%d,mKeyFormat:%d,mPrivacyInvoked:%d,mCap:0x%X,mWpaBcKenLen:%d\n",mDynKeyMode,mKeyFormat,mPrivacyInvoked,mCap,mWpaBcKeyLen);
+#endif
+
+        zd1205_unlock(macp);
+}
+
+void zd1205_update_brate(struct zd1205_private *macp, u32 value)
+{
+        u8 ii;
+        u8 nRate;
+        u8 *pRate;
+        card_Setting_t *pSetting = &macp->cardSetting;
+        u8 rate_list[4] = { 0x02, 0x04, 0x0B, 0x16 };
+
+        /* Get the number of rates we support */
+        nRate = pSetting->Info_SupportedRates[1];
+
+        pRate = &(pSetting->Info_SupportedRates[2]);
+
+        for(ii = 0; ii < nRate; ii++)
+        {
+                /* If the Rate is less than the basic Rate, mask 0x80 with the value. */
+                if((*pRate & 0x7f) <= rate_list[value])
+                        *pRate |= 0x80;
+                else
+                        *pRate &= 0x7f;
+
+                pRate++;
+        }
+}
+
+void acquire_ctrl_of_phy_req(void *regp)
+{
+        u32 tmpValue;
+
+        tmpValue = zd_readl(CtlReg1);
+        tmpValue &= ~0x80;
+        zd_writel(tmpValue, CtlReg1);
+}
+
+
+void release_ctrl_of_phy_req(void *regp)
+{
+        u32 tmpValue;
+
+        tmpValue = zd_readl(CtlReg1);
+        tmpValue |= 0x80;
+        zd_writel(tmpValue, CtlReg1);
+}
+
+void zd1205_dump_phy(struct zd1205_private *macp)
+{
+        void *regp = macp->regp;
+
+        u32 regValue[4];
+        int i;
+
+        acquire_ctrl_of_phy_req(regp);
+        for (i=0; i<256; i+=4)
+        {
+                //acquire_ctrl_of_phy_req(regp);
+                if (i==4)//The offset of CR4 to CR8 are not multiplied by 4 directly.
+                {
+                        regValue[0]=zd_readl(ZD_CR4);
+                        regValue[1]=zd_readl(ZD_CR5);
+                        regValue[2]=zd_readl(ZD_CR6);
+                        regValue[3]=zd_readl(ZD_CR7);
+                } else if (i==8) {
+                        regValue[0]=zd_readl(ZD_CR8);
+                        regValue[1]=zd_readl(ZD_CR9);
+                        regValue[2]=zd_readl(ZD_CR10);
+                        regValue[3]=zd_readl(ZD_CR11);
+                } else {
+                        regValue[0] = zd_readl(4*i);
+                        regValue[1] = zd_readl(4*(i+1));
+                        regValue[2] = zd_readl(4*(i+2));
+                        regValue[3] = zd_readl(4*(i+3));
+                }
+
+                printk(KERN_DEBUG "CR%03d = %02x  CR%03d = %02x  CR%03d = %02x  CR%03d = %02x\n",
+                       i, (u8)regValue[0],  i+1, (u8)regValue[1], i+2, (u8)regValue[2], i+3, (u8)regValue[3]);
+                //release_ctrl_of_phy_req(regp);
+        }
+        release_ctrl_of_phy_req(regp);
+}
+/*
+void zd1205_dump_eeprom(struct zd1205_private *macp)
+{
+	u32 e2pValue, e2pValue1;
+	int i;
+ 
+	for (i=0; i<20; i+=2) {
+		e2pValue = zd_readl(E2P_SUBID+4*i);
+		e2pValue1 = zd_readl(E2P_SUBID+4*(i+1));
+		printk(KERN_DEBUG "0x%x = %08x,     0x%x = %08x\n", E2P_SUBID+4*i, e2pValue,  E2P_SUBID+4*(i+1), e2pValue1);
+	}
+}
+*/
+void zd1205_dump_eeprom(struct zd1205_private *macp)
+{
+        u32 V1,V2,V3,V4 ;
+        int i;
+
+        for (i=0; i<0x30; i+=4)
+        {
+                V1 = zd_readl(E2P_SUBID+4*i);
+                V2 = zd_readl(E2P_SUBID+4*(i+1));
+                V3 = zd_readl(E2P_SUBID+4*(i+2));
+                V4 = zd_readl(E2P_SUBID+4*(i+3));
+
+                printk(KERN_DEBUG "0x%x = %08x %08x %08x %08x \n", E2P_SUBID+4*i, V1,V2,V3,V4);
+        }
+}
+
+extern void zd_ShowHashInfo(u8 aid);
+void zd1205_show_hash(struct zd1205_private *macp, u32 value)
+{
+        if (value < 33)
+                zd_ShowHashInfo(value);
+}
+
+void zd1205_show_card_setting(struct zd1205_private *macp)
+{
+        card_Setting_t *pSetting = &macp->cardSetting;
+
+        printk(KERN_DEBUG "RTSThreshold   = %04x   FragThreshold  = %04x\n",
+               pSetting->RTSThreshold, pSetting->FragThreshold);
+        printk(KERN_DEBUG "DtimPeriod     = %04x   BeaconInterval = %04x\n",
+               pSetting->DtimPeriod, pSetting->BeaconInterval);
+        printk(KERN_DEBUG "EncryMode      = %04x   EncryOnOff     = %04x\n",
+               pSetting->EncryMode, pSetting->EncryOnOff);
+        printk(KERN_DEBUG "EncryKeyId     = %04x   WepKeyLen      = %04x\n",
+               pSetting->EncryKeyId, pSetting->WepKeyLen);
+        printk(KERN_DEBUG "PreambleType   = %04x   AuthMode       = %04x\n",
+               pSetting->PreambleType, pSetting->AuthMode);
+        printk(KERN_DEBUG "Channel        = %04x   BssType        = %04x\n",
+               pSetting->Channel, pSetting->BssType);
+        printk(KERN_DEBUG "SuggestionMode = %04x   PwrState       = %04x\n",
+               macp->SuggestionMode, macp->PwrState);
+        printk(KERN_DEBUG "bPSMSupported  = %04x   bAssoc         = %04x\n",
+               macp->bPSMSupported, macp->bAssoc);
+        printk(KERN_DEBUG "bAnyActivity   = %04x   BSS_Members    = %04x\n",
+               macp->bAnyActivity, macp->BSS_Members);
+}
+#if 0
+void zd1205_dump_cam(struct zd1205_private *macp)
+{
+        int ii;
+
+        for(ii = 0; ii < 445; ii++)
+        {
+                u32 data = HW_CAM_Read(&dot11Obj, ii);
+
+                if((ii % 4) == 0)
+                        printk(KERN_ERR "\nAddr=0x%04x ", ii);
+
+                printk(KERN_ERR "0x%08x ", data);
+        }
+
+        printk(KERN_ERR "\n");
+}
+#endif
+void zd1205_dump_cam(struct zd1205_private *macp,u32 beginAddr, u32 length)
+{
+        u8  valid_uid[40];
+        u8  valid_uid_cnt;
+        u32 data;
+        int ii,jj;
+        //u32 RollCallTblLow;
+        //u32 RollCallTblHigh;
+        u32 MACINCAM[6];
+        u32 tmpRollCallTblLow;
+        u32 tmpRollCallTblHigh;
+        //u32 bDisplay;
+        int UserIdBase;
+        char *EncTypeStr[]={"","WEP64","TKIP","","AES","WEP128","WEP256",""};
+        char *CamModeStr[]={"IBSS","AP","STA","WDS","Client","VAP","",""};
+
+        for(ii = 0; ii < length; ii++)
+        {
+                data = HW_CAM_Read(&dot11Obj, beginAddr+ii);
+                printk(KERN_ERR "\nAddr(%03u)=0x%08x", ii+beginAddr, data);
+        }
+        printk(KERN_ERR "\n");
+        data = zd_readl(0x700); // Cam mode: MACREG(0x700)[2:0]
+        printk(KERN_ERR "CAM Mode: %s\n", CamModeStr[data&7]);
+        //tmpRollCallTblLow=RollCallTblLow=zd_readl(0x704);
+        //tmpRollCallTblHigh=RollCallTblHigh=zd_readl(0x708)&0xf;
+        tmpRollCallTblLow=zd_readl(0x704);
+        tmpRollCallTblHigh=zd_readl(0x708)&0xf;
+        //Scan user ID of CAM
+        valid_uid_cnt=0; //Reset number of user ID
+        for (ii=0; ii<40; ii++)
+        {
+                valid_uid[ii]=0;// Reset to invalid
+
+                if (ii<32) {// For user 0 - 31
+                        if (tmpRollCallTblLow & 1) {
+                                valid_uid[ii]=1;// set to valid
+                                valid_uid_cnt++;
+                        }
+                        tmpRollCallTblLow = tmpRollCallTblLow >> 1;
+                } else {
+                        if (tmpRollCallTblHigh & 1) {
+                                valid_uid[ii]=1; // set to valid
+                                valid_uid_cnt++;
+                        }
+                        tmpRollCallTblHigh = tmpRollCallTblHigh >> 1;
+                }
+        }
+        // Dump MAC address
+        UserIdBase=0;
+        for(ii = 0; ii < 60; ii+=6)
+        {
+                //UserIdBase = UserIdBase+4;
+                MACINCAM[0]=HW_CAM_Read(&dot11Obj, ii);
+                MACINCAM[1]=HW_CAM_Read(&dot11Obj, ii+1);
+                MACINCAM[2]=HW_CAM_Read(&dot11Obj, ii+2);
+                MACINCAM[3]=HW_CAM_Read(&dot11Obj, ii+3);
+                MACINCAM[4]=HW_CAM_Read(&dot11Obj, ii+4);
+                MACINCAM[5]=HW_CAM_Read(&dot11Obj, ii+5);
+                for (jj=0; jj<4; jj++) {
+                        if (valid_uid[UserIdBase+jj]) {
+                                printk(KERN_ERR "UID:%d Mac:%02x:%02x:%02x:%02x:%02x:%02x\n",UserIdBase+jj, MACINCAM[0]&255, MACINCAM[1]&255, MACINCAM[2]&255, MACINCAM[3]&255,MACINCAM[4]&255,MACINCAM[5]&255);
+                        }
+                        MACINCAM[0]=MACINCAM[0]>>8;
+                        MACINCAM[1]=MACINCAM[1]>>8;
+                        MACINCAM[2]=MACINCAM[2]>>8;
+                        MACINCAM[3]=MACINCAM[3]>>8;
+                        MACINCAM[4]=MACINCAM[4]>>8;
+                        MACINCAM[5]=MACINCAM[5]>>8;
+                }
+                UserIdBase = UserIdBase+4;
+        }
+        // Dump Encryption type: CAM location: 60-65
+        //tmpRollCallTblLow=RollCallTblLow;
+        //tmpRollCallTblHigh=RollCallTblHigh;
+        for(ii=60; ii<66; ii++)
+        {
+                data = HW_CAM_Read(&dot11Obj, ii);
+                UserIdBase=(ii-60)*8; //One location for 8 users.
+                if (UserIdBase >= 40) {
+                        {//location 65:For default key
+                                printk(KERN_ERR "DefaultKeySet:%s\n",EncTypeStr[data&7]);
+                        }
+                } else {
+                        for(jj=0; jj<8; jj++) {
+                                if (valid_uid[UserIdBase+jj]) {
+                                        printk(KERN_ERR "UID:%02d:%s\n",UserIdBase+jj,EncTypeStr[data&7]);
+                                        valid_uid[UserIdBase+jj] |= ((data & 7)<<1);
+                                }
+                                data = data >> 4; // Next user.
+                        }
+                }
+        }
+        printk(KERN_ERR "KeyContents:\n");
+        for (ii=0; ii<40; ii++)
+        {
+                u32 keylen;
+                u32 keytype;
+
+                if (valid_uid[ii]) {
+                        keytype=valid_uid[ii]>>1;
+                        switch(keytype) {
+                        case 2://TKIP
+                                keylen=32;
+                                break;
+                        case 4://AES
+                                keylen=16;
+                                break;
+                        case 1://WEP64
+                                keylen=8;
+                                break;
+                        case 5://WEP128
+                                keylen=16;
+                                break;
+                        default:
+                                keylen=0;
+                                break;
+                        }
+                        keylen = keylen >> 2;
+                        printk(KERN_ERR "UID:%02d\n", ii);
+                        for (jj=0; jj<keylen; jj++) {
+                                data = HW_CAM_Read(&dot11Obj, (66+(8*ii))+jj);
+                                printk(KERN_ERR "%08x\n", data);
+                        }
+                }
+        }
+        printk(KERN_ERR "\n");
+}
+void zd1205_cam_read(struct zd1205_private *macp, u32 addr)
+{
+        u32 value = HW_CAM_Read(&dot11Obj, addr);
+        printk(KERN_ERR "Addr: 0x%08x, value = 0x%08x\n", addr, value);
+}
+
+void zd1205_cam_write(struct zd1205_private *macp, u32 addr, u32 value)
+{
+        HW_CAM_Write(&dot11Obj, addr, value);
+        printk(KERN_ERR "Write value: 0x%08x to CAM address: 0x%08x\n", value, addr);
+}
+
+void zd1205_cam_rest(struct zd1205_private *macp, int mode)
+{
+}
+
+int zd1205_zd_dbg_ioctl(struct zd1205_private *macp, struct zdap_ioctl *zdreq)
+{
+        void *regp = macp->regp;
+        u16 zd_cmd;
+        u32 tmp_value;
+        u32 tmp_addr;
+        u32 CRn;
+
+        zd_cmd = zdreq->cmd;
+
+        switch(zd_cmd)
+        {
+        case ZD_IOCTL_DEBUG_FLAG:
+                macp->debugflag = zdreq->addr;
+                mDebugFlag = zdreq->value;
+                break;
+        case ZD_IOCTL_REG_READ:
+                acquire_ctrl_of_phy_req(regp);
+                tmp_value = zd_readl(zdreq->addr);
+                release_ctrl_of_phy_req(regp);
+                zdreq->value = tmp_value;
+
+                printk(KERN_DEBUG "zd1211 read register:  reg = 0x%04x, value = 0x%08x\n",
+                       zdreq->addr, zdreq->value);
+                //if (copy_to_user(ifr->ifr_data, &zdreq, sizeof (zdreq)))
+                //return -EFAULT;
+                break;
+
+        case ZD_IOCTL_REG_WRITE:
+                acquire_ctrl_of_phy_req(regp);
+                zd_writel(zdreq->value, zdreq->addr);
+                release_ctrl_of_phy_req(regp);
+
+                if (zdreq->addr == RX_OFFSET_BYTE)
+                        macp->rxOffset = zdreq->value;
+                break;
+
+        case ZD_IOCTL_MEM_DUMP:
+                zd1205_dump_data("mem", (u8 *)zdreq->addr, zdreq->value);
+                //memcpy(&zdreq->data[0], (u8 *)zdreq->addr, zdreq->value);
+                //if (copy_to_user(ifr->ifr_data, &zdreq, sizeof (zdreq)))
+                //return -EFAULT;
+                break;
+
+        case ZD_IOCTL_RATE:
+                /* Check for the validation of vale */
+                if(zdreq->value > 3 || zdreq->value < 0) {
+                        printk(KERN_DEBUG "zd1205: Basic Rate %x doesn't support\n", zdreq->value);
+                        break;
+                }
+
+                printk(KERN_DEBUG "zd1205: Basic Rate = %x\n", zdreq->value);
+                zd1205_update_brate(macp, zdreq->value);
+                break;
+
+        case ZD_IOCTL_SNIFFER:
+                macp->sniffer_on = zdreq->value;
+                printk(KERN_DEBUG "zd1205: sniffer_on = %x\n", macp->sniffer_on);
+                zd1205_set_sniffer_mode(macp);
+                break;
+
+        case ZD_IOCTL_CAM_DUMP://Arg1: Location, Arg2: Length
+                {
+                        u32 startAddr, length;
+                        startAddr=((zdreq->addr & 0xF00)>>8)*100+
+                                  ((zdreq->addr & 0xF0)>>4)*10+
+                                  (zdreq->addr & 0xF);
+                        length=((zdreq->value & 0xF00)>>8)*100+
+                               ((zdreq->value & 0xF0)>>4)*10+
+                               (zdreq->value & 0xF);
+                        printk(KERN_DEBUG "zd1205: dump cam\n");
+                        zd1205_dump_cam(macp,startAddr,length);
+                        break;
+                }
+        case ZD_IOCTL_DUMP_PHY:
+                printk(KERN_DEBUG "zd1205: dump phy\n");
+                zd1205_dump_phy(macp);
+                break;
+        case ZD_IOCTL_READ_PHY:
+        case ZD_IOCTL_WRITE_PHY:
+                acquire_ctrl_of_phy_req(regp);
+                tmp_addr = zdreq->addr;
+                CRn=    ((tmp_addr & 0xF00)>>8)*100+
+                        ((tmp_addr & 0xF0)>>4)*10+
+                        (tmp_addr & 0xF);
+                if (CRn >= 4 && CRn <= 8)//Special handling for CR4 to CR8
+                {
+                        u8 cnvtbl1[]={0x20, 0x10, 0x14, 0x18, 0x1c};
+                        tmp_addr = cnvtbl1[CRn-4];
+                } else {
+                        tmp_addr = CRn*4;
+                }
+                if (zd_cmd == ZD_IOCTL_READ_PHY) {
+                        zdreq->value = zd_readl(tmp_addr);
+                        printk(KERN_DEBUG "CR%d=0x%x\n",CRn, zdreq->value);
+                } else {// ZD_IOCTL_WRITE_PHY
+                        zd_writel(zdreq->value, tmp_addr);
+                        printk(KERN_DEBUG "set CR%d=0x%x\n",CRn, zdreq->value);
+                }
+                release_ctrl_of_phy_req(regp);
+                break;
+
+        case ZD_IOCTL_CARD_SETTING:
+                printk(KERN_DEBUG "zd1205: card setting\n");
+                zd1205_show_card_setting(macp);
+                break;
+
+        case ZD_IOCTL_HASH_DUMP:
+                printk(KERN_DEBUG "zd1205: aid = %x\n", zdreq->value);
+                zd1205_show_hash(macp, zdreq->value);
+                break;
+
+        case ZD_IOCTL_RFD_DUMP:
+                printk(KERN_DEBUG "===== zd1205 rfd dump =====\n");
+                zd1205_dump_rfds(macp);
+                break;
+
+        case ZD_IOCTL_MEM_READ: {
+                        u32 *p;
+
+                        p = (u32 *) bus_to_virt(zdreq->addr);
+                        printk(KERN_DEBUG "zd1205: read memory addr: 0x%08x value: 0x%08x\n", zdreq->addr, *p);
+                        break;
+                }
+
+        case ZD_IOCTL_MEM_WRITE: {
+                        u32 *p;
+
+                        p = (u32 *) bus_to_virt(zdreq->addr);
+                        *p = zdreq->value;
+                        printk(KERN_DEBUG "zd1205: write value: 0x%08x to memory addr: 0x%08x\n", zdreq->value, zdreq->addr);
+                        break;
+                }
+
+        case ZD_IOCTL_TX_RATE:
+                printk(KERN_DEBUG "zd1205: set tx rate = %d\n", zdreq->value);
+
+                if (zdreq->value < 0x0c) {
+                        macp->cardSetting.FixedRate = zdreq->value;
+                        macp->bFixedRate = 1;
+                } else
+                        macp->bFixedRate = 0;
+                break;
+
+        case ZD_IOCTL_EEPROM:
+                printk(KERN_DEBUG "zd1205: dump eeprom\n");
+                zd1205_dump_eeprom(macp);
+                break;
+
+                /* Generate the beacon */
+        case ZD_IOCTL_BCN:
+                dot11Obj.dbg_cmd |= DBG_CMD_BEACON;
+                printk(KERN_DEBUG "zd1205: configuration beacon\n");
+                ConfigBcnFIFO();
+                break;
+
+        case ZD_IOCTL_REG_READ16:
+                tmp_value = zd1211_readl(zdreq->addr, false);
+                zdreq->value = tmp_value & 0xffff;
+                printk(KERN_DEBUG "zd1205 read register:  reg = %4x, value = %4x\n",
+                       zdreq->addr, zdreq->value);
+                break;
+
+        case ZD_IOCTL_REG_WRITE16:
+                tmp_value = zdreq->value & 0xffff;
+                zd1211_writel(zdreq->addr, tmp_value, false);
+                printk(KERN_DEBUG "zd1205 write register: reg = %4x, value = %4x\n",
+                       zdreq->addr, zdreq->value);
+                break;
+
+        case ZD_IOCTL_CAM_READ:
+                printk(KERN_ERR "zd1205: cam read, addr: 0x%08x\n", zdreq->addr);
+                zd1205_cam_read(macp, zdreq->addr);
+                break;
+
+        case ZD_IOCTL_CAM_WRITE:
+                printk(KERN_ERR "zd1205: cam write, addr: 0x%08x value: 0x%08x\n", zdreq->addr, zdreq->value);
+                zd1205_cam_write(macp, zdreq->addr, zdreq->value);
+                break;
+
+        case ZD_IOCTL_CAM_RESET:
+                printk(KERN_ERR "zd1205: reset cam\n");
+                zd1205_cam_rest(macp, zdreq->value);
+                break;
+
+        case ZD_IOCTL_CONT_TX:
+                zd1205_cont_tx(macp, zdreq->value);
+                break;
+        case ZD_IOCTL_SET_MIC_CNT_ENABLE:
+                dot11Obj.MIC_CNT = zdreq->value>0?1:0;
+                printk("WPA MIC Counter Measure Feature : %s\n",
+                       dot11Obj.MIC_CNT ? "Enable":"Disalbe");
+
+                break;
+        case ZD_IOCTL_GET_MIC_CNT_ENABLE:
+                printk("WPA MIC Counter Measure Feature : %s\n",
+                       dot11Obj.MIC_CNT ? "Enable":"Disalbe");
+
+                break;
+        default :
+                printk(KERN_ERR "zd_dbg_ioctl: error command = %x\n", zd_cmd);
+                break;
+        }
+
+        return 0;
+}
+
+
+void zd1205_cont_tx(struct zd1205_private *macp, u8 rate)
+{
+
+        void *reg = dot11Obj.reg;
+        static u8 LastCont_TX_Rate=0;
+        printk(KERN_ERR "ZDContinuousTx,Rate=%d\n",rate);
+
+        //if (le32_to_cpu(pZDRD->ZDRdLength) < sizeof(ZD_RD_STRUCT))
+        //{
+        //   pZDRD->ZDRdLength = cpu_to_le32(sizeof(ZD_RD_STRUCT));
+        //    *BytesNeeded = sizeof(ZD_RD_STRUCT);
+        //    *BytesRead = 0;
+        //    Status = NDIS_STATUS_BUFFER_TOO_SHORT;
+        //    break;
+        //}
+
+        //macp->bContinueTxMode = le32_to_cpu(pZDRD->Buffer[0]);
+        //macp->bContinueTx = le32_to_cpu(pZDRD->Buffer[1]);
+
+        /* Use the Fixed Rate instead of LastSentTxRate */
+        //macp->LastZDContinuousTxRate = macp->cardSetting.LastSentTxRate;
+        //macp->LastZDContinuousTxRate = macp->cardSetting.FixedRate;
+
+        // Roger 2004-11-10 , Set for Dr.Wang request , set 0x0001c4 when CCK mode with AL2230
+        if (dot11Obj.rfMode == AL2230_RF)
+        {
+                //if (macp->cardSetting.LastSentTxRate > 3) {
+                if (LastCont_TX_Rate > 3) {
+                        HW_Set_IF_Synthesizer(&dot11Obj, 0x0005a4);
+                }
+                //else if (macp->cardSetting.LastSentTxRate <= 3) {
+                else if (LastCont_TX_Rate <= 3) {
+                        HW_Set_IF_Synthesizer(&dot11Obj, 0x0001c4);
+                }
+        }
+        LastCont_TX_Rate = rate;
+
+        if(rate <= RATE_54M)
+        {  // Start
+                u8	tmpChr = 0;
+                u32	RateTmp= 0;
+                u32	tmpvalue;
+                u32	nLoop;
+                LockPhyReg(&dot11Obj);
+                dot11Obj.SetReg(reg, ZD1205_CR2, 0x3F);
+                dot11Obj.SetReg(reg, ZD1205_CR138, 0x28);
+                dot11Obj.SetReg(reg, ZD1205_CR33, 0x20);
+                // Query CR60 until change to 0x04
+                nLoop = 200;
+                while(nLoop--) {
+                        dot11Obj.DelayUs(10*1000); // sleep 10ms
+                        tmpvalue = dot11Obj.GetReg(reg, ZD1205_CR60);
+
+                        if(tmpvalue == 0x04)
+                                break;
+                }
+
+                UnLockPhyReg(&dot11Obj);
+
+                printk(KERN_DEBUG "Start ContTx_Normal\n");
+
+                dot11Obj.bContinueTx = 1;
+                LockPhyReg(&dot11Obj);
+                /* In order to avoid the uninitial length problem,
+                   force to set length to 0x20.
+                 */
+                dot11Obj.SetReg(reg, ZD1205_CR134, 0x20);
+                UnLockPhyReg(&dot11Obj);
+
+                switch (rate) {
+                case RATE_6M: //6M
+                        RateTmp = 0xB;
+                        break;
+                case RATE_9M: //9M
+                        RateTmp = 0xF;
+                        break;
+                case RATE_12M: //12M
+                        RateTmp = 0xA;
+                        break;
+                case RATE_18M: //18M
+                        RateTmp = 0xE;
+                        break;
+                case RATE_24M: //24M
+                        RateTmp = 0x9;
+                        break;
+                case RATE_36M: //36M
+                        RateTmp = 0xD;
+                        break;
+
+                case RATE_48M:   //48M
+                        RateTmp = 0x8;
+                        break;
+
+                case RATE_54M:   //54M
+                        RateTmp = 0xC;
+                        break;
+
+                default:
+                        RateTmp = 0;
+                        break;
+                }
+
+                printk(KERN_DEBUG "RateTmp=0x%08x\n", RateTmp);
+
+                if (RateTmp) {
+                        LockPhyReg(&dot11Obj);
+                        dot11Obj.SetReg(reg, ZD1205_CR132, RateTmp);
+
+                        //AcquireCtrOfPhyReg(Adapter);
+                        tmpvalue = dot11Obj.GetReg(reg, ZD1205_CR159);
+                        tmpvalue &= ~(BIT_0 + BIT_1 );
+                        tmpvalue |= BIT_2;
+                        dot11Obj.SetReg(reg, ZD1205_CR159, tmpvalue);
+
+
+                        dot11Obj.SetReg(reg, 0x644, 7);
+
+                        tmpvalue = dot11Obj.GetReg(reg, 0x648);
+                        tmpvalue &= ~BIT_0;
+                        dot11Obj.SetReg(reg, 0x648, tmpvalue);
+                        UnLockPhyReg(&dot11Obj);
+
+                }
+
+                tmpChr = LastCont_TX_Rate;
+                printk(KERN_DEBUG "tmpChr=0x%x\n", tmpChr);
+
+#if 0
+
+                if (macp->preambleMode == 1)
+                        macp->cardSetting.PreambleType = 0x00;
+                else if (macp->preambleMode == 2)
+                        macp->cardSetting.PreambleType = 0x20;
+#endif
+
+                if (macp->cardSetting.PreambleType == SHORT_PREAMBLE) {
+                        // short premable
+                        tmpChr |= BIT_5;
+                } else {
+                        // long premable
+                        tmpChr &= ~BIT_5;
+                }
+
+                if (macp->RegionCode == 0x10)
+                        tmpChr &= ~BIT_6;   //USA
+                if (macp->RegionCode == 0x40)
+                        tmpChr |= BIT_6;    //japan
+
+                LockPhyReg(&dot11Obj);
+                dot11Obj.SetReg(reg, ZD1205_CR5, tmpChr);
+                dot11Obj.SetReg(reg, 0x644, 3);
+                UnLockPhyReg(&dot11Obj);
+        } else
+        {
+                u32	tmpvalue;
+
+                // Roger 2004-11-10 , Set for Dr.Wang request , set 0x0001c4 when CCK mode with AL2230
+                if (dot11Obj.rfMode == AL2230_RF) {
+                        HW_Set_IF_Synthesizer(&dot11Obj, 0x0005a4);
+                }
+
+                LockPhyReg(&dot11Obj);
+                dot11Obj.SetReg(reg, ZD1205_CR2, 0x26);
+                dot11Obj.SetReg(reg, ZD1205_CR138, 0xA8);
+                dot11Obj.SetReg(reg, ZD1205_CR33, 0x08);
+                UnLockPhyReg(&dot11Obj);
+                printk(KERN_DEBUG "Stop Normal Continuous Transmit\n");
+
+                dot11Obj.bContinueTx = 0;
+                LockPhyReg(&dot11Obj);
+                macp->PHYTestTimer = 30;
+                //                      ZD1205_WRITE_REGISTER(Adapter,CR122, 0x0);
+                UnLockPhyReg(&dot11Obj);
+
+                if (LastCont_TX_Rate >= 4) {
+                        LockPhyReg(&dot11Obj);
+                        tmpvalue = dot11Obj.GetReg(reg, ZD1205_CR159);
+                        tmpvalue &= ~(BIT_0 + BIT_1 + BIT_2 );
+                        dot11Obj.SetReg(reg, ZD1205_CR159, tmpvalue);
+
+                        dot11Obj.SetReg(reg, 0x644, 0);
+
+                        tmpvalue = dot11Obj.GetReg(reg, 0x648);
+                        tmpvalue |= BIT_0;
+                        dot11Obj.SetReg(reg, 0x648, tmpvalue);
+                        UnLockPhyReg(&dot11Obj);
+
+                } else {
+                        LockPhyReg(&dot11Obj);
+                        dot11Obj.SetReg(reg, 0x644, 0);
+
+                        tmpvalue = dot11Obj.GetReg(reg, 0x648);
+                        tmpvalue |= BIT_0;
+                        dot11Obj.SetReg(reg, 0x648, tmpvalue);
+                        UnLockPhyReg(&dot11Obj);
+                }
+
+                //dot11Obj.SetReg(reg, ZD_PS_Ctrl, 0x1);
+                //Roger 2004-11-16 SoftwareReset here to solve RX fail after TxContinue problem
+                {
+                        //zd1205_device_reset(macp);
+                        //Card resetting , copying from driver of ZyNOS
+                        //It's a little different from ours
+                        u32  tmp_value;
+                        /* Update the value of Beacon Interval and Pre TBTT */
+                        update_beacon_interval(macp, 0x2);
+                        zd_writel(0x01, Pre_TBTT);
+
+                        LockPhyReg(&dot11Obj);
+                        dot11Obj.SetReg(dot11Obj.reg, ZD1205_PHY_END, 0x8);
+                        tmp_value = zd_readl(PS_Ctrl);
+                        zd_writel(tmp_value | BIT_5, PS_Ctrl);
+                        dot11Obj.SetReg(dot11Obj.reg, ZD1205_PHY_END, 0x0);
+                        UnLockPhyReg(&dot11Obj);
+
+                        dot11Obj.bDeviceInSleep = 1;
+                        dot11Obj.DelayUs(5000);
+                }
+        }
+
+        return 0;
+}
+
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zddebug.h linux-2.4.35.3-mct/drivers/usb/zd1211/zddebug.h
--- linux-2.4.35.3/drivers/usb/zd1211/zddebug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zddebug.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,44 @@
+#ifndef _ZD_DEBUG_
+#define _ZD_DEBUG_
+
+#include <linux/string.h>
+#include <stdarg.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include "zd1205.h"
+
+#define ZD_DEBUG
+//#define WPA_DEBUG
+
+//#define DEBUG_DUMP_ASSOC_REQ
+
+#ifdef ZD_DEBUG
+#define ZD1211DEBUG(n, args...) do { if (macp->dbg_flag>(n)) printk(KERN_DEBUG "zd1211:" args); } while(0)
+#define ZENTER(n) do { if (macp->dbg_flag>(n))	printk(KERN_DEBUG "%s: (enter) %s, %s line %i\n", "zd1205", __FUNCTION__,__FILE__,__LINE__); } while(0)
+#define ZEXIT(n) do { if (macp->dbg_flag>(n))printk(KERN_DEBUG "%s: (exit) %s, %s line %i\n", "zd1205", __FUNCTION__,__FILE__,__LINE__); } while(0)
+#else
+#define ZD1211DEBUG(n, args...) do { } while (0)
+#define ZENTER(n) //do {} while (0)
+#define ZEXIT(n) //do {} while (0)
+#endif
+
+#ifdef WPA_DEBUG
+#define WPADEBUG(args...) do { printk(KERN_ERR args); } while(0)
+#else
+#define WPADEBUG(args...) do { } while (0)
+#endif
+
+#ifdef WPADATA_DEBUG
+#define WPADATADEBUG(bData, args...) do { if (bData) printk(KERN_DEBUG args); } while (0)
+#else
+#define WPADATADEBUG(bData, args...) do { } while (0)
+#endif
+
+extern  U32 mDebugFlag;
+int zd1205_zd_dbg_ioctl(struct zd1205_private *macp, struct zdap_ioctl *zdreq);
+void zd1205_set_sniffer_mode(struct zd1205_private *macp);
+void zd1205_dump_regs(struct zd1205_private *macp);
+void zd1205_dump_cnters(struct zd1205_private *macp);
+void zd1205_dump_rfds(struct zd1205_private *macp);
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zddebug2.c linux-2.4.35.3-mct/drivers/usb/zd1211/zddebug2.c
--- linux-2.4.35.3/drivers/usb/zd1211/zddebug2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zddebug2.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,121 @@
+#ifndef _ZD_DEBUG2_C_
+#define _ZD_DEBUG2_C_
+
+#ifdef ZDCONF_MENUDBG
+#include "zddebug2.h"
+#include "menu_drv_macro.h"
+
+extern zd_80211Obj_t dot11Obj;
+//for debug message show
+extern U8 mDynKeyMode;
+extern U8 mKeyFormat;
+struct zd1205_private *lmacp;
+extern  struct net_device *g_dev;
+
+#define CNT_MAX	64
+static u32 CNT_TBL[CNT_MAX];
+
+
+static void copy_cnt_tally(void)
+{
+        struct zd1205_private *macp = (struct zd1205_private *)g_dev->priv;
+
+        memset(CNT_TBL,0,sizeof(CNT_TBL));
+
+        CNT_TBL[T_bcnCnt]=macp->bcnCnt;
+        CNT_TBL[T_txCmpCnt]=macp->txCmpCnt;
+        CNT_TBL[T_dtimCnt]=macp->dtimCnt;
+        CNT_TBL[T_rxCnt]=macp->rxCnt;
+        CNT_TBL[T_retryFailCnt]=macp->retryFailCnt;
+        CNT_TBL[T_txCnt]=macp->txCnt;
+
+}
+static void acquire_ctrl_of_phy_req(void *regp)
+{
+        u32 tmpValue;
+
+        tmpValue = zd_readl(CtlReg1);
+        tmpValue &= ~0x80;
+        zd_writel(tmpValue, CtlReg1);
+}
+
+
+static void release_ctrl_of_phy_req(void *regp)
+{
+        u32 tmpValue;
+
+        tmpValue = zd_readl(CtlReg1);
+        tmpValue |= 0x80;
+        zd_writel(tmpValue, CtlReg1);
+}
+
+
+int zd1205_zd_dbg2_ioctl(struct zd1205_private *macp, struct zdap_ioctl *zdreq, u32 *ret)
+{
+        void *regp = macp->regp;
+        u16 zd_cmd;
+        u32 tmp_value;
+        u32 tmp_addr;
+        u32 CRn;
+
+        *ret=0;
+        zd_cmd = zdreq->cmd;
+        switch(zd_cmd)
+        {
+        case RDCNT:
+                copy_cnt_tally();
+                if(zdreq->addr < CNT_MAX-1)
+                        *ret = CNT_TBL[zdreq->addr];
+                break;
+        case RDMAC:
+                acquire_ctrl_of_phy_req(regp);
+                tmp_value = zd_readl(zdreq->addr);
+                release_ctrl_of_phy_req(regp);
+                zdreq->value = tmp_value;
+
+                *ret =  tmp_value;
+                //if (copy_to_user(ifr->ifr_data, &zdreq, sizeof (zdreq)))
+                //return -EFAULT;
+                break;
+
+        case WRMAC:
+                acquire_ctrl_of_phy_req(regp);
+                zd_writel(zdreq->value, zdreq->addr);
+                release_ctrl_of_phy_req(regp);
+
+                if (zdreq->addr == RX_OFFSET_BYTE)
+                        macp->rxOffset = zdreq->value;
+                break;
+
+        case RDPhy:
+        case WRPhy:
+                acquire_ctrl_of_phy_req(regp);
+                tmp_addr = zdreq->addr;
+                CRn=    ((tmp_addr & 0xF00)>>8)*100+
+                        ((tmp_addr & 0xF0)>>4)*10+
+                        (tmp_addr & 0xF);
+                if (CRn >= 4 && CRn <= 8)//Special handling for CR4 to CR8
+                {
+                        u8 cnvtbl1[]={0x20, 0x10, 0x14, 0x18, 0x1c};
+                        tmp_addr = cnvtbl1[CRn-4];
+                } else {
+                        tmp_addr = CRn*4;
+                }
+                if (zd_cmd == RDPhy) {
+                        zdreq->value = zd_readl(tmp_addr);
+                        *ret =  zdreq->value;
+                } else {// ZD_IOCTL_WRITE_PHY
+                        zd_writel(zdreq->value, tmp_addr);
+                }
+                release_ctrl_of_phy_req(regp);
+                break;
+
+        default :
+                printk(KERN_ERR "zd1205: error command = %x\n", zd_cmd);
+                break;
+        }
+
+        return 0;
+}
+#endif
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zddebug2.h linux-2.4.35.3-mct/drivers/usb/zd1211/zddebug2.h
--- linux-2.4.35.3/drivers/usb/zd1211/zddebug2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zddebug2.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,17 @@
+#ifndef _ZD_DEBUG2_
+#define _ZD_DEBUG2_
+
+#include <linux/string.h>
+#include <stdarg.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include "zd1205.h"
+#include "zdsorts.h"
+#include "zdutils.h"
+
+
+
+int zd1205_zd_dbg2_ioctl(struct zd1205_private *macp, struct zdap_ioctl *zdreq,u32 *ret);
+
+
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdencrypt.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdencrypt.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdencrypt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdencrypt.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,237 @@
+#ifndef _ZD_ENCRYPT_C
+#define _ZD_ENCRYPT_C
+
+#if defined(PHY_1202)
+#include "zd80211.h"
+
+const unsigned int crc32_tab[] =
+        {
+                0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+                0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+                0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+                0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+                0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+                0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+                0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+                0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+                0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+                0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+                0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+                0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+                0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+                0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+                0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+                0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+                0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+                0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+                0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+                0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+                0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+                0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+                0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+                0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+                0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+                0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+                0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+                0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+                0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+                0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+                0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+                0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+                0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+                0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+                0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+                0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+                0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+                0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+                0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+                0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+                0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+                0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+                0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+                0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+                0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+                0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+                0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+                0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+                0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+                0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+                0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+                0x2d02ef8dL
+        };
+
+
+U8 S[256];
+void initWepState(void)
+{
+        int i;
+
+        for (i=0; i<256; i++) {
+                S[i] = i;
+        }
+}
+
+
+void zd_EncryptData (
+        U8		Wep_Key_Len,
+        U8*		Wep_Key,
+        U8*		Wep_Iv,
+        U16		Num_Bytes,
+        U8*		Inbuf,
+        U8*		Outbuf,
+        U32*	Icv)
+{
+        U8  S2[256], Se[256];
+        register U16 ui;
+        register U16 i;
+        register U16 j;
+        register U8  temp;
+        U8  keylen = Wep_Key_Len + 3;
+        U8  K;
+        U8  *In = Inbuf;
+        U8  *Out = Outbuf;
+        U32 ltemp;
+
+        for (i=0; i<256; i++) {
+                if ((i&(keylen-1)) < 3)
+                        S2[i] = Wep_Iv[i & (keylen-1)];
+                else
+                        S2[i] = Wep_Key[(i & (keylen-1)) - 3];
+        }
+
+        memcpy(Se, S, 256);
+
+        j = 0;
+        for (i=0; i<256; i++) {
+                j = (j + Se[i] + S2[i]) ;
+                j &= 255 ;
+
+                // Swap S[i] and S[j]
+                temp = Se[i];
+                Se[i] = Se[j];
+                Se[j] = temp;
+        }
+
+        i = j = 0;
+        *Icv = -1;
+        for (ui=0; ui<Num_Bytes; ui++) {
+                i++;
+                i &= 255;
+                j += Se[i];
+                j &= 255;
+
+                // Swap S[i] and S[j]
+                temp = Se[i];
+                Se[i] = Se[j];
+                Se[j] = temp;
+                //          temp = (S[i] + temp) & 255;
+                temp += Se[i];
+                temp &= 255;
+                K = Se[temp];        // Key used to Xor with input data
+
+                *Icv =  (*Icv >> 8) ^ crc32_tab[(*Icv ^ *In) & 0xff];
+
+                *Out = *In ^ K;                 // XOR
+                In++;
+                Out++;
+        } //End of for (ui = 0; ui < Num_Bytes; ui++)
+
+        *Icv = ~(*Icv);
+        ltemp = *Icv;
+        for (ui=0; ui<4; ui++) {
+                i ++;
+                i &= 255;
+                j += Se[i];
+                j &= 255;
+
+                // Swap S[i] and S[j]
+                temp = Se[i];
+                Se[i] = Se[j];
+                Se[j] = temp;
+                temp += Se[i];
+                temp &= 255;
+                K = Se[temp];        // Key used to Xor with input data
+
+                *Out++ = (U8) (ltemp ^ K) & 0xff;
+                ltemp >>= 8;
+        }
+}
+
+
+BOOLEAN zd_DecryptData (
+        U8		Wep_Key_Len,
+        U8* 	Wep_Key,
+        U8* 	Wep_Iv,
+        U16 	Num_Bytes,	//include IVC
+        U8* 	Inbuf,
+        U8* 	Outbuf,		//the same with InBuf
+        U32*	Icv)
+{
+        U8   S2[256], Sd[256];
+        register U16  ui;
+        register U16  i;
+        register U16  j;
+        U8   keylen = Wep_Key_Len + 3;
+        register U8   temp;
+        U8   K;
+        U8   *In = Inbuf;
+        U8   *Out = Outbuf;
+
+        for (i=0; i<256; i++) {
+                if ((i&(keylen-1)) < 3)
+                        S2[i] = Wep_Iv[i&(keylen-1)];
+                else
+                        S2[i] = Wep_Key[(i&(keylen-1))-3];
+        }
+
+        memcpy(Sd, S, 256);
+
+        j = 0;
+        for (i=0; i<256; i++) {
+                j = (j + Sd[i] + S2[i]) & 255;
+                // Swap S[i] and S[j]
+                temp = Sd[i];
+                Sd[i] = Sd[j];
+                Sd[j] = temp;
+        }
+
+        i = j = 0;
+        // Decrypt Decrypted Data and Decrypted ICV
+        for (ui = 0; ui < Num_Bytes; ui++) {
+                i++;
+                i &= 255;
+                j += Sd[i];
+                j &= 255;
+
+                // Swap S[i] and S[j]
+                temp = Sd[i];
+                Sd[i] = Sd[j];
+                Sd[j] = temp;
+                temp += Sd[i];
+                temp &= 255;
+                K = Sd[temp];        // Key used to Xor with input data
+
+                *Out = *In ^ K;     // decrypt
+                In++;
+                Out++;
+        } //End of for (ui = 0; ui < Num_Bytes; ui++)
+
+        // Inverse Decrypted ICV
+        Outbuf[Num_Bytes-4] = ~Outbuf[Num_Bytes-4];
+        Outbuf[Num_Bytes-3] = ~Outbuf[Num_Bytes-3];
+        Outbuf[Num_Bytes-2] = ~Outbuf[Num_Bytes-2];
+        Outbuf[Num_Bytes-1] = ~Outbuf[Num_Bytes-1];
+
+        //Check ICV
+        *Icv = -1;
+        for (ui = 0; ui < Num_Bytes; ui++) {
+                *Icv = (*Icv>>8) ^ crc32_tab[(*Icv ^ Outbuf[ui]) & 0xff];
+        }
+
+        if (*Icv == 0)
+                return 1;
+        else
+                return 0;
+}
+#endif
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdencrypt.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdencrypt.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdencrypt.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdencrypt.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,29 @@
+#ifndef _ZD_ENCRYPT_H
+#define _ZD_ENCRYPT_H
+
+#if defined(PHY_1202)
+
+void initWepState(void);
+
+void zd_EncryptData (
+        U8		Wep_Key_Len,
+        U8*		Wep_Key,
+        U8*		Wep_Iv,
+        U16		Num_Bytes,
+        U8*		Inbuf,
+        U8*		Outbuf,
+        U32*	Icv);
+
+
+BOOLEAN zd_DecryptData (
+        U8		Wep_Key_Len,
+        U8* 	Wep_Key,
+        U8* 	Wep_Iv,
+        U16 	Num_Bytes,
+        U8* 	Inbuf,
+        U8* 	Outbuf,
+        U32*	Icv);
+
+#endif
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdequates.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdequates.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdequates.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdequates.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,459 @@
+/****************************************************************************
+** COPYRIGHT (C) 2002 ZYDAS CORPORATION                                    **
+** HTTP://WWW.ZYDAS.COM.TW/                                                **
+****************************************************************************/
+
+#ifndef _ZDEQUATES_H
+#define _ZDEQUATES_H
+
+
+//-------------------------------------------------------------------------
+// Ethernet Frame_t Sizes
+//-------------------------------------------------------------------------
+#define ETHERNET_ADDRESS_LENGTH         6
+#define ETHERNET_HEADER_SIZE            14
+#define MINIMUM_ETHERNET_PACKET_SIZE    60
+#define MAXIMUM_ETHERNET_PACKET_SIZE    1514
+#if 1//fMERGE_RX_FRAME
+    #define	MAX_WLAN_SIZE				4800
+    #define ZD_MAX_WLAN_SIZE			4800
+#else
+    #define	MAX_WLAN_SIZE               2432
+    #define ZD_MAX_WLAN_SIZE			1600
+#endif
+
+#define WLAN_HEADER						24
+#define CRC32_LEN						4
+#define IV_SIZE							4
+#define ICV_SIZE						4
+
+#if defined(HOST_IF_USB)
+#define PLCP_HEADER						5
+#define EXTRA_INFO_LEN					5 	//8 for ZD1212
+#else
+
+
+#define PLCP_HEADER						4
+#define EXTRA_INFO_LEN					4
+#endif
+
+#define EXTEND_IV_LEN					4
+#define MIC_LENGTH						8
+#define WDS_ADD_HEADER					6
+#define EAPOL_TYPE						0x888e
+
+#define BCN_INTERVAL_OFFSET				8
+#define CAP_OFFSET						10
+#define SSID_OFFSET						12
+#define	NUM_SUPPORTED_RATE				32
+
+#define BSS_INFO_NUM					64
+
+#define TUPLE_CACHE_SIZE				16
+#define MAX_DEFRAG_NUM					8
+
+
+#if defined(HOST_IF_USB)
+    #define MAX_RX_TIMEOUT				(100)
+#else
+    #define MAX_RX_TIMEOUT				(512*10*1000)
+#endif
+
+#define MAXIM2_MAX_TX_PWR_SET       	0x7F
+#define MAXIM2_MIN_TX_PWR_SET       	0x0
+#define RFMD_MAX_TX_PWR_SET         	0xF0
+#define RFMD_MIN_TX_PWR_SET        		0x60
+
+#define	GCT_MAX_TX_PWR_SET				0x3f
+#define	GCT_MIN_TX_PWR_SET				0x0
+
+#define	AL2210_MAX_TX_PWR_SET			0xff
+#define	AL2210_MIN_TX_PWR_SET			0x80
+
+#define MAX_TX_PWR_READING              0xf0
+#define MIN_TX_PWR_READING              0x30
+
+#define AL2230_MAX_TX_PWR_SET       	(0x7F-1)
+#define AL2230_MIN_TX_PWR_SET       	(0x00+1)
+
+
+#define	TRACKING_NUM					20//10
+
+
+//for USB
+#define cTX_CCK                     	1
+#define cTX_OFDM                    	2       // 6M - 36M
+#define cTX_48M                     	3
+#define cTX_54M                     	4
+#define cPWR_CTRL_GUARD             	4       // CR57: 4 -> 0.5 dB
+#define cPWR_INT_VALUE_GUARD        	8       // CR31: 4 -> 1 dB; 8 -> 2 dB
+#define cPWR_STRONG_SIG_DROP        	(0x18 - cPWR_INT_VALUE_GUARD)
+
+
+#define cLBTEST_COUNT               	1000
+#define cLBTEST_PATN                	0x55
+
+
+#define cMAX_MULTI_WRITE_REG_NUM    	15
+#define cMIN_MULTI_WRITE_REG_NUM    	0
+#define cMAX_MULTI_RF_REG_NUM       	28
+#define cMAX_MULTI_READ_REG_NUM     	15
+
+
+/* Firmware Interface */
+#define cTX_QUEUE_LEN               	4
+// make sure already Tx by HMAC (for UMAC System)
+// 1.Host->UMAC, 2.In UMAC Queue, 3.HMAC Sent
+#define cTX_SENT_LEN                	(cTX_QUEUE_LEN + 2)
+#define cFIRMWARE_OLD_ADDR          	0xEC00
+#define cFIRMWARE_START_ADDR        	0xEE00
+#define cFIRMWARE_EXT_CODE          	0x1000
+#define cADDR_ENTRY_TABLE           	(cFIRMWARE_START_ADDR + 0x1D)
+#define cBOOTCODE_START_ADDR        	0xF800
+#define cINT_VECT_ADDR              	0xFFF5
+#define cEEPROM_SIZE                	0x800   // 2k word (4k byte)
+
+
+// in word (16 bit width)
+#define cLOAD_CODE_LEN              	0xE
+#define cLOAD_VECT_LEN              	(0x10000 - 0xFFF7)
+#define cEPDATA_OFFSET              	(cLOAD_CODE_LEN + cLOAD_VECT_LEN)
+#define USB_BASE_ADDR_EEPROM        	0x9900
+#ifdef ZD1211B
+	#define USB_BASE_ADDR_HOST         	0x9F00
+#elif defined(ZD1211)
+	#define USB_BASE_ADDR_HOST			0x9B00
+#else
+	#error	"***** You Need To Specified ZD1211 or ZD1211B *****"
+#endif
+#define BASE_ADDR_MASK_HOST         	(~0x00FF)
+#define cFIRMWARE_EEPROM_OFFSET     	(cBOOTCODE_START_ADDR + cEPDATA_OFFSET)
+//end of USB
+
+
+// For Rate Adaption
+#define FALL_RATE						0x0
+#define	RISE_RATE						0x1
+
+#define PS_CAM							0x0
+#define	PS_PSM							0x1
+
+#define	ACC_1							0x0
+#define	ACC_2							0x1
+
+// MAC_PA_STATE
+#define	MAC_INI						0x0
+#define	MAC_OPERATION					0x1
+#define MAC_PS_OPERATION                                0x1
+#define MAC_PS_SLEEP					0x2
+
+
+
+// RF TYPE
+#define UW2451_RF					0x2
+#define uChip_RF					0x3
+#define	AL2230_RF					0x4
+#define	AL2210MPVB_RF				0x4
+#define AL7230B_RF					0x5 //a,b,g RF
+#define	THETA_RF					0x6
+#define	AL2210_RF					0x7
+#define	MAXIM_NEW_RF				0x8
+#define	GCT_RF						0x9
+#define	PV2000_RF					0xA
+#define	RALINK_RF					0xB
+#define	INTERSIL_RF					0xC
+#define	RFMD_RF						0xD
+
+
+#define	MAXIM_NEW_RF2				0xE
+#define	PHILIPS_RF					0xF
+
+
+#define ELEID_SSID					0
+
+
+#define	ELEID_SUPRATES				1
+#define ELEID_DSPARMS				3
+#define ELEID_TIM					5
+#define ELEID_ERP_INFO				42
+#define ELEID_EXT_RATES				50
+//-------------------------------------------------------------------------
+//- Miscellaneous Equates
+//-------------------------------------------------------------------------
+#ifndef FALSE
+#define FALSE       0
+#define TRUE        1
+#endif
+
+#define DRIVER_NULL ((u32)0xffffffff)
+
+//-------------------------------------------------------------------------
+// Bit Mask definitions
+//-------------------------------------------------------------------------
+#define BIT_0       		0x0001
+#define BIT_1       		0x0002
+#define BIT_2       		0x0004
+#define BIT_3       		0x0008
+#define BIT_4       		0x0010
+#define BIT_5       		0x0020
+#define BIT_6       		0x0040
+#define BIT_7       		0x0080
+#define BIT_8       		0x0100
+#define BIT_9       		0x0200
+#define BIT_10      		0x0400
+#define BIT_11      		0x0800
+#define BIT_12      		0x1000
+#define BIT_13      		0x2000
+#define BIT_14      		0x4000
+#define BIT_15      		0x8000
+#define BIT_16      		0x00010000
+#define BIT_17      		0x00020000
+#define BIT_18      		0x00040000
+#define BIT_19      		0x00080000
+#define BIT_20      		0x00100000
+#define BIT_21				0x00200000
+#define BIT_22				0x00400000
+#define BIT_23				0x00800000
+#define BIT_24      		0x01000000
+#define BIT_25				0x02000000
+#define BIT_26				0x04000000
+#define BIT_27				0x08000000
+#define BIT_28      		0x10000000
+#define BIT_29      		0x20000000
+#define BIT_30      		0x40000000
+#define BIT_31      		0x80000000
+
+#define BIT_0_1				0x0003
+#define BIT_0_2     		0x0007
+#define BIT_0_3     		0x000F
+#define BIT_0_4    			0x001F
+#define BIT_0_5     		0x003F
+#define BIT_0_6     		0x007F
+#define BIT_0_7     		0x00FF
+#define BIT_0_8    			0x01FF
+#define BIT_0_13    		0x3FFF
+#define BIT_0_15    		0xFFFF
+#define BIT_1_2    			0x0006
+#define BIT_1_3     		0x000E
+#define BIT_2_5     		0x003C
+#define BIT_3_4     		0x0018
+#define BIT_4_5     		0x0030
+#define BIT_4_6     		0x0070
+#define BIT_4_7     		0x00F0
+#define BIT_5_7     		0x00E0
+#define BIT_5_9     		0x03E0
+#define BIT_5_12    		0x1FE0
+#define BIT_5_15    		0xFFE0
+#define BIT_6_7     		0x00c0
+#define BIT_7_11    		0x0F80
+#define BIT_8_10    		0x0700
+#define BIT_9_13    		0x3E00
+#define BIT_12_15   		0xF000
+
+#define BIT_16_20   		0x001F0000
+#define BIT_21_25   		0x03E00000
+#define BIT_26_27   		0x0C000000
+
+#define RANDOM				0x0
+#define INCREMENT			0x1
+
+
+
+// Device Bus-Master (Tx) state
+#define TX_IDLE					0x00
+#define TX_READ_TBD				0x01
+#define TX_READ_DATA0			0x02
+#define TX_READ_DATA1			0x03
+#define TX_CHK_TBD_CNT			0x04
+#define TX_READ_TCB				0x05
+#define TX_CHK_TCB				0x06
+#define TX_WAIT_DATA			0x07
+#define TX_RETRYFAILURE			0x08
+#define TX_REDOWNLOAD			0x09
+
+// Device Bus-Master (Rx) state
+#define RX_IDLE					0x00
+#define RX_WAIT_DATA			0x10
+#define RX_DATA0				0x20
+#define RX_DATA1				0x30
+#define RX_READ_RCB				0x50
+
+#define RX_CHK_RCB				0x60
+#define RX_WAIT_STS				0x70
+#define RX_FRM_ERR				0x80
+#define RX_CHK_DATA				0x90
+
+
+#define MAX_SSID_LEN			32
+
+#define HOST_PEND				BIT_31
+#define CAM_WRITE				BIT_31
+#define MAC_LENGTH				6
+#define RX_MIC_ERROR_IND	    BIT_4 // Bit4 of ExtraInfo[6], its Bit3-Bit0 indicates the encryption type.
+#define RX_HW_MIC_ENABLE	    BIT_25 // The subfield of ZD_SnifferOn
+
+#define MIC_FINISH				BIT_0
+
+#define RX_MIC_ERROR_IND		BIT_4
+#define HW_MIC_ENABLE			BIT_25
+
+
+enum Frame_Control_Bit {
+        TO_DS = BIT_0,
+        FROM_DS = BIT_1,
+        MORE_FRAG = BIT_2,
+        RETRY_BIT = BIT_3,
+        PWR_BIT = BIT_4,
+        MORE_DATA = BIT_5,
+        ENCRY_BIT = BIT_6,
+        ODER_BIT = BIT_7
+
+};
+
+
+
+#define MAX_USER				40
+#define MAX_KEY_LENGTH			16
+#define ENCRY_TYPE_START_ADDR	60
+#define DEFAULT_ENCRY_TYPE		65
+#define KEY_START_ADDR			66
+#define STA_KEY_START_ADDR		386
+#define COUNTER_START_ADDR		418
+#define STA_COUNTER_START_ADDR	423
+
+#define EXTENDED_IV				BIT_5
+#define QoS_DATA				BIT_7
+#define TO_DS_FROM_DS			BIT_0_1
+
+#define AP_MODE					BIT_24
+#define IBSS_MODE				BIT_25
+#define POWER_MNT				BIT_26
+#define STA_PS					BIT_27
+
+#define NON_ERP_PRESENT_BIT		BIT_0
+
+#define USE_PROTECTION_BIT		BIT_1
+#define BARKER_PREAMBLE_BIT		BIT_2
+
+#define HOST_BIG_ENDIAN			BIT_0
+
+#define MEMBER_ZD1202			BIT_0
+#define MEMBER_OTHERS			BIT_1
+#define	BEACON_TIME				1
+#define REG_MAX_WAIT			500
+
+//for UART support
+
+/*
+ * These are the definitions for the Line Control Register
+ */
+#define UART_LCR_SBC			BIT_6	/* Set break control */
+#define UART_LCR_DLAB			BIT_7	/* Divisor latch access bit */
+
+/*
+ * These are the definitions for the Line Status Register
+ */
+#define UART_LSR_DR				BIT_0	/* Receiver data ready */
+#define UART_LSR_OE				BIT_1	/* Overrun error indicator */
+#define UART_LSR_BI				BIT_4	/* Break interrupt indicator */
+#define UART_LSR_THRE			BIT_5	/* Transmit-hold-register empty */
+#define UART_LSR_TEMT			BIT_6	/* Transmitter empty */
+
+/*
+ * These are the definitions for the Interrupt Identification Register
+ */
+#define UART_IIR_ID_MASK		0x0E	/* Mask for the interrupt ID */
+#define UART_IIR_MSI			0x00	/* Modem status interrupt */
+#define UART_IIR_NO_INT			BIT_0	/* No interrupts pending */
+#define UART_IIR_THRI			BIT_1	/* Transmitter holding register empty */
+#define UART_IIR_RDI			BIT_2	/* Receiver data interrupt */
+#define UART_IIR_RLSI			0x06	/* Receiver line status interrupt */
+#define UART_IIR_RX_TIMEOUT		0x0C	/* Rx timeout interrupt */
+
+/*
+ 
+ 
+ * These are the definitions for the Interrupt Enable Register
+ */
+#define UART_IER_RDI			BIT_0	/* Enable receiver data interrupt */
+#define UART_IER_THRI			BIT_1	/* Enable Transmitter holding register int. */
+#define UART_IER_RLSI			BIT_2	/* Enable receiver line status interrupt */
+#define UART_IER_MSI			BIT_3	/* Enable Modem status interrupt */
+
+/*
+ * These are the definitions for the Modem Control Register
+ */
+#define UART_MCR_DTR			BIT_0	/* DTR complement */
+#define UART_MCR_RTS			BIT_1	/* RTS complement */
+#define UART_MCR_TAFC			BIT_5	/* Tx auto flow control */
+#define UART_MCR_RAFC			BIT_6	/* Rx auot flow control */
+
+/*
+ * These are the definitions for the Modem Status Register
+ */
+#define UART_MSR_DCTS			BIT_0	/* Delta CTS */
+#define UART_MSR_DDCD			BIT_3	/* Delta DCD */
+#define UART_MSR_CTS			BIT_4	/* Clear to Send */
+#define UART_MSR_DCD			BIT_7	/* Data Carrier Detect */
+#define UART_MSR_ANY_DELTA 		0x09	/* Any of the delta bits! */
+
+/*
+ * These are the definitions for the FIFO Control Register
+ * 
+ */
+#define UART_FCR_CLEAR_RCVR		BIT_1 	/* Clear the RCVR FIFO */
+#define UART_FCR_CLEAR_XMIT		BIT_2 	/* Clear the XMIT FIFO */
+#define UART_FCR_TX_TRIGGER_1	0x00 /* Mask for tx trigger set at 1 */
+#define UART_FCR_TX_TRIGGER_2	0x10 /* Mask for tx trigger set at 2 */
+#define UART_FCR_TX_TRIGGER_4	0x20 /* Mask for tx trigger set at 4 */
+#define UART_FCR_TX_TRIGGER_8	0x30 /* Mask for tx trigger set at 8 */
+#define UART_FCR_RX_TRIGGER_1	0x00 /* Mask for rx trigger set at 1 */
+#define UART_FCR_RX_TRIGGER_4	0x40 /* Mask for rx trigger set at 4 */
+#define UART_FCR_RX_TRIGGER_8	0x80 /* Mask for rx trigger set at 8 */
+#define UART_FCR_RX_TRIGGER_14	0xC0 /* Mask for rx trigger set at 14 */
+
+
+//Extra Control register
+#define UART_ECR_BREAK_LEN_11_BAUD	0x00 	/* Break length 11 baud clocks */
+#define UART_ECR_BREAK_LEN_12_BAUD	0x01 	/* Break length 12 baud clocks */
+#define UART_ECR_BREAK_LEN_23_BAUD	0x02 	/* Break length 23 baud clocks */
+#define UART_ECR_BREAK_LEN_25_BAUD	0x03 	/* Break length 25 baud clocks */
+#define UART_ECR_BREAK_DETECTION 	BIT_2	/* Break detection */
+#define UART_ECR_BREAK_ENABLE 		BIT_3	/* Break enable */
+#define UART_ECR_RX_TOUT_10_BAUD	0x00	/* Rx fifo timeout 10 baud cloacks */
+#define UART_ECR_RX_TOUT_20_BAUD	0x10	/* Rx fifo timeout 20 baud cloacks */
+#define UART_ECR_RX_TOUT_40_BAUD	0x20	/* Rx fifo timeout 40 baud cloacks */
+#define UART_ECR_RX_TOUT_80_BAUD	0x30	/* Rx fifo timeout 80 baud cloacks */
+#define UART_ECR_ENABLE 			BIT_7	/* UART enable */
+
+//Baud rate definition
+#define	BAUD_RATE_2400			0xBF
+#define BAUD_RATE_4800 			0x5F
+#define BAUD_RATE_9600 			0x2F
+#define BAUD_RATE_19200 		0x17
+#define BAUD_RATE_38400			0x0B
+#define BAUD_RATE_57600 		0x07
+#define BAUD_RATE_115200		0x03
+#define BAUD_RATE_230400		0x01
+#define BAUD_RATE_460800		0x00
+
+// for EEPROM support
+#define EEPROM_BASE_ADDRESS		0x900
+#define EEPROM_WRITE_ACCESS		BIT_15
+#define EEPROM_BUSY_FLAG		BIT_15
+#define EEPROM_ACCESS_WRITE		0x01
+#define EEPROM_ACCESS_READ		0x00
+
+
+#define mBIT(b)                 (1 << (b))
+#define mMASK(w)                (mBIT(w) - 1)
+#define mSET_MASK(a, b)         ((a) | (b))
+#define mCLR_MASK(a, b)         ((a) & (~(b)))
+#define mSET_BIT(a, b)          mSET_MASK(a, mBIT(b))
+#define mCLR_BIT(a, b)          mCLR_MASK(a, mBIT(b))
+#define mCHK_BIT1(a, b)         ((a) & mBIT(b))
+#define mTEST_BIT(a, b)         mCHK_BIT1(a, b)
+
+
+#endif      // _EQUATES_H
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdglobal.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdglobal.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdglobal.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdglobal.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,104 @@
+#ifndef __ZDGLOBAL_C__
+#define __ZDGLOBAL_C__
+
+#include "zd80211.h"
+#include "zddebug.h"
+
+
+U8		mPreambleType = LONG_PREAMBLE;
+MacAddr_t	dot11MacAddress = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+Element		dot11DesiredSsid;
+U8 		dot11DesiredBssid[6];  // When macp->ap_scan=1, use this to associate with an AP.
+U32		mDebugFlag = 0;
+U8		mAuthAlogrithms[2] = {OPEN_SYSTEM, SHARE_KEY};
+U16		mRfChannel = 0;
+U16		mBeaconPeriod = 100;
+U16		mDtimPeriod = 1;
+U16		mFragThreshold = 2432;
+U16 		mRtsThreshold = 2432;
+U16		mTmRetryConnect=0;
+// For debugging purpose
+//#ifdef WPADATA_DEBUG
+u8 		*DbgStrEncryType[]={"NOWEP","WEP64","TKIP","NA3","AES","WEP128","WEP256", "NA7"};
+u8 		*DbgStrDynKeyMode[]={"NOWEP","WEP64","WEP128","NA3","TKIP","AES","NA6","NA7"};
+//#endif
+// ------------------------------------------------------------------------
+
+//WPA
+Element		mWPAIe;
+U8		mCounterMeasureState;
+//WEP
+U8		mKeyId = 0;
+U8		mKeyFormat = WEP64_USED;
+BOOLEAN 	mPrivacyInvoked = FALSE;
+Element		mSsid;
+Element		mBrates;
+Element 	mPhpm;
+MacAddr_t	mBssId;
+U16 		mCap = CAP_ESS;
+U16 		mDtimCount;
+
+U8	 	mPsStaCnt = 0;	//Station count for associated and in power save mode
+U8		mHiddenSSID = 0;
+U8		mLimitedUser = 0;
+U8		mCurrConnUser = 0;
+U8		mNumBOnlySta=0;
+
+U8		mBlockBSS = 0;
+U8		mRadioOn = 1;
+U8		mSwCipher = 0;
+U8		mKeyVector[4][16];
+U8		mBcKeyVector[16];
+U8 		mWepIv[4];
+U8 		mBcIv[4];
+U8		mWepKeyLen;
+U8		mBcKeyLen;
+U8		mBcKeyId;
+U8		mDynKeyMode = 0;
+BOOLEAN		mZyDasModeClient = FALSE;
+Seedvar		mBcSeed;
+MICvar		mBcMicKey;
+U8		mWpaBcKeyLen = 0;
+U8		mWpaBcKeyId = 1;
+U8		mGkInstalled = 0;
+U16		mIv16 = 0;
+U32		mIv32 = 0;
+const	U8  zeroMacAddress[6] =
+        {
+                0,0,0,0,0,0
+        };
+MacAddr_t	dot11BCAddress = {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff}};
+BssInfo_t	mBssInfo[64];
+U8		mBssNum = 0;
+U8		mBssCnt = 0;
+U16		mAuthAlg = OPEN_SYSTEM;
+U16		mListenInterval = 1;
+U16		mAid;
+BOOLEAN		mAssoc = FALSE;
+MacAddr_t	mOldAP;
+U8		mBssType = INFRASTRUCTURE_BSS;
+U16		mAPCap;
+Element		mAPBrates;
+U8		mBssIndex = 0;
+U16		mRequestFlag = 0;
+U8		mPwrState = 0;
+BOOLEAN		mAPAlive = FALSE;
+BOOLEAN		mProbeWithSsid = FALSE;
+Element		mIbssParms;
+U16		mATIMWindow;
+U8		mConnRetryCnt = 0;
+U8		mMaxTxRate = 3;
+
+// for G mode
+Element		mErp = {{EID_ERP, 1, 0x00}};
+Element		mExtRates;
+U8		mMacMode = MIXED_MODE;
+U8		mOperationMode;
+U8		mBurstMode;
+Element		mAPErates;
+BOOLEAN		mIfaceOpened = FALSE;
+
+Element		mBrates11A; //Basic Rate for 11A
+
+U8		mAuthMode;
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdglobal.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdglobal.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdglobal.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdglobal.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,94 @@
+#ifndef __ZDGLOBAL_H__
+#define __ZDGLOBAL_H__
+
+extern U16		mRfChannel;
+extern U16		mDtimPeriod;
+extern U16		mBeaconPeriod;
+extern Element		dot11DesiredSsid;
+extern U8		mAuthAlogrithms[2];
+extern U8		mPreambleType;
+
+extern U32		mDebugFlag;
+
+extern BOOLEAN 		mPrivacyInvoked;
+extern U8 		mKeyId;
+extern U8 		mBcKeyId;
+extern U8		mKeyFormat;
+extern MacAddr_t	dot11MacAddress;
+extern U16 		mRtsThreshold;
+extern U16		mFragThreshold;
+extern const	U8  zeroMacAddress[6];
+extern U8 		dot11DesiredBssid[6];  // When macp->ap_scan=1, use this to associate with an AP.
+// for debugging purpose
+extern u8 *DbgStrEncryType[];
+extern u8 *DbgStrDynKeyMode[];
+
+
+//WPA
+extern Element		mWPAIe;
+extern U8	mCounterMeasureState;
+extern U8			mNumBOnlySta;
+
+extern U16 		mCap;
+extern U16 		mDtimCount;
+extern Element		mSsid;
+extern Element		mBrates;
+extern Element 		mPhpm;
+extern MacAddr_t 	mBssId;
+
+//feature
+extern U8 		mPsStaCnt;
+extern U8		mHiddenSSID;
+extern U8		mLimitedUser;
+extern U8		mCurrConnUser;
+extern U8		mBlockBSS;
+extern U8		mRadioOn;
+extern U8		mSwCipher;
+extern U8		mKeyVector[4][16];
+extern U8		mBcKeyVector[16];
+extern U8 		mWepIv[4];
+extern U8 		mBcIv[4];
+extern U8		mWepKeyLen;
+extern U8		mBcKeyLen;
+extern U8		mDynKeyMode;
+extern BOOLEAN		mZyDasModeClient;
+extern Seedvar		mBcSeed;
+extern MICvar		mBcMicKey;
+extern U8		mWpaBcKeyLen;
+extern U8		mWpaBcKeyId;
+extern U8		mGkInstalled;
+extern U16		mIv16;
+extern U32		mIv32;
+extern MacAddr_t	dot11BCAddress;
+extern BssInfo_t	mBssInfo[64];
+extern U8		mBssNum;
+extern U8		mBssCnt;
+extern U16		mAuthAlg;
+extern U16		mListenInterval;
+extern U16		mAid;
+extern BOOLEAN		mAssoc;
+extern MacAddr_t	mOldAP;
+extern U8		mBssType;
+extern U16		mAPCap;
+extern Element		mAPBrates;
+extern U8		mBssIndex;
+extern U16		mRequestFlag;
+extern U8		mPwrState;
+
+extern BOOLEAN		mAPAlive;
+extern BOOLEAN		mProbeWithSsid;
+extern Element		mIbssParms;
+extern U16		mATIMWindow;
+extern U8		mConnRetryCnt;
+extern U8		mMaxTxRate;
+
+extern Element		mErp;
+extern Element		mExtRates;
+extern U8		mMacMode;
+extern U8		mOperationMode;
+extern U8		mBurstMode;
+extern Element		mAPErates;
+extern BOOLEAN		mIfaceOpened;
+
+extern U8		mAuthMode;
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdhci.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdhci.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdhci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdhci.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,2760 @@
+#ifndef _ZDHCI_C_
+#define _ZDHCI_C_
+#include "zd80211.h"
+#include "zdhci.h"
+#include "zdequates.h"
+#include "zd1205.h"
+#include "zddebug.h"
+
+#define MAX_CHANNEL_ALLOW				13
+
+BOOLEAN zd_PseudoIbssConnect(void);
+
+static U8 zd_Snap_Header[6] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};
+static U8 zd_SnapBridgeTunnel[6] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};
+static U8 zd_Snap_Apple_Type[] = {0xAA,0xAA,0x03,0x08,0x00,0x07,0x80,0x9b};
+static U8 zd_Snap_Apple_AARP[] = {0xAA,0xAA,0x03,0x00,0x00,0x00,0x80,0xf3};
+
+extern struct net_device *g_dev;
+zd_80211Obj_t *pdot11Obj = 0;
+
+extern const U16 dot11A_Channel[];
+extern const U16 dot11A_Channel_Amount;
+extern void ChangeMacMode(u8 MAC_Mode,u8 Channel);
+
+U16 CurrScanCH = 1;
+
+BOOLEAN zd_SendPkt(U8 *pEthHdr, U8 *pBody, U32 bodyLen, void *buf, U8 bEapol, void *pHash)
+{
+        Signal_t *signal;
+        FrmDesc_t *pfrmDesc;
+        Frame_t *frame;
+        U8	vapId = 0;
+        //FPRINT("zd_SendPkt");
+        if (mPsStaCnt) {
+                if (zd_CheckTotalQueCnt() > TXQ_THRESHOLD) {
+                        //FPRINT("Drop Tx packet");
+                        return FALSE;
+                }
+        }
+
+        signal = allocSignal();
+
+        if (!signal) {
+                FPRINT("zd_SendPkt out of signal");
+                FPRINT_V("freeSignalCount", freeSignalCount);
+                return FALSE;
+        }
+
+        pfrmDesc = allocFdesc();
+
+        if (!pfrmDesc) {
+                freeSignal(signal);
+                FPRINT("zd_SendPkt out of description");
+                FPRINT_V("freeFdescCount", freeFdescCount);
+                return FALSE;
+        }
+
+        frame = pfrmDesc->mpdu;
+        /*	FrameControl(2) Duration/ID(2) A1(6) A2(6) A3(6) Seq(2) A4/LLCHdr(6) LLCHdr(6) */
+        if (mBssType == AP_BSS) {
+                memcpy((char *)&(frame->header[4]), (char *)&(pEthHdr[0]), 6);		/* Set DA to A1 */
+                memcpy((char *)&(frame->header[16]), (char *)&(pEthHdr[6]), 6);		/* Set SA to A3 */
+                frame->header[1] = FROM_DS_BIT;
+        } else if (mBssType == INFRASTRUCTURE_BSS) {
+                memcpy((char *)&(frame->header[4]), (char *)&mBssId, 6);			/* Set BSSID to A1 */
+                memcpy((char *)&(frame->header[16]), (char *)&(pEthHdr[0]), 6);		/* Set DA to A3 */
+                frame->header[1] = TO_DS_BIT;
+                if (mPwrState) {
+                        frame->header[1] |= PW_SAVE_BIT;
+                } else
+                        frame->header[1] &= ~PW_SAVE_BIT;
+        } else if ((mBssType == INDEPENDENT_BSS) || (mBssType == PSEUDO_IBSS)) {
+                memcpy((char *)&(frame->header[4]), (char *)&(pEthHdr[0]), 6);		/* Set DA to A1 */
+                memcpy((char *)&(frame->header[16]), (char *)&mBssId, 6);			/* Set Bssid to A3 */
+                frame->header[1] = 0;
+        }
+
+        frame->bodyLen = bodyLen;
+        frame->body = pBody;
+        signal->buf = buf;
+        signal->vapId = vapId;
+        pfrmDesc->ConfigSet &= ~INTRA_BSS_SET;
+        frame->HdrLen = MAC_HDR_LNG;
+        frame->header[0] = ST_DATA;
+        setAddr2(frame, &dot11MacAddress);
+
+        if (bEapol) {
+                pfrmDesc->ConfigSet |= EAPOL_FRAME_SET;
+        } else
+                pfrmDesc->ConfigSet &= ~EAPOL_FRAME_SET;
+
+        signal->bDataFrm = 1;
+        //pfrmDesc->bDataFrm = 1;
+        pfrmDesc->pHash = (Hash_t *)pHash;
+        if (pHash == NULL && !(pEthHdr[0]&BIT_0) )
+                printk(KERN_ERR "===== ==== ===pHash is NULL in zd_SendPkt\n");
+        mkFragment(signal, pfrmDesc, pEthHdr); //10 us
+#if 0
+        //force free for debug only
+        zd1205_dump_data("header", (u8 *)&frame->header[0], frame->HdrLen);
+        zd1205_dump_data("body", (u8 *)frame->body, frame->bodyLen);
+        freeSignal(signal);
+        freeFdesc(pfrmDesc);
+        return TRUE;
+#endif
+
+#if 1
+
+        if (SendPkt(signal, pfrmDesc, TRUE))  //4727
+                return FALSE;
+        else
+                return TRUE;
+#else
+
+        SendPkt(signal, pfrmDesc, TRUE);
+        return TRUE;
+#endif
+}
+
+#define	LP_FORWARD		0
+#define	BC_FORWARD		1
+#define BSS_FORWARD		2
+void zd_WirelessForward(U8 *pHdr, U8 *pBody, U32 len, void *buf, U8 mode, void *pHash, U8 *pEthHdr)
+{
+        Signal_t *signal;
+        FrmDesc_t *pfrmDesc;
+        Frame_t *frame;
+        U8	vapId = 0;
+        //FPRINT("zd_WirelessForward");
+
+        if (mPsStaCnt) {
+                if (zd_CheckTotalQueCnt() > TXQ_THRESHOLD) {
+                        //FPRINT("Drop Intra-BSS packet");
+                        pdot11Obj->ReleaseBuffer(buf);
+                        return;
+                }
+        }
+
+        signal = allocSignal();
+        if (!signal) {
+                FPRINT("zd_WirelessForward out of signal");
+                FPRINT_V("freeSignalCount", freeSignalCount);
+                pdot11Obj->ReleaseBuffer(buf);
+                return;
+        }
+
+        pfrmDesc = allocFdesc();
+        if (!pfrmDesc) {
+                freeSignal(signal);
+                FPRINT("zd_WirelessForward out of description");
+                FPRINT_V("freeFdescCount", freeFdescCount);
+                pdot11Obj->ReleaseBuffer(buf);
+                return;
+        }
+
+        frame = pfrmDesc->mpdu;
+        /* FrameControl(2) Duration/ID(2) A1(6) A2(6) A3(6) Seq(2) A4/LLCHdr(6) LLCHdr(6) */
+        memcpy((char *)&(frame->header[4]), (char *)&(pHdr[16]), 6);	/* Set DA to A1 */
+        memcpy((char *)&(frame->header[16]), (char *)&(pHdr[10]), 6);	/* Set SA to A3 */
+
+        frame->bodyLen = len;
+        frame->body = pBody;
+        signal->buf = buf;
+        signal->vapId = vapId;
+
+        if (mode == LP_FORWARD) {
+                memcpy((char *)&(frame->header[4]), (char *)&(pHdr[10]), 6);	/* Set DA to A1 */
+                memcpy((char *)&(frame->header[16]), (char *)&dot11MacAddress, 6);	/* Set SA to A3 */
+                frame->body[6] = 0x38;
+                frame->body[7] = 0x39;
+        }
+
+        pfrmDesc->ConfigSet |= INTRA_BSS_SET;
+        pfrmDesc->ConfigSet &= ~EAPOL_FRAME_SET;
+        signal->bDataFrm = 1;
+        //pfrmDesc->bDataFrm = 1;
+        frame->HdrLen = MAC_HDR_LNG;
+        frame->header[0] = ST_DATA;
+        frame->header[1] = FROM_DS_BIT;
+        setAddr2(frame, &dot11MacAddress);
+        pfrmDesc->pHash = (Hash_t *)pHash;
+        mkFragment(signal, pfrmDesc, pEthHdr);
+        SendPkt(signal, pfrmDesc, FALSE);
+        return;
+}
+
+void zd_SendDeauthFrame(U8 *sta, U8 ReasonCode)
+{
+        Signal_t *signal;
+
+        printk(KERN_ERR "SendDeauthFrame with ReasonCode=%u\n",ReasonCode);
+        if ((mBssType == INDEPENDENT_BSS) || (mBssType == PSEUDO_IBSS))
+                return;
+
+        if ((signal = allocSignal()) == NULL)
+                return;
+        signal->id = SIG_DEAUTH_REQ;
+        signal->block = BLOCK_AUTH_REQ;
+        signal->vapId = 0;
+        memcpy(&signal->frmInfo.Sta, sta, 6);
+        signal->frmInfo.rCode =  ReasonCode;
+        sigEnque(pMgtQ, (signal));
+
+        return;
+}
+
+void zd_SendClass2ErrorFrame(MacAddr_t *sta, U8 vapId)
+{
+        Signal_t *signal;
+
+        //FPRINT("zd_sendClass2ErrorFrame");
+
+        if ((mBssType == INDEPENDENT_BSS) || (mBssType == PSEUDO_IBSS))
+                return;
+
+        if ((signal = allocSignal()) == NULL)
+                return;
+        signal->id = SIG_DEAUTH_REQ;
+        signal->block = BLOCK_AUTH_REQ;
+        signal->vapId = vapId;
+        memcpy(&signal->frmInfo.Sta, sta, 6);
+        signal->frmInfo.rCode = RC_CLASS2_ERROR;
+        sigEnque(pMgtQ, (signal));
+
+        return;
+}
+
+void zd_SendClass3ErrorFrame(MacAddr_t *sta, U8 vapId)
+{
+        Signal_t *signal;
+
+        //FPRINT("zd_SendClass3ErrorFrame");
+        if ((mBssType == INDEPENDENT_BSS) || (mBssType == PSEUDO_IBSS))
+                return;
+
+        if ((signal = allocSignal()) == NULL)
+                return;
+
+        signal->id = SIG_DIASSOC_REQ;
+        signal->block = BLOCK_ASOC;
+        signal->vapId = vapId;
+        memcpy(&signal->frmInfo.Sta, sta, 6);
+        signal->frmInfo.rCode = RC_CLASS3_ERROR;
+        sigEnque(pMgtQ, (signal));
+
+        return;
+}
+
+#define MIC_HEADER_LEN	16
+BOOLEAN zd_CheckMic(U8 *pHdr, U8 *pBody, U32 bodyLen, Hash_t *pHash, U8 *pEthHdr)
+{
+        MICvar *pRxMicKey;
+        U8 PkInstalled = 0;
+        U8 *pByte;
+        U8 CalMic[8];
+        int i = 0;
+        U8 *pIV = pHdr + 24;
+
+        /* Always return TRUE, 4D06 */
+        //return TRUE;
+        //if (!pHash)
+        //	return FALSE;
+
+        if (pIV[3] & EIV_BIT) {
+                if (pHdr[4] & 1) // Use group key
+                {
+                        if (mGkInstalled)
+                                pRxMicKey = &mBcMicKey;
+                        else
+                                return FALSE;
+                } else // Use Unicast key
+                {
+                        if (!pHash)
+                                return FALSE;
+                        if ((PkInstalled=pHash->pkInstalled))
+                                pRxMicKey = &pHash->RxMicKey;
+                        else
+                                return FALSE;
+                }
+
+                //zd1205_dump_data("IV = ", pIV, 8);
+                //zd1205_dump_data("MIC K0= ", (U8 *)&pRxMicKey->K0, 4);
+                //zd1205_dump_data("MIC K1= ", (U8 *)&pRxMicKey->K1, 4);
+                //pRxMicKey = &pHash->RxMicKey;
+
+                //PkInstalled = pHash->pkInstalled;
+
+                if (1) {
+                        U32 Len = bodyLen - MIC_LNG;
+#if 0
+
+                        void *reg = pdot11Obj->reg;
+                        U32 BolckLen = 0;
+                        U32 tmpValue = 0;
+                        U32 BlockNum = 2;
+                        U32 MicLow, MicHigh;
+                        U32 MicStatus = 0;
+                        U32 HwMicStatus = 0;
+                        register int j = 0;
+                        U32 RxMicWrBackAddr = (U32)pEthHdr + MIC_HEADER_LEN;
+                        U32 HwMicHighPhys = RxMicWrBackAddr + 4;
+                        U32 HwMicStatusPhys = HwMicHighPhys + 4;
+
+                        //FPRINT("************* RX MIC ****************");
+
+                        //reser HW MIC status
+                        memset(RxMicWrBackAddr, 0x11, 12);
+
+                        //wait last MIC finish, then start this one
+                        MicStatus = pdot11Obj->GetReg(reg, ZD_MIC_STATUS);
+                        while (MicStatus & MIC_BUSY) {
+                                pdot11Obj->DelayUs(1);
+                                MicStatus = pdot11Obj->GetReg(reg, ZD_MIC_STATUS);
+                                j++;
+                                if (j>1000) {
+                                        bMicFinish = FALSE;
+                                        //FPRINT("Rx MIC can't start !!!");
+                                        //FPRINT_V("MicStatus", MicStatus);
+                                        zdCnt.RxMicNoStart++;
+                                        break;
+                                }
+                        }
+
+                        //set mic key
+                        pdot11Obj->SetReg(reg, ZD_MIC_KEY_LOW, pRxMicKey->K0);
+                        pdot11Obj->SetReg(reg, ZD_MIC_KEY_HIGH, pRxMicKey->K1);
+
+                        //set 802.3 header
+                        pdot11Obj->SetReg(reg, ZD_MIC_START_ADDR0, (U32)pEthHdr);
+                        pdot11Obj->SetReg(reg, ZD_MIC_BLOCK0_LEN, MIC_HEADER_LEN);
+
+                        //set mac body
+                        pdot11Obj->SetReg(reg, ZD_MIC_START_ADDR1, (U32)pBody);
+                        pdot11Obj->SetReg(reg, ZD_MIC_BLOCK1_LEN, Len);
+
+                        //set write back address
+                        pdot11Obj->SetReg(reg, ZD_MIC_WRITE_BACK_ADDRS, (U32)RxMicWrBackAddr);
+
+                        BolckLen = MIC_HEADER_LEN + Len;
+                        tmpValue = (BlockNum | (BolckLen << 16));
+                        pdot11Obj->SetReg(reg, ZD_MIC_TOTAL_BLOCK_NUM, tmpValue);
+
+                        // busy waiting MIC finish
+                        j= 0;
+                        /* ath_desc: bigendian support */
+                        /* ath: replaced zd_le32_to_cpu by le32_to_cpu */
+                        HwMicStatus = le32_to_cpu(*(U32 *)(HwMicStatusPhys));
+                        while (HwMicStatus != HW_MIC_FINISH) {
+                                pdot11Obj->DelayUs(1);
+                                HwMicStatus = le32_to_cpu(*(U32 *)(HwMicStatusPhys));
+                                j++;
+                                if (j>1000) {
+                                        bMicFinish = FALSE;
+                                        //FPRINT("Rx MIC not finish !!!");
+                                        //FPRINT_V("HwMicStatus", HwMicStatus);
+                                        zdCnt.RxMicNoFinish++;
+                                        break;
+                                }
+                        }
+
+                        MicLow = le32_to_cpu (*(U32 *)RxMicWrBackAddr);
+                        MicHigh = le32_to_cpu (*(U32 *)(HwMicHighPhys));
+
+                        pByte = pBody + Len; //point to MIC start
+                        CalMic[0] = (U8) MicLow;
+                        CalMic[1] = (U8) (MicLow >> 8);
+                        CalMic[2] = (U8) (MicLow >> 16);
+                        CalMic[3] = (U8) (MicLow >> 24);
+                        CalMic[4] = (U8) MicHigh;
+                        CalMic[5] = (U8) (MicHigh >> 8);
+                        CalMic[6] = (U8) (MicHigh >> 16);
+                        CalMic[7] = (U8) (MicHigh >> 24);
+#else
+                        //Software MIC Calculation, HW MIC failed
+                        MICclear(pRxMicKey);
+
+                        //pByte = pEthHdr;
+                        if (mBssType == INFRASTRUCTURE_BSS ||
+                                        mBssType == INDEPENDENT_BSS)
+                                pByte = &pHdr[4]; // DA = Addr1
+                        else //if (mBssType == AP_BSS)
+                                pByte = &pHdr[16]; //DA = Addr3
+
+                        for (i=0; i<6; i++) {
+                                MICappendByte(*pByte++, pRxMicKey);
+                        }
+                        if (mBssType == AP_BSS ||
+                                        mBssType == INDEPENDENT_BSS)
+                                pByte = &pHdr[10]; // SA=Addr2
+                        else // if (mBssType == INFRASTRUCTURE_BSS)
+                                pByte = &pHdr[16]; // SA=Addr3
+                        for (i=0; i<6; i++) {
+                                MICappendByte(*pByte++, pRxMicKey);
+                        }
+                        MICappendByte(0,pRxMicKey);//priority
+                        MICappendByte(0,pRxMicKey);//3 zeros
+                        MICappendByte(0,pRxMicKey);
+                        MICappendByte(0,pRxMicKey);
+
+                        pByte = pBody;
+                        for (i=0; i<Len; i++) {
+                                MICappendByte(*pByte++, pRxMicKey);
+                        }
+
+                        MICgetMIC(CalMic, pRxMicKey); // Append MIC (8 byte)
+
+#endif
+                        //FPRINT_V("Calcu HW MIC", RxCompLogBuf[RxComplogPktCnt][10]-RxCompLogBuf[RxComplogPktCnt][9]);
+
+                        // now pBye point to MIC area
+                        if (pdot11Obj->MIC_CNT && memcmp(CalMic, pByte, MIC_LNG) != 0) {
+                                zd1205_dump_data("pHdr = ", pHdr, 32);
+                                //FPRINT_V("Body Addr", (U32)pBody);
+                                zd1205_dump_data("pBody = ", pBody, bodyLen+16);
+                                zd1205_dump_data("CalMic = ", CalMic, 8);
+                                zd1205_dump_data("ReceMic = ", pByte, 8);
+
+                                printk(KERN_ERR "SW MIC Check fail\n");
+                                hostap_michael_mic_failure((struct zd1205_private *)g_dev->priv, (struct hostap_ieee80211_hdr *)pHdr, pIV[3] & KEYID_MASK);
+                                //pdot11Obj->MicFailure(&pEthHdr[6]);
+                                return FALSE;
+                        } else {
+                                //FPRINT("***** MIC success *****");
+                                //printk(KERN_ERR "SW MIC check OK\n");
+                                return TRUE;
+                        }
+                }
+        }
+
+        return FALSE;
+}
+
+void zd_ReceivePkt(U8 *pHdr, U32 hdrLen, U8 *pBody, U32 bodyLen, void *buf, U8 *pEthHdr, rxInfo_t *pRxInfo)
+{
+        Signal_t *pRxSignal;
+        FrmDesc_t *pRxFdesc;
+        Frame_t *pRxFrame;
+        MacAddr_t *pDa, *pSa;
+        StationState sas;
+        PsMode psm = PSMODE_STA_ACTIVE;
+        U32 dataLen;
+        U8 *pData;
+        U8 mode;
+        void *bcBuf;
+        U8 *pBcData;
+        Hash_t *pHash;
+        U8 vapId = 0;
+        U8 rate = pRxInfo->rate;
+        U8 bDataFrm = pRxInfo->bDataFrm;
+        U8 SaIndex = pRxInfo->SaIndex;
+        U8 signalStrength = pRxInfo->signalStrength;
+        U8 signalQuality = pRxInfo->signalQuality;
+        U8 bSwCheckMIC = pRxInfo->bSwCheckMIC;
+
+        ZDEBUG("zd_ReceivePkt");
+
+
+        if (mBssType == AP_BSS) {
+                pDa = (MacAddr_t *)&pHdr[16]; //A3
+                pSa = (MacAddr_t *)&pHdr[10]; //A2
+                if (bDataFrm) {
+                        //don't care PS Bit in authenticate, (Re)assoicate and Probe Reguest frame
+                        psm = (PsMode)((pHdr[1] & PW_SAVE_BIT) ? PSMODE_POWER_SAVE : PSMODE_STA_ACTIVE);
+                }
+                if (SaIndex == 0)
+                        pHash = RxInfoIndicate(pSa, psm, rate); //12us update ps and rate information
+                else {
+                        pHash = sstByAid[SaIndex];
+                        if (pHash)
+                                RxInfoUpdate(pHash, psm, rate);
+                }
+        } else if (mBssType == INFRASTRUCTURE_BSS) {
+                pDa = (MacAddr_t *)&pHdr[4];  //A1 will be my MAC
+                //pSa = (MacAddr_t *)&pHdr[16]; //A3
+                pSa = (MacAddr_t *)&pHdr[10]; //A2 for Asoc status check
+                pHash = sstByAid[0];
+        } else { // INDEPENDENT_BSS or PSEUDO_IBSS
+                pDa = (MacAddr_t *)&pHdr[4];  //A1
+                pSa = (MacAddr_t *)&pHdr[10]; //A2
+                pHash = RxInfoIndicate(pSa, 0, rate);
+        }
+
+
+        if (bDataFrm) {
+                if (!bodyLen)
+                        goto rx_release;
+
+                if (!pHash) {
+                        zd_SendClass2ErrorFrame(pSa, vapId);
+                        goto rx_release;
+                } else {
+                        sas = pHash->asoc;
+                        if ((sas != STATION_STATE_ASOC) && (mBssType == AP_BSS)) {
+                                //if (sas != STATION_STATE_ASOC){
+                                zd_SendClass3ErrorFrame(pSa, vapId);
+                                printk(KERN_ERR "Class3ErrFrm:%02X %02X %02X %02X %02X %02X\n",pSa->mac[0],pSa->mac[1],pSa->mac[2],pSa->mac[3],pSa->mac[4],pSa->mac[5]);
+                                goto rx_release;
+                        }
+                }
+
+                if (sas == STATION_STATE_ASOC) { //association station
+                        if (mBssType == AP_BSS) {
+                                if (isGroup(pDa)) {
+                                        if (pHash->keyLength == 32) {
+                                                //if (mDynKeyMode == DYN_KEY_TKIP){
+                                                if (!pHash->pkInstalled)
+                                                        goto rx_release;
+                                                else if (!mGkInstalled)
+                                                        goto rx_release;
+                                                else if ((pHdr[1] & WEP_BIT) && (hdrLen == 32)) {
+                                                        if (bSwCheckMIC) {
+                                                                if (!zd_CheckMic(pHdr, pBody, bodyLen, pHash, pEthHdr)) {
+                                                                        goto rx_release;
+                                                                } else {
+                                                                        bodyLen -= MIC_LNG; //remove MIC
+                                                                }
+                                                        }
+                                                }
+                                        }
+                                        if (mCurrConnUser > 1) {
+                                                mode = BC_FORWARD;
+                                                bcBuf = pdot11Obj->AllocBuffer(bodyLen, &pBcData);
+                                                if (bcBuf) {
+                                                        memcpy(pBcData, pBody, bodyLen);
+                                                        zd_WirelessForward(pHdr, pBcData, bodyLen, bcBuf, mode, NULL, pEthHdr);
+                                                }
+                                        }
+                                        goto rx_ind;
+                                } else {
+                                        void *pTxHash = NULL;
+
+                                        if (mBlockBSS) { //discard IntraBSS packet
+                                                goto rx_release;
+                                        }
+
+                                        zd_QueryStaTable((U8 *)pDa, &pTxHash); //Automatic wireless forwarding
+
+                                        if (pTxHash) {
+                                                if (bSwCheckMIC) {
+                                                        if ((pHash->keyLength==32) && (pHdr[1] & WEP_BIT) && (hdrLen == 32)) {
+
+                                                                if (!zd_CheckMic(pHdr, pBody, bodyLen, pHash, pEthHdr)) {
+                                                                        goto rx_release;
+                                                                } else
+                                                                        bodyLen -= MIC_LNG; //remove MIC
+                                                        }
+                                                }
+
+                                                mode = BSS_FORWARD;
+                                                zd_WirelessForward(pHdr, pBody, bodyLen, buf, mode, pTxHash, pEthHdr);
+                                                return;
+                                        }
+                                }
+                        }
+                        // mic check
+                        if (bSwCheckMIC) // For TKIP, always use sw-mic check.
+                        {
+                                //if ((pHash->keyLength==32) && (pHdr[1] & WEP_BIT) && (hdrLen == 32))
+                                {
+                                        if (!zd_CheckMic(pHdr, pBody, bodyLen, pHash, pEthHdr))
+                                        {// sw-mic check failed, discard this packet.
+                                                goto rx_release;
+                                        } else
+                                        {// sw-mic check ok, remove MIC
+                                                bodyLen -= MIC_LNG;
+                                        }
+                                }
+                        }
+rx_ind:
+                        //If Typelen field is not used for len
+                        if(memcmp(pBody,zd_Snap_Apple_AARP,8)==0 || memcmp(pBody,zd_Snap_Apple_Type,8)==0) {
+
+                                pData = pBody - 14;
+                                dataLen = bodyLen + 14;     /* Plus DA, SA and TypeLen */
+                                pData[12] = (bodyLen>>8) & 0xFF;
+                                pData[13] = bodyLen & 0xFF;
+
+                        } else if ((bodyLen > 5 ) && (memcmp(pBody, zd_Snap_Header, 6) == 0
+                                                      || memcmp(pBody, zd_SnapBridgeTunnel, 6) == 0)) {
+
+                                pData = pBody - 6;
+                                dataLen = bodyLen + 6;		/* Plus DA, SA*/
+                        } else {
+                                pData = pBody - 14;
+                                dataLen = bodyLen + 14;		/* Plus DA, SA and TypeLen */
+                                pData[12] = (bodyLen>>8) & 0xFF;
+                                pData[13] = bodyLen & 0xFF;
+                        }
+                        memcpy(pData, pEthHdr, 6);	/* Set DA */
+                        memcpy(pData+6, pEthHdr+6, 6);	/* Set SA */
+                        //if (Type == 0x888e)
+                        //zd1205_dump_data("pData = ", pData, dataLen);
+                        pdot11Obj->RxInd(pData, dataLen, buf);
+                        return;
+                }
+        } else {	//Mgt Frame
+                pRxSignal = allocSignal();
+                if (!pRxSignal) {
+                        FPRINT("zd_ReceivePkt out of signal");
+                        FPRINT_V("freeSignalCount", freeSignalCount);
+                        goto rx_release;
+                }
+
+                pRxFdesc = allocFdesc();
+                if (!pRxFdesc) {
+                        FPRINT("zd_ReceivePkt out of description");
+                        FPRINT_V("freeFdescCount", freeFdescCount);
+                        freeSignal(pRxSignal);
+                        goto rx_release;
+                } else {
+                        //pRxFdesc->bDataFrm = bDataFrm;
+                        pRxFdesc->signalStrength = signalStrength;
+                        pRxFdesc->signalQuality = signalQuality;
+                        pRxFrame = pRxFdesc->mpdu;
+                        pRxFrame->HdrLen = hdrLen;
+                        pRxFrame->bodyLen = bodyLen;
+                        memcpy(pRxFrame->header, pHdr, hdrLen);
+                        pRxFrame->body = pBody;
+                        pRxSignal->buf = buf;
+                        pRxSignal->vapId = vapId;
+                        pRxSignal->frmInfo.frmDesc = pRxFdesc;
+                        if (!RxMgtMpdu(pRxSignal)) {
+                                freeSignal(pRxSignal);
+                                freeFdesc(pRxFdesc);
+                                pdot11Obj->ReleaseBuffer(buf);
+                        }
+                        return;
+                }
+        }
+
+rx_release:
+        pdot11Obj->ReleaseBuffer(buf);
+        return;
+}
+void zd_InitWepData(void)
+{
+        mWepIv[0] = 0;
+        mWepIv[1] = 0;
+        mWepIv[2] = 0;
+        mWepIv[3] = 0;
+        mBcIv[0] = 0;
+        mBcIv[1] = 0;
+        mBcIv[2] = 0;
+        mBcIv[3] = 0;
+}
+
+void zd_Release_80211_Buffer(void)
+{
+        releaseSignalBuf();
+        releaseFdescBuf();
+}
+
+//Cmd Functions
+BOOLEAN zd_Reset80211(zd_80211Obj_t * pObj)
+
+{
+        pdot11Obj = pObj;
+
+        initSignalBuf();
+        initFdescBuf();
+        ResetPSMonitor();
+        ResetPMFilter();
+        zd_InitWepData();
+        mBssCnt=0;
+        return TRUE;
+}
+
+BOOLEAN zd_HandlePsPoll(U8 *pHdr)
+{
+        Frame_t psPollFrame;
+
+        //PSDEBUG("zd_HandlePsPoll");
+        psPollFrame.HdrLen = 16;
+        psPollFrame.bodyLen = 0;
+        memcpy(&psPollFrame.header[0], pHdr, 16);
+        RxPsPoll(&psPollFrame);
+        return TRUE;
+}
+
+BOOLEAN zd_StartAP(void)
+{
+        void *reg = pdot11Obj->reg;
+
+        HW_SetRfChannel(pdot11Obj, mRfChannel, 1, mMacMode);
+
+#if defined(AMAC)
+
+        pdot11Obj->SetReg(reg, ZD_BasicRateTbl, 0);
+#endif
+
+        HW_SetSupportedRate(pdot11Obj, (U8 *)&mBrates);
+
+#if defined(OFDM)
+
+        if(PURE_A_MODE != mMacMode)
+                HW_SetSupportedRate(pdot11Obj, (U8 *)&mExtRates);
+
+#endif
+
+        /* Set CAM_MODE to AP Mode */
+        pdot11Obj->SetReg(reg, ZD_CAM_MODE, CAM_AP);
+
+        ConfigBcnFIFO();
+        HW_EnableBeacon(pdot11Obj, mBeaconPeriod, mDtimPeriod, AP_BSS);
+        HW_RadioOnOff(pdot11Obj, mRadioOn);
+        return TRUE;
+}
+
+BOOLEAN zd_ProbeReq(void)
+{
+        Signal_t *signal;
+        //FPRINT("zd_ProbeReq");
+
+        if ((signal = allocSignal()) == NULL) {
+                return FALSE;
+        }
+        signal->vapId=0;
+        signal->id = SIG_PROBE_REQ;
+        signal->block = BLOCK_SYNCH;
+        sigEnque(pMgtQ, (signal));
+        zd_SigProcess();
+
+        return TRUE;
+}
+BOOLEAN zd_ScanReq(void)
+{
+        Signal_t *signal;
+        if ((signal = allocSignal()) == NULL) {
+                return FALSE;
+        }
+        signal->vapId=0x12; //This member is not used in zd1211, we can use it to carry additional information, 0x1234 indicates we don't want to start a scantimer after sending a Probe Request frame.
+
+        signal->id = SIG_PROBE_REQ;
+        signal->block = BLOCK_SYNCH;
+        sigEnque(pMgtQ, (signal));
+        zd_SigProcess();
+        return TRUE;
+}
+#if 0
+void zd_ScanEnd()
+{
+        void *reg=pdot11Obj->reg;
+        if (mBssType == AP_BSS)
+                pdot11Obj->SetReg(reg, ZD_Rx_Filter, AP_RX_FILTER);
+        else
+                pdot11Obj->SetReg(reg, ZD_Rx_Filter, STA_RX_FILTER);
+        if (mAssoc) {
+                //		printk("HW_SetRfChannel:%s(%d)\n",__FILE__,__LINE__);
+                HW_SetRfChannel(pdot11Obj, mRfChannel, 1,mMacMode);
+        }
+
+        mBssCnt=mBssNum;
+        pdot11Obj->ConfigFlag &= ((~ACTIVE_CHANNEL_SCAN_SET) & (~JUST_CHANNEL_SCAN));
+}
+void zd_ScanBegin(void)
+{
+        void *reg=pdot11Obj->reg;
+        mBssNum=0;
+        pdot11Obj->ConfigFlag |= (ACTIVE_CHANNEL_SCAN_SET | JUST_CHANNEL_SCAN);
+        pdot11Obj->SetReg(reg, ZD_Rx_Filter, (BIT_5|BIT_8));
+}
+void zd_CmdScanReq(u16 channel)
+{
+        if(mMacMode != PURE_A_MODE) {
+                //		printk("HW_SetRfChannel:%s(%d)\n",__FILE__,__LINE__);
+                HW_SetRfChannel(pdot11Obj, channel, 1,mMacMode);
+        } else {
+                //		printk("HW_SetRfChannel:%s(%d)\n",__FILE__,__LINE__);
+                HW_SetRfChannel(pdot11Obj,dot11A_Channel[channel-1],1 ,mMacMode);
+        }
+
+
+        zd_ScanReq();
+        return;
+
+}
+#endif
+BOOLEAN zd_CmdProbeReq(U8 bWithSSID)
+{
+        void *reg = pdot11Obj->reg;
+
+        //FPRINT("zd_CmdProbeReq");
+        if (pdot11Obj->bChScanning) {
+                FPRINT("Channel is under scanning....");
+
+                if (mRequestFlag & CHANNEL_SCAN_SET)
+                        mRequestFlag &= ~CHANNEL_SCAN_SET;
+                return FALSE;
+        }
+        pdot11Obj->bChScanning=1;
+
+        pdot11Obj->SetReg(reg, ZD_Rx_Filter, (BIT_5|BIT_8)); //only accept beacon and ProbeRsp frame
+        pdot11Obj->ConfigFlag |= ACTIVE_CHANNEL_SCAN_SET;
+
+        mBssNum = 0;
+        if(mMacMode != PURE_A_MODE) {
+                //		printk("HW_SetRfChannel:%s(%d)\n",__FILE__,__LINE__);
+                HW_SetRfChannel(pdot11Obj, CurrScanCH, 1,mMacMode);
+        } else  {
+                //		printk("HW_SetRfChannel:%s(%d)\n",__FILE__,__LINE__);
+                HW_SetRfChannel(pdot11Obj, dot11A_Channel[CurrScanCH-1], 1,mMacMode);
+        }
+
+        zd_ProbeReq();
+
+        if (mRequestFlag & CHANNEL_SCAN_SET)
+                mRequestFlag &= ~CHANNEL_SCAN_SET;
+
+        //pdot11Obj->bChScanning = 1;
+        return TRUE;
+}
+
+BOOLEAN zd_StartSTA(BOOLEAN bEnable)
+{
+        void *reg = pdot11Obj->reg;
+        //FPRINT("zd_StartSTA");
+        HW_SetSupportedRate(pdot11Obj, (U8 *)&mBrates);
+        HW_RadioOnOff(pdot11Obj, mRadioOn);
+
+
+        if (mBssType == INFRASTRUCTURE_BSS)
+                pdot11Obj->SetReg(reg, ZD_CAM_MODE, CAM_STA);
+        else
+                pdot11Obj->SetReg(reg, ZD_CAM_MODE, CAM_IBSS);
+        if (mBssType == PSEUDO_IBSS) {
+                zd_PseudoIbssConnect();
+        } else {
+                //if (!bEnable)
+                {
+                        pdot11Obj->ConfigFlag |= SCAN_AND_CONNECT_SET;
+                        mRequestFlag |= CHANNEL_SCAN_SET;
+                }
+        }
+
+        return TRUE;
+}
+
+BOOLEAN zd_CmdDisasoc(MacAddr_t *sta, U8 rCode)
+{
+        Signal_t *signal;
+        //FPRINT("zd_CmdDisasoc");
+
+        //if (isGroup(sta))
+        //	return FALSE;
+
+        if ((signal = allocSignal()) == NULL)
+                return FALSE;
+
+        signal->id = SIG_DIASSOC_REQ;
+        signal->block = BLOCK_ASOC;
+        if (mBssType == INFRASTRUCTURE_BSS) {
+                memcpy(&signal->frmInfo.Sta, (U8 *)&mBssId, 6);
+        } else {
+                memcpy(&signal->frmInfo.Sta, sta, 6);
+        }
+        signal->frmInfo.rCode = (ReasonCode)rCode;
+        sigEnque(pMgtQ, (signal));
+
+        return TRUE;
+}
+
+BOOLEAN zd_CmdDeauth(MacAddr_t *sta, U8 rCode)
+{
+        Signal_t *signal;
+
+        if ((signal = allocSignal()) == NULL)
+                return FALSE;
+
+        signal->id = SIG_DEAUTH_REQ;
+        signal->block = BLOCK_AUTH_REQ;
+        memcpy(&signal->frmInfo.Sta, sta, 6);
+        signal->frmInfo.rCode = (ReasonCode)rCode;
+        sigEnque(pMgtQ, (signal));
+
+        return TRUE;
+}
+
+BOOLEAN zd_PassiveScan(void)
+{
+        void *reg = pdot11Obj->reg;
+
+        //FPRINT("zd_PassiveScan");
+
+        if (pdot11Obj->ConfigFlag & PASSIVE_CHANNEL_SCAN_SET)
+                return FALSE;
+
+        pdot11Obj->ConfigFlag |= PASSIVE_CHANNEL_SCAN_SET;
+        pdot11Obj->SetReg(reg, ZD_Rx_Filter, 0x100); //only accept beacon frame
+        if(mMacMode != PURE_A_MODE) {
+                //		printk("HW_SetRfChannel:%s(%d)\n",__FILE__,__LINE__);
+                HW_SetRfChannel(pdot11Obj, CurrScanCH, 1,mMacMode);
+        } else {
+                //		printk("HW_SetRfChannel:%s(%d)\n",__FILE__,__LINE__);
+                HW_SetRfChannel(pdot11Obj,dot11A_Channel[CurrScanCH-1],1 ,mMacMode);
+        }
+
+        pdot11Obj->StartTimer(SCAN_TIMEOUT, DO_SCAN);
+
+        return TRUE;
+}
+
+BOOLEAN zd_DisasocAll(U8 rCode)
+{
+        int i;
+        MacAddr_t *sta;
+        if (mBssType == AP_BSS) {
+                for (i=1; i<(MAX_AID+1); i++) {
+                        if (sstByAid[i]->asoc == STATION_STATE_ASOC) {
+                                sta = (MacAddr_t *)&sstByAid[i]->mac[0];
+                                zd_CmdDisasoc(sta, rCode);
+                        }
+                }
+
+                FlushQ(pTxQ);
+        } else if (mBssType == INFRASTRUCTURE_BSS) {
+                if (mAssoc)
+                        zd_CmdDisasoc(&mBssId, rCode);
+        }
+        return TRUE;
+
+}
+
+BOOLEAN zd_ChooseAP(BOOLEAN bUseBssid)
+{
+        U8 i;
+        U16 cap;
+        U16 quality = 10000;
+        BOOLEAN found = FALSE;
+
+        mBssIndex = 0xff;
+        for (i=0; i<mBssCnt; i++) {
+                if (bUseBssid) {
+                        if (memcmp(&dot11DesiredBssid, &mBssInfo[i].bssid.mac[0], ETH_ALEN) == 0 && memcmp(&dot11DesiredBssid, zeroMacAddress, ETH_ALEN)!=0) {
+                                //ZD1211DEBUG(0, "zd_ChooseAP: Bssid" MACSTR "matched to index:%d\n",MAC2STR(dot11DesiredBssid), i);
+                                mBssIndex = i;
+                                break;
+                        }
+                }
+
+                cap = mBssInfo[i].cap;
+                if ((memcmp(&dot11DesiredSsid, &mBssInfo[i].ssid, dot11DesiredSsid.buf[1]+2) == 0)
+                                || (!mProbeWithSsid) ) {
+
+                        if(1)
+                                ;
+                        else if ((mMacMode == PURE_B_MODE) && (mBssInfo[i].apMode == PURE_G_AP))
+                                continue;
+                        else if ((mMacMode == PURE_B_MODE) && (mBssInfo[i].apMode == PURE_A_AP))
+                                continue;
+                        else if ((mMacMode == PURE_G_MODE) && (mBssInfo[i].apMode == PURE_B_AP))
+                                continue;
+                        else if ((mMacMode == PURE_G_MODE) && (mBssInfo[i].apMode == PURE_A_AP))
+                                continue;
+
+                        else if ((mMacMode == PURE_A_MODE) && (mBssInfo[i].apMode != PURE_A_AP))
+                                continue;
+
+                        else if ((mMacMode == MIXED_MODE) && (mBssInfo[i].apMode == PURE_A_AP))
+                                continue;
+
+                        //check capability ...
+                        if (cap & CAP_PRIVACY) {
+                                if (!mPrivacyInvoked)
+                                        continue;
+                        } else {
+                                if (mPrivacyInvoked)
+                                        continue;
+                        }
+                        if (!pdot11Obj->IsUSB2_0) { //host is usb 1.1
+                                if (mBssInfo[i].apMode == PURE_G_AP)
+                                        continue;
+                        }
+
+                        if (cap & CAP_ESS) {
+                                if (mBssInfo[i].signalQuality < quality ) {
+                                        quality = mBssInfo[i].signalQuality;
+                                        mBssIndex = i;
+                                        //FPRINT_V("cap", cap);
+                                }
+                        }
+
+                        //break;
+                }
+        }
+        if (mBssIndex< mBssCnt) {
+                found = TRUE;
+                //FPRINT_V("Desired AP Found, Bss Index", mBssIndex);
+                if (pdot11Obj->ConfigFlag & SCAN_AND_CONNECT_SET) {
+                        //printk("zd_ChooseAP: set mRequestFlag.BSS_CONNECT_SET\n");
+                        mRequestFlag |= BSS_CONNECT_SET;
+                        pdot11Obj->ConfigFlag &= ~SCAN_AND_CONNECT_SET;
+                }
+        } else {
+                //printk(" \n");
+                //printk(KERN_ERR "****** Can't find desiredSSID:");
+                //for (i=0; i<dot11DesiredSsid.buf[1]; i++) {
+                //	printk("%c", dot11DesiredSsid.buf[2+i]);
+                //}
+                //printk(" \n");
+        }
+        //	int j;
+        //	if(0xff != mBssIndex) {
+        //		for(j=0;j<mBssInfo[mBssIndex].ssid.buf[1];j++)
+        //			printk("%c",mBssInfo[mBssIndex].ssid.buf[2+j]);
+        //		printk("  ChooseAP(Mac=%d,Ch:%d)\n",mBssInfo[mBssIndex].apMode,mBssInfo[mBssIndex].Phpm.buf[2]);
+        //	}
+
+        return found;
+}
+BOOLEAN zd_InfraConnect(U8 index)
+{
+        Signal_t *signal;
+        struct zd1205_private *macp = (struct zd1205_private *)g_dev->priv;
+
+        MacAddr_t *pBssid;
+        Element *pSsid = NULL;
+        U32 tmpvalue;
+        BOOLEAN	bChooseAPResult;
+        void *reg = pdot11Obj->reg;
+        //FPRINT("zd_InfraConnect");
+        if (mBssNum == 0)
+                return FALSE;
+
+        if ((signal = allocSignal()) == NULL)
+                return FALSE;
+        if(mCounterMeasureState) {
+                mRequestFlag &= ~BSS_CONNECT_SET;
+                return FALSE;
+        }
+        // look up global scan result table according to desired ssid,
+        // because mBssInfo order may be different from macp->BSSInfo[].
+        /*if (mBssCnt)
+        {
+            U8	ssidLength;
+            for(i=0; i<mBssCnt; i++)
+            {
+                ssidLength=dot11DesiredSsid.buf[1]+2;
+        	if (mBssInfo[i].cap & CAP_ESS)
+        	{
+        	    if (memcmp((U8*)&dot11DesiredSsid,(U8*)&mBssInfo[i].ssid,ssidLength)==0)
+        	    {
+        		break;
+        	    }
+        	}
+            }		
+        } */
+        // Use zd_ChooseAP instead of above code
+        bChooseAPResult=zd_ChooseAP(0);
+        if (!bChooseAPResult || 1) {// dot11DesiredSsid can't be found in table mBssInfo[]
+                if ((index+1) <= mBssCnt) {
+                        //printk(KERN_ERR "Desired SSID can't be found in current table\n");
+                        mBssIndex=index; // Can't found in the latest scan result table, use the old index.
+                } else {
+                        return FALSE; // The index exceed mBssInfo[].
+                }
+        } else {
+                //printk(KERN_ERR "Desired SSID found in location %d\n",mBssIndex);
+        }
+        //Disable IBSS mode
+        tmpvalue = pdot11Obj->GetReg(reg, ZD_BCNInterval);
+        tmpvalue &= ~BIT_25;
+        pdot11Obj->SetReg(reg, ZD_BCNInterval, tmpvalue);
+        mCap |= BIT_0;
+        mCap &= ~BIT_1;
+
+        // For IBSS Connect
+        if (mBssInfo[index].cap & CAP_IBSS) {
+        }
+        //mBssIndex = index;
+        //update beacon interval
+        HW_UpdateBcnInterval(pdot11Obj, mBssInfo[mBssIndex].bcnInterval);
+
+        pSsid = &mBssInfo[mBssIndex].ssid;
+        memcpy((U8 *)&mSsid, (U8 *)pSsid, pSsid->buf[1]+2);
+        pBssid = &mBssInfo[mBssIndex].bssid;
+        memcpy((U8 *)&mBssId, (U8 *)pBssid, 6);
+
+        //update Bssid
+        pdot11Obj->SetReg(reg, ZD_BSSID_P1, cpu_to_le32(*(U32 *)&mBssId.mac[0]));
+        pdot11Obj->SetReg(reg, ZD_BSSID_P2, cpu_to_le32(*(U32 *)&mBssId.mac[4]));
+        // Update channel number contained in the DS Parameter Set element of the received probe response or beacon frame.
+        mRfChannel = mBssInfo[mBssIndex].Phpm.buf[2];
+
+        if(PURE_A_AP == mBssInfo[mBssIndex].apMode) {
+                ChangeMacMode(PURE_A_MODE,mRfChannel);
+                zd_UpdateCardSetting(&(macp->cardSetting));
+                pdot11Obj->DelayUs(1000);
+                HW_SetRfChannel(pdot11Obj, mRfChannel, 1, PURE_A_MODE);
+
+        } else {
+                if(PURE_A_MODE == mMacMode)
+                        mMacMode = MIXED_MODE;
+                ChangeMacMode(mMacMode,mRfChannel);
+                zd_UpdateCardSetting(&(macp->cardSetting));
+                pdot11Obj->DelayUs(1000);
+                HW_SetRfChannel(pdot11Obj, mRfChannel, 1, MIXED_MODE);
+        }
+
+        signal->id = SIG_AUTH_REQ;
+        signal->block = BLOCK_AUTH_REQ;
+        memcpy(&signal->frmInfo.Sta, (U8 *)&mBssId, 6);
+        sigEnque(pMgtQ, (signal));
+
+        if (mRequestFlag & CONNECT_TOUT_SET)
+                mRequestFlag &= ~CONNECT_TOUT_SET;
+        if (mRequestFlag & BSS_CONNECT_SET)
+                mRequestFlag &= ~BSS_CONNECT_SET;
+
+        return TRUE;
+}
+
+BOOLEAN zd_IbssConnect(void)
+{
+        struct zd1205_private *macp=g_dev->priv;
+        int i;
+        U8 Length;
+        BOOLEAN bBSSFound = FALSE;
+        MacAddr_t *pBssid;
+        BssInfo_t *pBssInfo;
+        void *reg = pdot11Obj->reg;
+        U32 tmpvalue;
+        //FPRINT("zd_IbssConnect");
+#if defined(OFDM)
+
+        pdot11Obj->SetReg(reg, ZD_CWmin_CWmax, CW_NORMAL_SLOT);
+        // not to use short slot time
+        mCap &= ~BIT_10;
+        pdot11Obj->ConfigFlag &= ~SHORT_SLOT_TIME_SET;
+
+        if (mMacMode == PURE_G_MODE) {
+                // not use protection mechanism
+                pdot11Obj->ConfigFlag &= ~ENABLE_PROTECTION_SET;
+        } else if(mMacMode != PURE_A_MODE) {
+                // force use protection mechanism
+                pdot11Obj->ConfigFlag |= ENABLE_PROTECTION_SET;
+        }
+
+#endif
+
+
+        // Recover the EIFS to 0x200.
+        // We need not use SleepResetDevice. In IBSS mode, we can easily
+        // get others traffic. (not less of Rx-Frame)
+        pdot11Obj->SetReg(reg, ZD_IFS_Value, 0x5200032);
+        if (mATIMWindow != 0) {
+                // Do not set macp->PwrState = PSM, otherwise
+                // throughput with Cirrus card (in PS mode) will down.
+                //macp->PwrState = PSM;
+                // PwrMgt = 1
+                tmpvalue = pdot11Obj->GetReg(reg, ZD_BCNInterval);
+                tmpvalue |= BIT_26;
+                pdot11Obj->SetReg(reg, ZD_BCNInterval, tmpvalue);
+        } else {
+                //macp->PwrState = CAM;
+                // PwrMgt = 0;
+                tmpvalue = pdot11Obj->GetReg(reg, ZD_BCNInterval);
+                tmpvalue &= ~BIT_26;
+                pdot11Obj->SetReg(reg, ZD_BCNInterval, tmpvalue);
+        }
+
+
+        mCap &= ~BIT_0;
+        mCap |= BIT_1;
+
+        if (mBssCnt) {	// IBSS found
+                for (i=0; i<mBssCnt; i++) {
+                        Length = dot11DesiredSsid.buf[1]+2;
+                        if (mBssInfo[i].cap & CAP_IBSS) {
+                                if (memcmp((U8 *)&dot11DesiredSsid, (U8 *)&mBssInfo[i].ssid, Length) == 0) {
+                                        break;
+                                }
+                        }
+                }
+                if (i < mBssCnt) {
+                        bBSSFound = TRUE;
+                        mBssIndex = i;
+
+                        //FPRINT("IBSS found, joint it !!!");
+                        //FPRINT_V("mBssIndex", mBssIndex);
+                        if (mMacMode==PURE_B_MODE) {
+                                if ((mBssInfo[i].cap & CAP_SHORT_PREAMBLE)==0)
+                                        mCap &= ~CAP_SHORT_PREAMBLE;
+                        }
+                        pBssInfo = &mBssInfo[mBssIndex];
+                        // Update channel number contained in the DS Parameter Set element of the received probe response or beacon frame.
+                        macp->cardSetting.Channel = mRfChannel = pBssInfo->Phpm.buf[2];
+                        mPhpm.buf[2]=mRfChannel;
+                        if(PURE_A_AP == mBssInfo[mBssIndex].apMode) {
+                                ChangeMacMode(PURE_A_MODE, mRfChannel);
+                                HW_SetRfChannel(pdot11Obj, mRfChannel, 1, PURE_A_MODE);
+
+                        } else {
+                                ChangeMacMode(MIXED_MODE,mRfChannel);
+                                HW_SetRfChannel(pdot11Obj, mRfChannel, 1, MIXED_MODE);
+                        }
+
+
+                        //FPRINT_V("mRfChannel", mRfChannel);
+
+                        pBssid = &pBssInfo->bssid;
+                        memcpy((U8 *)&mBssId, (U8 *)pBssid, 6);
+                        //zd1205_dump_data("mBssId = ", (U8 *)&mBssId, 6);
+
+                        //update Bssid
+                        pdot11Obj->SetReg(reg, ZD_BSSID_P1, cpu_to_le32(*(U32 *)&mBssId.mac[0]));
+                        pdot11Obj->SetReg(reg, ZD_BSSID_P2, cpu_to_le32(*(U32 *)&mBssId.mac[4]));
+
+                        //update beacon interval
+                        mBeaconPeriod = pBssInfo->bcnInterval;
+                        HW_UpdateBcnInterval(pdot11Obj, mBeaconPeriod);
+                        //FPRINT_V("mBeaconPeriod", mBeaconPeriod);
+
+                        //update supported rated
+                        memcpy((U8 *)&mBrates, (U8 *)&pBssInfo->supRates, pBssInfo->supRates.buf[1]+2);
+                        HW_SetSupportedRate(pdot11Obj, (U8 *)&mBrates);
+                        //zd1205_dump_data("mBrates = ", (U8 *)&mBrates, mBrates.buf[1]+2);
+#if defined(OFDM)
+
+                        if (mMacMode != PURE_B_MODE && mMacMode != PURE_A_MODE) {
+                                if (pBssInfo->extRates.buf[0] == EID_EXT_RATES) {
+                                        memcpy((U8 *)&mExtRates, (U8 *)&pBssInfo->extRates, pBssInfo->extRates.buf[1]+2);
+                                        HW_SetSupportedRate(pdot11Obj, (U8 *)&mExtRates);
+                                        //zd1205_dump_data("mExtRates = ", (U8 *)&mExtRates, mExtRates.buf[1]+2);
+                                }
+                        }
+#endif
+                        //update ATIM Window
+                        mATIMWindow = pBssInfo->IbssParms.buf[2] + (((U16)pBssInfo->IbssParms.buf[3]) << 8);
+                        memcpy((U8 *)&mIbssParms, (U8 *)&pBssInfo->IbssParms, pBssInfo->IbssParms.buf[1]+2);
+                        HW_UpdateATIMWindow(pdot11Obj, mATIMWindow);
+                        //FPRINT_V("mATIMWindow", mATIMWindow);
+
+                        ConfigBcnFIFO();
+                        HW_EnableBeacon(pdot11Obj, mBeaconPeriod, 0, INDEPENDENT_BSS);
+                        HW_RadioOnOff(pdot11Obj, mRadioOn);
+                        mRequestFlag &= ~IBSS_CONNECT_SET;
+                        //Modified for Continuous Reconnect to an existing IBSS
+                        //When use a existing IBSS SSID
+                        mRequestFlag &= ~CHANNEL_SCAN_SET;
+
+
+                        mAssoc = TRUE;
+                        memcpy(&pdot11Obj->CurrSsid[0], (U8 *)&mSsid, mSsid.buf[1]+2);
+                        pdot11Obj->StatusNotify(STA_ASSOCIATED, (U8 *)&mBssId);
+                        return TRUE;
+                }
+        } else {
+                if (!(pdot11Obj->ConfigFlag & IBSS_CHANNEL_SCAN_SET)) {
+                        pdot11Obj->ConfigFlag |= IBSS_CHANNEL_SCAN_SET;
+                        zd_CmdProbeReq(1);
+                }
+                return FALSE;
+        }
+
+        if (!bBSSFound) {
+                //FPRINT("IBSS not found, create it !!!");
+                /****************************************************/
+                /* We generate an IBSS								*/
+                /****************************************************/
+                U32 seed = pdot11Obj->GetReg(reg, ZD_TSF_LowPart);
+                mBssIndex = 0xff;
+                //generate random BSSID
+                mBssId.mac[0] = (U8)((pdot11Obj->Rand(seed) & ~0x3) | 0x2); // I/G = 0, U/L = 1
+                mBssId.mac[1] = (U8)pdot11Obj->Rand(seed);
+                mBssId.mac[2] = (U8)pdot11Obj->Rand(seed);
+                mBssId.mac[3] = (U8)pdot11Obj->Rand(seed);
+                mBssId.mac[4] = (U8)pdot11Obj->Rand(seed);
+                mBssId.mac[5] = (U8)pdot11Obj->Rand(seed);
+                //zd1205_dump_data("mBssId = ", (U8 *)&mBssId, 6);
+                //update Bssid
+                pdot11Obj->SetReg(reg, ZD_BSSID_P1, cpu_to_le32(*(U32 *)&mBssId.mac[0]));
+                pdot11Obj->SetReg(reg, ZD_BSSID_P2, cpu_to_le32(*(U32 *)&mBssId.mac[4]));
+                HW_SetRfChannel(pdot11Obj, mRfChannel, 1, mMacMode);
+                //FPRINT_V("mRfChannel", mRfChannel);
+
+                //update beacon interval
+                HW_UpdateBcnInterval(pdot11Obj, mBeaconPeriod);
+                //FPRINT_V("mBeaconPeriod", mBeaconPeriod);
+
+                //update supported rated
+                HW_SetSupportedRate(pdot11Obj, (U8 *)&mBrates);
+                //zd1205_dump_data("mBrates = ", (U8 *)&mBrates, mBrates.buf[1]+2);
+#if defined(OFDM)
+
+                if(mMacMode != PURE_A_MODE && mMacMode != PURE_B_MODE)
+                        if (pdot11Obj->IsUSB2_0)
+                                HW_SetSupportedRate(pdot11Obj, (U8 *)&mExtRates);
+
+                //zd1205_dump_data("mExtRates = ", (U8 *)&mExtRates, mExtRates.buf[1]+2);
+#endif
+                //update ATIM Window
+                HW_UpdateATIMWindow(pdot11Obj, mATIMWindow);
+                //FPRINT_V("mATIMWindow", mATIMWindow);
+
+                ConfigBcnFIFO();
+                HW_EnableBeacon(pdot11Obj, mBeaconPeriod, 0, INDEPENDENT_BSS);
+                HW_RadioOnOff(pdot11Obj, mRadioOn);
+                mRequestFlag &= ~IBSS_CONNECT_SET;
+                mAssoc = TRUE;
+                memcpy(&pdot11Obj->CurrSsid[0], (U8 *)&mSsid, mSsid.buf[1]+2);
+                pdot11Obj->StatusNotify(STA_ASSOCIATED, (U8 *)&mBssId);
+                return TRUE;
+        }
+        return FALSE;
+}
+
+void zd_ResetDevice(void)
+{
+        U16	BeaconInterval = 0x2;
+        U32	tmpvalue;
+        void *reg = pdot11Obj->reg;
+        // Device will reset after 1ms
+        HW_UpdateBcnInterval(pdot11Obj, BeaconInterval);
+        pdot11Obj->SetReg(reg, ZD_Pre_TBTT, 0x1);
+        //++ Ensure the following is an atomic operation.
+#ifndef HOST_IF_USB
+
+        i_state = pdot11Obj->EnterCS();
+#endif
+
+        tmpvalue = pdot11Obj->GetReg(reg, ZD_PS_Ctrl);
+        pdot11Obj->SetReg(reg, ZD_PS_Ctrl, (tmpvalue | BIT_0));
+        pdot11Obj->bDeviceInSleep = 1;
+
+#ifndef HOST_IF_USB
+
+        pdot11Obj->ExitCS(i_state);
+        // Delay 1ms to ensure device had been reset
+        pdot11Obj->DelayUs(1000);
+#endif
+
+}
+
+BOOLEAN zd_PseudoIbssConnect(void)
+{
+        void *reg = pdot11Obj->reg;
+        U8 IBSS_BSSID[6];
+        memset(IBSS_BSSID, 0, 6);
+        //++
+        // Set EIFS=0x32 to prevent chamber low Tx-throughput (sometimes)
+        // problem. In chamber environment, almost no Rx-frame, once
+        // we detect a CRC16/CRC32 error frame, we adopt EIFS, because of
+        // less of RX-frame, it's less posibility to change EIFS to DIFS
+        // by FA (Frame Analyzer), and therefore damage the Tx-Throughput.
+        // We must use SleepResetDevice to trigger FA to adpot 0x32.
+        pdot11Obj->SetReg(reg, ZD_IFS_Value, 0x5032032);
+        zd_ResetDevice();
+
+        //update Bssid
+        pdot11Obj->SetReg(reg, ZD_BSSID_P1, cpu_to_le32(*(U32 *)&IBSS_BSSID[0]));
+        pdot11Obj->SetReg(reg, ZD_BSSID_P2, cpu_to_le32(*(U32 *)&IBSS_BSSID[4]));
+        HW_SetRfChannel(pdot11Obj, mRfChannel, 1, mMacMode);
+        mAssoc = TRUE;
+        pdot11Obj->StatusNotify(STA_ASSOCIATED, (U8 *)IBSS_BSSID);
+
+        return TRUE;
+}
+
+
+
+BOOLEAN zd_CmdConnect(U8 index, U8 bssType)
+{
+        if (bssType == INFRASTRUCTURE_BSS) {
+                //printk(KERN_ERR "Build Infra-Type BSS\n");
+                return zd_InfraConnect(index-1);
+        } else if (bssType==INDEPENDENT_BSS) {
+                //printk(KERN_ERR "Build IBSS\n");
+                return zd_IbssConnect();
+        } else if (bssType == PSEUDO_IBSS)
+                return zd_PseudoIbssConnect();
+
+
+        return TRUE;
+}
+
+BOOLEAN zd_CmdDisConnect(void)
+{
+        mAssoc = FALSE;
+        mRequestFlag |= DIS_CONNECT_SET;
+
+        return TRUE;
+}
+
+
+BOOLEAN zd_CmdRoaming(void)
+{
+        if ((mRequestFlag & ROAMING_SET) || pdot11Obj->bChScanning || (pdot11Obj->ConfigFlag & SCAN_AND_CONNECT_SET))
+                return FALSE;
+
+
+        mAssoc = FALSE;
+        mRequestFlag |= ROAMING_SET;
+
+        return TRUE;
+}
+
+
+BOOLEAN zd_CmdFlushQ(void)
+{
+        if (pdot11Obj->QueueFlag & TX_QUEUE_SET) {
+                FlushQ(pTxQ);
+        } else if (pdot11Obj->QueueFlag & MGT_QUEUE_SET) {
+                FlushQ(pMgtQ);
+        } else if (pdot11Obj->QueueFlag & AWAKE_QUEUE_SET) {
+                FlushQ(pAwakeQ);
+        }
+
+        return TRUE;
+}
+
+BOOLEAN zd_CmdProcess(U16 CmdId, void *parm1, U32 parm2)
+{
+        BOOLEAN status = TRUE;
+
+        switch(CmdId) {
+        case CMD_RESET_80211:
+                status = zd_Reset80211((zd_80211Obj_t *)parm1);
+                break;
+
+        case CMD_ENABLE:
+                if (mBssType == AP_BSS)
+                        status = zd_StartAP();
+                else {
+                        if ((pdot11Obj->ConfigFlag & SCAN_AND_CONNECT_SET)||(mRequestFlag & CHANNEL_SCAN_SET)) {
+                                //    printk("Scan and connect is underGoing\n");
+                                break;
+                        } else if (!mIfaceOpened) {
+                                status = zd_StartSTA(1);
+                                mIfaceOpened = TRUE;
+                        } else {
+                                pdot11Obj->ConfigFlag |= SCAN_AND_CONNECT_SET;
+                                zd_ChooseAP(0);
+                        }
+                }
+
+                break;
+
+        case CMD_DISASOC: //IAPP cth
+                status = zd_CmdDisasoc((MacAddr_t*)parm1, (U8)parm2);
+                break;
+
+        case CMD_DEAUTH://MAC filter cth
+                status = zd_CmdDeauth((MacAddr_t*)parm1, (U8)parm2);
+                break;
+
+        case CMD_PS_POLL:
+                //PSDEBUG("CMD_PS_POLL");
+                status = zd_HandlePsPoll((U8 *)parm1);
+                break;
+
+        case CMD_PASSIVE_SCAN:
+                status = zd_PassiveScan();
+                break;
+
+        case CMD_DISASOC_ALL:
+                status = zd_DisasocAll((U8)parm2);
+                break;
+
+        case CMD_CONNECT: {
+                        U8 *pBsstype=(U8*)parm1;
+                        status = zd_CmdConnect((U8)parm2,*pBsstype);
+                }
+                break;
+
+        case CMD_PROBE_REQ:
+                //FPRINT("CMD_PROBE_REQ");
+                status = zd_CmdProbeReq((U8)parm2);
+                pdot11Obj->ConfigFlag |= JUST_CHANNEL_SCAN;
+                break;
+
+        case CMD_DIS_CONNECT:
+                status = zd_CmdDisConnect();
+                break;
+
+        case CMD_FLUSH_QUEUE:
+                status = zd_CmdFlushQ();
+                break;
+
+        case CMD_ROAMING:
+                status = zd_CmdRoaming();
+                break;
+
+        default:
+                status = FALSE;
+                break;
+        }
+
+        return status;
+}
+
+//Event Nofify Functions
+void zd_NextBcn(void)
+{
+        if (mBssType == AP_BSS) {
+                if (mDtimCount == 0)
+                        mDtimCount = mDtimPeriod;
+                mDtimCount--;
+        }
+
+        ConfigBcnFIFO();
+
+        if (pTxQ->cnt)
+                pdot11Obj->QueueFlag |= TX_QUEUE_SET;
+        return;
+}
+
+void zd_DtimNotify(void)
+{
+        SendMcPkt();
+        return;
+}
+
+extern BOOLEAN Tchal_WaitChalRsp(Signal_t *signal);
+void zd_SendTChalMsg(void)
+{
+        Tchal_WaitChalRsp(NULL);
+        return;
+}
+
+extern BOOLEAN AuthTimeOut(Signal_t *signal);
+void zd_SendTAuthMsg(void)
+{
+        AuthTimeOut(NULL);
+        return;
+}
+
+extern BOOLEAN AsocTimeOut(Signal_t *signal);
+void zd_SendTAsocMsg(void)
+{
+        AsocTimeOut(NULL);
+        return;
+}
+
+
+void zd_SwitchNextCH(void)
+{
+        void *reg = pdot11Obj->reg;
+        static u8 LastScanMacMode;
+        static u8 ScanAround = 0;
+        //static u8 ScanWait = 0;
+        static u8 initMAC_Mode = 0xff;
+
+        if(initMAC_Mode == 0xff)
+                initMAC_Mode = mMacMode;
+        //FPRINT("zd_SwitchNextCH");
+
+        if ((PURE_A_MODE != mMacMode && CurrScanCH > MAX_CHANNEL_ALLOW) ||
+                        (PURE_A_MODE == mMacMode && CurrScanCH > dot11A_Channel_Amount - 1)
+                        //In 11a, channel array index 0 is also meaningful.
+           ) { //Scan Finish...
+#ifdef HMAC_DEBUG
+                U8 i, j;
+                U16 cap;
+#endif
+
+                if (mBssType == AP_BSS)
+                        pdot11Obj->SetReg(reg, ZD_Rx_Filter, AP_RX_FILTER);
+                else
+                        pdot11Obj->SetReg(reg, ZD_Rx_Filter, STA_RX_FILTER);
+
+                if (pdot11Obj->ConfigFlag & PASSIVE_CHANNEL_SCAN_SET)
+                        pdot11Obj->ConfigFlag &= ~PASSIVE_CHANNEL_SCAN_SET;
+
+                if (pdot11Obj->ConfigFlag & IBSS_CHANNEL_SCAN_SET) {
+                        pdot11Obj->ConfigFlag &= ~IBSS_CHANNEL_SCAN_SET;
+                        //mRequestFlag |= IBSS_CONNECT_SET;
+                }
+
+                CurrScanCH = 1;
+                pdot11Obj->bChScanning = 0;
+                ScanAround=0;
+
+                if (pdot11Obj->ConfigFlag & ACTIVE_CHANNEL_SCAN_SET) {
+#ifdef HMAC_DEBUG
+                        printk("\nSSID          BSSID            CH  Signal  Mode     Basic-Rates  Ext-Rates    b/g AP");
+                        printk("\n------------------------------------------------------------------------------------");
+                        for (i=0; i<mBssNum; i++) {
+                                printk("\n");
+                                for (j=0; j<mBssInfo[i].ssid.buf[1]; j++) {
+                                        printk("%c", mBssInfo[i].ssid.buf[2+j]);
+                                }
+
+                                for (j=mBssInfo[i].ssid.buf[1]; j<12; j++) {
+                                        printk(" ");
+                                }
+
+                                printk("%02x:%02x:%02x:%02x:%02x:%02x",
+                                       mBssInfo[i].bssid.mac[0], mBssInfo[i].bssid.mac[1], mBssInfo[i].bssid.mac[2],
+                                       mBssInfo[i].bssid.mac[3], mBssInfo[i].bssid.mac[4], mBssInfo[i].bssid.mac[5]);
+
+                                printk("  %2d", mBssInfo[i].Phpm.buf[2]);
+                                printk("   %2d", mBssInfo[i].signalStrength);
+
+                                cap = mBssInfo[i].cap;
+                                cap &= (CAP_PRIVACY | CAP_IBSS | CAP_ESS);
+
+                                switch(cap) {
+                                case 0x01:
+                                        printk("   Infra   ");
+                                        break;
+                                case 0x02:
+                                        printk("   Ad_Hoc  ");
+                                        break;
+                                case 0x11:
+                                        printk("   Infra, W");
+                                        break;
+                                case 0x12:
+                                        printk("   Ad_Hoc,W");
+                                        break;
+                                default :
+                                        break;
+                                }
+
+                                printk("  ");
+
+                                for (j=0; j<mBssInfo[i].supRates.buf[1]; j++) {
+                                        printk(" %x", mBssInfo[i].supRates.buf[2+j]);
+                                }
+
+                                printk("  ");
+                                for (j=0; j<mBssInfo[i].extRates.buf[1]; j++) {
+                                        printk(" %x", mBssInfo[i].extRates.buf[2+j]);
+                                }
+
+                                if (mBssInfo[i].apMode == PURE_B_AP)
+                                        printk("   B-AP");
+                                else if (mBssInfo[i].apMode == PURE_G_AP)
+                                        printk("   G-AP");
+                                else if  (mBssInfo[i].apMode == MIXED_AP)
+                                        printk("   M-AP");
+                        }
+                        else if (mBssInfo[i].apMode == PURE_A_AP)
+                                printk("   A_AP");
+                        else
+                                VerAssert();
+
+
+                        printk("\n");
+
+                        FPRINT("****** Scan Finished ******");
+#endif
+
+                        pdot11Obj->ConfigFlag &= ~ACTIVE_CHANNEL_SCAN_SET;
+                        mBssCnt = mBssNum;
+                }//End of ACTIVE_CHANNEL_SCAN_SET
+
+                if (pdot11Obj->ConfigFlag & JUST_CHANNEL_SCAN) {
+                        pdot11Obj->ConfigFlag &= ~JUST_CHANNEL_SCAN;
+
+                        if (mAssoc)
+                                HW_SetRfChannel(pdot11Obj, mRfChannel, 1, initMAC_Mode);
+                } else {
+                        if (mBssType == INFRASTRUCTURE_BSS)
+                                zd_ChooseAP(0);
+                        else if (mBssType == INDEPENDENT_BSS)
+                                zd_IbssConnect();
+                }
+
+                if (pdot11Obj->ConfigFlag & SCAN_AND_CONNECT_SET) {
+                        pdot11Obj->ConfigFlag &= ~SCAN_AND_CONNECT_SET;
+                }
+                initMAC_Mode = 0xff;
+                return;
+        }//End of (CurrentScannedChannel > MAX_CHANNEL_ALLOW)
+
+        CurrScanCH++;
+        if(mMacMode != PURE_A_MODE && CurrScanCH <= MAX_CHANNEL_ALLOW + 1) {
+                //printk("HW_SetRfChannel:%s(%d)\n",__FILE__,__LINE__);
+                HW_SetRfChannel(pdot11Obj, CurrScanCH, 1,mMacMode);
+                LastScanMacMode = mMacMode;
+        } else if(mMacMode == PURE_A_MODE && CurrScanCH<=dot11A_Channel_Amount) {
+                //printk("HW_SetRfChannel:%s(%d)\n",__FILE__,__LINE__);
+                HW_SetRfChannel(pdot11Obj, dot11A_Channel[CurrScanCH-1],1, mMacMode);
+                LastScanMacMode = mMacMode;
+        }
+        if(PURE_A_MODE != LastScanMacMode && CurrScanCH > MAX_CHANNEL_ALLOW && ScanAround <1) {
+                if(pdot11Obj->rfMode == AL7230B_RF) {
+                        mMacMode = PURE_A_MODE;
+                        CurrScanCH = 1;
+                        ChangeMacMode(PURE_A_MODE,dot11A_Channel[CurrScanCH-1]);
+                        pdot11Obj->DelayUs(1000);
+                        HW_SetRfChannel(pdot11Obj, dot11A_Channel[CurrScanCH-1],0,mMacMode);
+                        ScanAround ++;
+                }
+
+
+        } else if(ScanAround < 1 &&PURE_A_MODE == LastScanMacMode && CurrScanCH > dot11A_Channel_Amount - 1) {
+                ScanAround ++;
+                CurrScanCH = 1;
+                mMacMode = MIXED_MODE;
+                ChangeMacMode(MIXED_MODE, CurrScanCH);
+                pdot11Obj->DelayUs(1000);
+                HW_SetRfChannel(pdot11Obj, CurrScanCH, 0,mMacMode);
+        }
+
+
+        //for debug
+        //pdot11Obj->SetReg(reg, ZD_USB_DEBUG_PORT, 0x22222222);
+
+        if  (pdot11Obj->ConfigFlag & PASSIVE_CHANNEL_SCAN_SET)
+                pdot11Obj->StartTimer(SCAN_TIMEOUT, DO_SCAN);
+
+        if (pdot11Obj->ConfigFlag & ACTIVE_CHANNEL_SCAN_SET)
+                zd_ProbeReq();
+
+        return;
+}
+
+void zd_UpdateCurrTxRate(U8 rate, U16 aid)
+{
+        Hash_t *pHash;
+        if (mBssType == INFRASTRUCTURE_BSS) {
+                pHash = sstByAid[0];
+                pHash->CurrTxRate = rate;
+        } else {
+                if (aid) {
+                        pHash = sstByAid[aid];
+#if !defined(OFDM)
+
+                        pHash->CurrTxRate = rate;
+#else
+
+                        if (rate < pHash->CurrTxRate) { //Retry Failed happened
+                                pHash->FailedFrames++;
+                                //FPRINT_V("FailedFrames", pHash->FailedFrames);
+                        }
+#endif
+
+                }
+        }
+}
+
+void zd_EnableProtection(U8 protect)
+{
+        U32 tmpValue;
+        void *reg = pdot11Obj->reg;
+
+        if (protect) {
+                //FPRINT("zd_EnableProtection");
+                pdot11Obj->ConfigFlag |= ENABLE_PROTECTION_SET;
+                mErp.buf[2] |= USE_PROTECTION;
+                tmpValue = pdot11Obj->GetReg(reg, ZD_RTS_CTS_Rate);
+                tmpValue &= ~CTS_MOD_TYPE_OFDM;
+                tmpValue |= CTS_RATE_11M;
+                pdot11Obj->SetReg(reg, ZD_RTS_CTS_Rate, tmpValue);
+        } else {
+                //FPRINT("zd_DisableProtection");
+                pdot11Obj->ConfigFlag &= ~ENABLE_PROTECTION_SET;
+                mErp.buf[2] &= ~USE_PROTECTION;
+
+                //pdot11Obj->ConfigFlag &= ~SHORT_SLOT_TIME_SET;
+                mCap |= CAP_SHORT_SLOT_TIME;
+                pdot11Obj->SetReg(reg, ZD_CWmin_CWmax, CW_SHORT_SLOT);
+        }
+}
+
+void zd_EnableBarker(U8 barker)
+{
+        void *reg = pdot11Obj->reg;
+        if (barker) {
+                //FPRINT("zd_EnableBarker");
+                pdot11Obj->ConfigFlag |= BARKER_PREAMBLE_SET;
+                mErp.buf[2] |= BARKER_PREAMBLE;
+                pdot11Obj->SetReg(reg, ZD_RTS_CTS_Rate, 0x30000);
+        } else {
+                //FPRINT("zd_DisableBarker");
+                pdot11Obj->ConfigFlag &= ~BARKER_PREAMBLE_SET;
+                mErp.buf[2] &= ~BARKER_PREAMBLE;
+                pdot11Obj->SetReg(reg, ZD_RTS_CTS_Rate, 0x30000);
+
+        }
+        if(PURE_A_MODE == mMacMode) //Use Slowest rate when CTS/RTS,MZCai
+                pdot11Obj->SetReg(reg, ZD_RTS_CTS_Rate,0x01090109);
+        else
+                pdot11Obj->SetReg(reg, ZD_RTS_CTS_Rate, 0x30000);
+
+}
+
+void zd_EnableShortSlot(U8 slot)
+{
+        void *reg = pdot11Obj->reg;
+        if (slot) {
+                //FPRINT("zd_EnableShortSlot");
+                pdot11Obj->ConfigFlag |= SHORT_SLOT_TIME_SET;
+                pdot11Obj->SetReg(reg, ZD_IFS_Value, 0x547c00a);
+                pdot11Obj->SetReg(reg, ZD_CWmin_CWmax, CW_NORMAL_SLOT);
+        } else {
+                //FPRINT("zd_DisableShortSlot");
+                pdot11Obj->ConfigFlag &= ~SHORT_SLOT_TIME_SET;
+                pdot11Obj->SetReg(reg, ZD_IFS_Value, 0x547c032);
+                pdot11Obj->SetReg(reg, ZD_CWmin_CWmax, CW_LONG_SLOT);
+        }
+}
+
+void zd_PsChange(U8 PwrState)
+{
+        //FPRINT("zd_PsChange");
+
+        mPwrState = PwrState;
+        mRequestFlag |= PS_CHANGE_SET;
+        return;
+}
+
+void zd_EventNotify(U16 EventId, U32 parm1, U32 parm2, U32 parm3)
+{
+        //struct zd1205_private *macp = g_dev->priv;
+
+
+        switch(EventId) {
+        case EVENT_TBCN:
+                zd_NextBcn();
+                break;
+
+        case EVENT_DTIM_NOTIFY:
+                zd_DtimNotify();
+                break;
+
+        case EVENT_TX_COMPLETE:
+                TxCompleted(parm1, (U8)parm2, (U16)parm3);
+                break;
+
+        case EVENT_TCHAL_TIMEOUT:
+                zd_SendTChalMsg();
+                break;
+
+        case EVENT_SCAN_TIMEOUT:
+                zd_SwitchNextCH();
+                break;
+
+        case EVENT_UPDATE_TX_RATE:
+                zd_UpdateCurrTxRate((U8)parm1, (U16)parm2);
+                break;
+
+        case EVENT_SW_RESET:
+                //zd_SwReset();
+                break;
+
+        case EVENT_BUF_RELEASE:
+                zd_Release_80211_Buffer();
+                break;
+
+        case EVENT_AUTH_TIMEOUT:
+                zd_SendTAuthMsg();
+                break;
+
+        case EVENT_ASOC_TIMEOUT:
+                zd_SendTAsocMsg();
+                break;
+
+        case EVENT_PS_CHANGE:
+                zd_PsChange((U8)parm1);
+                break;
+
+        case EVENT_MORE_DATA:
+                mRequestFlag |= PS_POLL_SET;
+                break;
+
+        case EVENT_ENABLE_PROTECTION:
+                zd_EnableProtection((U8)parm1);
+                break;
+
+        case EVENT_ENABLE_BARKER:
+                zd_EnableBarker((U8)parm1);
+                break;
+
+        case EVENT_SHORT_SLOT:
+                zd_EnableShortSlot((U8)parm1);
+                break;
+
+        default:
+                break;
+        }
+
+        return;
+}
+
+BOOLEAN zd_CleanupTxQ(void)
+{
+        //FPRINT("*****zd_CleanupTxQ*****");
+        while(CleanupTxQ())
+                ;
+
+        if (!pTxQ->cnt) {
+                pdot11Obj->QueueFlag &= ~TX_QUEUE_SET;
+                return TRUE;
+        } else
+                return FALSE;
+}
+
+BOOLEAN zd_CleanupAwakeQ(void)
+{
+        //PSDEBUG("*****zd_CleanupAwakeQ*****");
+        while(CleanupAwakeQ())
+                ;
+
+        if (!pAwakeQ->cnt) {
+                pdot11Obj->QueueFlag &= ~AWAKE_QUEUE_SET;
+                return TRUE;
+        } else {
+#if 0
+                Signal_t *signal;
+                FrmInfo_t *pfrmInfo;
+                FrmDesc_t *pfrmDesc;
+
+                while(pAwakeQ->cnt) {
+                        signal = sigDeque(pAwakeQ);
+                        pfrmInfo = &signal->frmInfo;
+                        pfrmDesc = pfrmInfo->frmDesc;
+                        freeFdesc(pfrmDesc);
+                        pdot11Obj->ReleaseBuffer(signal->buf);
+                        freeSignal(signal);
+                }
+#endif
+                return FALSE;
+        }
+}
+
+void zd_ShowQInfo(void)
+{
+        printk(KERN_DEBUG "AwakeQ = %x, MgtQ = %x, TxQ  = %x, mcQ  = %x\n",
+               pAwakeQ->cnt, pMgtQ->cnt, pTxQ->cnt, pPsQ[0]->cnt);
+        printk(KERN_DEBUG "PsQ1   = %x, PsQ2 = %x, PsQ3 = %x, PsQ4 = %x\n",
+               pPsQ[1]->cnt, pPsQ[2]->cnt, pPsQ[3]->cnt, pPsQ[4]->cnt);
+}
+
+extern U8 AuthReqState;
+extern U8 AsocState;
+void zd_ShowState(void)
+{
+        printk(KERN_DEBUG "AuthReqState    = %04x, AsocState      = %04x\n", AuthReqState, AsocState);
+        printk(KERN_DEBUG "mPwrState       = %04x, mAssoc         = %04x\n", mPwrState, mAssoc);
+        printk(KERN_DEBUG "mAuthAlg        = %04x, mBssIndex      = %04x\n", mAuthAlg, mBssIndex);
+        printk(KERN_DEBUG "mBssType        = %04x, ConfigFlag     = %04x\n", mBssType, pdot11Obj->ConfigFlag);
+}
+
+void zd_ShowHashInfo(U8 aid)
+{
+        Hash_t *pHash = NULL;
+        if (mBssType == INFRASTRUCTURE_BSS) {
+                aid = 0;
+        }
+        pHash = sstByAid[aid];
+        zd1205_dump_data("Mac Addr = ", pHash->mac, 6);
+        FPRINT_V("Auth", pHash->auth);
+        FPRINT_V("Asoc", pHash->asoc);
+        FPRINT_V("psm", pHash->psm);
+        FPRINT_V("Aid", pHash->aid);
+        FPRINT_V("vapId", pHash->vapId);
+        FPRINT_V("bErpSta", pHash->bErpSta);
+        FPRINT_V("lsInterval", pHash->lsInterval);
+        FPRINT_V("encryMode", pHash->encryMode);
+        FPRINT_V("pkInstalled", pHash->pkInstalled);
+        FPRINT_V("ZydasMode", pHash->ZydasMode);
+        FPRINT_V("AlreadyIn", pHash->AlreadyIn);
+        FPRINT_V("CurrTxRate", pHash->CurrTxRate);
+        FPRINT_V("MaxRate", pHash->MaxRate);
+        FPRINT_V("Preamble", pHash->Preamble);
+        FPRINT_V("KeyId", pHash->KeyId);
+        FPRINT_V("Rx IV16", pHash->RxSeed.IV16);
+        FPRINT_V("Rx IV32", pHash->RxSeed.IV32);
+        zd1205_dump_data("TK = ", pHash->TxSeed.TK, 16);
+        zd1205_dump_data("Tx MIC K0 = ", (U8 *)&pHash->TxMicKey.K0, 4);
+        zd1205_dump_data("Tx MIC K1 = ", (U8 *)&pHash->TxMicKey.K1, 4);
+        zd1205_dump_data("Rx MIC K0 = ", (U8 *)&pHash->RxMicKey.K0, 4);
+        zd1205_dump_data("Rx MIC K1 = ", (U8 *)&pHash->RxMicKey.K1, 4);
+#if 0
+
+        FPRINT_V("KeyId", mWpaBcKeyId);
+        FPRINT_V("GkInstalled", mGkInstalled);
+        FPRINT_V("IV16", mIv16);
+        FPRINT_V("IV32", mIv32);
+        zd1205_dump_data("keyContent = ", pHash->keyContent, 16);
+        zd1205_dump_data("TK = ", mBcSeed.TK, 16);
+        zd1205_dump_data("Tx MIC K0 = ", (U8 *)&mBcMicKey.K0, 4);
+        zd1205_dump_data("Tx MIC K1 = ", (U8 *)&mBcMicKey.K1, 4);
+#endif
+}
+
+void zd_UpdateCardSetting(card_Setting_t *pSetting)
+{
+        void *reg = pdot11Obj->reg;
+        static BOOLEAN InitConfig = TRUE;
+        U8 bcAddr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+        U32 tmpValue;
+        BOOLEAN bReConnect = FALSE;
+        //FPRINT("zd_UpdateCardSetting");
+
+        if (pSetting->AuthMode == 0) { //open system only
+                mAuthAlogrithms[0] = OPEN_SYSTEM;
+                mAuthAlogrithms[1] = NULL_AUTH;
+                mAuthAlg = OPEN_SYSTEM;
+        } else if (pSetting->AuthMode == 1) {	//shared key only
+                mAuthAlogrithms[0] = SHARE_KEY;
+                mAuthAlogrithms[1] = NULL_AUTH;
+                mAuthAlg = SHARE_KEY;
+        } else if (pSetting->AuthMode == 2) {	//auto auth mode
+                mAuthAlogrithms[0] = OPEN_SYSTEM;
+                mAuthAlogrithms[1] = SHARE_KEY;
+
+        }
+
+        if (mAuthMode != pSetting->AuthMode) {
+                if (!InitConfig)
+                        bReConnect = TRUE;
+        }
+
+        mAuthMode = pSetting->AuthMode;
+
+        if (mLimitedUser != pSetting->LimitedUser) {
+                mLimitedUser = pSetting->LimitedUser;
+        }
+
+        mBlockBSS = pSetting->BlockBSS;
+        mSwCipher = pSetting->SwCipher;
+        mKeyFormat = pSetting->EncryMode;
+        mKeyId = pSetting->EncryKeyId;
+        mBcKeyId = pSetting->BcKeyId;
+        mDynKeyMode = pSetting->DynKeyMode;
+        mFragThreshold = pSetting->FragThreshold;
+        mRtsThreshold = pSetting->RTSThreshold;
+        mBeaconPeriod = pSetting->BeaconInterval;
+        mDtimPeriod = pSetting->DtimPeriod;
+
+        if (!InitConfig)
+                HW_EnableBeacon(pdot11Obj, mBeaconPeriod, mDtimPeriod, pSetting->BssType);
+        //HW_EnableBeacon(pdot11Obj, mBeaconPeriod, mDtimPeriod, mBssType);
+
+        if (mRadioOn != pSetting->RadioOn) {
+                mRadioOn = pSetting->RadioOn;
+                if (!InitConfig)
+                        HW_RadioOnOff(pdot11Obj, mRadioOn);
+        }
+
+        if (mRfChannel != pSetting->Channel) {
+                mRfChannel = pSetting->Channel;
+                mPhpm.buf[0] = EID_DSPARMS;
+                mPhpm.buf[1] = 1;
+                mPhpm.buf[2] = mRfChannel;
+
+                if (!InitConfig) {
+                        if (pSetting->BssType != INFRASTRUCTURE_BSS)
+                                HW_SetRfChannel(pdot11Obj, mRfChannel, 0,pSetting->MacMode);
+
+
+                        if (pSetting->BssType == INDEPENDENT_BSS) {
+                                mRequestFlag |= CHANNEL_SCAN_SET;
+                                pdot11Obj->ConfigFlag |= SCAN_AND_CONNECT_SET;
+                                //bReConnect = FALSE;
+                        }
+                }
+        }
+
+        mPreambleType = pSetting->PreambleType;
+
+        if (mPreambleType)
+                mCap |= CAP_SHORT_PREAMBLE;
+        else
+                mCap &= ~CAP_SHORT_PREAMBLE;
+
+        mPrivacyInvoked = pSetting->EncryOnOff;
+        if (pSetting->DynKeyMode > 0)
+                mPrivacyInvoked = TRUE;
+
+        if (mPrivacyInvoked)
+                mCap |= CAP_PRIVACY;
+        else
+                mCap &= ~CAP_PRIVACY;
+
+        memcpy(&dot11DesiredSsid, pSetting->Info_SSID,  pSetting->Info_SSID[1]+2);
+
+        if (dot11DesiredSsid.buf[1] == 0)
+                mProbeWithSsid = FALSE;
+        else
+                mProbeWithSsid = TRUE;
+        //mProbeWithSsid = FALSE;  //debug for ANY connection
+
+        if ((pSetting->BssType == INFRASTRUCTURE_BSS) || (pSetting->BssType == INDEPENDENT_BSS)) {
+                if (!InitConfig) {
+                        //   if (memcmp(&mSsid, &dot11DesiredSsid,  dot11DesiredSsid.buf[1]+2) != 0 ){
+                        bReConnect = TRUE;
+                        //    }
+                }
+
+                if (pSetting->BssType == INDEPENDENT_BSS) {
+                        memcpy(&mSsid, &dot11DesiredSsid,  dot11DesiredSsid.buf[1]+2);
+                        mATIMWindow = pSetting->ATIMWindow;
+                }
+        }
+
+
+        mHiddenSSID = pSetting->HiddenSSID;
+        if (mHiddenSSID) {
+                mSsid.buf[0] = EID_SSID;
+                mSsid.buf[1] = 1;
+                mSsid.buf[2] = 0x0;
+        }
+
+        memcpy(&mBrates, pSetting->Info_SupportedRates, pSetting->Info_SupportedRates[1]+2);
+
+        if (!InitConfig) {
+#if defined(AMAC)
+                pdot11Obj->SetReg(reg, ZD_BasicRateTbl, 0);
+#endif
+
+                HW_SetSupportedRate(pdot11Obj, (U8 *)&mBrates);
+        }
+
+#if defined(OFDM)
+        if (pSetting->MacMode != PURE_B_MODE) {
+                if (pSetting->ShortSlotTime) {
+                        pdot11Obj->ConfigFlag |= SHORT_SLOT_TIME_SET;
+                        mCap |= CAP_SHORT_SLOT_TIME;
+                } else {
+                        pdot11Obj->ConfigFlag &= ~SHORT_SLOT_TIME_SET;
+                        mCap &= ~CAP_SHORT_SLOT_TIME;
+                }
+
+                mMaxTxRate = 0x0b;
+                if(PURE_A_MODE != pSetting->MacMode) {
+                        memcpy(&mExtRates, pSetting->Ext_SupportedRates, pSetting->Ext_SupportedRates[1]+2);
+                        if (!InitConfig)
+                                HW_SetSupportedRate(pdot11Obj, (U8 *)&mExtRates);
+                }
+
+        } else
+                mMaxTxRate = 0x03;
+
+        if (!InitConfig) {
+                if (mMacMode != pSetting->MacMode) {   //MacMode changed
+                        bReConnect = TRUE;
+                }
+        }
+
+        mMacMode = pSetting->MacMode;
+#endif
+
+        memcpy((U8 *)&dot11MacAddress, pSetting->MacAddr, 6);
+        memcpy(&mKeyVector[0][0], &pSetting->keyVector[0][0], sizeof(mKeyVector));
+        mWepKeyLen = pSetting->WepKeyLen;
+        memcpy(&mBcKeyVector[0], &pSetting->BcKeyVector[0], sizeof(mBcKeyVector));
+
+        mBcKeyLen = pSetting->BcKeyLen;
+
+        /* Check if we need to copy the WPA IE */
+        //if ((mDynKeyMode == DYN_KEY_TKIP) || (mDynKeyMode == DYN_KEY_AES)
+        //  || (pSetting->WPASupport == 1 && pSetting->WPAIe[1] != 0)){
+        if ((pSetting->WPASupport==1 || pSetting->WPAIeLen)) {
+                //printk(KERN_ERR "Copy WPA IE in the zd_UpdateCardSetting\n");
+                memcpy(&mWPAIe, pSetting->WPAIe, pSetting->WPAIeLen);
+        } else {
+                memset(&mWPAIe.buf[0], 0, sizeof(mWPAIe));
+        }
+
+
+#if defined(AMAC)
+        mOperationMode = pSetting->OperationMode;
+        if (!InitConfig) {
+                //HW_CAM_ResetRollTbl(pdot11Obj);
+                if ((mOperationMode == CAM_AP_VAP) || (mOperationMode == CAM_AP_CLIENT)) {
+                        // for Ack response
+                        HW_CAM_ResetRollTbl(pdot11Obj);
+                        HW_CAM_SetMAC(pdot11Obj, CAM_VAP_START_AID, (U8 *)&dot11MacAddress);
+                        HW_CAM_UpdateRollTbl(pdot11Obj, CAM_VAP_START_AID);
+
+                        // for Address1 matching
+                        HW_CAM_SetMAC(pdot11Obj, 0, (U8 *)&bcAddr);
+                        HW_CAM_UpdateRollTbl(pdot11Obj, 0);
+                } else if (pSetting->BssType == INFRASTRUCTURE_BSS) {// Don't clear key in AP_BSS and IBSS mode.
+                        HW_CAM_ClearRollTbl(pdot11Obj, CAM_VAP_START_AID);
+                        HW_CAM_ClearRollTbl(pdot11Obj, 0);
+                }
+        } else {// Only clear all keys in the first time.
+                HW_CAM_ResetRollTbl(pdot11Obj);
+        }
+
+#endif
+
+        //mPwrState = pSetting->PwrState;
+        if (pSetting->BssType == AP_BSS) {
+                memcpy(&mSsid, &dot11DesiredSsid,  dot11DesiredSsid.buf[1]+2);
+                memcpy((U8 *)&mBssId, pSetting->MacAddr, 6);
+
+                // Update the mCap information
+                mCap &= ~BIT_1;
+                mCap |= BIT_0;
+
+                //mGkInstalled = 0;
+                zd_InitWepData();
+                if (!InitConfig) {
+                        zd_CmdProcess(CMD_DISASOC_ALL, 0, ZD_UNSPEC_REASON);
+                }
+
+        }
+
+#if defined(OFDM)
+        mErp.buf[2] = 0; //reset erp info
+
+        if ((mCap & CAP_SHORT_PREAMBLE) == 0) {
+                mErp.buf[2] |= BARKER_PREAMBLE;
+                if (pdot11Obj) {
+                        tmpValue = pdot11Obj->GetReg(reg, ZD_RTS_CTS_Rate);
+                        tmpValue &= ~NON_BARKER_PMB_SET;
+                        tmpValue |= CTS_RATE_11M;
+                        pdot11Obj->SetReg(reg, ZD_RTS_CTS_Rate, tmpValue);
+                }
+        }
+
+        if (pdot11Obj)
+                pdot11Obj->ConfigFlag &= ~ENABLE_PROTECTION_SET;
+
+        if (pSetting->BssType == INDEPENDENT_BSS) {
+                if (mMacMode == PURE_G_MODE)
+                        mErp.buf[2] = 0;
+                else
+                        mErp.buf[2] = (NON_ERP_PRESENT | USE_PROTECTION | BARKER_PREAMBLE);
+        }
+#endif
+
+        if (!InitConfig) {
+                //if (mBssType != pSetting->BssType){
+                if (mBssType != pSetting->BssType)
+                        //if (pSetting->BssType != INFRASTRUCTURE_BSS)
+                {
+                        //int i;
+
+                        mBssType = pSetting->BssType;
+                        if (pSetting->BssType == AP_BSS)
+                        {
+                                zd_StartAP();
+                                bReConnect = FALSE;
+                        } else
+                        {
+                                zd_StartSTA(0);
+                                bReConnect = FALSE;
+                        }
+
+                        //for (i=0; i<(MAX_AID+1); i++)
+                        //CleanupHash(sstByAid[i]);
+                        //InitHashTbl();
+                        zd_InitWepData();
+                        //zd_CmdFlushQ();
+                }
+        }
+
+        mBssType = pSetting->BssType;
+        pdot11Obj->BssType = mBssType;
+
+        if (bReConnect) {
+                if (pSetting->BssType == INFRASTRUCTURE_BSS) {
+                        BOOLEAN ret;
+                        pdot11Obj->ConfigFlag |= SCAN_AND_CONNECT_SET;
+                        if (pSetting->ap_scan == 1) {
+                                ret = zd_ChooseAP(1); // Choose AP by dot11DesiredBssid.
+                        } else
+                                ret = zd_ChooseAP(0);
+
+                        if (ret == FALSE) {
+                                zd_StartSTA(0);//ReScan all channels to find the selected BSS.
+                        }
+                }
+        }
+
+        InitConfig = FALSE;
+}
+
+
+void zd_PsPoll(void)
+{
+        Signal_t *signal;
+        FrmDesc_t *pfrmDesc;
+
+        //FPRINT("zd_PsPoll");
+
+        if ((signal = allocSignal()) == NULL) {
+                return;
+        }
+
+        pfrmDesc = allocFdesc();
+        if(!pfrmDesc) {
+                freeSignal(signal);
+                return;
+        }
+
+        sendPsPollFrame(signal, pfrmDesc, &mBssId, mAid);
+        mRequestFlag &= ~PS_POLL_SET;
+        return;
+}
+
+void zd_NullData(void)
+{
+        Signal_t *signal;
+        FrmDesc_t *pfrmDesc;
+
+        //FPRINT("zd_NullData");
+
+        if ((signal = allocSignal()) == NULL) {
+                return;
+        }
+
+        pfrmDesc = allocFdesc();
+        if(!pfrmDesc) {
+                freeSignal(signal);
+                return;
+        }
+
+        sendNullDataFrame(signal, pfrmDesc, &mBssId);
+        mRequestFlag &= ~PS_CHANGE_SET;
+        return;
+}
+
+void zd_DisConnect(void)
+{
+        //FPRINT("zd_DisConnect");
+
+        zd_CmdProcess(CMD_ROAMING,0,0);
+        mRequestFlag &= ~DIS_CONNECT_SET;
+
+        /*pdot11Obj->ConfigFlag |= SCAN_AND_CONNECT_SET;
+        pdot11Obj->bChScanning = 0;
+        mRequestFlag &= ~DIS_CONNECT_SET;
+        #if 0    
+        zd_CmdProbeReq((U8)mProbeWithSsid);
+        #else
+        zd_ChooseAP();
+        #endif    */
+}
+
+void zd_Roaming(void)
+{
+        //FPRINT("zd_Roaming");
+        pdot11Obj->ConfigFlag |= SCAN_AND_CONNECT_SET;
+        //pdot11Obj->bChScanning = 0;
+        mRequestFlag &= ~ROAMING_SET;
+        zd_CmdProbeReq((U8)mProbeWithSsid);
+}
+
+void zd_ConnectMon(void)
+{
+        //FPRINT_V("mRequestFlag", mRequestFlag);
+        if (mRequestFlag & DIS_CONNECT_SET) {
+                mRequestFlag = 0;
+                FPRINT("DIS_CONNECT_SET");
+                zd_DisConnect();
+                goto end;
+        }
+
+        if (mRequestFlag & ROAMING_SET) {
+                mRequestFlag = 0;
+                FPRINT("ROAMING_SET");
+                zd_Roaming();
+                goto end;
+        }
+
+        if (mRequestFlag & CHANNEL_SCAN_SET) {
+                //FPRINT("CHANNEL_SCAN_SET");
+                mRequestFlag &= ~BSS_CONNECT_SET;
+                mRequestFlag &= ~CONNECT_TOUT_SET;
+                zd_CmdProbeReq((U8)mProbeWithSsid);
+                goto end;
+        }
+
+        if (mRequestFlag & BSS_CONNECT_SET) {
+                //FPRINT("BSS_CONNECT_SET");
+                mRequestFlag &= ~CHANNEL_SCAN_SET;
+                mRequestFlag &= ~CONNECT_TOUT_SET;
+                zd_InfraConnect(mBssIndex);
+                goto end;
+        }
+
+        if (mRequestFlag & CONNECT_TOUT_SET) {
+                //FPRINT("CONNECT_TOUT_SET");
+                mConnRetryCnt++;
+
+                if ((mConnRetryCnt > 6) || (pdot11Obj->bChScanning)) {
+                        mRequestFlag &= ~CONNECT_TOUT_SET;
+                        mConnRetryCnt = 0;
+                        mSsid.buf[1] = 0; //reset mSsid
+                        //return;
+                } else {
+                        FPRINT("Connect Timeout, Re-Connect...");
+                        zd_InfraConnect(mBssIndex);
+                        //return;
+                }
+                goto end;
+        }
+
+        if (mRequestFlag & PS_POLL_SET) {
+                zd_PsPoll();
+                goto end;
+        }
+
+        if (mRequestFlag & PS_CHANGE_SET) {
+                zd_NullData();
+                goto end;
+        }
+
+        if (mRequestFlag & IBSS_CONNECT_SET) {
+                zd_IbssConnect();
+                goto end;
+        }
+end:
+        zd_SigProcess();
+}
+
+extern BOOLEAN SynchEntry(Signal_t* signal);
+extern BOOLEAN AuthReqEntry(Signal_t* signal);
+extern BOOLEAN AuthRspEntry(Signal_t* signal);
+extern BOOLEAN AsocEntry(Signal_t* signal);
+//State machine entry point
+void zd_SigProcess(void)
+{
+        Signal_t* 	signal = NULL;
+        BOOLEAN		ret;
+
+        while((signal = sigDeque(&mgtQ)) != NULL) {
+                switch(signal->block) {
+                case BLOCK_SYNCH:
+                        ret = SynchEntry(signal);
+                        break;
+
+                case BLOCK_AUTH_REQ:
+                        ret = AuthReqEntry(signal);
+                        break;
+
+                case BLOCK_AUTH_RSP:
+                        ret = AuthRspEntry(signal);
+                        break;
+
+                case BLOCK_ASOC:
+                        ret = AsocEntry(signal);
+                        break;
+
+                default:
+                        ret = TRUE;
+                        break;
+                }
+
+                if (ret) {
+                        pdot11Obj->ReleaseBuffer(signal->buf);
+                        freeSignal(signal);
+
+                }
+        }
+        pdot11Obj->QueueFlag &= ~MGT_QUEUE_SET;
+}
+
+U8 zd_CheckTotalQueCnt(void)
+{
+        U8 TotalQueCnt = 0;
+        U32 flags;
+        int i;
+
+        flags = pdot11Obj->EnterCS();
+
+        for (i=0; i<MAX_AID+1; i++)
+                TotalQueCnt += pPsQ[i]->cnt;
+
+        TotalQueCnt += pAwakeQ->cnt;
+        TotalQueCnt += pTxQ->cnt;
+        TotalQueCnt += pMgtQ->cnt;
+        pdot11Obj->ExitCS(flags);
+
+
+        return TotalQueCnt;
+}
+
+void zd_RateMoniter(void)
+{
+        int i;
+        U32 SucessFrmCnt;
+        U32 FailFmrCnt;
+        Hash_t *pHash;
+        U32 Ratio = 0;
+
+
+#if defined(OFDM)
+
+        if (mCurrConnUser > 0) {
+                for (i=1; i<(MAX_AID+1); i++) {
+                        pHash = sstByAid[i];
+                        if (pHash->bValid) {
+                                SucessFrmCnt = pHash->SuccessFrames;
+                                FailFmrCnt = pHash->FailedFrames;
+
+                                //FPRINT_V("Aid", i);
+
+                                if (SucessFrmCnt + FailFmrCnt < 20) {
+                                        //FPRINT(" FmrCnt < 20");
+                                        continue;
+                                }
+
+
+                                if ((SucessFrmCnt) && (FailFmrCnt == 0)) {
+                                        pHash->RiseConditionCount++;
+                                        pHash->DownConditionCount = 0;
+                                        //FPRINT(" FailFmrCnt == 0");
+                                        goto JudgeRate;
+                                } else {
+                                        Ratio = SucessFrmCnt / FailFmrCnt;
+
+                                        //FPRINT_V("Ratio", Ratio);
+
+                                        if (Ratio > LINE1) { //100
+                                                //FPRINT(" > LINE1");
+                                                if (pHash->CurrTxRate > RATE_36M) {
+                                                        pHash->RiseConditionCount = 0;
+                                                        pHash->DownConditionCount++;
+                                                        goto JudgeRate;
+                                                } else if (pHash->CurrTxRate == RATE_36M) {
+                                                        pHash->RiseConditionCount = 0;
+                                                        pHash->DownConditionCount = 0;
+                                                        goto JudgeRate;
+                                                } else {
+                                                        pHash->RiseConditionCount++;
+                                                        pHash->DownConditionCount = 0;
+                                                        goto JudgeRate;
+                                                }
+                                        } // LINE1
+                                        else {
+                                                if (Ratio >= LINE2) { //10
+                                                        //FPRINT(" > LINE2");
+                                                        if (pHash->CurrTxRate > RATE_24M) {
+                                                                pHash->RiseConditionCount = 0;
+                                                                pHash->DownConditionCount++;
+                                                                goto JudgeRate;
+                                                        } else if (pHash->CurrTxRate == RATE_24M) {
+                                                                pHash->RiseConditionCount = 0;
+                                                                pHash->DownConditionCount = 0;
+                                                                goto JudgeRate;
+                                                        } else {
+                                                                pHash->RiseConditionCount++;
+                                                                pHash->DownConditionCount = 0;
+                                                                goto JudgeRate;
+
+                                                        }
+                                                } // LINE2
+                                                else {
+                                                        if (Ratio >= LINE3) {
+                                                                //FPRINT(" > LINE3");
+                                                                if (pHash->CurrTxRate > RATE_18M) {
+                                                                        pHash->RiseConditionCount = 0;
+                                                                        pHash->DownConditionCount++;
+                                                                        goto JudgeRate;
+                                                                } else if (pHash->CurrTxRate == RATE_18M) {
+                                                                        pHash->RiseConditionCount = 0;
+                                                                        pHash->DownConditionCount = 0;
+                                                                        goto JudgeRate;
+                                                                } else {
+                                                                        pHash->RiseConditionCount++;
+                                                                        pHash->DownConditionCount = 0;
+                                                                        goto JudgeRate;
+                                                                }
+                                                        } // LINE3
+                                                        else {
+                                                                //FPRINT(" < LINE3");
+                                                                pHash->RiseConditionCount = 0;
+                                                                pHash->DownConditionCount++;
+                                                                goto JudgeRate;
+
+                                                        }
+                                                }
+                                        }
+                                }
+JudgeRate:
+                                if (pHash->bJustRiseRate) {
+                                        if (pHash->DownConditionCount) {
+                                                if (pHash->CurrTxRate > 0) {
+                                                        pHash->CurrTxRate--;
+                                                        //FPRINT_V("Case 1: Down Rate, NewRate", pHash->CurrTxRate);
+                                                }
+                                                pHash->DownConditionCount = 0;
+                                                pHash->bJustRiseRate = FALSE;
+                                        } else {
+                                                pHash->bJustRiseRate = FALSE;
+                                        }
+                                } else {
+                                        pHash->bJustRiseRate = 0;
+                                        if (pHash->RiseConditionCount >= RISE_CONDITION_THRESHOLD) {
+                                                if (pHash->MaxRate > pHash->CurrTxRate) {
+                                                        pHash->CurrTxRate++;
+                                                        pHash->bJustRiseRate = TRUE;
+                                                        //FPRINT_V("Case 2: Rise Rate, NewRate", pHash->CurrTxRate);
+                                                }
+                                                pHash->DownConditionCount = 0;
+                                                pHash->RiseConditionCount = 0;
+                                        } else if (pHash->DownConditionCount >= DOWN_CONDITION_THRESHOLD) {
+                                                if (pHash->CurrTxRate > 0) {
+                                                        pHash->CurrTxRate--;
+                                                        //FPRINT_V("Case 3: Down Rate, NewRate", pHash->CurrTxRate);
+                                                }
+                                                pHash->DownConditionCount = 0;
+                                                pHash->RiseConditionCount = 0;
+                                        }
+                                }
+                                pHash->SuccessFrames = 0;
+                                pHash->FailedFrames = 0;
+
+                        } // end of pHash->bValid
+                } // end of for loop
+        }
+#endif
+}
+
+void zd_PerSecTimer(void)
+{
+        static U32 sec = 0;
+        sec++;
+
+        if (mBssType == AP_BSS) {
+                if (sec > AGE_HASH_PERIOD) {
+                        U32 tmpValue;
+                        void *reg = pdot11Obj->reg;
+
+                        mZyDasModeClient = FALSE;
+                        pdot11Obj->ConfigFlag &= ~NON_ERP_PRESENT_SET;
+                        pdot11Obj->ConfigFlag &= ~BARKER_PREAMBLE_SET;
+                        AgeHashTbl();
+                        sec = 0;
+
+#if defined(OFDM)
+
+                        if (mMacMode != PURE_B_MODE && mMacMode != PURE_A_MODE) {
+
+                                if (pdot11Obj->ConfigFlag & NON_ERP_PRESENT_SET) {
+                                        //FPRINT("Enable Protection Mode");
+                                        mErp.buf[2] |= (NON_ERP_PRESENT | USE_PROTECTION);
+                                        pdot11Obj->ConfigFlag |= ENABLE_PROTECTION_SET;
+                                        tmpValue = pdot11Obj->GetReg(reg, ZD_RTS_CTS_Rate);
+                                        tmpValue &= ~CTS_MOD_TYPE_OFDM;
+                                        tmpValue |= CTS_RATE_11M;
+                                        pdot11Obj->SetReg(reg, ZD_RTS_CTS_Rate, tmpValue);
+                                        pdot11Obj->ConfigFlag &= ~SHORT_SLOT_TIME_SET;
+                                        mCap &= ~CAP_SHORT_SLOT_TIME;
+                                        pdot11Obj->SetReg(reg, ZD_CWmin_CWmax, CW_NORMAL_SLOT);
+
+                                        if (((mCap & CAP_SHORT_PREAMBLE) == 0) || (pdot11Obj->ConfigFlag & BARKER_PREAMBLE_SET)) {
+                                                mErp.buf[2] |= BARKER_PREAMBLE;
+                                                tmpValue = pdot11Obj->GetReg(reg, ZD_RTS_CTS_Rate);
+                                                tmpValue &= ~NON_BARKER_PMB_SET;
+                                                tmpValue |= CTS_RATE_11M;
+                                                pdot11Obj->SetReg(reg, ZD_RTS_CTS_Rate, tmpValue);
+                                                //FPRINT("Enable Barker Preamble");
+                                        }
+                                } else {
+                                        //#if 0 for pure g mode testing
+                                        //FPRINT("Disable Protection Mode");
+                                        mErp.buf[2] &= ~(NON_ERP_PRESENT);
+                                        pdot11Obj->ConfigFlag &= ~ENABLE_PROTECTION_SET;
+
+                                        //FPRINT("Disable Barker Preamble");
+                                        mErp.buf[2] &= ~(BARKER_PREAMBLE);
+
+                                        pdot11Obj->ConfigFlag &= ~SHORT_SLOT_TIME_SET;
+                                        mCap |= CAP_SHORT_SLOT_TIME;
+                                        pdot11Obj->SetReg(reg, ZD_CWmin_CWmax, CW_SHORT_SLOT);
+
+                                }
+
+                        }
+#endif
+
+                }
+        }
+}
+
+
+BOOLEAN zd_QueryStaTable(U8 *sta, void **ppHash)
+{
+        Hash_t *pHash = NULL;
+        MacAddr_t *addr = (MacAddr_t*) sta;
+
+        pHash = HashSearch(addr);
+
+        *ppHash = pHash;
+
+        if (!pHash)
+                return FALSE;
+
+        if (pHash->asoc == STATION_STATE_ASOC)
+                return TRUE;
+        else
+                return FALSE;
+}
+
+U8  zd_GetBssList(bss_info_t *pBssList)
+{
+        U8 i;
+
+        for (i=0; i < mBssCnt; i++, pBssList++) {
+                memcpy(pBssList->bssid, (U8 *)&mBssInfo[i].bssid, 6);
+                pBssList->beaconInterval = mBssInfo[i].bcnInterval;
+                pBssList->channel = mBssInfo[i].Phpm.buf[2];
+                pBssList->cap = mBssInfo[i].cap;
+                memcpy(pBssList->ssid, (U8 *)&mBssInfo[i].ssid, mBssInfo[i].ssid.buf[1]+2);
+                //printk("ssid: %s\r\n", &mBssInfo[i].ssid.buf[2]);
+                memcpy(pBssList->supRates, (U8 *)&mBssInfo[i].supRates, mBssInfo[i].supRates.buf[1]+2);
+                memcpy(pBssList->extRates, (U8 *)&mBssInfo[i].extRates, mBssInfo[i].extRates.buf[1]+2);
+                pBssList->atimWindow = mBssInfo[i].IbssParms.buf[2] + ((U16)(mBssInfo[i].IbssParms.buf[3]) << 8);
+                pBssList->signalStrength = mBssInfo[i].signalStrength;
+                pBssList->signalQuality = mBssInfo[i].signalQuality;
+                pBssList->apMode = mBssInfo[i].apMode;
+
+                /* Copy WPAIe */
+                memcpy(pBssList->WPAIe, (U8 *)&mBssInfo[i].WPAIe, mBssInfo[i].WPAIe[1]+2);
+                memcpy(pBssList->RSNIe, (U8 *)&mBssInfo[i].RSNIe, mBssInfo[i].RSNIe[1]+2);
+
+                //printk(" [zd_GetBssList] wpa ie len = %d\r\n", mBssInfo[i].WPAIe[1]+2);
+        }
+
+        return  mBssCnt;
+}
+
+U16 zd_AidLookUp(U8 *addr)
+{
+        MacAddr_t *sta = (MacAddr_t *)addr;
+        return AIdLookup(sta);
+}
+#if 0
+void zd_UpdateIbssInfo(U8 *addr, U8 tmpMaxRate, U8 preamble, U8 erpSta)
+{
+        U8 MaxRate;
+        MaxRate = RateConvert((tmpMaxRate & 0x7f));
+        if (MaxRate > mMaxTxRate)
+                MaxRate = mMaxTxRate;
+
+        UpdateStaStatus((MacAddr_t *)addr, STATION_STATE_ASOC, 0);
+        AssocInfoUpdate((MacAddr_t *)addr, MaxRate, 0, 0, preamble, erpSta, 0);
+        //FPRINT_V("MaxRate", MaxRate);
+        //FPRINT_V("erpSta", erpSta);
+}
+#endif
+void zd_UpdateIbssInfo(U8 *addr, U8 tmpMaxRate, U8 preamble, U8 erpSta)
+{
+        U8 MaxRate;
+        MacAddr_t	*Sta;
+        Hash_t		*pHash;
+        MaxRate = RateConvert((tmpMaxRate & 0x7f));
+
+        if (MaxRate > mMaxTxRate)
+                MaxRate = mMaxTxRate;
+        Sta = (MacAddr_t *)addr;
+        UpdateStaStatus(Sta, STATION_STATE_ASOC, 0);
+
+        pHash = HashSearch(Sta);
+        if (pHash != NULL) {
+                if (!pHash->AlreadyIn) {
+                        pHash->AlreadyIn=1;
+                        mCurrConnUser++;
+                        if (erpSta == FALSE) {
+                                mNumBOnlySta++;
+                        }
+                }
+        }
+        AssocInfoUpdate((MacAddr_t *)addr, MaxRate, 0, 0, preamble, erpSta, 0);
+        //FPRINT_V("MaxRate", MaxRate);
+        //FPRINT_V("erpSta", erpSta);
+}
+
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdhci.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdhci.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdhci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdhci.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,14 @@
+#ifndef _ZDHCI_H_
+#define _ZDHCI_H_
+#include "zdapi.h"
+
+extern zd_80211Obj_t *pdot11Obj;
+void zd_SendClass3ErrorFrame(MacAddr_t *sta, U8 vapId);
+U8 zd_CheckTotalQueCnt(void);
+void zd_EnableProtection(U8 protect);
+//BOOLEAN zd_ChooseAP(void);
+BOOLEAN zd_ChooseAP(BOOLEAN bUseBssid);
+extern void zd1205_dump_data(char *info, u8 *data, u32 data_len);
+BOOLEAN zd_CmdDeauth(MacAddr_t *sta, U8 rCode);
+BOOLEAN zd_CmdDisasoc(MacAddr_t *sta, U8 rCode);
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdhw.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdhw.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdhw.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdhw.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,4546 @@
+#ifndef __ZDHW_C__
+#define __ZDHW_C__
+
+#include "zdtypes.h"
+#include "zdequates.h"
+#include "zdapi.h"
+#include "zdhw.h"
+#include "zddebug.h"
+#include "zd1211.h"
+#include "zd1205.h"
+extern struct net_device *g_dev;
+extern u8 mMacMode;
+extern u8 a_OSC_get_cal_int( u8 ch, u32 rate, u8 *intValue, u8 *calValue);
+extern u8 *mTxOFDMType;
+extern const U16 dot11A_Channel[];
+extern const U16 dot11A_Channel_Amount;
+
+u8 LastSetChannel=1;
+u8 LastMacMode=0;
+
+U32 GRF5101T[] = {
+                         0x1A0000,   //Null
+                         0x1A0000,   //Ch 1
+                         0x1A8000,   //Ch 2
+                         0x1A4000,   //Ch 3
+                         0x1AC000,   //Ch 4
+                         0x1A2000,   //Ch 5
+                         0x1AA000,   //Ch 6
+                         0x1A6000,   //Ch 7
+                         0x1AE000,   //Ch 8
+                         0x1A1000,   //Ch 9
+                         0x1A9000,   //Ch 10
+                         0x1A5000,   //Ch 11
+                         0x1AD000,   //Ch 12
+                         0x1A3000,   //Ch 13
+                         0x1AB000    //Ch 14
+                 };
+
+
+U32 AL2210TB[] = {
+                         0x2396c0,   //;Null
+                         0x0196c0,   //;Ch 1
+                         0x019710,   //;Ch 2
+                         0x019760,   //;Ch 3
+                         0x0197b0,   //;Ch 4
+                         0x019800,   //;Ch 5
+                         0x019850,   //;Ch 6
+                         0x0198a0,   //;Ch 7
+                         0x0198f0,   //;Ch 8
+                         0x019940,   //;Ch 9
+                         0x019990,   //;Ch 10
+                         0x0199e0,   //;Ch 11
+                         0x019a30,   //;Ch 12
+                         0x019a80,   //;Ch 13
+                         0x019b40    //;Ch 14
+                 };
+
+
+U32	M2827BF[] = {
+                        0x0ccd4,    //;Null
+                        0x0ccd4,    //;Ch 1
+                        0x22224,    //;Ch 2
+                        0x37774,    //;Ch 3
+                        0x0ccd4,    //;Ch 4
+                        0x22224,    //;Ch 5
+                        0x37774,    //;Ch 6
+                        0x0ccd4,    //;Ch 7
+                        0x22224,    //;Ch 8
+                        0x37774,    //;Ch 9
+                        0x0ccd4,    //;Ch 10
+                        0x22224,    //;Ch 11
+                        0x37774,    //;Ch 12
+                        0x0ccd4,    //;Ch 13
+                        0x199a4    //;Ch 14
+                };
+
+
+U32	M2827BN[] = {
+                        0x30a03,    //;Null
+                        0x30a03,    //;Ch 1
+                        0x00a13,    //;Ch 2
+                        0x10a13,    //;Ch 3
+                        0x30a13,    //;Ch 4
+                        0x00a23,    //;Ch 5
+                        0x10a23,    //;Ch 6
+                        0x30a23,    //;Ch 7
+                        0x00a33,    //;Ch 8
+                        0x10a33,    //;Ch 9
+                        0x30a33,    //;Ch 10
+                        0x00a43,    //;Ch 11
+                        0x10a43,    //;Ch 12
+                        0x30a43,    //;Ch 13
+                        0x20a53    //;Ch 14
+                };
+
+
+U32	M2827BF2[] = {
+                         0x33334,    //;Null
+                         0x33334,    //;Ch 1
+                         0x08884,    //;Ch 2
+                         0x1ddd4,    //;Ch 3
+                         0x33334,    //;Ch 4
+                         0x08884,    //;Ch 5
+                         0x1ddd4,    //;Ch 6
+                         0x33334,    //;Ch 7
+                         0x08884,    //;Ch 8
+                         0x1ddd4,    //;Ch 9
+                         0x33334,    //;Ch 10
+                         0x08884,    //;Ch 11
+                         0x1ddd4,    //;Ch 12
+                         0x33334,    //;Ch 13
+                         0x26664    //;Ch 14
+                 };
+
+U32	M2827BN2[] = {
+                         0x10a03,    //;Null
+                         0x10a03,    //;Ch 1
+                         0x20a13,    //;Ch 2
+                         0x30a13,    //;Ch 3
+                         0x10a13,    //;Ch 4
+                         0x20a23,    //;Ch 5
+                         0x30a23,    //;Ch 6
+                         0x10a23,    //;Ch 7
+                         0x20a33,    //;Ch 8
+                         0x30a33,    //;Ch 9
+                         0x10a33,    //;Ch 10
+                         0x20a43,    //;Ch 11
+                         0x30a43,    //;Ch 12
+                         0x10a43,    //;Ch 13
+                         0x20a53    //;Ch 14
+                 };
+
+
+U32 AL2230TB[] = {
+                         0x03f790, 0x033331, 0x00000d,   //;Null
+                         0x03f790, 0x033331, 0x00000d,   //;Ch 1
+                         0x03f790, 0x0b3331, 0x00000d,  //;Ch 2
+                         0x03e790, 0x033331, 0x00000d,  //;Ch 3
+                         0x03e790, 0x0b3331, 0x00000d,  //;Ch 4
+                         0x03f7a0, 0x033331, 0x00000d,  //;Ch 5
+                         0x03f7a0, 0x0b3331, 0x00000d,  //;Ch 6
+                         0x03e7a0, 0x033331, 0x00000d,  //;Ch 7
+                         0x03e7a0, 0x0b3331, 0x00000d,  //;Ch 8
+                         0x03f7b0, 0x033331, 0x00000d,  //;Ch 9
+                         0x03f7b0, 0x0b3331, 0x00000d,  //;Ch 10
+                         0x03E7b0, 0x033331, 0x00000d,  //;Ch 11
+                         0x03e7b0, 0x0b3331, 0x00000d,  //;Ch 12
+                         0x03f7c0, 0x033331, 0x00000d,  //;Ch 13
+                         0x03e7c0, 0x066661, 0x00000d   //;Ch 14
+                 };
+U32 AL7230BTB[] = {
+                          0x09ec04, 0x8cccc8,   //;Null
+                          0x09ec00, 0x8cccc8,   //;Ch 1
+                          0x09ec00, 0x8cccd8,   //;Ch 2
+                          0x09ec00, 0x8cccc0,   //;Ch 3
+                          0x09ec00, 0x8cccd0,   //;Ch 4
+                          0x05ec00, 0x8cccc8,   //;Ch 5
+                          0x05ec00, 0x8cccd8,   //;Ch 6
+                          0x05ec00, 0x8cccc0,   //;Ch 7
+                          0x05ec00, 0x8cccd0,   //;Ch 8
+                          0x0dec00, 0x8cccc8,   //;Ch 9
+                          0x0dec00, 0x8cccd8,   //;Ch 10
+                          0x0dec00, 0x8cccc0,   //;Ch 11
+                          0x0dec00, 0x8cccd0,   //;Ch 12
+                          0x03ec00, 0x8cccc8,   //;Ch 13
+                          0x03ec00, 0x866660    //;Ch 14
+                  };
+
+U32 AL7230BTB_a[] = {
+                            0x06aff4, 0x855550, 0x47f8a2, 0x21ebfe,   //;Null
+                            0x02aff0, 0x800000, 0x47f8a2, 0x21ebf6,   //;CH 8 , 5040MHz
+                            0x02aff0, 0x855550, 0x47f8a2, 0x21ebfe,   //;CH 12, 5060MHz
+                            0x0aaff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;CH 16, 5080MHz
+                            0x06aff0, 0x8aaaa0, 0x47f8a2, 0x21ebfe,   //;CH 34, 5170MHz
+                            0x06aff0, 0x855550, 0x47f8a2, 0x21ebfe,   //;Ch 36, 5180MHz
+                            0x0eaff0, 0x800008, 0x47f8a2, 0x21ebfe,   //;Ch 38, 5190MHz
+                            0x0eaff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 40, 5200MHz
+                            0x0eaff0, 0x855558, 0x47f8a2, 0x21ebfe,   //;Ch 42, 5210MHz
+                            0x0eaff0, 0x800000, 0x47f8a2, 0x21ebf6,   //;Ch 44, 5220MHz, current support
+                            0x0eaff0, 0x8aaaa0, 0x47f8a2, 0x21ebfe,   //;Ch 46, 5230MHz
+                            0x0eaff0, 0x855550, 0x47f8a2, 0x21ebfe,   //;Ch 48, 5240MHz
+                            0x01aff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 52, 5260MHz
+                            0x01aff0, 0x800000, 0x47f8a2, 0x21ebf6,   //;Ch 56, 5280MHz, current support
+                            0x01aff0, 0x855550, 0x47f8a2, 0x21ebfe,   //;Ch 60, 5300MHz
+                            0x09aff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 64, 5320MHz
+                            0x09aff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 68, 5320MHz,dummy
+                            0x09aff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 72, 5320MHz,dummy
+                            0x09aff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 76, 5320MHz,dummy
+                            0x09aff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 80, 5320MHz,dummy
+                            0x09aff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 84, 5320MHz,dummy
+                            0x09aff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 88, 5320MHz,dummy
+                            0x09aff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 92, 5320MHz,dummy
+                            0x09aff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 96, 5320MHz,dummy
+                            0x03aff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 100, 5500MHz
+                            0x03aff0, 0x800000, 0x47f8a2, 0x21ebf6,   //;Ch 104, 5520MHz
+                            0x03aff0, 0x855550, 0x47f8a2, 0x21ebfe,   //;Ch 108, 5540MHz
+                            0x0baff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 112, 5560MHz
+                            0x0baff0, 0x800000, 0x47f8a2, 0x21ebf6,   //;Ch 116, 5580MHz
+                            0x0baff0, 0x855550, 0x47f8a2, 0x21ebfe,   //;Ch 120, 5600MHz
+                            0x07aff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 124, 5620MHz
+                            0x07aff0, 0x800000, 0x47f8a2, 0x21ebf6,   //;Ch 128, 5640MHz
+                            0x07aff0, 0x855550, 0x47f8a2, 0x21ebfe,   //;Ch 132, 5660MHz
+                            0x0faff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 136, 5680MHz
+                            0x0faff0, 0x800000, 0x47f8a2, 0x21ebf6,   //;Ch 140, 5700MHz
+                            0x0faff0, 0x800000, 0x47f8a2, 0x21ebf6,   //;Ch 144, 5700MHz, dummy
+                            0x006ff0, 0x800018, 0x47f8a2, 0x21ebfe,   //;Ch 149, 5745MHz
+                            0x006ff0, 0x855540, 0x47f8a2, 0x21ebfe,   //;Ch 153, 5765MHz
+                            0x006ff0, 0x8aaab0, 0x47f8a2, 0x21ebfe,   //;Ch 157, 5785MHz
+                            0x086ff0, 0x800018, 0x47f8a2, 0x21ebfe,   //;Ch 161, 5805MHz
+                            0x086ff0, 0x855540, 0x47f8a2, 0x21ebfe,   //;Ch 165, 5825MHz
+                            0x086ff0, 0x8d5540, 0x47f8a2, 0x21ebfe,   //;Ch 168, 5825MHz,dummy
+                            0x086ff0, 0x8d5540, 0x47f8a2, 0x21ebfe,   //;Ch 172, 5825MHz,dummy
+                            0x086ff0, 0x8d5540, 0x47f8a2, 0x21ebfe,   //;Ch 176, 5825MHz,dummy
+                            0x086ff0, 0x8d5540, 0x47f8a2, 0x21ebfe,   //;Ch 180, 5825MHz,dummy
+                            0x04aff0, 0x800000, 0x47f8a2, 0x21ebf6,   //;Ch 184, 4920MHz
+                            0x04aff0, 0x855550, 0x47f8a2, 0x21ebfe,   //;Ch 188, 4940MHz
+                            0x0caff0, 0x8aaaa8, 0x47f8a2, 0x21ebfe,   //;Ch 192, 4960MHz
+                            0x0caff0, 0x800000, 0x47f8a2, 0x21ebf6     //;Ch 196, 4980MHz
+                    };
+
+U32 RFMD2958t[] = {
+                          0x1422BD,   //Null
+                          0x185D17,   //Null
+                          0x181979,   //Ch 1
+                          0x1e6666,   //Ch 1
+                          0x181989,   //Ch 2
+                          0x1e6666,   //Ch 2
+                          0x181999,   //Ch 3
+                          0x1e6666,   //Ch 3
+                          0x1819a9,   //Ch 4
+                          0x1e6666,   //Ch 4
+                          0x1819b9,   //Ch 5
+                          0x1e6666,   //Ch 5
+                          0x1819c9,   //Ch 6
+                          0x1e6666,   //Ch 6
+                          0x1819d9,   //Ch 7
+                          0x1e6666,   //Ch 7
+                          0x1819e9,   //Ch 8
+                          0x1e6666,   //Ch 8
+                          0x1819f9,   //Ch 9
+                          0x1e6666,   //Ch 9
+                          0x181a09,   //Ch 10
+                          0x1e6666,   //Ch 10
+                          0x181a19,   //Ch 11
+                          0x1e6666,   //Ch 11
+                          0x181a29,   //Ch 12
+                          0x1e6666,   //Ch 12
+                          0x181a39,   //Ch 13
+                          0x1e6666,   //Ch 13
+                          0x181a60,   //Ch 14
+                          0x1c0000    //Ch 14
+                  };
+
+
+
+#if 0
+int HW_HTP(zd_80211Obj_t *pObj)
+{
+        void *reg = pObj->reg;
+        int i, ret = 0;
+        U32 tmpkey, tmpvalue, regvalue, seed;
+
+        dbg_pline_1("\r\nHW_HTP Starting....");
+
+        // PHY CR Registers Read/Write Test
+        dbg_pline_1("\r\nPHY CR Registers Read/Write Test Starting....");
+
+        seed = pObj->GetReg(reg, ZD_TSF_LowPart);
+        srand(seed);
+        LockPhyReg(pObj);
+
+        for (i=0; i<0x0200; i+=4) {
+                if ( (i==0x00) || ((i>=0xc8) && (i<=0xfc)) ||
+                                ((i>=0x1cc) && (i<=0x1d8)) || ((i>=0x1e0) && (i<=0x1ec))) {
+                        // Skip Read Only Register
+                        continue;
+                }
+                tmpkey = (U8)rand();
+                pObj->SetReg(reg, i, tmpkey);
+                tmpvalue = pObj->GetReg(reg, i);
+                if (tmpvalue != tmpkey) {
+                        //printf("CR %x Failed (Wr: %x, Rd: %x)\n", i, tmpkey, tmpvalue);
+                        dbg_plinew_1("\r\nCR ", i);
+                        dbg_pline_1(" Failed ");
+                        dbg_plineb_1("(Wr: ", (U8)tmpkey);
+                        dbg_plineb_1(", Rd: ", (U8)tmpvalue);
+                        dbg_pline_1(")");
+
+                        UnLockPhyReg(pObj);
+                        ret = 1;
+                } else {
+                        //printf("CR %x Success (Wr: %x, Rd: %x)\n", i, tmpkey, tmpvalue);
+                        dbg_plinew_1("\r\nCR ", i);
+                        dbg_pline_1(" Success ");
+                        dbg_plineb_1("(Wr: ", (U8)tmpkey);
+                        dbg_plineb_1(", Rd: ", (U8)tmpvalue);
+                        dbg_pline_1(")");
+                }
+        }
+
+        UnLockPhyReg(pObj);
+        dbg_pline_1("\r\nPHY CR Registers Read/Write Test End");
+        dbg_pline_1("\r\n");
+
+
+#if 1
+        // MAC Registers Read/Write Test
+        dbg_pline_1("\r\nMAC Registers Read/Write Test Starting....");
+        //to test 0x408, 0x410, 0x42c must set 0x418 to 0
+        pObj->SetReg(reg, ZD_GPI_EN, 0);
+        seed = pObj->GetReg(reg, ZD_TSF_LowPart);
+        srand(seed);
+        for (i=0; i<NUM_REG_MASK; i++) {
+                tmpkey = (U32)rand();
+                tmpkey |= (tmpkey << 16);
+                tmpkey &= MacRegMaskTab[i].ReadWriteMask;
+
+                if (MacRegMaskTab[i].Address == 0x42c) {
+                        pObj->SetReg(reg, ZD_GPI_EN, 0);
+
+                }
+
+
+
+                pObj->SetReg(reg, MacRegMaskTab[i].Address, tmpkey);
+                tmpvalue = pObj->GetReg(reg, MacRegMaskTab[i].Address);
+                tmpvalue &= MacRegMaskTab[i].ReadWriteMask;
+                if (tmpvalue != tmpkey) {
+                        //printf("MAC %x Failed (Wr: %x, Rd: %x)\n", MacRegMaskTab[i].Address, tmpkey, tmpvalue);
+                        dbg_plinew_1("\r\nMAC ", MacRegMaskTab[i].Address);
+                        dbg_pline_1(" Failed ");
+                        dbg_plinel_1("(Wr: ", tmpkey);
+                        dbg_plinel_1(", Rd: ", tmpvalue);
+                        dbg_pline_1(")");
+                        ret = 2;
+                }
+                else {
+                        //printf("MAC %x Success (Wr: %x, Rd: %x)\n", MacRegMaskTab[i].Address, tmpkey, tmpvalue);
+                        dbg_plinew_1("\r\nMAC ", MacRegMaskTab[i].Address);
+                        dbg_pline_1(" Success ");
+                        dbg_plinel_1("(Wr: ", tmpkey);
+                        dbg_plinel_1(", Rd: ", tmpvalue);
+                        dbg_pline_1(")");
+                }
+
+        }
+        dbg_pline_1("\r\nMAC Registers Read/Write Test End");
+        dbg_pline_1("\r\n");
+#endif
+
+#if 0
+        // EEPROM Read/Write Test
+        dbg_pline_1("\r\nEEPROM Read/Write Testing...........");
+        seed = pObj->GetReg(reg, ZD_TSF_LowPart);
+        srand(seed);
+
+        //for (tmpvalue=0; tmpvalue<1; tmpvalue++){
+        {
+                tmpkey = (U32)rand();
+                tmpkey |= (tmpkey << 16);
+                for (i=0; i<256; i++)
+                {
+                        //if (i == 1)
+                        //tmpkey = 0x89;
+                        pObj->SetReg(reg, ZD_E2P_SUBID+(i*4), tmpkey);
+                }
+                // Write to EEPROM
+                pObj->SetReg(reg, ZD_EEPROM_PROTECT0, 0x55aa44bb);
+                pObj->SetReg(reg, ZD_EEPROM_PROTECT1, 0x33cc22dd);
+                pObj->SetReg(reg, ZD_ROMDIR, 0x422);
+
+                // Sleep
+                //for (i=0; i<1000; i++)
+                //	pObj->DelayUs(5000);
+                delay1ms(5);
+
+
+                // Reset Registers
+                for (i=0; i<256; i++)
+                {
+                        pObj->SetReg(reg, ZD_E2P_SUBID+(i*4), 0);
+                }
+
+                // Reload EEPROM
+                pObj->SetReg(reg, ZD_ROMDIR, 0x424);
+
+                // Sleep
+                //for (i=0; i<1000; i++)
+                //	pObj->DelayUs(5000);
+                delay1ms(5);
+
+                // Check if right
+                for (i=0; i<256; i++)
+                {
+                        regvalue = pObj->GetReg(reg, ZD_E2P_SUBID+(i*4));
+                        if (regvalue != tmpkey) {
+                                //printf("EEPROM Addr (%x) error (Wr: %x, Rd: %x)\n", ZD_E2P_SUBID+(i*4), tmpkey, regvalue);
+                                dbg_plinew_1("\r\nEEPROM Addr ", ZD_E2P_SUBID+(i*4));
+                                dbg_pline_1(" error ");
+                                dbg_plinel_1("(Wr: ", tmpkey);
+                                dbg_plinel_1(",Rd: ", regvalue);
+                                dbg_pline_1(")");
+                                ret = 3;
+                        }
+                }
+        }
+#endif
+
+        //dbg_pline_1("\r\nDigital Loopback Testing...........");
+
+        dbg_pline_1("\r\nHW_HTP End");
+        dbg_pline_1("\r\n");
+        return 0;
+}
+#endif
+
+#define SET_IF_SYNTHESIZER(macp, InputValue)       \
+{                                                     \
+	mFILL_WRITE_REGISTER( ZD_CR244, (U8) ((InputValue & 0xff0000)>>16));               \
+	mFILL_WRITE_REGISTER( ZD_CR243, (U8) ((InputValue & 0xff00) >> 8));      \
+	mFILL_WRITE_REGISTER( ZD_CR242, (U8) ((InputValue & 0xff)));   \
+}
+#define mFILL_WRITE_REGISTER(addr0, value0) \
+{                                           \
+    WriteAddr[WriteIndex] = addr0;          \
+    WriteData[WriteIndex ++] = value0;      \
+}
+
+
+#ifndef HOST_IF_USB
+void
+HW_Set_IF_Synthesizer(zd_80211Obj_t *pObj, U32 InputValue)
+{
+        U32	S_bit_cnt;
+        U32 tmpvalue;
+        void *reg = pObj->reg;
+        int i;
+
+
+        S_bit_cnt = pObj->S_bit_cnt;
+
+        InputValue = InputValue << (31 - S_bit_cnt);
+
+#if !( (defined(OFDM) && defined(GCCK)) || defined(ECCK_60_5) )
+
+        pObj->SetReg(reg, ZD_LE2, 0);
+        pObj->SetReg(reg, ZD_RF_IF_CLK, 0);
+
+        while(S_bit_cnt) {
+                InputValue = InputValue << 1;
+                if (InputValue & 0x80000000) {
+                        pObj->SetReg(reg, ZD_RF_IF_DATA, 1);
+                } else {
+                        pObj->SetReg(reg, ZD_RF_IF_DATA, 0);
+                }
+                pObj->SetReg(reg, ZD_RF_IF_CLK, 1);
+                //pObj->DelayUs(50);
+                pObj->SetReg(reg, ZD_RF_IF_CLK, 0);
+
+                //pObj->DelayUs(50);
+                S_bit_cnt --;
+        }
+
+        pObj->SetReg(reg, ZD_LE2, 1);
+
+        if (pObj->S_bit_cnt == 20) {			//Is it Intersil's chipset
+                pObj->SetReg(reg, ZD_LE2, 0);
+        }
+        return;
+#else
+
+        LockPhyReg(pObj);
+        tmpvalue = pObj->GetReg(reg, ZD_CR203);
+        tmpvalue &= ~BIT_1;
+        pObj->SetReg(reg, ZD_CR203, tmpvalue);
+
+        tmpvalue = pObj->GetReg(reg, ZD_CR240);
+        tmpvalue = 0x80;
+        if (tmpvalue & BIT_7) {		// Configure RF by Software
+                tmpvalue = pObj->GetReg(reg, ZD_CR203);
+                tmpvalue &= ~BIT_2;
+                pObj->SetReg(reg, ZD_CR203, tmpvalue);
+
+
+                while(S_bit_cnt) {
+                        InputValue = InputValue << 1;
+                        if (InputValue & 0x80000000) {
+                                tmpvalue = pObj->GetReg(reg, ZD_CR203);
+                                tmpvalue |= BIT_3;
+                                pObj->SetReg(reg, ZD_CR203, tmpvalue);
+                        } else {
+                                tmpvalue = pObj->GetReg(reg, ZD_CR203);
+                                tmpvalue &= ~BIT_3;
+                                pObj->SetReg(reg, ZD_CR203, tmpvalue);
+                        }
+
+                        tmpvalue = pObj->GetReg(reg, ZD_CR203);
+                        tmpvalue |= BIT_2;
+                        pObj->SetReg(reg, ZD_CR203, tmpvalue);
+
+                        tmpvalue = pObj->GetReg(reg, ZD_CR203);
+
+                        tmpvalue &= ~BIT_2;
+                        pObj->SetReg(reg, ZD_CR203, tmpvalue);
+                        S_bit_cnt --;
+                }
+        } else {		// Configure RF by Hardware
+                // Make Bit-reverse to meet hardware requirement.
+                tmpvalue = 0;
+                for (i=0; i<S_bit_cnt; i++) {
+                        InputValue = InputValue << 1;
+                        if (InputValue & 0x80000000) {
+                                tmpvalue |= (0x1 << i);
+                        }
+                }
+                InputValue = tmpvalue;
+
+                // Setup Command-Length
+                // wait until command-queue is available
+                tmpvalue = pObj->GetReg(reg, ZD_CR241);
+                while(tmpvalue & BIT_0) {
+                        pObj->DelayUs(1);
+                        FPRINT("Command-Queue busy...");
+                }
+
+                // write command (from high-byte to low-byte)
+                pObj->SetReg(reg, ZD_CR245, InputValue >> 24);
+                pObj->SetReg(reg, ZD_CR244, InputValue >> 16);
+                pObj->SetReg(reg, ZD_CR243, InputValue >> 8);
+                pObj->SetReg(reg, ZD_CR242, InputValue);
+        }
+
+
+        tmpvalue = pObj->GetReg(reg, ZD_CR203);
+        tmpvalue |= BIT_1;
+        pObj->SetReg(reg, ZD_CR203, tmpvalue);
+
+        if (pObj->S_bit_cnt == 20) {			//Is it Intersil's chipset
+                tmpvalue = pObj->GetReg(reg, ZD_CR203);
+                tmpvalue &= ~BIT_1;
+                pObj->SetReg(reg, ZD_CR203, tmpvalue);
+        }
+
+        UnLockPhyReg(pObj);
+        return;
+#endif
+}
+#endif
+
+
+void
+LockPhyReg(zd_80211Obj_t *pObj)
+{
+#ifndef fQuickPhySet
+
+        void *reg = pObj->reg;
+        U32	tmpvalue;
+
+        tmpvalue = pObj->GetReg(reg, ZD_CtlReg1);
+        tmpvalue &= ~0x80;
+        pObj->SetReg(reg, ZD_CtlReg1, tmpvalue);
+#endif
+}
+
+
+void
+UnLockPhyReg(zd_80211Obj_t *pObj)
+{
+#ifndef fQuickPhySet
+        void *reg = pObj->reg;
+        U32	tmpvalue;
+
+        tmpvalue = pObj->GetReg(reg, ZD_CtlReg1);
+        tmpvalue |= 0x80;
+        pObj->SetReg(reg, ZD_CtlReg1, tmpvalue);
+#endif
+}
+
+
+void
+HW_Set_Maxim_New_Chips(zd_80211Obj_t *pObj, U32 ChannelNo, U8 InitChOnly)
+{
+        void *reg = pObj->reg;
+        U32 tmpvalue;
+
+        LockPhyReg(pObj);
+
+#ifdef HOST_IF_USB
+
+        pObj->SetReg(reg, ZD_CR23, 0x40);
+        pObj->SetReg(reg, ZD_CR15, 0x20);
+        pObj->SetReg(reg, ZD_CR28, 0x3e);
+        pObj->SetReg(reg, ZD_CR29, 0x00);
+        pObj->SetReg(reg, ZD_CR26, 0x11);
+        pObj->SetReg(reg, ZD_CR44, 0x33);
+        pObj->SetReg(reg, ZD_CR106, 0x2a);
+        pObj->SetReg(reg, ZD_CR107, 0x1a);
+
+        pObj->SetReg(reg, ZD_CR109, 0x2b);
+        pObj->SetReg(reg, ZD_CR110, 0x2b);
+        pObj->SetReg(reg, ZD_CR111, 0x2b);
+        pObj->SetReg(reg, ZD_CR112, 0x2b);
+        pObj->SetReg(reg, ZD_CR10, 0x89);
+        pObj->SetReg(reg, ZD_CR17, 0x20);
+        pObj->SetReg(reg, ZD_CR26, 0x93);
+        pObj->SetReg(reg, ZD_CR34, 0x30);
+        pObj->SetReg(reg, ZD_CR35, 0x40);
+        pObj->SetReg(reg, ZD_CR41, 0x24);
+        pObj->SetReg(reg, ZD_CR44, 0x32);
+        pObj->SetReg(reg, ZD_CR46, 0x90);
+        pObj->SetReg(reg, ZD_CR89, 0x18);
+        pObj->SetReg(reg, ZD_CR92, 0x0a);
+
+        pObj->SetReg(reg, ZD_CR101, 0x13);
+        pObj->SetReg(reg, ZD_CR102, 0x27);
+        pObj->SetReg(reg, ZD_CR106, 0x20);
+        pObj->SetReg(reg, ZD_CR107, 0x24);
+        pObj->SetReg(reg, ZD_CR109, 0x09);
+        pObj->SetReg(reg, ZD_CR110, 0x13);
+        pObj->SetReg(reg, ZD_CR111, 0x13);
+        pObj->SetReg(reg, ZD_CR112, 0x13);
+        pObj->SetReg(reg, ZD_CR113, 0x27);
+        pObj->SetReg(reg, ZD_CR114, 0x27);
+        pObj->SetReg(reg, ZD_CR115, 0x24);
+        pObj->SetReg(reg, ZD_CR116, 0x24);
+        pObj->SetReg(reg, ZD_CR117, 0xf4);
+        pObj->SetReg(reg, ZD_CR118, 0xfa);
+        pObj->SetReg(reg, ZD_CR120, 0x4f);
+        pObj->SetReg(reg, ZD_CR121, 0x77);
+        pObj->SetReg(reg, ZD_CR122, 0xfe);
+#else
+
+        pObj->SetReg(reg, ZD_CR23, 0x40);
+        pObj->SetReg(reg, ZD_CR15, 0x20);
+        pObj->SetReg(reg, ZD_CR28, 0x3e);
+        pObj->SetReg(reg, ZD_CR29, 0x00);
+        pObj->SetReg(reg, ZD_CR26, 0x11);
+        pObj->SetReg(reg, ZD_CR44, 0x34); //4112
+        pObj->SetReg(reg, ZD_CR106, 0x2a);
+        pObj->SetReg(reg, ZD_CR107, 0x1a);
+        pObj->SetReg(reg, ZD_CR109, 0x2b);
+        pObj->SetReg(reg, ZD_CR110, 0x2b);
+        pObj->SetReg(reg, ZD_CR111, 0x2b);
+        pObj->SetReg(reg, ZD_CR112, 0x2b);
+
+#if (defined(GCCK) && defined(OFDM))
+
+        pObj->SetReg(reg, ZD_CR10, 0x89);
+        pObj->SetReg(reg, ZD_CR17, 0x20);
+        pObj->SetReg(reg, ZD_CR26, 0x93);
+        pObj->SetReg(reg, ZD_CR34, 0x30);
+        pObj->SetReg(reg, ZD_CR35, 0x40);
+
+        pObj->SetReg(reg, ZD_CR41, 0x24);
+        pObj->SetReg(reg, ZD_CR44, 0x32);
+        pObj->SetReg(reg, ZD_CR46, 0x90);
+        pObj->SetReg(reg, ZD_CR89, 0x18);
+        pObj->SetReg(reg, ZD_CR92, 0x0a);
+        pObj->SetReg(reg, ZD_CR101, 0x13);
+        pObj->SetReg(reg, ZD_CR102, 0x27);
+        pObj->SetReg(reg, ZD_CR106, 0x20);
+        pObj->SetReg(reg, ZD_CR107, 0x24);
+        //pObj->SetReg(reg, ZD_CR109, 0x09);
+        //pObj->SetReg(reg, ZD_CR110, 0x13);
+        //pObj->SetReg(reg, ZD_CR111, 0x13);
+
+
+
+
+        pObj->SetReg(reg, ZD_CR109, 0x13); //4326
+        pObj->SetReg(reg, ZD_CR110, 0x27); //4326
+        pObj->SetReg(reg, ZD_CR111, 0x27); //4326
+        pObj->SetReg(reg, ZD_CR112, 0x13);
+        pObj->SetReg(reg, ZD_CR113, 0x27);
+        pObj->SetReg(reg, ZD_CR114, 0x27);
+        pObj->SetReg(reg, ZD_CR115, 0x24);
+        pObj->SetReg(reg, ZD_CR116, 0x24);
+        pObj->SetReg(reg, ZD_CR117, 0xf4);
+        //pObj->SetReg(reg, ZD_CR118, 0xfa);
+        pObj->SetReg(reg, ZD_CR118, 0x00); //4326
+        pObj->SetReg(reg, ZD_CR120, 0x4f);
+        //pObj->SetReg(reg, ZD_CR121, 0x77); //3n12
+        //pObj->SetReg(reg, ZD_CR121, 0x13); //3d24
+        pObj->SetReg(reg, ZD_CR121, 0x06); //4326
+        pObj->SetReg(reg, ZD_CR122, 0xfe);
+        pObj->SetReg(reg, ZD_CR150, 0x0d); //4407
+
+#elif (defined(ECCK_60_5))
+
+        pObj->SetReg(reg, ZD_CR26, 0x91);
+        pObj->SetReg(reg, ZD_CR47, 0x18);
+        pObj->SetReg(reg, ZD_CR106, 0x44);
+        pObj->SetReg(reg, ZD_CR107, 0x00);
+        pObj->SetReg(reg, ZD_CR14, 0x80);
+        pObj->SetReg(reg, ZD_CR10, 0x89);
+        pObj->SetReg(reg, ZD_CR11, 0x00);
+        pObj->SetReg(reg, ZD_CR24, 0x0e);
+        pObj->SetReg(reg, ZD_CR41, 0x24);
+        pObj->SetReg(reg, ZD_CR159, 0x93);
+        pObj->SetReg(reg, ZD_CR160, 0xfc);
+        pObj->SetReg(reg, ZD_CR161, 0x1e);
+        pObj->SetReg(reg, ZD_CR162, 0x24);
+#endif
+#endif
+
+        pObj->CR122Flag = 2;
+        pObj->CR31Flag = 2;
+
+        //UnLockPhyReg(pObj);
+
+#if !( (defined(OFDM) && defined(GCCK)) || defined(ECCK_60_5) )
+
+        pObj->SetReg(reg, ZD_PE1_PE2, 0x02);
+#else
+        //LockPhyReg(pObj);
+        tmpvalue = pObj->GetReg(reg, ZD_CR203);
+        tmpvalue &= ~BIT_4;
+        pObj->SetReg(reg, ZD_CR203, tmpvalue);
+        //UnLockPhyReg(pObj);
+#endif
+
+        HW_Set_IF_Synthesizer(pObj, M2827BF[ChannelNo]);
+        HW_Set_IF_Synthesizer(pObj, M2827BN[ChannelNo]);
+        HW_Set_IF_Synthesizer(pObj, 0x00400);
+        HW_Set_IF_Synthesizer(pObj, 0x00ca1);
+        HW_Set_IF_Synthesizer(pObj, 0x10072);
+        HW_Set_IF_Synthesizer(pObj, 0x18645);
+        HW_Set_IF_Synthesizer(pObj, 0x04006);
+        HW_Set_IF_Synthesizer(pObj, 0x000a7);
+        HW_Set_IF_Synthesizer(pObj, 0x08258);
+        HW_Set_IF_Synthesizer(pObj, 0x03fc9);
+        HW_Set_IF_Synthesizer(pObj, 0x0040a);
+        HW_Set_IF_Synthesizer(pObj, 0x0000b);
+        HW_Set_IF_Synthesizer(pObj, 0x0026c);
+#if	defined(ECCK_60_5)
+
+        HW_Set_IF_Synthesizer(pObj, 0x04258);
+#endif
+
+#if !( (defined(OFDM) && defined(GCCK)) || defined(ECCK_60_5) )
+
+        pObj->SetReg(reg, ZD_PE1_PE2, 0x03);
+#else
+        //LockPhyReg(pObj);
+        tmpvalue = pObj->GetReg(reg, ZD_CR203);
+        tmpvalue |= BIT_4;
+
+        pObj->SetReg(reg, ZD_CR203, tmpvalue);
+        ;
+        //UnLockPhyReg(pObj);
+#endif
+
+        UnLockPhyReg(pObj);
+}
+
+
+
+void
+HW_Set_Maxim_New_Chips2(zd_80211Obj_t *pObj, U32 ChannelNo, U8 InitChOnly)
+{
+        void *reg = pObj->reg;
+        U32	tmpvalue;
+
+        // Get Phy-Config permission
+        LockPhyReg(pObj);
+
+#ifdef HOST_IF_USB
+
+        pObj->SetReg(reg, ZD_CR23, 0x40);
+        pObj->SetReg(reg, ZD_CR15, 0x20);
+        pObj->SetReg(reg, ZD_CR28, 0x3e);
+        pObj->SetReg(reg, ZD_CR29, 0x00);
+        pObj->SetReg(reg, ZD_CR26, 0x11);
+        pObj->SetReg(reg, ZD_CR44, 0x33);
+        pObj->SetReg(reg, ZD_CR106, 0x2a);
+        pObj->SetReg(reg, ZD_CR107, 0x1a);
+        pObj->SetReg(reg, ZD_CR109, 0x2b);
+        pObj->SetReg(reg, ZD_CR110, 0x2b);
+        pObj->SetReg(reg, ZD_CR111, 0x2b);
+        pObj->SetReg(reg, ZD_CR112, 0x2b);
+        pObj->SetReg(reg, ZD_CR10, 0x89);
+        pObj->SetReg(reg, ZD_CR17, 0x20);
+        pObj->SetReg(reg, ZD_CR26, 0x93);
+        pObj->SetReg(reg, ZD_CR34, 0x30);
+        pObj->SetReg(reg, ZD_CR35, 0x40);
+        pObj->SetReg(reg, ZD_CR41, 0x24);
+        pObj->SetReg(reg, ZD_CR44, 0x32);
+        pObj->SetReg(reg, ZD_CR46, 0x90);
+        pObj->SetReg(reg, ZD_CR89, 0x18);
+        pObj->SetReg(reg, ZD_CR92, 0x0a);
+        pObj->SetReg(reg, ZD_CR101, 0x13);
+        pObj->SetReg(reg, ZD_CR102, 0x27);
+        pObj->SetReg(reg, ZD_CR106, 0x20);
+        pObj->SetReg(reg, ZD_CR107, 0x24);
+        pObj->SetReg(reg, ZD_CR109, 0x09);
+        pObj->SetReg(reg, ZD_CR110, 0x13);
+        pObj->SetReg(reg, ZD_CR111, 0x13);
+        pObj->SetReg(reg, ZD_CR112, 0x13);
+        pObj->SetReg(reg, ZD_CR113, 0x27);
+        pObj->SetReg(reg, ZD_CR114, 0x27);
+        pObj->SetReg(reg, ZD_CR115, 0x24);
+        pObj->SetReg(reg, ZD_CR116, 0x24);
+
+        pObj->SetReg(reg, ZD_CR117, 0xf4);
+        pObj->SetReg(reg, ZD_CR118, 0xfa);
+        pObj->SetReg(reg, ZD_CR120, 0x4f);
+
+        pObj->SetReg(reg, ZD_CR121, 0x77);
+
+
+        pObj->SetReg(reg, ZD_CR122, 0xfe);
+
+#else
+
+        pObj->SetReg(reg, ZD_CR23, 0x40);
+        pObj->SetReg(reg, ZD_CR15, 0x20);
+        pObj->SetReg(reg, ZD_CR28, 0x3e);
+        pObj->SetReg(reg, ZD_CR29, 0x00);
+        pObj->SetReg(reg, ZD_CR26, 0x11);
+        pObj->SetReg(reg, ZD_CR44, 0x33);
+        pObj->SetReg(reg, ZD_CR106, 0x2a);
+        pObj->SetReg(reg, ZD_CR107, 0x1a);
+        pObj->SetReg(reg, ZD_CR109, 0x2b);
+        pObj->SetReg(reg, ZD_CR110, 0x2b);
+        pObj->SetReg(reg, ZD_CR111, 0x2b);
+        pObj->SetReg(reg, ZD_CR112, 0x2b);
+
+#if (defined(GCCK) && defined(OFDM))
+
+        pObj->SetReg(reg, ZD_CR10, 0x89);
+        pObj->SetReg(reg, ZD_CR17, 0x20);
+        pObj->SetReg(reg, ZD_CR26, 0x93);
+        pObj->SetReg(reg, ZD_CR34, 0x30);
+        pObj->SetReg(reg, ZD_CR35, 0x40);
+        pObj->SetReg(reg, ZD_CR41, 0x24);
+        pObj->SetReg(reg, ZD_CR44, 0x32);
+
+        pObj->SetReg(reg, ZD_CR46, 0x90);
+        pObj->SetReg(reg, ZD_CR79, 0x58); //for Atheros compability 4415
+        pObj->SetReg(reg, ZD_CR80, 0x30); //for Atheros compability
+        pObj->SetReg(reg, ZD_CR81, 0x30); //for Atheros compability
+        pObj->SetReg(reg, ZD_CR89, 0x18);
+
+
+
+
+
+
+
+        pObj->SetReg(reg, ZD_CR92, 0x0a);
+        pObj->SetReg(reg, ZD_CR101, 0x13);
+        pObj->SetReg(reg, ZD_CR102, 0x27);
+        pObj->SetReg(reg, ZD_CR106, 0x20);
+        pObj->SetReg(reg, ZD_CR107, 0x24);
+        pObj->SetReg(reg, ZD_CR109, 0x09);
+        pObj->SetReg(reg, ZD_CR110, 0x13);
+        pObj->SetReg(reg, ZD_CR111, 0x13);
+        pObj->SetReg(reg, ZD_CR112, 0x13);
+        pObj->SetReg(reg, ZD_CR113, 0x27);
+        pObj->SetReg(reg, ZD_CR114, 0x27);
+        pObj->SetReg(reg, ZD_CR115, 0x24);
+        pObj->SetReg(reg, ZD_CR116, 0x24);
+        pObj->SetReg(reg, ZD_CR117, 0xf4);
+        //pObj->SetReg(reg, ZD_CR118, 0xfa);
+        pObj->SetReg(reg, ZD_CR118, 0x00); //4326
+        pObj->SetReg(reg, ZD_CR120, 0x4f);
+        //pObj->SetReg(reg, ZD_CR121, 0x77); //3n12
+        //pObj->SetReg(reg, ZD_CR121, 0x13); //3d24
+        pObj->SetReg(reg, ZD_CR121, 0x06); //4326
+        pObj->SetReg(reg, ZD_CR122, 0xfe);
+#elif (defined(ECCK_60_5))
+
+        pObj->SetReg(reg, ZD_CR47, 0x18);
+        pObj->SetReg(reg, ZD_CR106, 0x04);
+        pObj->SetReg(reg, ZD_CR107, 0x00);
+        pObj->SetReg(reg, ZD_CR14, 0x80);
+        pObj->SetReg(reg, ZD_CR10, 0x89);
+
+        pObj->SetReg(reg, ZD_CR11, 0x00);
+        pObj->SetReg(reg, ZD_CR161, 0x28);
+        pObj->SetReg(reg, ZD_CR162, 0x26);
+
+        pObj->SetReg(reg, ZD_CR24, 0x0e);
+        pObj->SetReg(reg, ZD_CR41, 0x24);
+        pObj->SetReg(reg, ZD_CR159, 0x93);
+        pObj->SetReg(reg, ZD_CR160, 0xfc);
+        pObj->SetReg(reg, ZD_CR161, 0x20);
+        pObj->SetReg(reg, ZD_CR162, 0x26);
+#endif
+#endif
+
+        pObj->CR122Flag = 2;
+        pObj->CR31Flag = 2;
+
+        //UnLockPhyReg(pObj);
+
+#if !( (defined(OFDM) && defined(GCCK)) || defined(ECCK_60_5) )
+
+        pObj->SetReg(reg, ZD_PE1_PE2, 2);
+#else
+        //LockPhyReg(pObj);
+        tmpvalue = pObj->GetReg(reg, ZD_CR203);
+        tmpvalue &= ~BIT_4;
+        pObj->SetReg(reg, ZD_CR203, tmpvalue);
+        //UnLockPhyReg(pObj);
+#endif
+
+        HW_Set_IF_Synthesizer(pObj, M2827BF2[ChannelNo]);
+        HW_Set_IF_Synthesizer(pObj, M2827BN2[ChannelNo]);
+        HW_Set_IF_Synthesizer(pObj, 0x00400);
+        HW_Set_IF_Synthesizer(pObj, 0x00ca1);
+        HW_Set_IF_Synthesizer(pObj, 0x10072);
+        HW_Set_IF_Synthesizer(pObj, 0x18645);
+        HW_Set_IF_Synthesizer(pObj, 0x04006);
+        HW_Set_IF_Synthesizer(pObj, 0x000a7);
+        HW_Set_IF_Synthesizer(pObj, 0x08258);
+
+        HW_Set_IF_Synthesizer(pObj, 0x03fc9);
+        HW_Set_IF_Synthesizer(pObj, 0x0040a);
+        HW_Set_IF_Synthesizer(pObj, 0x0000b);
+        HW_Set_IF_Synthesizer(pObj, 0x0026c);
+#if	defined(ECCK_60_5)
+
+        HW_Set_IF_Synthesizer(pObj, 0x04258);
+#endif
+
+#if !( (defined(OFDM) && defined(GCCK)) || defined(ECCK_60_5) )
+
+        pObj->SetReg(reg, ZD_PE1_PE2, 3);
+
+#else
+        //LockPhyReg(pObj);
+        tmpvalue = pObj->GetReg(reg, ZD_CR203);
+        tmpvalue |= BIT_4;
+        pObj->SetReg(reg, ZD_CR203, tmpvalue);
+        //UnLockPhyReg(pObj);
+#endif
+
+        UnLockPhyReg(pObj);
+}
+
+
+void
+HW_Set_GCT_Chips(zd_80211Obj_t *pObj, U32 ChannelNo, U8 InitChOnly)
+{
+        void *reg = pObj->reg;
+
+        if (!InitChOnly) {
+                LockPhyReg(pObj);
+                pObj->SetReg(reg, ZD_CR47, 0x1c);
+                pObj->SetReg(reg, ZD_CR15, 0xdc);
+                pObj->SetReg(reg, ZD_CR113, 0xc0); //3910
+                pObj->SetReg(reg, ZD_CR20, 0x0c);
+                pObj->SetReg(reg, ZD_CR17, 0x65);
+                pObj->SetReg(reg, ZD_CR34, 0x04);
+                pObj->SetReg(reg, ZD_CR35, 0x35);
+                pObj->SetReg(reg, ZD_CR24, 0x20);
+                pObj->SetReg(reg, ZD_CR9, 0xe0);
+                pObj->SetReg(reg, ZD_CR127, 0x02);
+                pObj->SetReg(reg, ZD_CR10, 0x91);
+                pObj->SetReg(reg, ZD_CR23, 0x7f);
+                pObj->SetReg(reg, ZD_CR27, 0x10);
+                pObj->SetReg(reg, ZD_CR28, 0x7a);
+                pObj->SetReg(reg, ZD_CR79, 0xb5);
+                pObj->SetReg(reg, ZD_CR64, 0x80);
+                //++ Enable D.C cancellation (CR33 Bit_5) to avoid
+                //	 CCA always high.
+                pObj->SetReg(reg, ZD_CR33, 0x28);
+                //--
+
+                pObj->SetReg(reg, ZD_CR38, 0x30);
+
+                UnLockPhyReg(pObj);
+
+                HW_Set_IF_Synthesizer(pObj, 0x1F0000);
+                HW_Set_IF_Synthesizer(pObj, 0x1F0000);
+                HW_Set_IF_Synthesizer(pObj, 0x1F0200);
+                HW_Set_IF_Synthesizer(pObj, 0x1F0600);
+                HW_Set_IF_Synthesizer(pObj, 0x1F8600);
+                HW_Set_IF_Synthesizer(pObj, 0x1F8600);
+                HW_Set_IF_Synthesizer(pObj, 0x002050);
+                HW_Set_IF_Synthesizer(pObj, 0x1F8000);
+                HW_Set_IF_Synthesizer(pObj, 0x1F8200);
+                HW_Set_IF_Synthesizer(pObj, 0x1F8600);
+                HW_Set_IF_Synthesizer(pObj, 0x1c0000);
+                HW_Set_IF_Synthesizer(pObj, 0x10c458);
+
+                HW_Set_IF_Synthesizer(pObj, 0x088e92);
+                HW_Set_IF_Synthesizer(pObj, 0x187b82);
+                HW_Set_IF_Synthesizer(pObj, 0x0401b4);
+                HW_Set_IF_Synthesizer(pObj, 0x140816);
+                HW_Set_IF_Synthesizer(pObj, 0x0c7000);
+                HW_Set_IF_Synthesizer(pObj, 0x1c0000);
+                HW_Set_IF_Synthesizer(pObj, 0x02ccae);
+                HW_Set_IF_Synthesizer(pObj, 0x128023);
+                HW_Set_IF_Synthesizer(pObj, 0x0a0000);
+                HW_Set_IF_Synthesizer(pObj, GRF5101T[ChannelNo]);
+                HW_Set_IF_Synthesizer(pObj, 0x06e380);
+                HW_Set_IF_Synthesizer(pObj, 0x16cb94);
+                HW_Set_IF_Synthesizer(pObj, 0x0e1740);
+                HW_Set_IF_Synthesizer(pObj, 0x014980);
+                HW_Set_IF_Synthesizer(pObj, 0x116240);
+                HW_Set_IF_Synthesizer(pObj, 0x090000);
+                HW_Set_IF_Synthesizer(pObj, 0x192304);
+                HW_Set_IF_Synthesizer(pObj, 0x05112f);
+                HW_Set_IF_Synthesizer(pObj, 0x0d54a8);
+                HW_Set_IF_Synthesizer(pObj, 0x0f8000);
+                HW_Set_IF_Synthesizer(pObj, 0x1c0008);
+                HW_Set_IF_Synthesizer(pObj, 0x1c0000);
+
+                HW_Set_IF_Synthesizer(pObj, GRF5101T[ChannelNo]);
+                HW_Set_IF_Synthesizer(pObj, 0x1c0008);
+                HW_Set_IF_Synthesizer(pObj, 0x150000);
+                HW_Set_IF_Synthesizer(pObj, 0x0c7000);
+                HW_Set_IF_Synthesizer(pObj, 0x150800);
+                HW_Set_IF_Synthesizer(pObj, 0x150000);
+        } else {
+                HW_Set_IF_Synthesizer(pObj, 0x1c0000);
+                HW_Set_IF_Synthesizer(pObj, GRF5101T[ChannelNo]);
+
+                HW_Set_IF_Synthesizer(pObj, 0x1c0008);
+        }
+}
+
+
+void
+HW_Set_AL2210MPVB_Chips(zd_80211Obj_t *pObj, U32 ChannelNo, U8 InitChOnly)
+{
+        void *reg = pObj->reg;
+        U32	tmpvalue;
+
+        pObj->SetReg(reg, ZD_PE1_PE2, 2);
+
+        if (!InitChOnly) {
+                LockPhyReg(pObj);
+                pObj->SetReg(reg, ZD_CR9, 0xe0);
+                pObj->SetReg(reg, ZD_CR10, 0x91);
+                pObj->SetReg(reg, ZD_CR12, 0x90);
+                pObj->SetReg(reg, ZD_CR15, 0xd0);
+                pObj->SetReg(reg, ZD_CR16, 0x40);
+                pObj->SetReg(reg, ZD_CR17, 0x58);
+                pObj->SetReg(reg, ZD_CR18, 0x04);
+                pObj->SetReg(reg, ZD_CR23, 0x66);
+                pObj->SetReg(reg, ZD_CR24, 0x14);
+                pObj->SetReg(reg, ZD_CR26, 0x90);
+                pObj->SetReg(reg, ZD_CR27, 0x30);
+                pObj->SetReg(reg, ZD_CR31, 0x80);
+                pObj->SetReg(reg, ZD_CR34, 0x06);
+                pObj->SetReg(reg, ZD_CR35, 0x3e);
+                pObj->SetReg(reg, ZD_CR38, 0x38);
+                pObj->SetReg(reg, ZD_CR46, 0x90);
+                pObj->SetReg(reg, ZD_CR47, 0x10);
+                pObj->SetReg(reg, ZD_CR64, 0x64);
+                pObj->SetReg(reg, ZD_CR79, 0xb5);
+                pObj->SetReg(reg, ZD_CR80, 0x38);
+                pObj->SetReg(reg, ZD_CR81, 0x30);
+                pObj->SetReg(reg, ZD_CR113, 0xc0);
+                pObj->SetReg(reg, ZD_CR127, 0x03);
+                UnLockPhyReg(pObj);
+
+                HW_Set_IF_Synthesizer(pObj, AL2210TB[ChannelNo]);
+                HW_Set_IF_Synthesizer(pObj, 0x00fcb1);
+                HW_Set_IF_Synthesizer(pObj, 0x358132);
+                HW_Set_IF_Synthesizer(pObj, 0x0108b3);
+                HW_Set_IF_Synthesizer(pObj, 0xc77804);
+                HW_Set_IF_Synthesizer(pObj, 0x456415);
+                HW_Set_IF_Synthesizer(pObj, 0xff2226);
+                HW_Set_IF_Synthesizer(pObj, 0x806667);
+                HW_Set_IF_Synthesizer(pObj, 0x7860f8);
+                HW_Set_IF_Synthesizer(pObj, 0xbb01c9);
+                HW_Set_IF_Synthesizer(pObj, 0x00000A);
+                HW_Set_IF_Synthesizer(pObj, 0x00000B);
+
+                LockPhyReg(pObj);
+                pObj->SetReg(reg, ZD_CR47, 0x0);
+                tmpvalue = pObj->GetReg(reg, ZD_RADIO_PD);
+
+                tmpvalue &= ~BIT_0;
+                pObj->SetReg(reg, ZD_RADIO_PD, tmpvalue);
+                tmpvalue |= BIT_0;
+                pObj->SetReg(reg, ZD_RADIO_PD, tmpvalue);
+                pObj->SetReg(reg, ZD_RFCFG, 0x5);
+                pObj->DelayUs(100);
+                pObj->SetReg(reg, ZD_RFCFG, 0x0);
+                pObj->SetReg(reg, ZD_CR47, 0x1c);
+                UnLockPhyReg(pObj);
+        } else {
+                LockPhyReg(pObj);
+                pObj->SetReg(reg, ZD_CR47, 0x0);
+                tmpvalue = pObj->GetReg(reg, ZD_RADIO_PD);
+                tmpvalue &= ~BIT_0;
+
+                pObj->SetReg(reg, ZD_RADIO_PD, tmpvalue);
+                tmpvalue |= BIT_0;
+
+
+
+                pObj->SetReg(reg, ZD_RADIO_PD, tmpvalue);
+                pObj->SetReg(reg, ZD_RFCFG, 0x5);
+                pObj->DelayUs(100);
+                pObj->SetReg(reg, ZD_RFCFG, 0x0);
+                pObj->SetReg(reg, ZD_CR47, 0x1c);
+                UnLockPhyReg(pObj);
+                HW_Set_IF_Synthesizer(pObj, AL2210TB[ChannelNo]);
+        }
+
+        pObj->SetReg(reg, ZD_PE1_PE2, 3);
+}
+
+
+void
+HW_Set_AL2210_Chips(zd_80211Obj_t *pObj, U32 ChannelNo, U8 InitChOnly)
+
+{
+        void *reg = pObj->reg;
+        U32	tmpvalue;
+
+        pObj->SetReg(reg, ZD_PE1_PE2, 2);
+
+        if (!InitChOnly) {
+                LockPhyReg(pObj);
+
+
+
+                pObj->SetReg(reg, ZD_CR9, 0xe0);
+                pObj->SetReg(reg, ZD_CR10, 0x91);
+                pObj->SetReg(reg, ZD_CR12, 0x90);
+                pObj->SetReg(reg, ZD_CR15, 0xd0);
+                pObj->SetReg(reg, ZD_CR16, 0x40);
+                pObj->SetReg(reg, ZD_CR17, 0x58);
+                pObj->SetReg(reg, ZD_CR18, 0x04);
+                pObj->SetReg(reg, ZD_CR23, 0x66);
+                pObj->SetReg(reg, ZD_CR24, 0x14);
+
+                pObj->SetReg(reg, ZD_CR26, 0x90);
+
+                pObj->SetReg(reg, ZD_CR31, 0x80);
+                pObj->SetReg(reg, ZD_CR34, 0x06);
+                pObj->SetReg(reg, ZD_CR35, 0x3e);
+                pObj->SetReg(reg, ZD_CR38, 0x38);
+                pObj->SetReg(reg, ZD_CR46, 0x90);
+                pObj->SetReg(reg, ZD_CR47, 0x10);
+                pObj->SetReg(reg, ZD_CR64, 0x64);
+                pObj->SetReg(reg, ZD_CR79, 0xb5);
+                pObj->SetReg(reg, ZD_CR80, 0x38);
+                pObj->SetReg(reg, ZD_CR81, 0x30);
+                pObj->SetReg(reg, ZD_CR113, 0xc0);
+                pObj->SetReg(reg, ZD_CR127, 0x3);
+                UnLockPhyReg(pObj);
+
+                HW_Set_IF_Synthesizer(pObj, AL2210TB[ChannelNo]);
+
+                HW_Set_IF_Synthesizer(pObj, 0x00fcb1);
+                HW_Set_IF_Synthesizer(pObj, 0x358132);
+                HW_Set_IF_Synthesizer(pObj, 0x0108b3);
+                HW_Set_IF_Synthesizer(pObj, 0xc77804);
+                HW_Set_IF_Synthesizer(pObj, 0x456415);
+                HW_Set_IF_Synthesizer(pObj, 0xff2226);
+                HW_Set_IF_Synthesizer(pObj, 0x806667);
+                HW_Set_IF_Synthesizer(pObj, 0x7860f8);
+                HW_Set_IF_Synthesizer(pObj, 0xbb01c9);
+                HW_Set_IF_Synthesizer(pObj, 0x00000A);
+                HW_Set_IF_Synthesizer(pObj, 0x00000B);
+
+                LockPhyReg(pObj);
+                pObj->SetReg(reg, ZD_CR47, 0x0);
+                tmpvalue = pObj->GetReg(reg, ZD_RADIO_PD);
+                tmpvalue &= ~BIT_0;
+                pObj->SetReg(reg, ZD_RADIO_PD, tmpvalue);
+
+                tmpvalue |= BIT_0;
+                pObj->SetReg(reg, ZD_RADIO_PD, tmpvalue);
+                pObj->SetReg(reg, ZD_RFCFG, 0x5);
+                pObj->DelayUs(100);
+                pObj->SetReg(reg, ZD_RFCFG, 0x0);
+                pObj->SetReg(reg, ZD_CR47, 0x1c);
+                UnLockPhyReg(pObj);
+        } else {
+                LockPhyReg(pObj);
+                pObj->SetReg(reg, ZD_CR47, 0x0);
+                tmpvalue = pObj->GetReg(reg, ZD_RADIO_PD);
+                tmpvalue &= ~BIT_0;
+                pObj->SetReg(reg, ZD_RADIO_PD, tmpvalue);
+                tmpvalue |= BIT_0;
+                pObj->SetReg(reg, ZD_RADIO_PD, tmpvalue);
+                pObj->SetReg(reg, ZD_RFCFG, 0x5);
+                pObj->DelayUs(100);
+                pObj->SetReg(reg, ZD_RFCFG, 0x0);
+                pObj->SetReg(reg, ZD_CR47, 0x1c);
+                UnLockPhyReg(pObj);
+                HW_Set_IF_Synthesizer(pObj, AL2210TB[ChannelNo]);
+        }
+
+        pObj->SetReg(reg, ZD_PE1_PE2, 3);
+}
+//------------------------------------------------------------------------------
+// Procedure:	 HW_Set_AL7230B_Chips
+//
+// Description:
+//
+// Arguments:
+//		Adapter - ptr to Adapter object instance
+//		ChannelNo
+//		Initial Channel only
+//
+// Returns:		(none)
+//
+// Note:
+//-------------------------------------------------------------------------------
+#ifndef ZD1211B
+// 1211
+void HW_Set_AL7230B_RF_Chips(zd_80211Obj_t *pObj, U32 ChannelNo, U8 InitChOnly, U8 MAC_Mode)
+{
+        void	*reg = pObj->reg;
+        U32		tmpvalue;
+        U32		ChannelNo_temp;
+        //int     i;
+        static u8 mOldMacMode = MIXED_MODE;
+        U16     WriteAddr[256];
+        U16     WriteData[256];
+        U16     WriteIndex = 0;
+
+        LockPhyReg(pObj);
+        pObj->SetReg(reg, ZD_CR240, 0x57);
+        UnLockPhyReg(pObj);
+
+        tmpvalue = pObj->GetReg(reg, CtlReg1);
+        tmpvalue &= ~0x80;
+        pObj->SetReg(reg, CtlReg1, tmpvalue);
+
+        if (!InitChOnly) {
+                mFILL_WRITE_REGISTER( ZD_CR15, 0x20);
+                mFILL_WRITE_REGISTER( ZD_CR23, 0x40);
+                mFILL_WRITE_REGISTER( ZD_CR24, 0x20);
+                mFILL_WRITE_REGISTER( ZD_CR26, 0x11);
+                mFILL_WRITE_REGISTER( ZD_CR28, 0x3e);
+                mFILL_WRITE_REGISTER( ZD_CR29, 0x00);
+                mFILL_WRITE_REGISTER( ZD_CR44, 0x33);
+                mFILL_WRITE_REGISTER( ZD_CR106, 0x22);  //from 0x2a to 0x22 for AL7230B
+                mFILL_WRITE_REGISTER( ZD_CR107, 0x1a);
+                mFILL_WRITE_REGISTER( ZD_CR109, 0x9);
+                mFILL_WRITE_REGISTER( ZD_CR110, 0x27);
+                mFILL_WRITE_REGISTER( ZD_CR111, 0x2b);
+                mFILL_WRITE_REGISTER( ZD_CR112, 0x2b);
+                mFILL_WRITE_REGISTER( ZD_CR119, 0xa);
+                mFILL_WRITE_REGISTER( ZD_CR122, 0xfc); //from /e0 to fc for AL7230B
+                mFILL_WRITE_REGISTER( ZD_CR10, 0x89);
+                mFILL_WRITE_REGISTER( ZD_CR17, 0x28);
+                mFILL_WRITE_REGISTER( ZD_CR26, 0x93);
+                mFILL_WRITE_REGISTER( ZD_CR34, 0x30);
+                mFILL_WRITE_REGISTER( ZD_CR35, 0x3E);
+                mFILL_WRITE_REGISTER( ZD_CR41, 0x24);
+                mFILL_WRITE_REGISTER( ZD_CR44, 0x32);
+                mFILL_WRITE_REGISTER( ZD_CR46, 0x96);
+                mFILL_WRITE_REGISTER( ZD_CR47, 0x1e);
+                mFILL_WRITE_REGISTER( ZD_CR79, 0x58);
+                mFILL_WRITE_REGISTER( ZD_CR80, 0x30);
+                mFILL_WRITE_REGISTER( ZD_CR81, 0x30);
+                mFILL_WRITE_REGISTER( ZD_CR87, 0x0A);
+                mFILL_WRITE_REGISTER( ZD_CR89, 0x04);
+                mFILL_WRITE_REGISTER( ZD_CR92, 0x0a);
+                mFILL_WRITE_REGISTER( ZD_CR99, 0x28);
+                mFILL_WRITE_REGISTER( ZD_CR100, 0x02);
+                mFILL_WRITE_REGISTER( ZD_CR101, 0x13);
+                mFILL_WRITE_REGISTER( ZD_CR102, 0x27);
+                mFILL_WRITE_REGISTER( ZD_CR106, 0x22); //from 0x20 to 0x22 for AL7230B
+                mFILL_WRITE_REGISTER( ZD_CR107, 0x3f);
+                mFILL_WRITE_REGISTER( ZD_CR109, 0x09);
+                mFILL_WRITE_REGISTER( ZD_CR110, 0x1f);
+                mFILL_WRITE_REGISTER( ZD_CR111, 0x1f);
+                mFILL_WRITE_REGISTER( ZD_CR112, 0x1f);
+                mFILL_WRITE_REGISTER( ZD_CR113, 0x27);
+                mFILL_WRITE_REGISTER( ZD_CR114, 0x27);
+                mFILL_WRITE_REGISTER( ZD_CR115, 0x24);
+                mFILL_WRITE_REGISTER( ZD_CR116, 0x3f);
+                mFILL_WRITE_REGISTER( ZD_CR117, 0xfa);
+                mFILL_WRITE_REGISTER( ZD_CR118, 0xfc);
+                mFILL_WRITE_REGISTER( ZD_CR119, 0x10);
+                mFILL_WRITE_REGISTER( ZD_CR120, 0x4f);
+                mFILL_WRITE_REGISTER( ZD_CR121, 0x77);
+                mFILL_WRITE_REGISTER( ZD_CR137, 0x88);
+                mFILL_WRITE_REGISTER( ZD_CR138, 0xa8);
+                mFILL_WRITE_REGISTER( ZD_CR252, 0x34);
+                mFILL_WRITE_REGISTER( ZD_CR253, 0x34);
+                // mFILL_WRITE_REGISTER( ZD_CR240, 0x57);
+
+                if( MAC_Mode != PURE_A_MODE ) {
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x2f);  //PLL_OFF
+                        SET_IF_SYNTHESIZER(macp, AL7230BTB[ChannelNo*2]);
+                        SET_IF_SYNTHESIZER(macp, AL7230BTB[ChannelNo*2+1]);
+                        //SET_IF_SYNTHESIZER(macp, 0x8cccd0);
+                        SET_IF_SYNTHESIZER(macp, 0x4ff821);
+                        SET_IF_SYNTHESIZER(macp, 0xc5fbfc);
+                        SET_IF_SYNTHESIZER(macp, 0x21ebfe);
+                        SET_IF_SYNTHESIZER(macp, 0xaad401);
+                        SET_IF_SYNTHESIZER(macp, 0x6cf56a);
+                        SET_IF_SYNTHESIZER(macp, 0xe04073);
+                        SET_IF_SYNTHESIZER(macp, 0x193d76);
+                        SET_IF_SYNTHESIZER(macp, 0x9dd844);
+                        SET_IF_SYNTHESIZER(macp, 0x500007);
+                        SET_IF_SYNTHESIZER(macp, 0xd8c010);
+                        SET_IF_SYNTHESIZER(macp, 0x3c900);
+                        //Adapter->AL7230CCKSetFlag=0;
+                        SET_IF_SYNTHESIZER(macp, 0xbfffff);
+                        SET_IF_SYNTHESIZER(macp, 0x700000);
+                        SET_IF_SYNTHESIZER(macp, 0xf15d58);
+                        //AcquireCtrOfPhyReg(Adapter);
+                        //ZD1205_WRITE_REGISTER(Adapter, CR251, 0x2f);  //PLL_OFF
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x3f);  //PLL_ON
+                        mFILL_WRITE_REGISTER( ZD_CR128, 0x14);
+                        mFILL_WRITE_REGISTER( ZD_CR129, 0x12);
+                        mFILL_WRITE_REGISTER( ZD_CR130, 0x10);
+                        mFILL_WRITE_REGISTER( ZD_CR38, 0x38);
+                        mFILL_WRITE_REGISTER( ZD_CR136, 0xdf);
+                        ///ZD1211_WRITE_MULTI_REG(Adapter, WriteAddr, WriteData, &WriteIndex);
+                        ///NdisStallExecution(1000);
+                        SET_IF_SYNTHESIZER(macp, 0xf15d59);
+                        ///ZD1211_WRITE_MULTI_REG(Adapter, WriteAddr, WriteData, &WriteIndex);
+                        ///NdisStallExecution(10000);
+                        SET_IF_SYNTHESIZER(macp, 0xf15d5c);
+                        ///ZD1211_WRITE_MULTI_REG(Adapter, WriteAddr, WriteData, &WriteIndex);
+                        ///NdisStallExecution(10000);
+                        SET_IF_SYNTHESIZER(macp, 0xf15d58);
+                } else {
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x2f); // shdnb(PLL_ON)=0
+                        if((34 <= ChannelNo) && (ChannelNo <= 48)) {
+                                ChannelNo_temp=(ChannelNo/2)-13;
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4]);
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+1]);
+                        } else {
+                                ChannelNo_temp=(ChannelNo/4)-1;
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4]);
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+1]);
+                        }
+                        SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+3]);
+                        SET_IF_SYNTHESIZER(macp, 0x47f8a2);
+                        SET_IF_SYNTHESIZER(macp, 0xc5fbfa);
+                        //SET_IF_SYNTHESIZER(macp, 0x21ebf6);
+                        SET_IF_SYNTHESIZER(macp, 0xaafca1);
+                        SET_IF_SYNTHESIZER(macp, 0x6cf56a);
+                        SET_IF_SYNTHESIZER(macp, 0xe04073);
+                        SET_IF_SYNTHESIZER(macp, 0x193d76);
+                        SET_IF_SYNTHESIZER(macp, 0x9dd844);
+                        SET_IF_SYNTHESIZER(macp, 0x500607);
+                        SET_IF_SYNTHESIZER(macp, 0xd8c010);
+                        if((48 < ChannelNo) && (ChannelNo < 184)) {
+                                SET_IF_SYNTHESIZER(macp, 0x3c2800);
+                        } else {
+                                SET_IF_SYNTHESIZER(macp, 0x3e2800);
+                        }
+                        SET_IF_SYNTHESIZER(macp, 0xbfffff);
+                        SET_IF_SYNTHESIZER(macp, 0x700000);
+                        SET_IF_SYNTHESIZER(macp, 0xf35d48);
+                        //AcquireCtrOfPhyReg(Adapter);
+                        //ZD1205_WRITE_REGISTER(Adapter, CR251, 0x2f); // shdnb(PLL_ON)=0
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x3f); // shdnb(PLL_ON)=1
+                        mFILL_WRITE_REGISTER( ZD_CR128, 0x12);
+                        mFILL_WRITE_REGISTER( ZD_CR129, 0x10);
+                        mFILL_WRITE_REGISTER( ZD_CR130, 0x10);
+                        mFILL_WRITE_REGISTER( ZD_CR38, 0x7f);
+                        mFILL_WRITE_REGISTER( ZD_CR136, 0x5f);
+                        ///ZD1211_WRITE_MULTI_REG(Adapter, WriteAddr, WriteData, &WriteIndex);
+                        ///NdisStallExecution(1000);
+                        SET_IF_SYNTHESIZER(macp, 0xf15d59);
+                        ///ZD1211_WRITE_MULTI_REG(Adapter, WriteAddr, WriteData, &WriteIndex);
+                        ///NdisStallExecution(10000);
+                        SET_IF_SYNTHESIZER(macp, 0xf15d5c);
+                        ///ZD1211_WRITE_MULTI_REG(Adapter, WriteAddr, WriteData, &WriteIndex);
+                        ///NdisStallExecution(10000);
+                        SET_IF_SYNTHESIZER(macp, 0xf35d48);
+                }
+
+        } else {
+                if( MAC_Mode != PURE_A_MODE ) {
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x2f);  //PLL_OFF
+                        //SET_IF_SYNTHESIZER(macp, 0x0b3331);
+                        if ( 1 || mOldMacMode != MAC_Mode ) {
+                                SET_IF_SYNTHESIZER(macp, 0x4ff821);
+                                SET_IF_SYNTHESIZER(macp, 0xc5fbfc);
+                                SET_IF_SYNTHESIZER(macp, 0x21ebfe);
+                                SET_IF_SYNTHESIZER(macp, 0xaad401);
+                                SET_IF_SYNTHESIZER(macp, 0x6cf56a);
+                                SET_IF_SYNTHESIZER(macp, 0xe04073);
+                                SET_IF_SYNTHESIZER(macp, 0x193d76);
+                                SET_IF_SYNTHESIZER(macp, 0x9dd844);
+                                SET_IF_SYNTHESIZER(macp, 0x500007);
+                                SET_IF_SYNTHESIZER(macp, 0xd8c010);
+                                SET_IF_SYNTHESIZER(macp, 0x3c9000);
+                                SET_IF_SYNTHESIZER(macp, 0xf15d58);
+
+                                mFILL_WRITE_REGISTER( ZD_CR128, 0x14);
+                                mFILL_WRITE_REGISTER( ZD_CR129, 0x12);
+                                mFILL_WRITE_REGISTER( ZD_CR130, 0x10);
+                                mFILL_WRITE_REGISTER( ZD_CR38, 0x38);
+                                mFILL_WRITE_REGISTER( ZD_CR136, 0xdf);
+                                mOldMacMode = MAC_Mode;
+                        }
+                        //Adapter->AL7230CCKSetFlag=0;
+                        SET_IF_SYNTHESIZER(macp, AL7230BTB[ChannelNo*2]);
+                        SET_IF_SYNTHESIZER(macp, AL7230BTB[ChannelNo*2+1]);
+                        SET_IF_SYNTHESIZER(macp, 0x3c9000);
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x3f);  //PLL_ON
+                } else {
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x2f); // shdnb(PLL_ON)=0
+
+                        if ( 1 || mOldMacMode != MAC_Mode ) {
+                                SET_IF_SYNTHESIZER(macp, 0x47f8a2);
+                                SET_IF_SYNTHESIZER(macp, 0xc5fbfa);
+                                SET_IF_SYNTHESIZER(macp, 0xaafca1);
+                                SET_IF_SYNTHESIZER(macp, 0x6cf56a);
+                                SET_IF_SYNTHESIZER(macp, 0xe04073);
+                                SET_IF_SYNTHESIZER(macp, 0x193d76);
+                                SET_IF_SYNTHESIZER(macp, 0x9dd844);
+                                SET_IF_SYNTHESIZER(macp, 0x500607);
+                                SET_IF_SYNTHESIZER(macp, 0xd8c010);
+                                SET_IF_SYNTHESIZER(macp, 0xf35d48);
+                                mFILL_WRITE_REGISTER( ZD_CR128, 0x12);
+                                mFILL_WRITE_REGISTER( ZD_CR129, 0x10);
+                                mFILL_WRITE_REGISTER( ZD_CR130, 0x10);
+                                mFILL_WRITE_REGISTER( ZD_CR38, 0x7f);
+                                mFILL_WRITE_REGISTER( ZD_CR136, 0x5f);
+                                mOldMacMode = MAC_Mode;
+                        }
+
+                        if((48 < ChannelNo) && (ChannelNo < 184)) {
+                                SET_IF_SYNTHESIZER(macp, 0x3c2800);
+                        } else {
+                                SET_IF_SYNTHESIZER(macp, 0x3e2800);
+                        }
+
+                        if((34 <= ChannelNo) && (ChannelNo <= 48)) {
+                                ChannelNo_temp=(ChannelNo/2)-13;
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4]);
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+1]);
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+3]);
+                        } else {
+                                ChannelNo_temp=(ChannelNo/4)-1;
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4]);
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+1]);
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+3]);
+                        }
+
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x3f);  //PLL_ON
+                }
+
+        }
+
+        mFILL_WRITE_REGISTER( ZD_CR203, 0x06);
+        ZD1211_WRITE_MULTI_REG(WriteAddr, WriteData, &WriteIndex);
+
+
+
+        tmpvalue = pObj->GetReg(reg, CtlReg1);
+        tmpvalue |= ~0x80;
+        pObj->SetReg(reg, CtlReg1, tmpvalue);
+
+        LockPhyReg(pObj);
+        pObj->SetReg(reg, ZD_CR240, 0x80);
+        UnLockPhyReg(pObj);
+
+        pObj->CR203Flag = 2;
+        //	pObj->CR31Flag = 2;
+        //   macp->PHY_G_6M_BandEdge_Flag = 0;
+        //	if(macp->PHY_36M_Setpoint_Flag != 0)
+        //	{
+        //		for(i=0;i<16;i++)
+        //			macp->a_Calibration_Data[2][i] = macp->PHY_36M_A_Calibration_Setpoint[i];
+        //		for(i=0;i<32;i++)
+        //			macp->a_Interpolation_Data[2][i] = macp->PHY_36M_A_Interpolation_Setpoint[i];
+        //		macp->PHY_36M_Setpoint_Flag = 0;
+        //	}
+
+}
+#else
+// 1215
+void HW_Set_AL7230B_RF_Chips(zd_80211Obj_t *pObj, U32 ChannelNo, U8 InitChOnly, U8 MAC_Mode)
+{
+        void	*reg = pObj->reg;
+        U32		tmpvalue;
+        U32		ChannelNo_temp;
+        int     i;
+        static  u8 mOldMacMode = MIXED_MODE;
+        U16     WriteAddr[256];
+        U16     WriteData[256];
+        U16     WriteIndex = 0;
+
+        LockPhyReg(pObj);
+        pObj->SetReg(reg, ZD_CR240, 0x57);
+        pObj->SetReg(reg, ZD_CR9, 0xe0);
+        UnLockPhyReg(pObj);
+
+        tmpvalue = pObj->GetReg(reg, CtlReg1);
+        tmpvalue &= ~0x80;
+        pObj->SetReg(reg, CtlReg1, tmpvalue);
+
+
+        if (!InitChOnly) {
+                //mFILL_WRITE_REGISTER( ZD_CR9, 0xe0);//5119
+                mFILL_WRITE_REGISTER( ZD_CR10, 0x89);
+                mFILL_WRITE_REGISTER( ZD_CR15, 0x20);
+                mFILL_WRITE_REGISTER( ZD_CR17, 0x2B);//for newest(3rd cut)AL2230
+                mFILL_WRITE_REGISTER( ZD_CR20, 0x10);//4N25->Stone Request
+                mFILL_WRITE_REGISTER( ZD_CR23, 0x40);
+                mFILL_WRITE_REGISTER( ZD_CR24, 0x20);
+                mFILL_WRITE_REGISTER( ZD_CR26, 0x93);
+                mFILL_WRITE_REGISTER( ZD_CR28, 0x3e);
+                mFILL_WRITE_REGISTER( ZD_CR29, 0x00);
+                mFILL_WRITE_REGISTER( ZD_CR33, 0x28);	//5613
+                mFILL_WRITE_REGISTER( ZD_CR34, 0x30);
+                mFILL_WRITE_REGISTER( ZD_CR35, 0x3e);  //for newest(3rd cut) AL2230
+                mFILL_WRITE_REGISTER( ZD_CR41, 0x24);
+                mFILL_WRITE_REGISTER( ZD_CR44, 0x32);
+                mFILL_WRITE_REGISTER( ZD_CR46, 0x99);  //for newest(3rd cut) AL2230
+                mFILL_WRITE_REGISTER( ZD_CR47, 0x1e);
+                mFILL_WRITE_REGISTER( ZD_CR48, 0x00);	//ZD1215 5610
+                mFILL_WRITE_REGISTER( ZD_CR49, 0x00);	//ZD1215 5610
+                mFILL_WRITE_REGISTER( ZD_CR51, 0x01);	//ZD1215 5610
+                mFILL_WRITE_REGISTER( ZD_CR52, 0x80);	//ZD1215 5610
+                mFILL_WRITE_REGISTER( ZD_CR53, 0x7e);	//ZD1215 5610
+                mFILL_WRITE_REGISTER( ZD_CR65, 0x00);	//ZD1215 5610
+                mFILL_WRITE_REGISTER( ZD_CR66, 0x00);	//ZD1215 5610
+                mFILL_WRITE_REGISTER( ZD_CR67, 0x00);	//ZD1215 5610
+                mFILL_WRITE_REGISTER( ZD_CR68, 0x00);	//ZD1215 5610
+                mFILL_WRITE_REGISTER( ZD_CR69, 0x28);	//ZD1215 5610
+                mFILL_WRITE_REGISTER( ZD_CR79, 0x58);
+                mFILL_WRITE_REGISTER( ZD_CR80, 0x30);
+                mFILL_WRITE_REGISTER( ZD_CR81, 0x30);
+                mFILL_WRITE_REGISTER( ZD_CR87, 0x0A);
+                mFILL_WRITE_REGISTER( ZD_CR89, 0x04);
+                mFILL_WRITE_REGISTER( ZD_CR90, 0x58);  //5112
+                mFILL_WRITE_REGISTER( ZD_CR91, 0x00);  //5613
+                mFILL_WRITE_REGISTER( ZD_CR92, 0x0a);
+                mFILL_WRITE_REGISTER( ZD_CR98, 0x8d);  //4804, for 1212 new algorithm
+                mFILL_WRITE_REGISTER( ZD_CR99, 0x00);
+                mFILL_WRITE_REGISTER( ZD_CR100, 0x02);
+                mFILL_WRITE_REGISTER( ZD_CR101, 0x13);
+                mFILL_WRITE_REGISTER( ZD_CR102, 0x27);
+                mFILL_WRITE_REGISTER( ZD_CR106, 0x20);	// change to 0x24 for AL7230B
+                mFILL_WRITE_REGISTER( ZD_CR107, 0x28);
+                mFILL_WRITE_REGISTER( ZD_CR109, 0x13);  //4804, for 1212 new algorithm
+                mFILL_WRITE_REGISTER( ZD_CR110, 0x1f);  //5127, 0x13->0x1f
+                mFILL_WRITE_REGISTER( ZD_CR111, 0x1f);  //0x13 to 0x1f for AL7230B
+                mFILL_WRITE_REGISTER( ZD_CR112, 0x1f);
+                mFILL_WRITE_REGISTER( ZD_CR113, 0x27);
+                mFILL_WRITE_REGISTER( ZD_CR114, 0x27);
+                mFILL_WRITE_REGISTER( ZD_CR115, 0x24);
+                mFILL_WRITE_REGISTER( ZD_CR116, 0x2a);
+                mFILL_WRITE_REGISTER( ZD_CR117, 0xfa);
+                mFILL_WRITE_REGISTER( ZD_CR118, 0xfa);
+                mFILL_WRITE_REGISTER( ZD_CR119, 0x12);
+                mFILL_WRITE_REGISTER( ZD_CR120, 0x4f);
+                mFILL_WRITE_REGISTER( ZD_CR121, 0x6c);  //5613
+                mFILL_WRITE_REGISTER( ZD_CR122, 0xfc);  // E0->FCh at 4901
+                mFILL_WRITE_REGISTER( ZD_CR123, 0x57);  //5613
+                mFILL_WRITE_REGISTER( ZD_CR125, 0xad);  //4804, for 1212 new algorithm
+                mFILL_WRITE_REGISTER( ZD_CR126, 0x6c);  //5613
+                mFILL_WRITE_REGISTER( ZD_CR127, 0x03);  //4804, for 1212 new algorithm
+                mFILL_WRITE_REGISTER( ZD_CR130, 0x10);
+                mFILL_WRITE_REGISTER( ZD_CR131, 0x00);	 //5112
+                mFILL_WRITE_REGISTER( ZD_CR137, 0x50);	 //5613
+                mFILL_WRITE_REGISTER( ZD_CR138, 0xa8);  //5112
+                mFILL_WRITE_REGISTER( ZD_CR144, 0xac);  //5613
+                mFILL_WRITE_REGISTER( ZD_CR148, 0x40);	 //5112
+                mFILL_WRITE_REGISTER( ZD_CR149, 0x40);  //4O07, 50->40
+                mFILL_WRITE_REGISTER( ZD_CR150, 0x1a);  //5112, 0C->1A
+
+
+                mFILL_WRITE_REGISTER( ZD_CR252, 0x34);
+                mFILL_WRITE_REGISTER( ZD_CR253, 0x34);
+                //mFILL_WRITE_REGISTER( ZD_CR240, 0x57);
+                if( MAC_Mode != PURE_A_MODE ) {
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x2f);  //PLL_OFF
+                        SET_IF_SYNTHESIZER(macp, AL7230BTB[ChannelNo*2]);
+                        SET_IF_SYNTHESIZER(macp, AL7230BTB[ChannelNo*2+1]);
+                        //SET_IF_SYNTHESIZER(macp, 0x8cccd0);
+                        SET_IF_SYNTHESIZER(macp, 0x4ff821);
+                        SET_IF_SYNTHESIZER(macp, 0xc5fbfc);
+                        SET_IF_SYNTHESIZER(macp, 0x21ebfe);
+                        SET_IF_SYNTHESIZER(macp, 0xaad401);
+                        SET_IF_SYNTHESIZER(macp, 0x6cf56a);
+                        SET_IF_SYNTHESIZER(macp, 0xe04073);
+                        SET_IF_SYNTHESIZER(macp, 0x190d76);
+                        SET_IF_SYNTHESIZER(macp, 0x9dd844);
+                        SET_IF_SYNTHESIZER(macp, 0x500007);
+                        SET_IF_SYNTHESIZER(macp, 0xd8c010);
+                        SET_IF_SYNTHESIZER(macp, 0x3c900);
+                        //Adapter->AL7230CCKSetFlag=0;
+                        SET_IF_SYNTHESIZER(macp, 0xbfffff);
+                        SET_IF_SYNTHESIZER(macp, 0x700000);
+                        SET_IF_SYNTHESIZER(macp, 0xf15d58);
+                        //AcquireCtrOfPhyReg(Adapter);
+                        //mFILL_WRITE_REGISTER( ZD_CR251, 0x2f);  //PLL_OFF
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x7f);  //PLL_ON
+                        mFILL_WRITE_REGISTER( ZD_CR128, 0x14);
+                        mFILL_WRITE_REGISTER( ZD_CR129, 0x12);
+                        mFILL_WRITE_REGISTER( ZD_CR130, 0x10);
+                        mFILL_WRITE_REGISTER( ZD_CR38, 0x38);
+                        mFILL_WRITE_REGISTER( ZD_CR136, 0xdf);
+                        //NdisStallExecution(1000);
+                        SET_IF_SYNTHESIZER(macp, 0xf15d59);
+                        //NdisStallExecution(10000);
+                        SET_IF_SYNTHESIZER(macp, 0xf15d5c);
+                        //NdisStallExecution(10000);
+                        SET_IF_SYNTHESIZER(macp, 0xf15d58);
+                } else {
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x2f); // shdnb(PLL_ON)=0
+                        if((34 <= ChannelNo) && (ChannelNo <= 48)) {
+                                ChannelNo_temp=(ChannelNo/2)-13;
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4]);
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+1]);
+                        } else {
+                                ChannelNo_temp=(ChannelNo/4)-1;
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4]);
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+1]);
+                        }
+                        SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+3]);
+                        SET_IF_SYNTHESIZER(macp, 0x47f8a2);
+                        SET_IF_SYNTHESIZER(macp, 0xc5fbfa);
+                        //SET_IF_SYNTHESIZER(macp, 0x21ebf6);
+                        SET_IF_SYNTHESIZER(macp, 0xaafca1);
+                        SET_IF_SYNTHESIZER(macp, 0x6cf56a);
+                        SET_IF_SYNTHESIZER(macp, 0xe04073);
+                        SET_IF_SYNTHESIZER(macp, 0x190d36);
+                        SET_IF_SYNTHESIZER(macp, 0x9dd844);
+                        SET_IF_SYNTHESIZER(macp, 0x500607);
+                        SET_IF_SYNTHESIZER(macp, 0xd8c010);
+                        if((48 < ChannelNo) && (ChannelNo < 184)) {
+                                SET_IF_SYNTHESIZER(macp, 0x3c2800);
+                        } else {
+                                SET_IF_SYNTHESIZER(macp, 0x3e2800);
+                        }
+                        SET_IF_SYNTHESIZER(macp, 0xbfffff);
+                        SET_IF_SYNTHESIZER(macp, 0x700000);
+                        SET_IF_SYNTHESIZER(macp, 0xf35d48);
+                        //AcquireCtrOfPhyReg(Adapter);
+                        //mFILL_WRITE_REGISTER( ZD_CR251, 0x2f); // shdnb(PLL_ON)=0
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x7f); // shdnb(PLL_ON)=1
+                        mFILL_WRITE_REGISTER( ZD_CR128, 0x12);
+                        mFILL_WRITE_REGISTER( ZD_CR129, 0x10);
+                        mFILL_WRITE_REGISTER( ZD_CR130, 0x10);
+                        mFILL_WRITE_REGISTER( ZD_CR38, 0x7f);
+                        mFILL_WRITE_REGISTER( ZD_CR136, 0x5f);
+                        //mFILL_WRITE_REGISTER( ZD_CR31, 0x58);
+
+                        //NdisStallExecution(1000);
+                        SET_IF_SYNTHESIZER(macp, 0xf15d59);
+                        //NdisStallExecution(10000);
+                        SET_IF_SYNTHESIZER(macp, 0xf15d5c);
+                        //NdisStallExecution(10000);
+                        SET_IF_SYNTHESIZER(macp, 0xf35d48);
+                }
+
+        } else {
+                if( MAC_Mode != PURE_A_MODE ) {
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x2f);  //PLL_OFF
+                        //SET_IF_SYNTHESIZER(macp, 0x8cccd0);
+                        if ( 1 || mOldMacMode != MAC_Mode ) {
+                                SET_IF_SYNTHESIZER(macp, 0x4ff821);
+                                SET_IF_SYNTHESIZER(macp, 0xc5fbfc);
+                                SET_IF_SYNTHESIZER(macp, 0x21ebfe);
+                                SET_IF_SYNTHESIZER(macp, 0xaad401);
+                                SET_IF_SYNTHESIZER(macp, 0x6cf56a);
+                                SET_IF_SYNTHESIZER(macp, 0xe04073);
+                                SET_IF_SYNTHESIZER(macp, 0x190d76);
+                                SET_IF_SYNTHESIZER(macp, 0x9dd844);
+                                SET_IF_SYNTHESIZER(macp, 0x500007);
+                                SET_IF_SYNTHESIZER(macp, 0xd8c010);
+                                SET_IF_SYNTHESIZER(macp, 0x3c9000);
+                                SET_IF_SYNTHESIZER(macp, 0xf15d58);
+                                //AcquireCtrOfPhyReg(Adapter);
+                                //mFILL_WRITE_REGISTER( ZD_CR251, 0x2f);  //PLL_OFF
+                                //mFILL_WRITE_REGISTER( ZD_CR251, 0x3f);  //PLL_ON
+                                mFILL_WRITE_REGISTER( ZD_CR128, 0x14);
+                                mFILL_WRITE_REGISTER( ZD_CR129, 0x12);
+                                mFILL_WRITE_REGISTER( ZD_CR130, 0x10);
+                                mFILL_WRITE_REGISTER( ZD_CR38, 0x38);
+                                mFILL_WRITE_REGISTER( ZD_CR136, 0xdf);
+                                mOldMacMode = MAC_Mode;
+                        }
+                        //Adapter->AL7230CCKSetFlag=0;
+                        SET_IF_SYNTHESIZER(macp, AL7230BTB[ChannelNo*2]);
+                        SET_IF_SYNTHESIZER(macp, AL7230BTB[ChannelNo*2+1]);
+                        SET_IF_SYNTHESIZER(macp, 0x3c9000);
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x7f);  //PLL_ON
+
+                        //NdisStallExecution(10);
+                        //SET_IF_SYNTHESIZER(macp, 0xf15d59);
+                        //NdisStallExecution(100);
+                        //SET_IF_SYNTHESIZER(macp, 0xf15d5c);
+                        //NdisStallExecution(100);
+                        //SET_IF_SYNTHESIZER(macp, 0xf15d58);
+                } else {
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x2f); // shdnb(PLL_ON)=0
+
+                        if ( 1 || mOldMacMode != MAC_Mode ) {
+                                SET_IF_SYNTHESIZER(macp, 0x47f8a2);
+                                SET_IF_SYNTHESIZER(macp, 0xc5fbfa);
+                                //SET_IF_SYNTHESIZER(macp, 0x21ebf6);
+                                SET_IF_SYNTHESIZER(macp, 0xaafca1);
+                                SET_IF_SYNTHESIZER(macp, 0x6cf56a);
+                                SET_IF_SYNTHESIZER(macp, 0xe04073);
+                                SET_IF_SYNTHESIZER(macp, 0x190d36);
+                                SET_IF_SYNTHESIZER(macp, 0x9dd844);
+                                SET_IF_SYNTHESIZER(macp, 0x500607);
+                                SET_IF_SYNTHESIZER(macp, 0xd8c010);
+                                SET_IF_SYNTHESIZER(macp, 0xf35d48);
+                                //AcquireCtrOfPhyReg(Adapter);
+                                //mFILL_WRITE_REGISTER( ZD_CR251, 0x2f); // shdnb(PLL_ON)=0
+                                //mFILL_WRITE_REGISTER( ZD_CR251, 0x3f); // shdnb(PLL_ON)=1
+                                mFILL_WRITE_REGISTER( ZD_CR128, 0x12);
+                                mFILL_WRITE_REGISTER( ZD_CR129, 0x10);
+                                mFILL_WRITE_REGISTER( ZD_CR130, 0x10);
+                                mFILL_WRITE_REGISTER( ZD_CR38, 0x7f);
+                                mFILL_WRITE_REGISTER( ZD_CR136, 0x5f);
+                                mOldMacMode = MAC_Mode;
+                        }
+                        if((48 < ChannelNo) && (ChannelNo < 184)) {
+                                SET_IF_SYNTHESIZER(macp, 0x3c2800);
+                        } else {
+                                SET_IF_SYNTHESIZER(macp, 0x3e2800);
+                        }
+                        if((34 <= ChannelNo) && (ChannelNo <= 48)) {
+                                ChannelNo_temp=(ChannelNo/2)-13;
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4]);
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+1]);
+                                //SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+2]);
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+3]);
+                                // SET_IF_SYNTHESIZER(macp, 0x3c2800);
+                        } else {
+                                ChannelNo_temp=(ChannelNo/4)-1;
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4]);
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+1]);
+                                //SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+2]);
+                                SET_IF_SYNTHESIZER(macp, AL7230BTB_a[ChannelNo_temp*4+3]);
+                                //SET_IF_SYNTHESIZER(macp, 0x3c2800);
+                        }
+                        mFILL_WRITE_REGISTER( ZD_CR251, 0x7f);  //PLL_ON
+                        //ZD1205_WRITE_REGISTER(Adapter, CR31, 0x58);
+
+                        //NdisStallExecution(10);
+                        //SET_IF_SYNTHESIZER(macp, 0xf15d59);
+                        //NdisStallExecution(100);
+                        //SET_IF_SYNTHESIZER(macp, 0xf15d5c);
+                        //NdisStallExecution(100);
+                        //SET_IF_SYNTHESIZER(macp, 0xf35d58);
+                }
+
+        }
+        //ZD1205_WRITE_REGISTER(Adapter,CR138, 0x28);
+        mFILL_WRITE_REGISTER( ZD_CR203, 0x06);
+        ZD1211_WRITE_MULTI_REG(WriteAddr, WriteData, &WriteIndex);
+
+        tmpvalue = pObj->GetReg(reg, CtlReg1);
+        tmpvalue |= ~0x80;
+        pObj->SetReg(reg, CtlReg1, tmpvalue);
+
+        LockPhyReg(pObj);
+        pObj->SetReg(reg, ZD_CR240, 0x80);
+        //if(macp->PHYNEWLayout)
+        //	pObj->SetReg(reg, ZD_CR9, 0xe1);
+        pObj->SetReg(reg, ZD_CR203, 0x06);
+        UnLockPhyReg(pObj);
+
+
+        pObj->CR203Flag = 2;
+        pObj->CR31Flag = 2;
+
+        //	macp->Change_SetPoint = 2;
+        //	macp->PHY_G_6M_BandEdge_Flag = 0;
+        //	if(macp->PHY_36M_Setpoint_Flag != 0)
+        //	{
+        //for(i=0;i<14;i++)
+        //	macp->SetPointOFDM[0][i] = macp->PHY_36M_G_Setpoint[i];
+        //		for(i=0;i<16;i++)
+        //			macp->a_Calibration_Data[2][i] = macp->PHY_36M_A_Calibration_Setpoint[i];
+        //		for(i=0;i<32;i++)
+        //			macp->a_Interpolation_Data[2][i] = macp->PHY_36M_A_Interpolation_Setpoint[i];
+        //		macp->PHY_36M_Setpoint_Flag = 0;
+        //	}
+
+
+#if !( (defined(OFDM) && defined(GCCK)) || defined(ECCK_60_5) )
+
+        pObj->SetReg(reg, ZD_PE1_PE2, 3);
+#endif
+
+}
+// end of AL7230B ZD1215
+#endif
+
+#ifdef ZD1211
+void
+HW_Set_AL2230_RF_Chips(zd_80211Obj_t *pObj, U32 ChannelNo, U8 InitChOnly)
+{
+
+        void *reg = pObj->reg;
+
+        LockPhyReg(pObj);
+#if !( (defined(OFDM) && defined(GCCK)) || defined(ECCK_60_5) )
+
+        pObj->SetReg(reg, ZD_PE1_PE2, 2);
+#else
+        //LockPhyReg(pObj);
+        //tmpvalue = pObj->GetReg(reg, ZD_CR203);
+        //pObj->SetReg(reg, ZD_CR203, tmpvalue);
+        //UnLockPhyReg(pObj);
+#endif
+
+        if (!InitChOnly) {
+                //LockPhyReg(pObj);
+#ifdef ZD1211B
+                pObj->SetReg(reg, ZD_CR10, 0x89);
+#endif
+
+                pObj->SetReg(reg, ZD_CR15, 0x20);
+#ifdef ZD1211B
+
+                pObj->SetReg(reg, ZD_CR17, 0x2B);
+#endif
+
+                pObj->SetReg(reg, ZD_CR23, 0x40);
+                pObj->SetReg(reg, ZD_CR24, 0x20);
+#ifdef ZD1211
+
+                pObj->SetReg(reg, ZD_CR26, 0x11);
+#elif defined(ZD1211B)
+
+                pObj->SetReg(reg, ZD_CR26, 0x93);
+#endif
+
+                pObj->SetReg(reg, ZD_CR28, 0x3e);
+                pObj->SetReg(reg, ZD_CR29, 0x00);
+#ifdef ZD1211B
+
+                pObj->SetReg(reg, ZD_CR33, 0x28);
+#elif defined(ZD1211)
+
+                pObj->SetReg(reg, ZD_CR44, 0x33);
+                pObj->SetReg(reg, ZD_CR106, 0x2a);
+                pObj->SetReg(reg, ZD_CR107, 0x1a);
+                pObj->SetReg(reg, ZD_CR109, 0x9);
+                pObj->SetReg(reg, ZD_CR110, 0x27);
+                pObj->SetReg(reg, ZD_CR111, 0x2b);
+                pObj->SetReg(reg, ZD_CR112, 0x2b);
+                pObj->SetReg(reg, ZD_CR119, 0xa);
+#endif
+
+#if (defined(GCCK) && defined(OFDM))
+
+                pObj->SetReg(reg, ZD_CR10, 0x89);
+                pObj->SetReg(reg, ZD_CR17, 0x28); //for newest (3rd cut) AL2300
+                pObj->SetReg(reg, ZD_CR26, 0x93);
+                pObj->SetReg(reg, ZD_CR34, 0x30);
+                pObj->SetReg(reg, ZD_CR35, 0x3E); //for newest (3rd cut) AL2300
+                pObj->SetReg(reg, ZD_CR41, 0x24);
+
+#ifdef HOST_IF_USB
+
+                pObj->SetReg(reg, ZD_CR44, 0x32);
+#else
+
+                pObj->SetReg(reg, ZD_CR44, 0x32);
+#endif
+
+                pObj->SetReg(reg, ZD_CR46, 0x96); //for newest (3rd cut) AL2300
+                pObj->SetReg(reg, ZD_CR47, 0x1e);
+#ifdef ZD1211B
+
+                pObj->SetReg(reg,ZD_CR48, 0x00);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR49, 0x00);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR51, 0x01);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR52, 0x80);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR53, 0x7e);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR65, 0x00);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR66, 0x00);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR67, 0x00);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR68, 0x00);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR69, 0x28);		//ZD1211B 05.06.10
+#endif
+
+                pObj->SetReg(reg, ZD_CR79, 0x58);
+                pObj->SetReg(reg, ZD_CR80, 0x30);
+                pObj->SetReg(reg, ZD_CR81, 0x30);
+                pObj->SetReg(reg, ZD_CR87, 0x0A);
+                pObj->SetReg(reg, ZD_CR89, 0x04);
+
+
+                pObj->SetReg(reg, ZD_CR92, 0x0a);
+                pObj->SetReg(reg, ZD_CR99, 0x28);
+                pObj->SetReg(reg, ZD_CR100, 0x00);
+                pObj->SetReg(reg, ZD_CR101, 0x13);
+                pObj->SetReg(reg, ZD_CR102, 0x27);
+                pObj->SetReg(reg, ZD_CR106, 0x24);
+                pObj->SetReg(reg, ZD_CR107, 0x2A);
+                pObj->SetReg(reg, ZD_CR109, 0x09);
+                pObj->SetReg(reg, ZD_CR110, 0x13);
+                pObj->SetReg(reg, ZD_CR111, 0x1f);
+                pObj->SetReg(reg, ZD_CR112, 0x1f);
+                pObj->SetReg(reg, ZD_CR113, 0x27);
+                pObj->SetReg(reg, ZD_CR114, 0x27);
+                pObj->SetReg(reg, ZD_CR115, 0x24); //for newest (3rd cut) AL2300
+                pObj->SetReg(reg, ZD_CR116, 0x24);
+#ifdef ZD1211
+
+                pObj->SetReg(reg, ZD_CR117, 0xf4);
+                pObj->SetReg(reg, ZD_CR118, 0xfc);
+#elif defined(ZD1211B)
+
+                pObj->SetReg(reg, ZD_CR117, 0xfa);
+                pObj->SetReg(reg, ZD_CR118, 0xfa);
+#endif
+
+                pObj->SetReg(reg, ZD_CR119, 0x10);
+                pObj->SetReg(reg, ZD_CR120, 0x4f);
+#ifdef ZD1211
+
+                pObj->SetReg(reg, ZD_CR121, 0x77);
+                pObj->SetReg(reg, ZD_CR122, 0xe0);
+#elif defined(ZD1211B)
+
+                pObj->SetReg(reg, ZD_CR121, 0x6c);
+                pObj->SetReg(reg, ZD_CR122, 0xfc);
+#endif
+
+                pObj->SetReg(reg, ZD_CR137, 0x88);
+#ifndef HOST_IF_USB
+
+                pObj->SetReg(reg, ZD_CR150, 0x0D);
+#endif
+#elif (defined(ECCK_60_5))
+
+                pObj->SetReg(reg, ZD_CR47, 0x18);
+                pObj->SetReg(reg, ZD_CR106, 0x04);
+                pObj->SetReg(reg, ZD_CR107, 0x00);
+                pObj->SetReg(reg, ZD_CR14, 0x80);
+                pObj->SetReg(reg, ZD_CR10, 0x89);
+                pObj->SetReg(reg, ZD_CR11, 0x00);
+                pObj->SetReg(reg, ZD_CR161, 0x28);
+                pObj->SetReg(reg, ZD_CR162, 0x26);
+
+                pObj->SetReg(reg, ZD_CR24, 0x0e);
+                pObj->SetReg(reg, ZD_CR41, 0x24);
+                pObj->SetReg(reg, ZD_CR159, 0x93);
+                pObj->SetReg(reg, ZD_CR160, 0xfc);
+                pObj->SetReg(reg, ZD_CR161, 0x20);
+                pObj->SetReg(reg, ZD_CR162, 0x26);
+#endif
+
+                pObj->SetReg(reg, ZD_CR252, 0xff);
+                pObj->SetReg(reg, ZD_CR253, 0xff);
+
+                //UnLockPhyReg(pObj);
+
+                HW_Set_IF_Synthesizer(pObj, AL2230TB[ChannelNo*3]);
+                HW_Set_IF_Synthesizer(pObj, AL2230TB[ChannelNo*3+1]);
+                HW_Set_IF_Synthesizer(pObj, AL2230TB[ChannelNo*3+2]);
+                HW_Set_IF_Synthesizer(pObj, 0x0b3331);
+                HW_Set_IF_Synthesizer(pObj, 0x03b812);
+                HW_Set_IF_Synthesizer(pObj, 0x00fff3);
+                HW_Set_IF_Synthesizer(pObj, 0x000da4);
+                HW_Set_IF_Synthesizer(pObj, 0x04edc5);
+                HW_Set_IF_Synthesizer(pObj, 0x0805b6);
+                HW_Set_IF_Synthesizer(pObj, 0x011687);
+                HW_Set_IF_Synthesizer(pObj, 0x000688);
+                HW_Set_IF_Synthesizer(pObj, 0x0403b9);   //External control TX power (CR31)
+                HW_Set_IF_Synthesizer(pObj, 0x00dbba);
+                HW_Set_IF_Synthesizer(pObj, 0x00099b);
+                HW_Set_IF_Synthesizer(pObj, 0x0bdffc);
+                HW_Set_IF_Synthesizer(pObj, 0x00000d);
+                HW_Set_IF_Synthesizer(pObj, 0x00500f);
+
+                //LockPhyReg(pObj);
+                pObj->SetReg(reg, ZD_CR251, 0x2f); // shdnb(PLL_ON)=0
+                pObj->SetReg(reg, ZD_CR251, 0x3f); // shdnb(PLL_ON)=1
+                pObj->DelayUs(10);
+                //UnLockPhyReg(pObj);
+                HW_Set_IF_Synthesizer(pObj, 0x000d00f);
+                pObj->DelayUs(100);
+                HW_Set_IF_Synthesizer(pObj, 0x0004c0f);
+                pObj->DelayUs(100);
+                HW_Set_IF_Synthesizer(pObj, 0x00540f);
+                pObj->DelayUs(100);
+                HW_Set_IF_Synthesizer(pObj, 0x00700f);
+                pObj->DelayUs(100);
+                HW_Set_IF_Synthesizer(pObj, 0x00500f);
+
+        } else {
+                HW_Set_IF_Synthesizer(pObj, AL2230TB[ChannelNo*3]);
+                HW_Set_IF_Synthesizer(pObj, AL2230TB[ChannelNo*3+1]);
+                HW_Set_IF_Synthesizer(pObj, AL2230TB[ChannelNo*3+2]);
+        }
+
+        //LockPhyReg(pObj);
+        pObj->SetReg(reg, ZD_CR138, 0x28);
+        pObj->SetReg(reg, ZD_CR203, 0x06);
+        //UnLockPhyReg(pObj);
+        pObj->CR203Flag = 2;
+        pObj->CR31Flag = 2;
+
+
+#if !( (defined(OFDM) && defined(GCCK)) || defined(ECCK_60_5) )
+
+        pObj->SetReg(reg, ZD_PE1_PE2, 3);
+#endif
+
+        UnLockPhyReg(pObj);
+}
+#elif defined(ZD1211B)
+void
+HW_Set_AL2230_RF_Chips(zd_80211Obj_t *pObj, U32 ChannelNo, U8 InitChOnly)
+{
+        //ZDMacLog("HW_Set_AL2230_RF_Chips\n");
+
+        void *reg = pObj->reg;
+
+        LockPhyReg(pObj);
+#if !( (defined(OFDM) && defined(GCCK)) || defined(ECCK_60_5) )
+
+        pObj->SetReg(reg, ZD_PE1_PE2, 2);
+#else
+//LockPhyReg(pObj);
+//tmpvalue = pObj->GetReg(reg, ZD_CR203);
+//pObj->SetReg(reg, ZD_CR203, tmpvalue);
+//UnLockPhyReg(pObj);
+#endif
+
+
+        //++
+#ifndef ZD1211B
+        //#ifndef ZD1211B        ->1211
+
+        if (!InitChOnly) {
+                //LockPhyReg(pObj);
+                pObj->SetReg(reg, ZD_CR15, 0x20);
+                pObj->SetReg(reg, ZD_CR23, 0x40);
+                pObj->SetReg(reg, ZD_CR24, 0x20);
+                pObj->SetReg(reg, ZD_CR26, 0x11);
+                pObj->SetReg(reg, ZD_CR28, 0x3e);
+                pObj->SetReg(reg, ZD_CR29, 0x00);
+                pObj->SetReg(reg, ZD_CR44, 0x33);
+                pObj->SetReg(reg, ZD_CR106, 0x2a);
+                pObj->SetReg(reg, ZD_CR107, 0x1a);
+                pObj->SetReg(reg, ZD_CR109, 0x9);
+                pObj->SetReg(reg, ZD_CR110, 0x27);
+                pObj->SetReg(reg, ZD_CR111, 0x2b);
+                pObj->SetReg(reg, ZD_CR112, 0x2b);
+                pObj->SetReg(reg, ZD_CR119, 0xa);
+#if (defined(GCCK) && defined(OFDM))
+
+                pObj->SetReg(reg, ZD_CR10, 0x89);
+                pObj->SetReg(reg, ZD_CR17, 0x28); //for newest (3rd cut) AL2300
+                pObj->SetReg(reg, ZD_CR26, 0x93);
+                pObj->SetReg(reg, ZD_CR34, 0x30);
+                pObj->SetReg(reg, ZD_CR35, 0x3E); //for newest (3rd cut) AL2300
+                pObj->SetReg(reg, ZD_CR41, 0x24);
+
+#ifdef HOST_IF_USB
+
+                pObj->SetReg(reg, ZD_CR44, 0x32);
+#else
+
+pObj->SetReg(reg, ZD_CR44, 0x32);
+#endif
+
+                pObj->SetReg(reg, ZD_CR46, 0x96); //for newest (3rd cut) AL2300
+                pObj->SetReg(reg, ZD_CR47, 0x1e);
+                pObj->SetReg(reg, ZD_CR79, 0x58);
+                pObj->SetReg(reg, ZD_CR80, 0x30);
+                pObj->SetReg(reg, ZD_CR81, 0x30);
+                pObj->SetReg(reg, ZD_CR87, 0x0A);
+                pObj->SetReg(reg, ZD_CR89, 0x04);
+
+
+                pObj->SetReg(reg, ZD_CR92, 0x0a);
+                pObj->SetReg(reg, ZD_CR99, 0x28);
+                pObj->SetReg(reg, ZD_CR100, 0x00);
+                pObj->SetReg(reg, ZD_CR101, 0x13);
+                pObj->SetReg(reg, ZD_CR102, 0x27);
+                pObj->SetReg(reg, ZD_CR106, 0x24);
+                pObj->SetReg(reg, ZD_CR107, 0x2A);
+                pObj->SetReg(reg, ZD_CR109, 0x09);
+                pObj->SetReg(reg, ZD_CR110, 0x13);
+                pObj->SetReg(reg, ZD_CR111, 0x1f);
+                pObj->SetReg(reg, ZD_CR112, 0x1f);
+                pObj->SetReg(reg, ZD_CR113, 0x27);
+                pObj->SetReg(reg, ZD_CR114, 0x27);
+                pObj->SetReg(reg, ZD_CR115, 0x24); //for newest (3rd cut) AL2300
+                pObj->SetReg(reg, ZD_CR116, 0x24);
+                pObj->SetReg(reg, ZD_CR117, 0xf4);
+                pObj->SetReg(reg, ZD_CR118, 0xfc);
+                pObj->SetReg(reg, ZD_CR119, 0x10);
+                pObj->SetReg(reg, ZD_CR120, 0x4f);
+                pObj->SetReg(reg, ZD_CR121, 0x77);
+                pObj->SetReg(reg, ZD_CR122, 0xe0);
+                pObj->SetReg(reg, ZD_CR137, 0x88);
+#ifndef HOST_IF_USB
+
+                pObj->SetReg(reg, ZD_CR150, 0x0D);
+#endif
+#elif (defined(ECCK_60_5))
+
+pObj->SetReg(reg, ZD_CR47, 0x18);
+pObj->SetReg(reg, ZD_CR106, 0x04);
+pObj->SetReg(reg, ZD_CR107, 0x00);
+pObj->SetReg(reg, ZD_CR14, 0x80);
+pObj->SetReg(reg, ZD_CR10, 0x89);
+pObj->SetReg(reg, ZD_CR11, 0x00);
+pObj->SetReg(reg, ZD_CR161, 0x28);
+pObj->SetReg(reg, ZD_CR162, 0x26);
+
+pObj->SetReg(reg, ZD_CR24, 0x0e);
+pObj->SetReg(reg, ZD_CR41, 0x24);
+pObj->SetReg(reg, ZD_CR159, 0x93);
+pObj->SetReg(reg, ZD_CR160, 0xfc);
+pObj->SetReg(reg, ZD_CR161, 0x20);
+pObj->SetReg(reg, ZD_CR162, 0x26);
+#endif
+
+#else
+//1211b----------------
+
+if (!InitChOnly) {
+        //LockPhyReg(pObj);
+        pObj->SetReg(reg, ZD_CR10, 0x89);
+        pObj->SetReg(reg, ZD_CR15, 0x20);
+        pObj->SetReg(reg, ZD_CR17, 0x2B);       //for newest(3rd cut) AL2230
+        pObj->SetReg(reg, ZD_CR23, 0x40);
+        pObj->SetReg(reg, ZD_CR24, 0x20);
+        pObj->SetReg(reg, ZD_CR26, 0x93);
+        pObj->SetReg(reg, ZD_CR28, 0x3e);
+        pObj->SetReg(reg, ZD_CR29, 0x00);
+        pObj->SetReg(reg, ZD_CR33, 0x28);   //5621
+        pObj->SetReg(reg, ZD_CR34, 0x30);
+        pObj->SetReg(reg, ZD_CR35, 0x3e);  //for newest(3rd cut) AL2230
+        pObj->SetReg(reg, ZD_CR41, 0x24);
+        pObj->SetReg(reg, ZD_CR44, 0x32);
+        pObj->SetReg(reg, ZD_CR46, 0x99);  //for newest(3rd cut) AL2230
+        pObj->SetReg(reg, ZD_CR47, 0x1e);
+        pObj->SetReg(reg, ZD_CR48, 0x00);       //ZD1211B 05.06.10
+        pObj->SetReg(reg, ZD_CR49, 0x00);       //ZD1211B 05.06.10
+        pObj->SetReg(reg, ZD_CR51, 0x01);       //ZD1211B 05.06.10
+        pObj->SetReg(reg, ZD_CR52, 0x80);       //ZD1211B 05.06.10
+        pObj->SetReg(reg, ZD_CR53, 0x7e);       //ZD1211B 05.06.10
+        pObj->SetReg(reg, ZD_CR65, 0x00);       //ZD1211B 05.06.10
+        pObj->SetReg(reg, ZD_CR66, 0x00);       //ZD1211B 05.06.10
+        pObj->SetReg(reg, ZD_CR67, 0x00);       //ZD1211B 05.06.10
+        pObj->SetReg(reg, ZD_CR68, 0x00);       //ZD1211B 05.06.10
+        pObj->SetReg(reg, ZD_CR69, 0x28);       //ZD1211B 05.06.10
+        pObj->SetReg(reg, ZD_CR79, 0x58);
+        pObj->SetReg(reg, ZD_CR80, 0x30);
+        pObj->SetReg(reg, ZD_CR81, 0x30);
+        pObj->SetReg(reg, ZD_CR87, 0x0a);
+        pObj->SetReg(reg, ZD_CR89, 0x04);
+        pObj->SetReg(reg, ZD_CR91, 0x00);   //5621
+        pObj->SetReg(reg, ZD_CR92, 0x0a);
+        pObj->SetReg(reg, ZD_CR98, 0x8d);  //4804, for 1212 new algorithm
+        pObj->SetReg(reg, ZD_CR99, 0x00);  //5621
+        pObj->SetReg(reg, ZD_CR101, 0x13);
+        pObj->SetReg(reg, ZD_CR102, 0x27);
+        pObj->SetReg(reg, ZD_CR106, 0x24);  //for newest(3rd cut) AL2230
+        pObj->SetReg(reg, ZD_CR107, 0x2a);
+        pObj->SetReg(reg, ZD_CR109, 0x13);  //4804, for 1212 new algorithm
+        pObj->SetReg(reg, ZD_CR110, 0x1f);  //4804, for 1212 new algorithm
+        pObj->SetReg(reg, ZD_CR111, 0x1f);
+        pObj->SetReg(reg, ZD_CR112, 0x1f);
+        pObj->SetReg(reg, ZD_CR113, 0x27);
+        pObj->SetReg(reg, ZD_CR114, 0x27);
+        pObj->SetReg(reg, ZD_CR115, 0x26); //24->26 at 4902 for newest(3rd cut) AL2230
+        pObj->SetReg(reg, ZD_CR116, 0x24);
+        pObj->SetReg(reg, ZD_CR117, 0xfa); // for 1211b
+        pObj->SetReg(reg, ZD_CR118, 0xfa); // for 1211b
+        pObj->SetReg(reg, ZD_CR119, 0x10);
+        pObj->SetReg(reg, ZD_CR120, 0x4f);
+        pObj->SetReg(reg, ZD_CR121, 0x6c); // for 1211b
+        pObj->SetReg(reg, ZD_CR122, 0xfc); // E0->FC at 4902
+        pObj->SetReg(reg, ZD_CR123, 0x57); //5623
+        pObj->SetReg(reg, ZD_CR125, 0xad); //4804, for 1212 new algorithm
+        pObj->SetReg(reg, ZD_CR126, 0x6c); //5614
+        pObj->SetReg(reg, ZD_CR127, 0x03); //4804, for 1212 new algorithm
+        pObj->SetReg(reg, ZD_CR137, 0x50); //5614
+        pObj->SetReg(reg, ZD_CR138, 0xa8);
+        pObj->SetReg(reg, ZD_CR144, 0xac); //5621
+        pObj->SetReg(reg, ZD_CR150, 0x0d);
+
+#endif
+                //--
+                pObj->SetReg(reg, ZD_CR252, 0x00);
+                pObj->SetReg(reg, ZD_CR253, 0x00);
+
+                //UnLockPhyReg(pObj);
+
+                HW_Set_IF_Synthesizer(pObj, AL2230TB[ChannelNo*3]);
+                HW_Set_IF_Synthesizer(pObj, AL2230TB[ChannelNo*3+1]);
+                HW_Set_IF_Synthesizer(pObj, AL2230TB[ChannelNo*3+2]);
+                HW_Set_IF_Synthesizer(pObj, 0x0b3331);
+                HW_Set_IF_Synthesizer(pObj, 0x03b812);
+                HW_Set_IF_Synthesizer(pObj, 0x00fff3);
+                HW_Set_IF_Synthesizer(pObj, 0x0005a4);
+                HW_Set_IF_Synthesizer(pObj, 0x044dc5);
+                HW_Set_IF_Synthesizer(pObj, 0x0805b6);
+                HW_Set_IF_Synthesizer(pObj, 0x0146c7);
+                HW_Set_IF_Synthesizer(pObj, 0x000688);
+                HW_Set_IF_Synthesizer(pObj, 0x0403b9);   //External control TX power (CR31)
+                HW_Set_IF_Synthesizer(pObj, 0x00dbba);
+                HW_Set_IF_Synthesizer(pObj, 0x00099b);
+                HW_Set_IF_Synthesizer(pObj, 0x0bdffc);
+                HW_Set_IF_Synthesizer(pObj, 0x00000d);
+                HW_Set_IF_Synthesizer(pObj, 0x00580f);
+                pObj->SetReg(reg, ZD_CR47, 0x00);
+                pObj->SetReg(reg, 0x464, 0x3);
+                pObj->DelayUs(10);
+                HW_Set_IF_Synthesizer(pObj, 0x000880f);
+                pObj->DelayUs(100);
+                HW_Set_IF_Synthesizer(pObj, 0x00080f);
+                pObj->DelayUs(100);
+
+                pObj->SetReg(reg, 0x464, 0x00);
+                pObj->SetReg(reg, ZD_CR47, 0x18);
+                //LockPhyReg(pObj);
+                pObj->SetReg(reg, ZD_CR251, 0x7f);
+                pObj->DelayUs(10);
+                //UnLockPhyReg(pObj);
+                HW_Set_IF_Synthesizer(pObj, 0x000d80f);
+                pObj->DelayUs(100);
+                //HW_Set_IF_Synthesizer(pObj, 0x0004c0f);
+                //pObj->DelayUs(100);
+                //HW_Set_IF_Synthesizer(pObj, 0x00540f);
+                //pObj->DelayUs(100);
+                HW_Set_IF_Synthesizer(pObj, 0x00780f);
+                pObj->DelayUs(100);
+                HW_Set_IF_Synthesizer(pObj, 0x00580f);
+
+
+        } else {
+                HW_Set_IF_Synthesizer(pObj, AL2230TB[ChannelNo*3]);
+                HW_Set_IF_Synthesizer(pObj, AL2230TB[ChannelNo*3+1]);
+                HW_Set_IF_Synthesizer(pObj, AL2230TB[ChannelNo*3+2]);
+        }
+
+        //LockPhyReg(pObj);
+        pObj->SetReg(reg, ZD_CR138, 0x28);
+        pObj->SetReg(reg, ZD_CR203, 0x06);
+        //UnLockPhyReg(pObj);
+        pObj->CR203Flag = 2;
+        pObj->CR31Flag = 2;
+
+
+#if !( (defined(OFDM) && defined(GCCK)) || defined(ECCK_60_5) )
+
+        pObj->SetReg(reg, ZD_PE1_PE2, 3);
+#endif
+
+        UnLockPhyReg(pObj);
+}
+
+#endif
+
+
+
+//2-step LNA for RF2959
+void
+HW_Set_RFMD_Chips(zd_80211Obj_t *pObj, U32 ChannelNo, U8 InitChOnly) {
+        void *reg = pObj->reg;
+
+        LockPhyReg(pObj);
+
+        // Get Phy-Config permission
+        if (!InitChOnly ) {
+                //LockPhyReg(pObj);
+                pObj->SetReg(reg, ZD_CR2, 0x1E);
+                pObj->SetReg(reg, ZD_CR9, 0x20);
+                //pObj->SetReg(reg, ZD_CR10, 0xB1);
+                pObj->SetReg(reg, ZD_CR10, 0x89);
+                pObj->SetReg(reg, ZD_CR11, 0x00);
+                pObj->SetReg(reg, ZD_CR15, 0xD0);
+#ifdef ZD1211
+
+                pObj->SetReg(reg, ZD_CR17, 0x68);
+#elif defined(ZD1211B)
+
+                pObj->SetReg(reg, ZD_CR17, 0x2b);
+#endif
+
+                pObj->SetReg(reg, ZD_CR19, 0x4a);
+                pObj->SetReg(reg, ZD_CR20, 0x0c);
+                pObj->SetReg(reg, ZD_CR21, 0x0E);
+                pObj->SetReg(reg, ZD_CR23, 0x48);
+
+                if (pObj->bIsNormalSize)
+                        pObj->SetReg(reg, ZD_CR24, 0x14);//cca threshold
+                else
+                        pObj->SetReg(reg, ZD_CR24, 0x20);//cca threshold
+
+                pObj->SetReg(reg, ZD_CR26, 0x90);
+                pObj->SetReg(reg, ZD_CR27, 0x30);
+                pObj->SetReg(reg, ZD_CR29, 0x20);
+                pObj->SetReg(reg, ZD_CR31, 0xb2);
+                //pObj->SetReg(reg, ZD_CR31, 0xaa);
+                pObj->SetReg(reg, ZD_CR32, 0x43);
+                pObj->SetReg(reg, ZD_CR33, 0x28);
+                pObj->SetReg(reg, ZD_CR38, 0x30);
+                pObj->SetReg(reg, ZD_CR34, 0x0f);
+                pObj->SetReg(reg, ZD_CR35, 0xF0);
+                pObj->SetReg(reg, ZD_CR41, 0x2a);
+                pObj->SetReg(reg, ZD_CR46, 0x7F);
+                pObj->SetReg(reg, ZD_CR47, 0x1c);
+#ifdef ZD1211
+
+                pObj->SetReg(reg, ZD_CR51, 0xc5);
+                pObj->SetReg(reg, ZD_CR52, 0xc5);
+                pObj->SetReg(reg, ZD_CR53, 0xc5);
+#elif defined(ZD1211B)
+
+                pObj->SetReg(reg, ZD_CR51, 0x01);
+                pObj->SetReg(reg, ZD_CR52, 0x80);
+                pObj->SetReg(reg, ZD_CR53, 0x7e);
+
+                pObj->SetReg(reg,ZD_CR48, 0x00);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR49, 0x00);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR65, 0x00);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR66, 0x00);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR67, 0x00);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR68, 0x00);		//ZD1211B 05.06.10
+                pObj->SetReg(reg,ZD_CR69, 0x28);		//ZD1211B 05.06.10
+
+#endif
+
+                pObj->SetReg(reg, ZD_CR79, 0x58);
+                pObj->SetReg(reg, ZD_CR80, 0x30);
+                pObj->SetReg(reg, ZD_CR81, 0x30);
+                pObj->SetReg(reg, ZD_CR82, 0x00);
+                pObj->SetReg(reg, ZD_CR83, 0x24);
+                pObj->SetReg(reg, ZD_CR84, 0x04);
+                pObj->SetReg(reg, ZD_CR85, 0x00);
+                pObj->SetReg(reg, ZD_CR86, 0x10);
+                pObj->SetReg(reg, ZD_CR87, 0x2A);
+                pObj->SetReg(reg, ZD_CR88, 0x10);
+                pObj->SetReg(reg, ZD_CR89, 0x24);
+                pObj->SetReg(reg, ZD_CR90, 0x18);
+                //pObj->SetReg(reg, ZD_CR91, 0x18);
+                pObj->SetReg(reg, ZD_CR91, 0x00); // to solve continuous CTS frames problem
+                pObj->SetReg(reg, ZD_CR92, 0x0a);
+                pObj->SetReg(reg, ZD_CR93, 0x00);
+                pObj->SetReg(reg, ZD_CR94, 0x01);
+                pObj->SetReg(reg, ZD_CR95, 0x00);
+                pObj->SetReg(reg, ZD_CR96, 0x40);
+
+                pObj->SetReg(reg, ZD_CR97, 0x37);
+#ifdef HOST_IF_USB
+	#ifdef ZD1211
+
+                pObj->SetReg(reg, ZD_CR98, 0x05);
+#elif defined(ZD1211B)
+
+                pObj->SetReg(reg, ZD_CR98, 0x8d);
+#endif
+#else
+
+                pObj->SetReg(reg, ZD_CR98, 0x0D);
+                pObj->SetReg(reg, ZD_CR121, 0x06);
+                pObj->SetReg(reg, ZD_CR125, 0xAA);
+#endif
+
+                pObj->SetReg(reg, ZD_CR99, 0x28);
+                pObj->SetReg(reg, ZD_CR100, 0x00);
+                pObj->SetReg(reg, ZD_CR101, 0x13);
+                pObj->SetReg(reg, ZD_CR102, 0x27);
+                pObj->SetReg(reg, ZD_CR103, 0x27);
+                pObj->SetReg(reg, ZD_CR104, 0x18);
+                pObj->SetReg(reg, ZD_CR105, 0x12);
+
+                if (pObj->bIsNormalSize)
+
+                        pObj->SetReg(reg, ZD_CR106, 0x1a);
+                else
+                        pObj->SetReg(reg, ZD_CR106, 0x22);
+
+                pObj->SetReg(reg, ZD_CR107, 0x24);
+                pObj->SetReg(reg, ZD_CR108, 0x0a);
+                pObj->SetReg(reg, ZD_CR109, 0x13);
+#ifdef ZD1211
+
+                pObj->SetReg(reg, ZD_CR110, 0x2F);
+#elif defined(ZD1211B)
+
+                pObj->SetReg(reg, ZD_CR110, 0x1F);
+#endif
+
+                pObj->SetReg(reg, ZD_CR111, 0x27);
+                pObj->SetReg(reg, ZD_CR112, 0x27);
+                pObj->SetReg(reg, ZD_CR113, 0x27);
+                pObj->SetReg(reg, ZD_CR114, 0x27);
+#ifdef ZD1211
+
+                pObj->SetReg(reg, ZD_CR115, 0x40);
+                pObj->SetReg(reg, ZD_CR116, 0x40);
+                pObj->SetReg(reg, ZD_CR117, 0xF0);
+                pObj->SetReg(reg, ZD_CR118, 0xF0);
+#elif defined(ZD1211B)
+
+                pObj->SetReg(reg, ZD_CR115, 0x26);
+                pObj->SetReg(reg, ZD_CR116, 0x40);
+                pObj->SetReg(reg, ZD_CR117, 0xFA);
+                pObj->SetReg(reg, ZD_CR118, 0xFA);
+                pObj->SetReg(reg, ZD_CR121, 0x6C);
+#endif
+
+                pObj->SetReg(reg, ZD_CR119, 0x16);
+                //pObj->SetReg(reg, ZD_CR122, 0xfe);
+                if (pObj->bContinueTx)
+                        pObj->SetReg(reg, ZD_CR122, 0xff);
+                else
+                        pObj->SetReg(reg, ZD_CR122, 0x00);
+                pObj->CR122Flag = 2;
+#ifdef ZD1211B
+
+                pObj->SetReg(reg,ZD_CR125, 0xad);  //4804, for 1212 new algorithm
+                pObj->SetReg(reg,ZD_CR126, 0x6c);  //5614
+
+#endif
+
+                pObj->SetReg(reg, ZD_CR127, 0x03);
+                pObj->SetReg(reg, ZD_CR131, 0x08);
+                pObj->SetReg(reg, ZD_CR138, 0x28);
+                pObj->SetReg(reg, ZD_CR148, 0x44);
+#ifdef ZD1211
+
+                pObj->SetReg(reg, ZD_CR150, 0x10);
+#elif defined(ZD1211B)
+
+                pObj->SetReg(reg, ZD_CR150, 0x14);
+#endif
+
+                pObj->SetReg(reg, ZD_CR169, 0xBB);
+                pObj->SetReg(reg, ZD_CR170, 0xBB);
+                //pObj->SetReg(reg, ZD_CR38, 0x30);
+                //UnLockPhyReg(pObj);
+
+                HW_Set_IF_Synthesizer(pObj, 0x000007);  //REG0(CFG1)
+                HW_Set_IF_Synthesizer(pObj, 0x07dd43);  //REG1(IFPLL1)
+                HW_Set_IF_Synthesizer(pObj, 0x080959);  //REG2(IFPLL2)
+                HW_Set_IF_Synthesizer(pObj, 0x0e6666);
+                HW_Set_IF_Synthesizer(pObj, 0x116a57);  //REG4
+                HW_Set_IF_Synthesizer(pObj, 0x17dd43);  //REG5
+                HW_Set_IF_Synthesizer(pObj, 0x1819f9);  //REG6
+                HW_Set_IF_Synthesizer(pObj, 0x1e6666);
+                HW_Set_IF_Synthesizer(pObj, 0x214554);
+                HW_Set_IF_Synthesizer(pObj, 0x25e7fa);
+                HW_Set_IF_Synthesizer(pObj, 0x27fffa);
+                //HW_Set_IF_Synthesizer(pObj, 0x294128);  //Register control TX power
+                // set in Set_RF_Channel( )
+                //HW_Set_IF_Synthesizer(pObj, 0x28252c);    //External control TX power (CR31_CCK, CR51_6-36M, CR52_48M, CR53_54M
+                HW_Set_IF_Synthesizer(pObj, 0x2c0000);
+                HW_Set_IF_Synthesizer(pObj, 0x300000);
+
+
+                HW_Set_IF_Synthesizer(pObj, 0x340000);  //REG13(0xD)
+                HW_Set_IF_Synthesizer(pObj, 0x381e0f);  //REG14(0xE)
+                HW_Set_IF_Synthesizer(pObj, 0x6c180f);  //REG27(0x11)
+        } else {
+                //LockPhyReg(pObj);
+                if (pObj->bContinueTx)
+                        pObj->SetReg(reg, ZD_CR122, 0xff);
+                else
+                        pObj->SetReg(reg, ZD_CR122, 0x00);
+                //UnLockPhyReg(pObj);
+
+                pObj->CR122Flag = 2;
+                pObj->CR31Flag = 2;
+
+                HW_Set_IF_Synthesizer(pObj, RFMD2958t[ChannelNo*2]);
+                HW_Set_IF_Synthesizer(pObj, RFMD2958t[ChannelNo*2+1]);
+
+        }
+
+
+        UnLockPhyReg(pObj);
+
+        return;
+}
+
+void HW_EnableBeacon(zd_80211Obj_t *pObj, U16 BeaconInterval, U16 DtimPeriod, U8 BssType) {
+        U32 tmpValue;
+        U32 Mode = 0;
+        U16 Dtim = 0;
+
+        void *reg = pObj->reg;
+
+        if (BssType == INDEPENDENT_BSS) {
+                Mode = IBSS_MODE;
+                printk(KERN_ERR "Mode: IBSS_MODE\n");
+        } else if (BssType == AP_BSS) {
+                Mode = AP_MODE;
+                Dtim = DtimPeriod;
+                printk(KERN_ERR "Mode: AP_BSS\n");
+        }
+
+        tmpValue = BeaconInterval | Mode | (Dtim<<16) ;
+        pObj->SetReg(reg, ZD_BCNInterval, tmpValue);
+}
+
+
+void HW_SwitchChannel(zd_80211Obj_t *pObj, U16 channel, U8 InitChOnly, const U8 MAC_Mode) {
+        void *reg = pObj->reg;
+
+
+        pObj->SetReg(reg, ZD_CONFIGPhilips, 0x0);
+
+        //FPRINT_V("rfMode", pObj->rfMode);
+
+        switch(pObj->rfMode) {
+        default:
+                FPRINT_V("Invalid RF module parameter", pObj->rfMode);
+
+                break;
+
+        case MAXIM_NEW_RF:
+                FPRINT_V("MAXIM_NEW_RF Channel", channel);
+                pObj->S_bit_cnt = 18;
+                HW_Set_Maxim_New_Chips(pObj, channel, 0);
+
+#ifdef HOST_IF_USB
+
+                HW_UpdateIntegrationValue(pObj, channel, MAC_Mode);
+#endif
+
+                break;
+
+        case GCT_RF:
+                //	FPRINT_V("GCT Channel", channel);
+                pObj->S_bit_cnt = 21;
+
+                pObj->AcquireDoNotSleep();
+                if (!pObj->bDeviceInSleep)
+                        HW_Set_GCT_Chips(pObj, channel, InitChOnly);
+                pObj->ReleaseDoNotSleep();
+                //HW_UpdateIntegrationValue(pObj, channel);
+                break;
+
+        case AL2230_RF:
+                //FPRINT_V("AL2210MPVB_RF Channel", channel);
+                pObj->S_bit_cnt = 24;
+                HW_Set_AL2230_RF_Chips(pObj, channel, InitChOnly);
+                HW_UpdateIntegrationValue(pObj, channel, MAC_Mode);
+                break;
+        case AL7230B_RF: //For 802.11a/b/g
+                FPRINT_V("AL7230B_RF",channel);
+                pObj->S_bit_cnt = 24;
+                //			printk("Before AL7230BRF:C,%d,M,%d\n\n",channel,MAC_Mode);
+                HW_Set_AL7230B_RF_Chips(pObj, channel, InitChOnly,MAC_Mode);
+                break;
+        case AL2210_RF:
+                //FPRINT_V("AL2210_RF Channel", channel);
+                pObj->S_bit_cnt = 24;
+                HW_Set_AL2210_Chips(pObj, channel, 0);
+                break;
+
+        case RALINK_RF:
+                FPRINT_V("Ralink Channel", channel);
+                break;
+
+        case INTERSIL_RF:
+                FPRINT_V("Intersil Channel", channel);
+                break;
+
+        case RFMD_RF:
+                FPRINT_V("RFMD Channel", channel);
+                pObj->S_bit_cnt = 24;
+                HW_Set_RFMD_Chips(pObj, channel, InitChOnly);
+
+
+                if (!InitChOnly)
+                        HW_UpdateIntegrationValue(pObj, channel, MAC_Mode);
+                break;
+
+        case MAXIM_NEW_RF2:
+                FPRINT_V("MAXIM_NEW_RF2 Channel", channel);
+
+                pObj->S_bit_cnt = 18;
+                HW_Set_Maxim_New_Chips2(pObj, channel, 0);
+                break;
+
+        case PHILIPS_RF:
+                FPRINT_V("Philips SA2400 Channel", channel);
+                break;
+        }
+
+        HW_OverWritePhyRegFromE2P(pObj);
+
+        return;
+}
+
+
+
+void HW_SetRfChannel(zd_80211Obj_t *pObj, U16 channel, U8 InitChOnly, const U8 MAC_Mode) {
+        void *reg = pObj->reg;
+        //FPRINT_V("HW_SetRfChannel", channel);
+
+        // Check if this ChannelNo allowed?
+        u32 i;
+
+        if (!((1 << (channel-1)) & pObj->AllowedChannel)) {
+                // Not an allowed channel, we use default channel.
+                //printk("Channel = %d Not an allowed channel\n", channel);
+                //printk("Set default channel = %d\n", (pObj->AllowedChannel >> 16));
+                //channel = (pObj->AllowedChannel >> 16);
+                if(PURE_A_MODE != MAC_Mode) {
+                        //printk("You use a non-allowed channel in HW_setRfChannel(%d)\n",channel);
+                        return;
+                }
+        }
+
+        //Check if channel is valid 2.4G Band
+        if(MAC_Mode != PURE_A_MODE) {
+                if ((channel > 14 ) || (channel < 1)) { // for the wrong content of the EEPROM
+                        printk(KERN_DEBUG "Error Channel Number in HW_SetRfChannel(11b/g)\n");
+                        return;
+                }
+        } else if(MAC_Mode == PURE_A_MODE) {
+                //Check is the A Band Channel is valid.
+                for(i=0;i<dot11A_Channel_Amount;i++)
+                        if(dot11A_Channel[i] == channel)
+                                break;
+                if(i>=dot11A_Channel_Amount) {
+                        printk(KERN_DEBUG "Error Channel Number in HW_SetRfChannel(11a,CH=%d)\n",channel);
+                        return;
+                }
+        }
+        if(PURE_A_MODE == MAC_Mode) {
+                pObj->SetReg(pObj->reg, ZD_IFS_Value, 0x1147c00a);
+                pObj->SetReg(pObj->reg, ZD_RTS_CTS_Rate, 0x01090109);
+        } else {
+                pObj->SetReg(pObj->reg, ZD_IFS_Value, 0xa47c032);
+                pObj->SetReg(pObj->reg, ZD_RTS_CTS_Rate, 0x30000);
+        }
+
+        pObj->Channel = channel;
+        HW_SwitchChannel(pObj, channel, InitChOnly,MAC_Mode);
+        LastSetChannel = channel;
+        LastMacMode = MAC_Mode;
+
+        //The UpdateIntegrationValue call should be called immediately
+        //after HW_SetRfChannel
+        HW_UpdateIntegrationValue(pObj, channel,MAC_Mode);
+
+        // When channnel == 14 , enable Japan spectrum mask
+        if (pObj->RegionCode == 0x40) { //Japan
+                if (channel == 14) {
+                        HW_Set_FilterBand(pObj, pObj->RegionCode);  // for Japan, RegionCode = 0x40
+                        if (pObj->rfMode == RFMD_RF) {
+                                LockPhyReg(pObj);
+                                pObj->SetReg(reg, ZD_CR47, 0x18);
+                                //UnLockPhyReg(pObj);
+
+                                HW_Set_IF_Synthesizer(pObj, 0x28252d);    //External control TX power (CR31_CCK, CR51_6-36M, CR52_48M, CR53_54M
+                                UnLockPhyReg(pObj);
+                        }
+
+                } else {
+
+                        // For other channels, use default filter.
+                        HW_Set_FilterBand(pObj, 0);
+
+                        if (pObj->rfMode == RFMD_RF) {
+                                // CR47 has been restored in Init_RF_Chips( ), its value is from EEPROM
+                                HW_Set_IF_Synthesizer(pObj, 0x28252d);    //External control TX power (CR31_CCK, CR51_6-36M, CR52_48M, CR53_54M
+                        }
+                }
+        }
+
+        pObj->DelayUs(100);
+}
+
+void HW_SetBeaconFIFO(zd_80211Obj_t *pObj, U8 *pBeacon, U16 index) {
+        U32 tmpValue, BCNPlcp;
+        U16 j;
+        void *reg = pObj->reg;
+        U32 count = 0;
+
+        pObj->SetReg(reg, ZD_BCN_FIFO_Semaphore, 0x0);
+        tmpValue = pObj->GetReg(reg, ZD_BCN_FIFO_Semaphore);
+
+        while (tmpValue & BIT_1) {
+                pObj->DelayUs(1000);
+                tmpValue = pObj->GetReg(reg, ZD_BCN_FIFO_Semaphore);
+
+                if ((++count % 100) == 0)
+                        printk(KERN_ERR "BCN\n");
+        }
+
+        /* Write (Beacon_Len -1) to Beacon-FIFO */
+        pObj->SetReg(reg, ZD_BCNFIFO, (index - 1));
+#ifdef ZD1211B
+
+        pObj->SetReg(reg,ZD_BCNLENGTH, (index - 1));
+#endif
+
+        for (j=0; j<index; j++) {
+                pObj->SetReg(reg, ZD_BCNFIFO, pBeacon[j]);
+        }
+        pObj->SetReg(reg, ZD_BCN_FIFO_Semaphore, 1);
+
+        /* Configure BCNPLCP */
+        if(mMacMode == PURE_A_MODE)  {
+                BCNPlcp = 0x0000003b; //802.11a 5g OFDM 6Mb
+        } else {
+                index = (index << 3); //802.11b/g 2.4G CCK 1Mb
+                BCNPlcp = 0x00000400;
+        }
+        BCNPlcp |= (((U32)index) << 16);
+        pObj->SetReg(reg, ZD_BCNPLCPCfg, BCNPlcp);
+}
+
+
+
+void HW_SetSupportedRate(zd_80211Obj_t *pObj, U8 *prates) {
+        U8 HighestBasicRate = SR_1M;
+        U8 HighestRate = SR_1M;
+        U8 SRate;
+        U32 tmpValue;
+        U16 j;
+        U8 MaxBasicRate;
+
+        void *reg = pObj->reg;
+        MaxBasicRate = pObj->BasicRate;
+
+
+        for (j=0; j<(*(prates+1)); j++) {
+                switch((*(prates+2+j)) & 0x7f) {
+                case SR_1M:
+                        SRate = SR_1M;
+#if defined(AMAC)
+
+                        if ((*(prates+2+j)) & 0x80) {	//It's a basic rate
+
+                                tmpValue = pObj->GetReg(reg, ZD_BasicRateTbl);
+                                tmpValue |= BIT_0;
+                                pObj->SetReg(reg, ZD_BasicRateTbl, tmpValue);
+                        }
+#endif
+                        break;
+
+                case SR_2M:
+                        SRate = SR_2M;
+#if defined(AMAC)
+
+                        if ((*(prates+2+j)) & 0x80) {	//It's a basic rate
+                                tmpValue = pObj->GetReg(reg, ZD_BasicRateTbl);
+                                tmpValue |= BIT_1;
+                                pObj->SetReg(reg, ZD_BasicRateTbl, tmpValue);
+                        }
+#endif
+                        break;
+
+                case SR_5_5M:
+                        SRate = SR_5_5M;
+#if defined(AMAC)
+
+                        if ((*(prates+2+j)) & 0x80) {	//It's a basic rate
+                                tmpValue = pObj->GetReg(reg, ZD_BasicRateTbl);
+
+                                tmpValue |= BIT_2;
+                                pObj->SetReg(reg, ZD_BasicRateTbl, tmpValue);
+                        }
+#endif
+                        break;
+
+                case SR_11M:
+                        SRate = SR_11M;
+#if defined(AMAC)
+
+                        if ((*(prates+2+j)) & 0x80) {	//It's a basic rate
+                                tmpValue = pObj->GetReg(reg, ZD_BasicRateTbl);
+                                tmpValue |= BIT_3;
+                                pObj->SetReg(reg, ZD_BasicRateTbl, tmpValue);
+                        }
+
+#endif
+                        break;
+
+#if	(defined(GCCK) && defined(OFDM))
+
+                case SR_6M:
+                        SRate = SR_6M;
+                        if ((*(prates+2+j)) & 0x80) {	//It's a basic rate
+                                tmpValue = pObj->GetReg(reg, ZD_BasicRateTbl);
+                                tmpValue |= BIT_8;
+                                pObj->SetReg(reg, ZD_BasicRateTbl, tmpValue);
+                        }
+                        break;
+
+                case SR_9M:
+                        SRate = SR_9M;
+                        if ((*(prates+2+j)) & 0x80) {	//It's a basic rate
+                                tmpValue = pObj->GetReg(reg, ZD_BasicRateTbl);
+                                tmpValue |= BIT_9;
+                                pObj->SetReg(reg, ZD_BasicRateTbl, tmpValue);
+                        }
+                        break;
+
+                case SR_12M:
+                        SRate = SR_12M;
+                        if ((*(prates+2+j)) & 0x80) {	//It's a basic rate
+                                tmpValue = pObj->GetReg(reg, ZD_BasicRateTbl);
+                                tmpValue |= BIT_10;
+                                pObj->SetReg(reg, ZD_BasicRateTbl, tmpValue);
+                        }
+                        break;
+
+                case SR_18M:
+                        SRate = SR_18M;
+                        if ((*(prates+2+j)) & 0x80) {	//It's a basic rate
+                                tmpValue = pObj->GetReg(reg, ZD_BasicRateTbl);
+                                tmpValue |= BIT_11;
+                                pObj->SetReg(reg, ZD_BasicRateTbl, tmpValue);
+                        }
+                        break;
+
+                case SR_24M:
+                        SRate = SR_24M;
+                        if ((*(prates+2+j)) & 0x80) {	//It's a basic rate
+                                tmpValue = pObj->GetReg(reg, ZD_BasicRateTbl);
+                                tmpValue |= BIT_12;
+                                pObj->SetReg(reg, ZD_BasicRateTbl, tmpValue);
+                        }
+                        break;
+
+                case SR_36M:
+                        SRate = SR_36M;
+                        if ((*(prates+2+j)) & 0x80) {	//It's a basic rate
+                                tmpValue = pObj->GetReg(reg, ZD_BasicRateTbl);
+                                tmpValue |= BIT_13;
+                                pObj->SetReg(reg, ZD_BasicRateTbl, tmpValue);
+
+                        }
+                        break;
+
+                case SR_48M:
+                        SRate = SR_48M;
+                        if ((*(prates+2+j)) & 0x80) {	//It's a basic rate
+                                tmpValue = pObj->GetReg(reg, ZD_BasicRateTbl);
+                                tmpValue |= BIT_14;
+                                pObj->SetReg(reg, ZD_BasicRateTbl, tmpValue);
+                        }
+                        break;
+
+                case SR_54M:
+                        SRate = SR_54M;
+                        if ((*(prates+2+j)) & 0x80) {	//It's a basic rate
+                                tmpValue = pObj->GetReg(reg, ZD_BasicRateTbl);
+                                tmpValue |= BIT_15;
+                                pObj->SetReg(reg, ZD_BasicRateTbl, tmpValue);
+                        }
+                        break;
+#endif
+
+                default:
+                        SRate = SR_1M;
+
+                        break;
+                }
+
+                if (HighestRate < SRate)
+                        HighestRate = SRate;
+
+
+                if ((*(prates+2+j)) & 0x80) {
+                        /* It's a basic rate */
+                        if (HighestBasicRate < SRate)
+                                HighestBasicRate = SRate;
+                }
+        }
+
+#if !defined(OFDM)
+        tmpValue = pObj->GetReg(reg, ZD_CtlReg1);
+
+        if (pObj->BssType == INDEPENDENT_BSS) {
+                if (HighestBasicRate == SR_1M) {
+                        // Workaround compatibility issue.
+                        // For resonable case, HighestBasicRate should larger than 2M if
+
+                        // short-preamble is supported.
+                        HighestBasicRate = SR_2M;
+                        pObj->SetReg(reg, ZD_Ack_Timeout_Ext, 0x3f);
+                }
+        }
+
+        switch(HighestBasicRate) {
+        case SR_1M:
+                tmpValue &= ~0x1c;
+                tmpValue |= 0x00;
+                pObj->SetReg(reg, ZD_CtlReg1, tmpValue);
+                pObj->BasicRate = 0x0;
+                break;
+
+        case SR_2M:
+                tmpValue &= ~0x1c;
+                tmpValue |= 0x04;
+                pObj->SetReg(reg, ZD_CtlReg1, tmpValue);
+                pObj->BasicRate = 0x1;
+                break;
+
+        case SR_5_5M:
+                tmpValue &= ~0x1c;
+
+                tmpValue |= 0x08;
+                pObj->SetReg(reg, ZD_CtlReg1, tmpValue);
+                pObj->BasicRate = 0x2;
+                break;
+
+        case SR_11M:
+                tmpValue &= ~0x1c;
+                tmpValue |= 0x0c;
+                pObj->SetReg(reg, ZD_CtlReg1, tmpValue);
+                pObj->BasicRate = 0x3;
+                break;
+
+        default:
+                break;
+        }
+#else
+        switch(HighestBasicRate) {
+        case SR_1M:
+                if (HighestBasicRate >= MaxBasicRate)
+                        pObj->BasicRate = 0x0;
+                break;
+
+
+        case SR_2M:
+                if (HighestBasicRate >= MaxBasicRate)
+                        pObj->BasicRate = 0x1;
+                break;
+
+        case SR_5_5M:
+                if (HighestBasicRate >= MaxBasicRate)
+                        pObj->BasicRate = 0x2;
+                break;
+
+        case SR_11M:
+                if (HighestBasicRate >= MaxBasicRate)
+                        pObj->BasicRate = 0x3;
+                break;
+
+        case SR_6M:
+                if (HighestBasicRate >= MaxBasicRate)
+                        pObj->BasicRate = 0x4;
+                break;
+
+        case SR_9M:
+                if (HighestBasicRate >= MaxBasicRate)
+                        pObj->BasicRate = 0x5;
+                break;
+
+        case SR_12M:
+                if (HighestBasicRate >= MaxBasicRate)
+                        pObj->BasicRate = 0x6;
+                break;
+
+        case SR_18M:
+                if (HighestBasicRate >= MaxBasicRate)
+                        pObj->BasicRate = 0x7;
+                break;
+
+        case SR_24M:
+                if (HighestBasicRate >= MaxBasicRate)
+                        pObj->BasicRate = 0x8;
+                break;
+
+        case SR_36M:
+                if (HighestBasicRate >= MaxBasicRate)
+                        pObj->BasicRate = 0x9;
+                break;
+
+        case SR_48M:
+                if (HighestBasicRate >= MaxBasicRate)
+
+                        pObj->BasicRate = 0xa;
+                break;
+
+        case SR_54M:
+                if (HighestBasicRate >= MaxBasicRate)
+                        pObj->BasicRate = 0xb;
+                break;
+
+        default:
+
+                break;
+        }
+#endif
+
+        //FPRINT_V("HighestBasicRate", pObj->BasicRate);
+}
+
+extern U16 mBeaconPeriod;
+
+void HW_SetSTA_PS(zd_80211Obj_t *pObj, U8 op) {
+        void *reg = pObj->reg;
+        U32 tmpValue;
+
+        tmpValue = pObj->GetReg(reg, ZD_BCNInterval);
+
+        /* Beacon interval check */
+        if((tmpValue & 0xffff) != mBeaconPeriod) {
+                printk(KERN_ERR "Beacon Interval not match\n");
+                return ;
+        }
+
+        //if (op)
+        //	tmpValue |= STA_PS;
+        //else
+        tmpValue &= ~STA_PS;
+
+        pObj->SetReg(reg, ZD_BCNInterval, tmpValue);
+}
+
+
+void HW_GetTsf(zd_80211Obj_t *pObj, U32 *loTsf, U32 *hiTsf) {
+        void *reg = pObj->reg;
+
+
+        *loTsf = pObj->GetReg(reg, ZD_TSF_LowPart);
+        *hiTsf = pObj->GetReg(reg, ZD_TSF_HighPart);
+}
+
+U32 HW_GetNow(zd_80211Obj_t *pObj) {
+#ifndef HOST_IF_USB
+        void *reg = pObj->reg;
+        return pObj->GetReg(reg, ZD_TSF_LowPart);  //us unit
+#else
+
+        return jiffies; //10ms unit
+#endif
+}
+
+void HW_RadioOnOff(zd_80211Obj_t *pObj, U8 on) {
+        void *reg = pObj->reg;
+        U32	tmpvalue;
+        U8 ii;
+
+
+        if (on) {
+                //++ Turn on RF
+                switch(pObj->rfMode) {
+                case RFMD_RF:
+                        if (!(pObj->PhyTest & BIT_2))
+                                HW_Set_IF_Synthesizer(pObj, 0x000007);
+
+                        if (!(pObj->PhyTest & BIT_0)) {
+                                LockPhyReg(pObj);
+                                pObj->SetReg(reg, ZD_CR10, 0x89);
+
+                                pObj->SetReg(reg, ZD_CR11, 0x00);
+                                tmpvalue = pObj->GetReg(reg, ZD_CR11);
+                                tmpvalue &= 0xFF;
+                                if (tmpvalue != 0x00) {
+                                        if (pObj->PhyTest & BIT_1) {
+                                                for (ii = 0; ii < 10; ii ++) {
+                                                        pObj->DelayUs(1000);
+                                                        pObj->SetReg(reg, ZD_CR11, 0x00);
+                                                        tmpvalue = pObj->GetReg(reg, ZD_CR11);
+                                                        if ((tmpvalue & 0xFF) == 0x00)
+                                                                break;
+                                                }
+                                        }
+                                }
+
+                                UnLockPhyReg(pObj);
+                        }
+                        break;
+
+                case AL2230_RF:
+                        LockPhyReg(pObj);
+
+                        for (ii = 0; ii < 10; ii ++) {
+                                pObj->DelayUs(1000);
+                                pObj->SetReg(reg, ZD_CR11, 0x00);
+                                tmpvalue = pObj->GetReg(reg, ZD_CR11);
+                                if ((tmpvalue & 0xFF) == 0x00)
+                                        break;
+                        }
+#ifdef ZD1211
+                        pObj->SetReg(reg, ZD_CR251, 0x3f);
+#elif defined(ZD1211B)
+
+                        pObj->SetReg(reg, ZD_CR251, 0x7f);
+#else
+	#error "You do not define ZD1211 Model"
+#endif
+
+                        UnLockPhyReg(pObj);
+                        break;
+
+
+                default:
+                        break;
+                }
+        } else {
+                //++ Turn off RF
+                switch(pObj->rfMode) {
+                case RFMD_RF:
+                        if (!(pObj->PhyTest & BIT_0)) {
+                                LockPhyReg(pObj);
+
+                                pObj->SetReg(reg, ZD_CR11, 0x15);
+                                tmpvalue = pObj->GetReg(reg, ZD_CR11);
+                                pObj->SetReg(reg, ZD_CR10, 0x81);
+                                UnLockPhyReg(pObj);
+                                tmpvalue &= 0xFF;
+                        }
+
+                        if (!(pObj->PhyTest & BIT_2)) {
+                                LockPhyReg(pObj);
+                                HW_Set_IF_Synthesizer(pObj, 0x00000F);
+                                UnLockPhyReg(pObj);
+                        }
+                        break;
+
+                case AL2230_RF:
+                        LockPhyReg(pObj);
+                        pObj->SetReg(reg, ZD_CR11, 0x04);
+                        pObj->SetReg(reg, ZD_CR251, 0x2f);
+                        UnLockPhyReg(pObj);
+                        break;
+
+
+                default:
+                        break;
+                }
+
+        }
+
+}
+
+#ifdef ZD1211
+void HW_ResetPhy(zd_80211Obj_t *pObj) {
+        void *reg = pObj->reg;
+
+
+        LockPhyReg(pObj);
+#ifdef ZD1211
+
+        pObj->SetReg(reg, ZD_CR0, 0x0a);
+#elif defined(ZD1211B)
+
+        pObj->SetReg(reg, ZD_CR0, 0x14);
+#endif
+
+        pObj->SetReg(reg, ZD_CR1, 0x06);
+        pObj->SetReg(reg, ZD_CR2, 0x26);
+        pObj->SetReg(reg, ZD_CR3, 0x38);
+        pObj->SetReg(reg, ZD_CR4, 0x80);
+        pObj->SetReg(reg, ZD_CR9, 0xa0);
+        pObj->SetReg(reg, ZD_CR10, 0x81);
+#if fTX_PWR_CTRL && fTX_GAIN_OFDM
+        //tmpvalue = pObj->GetReg(reg, ZD_CR11);
+        //tmpvalue |= BIT_6;
+        //pObj->SetReg(reg, ZD_CR11, tmpvalue);
+        pObj->SetReg(reg, ZD_CR11, BIT_6);
+#else
+
+        pObj->SetReg(reg, ZD_CR11, 0x00);
+#endif
+
+        pObj->SetReg(reg, ZD_CR12, 0x7f);
+        pObj->SetReg(reg, ZD_CR13, 0x8c);
+        pObj->SetReg(reg, ZD_CR14, 0x80);
+        pObj->SetReg(reg, ZD_CR15, 0x3d);
+        pObj->SetReg(reg, ZD_CR16, 0x20);
+        pObj->SetReg(reg, ZD_CR17, 0x1e);
+        pObj->SetReg(reg, ZD_CR18, 0x0a);
+        pObj->SetReg(reg, ZD_CR19, 0x48);
+        pObj->SetReg(reg, ZD_CR20, 0x0c);
+#ifdef ZD1211
+
+        pObj->SetReg(reg, ZD_CR21, 0x0c);
+#elif defined(ZD1211B)
+
+        pObj->SetReg(reg, ZD_CR21, 0x0e);
+#endif
+
+        pObj->SetReg(reg, ZD_CR22, 0x23);
+        pObj->SetReg(reg, ZD_CR23, 0x90);
+        pObj->SetReg(reg, ZD_CR24, 0x14);
+        pObj->SetReg(reg, ZD_CR25, 0x40);
+        pObj->SetReg(reg, ZD_CR26, 0x10);
+        pObj->SetReg(reg, ZD_CR27, 0x19);
+        pObj->SetReg(reg, ZD_CR28, 0x7f);
+        pObj->SetReg(reg, ZD_CR29, 0x80);
+
+#ifndef ASIC
+
+        pObj->SetReg(reg, ZD_CR30, 0x4b);
+#else
+
+        pObj->SetReg(reg, ZD_CR30, 0x49);
+#endif
+
+        pObj->SetReg(reg, ZD_CR31, 0x60);
+        pObj->SetReg(reg, ZD_CR32, 0x43);
+        pObj->SetReg(reg, ZD_CR33, 0x08);
+        pObj->SetReg(reg, ZD_CR34, 0x06);
+        pObj->SetReg(reg, ZD_CR35, 0x0a);
+        pObj->SetReg(reg, ZD_CR36, 0x00);
+        pObj->SetReg(reg, ZD_CR37, 0x00);
+        pObj->SetReg(reg, ZD_CR38, 0x38);
+        pObj->SetReg(reg, ZD_CR39, 0x0c);
+        pObj->SetReg(reg, ZD_CR40, 0x84);
+        pObj->SetReg(reg, ZD_CR41, 0x2a);
+        pObj->SetReg(reg, ZD_CR42, 0x80);
+        pObj->SetReg(reg, ZD_CR43, 0x10);
+#ifdef ZD1211
+
+        pObj->SetReg(reg, ZD_CR44, 0x12);
+#elif defined(ZD1211B)
+
+        pObj->SetReg(reg, ZD_CR44, 0x33);
+#endif
+
+        pObj->SetReg(reg, ZD_CR46, 0xff);
+#ifdef ZD1211
+
+        pObj->SetReg(reg, ZD_CR47, 0x08);
+#elif defined(ZD1211B)
+
+        pObj->SetReg(reg, ZD_CR47, 0x30);
+#endif
+
+        pObj->SetReg(reg, ZD_CR48, 0x26);
+        pObj->SetReg(reg, ZD_CR49, 0x5b);
+
+
+        pObj->SetReg(reg, ZD_CR64, 0xd0);
+        pObj->SetReg(reg, ZD_CR65, 0x04);
+        pObj->SetReg(reg, ZD_CR66, 0x58);
+        pObj->SetReg(reg, ZD_CR67, 0xc9);
+        pObj->SetReg(reg, ZD_CR68, 0x88);
+        pObj->SetReg(reg, ZD_CR69, 0x41);
+        pObj->SetReg(reg, ZD_CR70, 0x23);
+        pObj->SetReg(reg, ZD_CR71, 0x10);
+        pObj->SetReg(reg, ZD_CR72, 0xff);
+        pObj->SetReg(reg, ZD_CR73, 0x32);
+        pObj->SetReg(reg, ZD_CR74, 0x30);
+        pObj->SetReg(reg, ZD_CR75, 0x65);
+
+        pObj->SetReg(reg, ZD_CR76, 0x41);
+        pObj->SetReg(reg, ZD_CR77, 0x1b);
+        pObj->SetReg(reg, ZD_CR78, 0x30);
+#ifdef ZD1211
+
+        pObj->SetReg(reg, ZD_CR79, 0x68);
+#elif defined(ZD1211B)
+
+        pObj->SetReg(reg, ZD_CR79, 0xf0);
+#endif
+
+        pObj->SetReg(reg, ZD_CR80, 0x64);
+        pObj->SetReg(reg, ZD_CR81, 0x64);
+        pObj->SetReg(reg, ZD_CR82, 0x00);
+#ifdef ZD1211
+
+        pObj->SetReg(reg, ZD_CR83, 0x00);
+        pObj->SetReg(reg, ZD_CR84, 0x00);
+        pObj->SetReg(reg, ZD_CR85, 0x02);
+        pObj->SetReg(reg, ZD_CR86, 0x00);
+        pObj->SetReg(reg, ZD_CR87, 0x00);
+        pObj->SetReg(reg, ZD_CR88, 0xff);
+        pObj->SetReg(reg, ZD_CR89, 0xfc);
+        pObj->SetReg(reg, ZD_CR90, 0x00);
+        pObj->SetReg(reg, ZD_CR91, 0x00);
+#elif defined(ZD1211B)
+
+        pObj->SetReg(reg, ZD_CR83, 0x24);
+        pObj->SetReg(reg, ZD_CR84, 0x04);
+        pObj->SetReg(reg, ZD_CR85, 0x00);
+        pObj->SetReg(reg, ZD_CR86, 0x0c);
+        pObj->SetReg(reg, ZD_CR87, 0x12);
+        pObj->SetReg(reg, ZD_CR88, 0x0c);
+        pObj->SetReg(reg, ZD_CR89, 0x00);
+        pObj->SetReg(reg, ZD_CR90, 0x58);
+        pObj->SetReg(reg, ZD_CR91, 0x04);
+#endif
+
+
+        pObj->SetReg(reg, ZD_CR92, 0x00);
+        pObj->SetReg(reg, ZD_CR93, 0x08);
+        pObj->SetReg(reg, ZD_CR94, 0x00);
+#ifdef ZD1211
+
+        pObj->SetReg(reg, ZD_CR95, 0x00);
+#elif defined(ZD1211B)
+
+        pObj->SetReg(reg, ZD_CR95, 0x20);
+#endif
+
+        pObj->SetReg(reg, ZD_CR96, 0xff);
+        pObj->SetReg(reg, ZD_CR97, 0xe7);
+#ifdef ZD1211
+
+        pObj->SetReg(reg, ZD_CR98, 0x00);
+#elif defined(ZD1211B)
+
+        pObj->SetReg(reg, ZD_CR98, 0x35);
+#endif
+
+        pObj->SetReg(reg, ZD_CR99, 0x00);
+        pObj->SetReg(reg, ZD_CR100, 0x00);
+        pObj->SetReg(reg, ZD_CR101, 0xae);
+        pObj->SetReg(reg, ZD_CR102, 0x02);
+        pObj->SetReg(reg, ZD_CR103, 0x00);
+        pObj->SetReg(reg, ZD_CR104, 0x03);
+        pObj->SetReg(reg, ZD_CR105, 0x65);
+        pObj->SetReg(reg, ZD_CR106, 0x04);
+        pObj->SetReg(reg, ZD_CR107, 0x00);
+        pObj->SetReg(reg, ZD_CR108, 0x0a);
+#ifdef ZD1211
+
+        pObj->SetReg(reg, ZD_CR109, 0xaa);
+        pObj->SetReg(reg, ZD_CR110, 0xaa);
+        pObj->SetReg(reg, ZD_CR111, 0x25);
+        pObj->SetReg(reg, ZD_CR112, 0x25);
+        pObj->SetReg(reg, ZD_CR113, 0x00);
+
+        pObj->SetReg(reg, ZD_CR119, 0x1e);
+
+        pObj->SetReg(reg, ZD_CR125, 0x90);
+        pObj->SetReg(reg, ZD_CR126, 0x00);
+        pObj->SetReg(reg, ZD_CR127, 0x00);
+#elif defined(ZD1211B)
+
+        pObj->SetReg(reg,ZD_CR109, 0x27);
+        pObj->SetReg(reg,ZD_CR110, 0x27);
+        pObj->SetReg(reg,ZD_CR111, 0x27);
+        pObj->SetReg(reg,ZD_CR112, 0x27);
+        pObj->SetReg(reg,ZD_CR113, 0x27);
+        pObj->SetReg(reg,ZD_CR114, 0x27);
+        pObj->SetReg(reg,ZD_CR115, 0x26);
+        pObj->SetReg(reg,ZD_CR116, 0x24);
+        pObj->SetReg(reg,ZD_CR117, 0xfc);
+        pObj->SetReg(reg,ZD_CR118, 0xfa);
+        pObj->SetReg(reg,ZD_CR119, 0x1e);
+        pObj->SetReg(reg,ZD_CR125, 0x90);
+        pObj->SetReg(reg,ZD_CR126, 0x00);
+        pObj->SetReg(reg,ZD_CR127, 0x00);
+        pObj->SetReg(reg,ZD_CR128, 0x14);
+        pObj->SetReg(reg,ZD_CR129, 0x12);
+        pObj->SetReg(reg,ZD_CR130, 0x10);
+        pObj->SetReg(reg,ZD_CR131, 0x0c);
+        pObj->SetReg(reg,ZD_CR136, 0xdf);
+        pObj->SetReg(reg,ZD_CR137, 0xa0);
+        pObj->SetReg(reg,ZD_CR138, 0xa8);
+        pObj->SetReg(reg,ZD_CR139, 0xb4);
+#endif
+
+
+#if (defined(GCCK) && defined(OFDM))
+	#ifdef ZD1211
+
+        pObj->SetReg(reg, ZD_CR5, 0x00);
+        pObj->SetReg(reg, ZD_CR6, 0x00);
+        pObj->SetReg(reg, ZD_CR7, 0x00);
+        pObj->SetReg(reg, ZD_CR8, 0x00);
+#endif
+
+        pObj->SetReg(reg, ZD_CR9, 0x20);
+        pObj->SetReg(reg, ZD_CR12, 0xf0);
+        pObj->SetReg(reg, ZD_CR20, 0x0e);
+        pObj->SetReg(reg, ZD_CR21, 0x0e);
+        pObj->SetReg(reg, ZD_CR27, 0x10);
+#ifdef HOST_IF_USB
+
+        pObj->SetReg(reg, ZD_CR44, 0x33);
+#else
+
+        pObj->SetReg(reg, ZD_CR44, 0x33);
+#endif
+
+        pObj->SetReg(reg, ZD_CR47, 0x30);
+        pObj->SetReg(reg, ZD_CR83, 0x24);
+        pObj->SetReg(reg, ZD_CR84, 0x04);
+        pObj->SetReg(reg, ZD_CR85, 0x00);
+        pObj->SetReg(reg, ZD_CR86, 0x0C);
+        pObj->SetReg(reg, ZD_CR87, 0x12);
+        pObj->SetReg(reg, ZD_CR88, 0x0C);
+        pObj->SetReg(reg, ZD_CR89, 0x00);
+        pObj->SetReg(reg, ZD_CR90, 0x10);
+        pObj->SetReg(reg, ZD_CR91, 0x08);
+        pObj->SetReg(reg, ZD_CR93, 0x00);
+
+        pObj->SetReg(reg, ZD_CR94, 0x01);
+#ifdef HOST_IF_USB
+
+        pObj->SetReg(reg, ZD_CR95, 0x0);
+#else
+
+        pObj->SetReg(reg, ZD_CR95, 0x20); //3d24
+
+
+#endif
+
+        pObj->SetReg(reg, ZD_CR96, 0x50);
+        pObj->SetReg(reg, ZD_CR97, 0x37);
+#ifdef HOST_IF_USB
+
+        pObj->SetReg(reg, ZD_CR98, 0x35);
+#else
+
+        pObj->SetReg(reg, ZD_CR98, 0x8d); //4326
+#endif
+
+        pObj->SetReg(reg, ZD_CR101, 0x13);
+        pObj->SetReg(reg, ZD_CR102, 0x27);
+        pObj->SetReg(reg, ZD_CR103, 0x27);
+        pObj->SetReg(reg, ZD_CR104, 0x18);
+        pObj->SetReg(reg, ZD_CR105, 0x12);
+        pObj->SetReg(reg, ZD_CR109, 0x27);
+        pObj->SetReg(reg, ZD_CR110, 0x27);
+        pObj->SetReg(reg, ZD_CR111, 0x27);
+        pObj->SetReg(reg, ZD_CR112, 0x27);
+        pObj->SetReg(reg, ZD_CR113, 0x27);
+        pObj->SetReg(reg, ZD_CR114, 0x27);
+
+        pObj->SetReg(reg, ZD_CR115, 0x26);
+        pObj->SetReg(reg, ZD_CR116, 0x24);
+
+        pObj->SetReg(reg, ZD_CR117, 0xfc);
+        pObj->SetReg(reg, ZD_CR118, 0xfa);
+        pObj->SetReg(reg, ZD_CR120, 0x4f); //3d24
+#ifndef HOST_IF_USB
+
+        pObj->SetReg(reg, ZD_CR123, 0x27); //3d24
+#endif
+
+        pObj->SetReg(reg, ZD_CR125, 0xaa); //4326
+        pObj->SetReg(reg, ZD_CR127, 0x03); //4326
+        pObj->SetReg(reg, ZD_CR128, 0x14);
+        pObj->SetReg(reg, ZD_CR129, 0x12);
+        pObj->SetReg(reg, ZD_CR130, 0x10);
+        pObj->SetReg(reg, ZD_CR131, 0x0C);
+        pObj->SetReg(reg, ZD_CR136, 0xdf);
+        pObj->SetReg(reg, ZD_CR137, 0x40);
+        pObj->SetReg(reg, ZD_CR138, 0xa0);
+        pObj->SetReg(reg, ZD_CR139, 0xb0);
+#ifdef ZD1211
+
+        pObj->SetReg(reg, ZD_CR140, 0x99);
+#elif defined(ZD1211B)
+
+        pObj->SetReg(reg, ZD_CR140, 0x98); //4407
+#endif
+
+        pObj->SetReg(reg, ZD_CR141, 0x82);
+#ifdef ZD1211
+
+        pObj->SetReg(reg, ZD_CR142, 0x54);
+#elif defined(ZD1211B)
+
+        pObj->SetReg(reg, ZD_CR142, 0x53); //4407
+#endif
+
+        pObj->SetReg(reg, ZD_CR143, 0x1c);
+        pObj->SetReg(reg, ZD_CR144, 0x6c);
+        pObj->SetReg(reg, ZD_CR147, 0x07);
+        pObj->SetReg(reg, ZD_CR148, 0x4c);
+        pObj->SetReg(reg, ZD_CR149, 0x50);
+        pObj->SetReg(reg, ZD_CR150, 0x0e);
+        pObj->SetReg(reg, ZD_CR151, 0x18);
+#ifdef ZD1211B
+
+        pObj->SetReg(reg, ZD_CR159, 0x70); //3d24
+#endif
+
+        pObj->SetReg(reg, ZD_CR160, 0xfe);
+        pObj->SetReg(reg, ZD_CR161, 0xee);
+        pObj->SetReg(reg, ZD_CR162, 0xaa);
+        pObj->SetReg(reg, ZD_CR163, 0xfa);
+        pObj->SetReg(reg, ZD_CR164, 0xfa);
+
+        pObj->SetReg(reg, ZD_CR165, 0xea);
+        pObj->SetReg(reg, ZD_CR166, 0xbe);
+        pObj->SetReg(reg, ZD_CR167, 0xbe);
+        pObj->SetReg(reg, ZD_CR168, 0x6a);
+        pObj->SetReg(reg, ZD_CR169, 0xba);
+        pObj->SetReg(reg, ZD_CR170, 0xba);
+        pObj->SetReg(reg, ZD_CR171, 0xba);
+        // Note: CR204 must lead the CR203
+        pObj->SetReg(reg, ZD_CR204, 0x7d);
+        pObj->SetReg(reg, ZD_CR203, 0x30);
+#ifndef HOST_IF_USB
+
+        pObj->SetReg(reg, ZD_CR240, 0x80);
+#endif
+
+#endif
+
+        if(pObj->GetReg(reg, E2P_POD) & BIT_13) {
+                U32 tmp;
+                tmp = pObj->GetReg(reg, E2P_PHY_REG);
+                pObj->SetReg(reg, ZD_CR157, tmp >> 8);
+                printk("Set CR157 = 0x%02x\n", tmp>>8);
+        }
+
+
+        UnLockPhyReg(pObj);
+        return;
+}
+#elif defined(ZD1211B)
+void HW_ResetPhy(zd_80211Obj_t *pObj) {
+        void *reg = pObj->reg;
+
+        // Get Phy-Config permission
+        LockPhyReg(pObj);
+
+        pObj->SetReg(reg,ZD_CR0, 0x14);
+        pObj->SetReg(reg,ZD_CR1, 0x06);
+        pObj->SetReg(reg,ZD_CR2, 0x26);
+        pObj->SetReg(reg,ZD_CR3, 0x38);
+        pObj->SetReg(reg,ZD_CR4, 0x80);
+        pObj->SetReg(reg,ZD_CR9, 0xe0);
+        pObj->SetReg(reg,ZD_CR10, 0x81);
+        //``JWEI 2003/12/26
+#if fTX_PWR_CTRL && fTX_GAIN_OFDM
+
+        pObj->SetReg(reg, ZD_CR11, BIT_6);
+#else
+
+pObj->SetReg(reg,ZD_CR11, 0x00);
+#endif
+
+        pObj->SetReg(reg,ZD_CR12, 0xf0);
+        pObj->SetReg(reg,ZD_CR13, 0x8c);
+        pObj->SetReg(reg,ZD_CR14, 0x80);
+        pObj->SetReg(reg,ZD_CR15, 0x3d);
+        pObj->SetReg(reg,ZD_CR16, 0x20);
+        pObj->SetReg(reg,ZD_CR17, 0x1e);
+        pObj->SetReg(reg,ZD_CR18, 0x0a);
+        pObj->SetReg(reg,ZD_CR19, 0x48);
+        pObj->SetReg(reg,ZD_CR20, 0x10);//Org:0x0E,ComTrend:RalLink AP
+        pObj->SetReg(reg,ZD_CR21, 0x0e);
+        pObj->SetReg(reg,ZD_CR22, 0x23);
+        pObj->SetReg(reg,ZD_CR23, 0x90);
+        pObj->SetReg(reg,ZD_CR24, 0x14);
+        pObj->SetReg(reg,ZD_CR25, 0x40);
+        pObj->SetReg(reg,ZD_CR26, 0x10);
+        pObj->SetReg(reg,ZD_CR27, 0x10);
+        pObj->SetReg(reg,ZD_CR28, 0x7f);
+        pObj->SetReg(reg,ZD_CR29, 0x80);
+#ifndef ASIC
+        // For FWT
+        pObj->SetReg(reg,ZD_CR30, 0x4b);
+#else
+// For Jointly decoder
+pObj->SetReg(reg,ZD_CR30, 0x49);
+#endif
+
+        pObj->SetReg(reg,ZD_CR31, 0x60);
+        pObj->SetReg(reg,ZD_CR32, 0x43);
+        pObj->SetReg(reg,ZD_CR33, 0x08);
+        pObj->SetReg(reg,ZD_CR34, 0x06);
+        pObj->SetReg(reg,ZD_CR35, 0x0a);
+        pObj->SetReg(reg,ZD_CR36, 0x00);
+        pObj->SetReg(reg,ZD_CR37, 0x00);
+        pObj->SetReg(reg,ZD_CR38, 0x38);
+        pObj->SetReg(reg,ZD_CR39, 0x0c);
+        pObj->SetReg(reg,ZD_CR40, 0x84);
+        pObj->SetReg(reg,ZD_CR41, 0x2a);
+        pObj->SetReg(reg,ZD_CR42, 0x80);
+        pObj->SetReg(reg,ZD_CR43, 0x10);
+        pObj->SetReg(reg,ZD_CR44, 0x33);
+        pObj->SetReg(reg,ZD_CR46, 0xff);
+        pObj->SetReg(reg,ZD_CR47, 0x30);
+        pObj->SetReg(reg,ZD_CR48, 0x26);
+        pObj->SetReg(reg,ZD_CR49, 0x5b);
+        pObj->SetReg(reg,ZD_CR64, 0xd0);
+        pObj->SetReg(reg,ZD_CR65, 0x04);
+        pObj->SetReg(reg,ZD_CR66, 0x58);
+        pObj->SetReg(reg,ZD_CR67, 0xc9);
+        pObj->SetReg(reg,ZD_CR68, 0x88);
+        pObj->SetReg(reg,ZD_CR69, 0x41);
+        pObj->SetReg(reg,ZD_CR70, 0x23);
+        pObj->SetReg(reg,ZD_CR71, 0x10);
+        pObj->SetReg(reg,ZD_CR72, 0xff);
+        pObj->SetReg(reg,ZD_CR73, 0x32);
+        pObj->SetReg(reg,ZD_CR74, 0x30);
+        pObj->SetReg(reg,ZD_CR75, 0x65);
+        pObj->SetReg(reg,ZD_CR76, 0x41);
+        pObj->SetReg(reg,ZD_CR77, 0x1b);
+        pObj->SetReg(reg,ZD_CR78, 0x30);
+        pObj->SetReg(reg,ZD_CR79, 0xf0);
+        pObj->SetReg(reg,ZD_CR80, 0x64);
+        pObj->SetReg(reg,ZD_CR81, 0x64);
+        pObj->SetReg(reg,ZD_CR82, 0x00);
+        pObj->SetReg(reg,ZD_CR83, 0x24);
+        pObj->SetReg(reg,ZD_CR84, 0x04);
+        pObj->SetReg(reg,ZD_CR85, 0x00);
+        pObj->SetReg(reg,ZD_CR86, 0x0c);
+        pObj->SetReg(reg,ZD_CR87, 0x12);
+        pObj->SetReg(reg,ZD_CR88, 0x0c);
+        pObj->SetReg(reg,ZD_CR89, 0x00);
+        pObj->SetReg(reg,ZD_CR90, 0x58);
+        pObj->SetReg(reg,ZD_CR91, 0x04);
+        pObj->SetReg(reg,ZD_CR92, 0x00);
+        pObj->SetReg(reg,ZD_CR93, 0x00);
+        pObj->SetReg(reg,ZD_CR94, 0x01);
+        pObj->SetReg(reg,ZD_CR95, 0x20); // ZD1211B
+        pObj->SetReg(reg,ZD_CR96, 0x50);
+        pObj->SetReg(reg,ZD_CR97, 0x37);
+        pObj->SetReg(reg,ZD_CR98, 0x35);
+        pObj->SetReg(reg,ZD_CR99, 0x00);
+        pObj->SetReg(reg,ZD_CR100, 0x01);
+        pObj->SetReg(reg,ZD_CR101, 0x13);
+        pObj->SetReg(reg,ZD_CR102, 0x27);
+        pObj->SetReg(reg,ZD_CR103, 0x27);
+        pObj->SetReg(reg,ZD_CR104, 0x18);
+        pObj->SetReg(reg,ZD_CR105, 0x12);
+        pObj->SetReg(reg,ZD_CR106, 0x04);
+        pObj->SetReg(reg,ZD_CR107, 0x00);
+        pObj->SetReg(reg,ZD_CR108, 0x0a);
+        pObj->SetReg(reg,ZD_CR109, 0x27);
+        pObj->SetReg(reg,ZD_CR110, 0x27);
+        pObj->SetReg(reg,ZD_CR111, 0x27);
+        pObj->SetReg(reg,ZD_CR112, 0x27);
+        pObj->SetReg(reg,ZD_CR113, 0x27);
+        pObj->SetReg(reg,ZD_CR114, 0x27);
+        pObj->SetReg(reg,ZD_CR115, 0x26);
+        pObj->SetReg(reg,ZD_CR116, 0x24);
+        pObj->SetReg(reg,ZD_CR117, 0xfc);
+        pObj->SetReg(reg,ZD_CR118, 0xfa);
+        pObj->SetReg(reg,ZD_CR119, 0x1e);
+        pObj->SetReg(reg,ZD_CR125, 0x90);
+        pObj->SetReg(reg,ZD_CR126, 0x00);
+        pObj->SetReg(reg,ZD_CR127, 0x00);
+        pObj->SetReg(reg,ZD_CR128, 0x14);
+        pObj->SetReg(reg,ZD_CR129, 0x12);
+        pObj->SetReg(reg,ZD_CR130, 0x10);
+        pObj->SetReg(reg,ZD_CR131, 0x0c);
+        pObj->SetReg(reg,ZD_CR136, 0xdf);
+        pObj->SetReg(reg,ZD_CR137, 0xa0);
+        pObj->SetReg(reg,ZD_CR138, 0xa8);
+        pObj->SetReg(reg,ZD_CR139, 0xb4);
+        pObj->SetReg(reg,ZD_CR140, 0x98);
+        pObj->SetReg(reg,ZD_CR141, 0x82);
+        pObj->SetReg(reg,ZD_CR142, 0x53);
+        pObj->SetReg(reg,ZD_CR143, 0x1c);
+        pObj->SetReg(reg,ZD_CR144, 0x6c);
+        pObj->SetReg(reg,ZD_CR147, 0x07);
+        pObj->SetReg(reg,ZD_CR148, 0x40);
+        pObj->SetReg(reg,ZD_CR149, 0x40); // Org:0x50 //ComTrend:RalLink AP
+        pObj->SetReg(reg,ZD_CR150, 0x14);//Org:0x0E //ComTrend:RalLink AP
+        pObj->SetReg(reg,ZD_CR151, 0x18);
+        pObj->SetReg(reg,ZD_CR159, 0x70);
+        pObj->SetReg(reg,ZD_CR160, 0xfe);
+        pObj->SetReg(reg,ZD_CR161, 0xee);
+        pObj->SetReg(reg,ZD_CR162, 0xaa);
+        pObj->SetReg(reg,ZD_CR163, 0xfa);
+        pObj->SetReg(reg,ZD_CR164, 0xfa);
+        pObj->SetReg(reg,ZD_CR165, 0xea);
+        pObj->SetReg(reg,ZD_CR166, 0xbe);
+        pObj->SetReg(reg,ZD_CR167, 0xbe);
+        pObj->SetReg(reg,ZD_CR168, 0x6a);
+        pObj->SetReg(reg,ZD_CR169, 0xba);
+        pObj->SetReg(reg,ZD_CR170, 0xba);
+        pObj->SetReg(reg,ZD_CR171, 0xba);
+        // Note: CR204 must lead the CR203
+        pObj->SetReg(reg,ZD_CR204, 0x7d);
+        pObj->SetReg(reg,ZD_CR203, 0x30);
+
+        // Release Phy-Config permission
+        if(pObj->GetReg(reg, E2P_POD) & BIT_13) {
+                U32 tmp;
+                tmp = pObj->GetReg(reg, E2P_PHY_REG);
+                pObj->SetReg(reg, ZD_CR157, tmp >> 8);
+                printk("Set CR157 = 0x%02x\n", tmp>>8);
+        }
+        UnLockPhyReg(pObj);
+
+
+        return;
+}
+
+#endif
+
+void HW_InitHMAC(zd_80211Obj_t *pObj) {
+        void *reg = pObj->reg;
+
+        // Set GPI_EN be zero. ie. Disable GPI (Requested by Ahu)
+        //pObj->SetReg(reg, ZD_GPI_EN, 0x00);
+
+        // Use Ack_Timeout_Ext to tolerance some peers that response slowly.
+        // The influence is that the retry frame will be less competitive. It's acceptable.
+        pObj->SetReg(reg, ZD_Ack_Timeout_Ext, 0x20); //only bit0-bit5 are valid
+
+        pObj->SetReg(reg, ZD_ADDA_MBIAS_WarmTime, 0x30000808);
+
+        /* Set RetryMax 8 */
+#ifdef ZD1211
+
+        pObj->SetReg(reg, ZD_RetryMAX, 0x2);
+#elif defined(ZD1211B)
+
+        pObj->SetReg(reg, ZD_RetryMAX, 0x02020202);
+
+        pObj->SetReg(reg,0xB0C,0x007f003f);
+        pObj->SetReg(reg,0xB08,0x007f003f);
+        pObj->SetReg(reg,0xB04,0x003f001f);
+        pObj->SetReg(reg,0xB00,0x001f000f);
+        //set AIFS AC0 - AC3
+        pObj->SetReg(reg,0xB10,0x00280028);
+        pObj->SetReg(reg,0xB14,0x008C003C);
+        //set TXOP AC0 - AC3
+        pObj->SetReg(reg,0xB20,0x01800824);
+        //pObj->SetReg(reg,0xB20,0x00800a28);
+
+#endif
+
+        /* Turn off sniffer mode */
+        pObj->SetReg(reg, ZD_SnifferOn, 0);
+
+        /* Set Rx filter*/
+        // filter Beacon and unfilter PS-Poll
+        pObj->SetReg(reg, ZD_Rx_Filter, AP_RX_FILTER);
+
+        /* Set Hashing table */
+        pObj->SetReg(reg, ZD_GroupHash_P1, 0x00);
+        pObj->SetReg(reg, ZD_GroupHash_P2, 0x80000000);
+
+        pObj->SetReg(reg, ZD_CtlReg1, 0xa4);
+        pObj->SetReg(reg, ZD_ADDA_PwrDwn_Ctrl, 0x7f);
+
+        /* Initialize BCNATIM needed registers */
+        pObj->SetReg(reg, ZD_BCNPLCPCfg, 0x00f00401);
+        pObj->SetReg(reg, ZD_PHYDelay, 0x00);
+
+#if defined(OFDM)
+	#ifdef HOST_IF_USB
+
+        pObj->SetReg(reg, ZD_Ack_Timeout_Ext, 0x80);
+        pObj->SetReg(reg, ZD_ADDA_PwrDwn_Ctrl, 0x0);
+#endif
+
+        //pObj->SetReg(reg, ZD_AckTime80211, 0x102);
+        pObj->SetReg(reg, ZD_AckTime80211, 0x100);
+        pObj->SetReg(reg, ZD_IFS_Value, 0x547c032); //0x547c032
+
+        // accept beacon for enable protection mode
+
+        //pObj->SetReg(reg, ZD_Rx_Filter, ((BIT_10 << 16) | (0xffff)));
+        //pObj->SetReg(reg, ZD_Rx_Filter, ((BIT_10 << 16) | (0xffff & ~BIT_8))); //for pure G debug
+
+        // Set RX_PE_DELAY 0x10 to enlarge the time for decharging tx power.
+        pObj->SetReg(reg, ZD_RX_PE_DELAY, 0x70);
+
+        //pObj->SetReg(reg, ZD_SnifferOn, 0x3000000); //enable HW Rx Retry filter, and HW MIC
+        //pObj->SetReg(reg, ZD_Rx_OFFSET, 0x03); //to fit MIC engine's 4 byte alignment
+
+        // Keep 44MHz oscillator always on.
+        pObj->SetReg(reg, ZD_PS_Ctrl, 0x10000000);
+#endif
+
+
+#if defined(AMAC)
+	#if defined(ECCK_60_5)
+
+        pObj->SetReg(reg, ZD_RTS_CTS_Rate, 0x00);
+#elif (defined(GCCK) && defined(OFDM))
+        //pObj->SetReg(reg, ZD_RTS_CTS_Rate, 0x30000);
+        pObj->SetReg(reg, ZD_RTS_CTS_Rate, 0x2030203);
+#endif
+
+        // Set Rx Threshold
+        pObj->SetReg(reg, ZD_RX_THRESHOLD, 0x000c0640);
+
+        // Set Tx-Pwr-Control registers
+        //pObj->SetReg(reg, ZD_TX_PWR_CTRL_1, 0x7f7f7f7f);
+        //pObj->SetReg(reg, ZD_TX_PWR_CTRL_2, 0x7c7f7f7f);
+        //pObj->SetReg(reg, ZD_TX_PWR_CTRL_3, 0x6c6c747c);
+        //pObj->SetReg(reg, ZD_TX_PWR_CTRL_4, 0x00006064);
+
+#ifdef HOST_IF_USB
+
+        pObj->SetReg(reg, ZD_AfterPNP, 0x1);
+        pObj->SetReg(reg, ZD_Wep_Protect, 0x114);
+#else
+
+        pObj->SetReg(reg, ZD_AfterPNP, 0x64009);
+        pObj->SetReg(reg, ZD_Wep_Protect, 0x118); //4315 for TKIP key mixing
+#endif
+#endif
+}
+
+void HW_OverWritePhyRegFromE2P(zd_80211Obj_t *pObj) {
+        U32 tmpvalue;
+        void *reg = pObj->reg;
+
+#ifdef HOST_IF_USB
+
+        if (!pObj->bOverWritePhyRegFromE2P)
+                return;
+
+        LockPhyReg(pObj);
+        tmpvalue = pObj->GetReg(reg, E2P_PHY_REG);
+        pObj->SetReg(reg, ZD_CR47, (tmpvalue & 0xFF));
+        UnLockPhyReg(pObj);
+        return;
+#endif
+}
+
+void HW_WritePhyReg(zd_80211Obj_t *pObj, U8 PhyIdx, U8 PhyValue) {
+        U32	IoAddress;
+        void *reg = pObj->reg;
+
+        switch(PhyIdx) {
+        case 4:
+                IoAddress = 0x20;
+                break;
+
+        case 5:
+                IoAddress = 0x10;
+                break;
+
+        case 6:
+                IoAddress = 0x14;
+                break;
+
+        case 7:
+                IoAddress = 0x18;
+                break;
+
+        case 8:
+                IoAddress = 0x1C;
+                break;
+
+        default:
+                IoAddress = (((U32)PhyIdx) << 2);
+
+                break;
+        }
+
+        LockPhyReg(pObj);
+        pObj->SetReg(reg, IoAddress, PhyValue);
+        UnLockPhyReg(pObj);
+}
+
+
+void HW_UpdateIntegrationValue(zd_80211Obj_t *pObj, U32 ChannelNo, const U8 MAC_Mode) {
+#ifdef ZD1211B
+        void *reg = pObj->reg;
+        struct zd1205_private *macp = (struct zd1205_private *) g_dev->priv;
+#endif
+#ifdef HOST_IF_USB
+        U32	tmpvalue;
+        u8 Useless_set, intV;
+
+        //tmpvalue = pObj->GetReg(reg, ZD_E2P_PWR_INT_VALUE1+((ChannelNo-1) & 0xc));
+        //tmpvalue = (U8) (tmpvalue >> (((ChannelNo - 1) % 4) * 8));
+        if(PURE_A_MODE != MAC_Mode)
+                tmpvalue = pObj->IntValue[ChannelNo - 1];
+        else if(PURE_A_MODE == MAC_Mode) {
+                a_OSC_get_cal_int(ChannelNo, RATE_54M,&intV,&Useless_set);
+                tmpvalue = intV;
+        } else
+                VerAssert();
+        HW_Write_TxGain1(pObj, (U8) tmpvalue, cTX_CCK);
+#endif
+#ifdef ZD1211B
+
+        LockPhyReg(pObj);
+        if(PURE_A_MODE != MAC_Mode) {
+                pObj->SetReg(reg,ZD_CR65,macp->SetPointOFDM[2][ChannelNo-1]);
+                pObj->SetReg(reg,ZD_CR66,macp->SetPointOFDM[1][ChannelNo-1]);
+                pObj->SetReg(reg,ZD_CR67,macp->SetPointOFDM[0][ChannelNo-1]);
+                pObj->SetReg(reg,ZD_CR68,macp->EepSetPoint[ChannelNo-1]);
+        } else {
+                u8 set36,set48,set54, intValue;
+                a_OSC_get_cal_int( ChannelNo, RATE_54M, &intValue, &set54);
+                a_OSC_get_cal_int( ChannelNo, RATE_48M, &intValue, &set48);
+                a_OSC_get_cal_int( ChannelNo, RATE_36M, &intValue, &set36);
+                pObj->SetReg(reg,ZD_CR65,set54);
+                pObj->SetReg(reg,ZD_CR66,set48);
+                pObj->SetReg(reg,ZD_CR67,set36);
+                pObj->SetReg(reg,ZD_CR68,macp->EepSetPoint[ChannelNo-1]);
+        }
+
+        pObj->SetReg(reg,ZD_CR69,0x28);
+        pObj->SetReg(reg,ZD_CR69,0x2a);
+
+        UnLockPhyReg(pObj);
+#endif
+}
+
+void HW_Write_TxGain(zd_80211Obj_t *pObj, U32 txgain) {
+        U32	tmpvalue;
+        void *reg = pObj->reg;
+        U8	i;
+
+        switch(pObj->rfMode) {
+        case GCT_RF:
+                txgain &= 0x3f;
+
+                //FPRINT_V("Set tx gain", txgain);
+                tmpvalue = 0;
+                // Perform Bit-Reverse
+                for (i=0; i<6; i++) {
+                        if (txgain & BIT_0) {
+                                tmpvalue |= (0x1 << (15-i));
+                        }
+                        txgain = (txgain >> 1);
+                }
+                tmpvalue |= 0x0c0000;
+                HW_Set_IF_Synthesizer(pObj, tmpvalue);
+                //FPRINT_V("HW_Set_IF_Synthesizer", tmpvalue);
+                HW_Set_IF_Synthesizer(pObj, 0x150800);
+                HW_Set_IF_Synthesizer(pObj, 0x150000);
+                break;
+
+        case AL2210_RF:
+        case AL2210MPVB_RF:
+                if (txgain > AL2210_MAX_TX_PWR_SET) {
+                        txgain = AL2210_MAX_TX_PWR_SET;
+                } else if (txgain < AL2210_MIN_TX_PWR_SET) {
+                        txgain = AL2210_MIN_TX_PWR_SET;
+                }
+
+                LockPhyReg(pObj);
+                pObj->SetReg(reg, ZD_CR31, (U8)txgain);
+                UnLockPhyReg(pObj);
+                break;
+
+        default:
+                break;
+        }
+}
+
+
+void HW_Write_TxGain0(zd_80211Obj_t *pObj, U8 *pTxGain, U8 TxPwrType) {
+        void *reg = pObj->reg;
+
+        switch (pObj->rfMode) {
+        case MAXIM_NEW_RF:
+                *pTxGain &= MAXIM2_MAX_TX_PWR_SET;
+                LockPhyReg(pObj);
+
+                if (TxPwrType != cTX_OFDM) {
+                        pObj->SetReg(reg, ZD_CR31, *pTxGain);
+                } else {
+#if !fTX_GAIN_OFDM
+                        pObj->SetReg(reg, ZD_CR31, *pTxGain);
+#else
+
+                        pObj->SetReg(reg, ZD_CR51, *pTxGain);
+                        pObj->SetReg(reg, ZD_CR52, *pTxGain);
+                        pObj->SetReg(reg, ZD_CR53, *pTxGain);
+#endif
+
+                }
+                UnLockPhyReg(pObj);
+                break;
+
+        case RFMD_RF:
+        case AL2230_RF:
+        case AL7230B_RF:
+                LockPhyReg(pObj);
+                if (TxPwrType != cTX_OFDM) {
+                        pObj->SetReg(reg, ZD_CR31, *pTxGain);
+                } else {
+#if !fTX_GAIN_OFDM
+                        pObj->SetReg(reg, ZD_CR31, *pTxGain);
+#else
+
+                        pObj->SetReg(reg, ZD_CR51, *pTxGain);
+                        pObj->SetReg(reg, ZD_CR52, *pTxGain);
+                        pObj->SetReg(reg, ZD_CR53, *pTxGain);
+#endif
+
+                }
+                UnLockPhyReg(pObj);
+                break;
+        default:
+                break;
+        }
+}
+
+void HW_Write_TxGain1(zd_80211Obj_t *pObj, U8 txgain, U8 TxPwrType) {
+        U8   *pTxGain;
+
+        HW_Write_TxGain0(pObj, &txgain, TxPwrType);
+
+#if fTX_GAIN_OFDM
+
+        if (TxPwrType != cTX_OFDM)
+                pTxGain = &(pObj->TxGainSetting);
+        else
+                pTxGain = &(pObj->TxGainSetting2);
+#else
+
+        pTxGain = &(pObj->TxGainSetting);
+#endif
+
+        *pTxGain = txgain;
+}
+
+void HW_Write_TxGain2(zd_80211Obj_t *pObj, U8 TxPwrType) {
+        U8   *pTxGain;
+
+
+        if (TxPwrType != cTX_OFDM) {
+                pTxGain = &(pObj->TxGainSetting);
+        } else {
+#if fTX_GAIN_OFDM
+                pTxGain = &(pObj->TxGainSetting2);
+#else
+
+                pTxGain = &(pObj->TxGainSetting);
+#endif
+
+        }
+
+        HW_Write_TxGain0(pObj, pTxGain, TxPwrType);
+}
+
+void HW_Set_FilterBand(zd_80211Obj_t *pObj, U32	region_code) {
+        U32	tmpLong;
+        void *reg = pObj->reg;
+
+        switch(region_code) {
+        case 0x40:	// Japan
+                LockPhyReg(pObj);
+                //if (pObj->rfMode == MAXIM_NEW_RF)
+                {
+                        tmpLong = pObj->GetReg(reg, ZD_CR5);
+                        tmpLong |= BIT_6;	//japan
+                        pObj->SetReg(reg, ZD_CR5, tmpLong);
+                }
+
+                UnLockPhyReg(pObj);
+                break;
+
+        default:
+                LockPhyReg(pObj);
+                tmpLong = pObj->GetReg(reg, ZD_CR5);
+                tmpLong &= ~BIT_6;//USA
+
+                pObj->SetReg(reg, ZD_CR5, tmpLong);
+                UnLockPhyReg(pObj);
+                break;
+        }
+}
+
+
+void HW_UpdateBcnInterval(zd_80211Obj_t *pObj, U16 BcnInterval) {
+        void *reg = pObj->reg;
+        U32	tmpvalue;
+        U32	ul_PreTBTT;
+        U32	ul_ATIMWnd;
+
+
+        //++
+        // Make sure that BcnInterval > Pre_TBTT > ATIMWnd >= 0
+        if (BcnInterval < 5) {
+                BcnInterval = 5;
+        }
+
+        ul_PreTBTT = pObj->GetReg(reg, ZD_Pre_TBTT);
+        if (ul_PreTBTT < 4) {
+                ul_PreTBTT = 4;
+        }
+
+        if (ul_PreTBTT >= BcnInterval) {
+                ul_PreTBTT = BcnInterval-1;
+
+        }
+        pObj->SetReg(reg, ZD_Pre_TBTT, ul_PreTBTT);
+
+        ul_ATIMWnd = pObj->GetReg(reg, ZD_ATIMWndPeriod);
+        if (ul_ATIMWnd >= ul_PreTBTT) {
+                ul_ATIMWnd = ul_PreTBTT-1;
+        }
+        pObj->SetReg(reg, ZD_ATIMWndPeriod, ul_ATIMWnd);
+
+        tmpvalue = pObj->GetReg(reg, ZD_BCNInterval);
+        tmpvalue &= ~0xffff;
+        tmpvalue |= BcnInterval;
+        pObj->SetReg(reg, ZD_BCNInterval, tmpvalue);
+
+        pObj->BeaconInterval = BcnInterval;
+}
+
+
+
+
+void HW_UpdateATIMWindow(zd_80211Obj_t *pObj, U16 AtimWnd) {
+        void *reg = pObj->reg;
+        U32	ul_PreTBTT;
+
+        //++
+        // Make sure that Pre_TBTT > ATIMWnd >= 0
+
+        ul_PreTBTT = pObj->GetReg(reg, ZD_Pre_TBTT);
+        if (AtimWnd >= ul_PreTBTT) {
+                AtimWnd = (U16)(ul_PreTBTT-1);
+        }
+        //--
+
+        pObj->SetReg(reg, ZD_ATIMWndPeriod, AtimWnd);
+}
+
+
+void HW_UpdatePreTBTT(zd_80211Obj_t *pObj, U32 pretbtt) {
+        void *reg = pObj->reg;
+        U32	ul_BcnItvl;
+        U32	ul_AtimWnd;
+
+        //++
+        // Make sure that BcnInterval > Pre_TBTT > ATIMWnd
+        ul_BcnItvl = pObj->GetReg(reg, ZD_BCNInterval);
+        ul_BcnItvl &= 0xff;
+        if (pretbtt >= ul_BcnItvl) {
+                pretbtt = ul_BcnItvl-1;
+        }
+
+        ul_AtimWnd = pObj->GetReg(reg, ZD_ATIMWndPeriod);
+        if (pretbtt <= ul_AtimWnd) {
+                pretbtt = ul_AtimWnd+1;
+        }
+        //--
+
+        pObj->SetReg(reg, ZD_Pre_TBTT, pretbtt);
+}
+
+// for AMAC CAM operation
+void HW_CAM_Avail(zd_80211Obj_t *pObj) {
+        void *reg = pObj->reg;
+        U32 tmpValue;
+
+        tmpValue = pObj->GetReg(reg, ZD_CAM_MODE);
+        while(tmpValue & HOST_PEND) {
+                pObj->DelayUs(10);
+                tmpValue = pObj->GetReg(reg, ZD_CAM_MODE);
+        }
+}
+
+void HW_CAM_Write(zd_80211Obj_t *pObj, U32 address, U32 data) {
+        void *reg = pObj->reg;
+
+        HW_CAM_Avail(pObj);
+        pObj->SetReg(reg, ZD_CAM_DATA, data);
+        pObj->SetReg(reg, ZD_CAM_ADDRESS, (address | CAM_WRITE));
+}
+
+U32 HW_CAM_Read(zd_80211Obj_t *pObj, U32 address) {
+        void *reg = pObj->reg;
+        U32 result;
+
+        HW_CAM_Avail(pObj);
+        pObj->SetReg(reg, ZD_CAM_ADDRESS, address);
+        HW_CAM_Avail(pObj);
+        result = pObj->GetReg(reg, ZD_CAM_DATA);
+
+        return result;
+}
+
+void HW_CAM_SetMAC(zd_80211Obj_t *pObj, U16 aid, U8 *pMAC) {
+        U32 userWordAddr;
+        U32 userByteOffset;
+        U32 tmpValue;
+        int i;
+
+        userWordAddr = (aid/4)*6;
+        userByteOffset = aid % 4;
+
+        for (i=0; i<MAC_LENGTH; i++) {
+                tmpValue = HW_CAM_Read(pObj, (userWordAddr+i));
+                tmpValue &= ~(0xff << (userByteOffset*8));
+                tmpValue |= pMAC[i]<<(userByteOffset*8);
+                HW_CAM_Write(pObj, (userWordAddr+i), tmpValue);
+        }
+}
+
+
+void HW_CAM_GetMAC(zd_80211Obj_t *pObj, U16 aid, U8 *pMac) {
+        U32 userWordAddr;
+        U32 userByteOffset;
+        U32 tmpValue;
+        U8 mac[6];
+        int i;
+
+        userWordAddr = (aid/4)*6;
+        userByteOffset = aid % 4;
+
+        for (i=0; i<MAC_LENGTH; i++) {
+                tmpValue = HW_CAM_Read(pObj, (userWordAddr+i));
+                mac[i] = (U8)(tmpValue >> (userByteOffset*8)) & 0xFF;
+        }
+
+        if (memcmp(mac, pMac, 6) != 0) {
+                FPRINT("*****Where is my MAC ????");
+        } else
+                FPRINT("*****Verify MAC OK!!!");
+}
+
+
+void HW_CAM_SetEncryType(zd_80211Obj_t *pObj, U16 aid, U8 encryType) {
+        U32 encryWordAddr;
+        U32 encryByteOffset;
+        U32 tmpValue;
+
+        U8 targetByte;
+
+        encryWordAddr = ENCRY_TYPE_START_ADDR + (aid/8);
+        encryByteOffset = (aid/2) % 4;
+
+        tmpValue = HW_CAM_Read(pObj, encryWordAddr);
+        targetByte = (U8)(tmpValue >> (encryByteOffset*8));
+        tmpValue &= ~(0xff << (encryByteOffset*8)); //clear target byte
+        if (aid % 2)
+                targetByte = (encryType<<4) | (targetByte & 0xf); //set hignt part
+        else //low nibble
+                targetByte = encryType | (targetByte & 0xf0); //set low part
+
+        tmpValue |= targetByte << (encryByteOffset*8);
+
+
+        HW_CAM_Write(pObj, encryWordAddr, tmpValue);
+}
+
+
+U8 HW_CAM_GetEncryType(zd_80211Obj_t *pObj, U16 aid) {
+        U32 encryWordAddr;
+        U32 encryByteOffset;
+
+        U32 tmpValue;
+        U8 keyLength = 0;
+        U8 targetByte;
+
+        encryWordAddr = ENCRY_TYPE_START_ADDR + (aid/8);
+        encryByteOffset = (aid/2) % 4;
+
+        tmpValue = HW_CAM_Read(pObj, encryWordAddr);
+        targetByte = (U8)(tmpValue >> (encryByteOffset*8));
+        if (aid % 2)
+                targetByte >>= 4; //get hignt part
+        else
+                targetByte &= 0x0f; //get low part
+
+        switch(targetByte) {
+        case NO_WEP: //0
+                FPRINT("***No Encryption");
+                break;
+
+        case WEP64: //1
+                FPRINT("***WEP 64");
+                keyLength = 5;
+                break;
+
+        case TKIP: //2
+                FPRINT("**TKIP");
+                keyLength = 16;
+                break;
+
+        case AES: //4
+
+                FPRINT("***CCM");
+                keyLength = 16;
+                break;
+
+
+        case WEP128: //5
+                FPRINT("***WEP 128");
+                keyLength = 13;
+                break;
+
+        default:
+                FPRINT("***Not Supported Encry");
+                break;
+        }
+
+        return keyLength;
+
+}
+
+
+void HW_CAM_SetKey(zd_80211Obj_t *pObj, U16 aid, U8 keyLength, U8 *pKey) {
+        U32 keyWordAddr;
+        U8 offset;
+        U32 tmpValue;
+        int i, j, k;
+
+        keyWordAddr = KEY_START_ADDR + (aid*8);
+
+        offset = 0;
+        for (i=0; i<8; i++) {
+                tmpValue = HW_CAM_Read(pObj, (keyWordAddr+i));
+                for (j=offset, k=0; k<4; j++, k++) {
+                        tmpValue &= ~(0xff << (k*8));
+                        if (offset < keyLength) {
+                                tmpValue |= pKey[j] << (k*8);
+                        }
+                        offset++;
+                }
+                HW_CAM_Write(pObj, (keyWordAddr+i), tmpValue);
+        }
+
+}
+
+
+void HW_CAM_GetKey(zd_80211Obj_t *pObj, U16 aid, U8 keyLength, U8 *pKey) {
+        U32 keyWordAddr;
+        U8 key[32];
+        int i, j;
+        U32 tmpValue;
+
+        keyWordAddr = KEY_START_ADDR + (aid*8);
+        j = 0;
+        for (i=0; i<8; i++) {
+                tmpValue = HW_CAM_Read(pObj, (keyWordAddr+i));
+                key[j] = (U8)(tmpValue);
+                j++;
+                key[j] = (U8)(tmpValue >> 8);
+                j++;
+                key[j] = (U8)(tmpValue >> 16);
+                j++;
+                key[j] = (U8)(tmpValue >> 24);
+                j++;
+        }
+
+        if (memcmp(&key[0], pKey, keyLength) != 0) {
+                FPRINT("*****Where is my Key ????");
+        } else
+                FPRINT("*****Verify KEY OK!!!");
+}
+
+
+void HW_CAM_UpdateRollTbl(zd_80211Obj_t *pObj, U16 aid) {
+        void *reg = pObj->reg;
+        U32 tmpValue;
+
+        if (aid >= 32) {
+                tmpValue = pObj->GetReg(reg, ZD_CAM_ROLL_TB_HIGH);
+                tmpValue |= BIT_0 << (aid-32);
+                pObj->SetReg(reg, ZD_CAM_ROLL_TB_HIGH, tmpValue);
+        } else {
+                tmpValue = pObj->GetReg(reg, ZD_CAM_ROLL_TB_LOW);
+                tmpValue |= (BIT_0 << aid);
+                pObj->SetReg(reg, ZD_CAM_ROLL_TB_LOW, tmpValue);
+        }
+}
+
+
+void HW_CAM_ResetRollTbl(zd_80211Obj_t *pObj) {
+        void *reg = pObj->reg;
+
+        pObj->SetReg(reg, ZD_CAM_ROLL_TB_LOW, 0);
+        pObj->SetReg(reg, ZD_CAM_ROLL_TB_HIGH, 0);
+}
+
+
+void HW_CAM_ClearRollTbl(zd_80211Obj_t *pObj, U16 aid) {
+        void *reg = pObj->reg;
+        U32 tmpValue;
+
+
+        //update roll table
+        if (aid > 32) {
+                tmpValue = pObj->GetReg(reg, ZD_CAM_ROLL_TB_HIGH);
+                tmpValue &= ~(BIT_0 << (aid-32)); //set user invalid
+                pObj->SetReg(reg, ZD_CAM_ROLL_TB_HIGH, tmpValue);
+        } else {
+                tmpValue = pObj->GetReg(reg, ZD_CAM_ROLL_TB_LOW);
+                tmpValue &= ~(BIT_0 << aid); //set user invalid
+                pObj->SetReg(reg, ZD_CAM_ROLL_TB_LOW, tmpValue);
+        }
+}
+#if 0
+void HW_ConfigDynaKey(zd_80211Obj_t *pObj, U16 aid, U8 *pMac, U8 *pKey, U8 keyLength, U8 encryType) {
+        //void *reg = pObj->reg;
+
+        //set MAC address
+        HW_CAM_SetMAC(pObj, aid, pMac);
+        HW_CAM_SetEncryType(pObj, aid, encryType);
+        HW_CAM_SetKey(pObj, aid, keyLength, pKey);
+        HW_CAM_UpdateRollTbl(pObj, aid);
+}
+#endif
+void HW_ConfigDynaKey(zd_80211Obj_t *pObj, U16 aid, U8 *pMac, U8 *pKey, U8 keyLength, U8 encryType, U8 change_enc) {
+        //set MAC address
+        //	int	flags;
+        //flags = pObj->EnterCS();
+        HW_CAM_ClearRollTbl(pObj, aid);
+        if (change_enc)
+                //if (1)
+        {
+                HW_CAM_SetMAC(pObj, aid, pMac);
+                HW_CAM_SetEncryType(pObj, aid, encryType);
+        }
+        HW_CAM_SetKey(pObj, aid, keyLength, pKey);
+        HW_CAM_UpdateRollTbl(pObj, aid);
+        //pObj->ExitCS(flags);
+}
+
+void HW_ConfigStatKey(zd_80211Obj_t *pObj, U8 *pKey, U8 keyLen, U32 startAddr) {
+        int i, j, k, offset;
+        U32 tmpKey = 0;
+
+        j = 0;
+        offset = 0;
+
+        while(offset < keyLen) {
+                for (i=offset, k=0; k<4; i++, k++) {
+                        tmpKey |= pKey[i] << ((k%4)*8);
+                        offset++;
+                        if (offset == keyLen)
+                                goto last_part;
+                }
+                HW_CAM_Write(pObj, startAddr+j, tmpKey);
+                j++;
+                tmpKey = 0;
+        }
+
+last_part:
+        HW_CAM_Write(pObj, startAddr+j, tmpKey);
+}
+
+
+void HW_GetStatKey(zd_80211Obj_t *pObj) {
+        //void *reg = pObj->reg;
+        int i, j;
+        U8 key[128];
+        U32 tmpValue;
+        U32 encryType;
+        U8	keyLength;
+
+        encryType = HW_CAM_Read(pObj, DEFAULT_ENCRY_TYPE);
+        switch(encryType) {
+        case WEP64:
+                FPRINT("WEP64 Mode");
+
+                keyLength = 5;
+                break;
+
+        case WEP128:
+                FPRINT("WEP128 Mode");
+                keyLength = 13;
+                break;
+
+        case WEP256:
+                FPRINT("WEP256 Mode");
+                keyLength = 29;
+                break;
+
+        default:
+                FPRINT("Not supported Mode");
+                return;
+
+        }
+
+        for (i=0, j=0; i<32; i++) {
+                tmpValue = HW_CAM_Read(pObj, (STA_KEY_START_ADDR+i));
+
+                key[j] = (U8)(tmpValue);
+                j++;
+                key[j] = (U8)(tmpValue >> 8);
+                j++;
+                key[j] = (U8)(tmpValue >> 16);
+                j++;
+                key[j] = (U8)(tmpValue >> 24);
+                j++;
+        }
+
+        zd1205_dump_data("Key 1 = ", (U8 *)&key[0], keyLength);
+        zd1205_dump_data("Key 2 = ", (U8 *)&key[32], keyLength);
+        zd1205_dump_data("Key 3 = ", (U8 *)&key[2*32], keyLength);
+        zd1205_dump_data("Key 4 = ", (U8 *)&key[3*32], keyLength);
+        return;
+}
+
+
+void HW_EEPROM_ACCESS(zd_80211Obj_t *pObj, U8 RamAddr, U32 RomAddr, U32 length, U8 bWrite) {
+        void *reg = pObj->reg;
+        U32 status;
+        U32 access = 0;
+        U32 startTime;
+        U32 endTime;
+        U32 diffTime;
+        int count = 0;
+
+        if (bWrite) {
+                FPRINT("Write Access");
+        } else
+                FPRINT("Read Access");
+
+
+        FPRINT_V("RomAddr", RomAddr);
+        FPRINT_V("RamAddr", RamAddr);
+        FPRINT_V("Length", length);
+
+        if (bWrite) {
+                access = EEPROM_WRITE_ACCESS;
+                //unlock write access
+                pObj->SetReg(reg, ZD_EPP_KEY_PROT, 0x55aa);
+                pObj->SetReg(reg, ZD_EPP_KEY_PROT, 0x44bb);
+                pObj->SetReg(reg, ZD_EPP_KEY_PROT, 0x33cc);
+                pObj->SetReg(reg, ZD_EPP_KEY_PROT, 0x22dd);
+        }
+
+        pObj->SetReg(reg, ZD_EPP_ROM_ADDRESS, RomAddr);
+        pObj->SetReg(reg, ZD_EPP_SRAM_ADDRESS, RamAddr);
+        pObj->SetReg(reg, ZD_EPP_LENG_DIR, access | length);
+
+        startTime = pObj->GetReg(reg, ZD_TSF_LowPart);
+
+        pObj->DelayUs(2000);
+        status = pObj->GetReg(reg, ZD_EPP_CLOCK_DIV);
+        while(status & EEPROM_BUSY_FLAG) {
+                pObj->DelayUs(1000);
+                //FPRINT("EEPROM programming !!!");
+                status = pObj->GetReg(reg, ZD_EPP_CLOCK_DIV);
+
+                if (count > 500) {
+                        FPRINT("EEPROM Timeout !!!");
+                        if (bWrite)
+                                pObj->SetReg(reg, ZD_EPP_KEY_PROT, 0x00);
+                        return;
+                }
+                //len = pObj->GetReg(reg, ZD_EPP_LENG_DIR);
+                //FPRINT_V("len", len);
+                count++;
+        }
+
+        endTime = pObj->GetReg(reg, ZD_TSF_LowPart);
+        if (endTime > startTime) {
+                diffTime = endTime - startTime;
+        } else {
+                diffTime = 0xffffffff + startTime - endTime;
+        }
+
+        //FPRINT_V("Processing Time", diffTime);
+
+        printk("\nProcessing Time = %lu ms\n", diffTime/1000);
+
+
+        //lock write access
+        if (bWrite)
+                pObj->SetReg(reg, ZD_EPP_KEY_PROT, 0x00);
+}
+
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdhw.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdhw.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdhw.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdhw.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,678 @@
+#ifndef __ZDHW_H__
+#define __ZDHW_H__
+
+#include "zdequates.h"
+
+#define		RTS_RATE_1M				0x00
+#define		RTS_RATE_11M			0x03
+#define		RTS_RATE_24M			0x09
+#define		RTS_MOD_TYPE_OFDM		0x100
+#define		RTS_PMB_TYPE_SHORT		0x200
+#define		CTS_RATE_11M			0x30000
+#define		CTS_RATE_24M			0x90000
+#define		CTS_MOD_TYPE_OFDM		0x1000000
+#define		CTS_PMB_TYPE_SHORT		0x2000000
+#define		NON_BARKER_PMB_SET		(RTS_MOD_TYPE_OFDM | RTS_PMB_TYPE_SHORT | CTS_MOD_TYPE_OFDM | CTS_PMB_TYPE_SHORT)
+#define		NON_PROTECT_SET			(RTS_MOD_TYPE_OFDM | CTS_MOD_TYPE_OFDM)
+
+#define		ZD_CR0			0x0000
+#define		ZD_CR1			0x0004
+#define		ZD_CR2			0x0008
+#define		ZD_CR3			0x000C
+#define		ZD_CR5			0x0010
+#define		ZD_CR6			0x0014
+#define		ZD_CR7			0x0018
+#define		ZD_CR8			0x001C
+#define		ZD_CR4			0x0020
+#define		ZD_CR9			0x0024
+#define		ZD_CR10			0x0028
+#define		ZD_CR11			0x002C
+#define		ZD_CR12			0x0030
+#define		ZD_CR13			0x0034
+#define		ZD_CR14			0x0038
+#define		ZD_CR15			0x003C
+#define		ZD_CR16			0x0040
+#define		ZD_CR17			0x0044
+#define		ZD_CR18			0x0048
+#define		ZD_CR19			0x004C
+#define		ZD_CR20			0x0050
+#define		ZD_CR21			0x0054
+#define		ZD_CR22			0x0058
+#define		ZD_CR23			0x005C
+#define		ZD_CR24			0x0060
+#define		ZD_CR25			0x0064
+#define		ZD_CR26			0x0068
+#define		ZD_CR27			0x006C
+#define		ZD_CR28			0x0070
+#define		ZD_CR29			0x0074
+#define		ZD_CR30			0x0078
+#define		ZD_CR31			0x007C
+#define		ZD_CR32			0x0080
+#define		ZD_CR33			0x0084
+#define		ZD_CR34			0x0088
+#define		ZD_CR35			0x008C
+#define		ZD_CR36			0x0090
+#define		ZD_CR37			0x0094
+#define		ZD_CR38			0x0098
+#define		ZD_CR39			0x009C
+#define		ZD_CR40			0x00A0
+#define		ZD_CR41			0x00A4
+#define		ZD_CR42			0x00A8
+#define		ZD_CR43			0x00AC
+#define		ZD_CR44			0x00B0
+#define		ZD_CR45			0x00B4
+#define		ZD_CR46			0x00B8
+#define		ZD_CR47			0x00BC
+#define		ZD_CR48			0x00C0
+#define		ZD_CR49			0x00C4
+#define		ZD_CR50			0x00C8
+#define		ZD_CR51			0x00CC
+#define		ZD_CR52			0x00D0
+#define		ZD_CR53			0x00D4
+#define		ZD_CR54			0x00D8
+#define		ZD_CR55			0x00DC
+#define		ZD_CR56			0x00E0
+#define		ZD_CR57			0x00E4
+#define		ZD_CR58			0x00E8
+#define		ZD_CR59			0x00EC
+#define		ZD_CR60			0x00F0
+#define		ZD_CR61			0x00F4
+#define		ZD_CR62			0x00F8
+#define		ZD_CR63			0x00FC
+#define		ZD_CR64			0x0100
+#define		ZD_CR65			0x0104
+#define		ZD_CR66			0x0108
+#define		ZD_CR67			0x010C
+#define		ZD_CR68			0x0110
+#define		ZD_CR69			0x0114
+#define		ZD_CR70			0x0118
+#define		ZD_CR71			0x011C
+#define		ZD_CR72			0x0120
+#define		ZD_CR73			0x0124
+#define		ZD_CR74			0x0128
+#define		ZD_CR75			0x012C
+#define		ZD_CR76			0x0130
+#define		ZD_CR77			0x0134
+#define		ZD_CR78			0x0138
+#define		ZD_CR79			0x013C
+#define		ZD_CR80			0x0140
+#define		ZD_CR81			0x0144
+#define		ZD_CR82			0x0148
+#define		ZD_CR83			0x014C
+#define		ZD_CR84			0x0150
+#define		ZD_CR85			0x0154
+#define		ZD_CR86			0x0158
+#define		ZD_CR87			0x015C
+#define		ZD_CR88			0x0160
+#define		ZD_CR89			0x0164
+#define		ZD_CR90			0x0168
+#define		ZD_CR91			0x016C
+#define		ZD_CR92			0x0170
+#define		ZD_CR93			0x0174
+#define		ZD_CR94			0x0178
+#define		ZD_CR95			0x017C
+#define		ZD_CR96			0x0180
+#define		ZD_CR97			0x0184
+#define		ZD_CR98			0x0188
+#define		ZD_CR99			0x018C
+#define		ZD_CR100		0x0190
+#define		ZD_CR101		0x0194
+#define		ZD_CR102		0x0198
+#define		ZD_CR103		0x019C
+#define		ZD_CR104		0x01A0
+#define		ZD_CR105		0x01A4
+#define		ZD_CR106		0x01A8
+#define		ZD_CR107		0x01AC
+#define		ZD_CR108		0x01B0
+#define		ZD_CR109		0x01B4
+#define		ZD_CR110		0x01B8
+#define		ZD_CR111		0x01BC
+#define		ZD_CR112		0x01C0
+#define		ZD_CR113		0x01C4
+#define		ZD_CR114		0x01C8
+#define		ZD_CR115		0x01CC
+#define		ZD_CR116		0x01D0
+#define		ZD_CR117		0x01D4
+#define		ZD_CR118		0x01D8
+#define		ZD_CR119		0x01DC
+#define		ZD_CR120		0x01E0
+#define		ZD_CR121		0x01E4
+#define		ZD_CR122		0x01E8
+#define		ZD_CR123		0x01EC
+#define		ZD_CR124		0x01F0
+#define		ZD_CR125		0x01F4
+#define		ZD_CR126		0x01F8
+#define		ZD_CR127		0x01FC
+#define		ZD_CR128		0x0200
+#define		ZD_CR129		0x0204
+#define		ZD_CR130		0x0208
+#define		ZD_CR131		0x020C
+#define		ZD_CR132		0x0210
+#define		ZD_CR133		0x0214
+#define		ZD_CR134		0x0218
+#define		ZD_CR135		0x021C
+#define		ZD_CR136		0x0220
+#define		ZD_CR137		0x0224
+#define		ZD_CR138		0x0228
+#define		ZD_CR139		0x022C
+#define		ZD_CR140		0x0230
+#define		ZD_CR141		0x0234
+#define		ZD_CR142		0x0238
+#define		ZD_CR143		0x023C
+#define		ZD_CR144		0x0240
+#define		ZD_CR145		0x0244
+#define		ZD_CR146		0x0248
+#define		ZD_CR147		0x024C
+#define		ZD_CR148		0x0250
+#define		ZD_CR149		0x0254
+#define		ZD_CR150		0x0258
+#define		ZD_CR151		0x025C
+#define		ZD_CR152		0x0260
+#define		ZD_CR153		0x0264
+#define		ZD_CR154		0x0268
+#define		ZD_CR155		0x026C
+#define		ZD_CR156		0x0270
+#define		ZD_CR157		0x0274
+#define		ZD_CR158		0x0278
+#define		ZD_CR159		0x027C
+#define		ZD_CR160		0x0280
+#define		ZD_CR161		0x0284
+#define		ZD_CR162		0x0288
+#define		ZD_CR163		0x028C
+#define		ZD_CR164		0x0290
+#define		ZD_CR165		0x0294
+#define		ZD_CR166		0x0298
+#define		ZD_CR167		0x029C
+#define		ZD_CR168		0x02A0
+#define		ZD_CR169		0x02A4
+#define		ZD_CR170		0x02A8
+#define		ZD_CR171		0x02AC
+#define		ZD_CR172		0x02B0
+#define		ZD_CR173		0x02B4
+#define		ZD_CR174		0x02B8
+#define		ZD_CR175		0x02BC
+#define		ZD_CR176		0x02C0
+#define		ZD_CR177		0x02C4
+#define		ZD_CR178		0x02C8
+#define		ZD_CR179		0x02CC
+#define		ZD_CR180		0x02D0
+#define		ZD_CR181		0x02D4
+#define		ZD_CR182		0x02D8
+#define		ZD_CR183		0x02DC
+#define		ZD_CR184		0x02E0
+#define		ZD_CR185		0x02E4
+#define		ZD_CR186		0x02E8
+#define		ZD_CR187		0x02EC
+#define		ZD_CR188		0x02F0
+#define		ZD_CR189		0x02F4
+#define		ZD_CR190		0x02F8
+#define		ZD_CR191		0x02FC
+#define		ZD_CR192		0x0300
+#define		ZD_CR193		0x0304
+#define		ZD_CR194		0x0308
+#define		ZD_CR195		0x030C
+#define		ZD_CR196		0x0310
+#define		ZD_CR197		0x0314
+#define		ZD_CR198		0x0318
+#define		ZD_CR199		0x031C
+#define		ZD_CR200		0x0320
+#define		ZD_CR201		0x0324
+#define		ZD_CR202		0x0328
+#define		ZD_CR203		0x032C
+#define		ZD_CR204		0x0330
+#define		ZD_CR205		0x0334
+#define		ZD_CR206		0x0338
+#define		ZD_CR207		0x033C
+#define		ZD_CR208		0x0340
+#define		ZD_CR209		0x0344
+#define		ZD_CR210		0x0348
+#define		ZD_CR211		0x034C
+#define		ZD_CR212		0x0350
+#define		ZD_CR213		0x0354
+#define		ZD_CR214		0x0358
+#define		ZD_CR215		0x035C
+#define		ZD_CR216		0x0360
+#define		ZD_CR217		0x0364
+#define		ZD_CR218		0x0368
+#define		ZD_CR219		0x036C
+#define		ZD_CR220		0x0370
+#define		ZD_CR221		0x0374
+#define		ZD_CR222		0x0378
+#define		ZD_CR223		0x037C
+#define		ZD_CR224		0x0380
+#define		ZD_CR225		0x0384
+#define		ZD_CR226		0x0388
+#define		ZD_CR227		0x038C
+#define		ZD_CR228		0x0390
+#define		ZD_CR229		0x0394
+#define		ZD_CR230		0x0398
+#define		ZD_CR231		0x039C
+#define		ZD_CR232		0x03A0
+#define		ZD_CR233		0x03A4
+#define		ZD_CR234		0x03A8
+#define		ZD_CR235		0x03AC
+#define		ZD_CR236		0x03B0
+
+#define		ZD_CR240		0x03C0
+#define		ZD_CR241		0x03C4
+#define		ZD_CR242		0x03C8
+#define		ZD_CR243		0x03CC
+#define		ZD_CR244		0x03D0
+#define		ZD_CR245		0x03D4
+
+#define		ZD_CR251		0x03EC
+#define		ZD_CR252		0x03F0
+#define		ZD_CR253		0x03F4
+#define		ZD_CR254		0x03F8
+#define		ZD_CR255		0x03FC
+
+#define		ZD_RF_IF_CLK			0x0400
+#define		ZD_RF_IF_DATA			0x0404
+#define		ZD_PE1_PE2				0x0408
+#define		ZD_PE2_DLY				0x040C
+#define		ZD_LE1					0x0410
+#define		ZD_LE2					0x0414
+#define		ZD_GPI_EN				0x0418
+#define		ZD_RADIO_PD				0x042C
+#define		ZD_RF2948_PD			0x042C
+
+#ifndef HOST_IF_USB
+	#define		ZD_LED1				0x0430
+	#define		ZD_LED2				0x0434
+#endif
+
+
+#define		ZD_EnablePSManualAGC	0x043C	// 1: enable
+#define		ZD_CONFIGPhilips		0x0440
+#define		ZD_SA2400_SER_AP		0x0444
+#define		ZD_I2C_WRITE			0x0444	// Same as SA2400_SER_AP (for compatible with ZD1201)
+#define		ZD_SA2400_SER_RP		0x0448
+
+
+#define		ZD_RADIO_PE				0x0458
+#define		ZD_RstBusMaster			0x045C
+
+#define		ZD_RFCFG				0x0464
+
+#define		ZD_HSTSCHG				0x046C
+
+#define		ZD_PHY_ON				0x0474
+#define		ZD_RX_DELAY				0x0478
+#define		ZD_RX_PE_DELAY			0x047C
+
+
+#define		ZD_GPIO_1				0x0490
+#define		ZD_GPIO_2				0x0494
+
+
+#define		ZD_EncryBufMux			0x04A8
+
+
+#define		ZD_PS_Ctrl				0x0500
+#define		ZD_ADDA_PwrDwn_Ctrl		0x0504
+#define		ZD_ADDA_MBIAS_WarmTime	0x0508
+#define		ZD_MAC_PS_STATE			0x050C
+#define		ZD_InterruptCtrl		0x0510
+#define		ZD_TSF_LowPart			0x0514
+#define		ZD_TSF_HighPart			0x0518
+#define		ZD_ATIMWndPeriod		0x051C
+#define		ZD_BCNInterval			0x0520
+#define		ZD_Pre_TBTT				0x0524	//In unit of TU(1024us)
+
+//for UART support
+#define		ZD_UART_RBR_THR_DLL		0x0540
+#define		ZD_UART_DLM_IER			0x0544
+#define		ZD_UART_IIR_FCR			0x0548
+#define		ZD_UART_LCR				0x054c
+#define		ZD_UART_MCR				0x0550
+#define		ZD_UART_LSR				0x0554
+#define		ZD_UART_MSR				0x0558
+#define		ZD_UART_ECR				0x055c
+#define		ZD_UART_STATUS			0x0560
+
+#define		ZD_PCI_TxAddr_p1		0x0600
+#define		ZD_PCI_TxAddr_p2		0x0604
+#define		ZD_PCI_RxAddr_p1		0x0608
+#define		ZD_PCI_RxAddr_p2		0x060C
+#define		ZD_MACAddr_P1			0x0610
+#define		ZD_MACAddr_P2			0x0614
+#define		ZD_BSSID_P1				0x0618
+#define		ZD_BSSID_P2				0x061C
+#define		ZD_BCNPLCPCfg			0x0620
+#define		ZD_GroupHash_P1			0x0624
+#define		ZD_GroupHash_P2			0x0628
+#define		ZD_RX_TIMEOUT			0x062C
+
+#define		ZD_BasicRateTbl			0x0630
+#define		ZD_MandatoryRateTbl		0x0634
+#define		ZD_RTS_CTS_Rate			0x0638
+
+//				Wep protect
+//				_
+//	if set to 0x114
+//				 __
+//				0x14 * slot time(if is 2us) = 40us = wep init time.
+//
+// So if we change slot time, change 0x14 to let wep init time close to 40us.
+#define		ZD_Wep_Protect			0x063C
+#define		ZD_RX_THRESHOLD			0x0640
+
+#ifdef HOST_IF_USB
+	#define		RFCFG1					0x0644
+#else
+	#define		ZD_TX_PE_CTRL			0x0644
+#endif
+
+#if defined(AMAC)
+	#define		ZD_AfterPNP			0x0648
+#endif
+
+#if defined(OFDM)
+	#define		ZD_AckTime80211		0x0658
+#endif
+
+#define		ZD_Rx_OFFSET			0x065c
+
+#ifdef ZD1211B
+	#define		ZD_BCNLENGTH			0x0664
+#endif
+#define		ZD_PHYDelay				0x066C
+#define		ZD_BCNFIFO				0x0670
+#define		ZD_SnifferOn			0x0674
+#define		ZD_EncryType			0x0678
+#ifdef ZD1211
+	#define		ZD_RetryMAX				0x067C
+#endif
+#define		ZD_CtlReg1				0x0680	//Bit0:		IBSS mode
+//Bit1:		PwrMgt mode
+//Bit2-4 :	Highest basic rate
+//Bit5:		Lock bit
+//Bit6:		PLCP weight select
+//Bit7:		PLCP switch
+#define		ZD_DeviceState			0x0684
+#define		ZD_UnderrunCnt			0x0688
+#define		ZD_Rx_Filter			0x068c
+#define		ZD_Ack_Timeout_Ext		0x0690
+#define		ZD_BCN_FIFO_Semaphore	0x0694
+#define		ZD_IFS_Value			0x0698
+#define		ZD_RX_TIME_OUT			0x069C
+#define		ZD_TotalRxFrm			0x06A0
+#define		ZD_CRC32Cnt				0x06A4
+#define		ZD_CRC16Cnt				0x06A8
+#define		ZD_DecrypErr_UNI		0x06AC
+#define		ZD_RxFIFOOverrun		0x06B0
+
+#define		ZD_DecrypErr_Mul		0x06BC
+
+#define		ZD_NAV_CNT				0x06C4
+#define		ZD_NAV_CCA				0x06C8
+#define		ZD_RetryCnt				0x06CC
+
+#define		ZD_ReadTcbAddress		0x06E8
+#define		ZD_ReadRfdAddress		0x06EC
+#define		ZD_CWmin_CWmax			0x06F0
+#define		ZD_TotalTxFrm			0x06F4
+
+#define		ZD_CAM_MODE				0x0700
+#define		ZD_CAM_ROLL_TB_LOW		0x0704
+#define		ZD_CAM_ROLL_TB_HIGH		0x0708
+#define		ZD_CAM_ADDRESS			0x070C
+#define		ZD_CAM_DATA				0x0710
+
+#define		ZD_ROMDIR				0x0714
+
+#define		ZD_DECRY_ERR_FLG_LOW	0x0714
+#define		ZD_DECRY_ERR_FLG_HIGH	0x0718
+
+#define		ZD_WEPKey0				0x0720
+#define		ZD_WEPKey1				0x0724
+#define		ZD_WEPKey2				0x0728
+#define		ZD_WEPKey3				0x072C
+#define		ZD_WEPKey4				0x0730
+#define		ZD_WEPKey5				0x0734
+#define		ZD_WEPKey6				0x0738
+#define		ZD_WEPKey7				0x073C
+#define		ZD_WEPKey8				0x0740
+#define		ZD_WEPKey9				0x0744
+#define		ZD_WEPKey10				0x0748
+#define		ZD_WEPKey11				0x074C
+#define		ZD_WEPKey12				0x0750
+#define		ZD_WEPKey13				0x0754
+#define		ZD_WEPKey14				0x0758
+#define		ZD_WEPKey15				0x075c
+#define		ZD_TKIP_MODE			0x0760
+
+#define		ZD_TX_CCM_MODE			0x0B80
+#define		ZD_TX_CCM_MASK			0x0B84
+#define		ZD_RX_CCM_MODE			0x0C88
+#define		ZD_RX_CCM_MASK			0x0C8C
+
+
+#define		ZD_EEPROM_PROTECT0		0x0758
+#define		ZD_EEPROM_PROTECT1		0x075C
+
+#define		ZD_Dbg_FIFO_Rd			0x0800
+#define		ZD_Dbg_Select			0x0804
+#define		ZD_FIFO_Length			0x0808
+
+
+//#define		RF_Mode					0x080C
+#define		ZD_RSSI_MGC				0x0810
+
+#define		ZD_PON					0x0818
+#define		ZD_Rx_ON				0x081C
+#define		ZD_Tx_ON				0x0820
+#define		ZD_CHIP_EN				0x0824
+#define		ZD_LO_SW				0x0828
+#define		ZD_TxRx_SW				0x082C
+#define		ZD_S_MD					0x0830
+
+#define		ZD_USB_DEBUG_PORT		0x0888
+
+// EEPROM Memmory Map Region
+#define		ZD_EEPROM_START_ADDRESS	0x0900
+#define		ZD_E2P_SUBID			0x0900
+#define		ZD_E2P_POD				0x0904
+#define		ZD_E2P_MACADDR_P1		0x0908
+#define		ZD_E2P_MACADDR_P2		0x090C
+#define     ZD_E2P_PWR_CAL_VALUE1   0x0910
+#define     ZD_E2P_PWR_CAL_VALUE2   0x0914
+#define     ZD_E2P_PWR_CAL_VALUE3   0x0918
+#define     ZD_E2P_PWR_CAL_VALUE4   0x091c
+#define		ZD_E2P_PWR_INT_VALUE1	0x0920
+#define		ZD_E2P_PWR_INT_VALUE2	0x0924
+#define		ZD_E2P_PWR_INT_VALUE3	0x0928
+#define		ZD_E2P_PWR_INT_VALUE4	0x092c
+#define		ZD_E2P_ALLOWED_CHANNEL	0x0930
+
+
+#ifdef HOST_IF_USB
+	#define     E2P_DEVICE_VER          0x0940
+	#define     E2P_PHY_REG             0x094A
+	#define     E2P_36M_CAL_VALUE       0x0950
+#define		ZD_E2P_36M_CAL_VALUE2			0x0954
+#define         ZD_E2P_36M_CAL_VALUE3                   0x0958
+#define         ZD_E2P_36M_CAL_VALUE4                   0x095C
+
+#define		ZD_E2P_11A_INT_VALUE1			0x0960 //802.11a IntValue1 for All Rate
+#define         ZD_E2P_11A_INT_VALUE2                   0x0964 //802.11a IntValue2 for All Rate
+#define         ZD_E2P_11A_INT_VALUE3                   0x0968 //802.11a IntValue3 for All Rate
+#define         ZD_E2P_48M_CAL_VALUE2                   0x0974
+#define         ZD_E2P_48M_CAL_VALUE3                   0x0978
+#define         ZD_E2P_48M_CAL_VALUE4                   0x097C
+
+#define		ZD_E2P_A36M_CAL_VALUE			0x0980 //802.11a SetPoint for 36~6M
+#define         ZD_E2P_A36M_CAL_VALUE2                  0x0984
+#define         ZD_E2P_A36M_CAL_VALUE3                  0x0988
+#define         ZD_E2P_A36M_CAL_VALUE4                  0x098C
+#define         ZD_E2P_54M_CAL_VALUE2                   0x0994
+#define         ZD_E2P_54M_CAL_VALUE3                   0x0998
+#define         ZD_E2P_54M_CAL_VALUE4                   0x099C
+
+
+#define		ZD_E2P_A54M_CAL_VALUE			0x09A0 //802.11a SetPoint for 54/48M
+#define         ZD_E2P_A54M_CAL_VALUE2                  0x09A4
+#define         ZD_E2P_A54M_CAL_VALUE3                  0x09A8
+#define         ZD_E2P_A54M_CAL_VALUE4                  0x09AC
+#define         ZD_E2P_11A_INT_VALUE4                   0x096C //802.11a IntValue4 for All Rate
+
+
+#define     E2P_36M_INT_VALUE       0x0960
+	#define     E2P_48M_CAL_VALUE       0x0970
+	#define     E2P_48M_INT_VALUE       0x0980
+	#define     E2P_54M_CAL_VALUE       0x0990
+	#define     E2P_54M_INT_VALUE       0x09A0
+
+
+#ifndef fNEW_CODE_MAP
+		#define     E2P_END             0x09F0
+    #else
+		#define     E2P_END             0x09FC
+    #endif
+#else
+	#define		ZD_E2P_PHY_REG			0x0934
+	#define		ZD_E2P_REGION_CODE		0x0960
+	#define		ZD_E2P_FEATURE_BITMAP	0x0964
+	#define     ZD_E2P_END              0x0968
+#endif
+
+#ifdef ZD1211B
+	#define 	ZD_RetryMAX				0x0B28
+#endif
+
+#ifdef HOST_IF_USB
+	#ifdef ZD1211
+		#define     FW_FIRMWARE_VER         0x0B00
+		#define     FW_USB_SPEED            0x0B01
+		#define     FW_FIX_TX_RATE          0x0B02
+		#define     FW_LINK_STATUS          0x0B03
+		#define     FW_SOFT_RESET           0x0B04
+		#define     FW_FLASH_CHK            0x0B05
+	#elif defined(ZD1211B)
+        #define     FW_FIRMWARE_VER         0x0F00
+        #define     FW_USB_SPEED            0x0F01
+        #define     FW_FIX_TX_RATE          0x0F02
+        #define     FW_LINK_STATUS          0x0F03
+        #define     FW_SOFT_RESET           0x0F04
+        #define     FW_FLASH_CHK            0x0F05
+	#endif
+
+#define     ZD1211_CLOCK_CTRL       0x8540
+	#define     bZD1211_CLOCK_EEPROM    0
+	#define     bmZD1211_CLOCK_EEPROM   mBIT(bZD1211_CLOCK_EEPROM)
+	#define     UMAC_EPROM_ROM_ADDR     0x862A
+	#define     UMAC_EPROM_RAM_ADDR     0x862B
+	#define     UMAC_EPROM_DMA_LEN_DIR  0x862C
+	#define     bmEPROM_XFER_DIR        BIT_15
+	#define     UMAC_WAIT_STATE         0x8801
+#endif
+
+
+#define		ZD_TX_PWR_CTRL_1		0x0B00
+#define		ZD_TX_PWR_CTRL_2		0x0B04
+#define		ZD_TX_PWR_CTRL_3		0x0B08
+#define		ZD_TX_PWR_CTRL_4		0x0B0C
+
+#define		ZD_EPP_ROM_ADDRESS		0x0A04
+#define		ZD_EPP_SRAM_ADDRESS		0x0A08
+#define		ZD_EPP_LENG_DIR			0x0A0C
+#define		ZD_EPP_CLOCK_DIV		0x0A10
+#define		ZD_EPP_KEY_PROT			0x0A14
+
+//HW MIC Engine
+#define		ZD_MIC_START_ADDR0		0x0D00
+
+
+#define		ZD_MIC_BLOCK0_LEN		0x0D04
+#define		ZD_MIC_START_ADDR1		0x0D08
+#define		ZD_MIC_BLOCK1_LEN		0x0D0C
+#define		ZD_MIC_START_ADDR2		0x0D10
+#define		ZD_MIC_BLOCK2_LEN		0x0D14
+#define		ZD_MIC_START_ADDR3		0x0D18
+#define		ZD_MIC_BLOCK3_LEN		0x0D1C
+#define		ZD_MIC_START_ADDR4		0x0D20
+#define		ZD_MIC_BLOCK4_LEN		0x0D24
+#define		ZD_MIC_START_ADDR5		0x0D28
+#define		ZD_MIC_BLOCK5_LEN		0x0D2C
+#define		ZD_MIC_KEY_LOW			0x0D30
+#define		ZD_MIC_KEY_HIGH			0x0D34
+#define		ZD_MIC_VALUE_LOW		0x0D38
+#define		ZD_MIC_VALUE_HIGH		0x0D3C
+#define		ZD_MIC_STATUS			0x0D40
+#define		ZD_MIC_TOTAL_BLOCK_NUM	0x0D44
+#define		ZD_MIC_WRITE_BACK_ADDRS	0x0D48
+#define		ZD_HOST_ENDIAN			0x0D4C
+
+
+#define	SR_1M		0x02
+#define	SR_2M		0x04
+#define	SR_5_5M		0x0b
+#define	SR_11M		0x16
+#define	SR_16_5M	0x21
+#define	SR_27_5M	0x37
+#define	SR_6M		0x0c
+#define	SR_9M		0x12
+#define	SR_12M		0x18
+#define	SR_18M		0x24
+#define	SR_24M		0x30
+#define	SR_36M		0x48
+#define	SR_48M		0x60
+#define	SR_54M		0x6c
+
+void HW_Set_Intersil_Chips(zd_80211Obj_t *pObj, U32 ChannelNo, U8 InitChOnly);
+void HW_Set_GCT_Chips(zd_80211Obj_t *pObj, U32 ChannelNo, U8 InitChOnly);
+void HW_Set_AL7230B_RF_Chips(zd_80211Obj_t *pObj, U32 ChannelNo, U8 InitChOnly,U8 MAC_Mode);
+
+void LockPhyReg(zd_80211Obj_t *pObj);
+void UnLockPhyReg(zd_80211Obj_t *pObj);
+void HW_SetSupportedRate(zd_80211Obj_t *pObj, U8 *prates);
+void HW_EnableBeacon(zd_80211Obj_t *pObj, U16 BecaonInterval, U16 DtimPeriod, U8 BssType);
+U32 HW_GetNow(zd_80211Obj_t *pObj);
+void HW_GetTsf(zd_80211Obj_t *pObj, U32 *loTsf, U32 *hiTsf);
+void HW_SetBeaconFIFO(zd_80211Obj_t *pObj, U8 *pBeacon, U16 index);
+void HW_SwitchChannel(zd_80211Obj_t *pObj, U16 channel, U8 InitChOnly, const U8 MAC_Mode);
+void HW_SetRfChannel(zd_80211Obj_t *pObj, U16 channel, U8 InitChOnly, const U8 MAC_Mode);
+
+int HW_HTP(zd_80211Obj_t *pObj);
+void HW_RadioOnOff(zd_80211Obj_t *pObj, U8 on);
+void HW_Set_IF_Synthesizer(zd_80211Obj_t *pObj, U32 InputValue);
+void HW_ResetPhy(zd_80211Obj_t *pObj);
+void HW_InitHMAC(zd_80211Obj_t *pObj);
+void HW_UpdateIntegrationValue(zd_80211Obj_t *pObj, U32 ChannelNo,const U8 MAC_Mode);
+
+void HW_WritePhyReg(zd_80211Obj_t *pObj, U8 PhyIdx, U8 PhyValue);
+void HW_OverWritePhyRegFromE2P(zd_80211Obj_t *pObj);
+void HW_E2P_AutoPatch(zd_80211Obj_t *pObj);
+void HW_SetSTA_PS(zd_80211Obj_t *pObj, U8 op);
+void HW_Write_TxGain(zd_80211Obj_t *pObj, U32 txgain);
+void HW_Set_FilterBand(zd_80211Obj_t *pObj, U32	region_code);
+void HW_UpdateBcnInterval(zd_80211Obj_t *pObj, U16 BcnInterval);
+void HW_UpdateATIMWindow(zd_80211Obj_t *pObj, U16 AtimWnd);
+void HW_UpdatePreTBTT(zd_80211Obj_t *pObj, U32 pretbtt);
+
+
+// for AMAC CAM operation
+void HW_CAM_Avail(zd_80211Obj_t *pObj);
+void HW_CAM_Write(zd_80211Obj_t *pObj, U32 address, U32 data);
+U32 HW_CAM_Read(zd_80211Obj_t *pObj, U32 address);
+void HW_CAM_SetMAC(zd_80211Obj_t *pObj, U16 aid, U8 *pMAC);
+void HW_CAM_GetMAC(zd_80211Obj_t *pObj, U16 aid, U8 *pMac);
+void HW_CAM_SetEncryType(zd_80211Obj_t *pObj, U16 aid, U8 encryType);
+U8 HW_CAM_GetEncryType(zd_80211Obj_t *pObj, U16 aid);
+void HW_CAM_SetKey(zd_80211Obj_t *pObj, U16 aid, U8 keyLength, U8 *pKey);
+void HW_CAM_GetKey(zd_80211Obj_t *pObj, U16 aid, U8 keyLength, U8 *pKey);
+void HW_CAM_UpdateRollTbl(zd_80211Obj_t *pObj, U16 aid);
+void HW_CAM_ResetRollTbl(zd_80211Obj_t *pObj);
+void HW_CAM_ClearRollTbl(zd_80211Obj_t *pObj, U16 aid);
+//void HW_ConfigDynaKey(zd_80211Obj_t *pObj, U16 aid, U8 *pMac, U8 *pKey, U8 KeyLength, U8 encryType);
+void HW_ConfigDynaKey(zd_80211Obj_t *pObj, U16 aid, U8 *pMac, U8 *pKey, U8 KeyLength, U8 encryType, U8 change_enc);
+void HW_ConfigStatKey(zd_80211Obj_t *pObj, U8 *pKey, U8 keyLen, U32 startAddr);
+void HW_GetStatKey(zd_80211Obj_t *pObj);
+void HW_EEPROM_ACCESS(zd_80211Obj_t *pObj, U8 RamAddr, U32 RomAddr, U32 length, U8 bWrite);
+
+
+//
+void HW_Write_TxGain0(zd_80211Obj_t *pObj, U8 *pTxGain, U8 TxPwrType);
+void HW_Write_TxGain1(zd_80211Obj_t *pObj, U8 txgain, U8 TxPwrType);
+void HW_Write_TxGain2(zd_80211Obj_t *pObj, U8 TxPwrType);
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdinlinef.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdinlinef.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdinlinef.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdinlinef.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,756 @@
+#ifndef _ZD_INLINEF_H
+#define _ZD_INLINEF_H
+#include "zd1205.h"
+#include "zdglobal.h"
+#include "zddebug.h"
+
+#define write_str(a,b)
+extern zd_80211Obj_t dot11Obj;
+
+#if defined(OFDM)
+
+extern u8 OfdmRateTbl_11A[12];
+
+extern u8 OfdmRateTbl[12];
+#endif
+
+
+__inline void
+Cal_Us_Service(
+        u8 TxRate,
+        u16 Len,
+        u16	*pLenInUs,
+        u8 *pService
+)
+{
+        u32		Remainder;
+        u32		Delta;
+
+#if defined(OFDM)
+
+        *(pService) = 0x00;
+#endif
+
+        switch(TxRate) {
+        case RATE_1M:		/* 1M bps */
+                *(pLenInUs) = Len << 3;
+                break;
+
+        case RATE_2M:		/* 2M bps */
+                *(pLenInUs) = Len << 2;
+                break;
+
+        case RATE_5M:		/* 5.5M bps */
+                *(pLenInUs) = (u16)(((u32)Len << 4)/11);
+                Remainder = (((u32)Len << 4) % 11);
+                if ( Remainder ) {
+                        *(pLenInUs) += 1;
+                }
+                break;
+
+        case RATE_11M:		/* 11M bps */
+                *(pLenInUs) = (u16)(((u32)Len << 3)/11);
+                Remainder = (((u32)Len << 3) % 11);
+                Delta = 11 - Remainder;
+                if ( Remainder ) {
+                        *(pLenInUs) += 1;
+                        if ( Delta >= 8 ) {
+                                *(pService) |= BIT_7;
+                        }
+                }
+                break;
+
+#if !(defined(GCCK) && defined(OFDM))
+
+        case RATE_16M:		// 16.5M bps
+                *(pLenInUs) = (u16)(((u32)Len << 4)/33);
+                Remainder = (((u32)Len << 4) % 33);
+                Delta = 33 - Remainder;
+                if ( Remainder ) {
+                        *(pLenInUs) += 1;
+                        if ( Delta < 16 ) {}
+                        else if ( (Delta >= 16) && (Delta < 32) ) {
+                                *(pService) |= BIT_7;
+                        } else if ( Delta >= 32 ) {
+                                *(pService) |= BIT_6;
+                        }
+                }
+                break;
+
+        case RATE_22M:		// 22M bps
+                *(pLenInUs) = (u16)(((u32)Len << 2)/11);
+                Remainder = (((u32)Len << 2) % 11);
+                Delta = 11 - Remainder;
+                if ( Remainder ) {
+                        *(pLenInUs) += 1;
+                        if ( Delta < 4 ) {}
+                        else if ( (Delta >= 4) && (Delta < 8) ) {
+                                *(pService) |= BIT_7;
+                        } else if ( Delta >= 8 ) {
+                                *(pService) |= BIT_6;
+                        }
+                }
+                break;
+
+
+
+        case RATE_27M:		// 27.5 bps
+                *(pLenInUs) = (u16)(((u32)Len << 4)/55);
+                Remainder = (((u32)Len << 4) % 55);
+                Delta = 55 - Remainder;
+                if ( Remainder ) {
+                        *(pLenInUs) += 1;
+                        if ( Delta < 16 ) {}
+                        else if ( (Delta >= 16) && (Delta < 32) ) {
+                                *(pService) |= BIT_7;
+
+                        }
+                        else if ( (Delta >= 32) && (Delta < 48) ) {
+                                *(pService) |= BIT_6;
+                        } else if ( Delta >= 48 ) {
+                                *(pService) |= (BIT_6 | BIT_7);
+                        }
+                }
+                break;
+
+        case RATE_33M:		// 33M bps
+                *(pLenInUs) = (u16)(((u32)Len << 3)/33);
+                Remainder = (((u32)Len << 3) % 33);
+                Delta = 33 - Remainder;
+                if ( Remainder ) {
+                        *(pLenInUs) += 1;
+                        if ( Delta < 8 ) {}
+                        else if ( (Delta >= 8) && (Delta < 16) ) {
+                                *(pService) |= BIT_7;
+                        } else if ( (Delta >= 16) && (Delta < 24) ) {
+                                *(pService) |= BIT_6;
+                        } else if ( (Delta >= 24) && (Delta < 32) ) {
+                                *(pService) |= (BIT_6 | BIT_7);
+                        } else if ( Delta >= 32 ) {
+                                *(pService) |= BIT_5;
+                        }
+                }
+                break;
+
+        case RATE_38M:		// 38.5M bps
+                *(pLenInUs) = (u16)(((u32)Len << 4)/77);
+                Remainder = (((u32)Len << 4) % 77);
+                Delta = 77 - Remainder;
+                if ( Remainder ) {
+                        *(pLenInUs) += 1;
+                        if ( Delta < 16 ) {}
+                        else if ( (Delta >= 16) && (Delta < 32) ) {
+                                *(pService) |= BIT_7;
+
+
+                        } else if ( (Delta >= 32) && (Delta < 48) ) {
+                                *(pService) |= BIT_6;
+                        } else if ( (Delta >= 48) && (Delta < 64) ) {
+                                *(pService) |= (BIT_6 | BIT_7);
+                        } else if ( Delta >= 64) {
+                                *(pService) |= BIT_5;
+                        }
+                }
+                break;
+
+        case RATE_44M:		// 44M bps
+                *(pLenInUs) = (u16)(((u32)Len << 1)/11);
+                Remainder = (((u32)Len << 1) % 11);
+                Delta = 11 - Remainder;
+                if ( Remainder ) {
+                        *(pLenInUs) += 1;
+                        if ( Delta < 2 ) {}
+                        else if ( (Delta >= 2) && (Delta < 4) ) {
+                                *(pService) |= BIT_7;
+                        } else if ( (Delta >= 4) && (Delta < 6) ) {
+                                *(pService) |= BIT_6;
+                        } else if ( (Delta >= 6) && (Delta < 8) ) {
+                                *(pService) |= (BIT_6 | BIT_7);
+                        } else if ( (Delta >= 8) && (Delta < 10) ) {
+                                *(pService) |= BIT_5;
+                        } else if ( Delta >= 10 ) {
+                                *(pService) |= (BIT_5 | BIT_7);
+                        }
+                }
+                break;
+
+        case RATE_49M:		// 49.5M bps
+                *(pLenInUs) = (u16)(((u32)Len << 4)/99);
+                Remainder = (((u32)Len << 4) % 99);
+                Delta = 99 - Remainder;
+                if ( Remainder ) {
+                        *(pLenInUs) += 1;
+                        if ( Delta < 16 ) {}
+                        else if ( (Delta >= 16) && (Delta < 32) ) {
+                                *(pService) |= BIT_7;
+                        } else if ( (Delta >= 32) && (Delta < 48) ) {
+                                *(pService) |= BIT_6;
+                        } else if ( (Delta >= 48) && (Delta < 64) ) {
+                                *(pService) |= (BIT_6 | BIT_7);
+                        }
+
+                        else if ( (Delta >= 64) && (Delta < 80) ) {
+                                *(pService) |= BIT_5;
+                        } else if ( (Delta >= 80) && (Delta < 96) ) {
+                                *(pService) |= (BIT_5 | BIT_7);
+                        } else if ( Delta >= 96 ) {
+                                *(pService) |= (BIT_5 | BIT_6);
+                        }
+                }
+                break;
+
+        case RATE_55M:		// 55M bps
+                *(pLenInUs) = (u16)(((u32)Len << 3)/55);
+                Remainder = (((u32)Len << 3) % 55);
+                Delta = 55 - Remainder;
+                if ( Remainder ) {
+                        *(pLenInUs) += 1;
+                        if ( Delta < 8 ) {}
+                        else if ( (Delta >= 8) && (Delta < 16) ) {
+                                *(pService) |= BIT_7;
+                        } else if ( (Delta >= 16) && (Delta < 24) ) {
+                                *(pService) |= BIT_6;
+                        } else if ( (Delta >= 24) && (Delta < 32) ) {
+                                *(pService) |= (BIT_6 | BIT_7);
+                        } else if ( (Delta >= 32) && (Delta < 40) ) {
+                                *(pService) |= BIT_5;
+                        } else if ( (Delta >= 40) && (Delta < 48) ) {
+                                *(pService) |= (BIT_5 | BIT_7);
+                        } else if ( Delta >= 48 ) {
+                                *(pService) |= (BIT_5 | BIT_6);
+                        }
+                }
+                break;
+
+        case RATE_60M:		// 60.5M bps
+                *(pLenInUs) = (u16)(((u32)Len << 4)/121);
+                Remainder = (((u32)Len << 4) % 121);
+                Delta = 121 - Remainder;
+                if ( Remainder ) {
+                        *(pLenInUs) += 1;
+                        if ( Delta < 16 ) {}
+                        else if ( (Delta >= 16) && (Delta < 32) ) {
+                                *(pService) |= BIT_7;
+                        } else if ( (Delta >= 32) && (Delta < 48) ) {
+                                *(pService) |= BIT_6;
+                        } else if ( (Delta >= 48) && (Delta < 64) ) {
+                                *(pService) |= (BIT_6 | BIT_7);
+                        } else if ( (Delta >= 64) && (Delta < 80) ) {
+                                *(pService) |= BIT_5;
+                        } else if ( (Delta >= 80) && (Delta < 96) ) {
+                                *(pService) |= (BIT_5 | BIT_7);
+                        } else if ( (Delta >= 96) && (Delta < 112) ) {
+                                *(pService) |= (BIT_5 | BIT_6);
+                        } else if ( Delta >= 112 ) {
+                                *(pService) |= (BIT_5 | BIT_6 | BIT_7);
+                        }
+                }
+                break;
+
+        case 13:		// 8.25M bps
+                *(pLenInUs) = (u16)(((u32)Len * 32)/33);
+                Remainder = (((u32)Len * 32) % 33);
+                Delta = 33 - Remainder;
+                if ( Remainder ) {
+                        *(pLenInUs) += 1;
+                        if (Delta < 32) {}
+                        else {
+                                *(pService) |= BIT_7;
+                        }
+                }
+
+                break;
+#else
+
+        case RATE_6M:	// 6M
+                *(pLenInUs) = (u16)(((u32)Len << 3)/6);
+                break;
+
+        case RATE_9M:	// 9M
+                *(pLenInUs) = (u16)(((u32)Len << 3)/9);
+                break;
+
+        case RATE_12M:	// 12M
+                *(pLenInUs) = (u16)(((u32)Len << 3)/12);
+                break;
+
+        case RATE_18M:	// 18M
+                *(pLenInUs) = (u16)(((u32)Len << 3)/18);
+                break;
+
+        case RATE_24M:	// 24M
+                *(pLenInUs) = (u16)(((u32)Len << 3)/24);
+                break;
+
+        case RATE_36M:	// 36M
+                *(pLenInUs) = (u16)(((u32)Len << 3)/36);
+
+                break;
+
+        case RATE_48M:	// 48M
+                *(pLenInUs) = (u16)(((u32)Len << 3)/48);
+                break;
+
+        case RATE_54M:	// 54M
+                *(pLenInUs) = (u16)(((u32)Len << 3)/54);
+                break;
+#endif
+
+        default:
+                printk(KERN_ERR "zd1205: Invalid RF module parameter\n");
+
+        }
+}
+
+char DbgStr100[]="TKIP:";
+char DbgStr101[]="CtrlSetting";
+char DbgStr102[]="EncryType";
+#define CTRL_SIZE	25
+__inline unsigned long
+Cfg_CtrlSetting(
+        struct zd1205_private *macp,
+        zd1205_SwTcb_t		*pSwTcb,
+        wla_Header_t	*pWlaHdr,
+        ctrl_Set_parm_t *pSetParms
+)
+{
+        zd1205_Ctrl_Set_t	*pCtrlSet = pSwTcb->pHwCtrlPtr;
+        u8			tmp;
+        u16			Len = 0;
+        u16			NextLen = 0;
+        u16			LenInUs = 0;
+        u16			NextLenInUs = 0;
+        u8			Service;
+        u8			TxRate;
+        u8			Rate = pSetParms->Rate;
+        u8			Preamble = pSetParms->Preamble;
+        u32			CurrFragLen = pSetParms->CurrFragLen;
+        u32			NextFragLen = pSetParms->NextFragLen;
+        u8			encryType = pSetParms->encryType;
+        //u8			vapId = pSetParms->vapId;
+        u8			bMgtFrame = 0;
+        u8			bGroupAddr = 0;
+        u8			EnCipher = ((pWlaHdr->FrameCtrl[1] & ENCRY_BIT) ? 1 : 0);
+        u16			FragNum = (pWlaHdr->SeqCtrl[0] & 0x0F);
+        card_Setting_t		*pCardSettting = &macp->cardSetting;
+        u16			FrameType = pWlaHdr->FrameCtrl[0];
+        u8			bBusrt = 0;
+#ifdef ZD1211B
+
+        u8			LengthDiff=0;
+#endif
+
+        memset(pCtrlSet,0,sizeof(zd1205_Ctrl_Set_t));
+
+        if (Rate > macp->AdapterMaxRate)
+                Rate = macp->AdapterMaxRate;
+
+        if ((FrameType & 0x0c) == MANAGEMENT)
+        {
+                bMgtFrame = 1;
+                Rate = dot11Obj.BasicRate;
+        }
+        if ((FrameType & 0x0c) == DATA)
+        {
+                write_str(DbgStr101, EnCipher);
+        }
+        if (bMgtFrame)
+        {
+                if ((FrameType == PROBE_RSP) || (FrameType == PROBE_REQ)) {
+                        // Ensure Site-Survey smooth
+                        if(PURE_A_MODE != pCardSettting->MacMode) {
+                                Rate = RATE_1M;
+                                Preamble = 0;
+                        } else if(PURE_A_MODE == pCardSettting->MacMode) {
+                                Rate = RATE_6M;
+                                Preamble =1;
+                        }
+
+                }
+        }
+
+        if (FrameType == PS_POLL)
+        {
+                // For compatibility with D-Link AP
+                if(PURE_A_MODE != pCardSettting->MacMode) {
+                        Rate = RATE_1M;
+                        Preamble = 0;
+                } else if(PURE_A_MODE == pCardSettting->MacMode) {
+                        Rate = RATE_6M;
+                        Preamble = 1;
+                }
+
+        }
+
+        if ((Rate == RATE_1M) && (Preamble == 1))
+        { //1M && short preamble
+                Rate = RATE_2M;
+        }
+
+        if (macp->bFixedRate)
+        {
+                if (!bMgtFrame)
+                        Rate = pCardSettting->FixedRate;
+        }
+
+        pSwTcb->Rate = Rate;
+        //FPRINT_V("zdinline Rate", Rate);
+
+#if !defined(OFDM)
+
+        pCtrlSet->CtrlSetting[0] = (Rate | (Preamble << 5));
+#else
+
+        if (Rate < RATE_6M)
+        { //CCK frame
+                pCtrlSet->CtrlSetting[0] = (Rate | (Preamble << 5));
+                //``JWEI 2003/12/22
+#if fTX_PWR_CTRL
+
+                if ((macp->TxOFDMCnt > 0) && (macp->TxOFDMCnt < cTX_SENT_LEN))
+                        macp->TxOFDMCnt --;
+                macp->TxPwrCCK ++;
+#endif
+
+        } else
+        {
+#if fTX_PWR_CTRL
+                macp->TxPwrOFDM ++;
+                macp->TxOFDMCnt ++;
+                if (Rate == RATE_48M) {
+                        if (macp->TxOFDMType != cTX_48M)
+                                macp->TxOFDMCnt = 0;
+                        macp->TxOFDMType = cTX_48M;
+                } else if (Rate == RATE_54M) {
+                        if (macp->TxOFDMType != cTX_54M)
+                                macp->TxOFDMCnt = 0;
+                        macp->TxOFDMType = cTX_54M;
+                } else {
+                        if (macp->TxOFDMType != cTX_OFDM)
+                                macp->TxOFDMCnt = 0;
+                        macp->TxOFDMType = cTX_OFDM;
+                }
+#endif
+
+                if(PURE_A_MODE != pCardSettting->MacMode)
+                        pCtrlSet->CtrlSetting[0] = OfdmRateTbl[Rate];
+                else if(PURE_A_MODE == pCardSettting->MacMode) {
+                        pCtrlSet->CtrlSetting[0] = OfdmRateTbl_11A[Rate];
+                }
+
+        }
+#endif
+
+        TxRate = Rate;
+
+        //keep current Tx rate
+        pCardSettting->CurrTxRate = TxRate;
+
+        /* Length in byte */
+        if (EnCipher)
+        {
+                if (!pCardSettting->SwCipher) {
+                        write_str(DbgStr102, encryType);
+                        switch(encryType) {
+                        case WEP64:
+                        case WEP128:
+                        case WEP256:
+                                Len = CurrFragLen + 36; 	/* Header(24) + CRC32(4) + IV(4) + ICV(4) */
+                                NextLen = NextFragLen + 36;
+#ifdef ZD1211B
+
+                                LengthDiff=17;
+#endif
+
+                                break;
+
+                        case TKIP:
+                                write_str(DbgStr100, CurrFragLen);
+                                Len = CurrFragLen + 40; 	/* Header(24) + CRC32(4) + IV(4) + EIV(4) + ICV(4) */
+                                NextLen = NextFragLen + 40;
+#ifdef ZD1211B
+
+                                LengthDiff=17;
+#endif
+
+                                break;
+
+                        case AES:
+                                Len = CurrFragLen + 44; 	/* Header(24) + CRC32(4) + IV(4) +  ExtendedIV(4) + MIC(8) */
+                                NextLen = NextFragLen + 44;
+#ifdef ZD1211B
+
+                                LengthDiff=13;
+#endif
+                                //FPRINT_V("Len", Len);
+                                break;
+
+                        default:
+                                printk(KERN_DEBUG "error encryType = %x\n", encryType);
+                                break;
+                        }
+                } else { //use software encryption
+                        if (pCardSettting->DynKeyMode == DYN_KEY_TKIP) {
+                                if ((pWlaHdr->DA[0] & BIT_0) && (pCardSettting->WpaBcKeyLen != 32)) { //multicast
+                                        Len = CurrFragLen + 32; // Header(24) + CRC32(4) + IV(4), ICV was packed under payload
+
+                                        NextLen = NextFragLen + 32;
+                                } else {
+                                        Len = CurrFragLen + 36; // Header(24) + CRC32(4) + IV(4) + ExtendIV(4), ICV was packed under payload
+                                        NextLen = NextFragLen + 36;
+                                }
+                        } else {
+                                Len = CurrFragLen + 32; // Header(24) + CRC32(4) + IV(4), ICV was packed under payload
+                                NextLen = NextFragLen + 32;
+                        }
+                }
+        } else
+        { // no cipher
+                Len = CurrFragLen + 28; 	/* Header(24) + CRC32(4) */
+                NextLen = NextFragLen + 28;
+#ifdef ZD1211B
+
+                LengthDiff=21;
+#endif
+
+        }
+
+        /* Corret some exceptions */
+        if (FrameType == PS_POLL)
+        {
+                Len = CurrFragLen + 20; // Header(16) + CRC32(4)
+        }
+
+        /* Corret some exceptions */
+        if (NextFragLen == 0)
+                NextLen = 0;
+
+        pCtrlSet->CtrlSetting[1] = (u8)Len; 			/* low byte */
+        pCtrlSet->CtrlSetting[2] = (u8)(Len >> 8);   /* high byte */
+
+        /* TCB physical address */
+        pCtrlSet->CtrlSetting[3] = (u8)(pSwTcb->TcbPhys);
+        pCtrlSet->CtrlSetting[4] = (u8)(pSwTcb->TcbPhys >> 8);
+        pCtrlSet->CtrlSetting[5] = (u8)(pSwTcb->TcbPhys >> 16);
+        pCtrlSet->CtrlSetting[6] = (u8)(pSwTcb->TcbPhys >> 24);
+
+        pCtrlSet->CtrlSetting[7] = 0x00;
+        pCtrlSet->CtrlSetting[8] = 0x00;
+        pCtrlSet->CtrlSetting[9] = 0x00;
+        pCtrlSet->CtrlSetting[10] = 0x00;
+
+        /* Misc */
+        tmp = 0;
+        if (!FragNum)
+        {
+                tmp |= BIT_0;
+
+                if (macp->bTxBurstEnable) {
+                        if (macp->activeTxQ->count > 0) {
+                                // AT LEAST one packet in ActiveChainList
+                                macp->TxBurstCount++;
+                                if (macp->TxBurstCount == 3)	// only 3 packets
+                                        macp->TxBurstCount = 0;
+                        } else {
+                                // recount again, next packet will back off
+                                macp->TxBurstCount = 0;
+                        }
+
+                        // burst mode
+                        if (macp->TxBurstCount == 0) {
+                                tmp |= BIT_0;	//need back off
+                        } else {
+                                tmp &= ~BIT_0;	//burst, no need back off
+                                bBusrt = 1;
+
+                                pCtrlSet->CtrlSetting[0] |= BIT_7;
+                        }
+                }
+        }
+
+        if (pWlaHdr->DA[0] & BIT_0)
+        {		/* Multicast */
+                bGroupAddr = 1;
+                tmp |= BIT_1;
+        }
+
+        //if (bMgtFrame){
+        //	tmp |= BIT_3;
+        //}
+
+        if (FrameType == PS_POLL) //AP don't send PS_POLL
+                tmp |= BIT_2;
+
+
+#ifndef HOST_IF_USB
+
+        if ((pCardSettting->BssType == INDEPENDENT_BSS) && (!bMgtFrame))
+        {
+                if (zd1205_DestPowerSave(macp, &pWlaHdr->DA[0])) {
+                        tmp |= BIT_4;
+                }
+        }
+#endif
+
+        if (Len > pCardSettting->RTSThreshold)
+        {
+                if ((!bMgtFrame) && (!bGroupAddr)) {
+                        if(PURE_A_MODE != macp->cardSetting.MacMode)
+                                tmp |= BIT_5;
+                        else if(PURE_A_MODE == macp->cardSetting.MacMode)
+                                tmp |= BIT_7;
+                }
+        }
+
+#if (defined(GCCK) && defined(OFDM))
+
+        if (TxRate > RATE_11M && PURE_A_MODE != macp->cardSetting.MacMode)
+        {
+
+                if (tmp & BIT_5) {
+                        // need to send RTS or CTS, in OFDM only send CTS, in CCK send RTS
+                        tmp &= ~BIT_5;
+                        tmp |= BIT_7;
+                }
+                //else if ((dot11Obj.ConfigFlag & ENABLE_PROTECTION_SET) && dot11Obj.bDisProtection==0)
+                else if ((dot11Obj.ConfigFlag & ENABLE_PROTECTION_SET)) {
+                        // id SelfCTS on, force send CTS when OFDM
+                        tmp |= BIT_7;
+                }
+        }
+#endif
+
+        if ((EnCipher) && (!pCardSettting->SwCipher))
+        {
+                tmp |= BIT_6;
+        }
+
+
+        if ((macp->bTxBurstEnable))
+        {
+                if (!bBusrt)
+                        // bBusrt off, this is the first one, force send CTS
+                        tmp |= BIT_7;
+                else
+                        // bBusrt on, this is the burst one, no need CTS
+                        tmp &= ~BIT_7;
+        }
+
+        pCtrlSet->CtrlSetting[11] = tmp;
+
+        /* Address1 */
+        pCtrlSet->CtrlSetting[12] = pWlaHdr->DA[0];
+        pCtrlSet->CtrlSetting[13] = pWlaHdr->DA[1];
+        pCtrlSet->CtrlSetting[14] = pWlaHdr->DA[2];
+        pCtrlSet->CtrlSetting[15] = pWlaHdr->DA[3];
+        pCtrlSet->CtrlSetting[16] = pWlaHdr->DA[4];
+        pCtrlSet->CtrlSetting[17] = pWlaHdr->DA[5];
+
+        if (FrameType == DATA)
+        {
+                macp->TotalTxDataFrmBytes += Len;
+                if (pCtrlSet->CtrlSetting[12] & BIT_0) {
+                        macp->txMulticastFrm ++;
+                        macp->txMulticastOctets += CurrFragLen;
+                } else {
+                        macp->txUnicastFrm ++;
+                        macp->txUnicastOctets += CurrFragLen;
+                        macp->txDataPerSec += CurrFragLen;
+                }
+
+        }
+
+        /* NextLen */
+#ifdef ZD1211
+        if (NextLen)
+        {
+                pCtrlSet->CtrlSetting[18] = (u8)NextLen;
+                pCtrlSet->CtrlSetting[19] = (u8)(NextLen >> 8);
+        }
+#elif defined(ZD1211B)
+        pSwTcb->LengthDiff = LengthDiff;
+#endif
+
+        /* LenInUs */
+        Cal_Us_Service(TxRate, Len, &LenInUs, &Service);
+
+        if (macp->bTxBurstEnable)
+                if (!bBusrt)
+                        LenInUs = LenInUs * 4;
+
+        pCtrlSet->CtrlSetting[20] = (u8)LenInUs;
+        pCtrlSet->CtrlSetting[21] = (u8)(LenInUs >> 8);
+
+        /* Service */
+#if !(defined(GCCK) && defined(OFDM))
+
+        pCtrlSet->CtrlSetting[22] = Service;
+#else
+
+        if (Rate < RATE_6M)
+        {
+                pCtrlSet->CtrlSetting[22] = Service;
+        } else
+        {
+                pCtrlSet->CtrlSetting[22] = 0;
+        }
+#endif
+
+        if (NextLen == 0)
+        {
+                NextLenInUs = 0;
+        } else
+        {
+                Cal_Us_Service(TxRate, NextLen, &NextLenInUs, &Service);
+                pCtrlSet->CtrlSetting[23] = (u8)NextLenInUs;
+                pCtrlSet->CtrlSetting[24] = (u8)(NextLenInUs >> 8);
+
+#ifdef OFDM
+                // NextLen
+                // backup NextLen, because OFDM use these 2 bytes as total length,
+                // so we backup here for Retry fail use.
+                pCtrlSet->CtrlSetting[26] = (u8)NextLen;
+                pCtrlSet->CtrlSetting[27] = (u8)(NextLen >> 8);
+#endif
+
+        }
+
+        return(CTRL_SIZE);
+}
+
+
+#define LOW8(v16)	((u8)( (v16) & 0xFF))
+#define HIGH8(v16)  ((u8)(((v16)>>8) & 0xFF))
+__inline u8
+ABS(u8 N1, u8 N2)
+{
+        s16 Result;
+
+        Result = N1-N2;
+        if(Result < 0 )
+                Result *= -1;
+        return (u8)Result;
+
+}
+
+__inline u32
+Cfg_MacHeader(
+        struct zd1205_private	*macp,
+        zd1205_SwTcb_t	 		*pSwTcb,
+        wla_Header_t 			*pWlaHdr,
+        u8						hdrLen
+)
+{
+        zd1205_Header_t	*pHdr;
+        u8	HdrLen;
+
+        pHdr = pSwTcb->pHwHeaderPtr;
+
+        HdrLen = hdrLen;
+        memcpy(&pHdr->MacHeader[0], (u8 *)pWlaHdr, hdrLen);
+
+        return(HdrLen);
+}
+
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdmic.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdmic.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdmic.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdmic.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,193 @@
+#include "zd80211.h"
+//
+// Michael.cpp  Reference implementation for Michael
+//
+// Copyright (c) 2001 by MacFergus BV
+// All rights reserved,
+//
+
+
+U32 getUInt32(U8 *p)
+// Convert from U8[] to U32 in a portable way
+{
+        U32 res = 0;
+        int i;
+
+        for( i=0; i<4; i++ )
+        {
+                res |= (*p++) << (8*i);
+        }
+
+        return res;
+}
+
+
+void putUInt32(U8 *p, U32 val)
+// Convert from U32 to U8[] in a portable way
+{
+        int i;
+
+        for(i=0; i<4; i++)
+        {
+                *p++ = (U8)(val & 0xff);
+                val >>= 8;
+        }
+}
+
+
+/***********************************************************************/
+/*                                                                     */
+/*   FUNCTION DESCRIPTION                   MICclear                   */
+/*      Initial variable require by MIC computation                    */
+/*                                                                     */
+/*   AUTHOR                                                            */
+/*     Liam,Hwu            ZyDAS Technology   Corporation              */
+/*                                                                     */
+/***********************************************************************/
+void MICclear(MICvar *MIC)
+{
+        // Reset the state to the empty message.
+        MIC->L = MIC->K0;
+        MIC->R = MIC->K1;
+        MIC->nBytesInM = 0;
+        MIC->M = 0;
+}
+
+
+/***********************************************************************/
+/*                                                                     */
+/*   FUNCTION DESCRIPTION                   MICsetKey                  */
+/*      Set MIC key (Tx or Rx)                                         */
+/*                                                                     */
+/*   AUTHOR                                                            */
+/*     Liam,Hwu            ZyDAS Technology   Corporation              */
+/*                                                                     */
+/***********************************************************************/
+void MICsetKey(U8 *key, MICvar *MIC)
+{
+        // Set the key
+        MIC->K0 = getUInt32(key);
+        MIC->K1 = getUInt32(key + 4);
+        if (MIC) {
+#ifdef WPA_DEBUG
+                printk(KERN_ERR "mic->K0= %08x K1=%08x\n", (unsigned)MIC->K0,(unsigned)MIC->K1);
+#endif
+        } else
+                printk(KERN_ERR "pMic is NULL\n");
+        // and reset the message
+        MICclear(MIC);
+}
+
+
+/***********************************************************************/
+/*                                                                     */
+/*   FUNCTION DESCRIPTION                   MICappendByte              */
+/*      Compute MIC for adding a single byte                           */
+/*                                                                     */
+/*   AUTHOR                                                            */
+/*     Liam,Hwu            ZyDAS Technology   Corporation              */
+/*                                                                     */
+/***********************************************************************/
+void MICappendByte(U8 b, MICvar *MIC)
+{
+        register int nBytesInM = MIC->nBytesInM;
+        register U32 M = MIC->M;
+
+        // Append the byte to our word-sized buffer
+        M |= b << (8* nBytesInM);
+        nBytesInM ++;
+
+        // Process the word if it is full.
+        if (nBytesInM > 3) {
+                register U32 L = MIC->L;
+                register U32 R = MIC->R;
+
+                L ^= M;
+                R ^= ROL32(L, 17);
+                L += R;
+                R ^= ((L & 0xff00ff00) >> 8) | ((L & 0x00ff00ff) << 8);
+                L += R;
+                R ^= ROL32(L, 3);
+                L += R;
+                R ^= ROR32(L, 2);
+                L += R;
+
+                MIC->L = L;
+                MIC->R = R;
+
+                // Clear the buffer
+                M = 0;
+                nBytesInM = 0;
+        }
+
+        MIC->M = M;
+        MIC->nBytesInM = nBytesInM;
+
+}
+
+
+void MICappendArr(U8 *pb, MICvar *MIC, U32 Size)
+{
+        int	i;
+        U8 *pB = pb;
+        // Append the byte to our word-sized buffer
+
+        for (i=0; i<Size; i++) {
+                MIC->M |= *pB << (8 * MIC->nBytesInM);
+                MIC->nBytesInM++;
+
+                // Process the word if it is full.
+                if(MIC->nBytesInM >= 4) {
+                        MIC->L ^= MIC->M;
+                        MIC->R ^= ROL32(MIC->L, 17);
+                        MIC->L += MIC->R;
+                        MIC->R ^= ((MIC->L & 0xff00ff00) >> 8) | ((MIC->L & 0x00ff00ff) << 8);
+                        MIC->L += MIC->R;
+                        MIC->R ^= ROL32(MIC->L, 3);
+                        MIC->L += MIC->R;
+                        MIC->R ^= ROR32(MIC->L, 2);
+                        MIC->L += MIC->R;
+
+                        // Clear the buffer
+                        MIC->M = 0;
+                        MIC->nBytesInM = 0;
+                }
+                pB++;
+        }
+}
+
+
+/***********************************************************************/
+/*                                                                     */
+/*   FUNCTION DESCRIPTION                   MICappendByte              */
+/*      Compute MIC for adding a single byte                           */
+/*                                                                     */
+/*   AUTHOR                                                            */
+/*     Liam,Hwu            ZyDAS Technology   Corporation              */
+/*                                                                     */
+/***********************************************************************/
+U8	MicTailPadding[]={0x5a, 0, 0, 0, 0, 0, 0, 0, 0};
+
+void MICgetMIC(U8 *dst, MICvar *MIC)
+{
+        // Append the minimum padding
+        //MICappendArr(MicTailPadding, MIC, 5+((4 -((MIC->nBytesInM+5) & 3)) & 3));
+
+        MICappendByte(0x5a, MIC);
+        MICappendByte(0, MIC);
+        MICappendByte(0, MIC);
+        MICappendByte(0, MIC);
+        MICappendByte(0, MIC);
+
+        // and then zeroes until the length is a multiple of 4
+        while( MIC->nBytesInM != 0 ) {
+                MICappendByte(0, MIC);
+        }
+
+        // The appendByte function has already computed the result.
+        putUInt32(dst, MIC->L);
+        putUInt32(dst+4, MIC->R);
+
+        // Reset to the empty message.
+        MICclear(MIC);
+}
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdmic.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdmic.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdmic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdmic.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,72 @@
+/*
+   $Id: zdmic.h,v 1.1.1.1 2005/11/25 08:04:38 mzcai Exp $
+*/
+/***********************************************************************/
+/*          Copyright 2003 by ZyDAS Technology     Corporation         */
+/*                                                                     */
+/***********************************************************************/
+/***********************************************************************/
+/*                                                                     */
+/*    FILE DESCRIPTION                          MIChael.h              */
+/*      Header file required for TKIP  MIC                             */
+/*                                                                     */
+/*    ROUTINES                                                         */
+/*      XXX                                                            */
+/*                                                                     */
+/*    NOTES                                                            */
+/*      XXX                                                            */
+/*                                                                     */
+/*    MAINTAINER                                                       */
+/*      Liam,Hwu            ZyDAS Technology   Corporation     2003    */
+/*                                                                     */
+/***********************************************************************/
+#ifndef _ZDMIC_H_
+#define _ZDMIC_H_
+
+
+// Rotation functions on 32 bit values
+#define ROL32(A, n) \
+ 		( ((A) << (n)) | ( ((A)>>(32-(n)))  & ( (1UL << (n)) - 1 ) ) )
+
+#define ROR32(A, n) ROL32( (A), 32-(n) )
+
+
+//variable.
+typedef struct
+{
+        U32  K0, K1;	// Key
+        U32  L, R;   	// Current state
+        U32  M;      	// Message accumulator (single word)
+        int  nBytesInM; // # bytes in M
+}
+MICvar;			// variable for MIC
+
+
+// Clear the internal message,
+// resets the object to the state just after construction.
+void MICclear(MICvar *MIC);
+
+
+// Set the key to a new value
+void MICsetKey(U8 *key, MICvar *MIC);
+
+
+// Get the MIC result. Destination should accept 8 bytes of result.
+// This also resets the message to empty.
+
+void MICgetMIC(U8 *dst, MICvar *MIC);
+
+
+// Add a single byte to the internal message
+void MICappendByte(U8 b, MICvar *MIC);
+void MICappendArr(U8 *pb, MICvar *MIC, U32 Size);
+
+
+// Get U32 from 4 bytes LSByte first
+U32 getUInt32(U8 *p);
+
+
+// Put U32 into 4 bytes LSByte first
+void putUInt32(U8 *p, U32 val);
+
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdmmrx.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdmmrx.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdmmrx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdmmrx.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,200 @@
+#ifndef __ZDMMRX_C__
+#define __ZDMMRX_C__
+
+#include "zd80211.h"
+
+
+void RxPsPoll(Frame_t *rdu)
+{
+        U16 aid;
+        U8 vapId = 0;
+        Hash_t *pHash;
+        MacAddr_t *sta;
+
+        //PSDEBUG("RxPsPoll");
+
+        aid = durId(rdu) & 0x3FFF;
+        sta = addr2(rdu);
+        if (isGroup(sta))
+                return;
+
+        if ((aid > MAX_AID) || (aid == 0)) {
+                zd_SendClass3ErrorFrame(sta, vapId);
+                return;
+        } else {
+                pHash = sstByAid[aid];
+                if (pHash->asoc == STATION_STATE_ASOC)
+                        PsPolled(sta, aid);
+                else
+                        zd_SendClass3ErrorFrame(sta, vapId);
+        }
+}
+
+BOOLEAN RxMgtMpdu(Signal_t *signal)
+{
+        StationState sas, sau;
+        FrmDesc_t *pfrmDesc;
+        Frame_t *rdu;
+        U8 FrmType;
+        U16 authSeq = 0;
+
+        ZDEBUG("MgtRxMpdu");
+        pfrmDesc = signal->frmInfo.frmDesc;
+        rdu = pfrmDesc->mpdu;
+        FrmType = frmType(rdu);
+        ZDEBUG_V("FrmType", FrmType);
+
+        switch (FrmType) {
+        case ST_PROBE_REQ:
+                signal->id = SIG_PROBE;
+                signal->block = BLOCK_SYNCH;
+                goto rx_indicate;
+
+        case ST_DEAUTH:
+                if (isGroup(addr1(rdu)))
+                        goto rx_release;
+                else {
+                        if ((memcmp(&mBssId.mac[0],addr2(rdu),6)==0 && mBssType==INFRASTRUCTURE_BSS)) {
+#ifdef WPA_DEBUG
+                                printk(KERN_ERR "Rx Deauth,Reason:%u\n",reason(rdu));
+#endif
+
+                                signal->id = SIG_DEAUTH;
+                                signal->block = BLOCK_AUTH_RSP;
+                                goto rx_indicate;
+                        } else if ((memcmp(&mBssId.mac[0],addr1(rdu),6)==0 && mBssType==AP_BSS)) {
+#ifdef WPA_DEBUG
+                                u8 *pCh=(u8*)addr2(rdu);
+                                u8 i;
+                                printk(KERN_ERR "Rx Deauth from station:");
+                                for (i=0; i<6; i++) {
+                                        printk("%02X ",  *pCh++);
+                                }
+                                printk("\n");
+#endif
+
+                                signal->id = SIG_DEAUTH;
+                                signal->block = BLOCK_AUTH_RSP;
+                                goto rx_indicate;
+                        } else {
+#ifdef WPA_DEBUG
+                                u8 *pCh=(u8*)addr2(rdu);
+                                u8 i;
+                                printk(KERN_ERR "Rx Deauth from unknown station:");
+                                for (i=0; i<6; i++) {
+                                        printk("%02X ",  *pCh++);
+                                }
+                                printk("\n");
+#endif
+
+                                goto rx_release;
+                        }
+
+                }
+
+
+        case ST_AUTH:
+                if (isGroup(addr1(rdu)))
+                        goto rx_release;
+                else {
+                        authSeq = authSeqNum(rdu);
+                        if ((authSeq == 1) || ((authSeq == 3) && wepBit(rdu))) { //Seqence 1 or 3
+                                signal->id = SIG_AUTH_ODD;
+                                signal->block = BLOCK_AUTH_RSP;
+                                goto rx_indicate;
+                        } else if ((authSeq == 2) || (authSeq == 4)) { //Seqence 2 or 4
+                                signal->id = SIG_AUTH_EVEN;
+                                signal->block = BLOCK_AUTH_REQ;
+                                goto rx_indicate;
+                        } else {
+                                goto rx_release;
+                        }
+                }
+
+        case ST_DISASOC:
+                SsInquiry(addr2(rdu), &sas, &sau);
+                if ((memcmp(&mBssId.mac[0],addr2(rdu),6)==0 && mBssType==INFRASTRUCTURE_BSS)) {
+#ifdef WPA_DEBUG
+                        printk(KERN_ERR "Rx DeAssoc,Reason:%u\n",reason(rdu));
+#endif
+
+                }
+                if(sau == STATION_STATE_NOT_AUTH) {
+                        goto class2_err;
+                } else {
+                        signal->id = SIG_DISASSOC;
+                        signal->block = BLOCK_ASOC;
+                        goto rx_indicate;
+                }
+
+        case ST_ASOC_REQ:
+                SsInquiry(addr2(rdu), &sas, &sau);
+                if (sau == STATION_STATE_NOT_AUTH) {
+                        goto class2_err;
+                } else {
+                        signal->id = SIG_ASSOC;
+                        signal->block = BLOCK_ASOC;
+                        goto rx_indicate;
+                }
+
+        case ST_REASOC_REQ:
+                SsInquiry(addr2(rdu), &sas, &sau);
+                if (sau == STATION_STATE_NOT_AUTH) {
+                        goto class2_err;
+                } else {
+                        signal->id = SIG_REASSOC;
+                        signal->block = BLOCK_ASOC;
+                        goto rx_indicate;
+                }
+
+        case ST_BEACON:
+        case ST_PROBE_RSP:
+                if (mBssType == AP_BSS)
+                        goto rx_release;
+
+                signal->id = SIQ_PROBE_RSP_BEACON;
+                signal->block = BLOCK_SYNCH;
+                goto rx_indicate;
+
+        case ST_ASOC_RSP:
+                if (mBssType == AP_BSS)
+                        goto rx_release;
+
+                signal->id = SIG_ASSOC_RSP;
+                signal->block = BLOCK_ASOC;
+                goto rx_indicate;
+
+        case ST_REASOC_RSP:
+                if (mBssType == AP_BSS)
+                        goto rx_release;
+
+                signal->id = SIG_REASSOC_RSP;
+                signal->block = BLOCK_ASOC;
+                goto rx_indicate;
+
+        default:
+                goto rx_release;
+        }
+
+rx_release:
+        ZDEBUG("goto rx_release");
+        return FALSE;
+
+rx_indicate:
+        signal->frmInfo.frmDesc = pfrmDesc;
+        sigEnque(pMgtQ, (signal));
+        return TRUE;
+
+class2_err:
+        ZDEBUG("goto class2_err");
+        signal->id =  SIG_DEAUTH_REQ;
+        signal->block = BLOCK_AUTH_REQ;
+        memcpy((U8 *)&signal->frmInfo.Sta, (U8 *)(addr2(rdu)), 6);
+        signal->frmInfo.rCode = RC_CLASS2_ERROR;
+        freeFdesc(pfrmDesc);
+        sigEnque(pMgtQ, (signal));
+        return TRUE;
+}
+
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdmmrx.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdmmrx.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdmmrx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdmmrx.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,7 @@
+#ifndef _ZDMMRX_H
+#define _ZDMMRX_H
+
+BOOLEAN RxMgtMpdu(Signal_t *signal);
+void RxPsPoll(Frame_t *rdu);
+
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdos.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdos.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdos.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdos.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,9 @@
+#ifndef __ZDOS_H__
+#define __ZDOS_H__
+
+#include <linux/string.h>
+#include <stdarg.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdpci_hotplug.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdpci_hotplug.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdpci_hotplug.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdpci_hotplug.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,74 @@
+
+#include <linux/version.h>
+
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+#include <linux/module.h>
+
+#include <linux/pci.h>
+
+#include "zd1205.h"
+#include "zddebug.h"
+#include "zdpci_hotplug.h"
+#include "zdversion.h"
+
+
+/******************************************************************************
+        Global variable definition section
+******************************************************************************/
+MODULE_AUTHOR("Yarco Yang");
+MODULE_DESCRIPTION("ZyDAS 802.11 Wireless LAN adapter");
+MODULE_LICENSE("GPL");
+
+extern struct net_device *g_dev;
+
+static struct pci_device_id zd1205_id_table[]  =
+        {
+                {
+                        0x167b, 0x2102, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ZD_1202
+                },
+                {0x167b, 0x2100, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ZD_1202},
+                {0x167b, 0x2105, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ZD_1205},
+                {0,}			/* terminate list */
+        };
+
+
+// register the device with the Hotplug facilities of the kernel
+MODULE_DEVICE_TABLE(pci, zd1205_id_table);
+
+
+struct pci_driver zd1205_driver =
+        {
+                .name         = "zd1205",			// Driver name
+                                .id_table     = zd1205_id_table,	// id table
+                                                .probe        = zd1205_found1,		// probe function
+                                                                .remove       = zd1205_remove1,		// remove function
+                                                                        };
+
+/******************************************************************************
+    Module initialization functions
+******************************************************************************/
+
+
+int init_module( void )
+{
+        printk(KERN_NOTICE "%s - version %s\n",  DRIVER_NAME, VERSIONID);
+
+        if (pci_register_driver(&zd1205_driver) <= 0) {
+                printk(KERN_ERR "%s: No devices found, driver not "
+                       "installed.\n", DRIVER_NAME);
+                pci_unregister_driver(&zd1205_driver);
+                return -ENODEV;
+        }
+
+        return 0;
+}
+
+
+void cleanup_module( void )
+{
+        pci_unregister_driver(&zd1205_driver);
+
+        printk(KERN_NOTICE "Unloaded %s \n",  DRIVER_NAME);
+}
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdpci_hotplug.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdpci_hotplug.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdpci_hotplug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdpci_hotplug.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,15 @@
+#ifndef _ZDPCI_HOTPLUG_H
+#define _ZDPCI_HOTPLUG_H
+
+
+#ifndef DRIVER_NAME
+#define DRIVER_NAME             "zd1205"
+#endif
+
+
+
+int init_module( void );
+void cleanup_module( void );
+
+
+#endif  // _ZDPCI_HOTPLUG_H
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdpci_pcmcia.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdpci_pcmcia.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdpci_pcmcia.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdpci_pcmcia.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,124 @@
+#include <linux/version.h>
+
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+
+#include <linux/module.h>
+
+
+#include <linux/pci.h>
+#include <pcmcia/driver_ops.h>
+
+#include "zd1205.h"
+#include "zddebug.h"
+#include "zdpci_pcmcia.h"
+#include "zdversion.h"
+
+/******************************************************************************
+        Global variable definition section
+******************************************************************************/
+MODULE_AUTHOR("Yarco Yang");
+MODULE_DESCRIPTION("ZyDAS 802.11 Wireless LAN adapter");
+MODULE_LICENSE("GPL");
+
+extern struct net_device *g_dev;
+
+struct driver_operations zdpci_ops =
+        {
+                "zd1205", zdpci_attach, zdpci_suspend, zdpci_resume, zdpci_detach
+        };
+
+
+/******************************************************************************
+    Module initialization functions
+******************************************************************************/
+dev_node_t *zdpci_attach(dev_locator_t * loc)
+{
+        u32 io;
+        u16 dev_id;
+        u8 bus, devfn, irq, latency_tmr;
+        struct pci_dev *pci_device;
+        dev_node_t *node;
+        struct zd1205_private *macp;
+
+        // perform some initial setting checks
+        if (loc->bus != LOC_PCI)
+                return NULL;
+
+        bus = loc->b.pci.bus;
+        devfn = loc->b.pci.devfn;
+
+        // get some pci settings for verification
+        pcibios_read_config_dword(bus, devfn, PCI_BASE_ADDRESS_0, &io);
+        pcibios_read_config_byte(bus, devfn, PCI_INTERRUPT_LINE, &irq);
+        pcibios_read_config_word(bus, devfn, PCI_DEVICE_ID, &dev_id);
+
+        // check whether the latency timer is set correctly
+        pcibios_read_config_byte(bus, devfn, PCI_LATENCY_TIMER, &latency_tmr);
+
+        if (io &= ~3, io == 0 || irq == 0) {
+                printk(KERN_ERR "The interface was not assigned\n");
+                return NULL;
+        }
+
+        // get pci device information by loading the pci_dev structure
+        if (pci_device = pci_find_slot(bus, devfn), pci_device == NULL) {
+                // error reading the pci device structure
+                printk(KERN_ERR "ERROR: %s could not get PCI device "
+                       "information \n", DRIVER_NAME );
+                return NULL;
+        }
+
+        zd1205_found1(pci_device, NULL);
+
+
+        // finally setup the node structure with the device information
+        node = kmalloc(sizeof(dev_node_t), GFP_KERNEL);
+        strcpy(node->dev_name, macp->device->name);
+        node->major = 0;
+        node->minor = 0;
+        node->next = NULL;
+        MOD_INC_USE_COUNT;
+        return node;
+}
+
+void zdpci_suspend(dev_node_t * node)
+{
+}
+
+void zdpci_resume(dev_node_t * node)
+{
+}
+
+void zdpci_detach(dev_node_t * node)
+{
+        struct zd1205_private *macp = g_dev->priv;
+
+        unregister_netdev(g_dev);
+        zd1205_remove_proc_subdir(macp);
+        zd1205_clear_structs(g_dev);
+        //--zd1205nics;
+
+        // free the node
+        kfree(node);
+        MOD_DEC_USE_COUNT;
+}
+
+
+int init_module(void)
+{
+        printk(KERN_NOTICE "%s - version %s\n",  DRIVER_NAME, VERSIONID);
+        //register_driver(&zdpci_ops);
+        register_pcmcia_driver();
+
+        return 0;
+}
+
+
+void cleanup_module(void)
+{
+        unregister_driver(&zdpci_ops);
+
+        printk(KERN_NOTICE "Unloaded %s \n",  DRIVER_NAME);
+}
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdpci_pcmcia.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdpci_pcmcia.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdpci_pcmcia.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdpci_pcmcia.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,18 @@
+#ifndef _ZDPCI_PCMCIA_H
+#define _ZDPCI_PCMCIA_H
+
+
+#ifndef DRIVER_NAME
+#define DRIVER_NAME             "zd1205_cb"
+#endif
+
+
+dev_node_t *zdpci_attach( dev_locator_t * );
+void zdpci_suspend( dev_node_t * );
+void zdpci_resume( dev_node_t * );
+void zdpci_detach( dev_node_t * );
+int init_module( void );
+void cleanup_module( void );
+
+
+#endif  // _ZDPCI_PCMCIA_H
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdpmfilter.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdpmfilter.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdpmfilter.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdpmfilter.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,1043 @@
+#ifndef __ZDPMFILTER_C__
+#define __ZDPMFILTER_C__
+
+#include "zd80211.h"
+#include "zd1205.h"
+#include "zddebug.h"
+extern struct net_device *g_dev;
+
+#define DBG_USE_SERIAL_WRITE 0
+void AgePsQ(U16 aid);
+BOOLEAN TxSend(Signal_t *signal, FrmDesc_t *pfrmDesc);
+#define write_str(a,b)
+U8 usedID = 0;
+U8 TimBitMap[(MAX_AID/8)+2];
+Signal_t *txRequest[BURST_NUM];
+static BOOLEAN	mcBuffered = FALSE;
+
+//make tim for beacon frame
+void mkTim(Element *tim, TrafficMap_t *trf, U8 dtc, U8 dtp, U16 aidLo, U16 aidHi, BOOLEAN bc)
+{
+        int	i;
+        U8 *map = (U8*)trf->t;
+        U16	N1 = 0;
+        U16	N2 = 0;
+        U8	index = 0;
+
+        tim->buf[0] = EID_TIM;
+        tim->buf[2] = dtc;
+        tim->buf[3] = dtp;
+
+        // Calculate N1
+        for (i=0; i<=(aidHi/8); i++) {
+                if (map[i] != 0) {
+                        break;
+                }
+        }
+
+        if (i>0) {
+                // N1 is the largest even number
+                N1 = (U16)(i & ~0x01);
+        }
+
+        // Calculate N2
+        for (i=(aidHi/8); i>=0; i--) {
+                if (map[i] != 0) {
+                        break;
+                }
+        }
+
+        if (i>0) {
+                N2 = (U16)i;
+        }
+
+        // Fill the content
+        if (N2==0) {
+                tim->buf[4] = 0;
+                tim->buf[5] = map[0];
+                tim->buf[1] = 4;
+        } else {
+                tim->buf[4] = (U8)N1;
+                for (i=N1; i<=N2; i++) {
+                        tim->buf[5+index++] = map[i];
+                }
+                tim->buf[1] = N2-N1+4;
+        }
+
+        if (bc) {
+                tim->buf[4] |= 0x01;
+        }
+}
+
+
+void TxCompleted(U32 result, U8 retID, U16 aid) //in isr routine
+{
+        Signal_t *signal;
+        FrmInfo_t *pfrmInfo;
+        FrmDesc_t *pfrmDesc;
+        void *buf;
+        Hash_t *pHash = NULL;
+        U8	bIntraBss = 0;
+
+#ifdef HOST_IF_USB
+
+        if ((result != ZD_TX_CONFIRM) && (retID == 0xff))
+        {
+                pHash = sstByAid[aid];
+                if (!pHash)
+                        return;
+                else
+                        pHash->FailedFrames++;
+
+                return;
+        }
+#endif
+
+        signal = txRequest[retID];
+        if (signal == NULL)
+        {
+                printk(KERN_ERR "TxCompleted: input signal is NULL\n");
+                return;
+        }
+        pfrmInfo = &signal->frmInfo;
+        pfrmDesc = pfrmInfo->frmDesc;
+
+        buf = signal->buf;
+        if (pfrmDesc)
+                bIntraBss = (pfrmDesc->ConfigSet & INTRA_BSS_SET);
+
+        //if (aid)
+        {
+                pHash = sstByAid[aid];
+                if (!pHash)
+                        goto no_rate_info;
+
+                if (result == ZD_TX_CONFIRM)
+                {
+                        //for rate adaption
+                        pHash->SuccessFrames++;
+                } else  //retry failed
+                        pHash->FailedFrames++;
+
+        }
+
+
+no_rate_info:
+        if (pfrmDesc)
+                freeFdesc(pfrmDesc);
+        pdot11Obj->ReleaseBuffer(buf);
+        freeSignal(signal);
+        txRequest[retID] = NULL;
+
+        if ((buf) && (!bIntraBss))
+        {	//upper layer data
+                pdot11Obj->TxCompleted();
+        }
+}
+
+
+char DbgStr1[]="Tx ProbReq";
+char DbgStr2[]="Tx Auth";
+char DbgStr3[]="Tx Data";
+char DbgStr4[]="msg4";
+char DbgStr5[]="msg5";
+char DbgStr6[]="msg6";
+char DbgStr7[]="msg7";
+char DbgStr8[]="msg8";
+char DbgStr9[]="msg9";
+char DbgStr10[]="msg10";
+char DbgStr11[]="msg11";
+
+char DbgStr12[]="msg12";
+BOOLEAN TxSend(Signal_t *signal, FrmDesc_t *pfrmDesc)
+{
+        FrmInfo_t *pfrmInfo;
+        U32 nextBodyLen;
+        fragInfo_t fragInfo;
+        int i;
+        U8 bIntraBss = 0;
+        Frame_t *pf;
+        Frame_t *nextPf;
+        U32 flags;
+        Hash_t *pHash = NULL;
+        U32 *tmpiv = NULL;
+        //U8 WepKeyLen = 0;
+        //U8 *pWepKey = NULL;
+        U8 tmp4pIv[8];
+        U8 *pIv = tmp4pIv;
+        U8 KeyId = 5;
+        U32 iv32 = 0;
+        BOOLEAN	bExtIV = FALSE;
+        U8 EncryType;
+        BOOLEAN	bGroupAddr = FALSE;
+        U8 bWep = 0;
+        U8 vapId = 0;
+        U8 Num;
+        U8 bDataFrm = signal->bDataFrm;
+        //U8 KeyInstalled = 0;
+
+        ZDEBUG("TxSend");
+
+
+        //txRequest[usedID] = signal;
+        memcpy(fragInfo.CalSwMic, pfrmDesc->CalMIC, MIC_LNG+1);
+        pfrmInfo = &signal->frmInfo;
+        bIntraBss = (pfrmDesc->ConfigSet & INTRA_BSS_SET);
+
+        pf = pfrmDesc->mpdu;
+
+        //for PS-POLL handling
+        if (pfrmDesc->ConfigSet & PS_POLL_SET) {
+                if(mMacMode != PURE_A_MODE) {
+                        fragInfo.rate = RATE_1M;
+                        fragInfo.preamble = mPreambleType;
+                } else if(mMacMode == PURE_A_MODE) {
+                        fragInfo.rate = RATE_6M;
+                        fragInfo.preamble = SHORT_PREAMBLE; //802.11A frame must
+                }
+
+                fragInfo.aid = 0;
+                fragInfo.macHdr[0] = &pf->header[0];
+                fragInfo.macBody[0] = pf->body;
+                fragInfo.bodyLen[0] = 0;
+                fragInfo.nextBodyLen[0] = 0;
+                //fragInfo.msgID = usedID;
+                fragInfo.totalFrag = 1;
+                fragInfo.hdrLen = pf->HdrLen;
+                fragInfo.encryType = WEP_NOT_USED;
+                fragInfo.vapId = vapId;
+                fragInfo.bIntraBss = bIntraBss;
+                fragInfo.buf = signal->buf;
+                goto just_send;
+        }
+
+        pHash = pfrmDesc->pHash;
+        bWep = wepBit(pf);
+        EncryType = mKeyFormat;
+
+        /*   if ((pf->header[0] & 0xFC) == 0x40)
+             { //Probe Req, for debugging purpose.
+                 if (pf->body[0]==0)
+                 {
+                     if (pf->body[1] == 0)
+                          printk(KERN_ERR "Probe Request with Broadcase ssid\n");
+                     else
+                          printk(KERN_ERR "Probe Request with ssid=%s",&pf->body[2]);
+                 }
+             }    
+             else if ((pf->header[0] & 0xFC) == 0xB0)
+        {
+                 //printk(KERN_ERR "Tx Auth\n");
+          //serial_printf(" Tx Auth\n");	
+        }
+             else if ((pf->header[0] & 0xFC) == 0x08)
+        {
+                 //printk(KERN_ERR "Tx Data,keyMode=%d\n",mDynKeyMode);
+                 //serial_printf("Tx Data,keyMode=%d\n",mDynKeyMode);
+             } */
+        if (isGroup(addr1(pf))) {
+                bGroupAddr = TRUE;
+                fragInfo.rate = pdot11Obj->BasicRate;
+                fragInfo.aid = 0;
+                if(PURE_A_MODE != mMacMode)
+                        fragInfo.preamble = 0;
+                else
+                        fragInfo.preamble = 1;
+
+                /*if ((mSwCipher) && (bWep)){
+                	if ((mDynKeyMode == DYN_KEY_WEP64) || (mDynKeyMode == DYN_KEY_WEP128)){
+                		WepKeyLen = mBcKeyLen;
+                		pWepKey = &mBcKeyVector[0];
+                		pIv = &mBcIv[1];
+                		KeyId = mBcKeyId;
+                		tmpiv = (U32 *)mBcIv;
+                	}
+                }*/ /* The software encryption is always disabled.*/
+
+                if (bWep) {// For 802.1x dynamic key mode
+                        if ((mDynKeyMode == DYN_KEY_WEP64) || (mDynKeyMode == DYN_KEY_WEP128)) {
+                                if (mDynKeyMode == DYN_KEY_WEP64)
+                                        EncryType = WEP64_USED;
+                                else
+                                        EncryType = WEP128_USED;
+                                pIv = &mBcIv[1];
+                                KeyId = mBcKeyId;
+                                tmpiv = (U32 *)mBcIv;
+                        }
+                }
+
+        } else { // unicast frame
+                if (!pHash) {
+                        // Should be Probe Response frame
+                        fragInfo.rate = pdot11Obj->BasicRate;
+                        //FPRINT_V("pHash = 0; fragInfo.rate", fragInfo.rate);
+                        fragInfo.aid = 0;
+                        if(mMacMode != PURE_A_MODE)
+                                fragInfo.preamble = 0;
+                        else
+                                fragInfo.preamble = 1;
+
+                } else {
+                        fragInfo.rate = pHash->CurrTxRate;
+
+                        //FPRINT_V("pHash != 0 fragInfo.rate", fragInfo.rate);
+                        fragInfo.aid = (U16)pHash->aid;
+                        fragInfo.preamble = pHash->Preamble;
+
+                        //if (mBssType == AP_BSS)
+                        {
+                                EncryType = pHash->encryMode;
+                        }
+
+                        //get pairwise key
+                        if (bWep) {
+                                if ((mDynKeyMode == DYN_KEY_WEP64) || (mDynKeyMode == DYN_KEY_WEP128)) {
+                                        pIv = &pHash->wepIv[1];
+                                        KeyId = pHash->KeyId;
+                                        tmpiv = (U32 *)pHash->wepIv;
+                                }
+                        }
+                }
+        }
+
+        if (bWep) {
+                if (mDynKeyMode == 0) {  // static 4 keys, wep64, 128 or 256
+                        pIv = &mWepIv[1];
+                        KeyId = mKeyId;
+                        tmpiv = (U32 *)mWepIv;
+                        EncryType = mKeyFormat;
+                }
+        }
+
+        Num = pfrmInfo->fTot;
+        //FPRINT_V("Tx fTot", pfrmInfo->fTot);
+        for (i=0; i<Num; i++) {
+                pf = &pfrmDesc->mpdu[i];
+                if (Num == 1) {
+                        nextBodyLen = 0;
+                        if (!bDataFrm) { //Management frame
+                                bIntraBss = 0;
+                                if (frmType(pf) == ST_PROBE_RSP)
+                                {
+                                        U32 loTm, hiTm;
+                                        HW_GetTsf(pdot11Obj, &loTm, &hiTm);
+                                        setTs(pf, loTm, hiTm);
+                                }
+                        }
+                } else {
+                        if (Num != (i+1)) {
+                                nextPf = &pfrmDesc->mpdu[i+1];
+                                nextBodyLen = nextPf->bodyLen;
+                        } else {
+                                nextBodyLen = 0;
+                        }
+                }
+
+                //prepare frag information
+                fragInfo.macHdr[i] = &pf->header[0];
+                fragInfo.macBody[i] = pf->body;
+                fragInfo.bodyLen[i] = pf->bodyLen;
+                fragInfo.nextBodyLen[i] = nextBodyLen;
+
+                if (bWep) {// Encryption is needed.
+                        if ((mDynKeyMode == DYN_KEY_TKIP) || (mDynKeyMode == DYN_KEY_AES)) {// WPA encryption mode.
+                                if (bGroupAddr) {
+                                        if (mGkInstalled) {
+                                                switch(mWpaBcKeyLen) {
+                                                case 32:// Group TKIP
+                                                        mIv16++;
+                                                        if (mIv16 == 0)
+                                                                mIv32++;
+                                                        pIv[0] = Hi8(mIv16);
+                                                        pIv[1] = (Hi8(mIv16) | 0x20) & 0x7f;
+                                                        pIv[2] = Lo8(mIv16);
+                                                        KeyId = mWpaBcKeyId;
+                                                        iv32 = mIv32;
+                                                        bExtIV = TRUE;
+                                                        EncryType = TKIP_USED;
+                                                        break;
+                                                case 5: // Group WEP64
+                                                        pIv = &mBcIv[1];
+                                                        KeyId = mWpaBcKeyId;
+                                                        tmpiv = (U32 *)mBcIv;
+                                                        EncryType = WEP64_USED;
+                                                        break;
+                                                case 13: // Group WEP128
+                                                        pIv = &mBcIv[1];
+                                                        KeyId = mWpaBcKeyId;
+                                                        tmpiv = (U32 *)mBcIv;
+                                                        EncryType = WEP128_USED;
+                                                        break;
+                                                case 16:// Group AES
+                                                        mIv16++;
+                                                        if (mIv16 == 0)
+                                                                mIv32++;
+                                                        pIv[0] = Lo8(mIv16);
+                                                        pIv[1] = Hi8(mIv16);
+                                                        pIv[2] = 0;
+                                                        KeyId = mWpaBcKeyId;
+                                                        iv32 = mIv32;
+                                                        bExtIV = TRUE;
+                                                        EncryType = AES_USED;
+                                                        break;
+                                                default: // Group key Len error
+                                                        bWep=FALSE;
+                                                        fragInfo.macHdr[i][1] &= ~WEP_BIT;
+                                                        break;
+                                                }
+                                        } else {// Group key was not installed yet.
+                                                bWep=FALSE;
+                                                fragInfo.macHdr[i][1] &= ~WEP_BIT;
+                                        }
+                                }//endof group frame.
+                                else { //unicast
+                                        //printk(KERN_ERR "send unicast packet,pkeyinstalled:%d\n",pHash->pkInstalled);
+                                        //KeyInstalled = pHash->pkInstalled;
+                                        if ((pHash) && (pHash->pkInstalled)) {
+                                                pHash->iv16++;
+                                                if (pHash->iv16 == 0)
+                                                        pHash->iv32++;
+                                                if (EncryType == TKIP_USED) {
+                                                        pIv[0]  = Hi8(pHash->iv16);
+                                                        pIv[1]  = (Hi8(pHash->iv16) | 0x20) & 0x7f;
+                                                        pIv[2]  = Lo8(pHash->iv16);
+                                                } else if (EncryType == AES_USED) {
+                                                        pIv[0]  = Lo8(pHash->iv16);
+                                                        pIv[1]  = Hi8(pHash->iv16);
+                                                        pIv[2]  = 0;
+                                                }
+                                                KeyId = pHash->KeyId;
+                                                iv32 = pHash->iv32;
+                                                bExtIV = TRUE;
+                                        } else {// No key has been installed before.
+                                                bWep=FALSE;
+                                                fragInfo.macHdr[i][1] &= ~WEP_BIT;
+                                        }
+                                }
+                        } // end of ((mDynKeyMode == DYN_KEY_TKIP) || (mDynKeyMode == DYN_KEY_AES))
+                        fragInfo.macHdr[i][MAC_HDR_LNG] = pIv[0];
+                        fragInfo.macHdr[i][MAC_HDR_LNG+1] = pIv[1];
+                        fragInfo.macHdr[i][MAC_HDR_LNG+2] = pIv[2];
+                        fragInfo.macHdr[i][MAC_HDR_LNG+3] = KeyId << 6;
+                        //if (mDynKeyMode != DYN_KEY_TKIP && mDynKeyMode != DYN_KEY_AES)
+                        if (EncryType == WEP64_USED || EncryType == WEP128_USED)
+                                *tmpiv  = (((*tmpiv) & 0x00FFFFFF) + 1) | ((*tmpiv) & 0xFF000000);
+
+                        if (bExtIV) {
+                                fragInfo.macHdr[i][MAC_HDR_LNG+3] |= 0x20;
+                                fragInfo.macHdr[i][MAC_HDR_LNG+4] = (U8)(iv32);
+                                fragInfo.macHdr[i][MAC_HDR_LNG+5] = (U8)(iv32 >> 8);
+                                fragInfo.macHdr[i][MAC_HDR_LNG+6] = (U8)(iv32 >> 16);
+                                fragInfo.macHdr[i][MAC_HDR_LNG+7] = (U8)(iv32 >> 24);
+                        }
+                }
+
+        }
+
+        //fragInfo.msgID = usedID;
+        fragInfo.bIntraBss = bIntraBss;
+        fragInfo.buf = signal->buf;
+        fragInfo.totalFrag = Num;
+        fragInfo.hdrLen = MAC_HDR_LNG;
+
+        if (bWep) {
+                fragInfo.hdrLen += IV_LNG;
+                if (bExtIV) {
+                        fragInfo.hdrLen += EIV_LNG;
+                }
+                fragInfo.encryType = EncryType;
+        } else
+                fragInfo.encryType=WEP_NOT_USED;
+
+        //if (mAssoc)
+        //FPRINT_V("EncryType", fragInfo.encryType);
+        //fragInfo.vapId = vapId;
+
+        //if (fragInfo.encryType == TKIP)
+        {
+                //fragInfo.bWaitingMIC = pfrmDesc->bWaitingMIC;
+                //fragInfo.bSwCalcMIC = pfrmDesc->bSwCalcMIC;
+                //fragInfo.HwMicPhys = (U32)pfrmDesc->HwMicPhys;
+        }
+
+just_send:
+        flags = pdot11Obj->EnterCS();
+        // The following 5 lines must be protected by a critical section.
+        fragInfo.msgID = usedID;
+        txRequest[usedID] = signal;
+        usedID++;
+        if (usedID > (BURST_NUM -1))
+                usedID = 0;
+        pdot11Obj->SetupNextSend(&fragInfo); // No need protection in CardBus
+
+        pdot11Obj->ExitCS(flags);
+
+        return FALSE;
+}
+
+void FlushQ(SignalQ_t *Q)
+{
+        Signal_t *signal;
+        FrmInfo_t *pfrmInfo;
+        FrmDesc_t *pfrmDesc;
+
+        while((signal = sigDeque(Q)) != NULL) {
+                pfrmInfo = &signal->frmInfo;
+                pfrmDesc = pfrmInfo->frmDesc;
+                pdot11Obj->ReleaseBuffer(signal->buf);
+                freeFdesc(pfrmDesc);
+                freeSignal(signal);
+        }
+}
+
+
+void TimMapSet(U8 *map, U16 aid, BOOLEAN flag)
+{
+        U8	mask, index;
+
+
+        if ((aid == 0) || (aid > MAX_AID))
+                return;
+
+        index = aid / 8;
+        mask = 0x01 << (aid % 8);
+
+        if (flag)
+                map[index] |= mask;
+        else
+                map[index] &= ~mask;
+}
+
+
+
+BOOLEAN CleanupTxQ(void)
+{
+        Signal_t *signal;
+        FrmInfo_t *pfrmInfo;
+        FrmDesc_t *pfrmDesc;
+
+        //PSDEBUG("CleanupTxQ");
+        if (pTxQ->cnt > 0) {
+                signal = pTxQ->first;
+                if (!signal)
+                        return FALSE;
+
+                pfrmInfo = &signal->frmInfo;
+                pfrmDesc = pfrmInfo->frmDesc;
+
+                if (!pdot11Obj->CheckTCBAvail(pfrmInfo->fTot))
+                        return FALSE;
+
+                signal = sigDeque(pTxQ);
+                goto send_PduReq;
+        }
+
+        return FALSE;
+
+
+send_PduReq:
+        TxSend(signal, pfrmDesc);
+        return TRUE;
+}
+
+
+
+BOOLEAN CleanupAwakeQ(void)
+{
+        Signal_t *signal;
+        FrmInfo_t *pfrmInfo;
+        FrmDesc_t *pfrmDesc;
+
+        //PSDEBUG("CleanupAwakeQ");
+        if (pAwakeQ->cnt > 0) {
+                signal = pAwakeQ->first;
+                if (!signal)
+                        return FALSE;
+
+                pfrmInfo = &signal->frmInfo;
+
+                pfrmDesc = pfrmInfo->frmDesc;
+                if (!pdot11Obj->CheckTCBAvail(pfrmInfo->fTot))
+                        return FALSE;
+
+                signal = sigDeque(pAwakeQ);
+                //PSDEBUG("===== Queue out awakeQ");
+                //PSDEBUG_V("pAwakeQ->cnt", pAwakeQ->cnt);
+                goto send_PduReq;
+        }
+
+        return FALSE;
+
+
+send_PduReq:
+        TxSend(signal, pfrmDesc);
+        return TRUE;
+}
+
+
+void AgePsQ(U16 aid)
+{
+        Signal_t *psSignal;
+        U16 interval;
+        FrmDesc_t *pfrmDesc;
+        U32 eol;
+        FrmInfo_t *pfrmInfo;
+
+        if ((aid == 0) || (aid > MAX_AID))	//Invalid AID
+                return;
+
+
+        while (pPsQ[aid]->cnt) {
+                interval = sstByAid[aid]->lsInterval;
+                if (interval == 0)
+                        interval = 1;
+
+                psSignal = pPsQ[aid]->first;
+
+                if (!psSignal)
+                        break;
+
+                pfrmInfo = &psSignal->frmInfo;
+                eol = pfrmInfo->eol;
+#ifndef HOST_IF_USB
+
+                if ((HW_GetNow(pdot11Obj) - eol) < (2*interval*mBeaconPeriod*1024)) //us
+                        break;
+
+                if ((HW_GetNow(pdot11Obj) - eol) < (1024*1024)) //us
+                        break;
+#else
+
+                if ((HW_GetNow(pdot11Obj) - eol) < (2*interval*mBeaconPeriod/10)) //10ms
+                        break;
+
+                if ((HW_GetNow(pdot11Obj) - eol) < (100)) //10ms
+                        break;
+#endif
+                //Data life time-out
+                psSignal = sigDeque(pPsQ[aid]);
+                if (!psSignal)
+                        break;
+
+                PSDEBUG_V("*****Data life time-out, AID", aid);
+                pfrmDesc = pfrmInfo->frmDesc;
+
+                freeFdesc(pfrmDesc);
+                pdot11Obj->ReleaseBuffer(psSignal->buf);
+                freeSignal(psSignal);
+        }
+
+
+        if (!pPsQ[aid]->cnt)
+                TimMapSet(TimBitMap, aid, FALSE);
+
+        return;
+}
+
+
+void PsPolled(MacAddr_t *sta, U16 aid)
+{
+        Signal_t *signal;
+        FrmInfo_t *pfrmInfo;
+        FrmDesc_t *pfrmDesc;
+        Frame_t	*frame;
+        int i;
+        U8 Num;
+
+        //PSDEBUG("PsPolled");
+
+        signal = sigDeque(pPsQ[aid]);
+        if (!signal) {
+                PSDEBUG("No Queue data for PS-POLL!!!");
+                TimMapSet(TimBitMap, aid, FALSE);
+                return;
+        } else {
+
+                PSDEBUG_V("Queue out psQ, AID ", aid);
+                PSDEBUG_V("cnt ", pPsQ[aid]->cnt);
+                pfrmInfo = &signal->frmInfo;
+                pfrmDesc = pfrmInfo->frmDesc;
+
+                Num = pfrmInfo->fTot;
+                for (i=0; i<Num; i++) {
+                        frame = &pfrmDesc->mpdu[i];
+                        //PSDEBUG_V("pfrmInfo ", (U32)pfrmInfo);
+                        //PSDEBUG_V("eol ", (U32)pfrmInfo->eol);
+                        PSDEBUG_V("pfrmDesc ", (U32)pfrmDesc);
+                        //PSDEBUG_V("frame ", (U32)frame);
+                        if (!pPsQ[aid]->cnt) {
+                                frame->header[1] &= ~MORE_DATA_BIT;
+                                PSDEBUG("More bit 0");
+                        } else {
+                                frame->header[1] |= MORE_DATA_BIT;
+                                PSDEBUG("More bit 1");
+                        }
+
+                        PSDEBUG_V("bodyLen ", frame->bodyLen);
+                }
+
+
+                if (!pdot11Obj->CheckTCBAvail(Num)) {
+                        PSDEBUG("*****Fail to send out!!!");
+                        PSDEBUG_V("Queue in psQ, AID", aid);
+                        sigEnqueFirst(pPsQ[aid], signal);
+                        return;
+                } else
+                        sigEnque(pTxQ, signal);
+                return;
+        }
+}
+
+
+void StaWakeup(MacAddr_t *sta)
+{
+        U16 aid;
+        Signal_t *signal;
+
+        aid = AIdLookup(sta);
+        if ((aid == 0) || (aid > MAX_AID))
+                return;
+
+        while((signal = sigDeque(pPsQ[aid])) != NULL) {
+                sigEnque(pTxQ, signal);
+        }
+}
+
+
+void InitPMFilterQ(void)
+{
+        U8	i;
+        static	BOOLEAN bFirstTime = TRUE;
+
+        if (bFirstTime) {
+                bFirstTime = FALSE;
+                for (i=0; i < MAX_RECORD; i++) {
+                        pPsQ[i] = &psQ[i];
+                        initSigQue(pPsQ[i]);
+                }
+                pTxQ = &txQ;
+                pAwakeQ = &awakeQ;
+                initSigQue(pTxQ);
+                initSigQue(pAwakeQ);
+        } else {
+                for (i=0; i < MAX_RECORD; i++)
+                        FlushQ(pPsQ[i]);
+                FlushQ(pTxQ);
+                FlushQ(pAwakeQ);
+        }
+
+        memset(TimBitMap, 0, sizeof(TimBitMap));
+}
+
+
+void ConfigBcnFIFO(void)
+{
+        int i, j;
+        BOOLEAN	bcst = FALSE;
+        struct zd1205_private *macp=g_dev->priv;
+        Signal_t *signal;
+        U8 tim[256];
+        U8 Beacon[256];
+        U16 BcnIndex = 0;
+        U8	Len;
+
+        //FPRINT("ConfigBcnFIFO");
+
+        if (mBssType == AP_BSS) {
+                if (mPsStaCnt > 0) {
+                        HW_SetSTA_PS(pdot11Obj, 1);
+                        for (i=1; i < (MAX_AID+1); i++) {
+                                AgePsQ(i);
+                                if (pPsQ[i]->cnt) {
+                                        TimMapSet(TimBitMap, i, TRUE);
+                                        PSDEBUG_V("TimMapSet Aid", i);
+                                }
+                        }
+                } else {
+                        HW_SetSTA_PS(pdot11Obj, 0);
+                        //send McQ
+                        if (pPsQ[0]->cnt) {
+                                while(1) {
+                                        signal = sigDeque(pPsQ[0]);
+                                        if (!signal)
+                                                break;
+
+                                        sigEnque(pTxQ, signal);
+                                }
+                        }
+                }
+        }
+
+        /* make beacon frame */
+        /* Frame control */
+        Beacon[BcnIndex++] = 0x80;
+        Beacon[BcnIndex++] = 0x00;
+
+        /* Duration HMAC will fill this field */
+        Beacon[BcnIndex++] = 0x00;
+        Beacon[BcnIndex++] = 0x00;
+
+        /* Address1 */
+        Beacon[BcnIndex++] = 0xff;
+        Beacon[BcnIndex++] = 0xff;
+        Beacon[BcnIndex++] = 0xff;
+        Beacon[BcnIndex++] = 0xff;
+        Beacon[BcnIndex++] = 0xff;
+        Beacon[BcnIndex++] = 0xff;
+
+        /* Address2 */
+        for (j=0; j<6; j++)
+                //Beacon[BcnIndex++] = mBssId.mac[j];
+                Beacon[BcnIndex++] = dot11MacAddress.mac[j];
+
+        /* Address3 */
+        for (j=0; j<6; j++)
+
+                Beacon[BcnIndex++] = mBssId.mac[j];
+
+        /* Sequence control	HMAC will fill this field */
+        //Beacon[BcnIndex++] = 0x00;
+        //Beacon[BcnIndex++] = 0x00;
+        BcnIndex += 2;
+
+        /* Timestamp	HMAC will fill this field */
+        //for (j=0; j<8; j++)
+        //Beacon[BcnIndex++] = 0x00;
+        BcnIndex += 8;
+
+        /* BeaconInterval */
+        Beacon[BcnIndex++] = mBeaconPeriod;
+        Beacon[BcnIndex++] = mBeaconPeriod >> 8;
+
+        /* Display the Capability */
+        if(pdot11Obj->dbg_cmd & DBG_CMD_BEACON)
+                printk(KERN_ERR "mCap: 0x%04x\n", mCap);
+
+        /* Capability */
+        Beacon[BcnIndex++] = mCap;
+        Beacon[BcnIndex++] = mCap >> 8;
+
+        /* SSID */
+        Len = eLen(&mSsid)+2;
+        for (j=0; j<Len; j++)
+                Beacon[BcnIndex++] = mSsid.buf[j];
+
+        /* Supported rates */
+        Len = eLen(&mBrates)+2;
+        for (j=0; j<Len; j++)
+                Beacon[BcnIndex++] = mBrates.buf[j];
+
+        /* DS parameter */
+        Beacon[BcnIndex++] = mPhpm.buf[0];
+        Beacon[BcnIndex++] = mPhpm.buf[1];
+        Beacon[BcnIndex++] = mPhpm.buf[2];
+
+        if (mBssType == INDEPENDENT_BSS) {
+                Beacon[BcnIndex++] = EID_IBPARMS;
+                Beacon[BcnIndex++] = 0x2;
+                Beacon[BcnIndex++] = mATIMWindow;
+                Beacon[BcnIndex++] = mATIMWindow >> 8;
+        }
+
+        /* Tim */
+        //if ((mDtimCount == 0) && (pPsQ[0]->cnt > 0)){ //dtim and buffer for mc
+        if (mBssType == AP_BSS) {
+                if ((mDtimCount == 0) && mcBuffered) {
+                        bcst = TRUE;
+                }
+
+                mkTim((Element*)tim, (TrafficMap_t *)&TimBitMap, mDtimCount, mDtimPeriod, 1, MAX_AID, bcst);
+                Len = tim[1]+2;
+                for (j=0; j<Len; j++)
+                        Beacon[BcnIndex++] = tim[j];
+        }
+
+#if defined(OFDM)
+        if (mMacMode != PURE_B_MODE && mMacMode != PURE_A_MODE) {
+
+                //ERP element
+
+                Beacon[BcnIndex++] = mErp.buf[0];
+                Beacon[BcnIndex++] = mErp.buf[1];
+                Beacon[BcnIndex] = mErp.buf[2];
+                /*if (pdot11Obj->bDisProtection==1)
+                {//Disable protection
+                	Beacon[BcnIndex] &= ~USE_PROTECTION;
+                }*/
+                BcnIndex++;
+
+                //Extended supported rates
+                Len = mExtRates.buf[1]+2;
+                ;
+                for (j=0; j<Len; j++)
+                        Beacon[BcnIndex++] = mExtRates.buf[j];
+        }
+#endif
+
+        //WPA IE
+        /*	if ((mDynKeyMode == DYN_KEY_TKIP) || (mDynKeyMode == DYN_KEY_AES)){
+        		Len = mWPAIe.buf[1]+2;
+        		for (j=0; j<Len; j++)
+        			Beacon[BcnIndex++] = mWPAIe.buf[j];
+        	}	*/
+        Len  = macp->cardSetting.WPAIeLen;
+        if (Len) {
+                memcpy(&Beacon[BcnIndex], &mWPAIe, Len);
+                BcnIndex += Len;
+        }
+
+        /* CRC32 HMAC will calucate this value */
+        //for (j=0; j<4; j++)
+        //	Beacon[BcnIndex++] = 0x00;
+        BcnIndex += 4;
+
+
+        HW_SetBeaconFIFO(pdot11Obj, &Beacon[0], BcnIndex);
+        memset(TimBitMap, 0, sizeof(TimBitMap));
+}
+
+
+void SendMcPkt(void)
+{
+        Signal_t *signal;
+
+        while(pPsQ[0]->cnt > 0) {
+                signal = pPsQ[0]->first;
+                if (!signal)
+                        break;
+
+                signal = sigDeque(pPsQ[0]);
+                //PSDEBUG("Queue in awakeQ");
+                sigEnque(pAwakeQ, signal);
+                //PSDEBUG_V("pAwakeQ->cnt", pAwakeQ->cnt);
+        }
+
+        if (pAwakeQ->cnt > 0) {
+                mcBuffered = TRUE;
+        } else
+                mcBuffered = FALSE;
+}
+
+
+void ResetPMFilter(void)
+{
+        int i;
+
+        for (i=0; i<BURST_NUM; i++)
+                txRequest[i] = NULL;
+
+        InitPMFilterQ();
+}
+
+
+BOOLEAN SendPkt(Signal_t* signal, FrmDesc_t *pfrmDesc, BOOLEAN bImmediate)
+{
+        FrmInfo_t *pfrmInfo;
+        Frame_t	*frame;
+        int i;
+        Hash_t *pHash;
+        U8	Num;
+
+        //PSDEBUG("SendPkt");
+        pfrmInfo = &signal->frmInfo;
+        frame = pfrmDesc->mpdu;
+        pHash = pfrmDesc->pHash;
+        Num = pfrmInfo->fTot;
+
+        if (!signal->bDataFrm) {
+                //if (!pfrmDesc->bDataFrm){
+                goto direct_send;
+        }
+
+        if (!isGroup(addr1(frame))) { //unicast
+                PsMode dpsm;
+                U16 aid;
+
+                /* ath_desc: fix AP_BSS crash */
+                if ((mBssType != AP_BSS) || (!pHash))
+                        goto direct_send;
+
+                //PsInquiry(addr1(frame), &dpsm, &aid);
+                dpsm = pHash->psm;
+                aid = pHash->aid;
+
+                if ((dpsm == PSMODE_POWER_SAVE) && (aid > 0) && (aid <(MAX_AID+1))) {
+                        AgePsQ(aid);
+
+                        if (zd_CheckTotalQueCnt() > TXQ_THRESHOLD) {
+                                PSDEBUG("*****Drop PS packet*****");
+                                freeFdesc(pfrmDesc);
+                                pdot11Obj->ReleaseBuffer(signal->buf);
+                                freeSignal(signal);
+                                return FALSE;
+                        } else {
+                                //for (i=0; i<Num; i++){
+                                //	setMoreData((&pfrmDesc->mpdu[i]), 1);
+                                //  pfrmDesc->mpdu[i].header[i] |= MORE_DATA_BIT;
+                                //}
+                                pfrmInfo->eol = HW_GetNow(pdot11Obj);	//Set timestamp
+
+                                sigEnque(pPsQ[aid], signal);			//Queue in PS Queue
+                                PSDEBUG_V("Queue in PS Queue, AID ", aid);
+                                PSDEBUG_V("cnt ", pPsQ[aid]->cnt);
+                                //PSDEBUG_V("pfrmInfo ", (U32)pfrmInfo);
+                                //PSDEBUG_V("eol ", (U32)pfrmInfo->eol);
+                                PSDEBUG_V("pfrmDesc ", (U32)pfrmDesc);
+                                //PSDEBUG_V("frame ", (U32)frame);
+                                PSDEBUG_V("bodyLen ", frame->bodyLen);
+                                TimMapSet(TimBitMap, aid, TRUE);
+                                return FALSE;
+                        }
+                } else {
+                        goto direct_send;
+                }
+        } else {   //group address
+                if ((orderBit(frame) == 0) && (mPsStaCnt > 0)) {
+                        if ((zd_CheckTotalQueCnt() > TXQ_THRESHOLD) || (pPsQ[0]->cnt > MCQ_THRESHOLD)) {
+                                PSDEBUG("*****Drop MC packet*****");
+                                freeFdesc(pfrmDesc);
+                                pdot11Obj->ReleaseBuffer(signal->buf);
+                                freeSignal(signal);
+                                return FALSE;
+                        } else {
+                                for (i=0; i<Num; i++) {
+                                        pfrmDesc->mpdu[i].header[i] |= MORE_DATA_BIT;
+                                }
+
+                                sigEnque(pPsQ[0], signal);	// psQ[0] is for mcQ
+                                //PSDEBUG("+++++ Queue in mcQ");
+                                //PSDEBUG_V("mcQ->cnt", pPsQ[0]->cnt);
+                                return FALSE;
+                        }
+                } else {
+                        goto direct_send;
+                }
+        }
+
+
+direct_send:
+        if (!bImmediate) {
+                sigEnque(pTxQ, signal);
+                return FALSE;
+        } else {
+                if (!pdot11Obj->CheckTCBAvail(Num)) {
+#if 1  //727
+                        /* ath_desc: fix mem leak */
+                        freeFdesc(pfrmDesc);
+                        pdot11Obj->ReleaseBuffer(signal->buf);
+                        freeSignal(signal);
+                        return TRUE;
+#else
+
+                        sigEnque(pTxQ, signal);
+                        return FALSE;
+#endif
+                        //PSDEBUG("Queue in TxQ");
+                        //PSDEBUG_V("Cnt of TxQ", pTxQ->cnt);
+                }
+                return TxSend(signal, pfrmDesc); //14 us
+        }
+}
+
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdpmfilter.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdpmfilter.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdpmfilter.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdpmfilter.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,17 @@
+#ifndef _ZDPMFILTER_H
+#define _ZDPMFILTER_H
+
+extern Signal_t *txRequest[BURST_NUM];
+
+void TxCompleted(U32 result, U8 retID, U16 aid);
+void StaWakeup(MacAddr_t *sta);
+void ConfigBcnFIFO(void);
+void SendMcPkt(void);
+void ResetPMFilter(void);
+void PsPolled(MacAddr_t *sta, U16 aid);
+void InitPMFilterQ(void);
+void FlushQ(SignalQ_t *Q);
+BOOLEAN CleanupAwakeQ(void);
+BOOLEAN CleanupTxQ(void);
+BOOLEAN SendPkt(Signal_t* signal, FrmDesc_t *pfrmDesc, BOOLEAN bImmediate);
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdpsmon.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdpsmon.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdpsmon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdpsmon.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,1045 @@
+#ifndef __ZDPSMON_C__
+#define __ZDPSMON_C__
+
+#include "zd80211.h"
+#include "zddebug.h"
+
+#define GetEntry(pMac)		(((pMac->mac[3]) ^ (pMac->mac[4]) ^ (pMac->mac[5])) & (MAX_AID-1))
+
+Hash_t *FreeHashList;
+Hash_t HashBuf[MAX_RECORD];
+Hash_t *HashTbl[MAX_RECORD];
+Hash_t *sstByAid[MAX_RECORD];
+U32 freeHashCount;
+
+extern void zd1205_config_dyn_key(u8 DynKeyMode, u8 *pkey, int idx);
+Hash_t *HashInsert(MacAddr_t *pMac);
+
+void CleanupHash(Hash_t *hash)
+{
+        memset(hash->mac, 0, 6);
+        hash->asoc = STATION_STATE_DIS_ASOC;
+        hash->auth = STATION_STATE_NOT_AUTH;
+        hash->psm = PSMODE_STA_ACTIVE;
+        hash->encryMode = WEP_NOT_USED;
+        hash->ZydasMode = 0;
+        hash->pkInstalled = 0;
+        hash->AlreadyIn = 0;
+        hash->ContSuccFrames = 0;
+        hash->ttl = 0;
+        hash->bValid = FALSE;
+        hash->Preamble = 0;
+        hash->keyLength = 0;
+        hash->KeyId = 0;
+        memset(hash->wepIv, 0, 4);
+        memset(&hash->TxSeed, 0, sizeof(Seedvar));
+        memset(&hash->RxSeed, 0, sizeof(Seedvar));
+        memset(&hash->TxMicKey, 0, sizeof(MICvar));
+        memset(&hash->RxMicKey, 0, sizeof(MICvar));
+        hash->SuccessFrames = 0;
+        hash->FailedFrames = 0;
+        hash->bJustRiseRate = FALSE;
+        hash->RiseConditionCount = 0;
+        hash->DownConditionCount = 0;
+        hash->vapId = 0;
+#if defined(OFDM)
+
+        hash->bErpSta = TRUE;
+#else
+
+        hash->bErpSta = FALSE;
+#endif
+}
+
+
+void CleanupKeyInfo(Hash_t *hash)
+{
+        hash->encryMode = WEP_NOT_USED;
+        hash->pkInstalled = 0;
+        hash->keyLength = 0;
+        hash->KeyId = 0;
+        memset(hash->wepIv, 0, 4);
+        memset(&hash->TxSeed, 0, sizeof(Seedvar));
+        memset(&hash->RxSeed, 0, sizeof(Seedvar));
+        memset(&hash->TxMicKey, 0, sizeof(MICvar));
+        memset(&hash->RxMicKey, 0, sizeof(MICvar));
+}
+
+
+void initHashBuf(void)
+{
+        int i;
+
+        freeHashCount = MAX_RECORD;
+
+        for (i=0; i<MAX_AID; i++) { //from 0 to 31
+                HashBuf[i].pNext = &HashBuf[i+1];
+                sstByAid[i] = &HashBuf[i];
+                HashBuf[i].aid = i;
+                CleanupHash(&HashBuf[i]);
+        }
+
+        //aid 32 is here
+        HashBuf[MAX_AID].pNext = NULL;
+        sstByAid[MAX_AID] = &HashBuf[MAX_AID];
+        HashBuf[MAX_AID].aid = MAX_AID;
+        CleanupHash(&HashBuf[MAX_AID]);
+
+        FreeHashList = &HashBuf[1]; //by pass aid = 0
+
+        //deal with aid = 0
+        HashBuf[0].pNext = NULL;
+}
+
+
+Hash_t *allocHashBuf(void)
+{
+        Hash_t *hash = NULL;
+        /* ath_desc: AMD64 support */
+        unsigned long flags;
+
+        //HSDEBUG("*****allocHashBuf*****");
+        flags = pdot11Obj->EnterCS();
+        if (FreeHashList != NULL) {
+                hash = FreeHashList;
+                FreeHashList = FreeHashList->pNext;
+                hash->pNext = NULL;
+                freeHashCount--;
+        }
+        pdot11Obj->ExitCS(flags);
+        return hash;
+}
+
+
+
+void freeHashBuf(Hash_t *hash)
+{
+        unsigned long flags;
+
+        //HSDEBUG("*****freeHashBuf*****");
+        flags = pdot11Obj->EnterCS();
+        if (hash->AlreadyIn) {
+                if (mCurrConnUser > 0)
+                        mCurrConnUser--;
+                if (hash->bErpSta == FALSE && mNumBOnlySta > 0) {
+                        mNumBOnlySta--;
+                        if (mNumBOnlySta==0) {
+                                pdot11Obj->ConfigFlag &= ~NON_ERP_PRESENT_SET;
+                                mErp.buf[2] &= ~NON_ERP_PRESENT;
+                        }
+                }
+        }
+
+        if (hash->psm == PSMODE_POWER_SAVE) {
+                if (mPsStaCnt > 0)
+                        mPsStaCnt--;
+        }
+
+#if defined(AMAC)
+        HW_CAM_ClearRollTbl(pdot11Obj, hash->aid);
+#endif
+
+        CleanupHash(hash);
+        hash->pNext = FreeHashList;
+        FreeHashList = hash;
+        freeHashCount++;
+        pdot11Obj->ExitCS(flags);
+}
+
+
+void InitHashTbl(void)
+{
+        int i;
+
+        for (i=0; i<MAX_RECORD; i++) {
+                HashTbl[i] = NULL;
+        }
+}
+
+
+Hash_t *HashSearch(MacAddr_t *pMac)
+{
+        U8 entry;
+        Hash_t *hash = NULL;
+        unsigned long flags;
+
+        if (mBssType == INFRASTRUCTURE_BSS) {
+                if (memcmp(&mBssId, pMac, 6) != 0) {
+                        return NULL;
+                } else
+                        return sstByAid[0];
+        }
+
+        //HSDEBUG("HashSearch");
+        entry = GetEntry(pMac);
+        flags = pdot11Obj->EnterCS();
+        if (HashTbl[entry] == NULL) {
+                goto exit;
+        } else {
+                hash = HashTbl[entry];
+                do {
+                        if (memcmp(hash->mac, (U8 *)pMac, 6) == 0) {
+                                //HSDEBUG("Search got one");
+                                goto exit;
+                        } else
+                                hash = hash->pNext;
+
+                } while(hash != NULL);
+        }
+
+exit:
+        pdot11Obj->ExitCS(flags);
+        if (hash) {
+#if 0
+                printf("macaddr = %02x:%02x:%02x:%02x:%02x:%02x\n",
+                       hash->mac[0],  hash->mac[1], hash->mac[2],
+                       hash->mac[3], hash->mac[4], hash->mac[5]);
+                printf("asoc = %x\n", hash->asoc);
+                printf("auth = %x\n", hash->auth);
+                printf("psm = %x\n", hash->psm);
+                printf("aid = %x\n", hash->aid);
+                printf("lsInterval = %x\n", hash->lsInterval);
+#endif
+
+        } else
+                ;//HSDEBUG("Search no one");
+
+        return hash;
+}
+
+
+
+
+
+
+Hash_t *HashInsert(MacAddr_t *pMac)
+{
+        U8 entry;
+        Hash_t *hash;
+        unsigned long flags;
+
+        HSDEBUG("HashInsert");
+
+        if (mBssType == INFRASTRUCTURE_BSS) {
+                hash = sstByAid[0];
+                memcpy(hash->mac, (U8 *)pMac, 6);
+                hash->ttl = HW_GetNow(pdot11Obj);
+                hash->bValid = TRUE;
+                return hash;
+        }
+
+        hash = allocHashBuf();
+        if (!hash) {
+                HSDEBUG("No free one");
+                //Age Hash table
+                AgeHashTbl();
+                return NULL; // no free one
+        } else {
+                entry = GetEntry(pMac);
+                HSDEBUG_V("entry", entry);
+
+                if (HashTbl[entry] == NULL) { //entry is null
+                        HashTbl[entry] = hash;
+                        HSDEBUG("Entry is null");
+                } else { //insert list head
+                        flags = pdot11Obj->EnterCS();
+                        hash->pNext = HashTbl[entry];
+                        HashTbl[entry] = hash;
+                        pdot11Obj->ExitCS(flags);
+                        HSDEBUG("Insert to list head");
+                }
+
+                memcpy(hash->mac, (U8 *)pMac, 6);
+                hash->ttl = HW_GetNow(pdot11Obj);
+                hash->bValid = TRUE;
+                return hash;
+        }
+}
+
+
+BOOLEAN AgeHashTbl(void)
+{
+        U32 now, ttl, idleTime;
+        U8 entry, firstLayer;
+
+        int i;
+        MacAddr_t *pMac;
+        Hash_t *hash, *preHash = NULL;
+        BOOLEAN ret = FALSE;
+
+        HSDEBUG("*****AgeHashTbl*****");
+        now = HW_GetNow(pdot11Obj);
+
+        for (i=1; i<(MAX_AID+1); i++) {
+                ttl = sstByAid[i]->ttl;
+                if (now > ttl)
+                        idleTime = now - ttl;
+                else
+                        idleTime = 	(0xffffffff - ttl) + now;
+
+
+                if (sstByAid[i]->bValid) {
+                        if (idleTime > IDLE_TIMEOUT ) {
+                                HSDEBUG("*****Age one*****");
+                                HSDEBUG_V("aid", i);
+                                HSDEBUG_V("now", now);
+                                HSDEBUG_V("ttl", ttl);
+                                HSDEBUG_V("idleTime", idleTime);
+
+                                pMac = (MacAddr_t *)&sstByAid[i]->mac[0];
+                                entry = GetEntry(pMac);
+                                HSDEBUG_V("entry", entry);
+                                hash = HashTbl[entry];
+                                firstLayer = 1;
+                                do {
+                                        if (hash == sstByAid[i]) {
+                                                if (firstLayer == 1) {
+                                                        HSDEBUG("*****firstLayer*****");
+                                                        if (hash->pNext != NULL)
+                                                                HashTbl[entry] = hash->pNext;
+                                                        else
+                                                                HashTbl[entry] = NULL;
+                                                } else {
+                                                        HSDEBUG("*****Not firstLayer*****");
+                                                        preHash->pNext = hash->pNext;
+                                                }
+                                                zd_CmdProcess(CMD_DISASOC, &hash->mac[0], ZD_INACTIVITY);
+                                                freeHashBuf(hash);
+                                                break;
+                                        } else {
+                                                preHash = hash;
+                                                hash = hash->pNext;
+                                                firstLayer = 0;
+                                        }
+                                } while(hash != NULL);
+                                ret = TRUE;
+                        } else {
+                                if (sstByAid[i]->ZydasMode == 1)
+                                        mZyDasModeClient = TRUE;
+
+                                if (sstByAid[i]->bErpSta == FALSE && mMacMode != PURE_A_MODE) {
+                                        pdot11Obj->ConfigFlag |= NON_ERP_PRESENT_SET;
+                                        pdot11Obj->ConfigFlag |= ENABLE_PROTECTION_SET;
+                                        if (sstByAid[i]->Preamble == 0) { //long preamble
+                                                pdot11Obj->ConfigFlag |= BARKER_PREAMBLE_SET;
+                                        }
+                                }
+                        }
+                }
+
+        }
+
+        //HSDEBUG_V("ret", ret);
+        return ret;
+}
+
+
+void ResetPSMonitor(void)
+{
+        ZDEBUG("ResetPSMonitor");
+        initHashBuf();
+        InitHashTbl();
+        mPsStaCnt = 0;
+}
+
+
+Hash_t *RxInfoIndicate(MacAddr_t *sta, PsMode psm, U8 rate)
+{
+        Hash_t *pHash;
+
+        ZDEBUG("RxInfoIndicate");
+
+        //if (isGroup(sta))
+        //return NULL;
+
+        pHash = HashSearch(sta);
+        if (!pHash) {
+                if (mBssType == PSEUDO_IBSS) {
+                        pHash = HashInsert(sta);
+                        if (!pHash)
+                                return NULL;
+                        else {
+                                pHash->asoc = STATION_STATE_ASOC;
+                                zd1205_dump_data(" HashInsert macAddr = ", (U8 *)&pHash->mac[0], 6);
+                                goto updateInfo;
+                        }
+                } else
+                        return NULL;
+        } else {
+updateInfo:
+                if (rate > pHash->MaxRate)
+                        pHash->MaxRate = rate;
+
+                pHash->RxRate = rate;
+                pHash->ttl = HW_GetNow(pdot11Obj);
+
+                if (mBssType == AP_BSS) {
+                        PsMode oldPsm = pHash->psm;
+                        StationState asoc = pHash->asoc;
+
+                        if (psm == PSMODE_STA_ACTIVE) {
+                                if (oldPsm == PSMODE_POWER_SAVE) {
+                                        StaWakeup(sta);
+                                        if (asoc == STATION_STATE_ASOC) {
+                                                if (mPsStaCnt >0) {
+                                                        mPsStaCnt--;
+                                                }
+                                        }
+                                }
+                        } else {
+                                if (oldPsm == PSMODE_STA_ACTIVE) {
+                                        if (asoc == STATION_STATE_ASOC) {
+                                                if (mPsStaCnt < MAX_AID) {
+                                                        mPsStaCnt++;
+                                                }
+                                        }
+                                } else if (oldPsm == PSMODE_POWER_SAVE) {
+                                        if (asoc == STATION_STATE_ASOC) {
+                                                if (mPsStaCnt == 0)
+                                                        mPsStaCnt++;
+                                        }
+                                }
+                        }
+                }
+
+                pHash->psm = psm;
+        }
+
+        return pHash;
+}
+
+
+void RxInfoUpdate(Hash_t *pHash, PsMode psm, U8 rate)
+{
+        PsMode oldPsm = pHash->psm;
+        StationState asoc = pHash->asoc;
+
+        if (rate > pHash->MaxRate)
+                pHash->MaxRate = rate;
+
+        pHash->RxRate = rate;
+        pHash->ttl = HW_GetNow(pdot11Obj);
+
+        if (psm == PSMODE_STA_ACTIVE) {
+                if (oldPsm == PSMODE_POWER_SAVE) {
+                        StaWakeup((MacAddr_t *)pHash->mac);
+                        if (asoc == STATION_STATE_ASOC) {
+                                if (mPsStaCnt >0) {
+                                        mPsStaCnt--;
+                                }
+                        }
+                }
+        } else {
+                if (oldPsm == PSMODE_STA_ACTIVE) {
+                        if (asoc == STATION_STATE_ASOC) {
+                                if (mPsStaCnt < MAX_AID) {
+                                        mPsStaCnt++;
+                                }
+                        }
+                } else if (oldPsm == PSMODE_POWER_SAVE) {
+                        if (asoc == STATION_STATE_ASOC) {
+                                if (mPsStaCnt == 0)
+                                        mPsStaCnt++;
+                        }
+
+                }
+        }
+
+
+        pHash->psm = psm;
+}
+
+
+BOOLEAN UpdateStaStatus(MacAddr_t *sta, StationState staSte, U8 vapId)
+{
+        Hash_t *pHash;
+
+        ZDEBUG("UpdateStaStatus");
+
+        if (mBssType == AP_BSS) {
+                pHash = HashSearch(sta);
+                if (pHash)
+                        goto UpdateStatus;
+                else {
+                        if ((STATION_STATE_AUTH_OPEN == staSte) || (STATION_STATE_AUTH_KEY == staSte)) {
+                                if ((mCurrConnUser + 1) > mLimitedUser) {
+                                        //AgeHashTbl();
+                                        return FALSE;
+                                } else {
+                                        pHash = HashInsert(sta);
+                                        if (!pHash)
+                                                return FALSE;
+                                }
+                        } else
+                                return FALSE;
+                }
+        } else if (mBssType == INFRASTRUCTURE_BSS) {
+                if ((STATION_STATE_AUTH_OPEN == staSte) || (STATION_STATE_AUTH_KEY == staSte)) {
+                        CleanupHash(sstByAid[0]);
+                        pHash = HashInsert(sta);
+                } else {
+                        pHash = sstByAid[0]; //use aid = 0 to store AP's info
+                }
+        } else if (mBssType == INDEPENDENT_BSS) {
+                pHash = HashSearch(sta);
+                if (pHash)
+                        goto UpdateStatus;
+                else {
+                        pHash = HashInsert(sta);
+                        if (!pHash)
+                                return FALSE;
+                        else
+                                zd1205_dump_data(" HashInsert macAddr = ", (U8 *)&pHash->mac[0], 6);
+                }
+        } else
+                return FALSE;
+
+UpdateStatus:
+        switch(staSte) {
+        case STATION_STATE_AUTH_OPEN:
+        case STATION_STATE_AUTH_KEY:
+                pHash->auth = staSte;
+                break;
+
+        case STATION_STATE_ASOC:
+                if (mBssType == AP_BSS) {
+                        if (((mCurrConnUser + 1) > mLimitedUser) && (!pHash->AlreadyIn)) {
+                                return FALSE;
+                        }
+
+                        if (pHash->psm == PSMODE_POWER_SAVE) {
+                                if (mPsStaCnt > 0) {
+                                        mPsStaCnt--;
+                                }
+
+                        }
+
+                        pHash->asoc = STATION_STATE_ASOC;
+                        /*if (!pHash->AlreadyIn){
+                        	pHash->AlreadyIn = 1;
+                        	mCurrConnUser++;
+                        }*/
+                } else {
+                        pHash->asoc = STATION_STATE_ASOC;
+                }
+
+                if (mBssType != INDEPENDENT_BSS)
+                        CleanupKeyInfo(pHash);
+
+                memcpy(&pdot11Obj->CurrSsid[0], (U8 *)&mSsid, mSsid.buf[1]+2);
+                break;
+
+        case STATION_STATE_NOT_AUTH:
+        case STATION_STATE_DIS_ASOC:
+                if (mBssType == AP_BSS) {
+                        if (pHash->asoc == STATION_STATE_ASOC) {
+                                if (pHash->psm == PSMODE_POWER_SAVE) {
+                                        FlushQ(pPsQ[pHash->aid]);
+                                        if (mPsStaCnt > 0) {
+                                                mPsStaCnt--;
+                                                if (mPsStaCnt == 0) {
+                                                        FlushQ(pAwakeQ);
+                                                        FlushQ(pPsQ[0]);
+                                                }
+                                        }
+                                }
+                                /*if (pHash->AlreadyIn){
+                                	pHash->AlreadyIn = 0;
+                                	mCurrConnUser--;	
+                                }*/
+                        }
+                }
+
+                pHash->auth = STATION_STATE_NOT_AUTH;
+                pHash->asoc = STATION_STATE_DIS_ASOC;
+                CleanupKeyInfo(pHash);
+                //for Rx-Retry filter
+                HW_CAM_ClearRollTbl(pdot11Obj, pHash->aid);
+                {
+                        MacAddr_t	*pMac;
+                        Hash_t 		*sta_info;
+                        U8 			entry;
+                        pMac = (MacAddr_t *) pHash->mac;
+                        entry = GetEntry(pMac);
+                        sta_info=HashTbl[entry];
+                        if (sta_info) {
+                                if (memcmp(sta_info->mac, pHash->mac, 6)==0) {
+                                        HashTbl[entry]=sta_info->pNext;
+                                        freeHashBuf(pHash);
+                                } else {
+                                        while (sta_info->pNext != NULL && memcmp(sta_info->pNext->mac, pHash->mac, 6) != 0)
+                                                sta_info = sta_info->pNext;
+                                        if (sta_info->pNext != NULL) {
+                                                Hash_t	*sta_info1;
+                                                sta_info1 = sta_info->pNext;
+                                                sta_info->pNext =  sta_info->pNext->pNext;
+                                                freeHashBuf(sta_info1);
+                                        } else {
+                                                printk(KERN_DEBUG "Could not remove STA:" MACSTR "\n", MAC2STR(pHash->mac));
+                                        }
+                                }
+                        }
+                }
+
+                break;
+
+        }
+
+        return TRUE;
+}
+
+
+void SsInquiry(MacAddr_t *sta, StationState *sst, StationState *asst)
+{
+        ZDEBUG("SsInquiry");
+        if (isGroup(sta)) {
+                *asst = STATION_STATE_NOT_AUTH;
+                *sst = STATION_STATE_DIS_ASOC;
+        } else {
+                Hash_t *pHash;
+                pHash = HashSearch(sta);
+
+                if (!pHash) {
+                        *asst = STATION_STATE_NOT_AUTH;
+                        *sst = STATION_STATE_DIS_ASOC;
+                } else {
+                        *asst = pHash->auth;
+                        if ((*asst == STATION_STATE_AUTH_OPEN) || (*asst == STATION_STATE_AUTH_KEY))
+                                *sst = pHash->asoc;
+                        else
+                                *sst = STATION_STATE_DIS_ASOC;
+                }
+        }
+
+}
+
+
+U16 AIdLookup(MacAddr_t *sta)
+{
+        Hash_t *pHash;
+
+        ZDEBUG("AIdLookup");
+        pHash = HashSearch(sta);
+        if (!pHash)
+                return (U16)0;
+        else
+                return pHash->aid;
+}
+
+
+void AssocInfoUpdate(MacAddr_t *sta, U8 MaxRate, U8 lsInterval, U8 ZydasMode, U8 Preamble, BOOLEAN bErpSta, U8 vapId)
+{
+        Hash_t *pHash;
+
+        ZDEBUG("AssocInfoUpdate");
+        if (isGroup(sta))
+                return;
+
+        pHash = HashSearch(sta);
+        if (!pHash)
+                return;
+        else {
+                pHash->MaxRate = MaxRate;
+                pHash->CurrTxRate = MaxRate;
+                pHash->lsInterval = lsInterval;
+                pHash->ZydasMode = ZydasMode;
+                pHash->Preamble = Preamble;
+                pHash->bErpSta = bErpSta;
+                pHash->vapId = vapId;
+        }
+}
+
+int zd_SetKeyInfo(U8 *addr, U8 encryMode, U8 keyLength, U8 KeyId, U8 *pKeyContent)
+{
+        Hash_t *pHash;
+        MacAddr_t *sta = (MacAddr_t *)addr;
+        U8 bcAddr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+        U8 ZeroAddr[6]={0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+        U16 aid;
+        U8 change_enc = 0;
+
+        if (isGroup(sta)) {
+                change_enc = 1;
+                if (keyLength == 0) {
+                        WPADEBUG("Clear Group key RollTbl (aid0)\n");
+                        HW_CAM_ClearRollTbl(pdot11Obj, 0);//Clear group key.(aid0)
+                } else if (encryMode == WEP64 || encryMode == WEP128) {
+
+                        if (mWpaBcKeyLen == keyLength && mGkInstalled == 1)
+                                change_enc = 0; // Nonfirst time group key update.
+                        mWpaBcKeyLen = keyLength;
+                        mBcKeyId = KeyId;// We tell KeyLength to hdwr by encryMode, while, the key ID is set by the driver when transmit packet.
+
+                        if (mOperationMode != CAM_AP_VAP) {
+                                HW_ConfigDynaKey(pdot11Obj, 32, &bcAddr[0], pKeyContent, keyLength, encryMode, change_enc);
+                                // Also set default key for Multicast case to avoid Tx-underrun.
+                                HW_CAM_Write(pdot11Obj, DEFAULT_ENCRY_TYPE, encryMode);
+                                HW_ConfigStatKey(pdot11Obj, pKeyContent, keyLength, STA_KEY_START_ADDR+(KeyId * 8));
+                        } else
+                                HW_ConfigDynaKey(pdot11Obj, CAM_VAP_START_AID, (U8 *)&dot11MacAddress, pKeyContent, keyLength, encryMode,change_enc);
+
+                        mGkInstalled = 1;
+                        return 0;
+                } else if (encryMode == TKIP) {
+                        //only vaild for Tx
+                        if (mWpaBcKeyLen == keyLength && mGkInstalled==1)//Non-First time group key update.
+                                change_enc = 0;
+
+                        mWpaBcKeyLen = keyLength;
+                        mWpaBcKeyId = KeyId;
+                        if (mWpaBcKeyLen == 32) {
+                                if (mOperationMode != CAM_AP_VAP) {
+                                        //Tmep key(16), Tx Mic Key(8), Rx Mic Key(8)
+                                        HW_ConfigDynaKey(pdot11Obj, 32, &bcAddr[0], pKeyContent, keyLength, encryMode, change_enc);
+                                        // Also set default key for Multicast case to avoid Tx-underrun.
+                                        //if ((mDebugFlag & BIT_1)==0)
+                                        {
+                                                HW_CAM_Write(pdot11Obj, DEFAULT_ENCRY_TYPE, encryMode);
+                                                HW_ConfigStatKey(pdot11Obj, pKeyContent, keyLength, STA_KEY_START_ADDR+(KeyId * 8));
+                                        }
+                                } else {
+                                        HW_ConfigDynaKey(pdot11Obj, CAM_VAP_START_AID, (U8 *)&dot11MacAddress, pKeyContent, keyLength, encryMode, change_enc);
+                                }
+                                if (mBssType == INFRASTRUCTURE_BSS)
+                                        MICsetKey(&pKeyContent[24], &mBcMicKey); //Tx Mic key
+                                else
+                                        MICsetKey(&pKeyContent[16], &mBcMicKey);// For Infra-STA mode.
+                        }
+                        mGkInstalled = 1;
+                        return 0;
+                } else if (encryMode == AES) {
+                        if (mWpaBcKeyLen == keyLength && mGkInstalled == 1)//Non-First time group key update.
+                                change_enc = 0;
+                        mWpaBcKeyLen = keyLength;
+                        mWpaBcKeyId = KeyId;
+                        if (mWpaBcKeyLen == 16) {
+                                if (mOperationMode != CAM_AP_VAP) {
+                                        HW_ConfigDynaKey(pdot11Obj, 32, &bcAddr[0], pKeyContent, keyLength, encryMode, change_enc);
+                                        // Also set default key for Multicast case to avoid Tx-underrun.
+                                        HW_CAM_Write(pdot11Obj, DEFAULT_ENCRY_TYPE, encryMode);
+                                        HW_ConfigStatKey(pdot11Obj, pKeyContent, keyLength, STA_KEY_START_ADDR+(KeyId * 8));
+                                } else {
+                                        HW_ConfigDynaKey(pdot11Obj, CAM_VAP_START_AID, (U8 *)&dot11MacAddress, pKeyContent, keyLength, encryMode, change_enc);
+                                }
+                        }
+                        mGkInstalled = 1;
+                        return 0;
+                } else {
+                        return -1;
+                }
+        }// End of Group key setting.
+
+        // Start of Pairwise key setting.
+        pHash = HashSearch(sta);
+        if (!pHash) {
+                if (!memcmp(&sta->mac[0], ZeroAddr, 6)) {
+                        int i;
+                        HW_CAM_ResetRollTbl(pdot11Obj);
+                        if (mGkInstalled) {
+                                HW_CAM_UpdateRollTbl(pdot11Obj,0);//ReEnable group key.
+                        }
+                        if (mBssType != INFRASTRUCTURE_BSS) {//AP mode.
+                                WPADEBUG("clear all tx key\n");
+                                for (i=0; i<MAX_RECORD; i++)
+                                        HashBuf[i].pkInstalled=0;
+                        } else {// STA mode.
+                                WPADEBUG("clear key of aid %d\n",sstByAid[0]->aid);
+                                sstByAid[0]->pkInstalled=0;
+                        }
+                }
+                return -1;
+        } else {
+                pHash->keyLength = keyLength;
+                if (pHash->encryMode != encryMode)
+                        change_enc = 1;
+                pHash->encryMode = encryMode;
+                aid = pHash->aid;
+
+                if (encryMode != NO_WEP)
+                        WPADEBUG("********* Set key%s for aid:%d\n",DbgStrEncryType[encryMode & 7],aid);
+                else
+                        WPADEBUG("********* Clear key for aid:%d\n",aid);
+                if (encryMode == NO_WEP) {// Clear pairwise key
+                        pHash->pkInstalled = 0;
+                        if (mBssType == INFRASTRUCTURE_BSS)
+                                HW_CAM_ClearRollTbl(pdot11Obj, 8);
+                        else
+                                HW_CAM_ClearRollTbl(pdot11Obj, aid);
+                } else if (encryMode == TKIP) {
+                        if (mBssType == INFRASTRUCTURE_BSS) {
+                                //				zd1205_dump_data("key:", (u8*)pKeyContent, 32);
+                                HW_ConfigDynaKey(pdot11Obj, 8, addr, pKeyContent, 32, encryMode, change_enc);
+                        } else
+                                HW_ConfigDynaKey(pdot11Obj, aid, addr, pKeyContent, 32, encryMode, change_enc);
+
+                        MICsetKey(&pKeyContent[16], &pHash->TxMicKey);
+                        MICsetKey(&pKeyContent[24], &pHash->RxMicKey);
+                        pHash->KeyId = KeyId;
+                        pHash->pkInstalled = 1;
+                } else //if (encryMode == AES)
+                {
+                        if (mBssType == INFRASTRUCTURE_BSS) {
+                                WPADEBUG("********* setAESkey\n");
+                                HW_ConfigDynaKey(pdot11Obj, 8, addr, pKeyContent, keyLength, encryMode, change_enc);
+                        } else
+                                HW_ConfigDynaKey(pdot11Obj, aid, addr, pKeyContent, keyLength, encryMode, change_enc);
+                        pHash->KeyId = KeyId;
+                        pHash->pkInstalled = 1;
+                }
+                return 0;
+        }
+}
+
+BOOLEAN zd_GetKeyInfo(U8 *addr, U8 *encryMode, U8 *keyLength, U8 *pKeyContent)
+{
+        Hash_t *pHash;
+        MacAddr_t *sta = (MacAddr_t *)addr;
+
+        ZDEBUG("zd_GetKeyInfo");
+        if (isGroup(sta)) {
+                return FALSE;
+        }
+
+        pHash = HashSearch(sta);
+        if (!pHash) {
+                *encryMode = 0;
+                *keyLength = 0;
+                return FALSE;
+        } else {
+                *encryMode = pHash->encryMode;
+                *keyLength = pHash->keyLength;
+                memcpy(pKeyContent, &pHash->keyContent[0], pHash->keyLength);
+                return TRUE;
+        }
+}
+
+/**
+ * zd_SetKeyContext - Set Key context to CAM (used for WPA/WPA2)
+ * @addr: MAC address of AP we associated with
+ * @encryMode: Encryption mode
+ * @keyLength: Length of key context
+ * @keyId: Key index
+ * @pKeyContent: Context of key
+ */
+#if 0
+
+int zd_SetKeyContext(U8 *addr, U8 encryMode, U8 keyLength, U8 KeyId, U8 *pKeyContent)
+{
+        Hash_t *pHash;
+
+        if (isGroup(addr)) {
+                mWpaBcKeyLen = keyLength;
+                mWpaBcKeyId = KeyId;
+
+                if (encryMode == DYN_KEY_TKIP) {
+                        if (keyLength == 32) {
+                                zd1205_config_dyn_key(encryMode, pKeyContent, KeyId);
+                                MICsetKey(&pKeyContent[24], &mBcMicKey);
+                        }
+
+                        mGkInstalled = 1;
+                        return 0;
+                } else if (encryMode == DYN_KEY_AES) {
+                        printk(KERN_ERR "***** set group key ID: %d\n",KeyId);
+                        zd1205_config_dyn_key(encryMode, pKeyContent, KeyId);
+                        mGkInstalled = 1;
+                        return 0;
+                } else {
+                        WPADEBUG("zd_SetKeyContext: encryMode: %d not support\n", encryMode);
+                        return -1;
+                }
+
+        }
+
+        pHash = HashSearch((MacAddr_t*)addr);
+
+        if(!pHash) {
+                WPADEBUG("Can't find AP's MAC address in the hash table\n");
+                return -1;
+        } else {
+                pHash->encryMode = encryMode;
+
+                if (encryMode == DYN_KEY_TKIP) {
+                        zd1205_config_dyn_key(encryMode, pKeyContent, KeyId);
+
+                        MICsetKey(&pKeyContent[16], &pHash->TxMicKey);
+                        MICsetKey(&pKeyContent[24], &pHash->RxMicKey);
+                        pHash->KeyId = KeyId;
+                        pHash->pkInstalled = 1;
+                } else if (encryMode == DYN_KEY_AES) {
+                        zd1205_config_dyn_key(encryMode, pKeyContent, KeyId);
+                        pHash->KeyId = KeyId;
+                        pHash->pkInstalled = 1;
+                }
+                else {
+                        WPADEBUG("zd_SetKeyContext: encryMode: %d not support\n", encryMode);
+                }
+        }
+
+        return 0;
+}
+#endif
+
+#if defined(PHY_1202)
+int zd_GetKeyInfo_ext(U8 *addr, U8 *encryMode, U8 *keyLength, U8 *pKeyContent, U16 iv16, U32 iv32)
+{
+        Hash_t *pHash;
+        MacAddr_t *sta = (MacAddr_t *)addr;
+
+        ZDEBUG("zd_GetKeyInfo_ext");
+        if (isGroup(sta)) {
+                return -1;
+        }
+
+        if (mDynKeyMode != DYN_KEY_TKIP)
+                return -1;
+
+        pHash = HashSearch(sta);
+        if (!pHash) {
+                *encryMode = 0;
+                *keyLength = 0;
+                return -1;
+        } else {
+                if (pHash->pkInstalled == 0)
+                        return -2;
+
+                if ((iv16 == pHash->RxSeed.IV16) && (iv32 == pHash->RxSeed.IV32)) {
+                        // iv out of sequence
+                        //FPRINT_V("iv16", iv16);
+                        //FPRINT_V("iv32", iv32);
+                        //return -3;
+                }
+
+                *encryMode = pHash->encryMode;
+                *keyLength = pHash->keyLength;
+                //do key mixing
+                Tkip_phase1_key_mix(iv32, &pHash->RxSeed);
+                Tkip_phase2_key_mix(iv16, &pHash->RxSeed);
+                Tkip_getseeds(iv16, pKeyContent, &pHash->RxSeed);
+                pHash->RxSeed.IV16 = iv16;
+                pHash->RxSeed.IV32 = iv32;
+                return pHash->aid;
+        }
+}
+
+
+int zd_SetTsc(U8 *addr, U8 KeyId, U8 direction, U32 tscHigh, U16 tscLow)
+{
+        Hash_t *pHash;
+        MacAddr_t *sta = (MacAddr_t *)addr;
+
+        ZDEBUG("zd_SetTsc");
+        if (isGroup(sta)) {
+                return -1;
+        }
+
+        pHash = HashSearch(sta);
+        if (!pHash)
+                return -1;
+        else {
+                pHash->KeyId = KeyId;
+                if (direction == 0) { //Tx
+                        pHash->TxSeed.IV16 = tscLow;
+                        pHash->TxSeed.IV32 = tscHigh;
+                } else if (direction == 1) { //Rx
+                        pHash->RxSeed.IV16 = tscLow;
+                        pHash->RxSeed.IV32 = tscHigh;
+                }
+                return 0;
+        }
+}
+
+
+int zd_GetTsc(U8 *addr, U8 KeyId, U8 direction, U32 *tscHigh, U16 *tscLow)
+{
+        Hash_t *pHash;
+        MacAddr_t *sta = (MacAddr_t *)addr;
+
+        ZDEBUG("zd_GetTsc");
+        if (isGroup(sta)) {
+                return -1;
+        }
+
+        pHash = HashSearch(sta);
+        if (!pHash)
+                return -1;
+        else {
+                if (direction == 0) { //Tx
+                        *tscLow = pHash->TxSeed.IV16;
+                        *tscHigh = pHash->TxSeed.IV32;
+                } else if (direction == 1) { //Rx
+                        *tscLow = pHash->RxSeed.IV16;
+                        *tscHigh = pHash->RxSeed.IV32;
+                }
+                return 0;
+        }
+}
+#endif
+
+
+BOOLEAN zd_CheckIvSeq(U8 aid, U16 iv16, U32 iv32)
+{
+        Hash_t *pHash = NULL;
+        U16 oldIv16;
+        U32 oldIv32;
+
+
+        ZDEBUG("zd_CheckIvSeq");
+
+        if (mDynKeyMode != DYN_KEY_TKIP) {
+                FPRINT("Not in DYN_KEY_TKIP mode");
+                return FALSE;
+        }
+
+        pHash = sstByAid[aid];
+        if (!pHash) {
+                FPRINT("zd_CheckIvSeq failed");
+                return FALSE;
+        } else {
+                if (pHash->pkInstalled == 0) {
+                        FPRINT("pkInstalled == 0");
+                        return FALSE;
+                }
+
+                oldIv16 = pHash->RxSeed.IV16;
+                oldIv32 = pHash->RxSeed.IV32;
+
+#if 1
+
+                if ((oldIv16 == iv16) && (oldIv32 == iv32)) {
+                        // iv out of sequence
+                        FPRINT("iv out of sequence");
+                        FPRINT_V("iv16", iv16);
+                        FPRINT_V("iv32", iv32);
+                        return FALSE;
+                }
+
+#else //If fifo overrun, this will failed
+                if (iv32 == oldIv32) {
+                        if (iv16 != oldIv16+1) {
+                                // iv out of sequence
+                                FPRINT("iv out of sequence");
+                                FPRINT_V("iv16", iv16);
+                                FPRINT_V("iv32", iv32);
+                                return FALSE;
+                        }
+                } else {
+                        if ((iv16 != 0) || (oldIv16 != 0xffff)) {
+                                // iv out of sequence
+                                FPRINT("iv out of sequence");
+                                FPRINT_V("iv16", iv16);
+                                FPRINT_V("iv32", iv32);
+                                return FALSE;
+                        }
+                }
+#endif
+
+                pHash->RxSeed.IV16 = iv16;
+                pHash->RxSeed.IV32 = iv32;
+                return TRUE;
+        }
+}
+
+
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdpsmon.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdpsmon.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdpsmon.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdpsmon.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,21 @@
+#ifndef _ZDPSMON_H_
+#define _ZDPSMON_H_
+
+
+void ResetPSMonitor(void);
+void SsInquiry(MacAddr_t *sta, StationState *sst, StationState *asst);
+void AssocInfoUpdate(MacAddr_t *sta, U8 MaxRate, U8 lsInterval, U8 ZydasMode, U8 Preamble, BOOLEAN bErpSta, U8 vapId);
+U16 AIdLookup(MacAddr_t *sta);
+BOOLEAN AgeHashTbl(void);
+BOOLEAN UpdateStaStatus(MacAddr_t *sta, StationState staSte,  U8 vapId);
+int zd_SetKeyInfo(U8 *addr, U8 encryMode, U8 keyLength, U8 KeyId, U8 *pKeyContent);
+int zd_SetKeyContext(U8 *addr, U8 encryMode, U8 keyLength, U8 KeyId, U8 *pKeyContent);
+Hash_t *HashSearch(MacAddr_t *pMac);
+Hash_t *RxInfoIndicate(MacAddr_t *sta, PsMode psm, U8 rate);
+void RxInfoUpdate(Hash_t *pHash, PsMode psm, U8 rate);
+extern Hash_t *HashTbl[MAX_RECORD];
+extern Hash_t *sstByAid[MAX_RECORD];
+void initHashBuf(void);
+void InitHashTbl(void);
+void CleanupHash(Hash_t *hash);
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdshared.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdshared.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdshared.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdshared.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,773 @@
+#ifndef __ZDSHARED_C__
+#define __ZDSHARED_C__
+
+#include "zd80211.h"
+#include "zddebug.h"
+#include "zd1205.h"
+extern struct net_device *g_dev;
+
+void mkFragment(Signal_t *signal, FrmDesc_t *pfrmDesc, U8 *pEthHdr)
+{
+        struct zd1205_private *macp=g_dev->priv;
+        Frame_t *mpdu, *curMpdu;
+        FrmInfo_t *pfrmInfo;
+        BOOLEAN bWep;
+        U16 pdusize;
+        U8 *pBody;
+        U16 len;
+        U8 fn;
+        U8 *pByte;
+        int i;
+        Hash_t *pHash;
+        MICvar *pTxMicKey = NULL;
+        U8 KeyInstalled = 0;
+        U8 vapId = 0;
+        U8 Num;
+        U8 bDataFrm = signal->bDataFrm;
+        //U8 bDataFrm = pfrmDesc->bDataFrm;
+        U16 HdrLen;
+
+        ZDEBUG("mkFragment");
+        pfrmDesc->CalMIC[MIC_LNG]=FALSE;
+        pfrmInfo = &signal->frmInfo;
+        pfrmInfo->frmDesc = pfrmDesc; //make connection for signal and frmDesc
+        //PSDEBUG_V("mkFrag pfrmDesc", (U32)pfrmInfo->frmDesc);
+        mpdu = pfrmDesc->mpdu;
+        vapId = signal->vapId;
+#if 0
+
+        if (mDynKeyMode == DYN_KEY_TKIP || mDynKeyMode == DYN_KEY_AES) {
+                if (bDataFrm) {
+                        if (isGroup(addr1(mpdu))) {
+                                KeyInstalled = mGkInstalled;
+
+                                if (mDynKeyMode == DYN_KEY_TKIP) {
+                                        pTxMicKey = &mBcMicKey;
+                                        if (mWpaBcKeyLen != 32) // Not TKIP, don't make MIC
+                                                KeyInstalled = 0;
+                                }
+                        } else { //unicast
+                                pHash = HashSearch(addr1(mpdu));
+                                if (!pHash) {
+                                        FPRINT("HashSearch2 failed !!!");
+                                        zd1205_dump_data("addr1 = ", (U8 *)addr1(mpdu), 6);
+                                        KeyInstalled = 0;
+                                } else {
+                                        if (mDynKeyMode == DYN_KEY_TKIP)
+                                                pTxMicKey = &pHash->TxMicKey;
+                                        KeyInstalled = pHash->pkInstalled;
+                                }
+                        }
+
+                        if ((KeyInstalled) && (mDynKeyMode == DYN_KEY_TKIP)) {
+#endif
+                                // The following section is used for TKIP-MIC append.
+                                if (bDataFrm) {
+                                        if (macp->cardSetting.WPAIeLen) // WPA is supported for now.
+                                        {
+                                                if (isGroup(addr1(mpdu)))
+                                                {// Prepare to send the BC/MC packet.
+                                                        KeyInstalled=mGkInstalled;
+                                                        if (KeyInstalled) {
+                                                                if(mWpaBcKeyLen == 32)
+                                                                        pTxMicKey = &mBcMicKey;
+                                                        } else
+                                                                FPRINT("MkFrag: No Group key installed\n");
+                                                } else
+                                                {// Prepare to send the UC packet.
+                                                        pHash = HashSearch(addr1(mpdu));
+                                                        KeyInstalled=pHash->pkInstalled;
+                                                        if (!pHash) {
+                                                                FPRINT("HashSearch2 failed !!!");
+                                                                zd1205_dump_data("addr1 = ", (U8 *)addr1(mpdu), 6);
+                                                        } else if(KeyInstalled) {
+                                                                //if (pHash->keyLength==32)
+                                                                if (pHash->encryMode == TKIP)
+                                                                        pTxMicKey = &pHash->TxMicKey;
+                                                        } else {
+                                                                FPRINT("MkFrag: Can't find Pairwise key\n");
+                                                        }
+                                                }
+
+                                                if (pTxMicKey != NULL)
+                                                { // This section is used for TKIP-MIC append.
+
+                                                        U16 len = mpdu->bodyLen;
+
+                                                        // calculate and append MIC to payload before fragmentation
+                                                        MICclear(pTxMicKey);
+
+
+                                                        if(mBssType == AP_BSS || mBssType==INDEPENDENT_BSS)
+                                                                pByte = &mpdu->header[4]; //DA=Addr1
+                                                        else //if (mBssType == INFRASTRUCTURE_BSS)
+                                                                pByte = &mpdu->header[16];//DA=Addr3
+                                                        for(i=0; i<6; i++) { //for DA
+                                                                MICappendByte(*pByte++, pTxMicKey);
+                                                        }
+
+                                                        if(mBssType == INFRASTRUCTURE_BSS || mBssType==INDEPENDENT_BSS)
+                                                                pByte = &mpdu->header[10]; //SA=Addr2
+                                                        else //if (mBssType == AP_BSS)
+                                                                pByte = &mpdu->header[16];
+                                                        for(i=0; i<6; i++) { //for SA
+                                                                MICappendByte(*pByte++, pTxMicKey);
+                                                        }
+
+                                                        MICappendByte(0, pTxMicKey);
+                                                        MICappendByte(0, pTxMicKey);
+                                                        MICappendByte(0, pTxMicKey);
+                                                        MICappendByte(0, pTxMicKey);
+
+                                                        pByte = mpdu->body;
+                                                        for (i=0; i<len; i++) {
+                                                                MICappendByte(*pByte++, pTxMicKey);
+                                                        }
+                                                        MICgetMIC(pfrmDesc->CalMIC, pTxMicKey);
+                                                        pfrmDesc->CalMIC[MIC_LNG]=TRUE;
+                                                        //zd1205_dump_data("add sw mic:",(u8*)pfrmDesc->CalMIC, 8);
+                                                        mpdu->bodyLen += MIC_LNG;
+                                                }
+                                        }
+                                }
+
+                                bWep = mPrivacyInvoked;
+                                if ((!bDataFrm) && (!(pfrmDesc->ConfigSet & FORCE_WEP_SET))) {
+                                        bWep = FALSE;
+                                } else {
+                                        if (pfrmDesc->ConfigSet & EAPOL_FRAME_SET)
+                                                bWep = FALSE;
+                                }
+
+                                if (KeyInstalled) // After pairwise key installed, even Eapol frame need to be encrypted
+                                {
+                                        bWep = TRUE;
+                                } else {
+                                        if (bDataFrm && !mKeyFormat && bWep) {
+                                                printk(KERN_DEBUG "chkpnt 001\n");
+                                                bWep = FALSE;
+                                        }
+                                }
+
+                                pfrmInfo->eol = 0;
+
+                                pdusize = mFragThreshold;
+                                if ((!isGroup(addr1(mpdu))) && (mpdu->HdrLen + mpdu->bodyLen + CRC_LNG > pdusize)) { //Need fragment
+                                        pdusize -= mpdu->HdrLen + CRC_LNG;
+                                        pfrmInfo->fTot = (mpdu->bodyLen + (pdusize-1)) / pdusize;
+                                        if (pfrmInfo->fTot == 0)
+                                                pfrmInfo->fTot = 1;
+                                } else {
+                                        pdusize = mpdu->bodyLen;
+                                        pfrmInfo->fTot = 1;
+                                }
+
+                                curMpdu = mpdu;
+                                pBody = mpdu->body;
+                                len = mpdu->bodyLen;
+                                Num = pfrmInfo->fTot;
+                                HdrLen = mpdu->HdrLen;
+
+                                for (fn=0; fn<Num; fn++) {
+                                        if (fn) {
+                                                curMpdu = &pfrmDesc->mpdu[fn];
+                                                memcpy(&curMpdu->header[0], &mpdu->header[0], HdrLen); //make header
+                                                curMpdu->HdrLen = HdrLen;
+                                                curMpdu->body = pBody;
+                                        }
+                                        curMpdu->header[22] = ((curMpdu->header[22] & 0xF0) | fn);
+
+                                        if (fn == (Num - 1)) {
+                                                curMpdu->bodyLen = len;
+                                                curMpdu->header[1] &= ~MORE_FRAG_BIT;
+                                        } else {
+                                                curMpdu->bodyLen = pdusize;
+                                                pBody += pdusize;
+                                                len -= pdusize;
+                                                curMpdu->header[1] |= MORE_FRAG_BIT;
+                                        }
+
+                                        if (bWep)
+                                                curMpdu->header[1] |= WEP_BIT;
+                                }
+                        }
+
+
+                        BOOLEAN sendMgtFrame(Signal_t *signal, FrmDesc_t *pfrmDesc) {
+                                //	ZDEBUG("sendMgtFrame");
+                                pfrmDesc->ConfigSet &= ~INTRA_BSS_SET;
+                                pfrmDesc->ConfigSet &= ~EAPOL_FRAME_SET;
+                                pfrmDesc->pHash = NULL;
+                                pdot11Obj->ReleaseBuffer(signal->buf);
+                                signal->buf = NULL;
+                                signal->bDataFrm = 0;
+                                //pfrmDesc->bDataFrm = 0;
+                                mkFragment(signal, pfrmDesc, NULL);
+                                return SendPkt(signal, pfrmDesc, TRUE);
+                        }
+#if 0
+                        BOOLEAN	getElem(Frame_t	*frame, ElementID  eleID, Element  *elem) {
+                                U8 k = 0; 	//offset bytes to first element
+                                U8 n = 0; 	//num. of element
+
+
+                                U8 pos;		//current position
+                                U8 len;
+                                U8 max_len=34;
+                                switch (frmType(frame)) {
+                                case ST_PROBE_REQ:
+                                        k = 0;
+                                        n = 4;
+                                        if ((mDynKeyMode == DYN_KEY_TKIP) || (mDynKeyMode == DYN_KEY_AES))
+                                                n++;
+                                        break;
+
+                                case ST_ASOC_REQ:
+
+                                        k = 4;
+                                        n = 4;
+                                        if ((mDynKeyMode == DYN_KEY_TKIP) || (mDynKeyMode == DYN_KEY_AES))
+                                                n++;
+                                        break;
+
+                                case ST_REASOC_REQ:
+                                        k = 10;
+                                        n = 4;
+                                        if ((mDynKeyMode == DYN_KEY_TKIP) || (mDynKeyMode == DYN_KEY_AES))
+                                                n++;
+                                        break;
+
+                                case ST_AUTH:
+                                        k = 6;
+                                        n = 1;
+                                        max_len=130;
+                                        break;
+
+                                case ST_BEACON:
+                                case ST_PROBE_RSP:
+                                        k = 12;
+                                        n = 6;
+
+                                        if (mBssType == INDEPENDENT_BSS)
+                                                n++;
+                                        if ((mDynKeyMode == DYN_KEY_TKIP) || (mDynKeyMode == DYN_KEY_AES))
+                                                n++;
+                                        n++; //for country info
+                                        break;
+
+                                case ST_ASOC_RSP:
+                                case ST_REASOC_RSP:
+                                        k = 6;
+                                        n = 2;
+
+                                        if ((mDynKeyMode == DYN_KEY_TKIP) || (mDynKeyMode == DYN_KEY_AES))
+                                                n++;
+                                        break;
+
+                                default:
+                                        elem->buf[1] = 0;
+                                        return FALSE;
+                                }
+
+                                //while(n--){
+                                while(k < frame->bodyLen) {
+                                        pos = frame->body[k];
+                                        len = frame->body[k+1] + 2;
+
+                                        if ((pos == eleID) && (len <= max_len)) {	//match
+                                                if (eleID == EID_WPA) //Valid WPA IE
+                                                {
+                                                        if (len > 20)
+                                                        {
+                                                                memcpy((U8 *)elem, &frame->body[k], len);
+                                                                return TRUE;
+                                                        } else
+                                                                k += len;
+                                                } else {
+                                                        memcpy((U8 *)elem, &frame->body[k], len);
+                                                        return TRUE;
+                                                }
+                                        } else {
+                                                k += len;
+                                        }
+                                }
+
+                                elem->buf[1] = 0; //set element length to zero
+                                return FALSE;
+                        }
+#endif
+                        BOOLEAN	getElem(Frame_t	*frame, ElementID  eleID, Element  *elem) {
+                                U8 k = 0; 	//offset bytes to first element
+                                U8 pos;		//current position
+                                U8 len;
+                                U8 max_len = 130;
+
+                                switch (frmType(frame)) {
+                                case ST_PROBE_REQ:
+                                        k = 0;
+                                        break;
+
+                                case ST_ASOC_REQ:
+                                        k = 4;
+                                        break;
+
+                                case ST_REASOC_REQ:
+                                        k = 10;
+                                        break;
+
+                                case ST_AUTH:
+                                        k = 6;
+                                        break;
+
+                                case ST_BEACON:
+                                case ST_PROBE_RSP:
+                                        k = 12;
+                                        break;
+
+                                case ST_ASOC_RSP:
+                                case ST_REASOC_RSP:
+                                        k = 6;
+                                        break;
+
+                                default:
+                                        elem->buf[1] = 0;
+                                        return FALSE;
+                                }
+
+                                //jxiao
+                                while (k < frame->bodyLen) {
+                                        pos=frame->body[k];
+                                        len=frame->body[k+1]+2;
+                                        if ((pos==eleID) && (len <= max_len)) {
+                                                if (eleID == EID_WPA)//The WMM and WPA use the same Element ID.
+                                                {
+                                                        if (len > 20)
+                                                        {
+                                                                u8 WPA_OUI[4]={0x00, 0x50, 0xF2, 0x01};
+                                                                //u8 WMM_OUI[4]={0x00, 0x50, 0xF2, 0x02};
+                                                                if (memcmp (WPA_OUI, (u8*)&frame->body[k+2], 4)==0) {
+                                                                        memcpy((U8 *)elem, &frame->body[k], len);
+                                                                        return TRUE;
+                                                                }
+                                                                //else if (memcmp (WMM_OUI, (u8*)&frame->body[k+2], 4)==0)
+                                                                //{
+                                                                //   memcpy((U8 *)&elem->buf[0]+128, &frame->body[k], len);
+                                                                //return TRUE;
+                                                                //}
+                                                                else
+                                                                        k += len;
+                                                        } else
+                                                                k += len;
+                                                } else {
+                                                        memcpy((U8 *)elem, &frame->body[k], len);
+                                                        return TRUE;
+                                                }
+                                        } else {
+                                                k += len;
+                                        }
+                                }
+                                elem->buf[1]=0;
+                                return FALSE;
+                        }
+
+                        void mkAuthFrm(FrmDesc_t* pfrmDesc, MacAddr_t *addr1, U16 Alg, U16 Seq,
+                                       U16 Status, U8 *pChalng, U8 vapId) {
+                                U8 *body;
+                                U16 len;
+                                Frame_t *pf = pfrmDesc->mpdu;
+
+                                setFrameType(pf, ST_AUTH);
+                                pf->body = pfrmDesc->buffer;
+                                body = pf->body;
+                                setAddr1(pf, addr1);
+                                setAddr2(pf, &dot11MacAddress);
+                                setAddr3(pf, &mBssId);
+                                pf->HdrLen = MAC_HDR_LNG;
+
+                                body[0] = Alg & 0xff;			//AuthAlg
+                                body[1] = (Alg & 0xff00) >> 8;
+                                body[2] = Seq & 0xff;			//AuthSeq
+                                body[3] = (Seq & 0xff00) >> 8;
+                                body[4] = Status & 0xff;		//Status
+                                body[5] = (Status & 0xff00) >> 8;
+                                len = 6;
+
+                                if ((Alg == SHARE_KEY) && ((Seq == 2)|| (Seq == 3)) && (pChalng)) {
+                                        body[len] = EID_CTEXT;
+                                        body[len+1] = CHAL_TEXT_LEN;
+                                        memcpy(&body[len+2], pChalng, CHAL_TEXT_LEN);
+                                        len += (2+CHAL_TEXT_LEN);
+                                }
+
+                                pf->bodyLen = len;
+                        }
+
+                        void mkRe_AsocRspFrm(FrmDesc_t* pfrmDesc, TypeSubtype subType, MacAddr_t *addr1,
+                                             U16 Cap, U16 Status, U16 Aid, Element *pSupRates, Element *pExtRates, U8 vapId) {
+                                U8 *body;
+                                U8 elemLen;
+                                U16 len;
+                                Frame_t *pf = pfrmDesc->mpdu;
+
+                                setFrameType(pf, subType);
+                                pf->body = pfrmDesc->buffer;
+                                body = pf->body;
+                                setAddr1(pf, addr1);
+                                setAddr2(pf, &dot11MacAddress);
+                                setAddr3(pf, &mBssId);
+                                pf->HdrLen = MAC_HDR_LNG;
+
+                                body[0] = Cap & 0xff;			//Cap
+                                body[1] = (Cap & 0xff00) >> 8;
+                                body[2] = Status & 0xff;		//Status
+                                body[3] = (Status & 0xff00) >> 8;
+                                body[4] = Aid & 0xff;			//AID
+                                body[5] = (Aid & 0xff00) >> 8;
+                                len = 6;
+
+                                elemLen = pSupRates->buf[1]+2;
+                                memcpy(&body[len], (U8 *)pSupRates, elemLen); //Support Rates
+                                len += elemLen;
+
+                                if ((mMacMode != PURE_B_MODE) && (PURE_A_MODE != mMacMode) && (pExtRates)) {
+                                        elemLen = pExtRates->buf[1]+2;
+                                        memcpy(&body[len], (U8 *)pExtRates, elemLen); //Extended rates
+                                        len += elemLen;
+                                }
+
+                                pf->bodyLen = len;
+
+                        }
+
+
+                        void mkProbeRspFrm(FrmDesc_t* pfrmDesc, MacAddr_t *addr1, U16 BcnInterval,
+                                           U16 Cap, Element *pSsid, Element *pSupRates, Element *pDsParms,
+                                           Element *pExtRates, Element *pWpa, U8 vapId)
+                        {
+                                struct zd1205_private *macp=g_dev->priv;
+
+                                U8 *body;
+                                U8 elemLen;
+                                U16 len;
+                                Frame_t *pf = pfrmDesc->mpdu;
+
+                                setFrameType(pf, ST_PROBE_RSP);
+                                pf->body = pfrmDesc->buffer;
+                                body = pf->body;
+                                setAddr1(pf, addr1);
+                                setAddr2(pf, &dot11MacAddress);
+                                setAddr3(pf, &mBssId);
+                                pf->HdrLen = MAC_HDR_LNG;
+
+                                body[8] = BcnInterval & 0xff;	//BcnPeriod
+                                body[9] = (BcnInterval & 0xff00) >> 8;
+                                body[10] = Cap & 0xff;			//Cap
+                                body[11] = (Cap & 0xff00) >> 8;
+
+                                len = 12;
+                                elemLen = pSsid->buf[1]+2;
+                                memcpy(&body[len], (U8 *)pSsid, elemLen); //SSID
+                                len += elemLen;
+
+                                elemLen = pSupRates->buf[1]+2;
+
+                                memcpy(&body[len], (U8 *)pSupRates, elemLen); //Suported rates
+                                len += elemLen;
+
+                                elemLen = pDsParms->buf[1]+2;
+                                memcpy(&body[len], (U8 *)pDsParms, elemLen); //Extended rates
+                                len += elemLen;
+
+                                if ((mMacMode != PURE_B_MODE)&& (mMacMode != PURE_A_MODE) && (pExtRates)) {
+                                        elemLen = pExtRates->buf[1]+2;
+                                        memcpy(&body[len], (U8 *)pExtRates, elemLen); //Extended rates
+                                        len += elemLen;
+                                }
+#if 0
+                                if (((mDynKeyMode == DYN_KEY_TKIP) || (mDynKeyMode == DYN_KEY_AES))  && (pWpa)) {
+                                        elemLen = pWpa->buf[1]+2;
+                                        memcpy(&body[len], (U8 *)pWpa, elemLen); //WPA IE
+                                        len += elemLen;
+                                }
+#endif
+                                //if (((mDynKeyMode == DYN_KEY_TKIP) || (mDynKeyMode == DYN_KEY_AES))  && (pWpa)){
+                                if (macp->cardSetting.WPAIeLen) {
+                                        //elemLen = pWpa->buf[1]+2;
+                                        //memcpy(&body[len], (U8 *)pWpa, elemLen); //WPA IE
+                                        memcpy(&body[len], macp->cardSetting.WPAIe, macp->cardSetting.WPAIeLen);
+                                        len += macp->cardSetting.WPAIeLen;
+                                }
+
+                                pf->bodyLen = len;
+                        }
+
+
+                        void mkDisAssoc_DeAuthFrm(FrmDesc_t* pfrmDesc, TypeSubtype subType, MacAddr_t *addr1,
+                                                  U16 Reason, U8 vapId) {
+                                U8 *body;
+                                Frame_t *pf = pfrmDesc->mpdu;
+
+                                setFrameType(pf, subType);
+                                pf->body = pfrmDesc->buffer;
+                                body = pf->body;
+                                setAddr1(pf, addr1);
+                                setAddr2(pf, &dot11MacAddress);
+                                setAddr3(pf, &mBssId);
+                                pf->HdrLen = MAC_HDR_LNG;
+
+                                body[0] = Reason & 0xff;	//Reason Code
+                                body[1] = (Reason & 0xff00) >> 8;
+
+                                pf->bodyLen = 2;
+                        }
+
+
+                        void sendProbeRspFrm(MacAddr_t *addr1, U16 BcnInterval, U16 Cap,
+                                             Element *pSsid, Element *pSupRates, Element *pDsParms,
+                                             Element *pExtRates, Element *pWpa, U8 vapId) {
+                                Signal_t *signal;
+                                FrmDesc_t *pfrmDesc;
+
+                                if ((signal = allocSignal()) == NULL)
+                                        return;
+
+                                if ((pfrmDesc = allocFdesc()) == NULL) {
+                                        freeSignal(signal);
+                                        return;
+                                }
+
+                                mkProbeRspFrm(pfrmDesc, addr1, BcnInterval, Cap, pSsid, pSupRates, pDsParms,
+                                              pExtRates, pWpa, vapId);
+                                sendMgtFrame(signal, pfrmDesc);
+                        }
+
+
+                        void mkProbeReqFrm(FrmDesc_t* pfrmDesc, MacAddr_t *addr1, Element *pSsid, Element *pSupRates,
+                                           Element *pExtRates, Element *pWpa, U8 vapId) {
+                                U8 *body;
+                                U8 elemLen;
+                                U16 len;
+                                Frame_t *pf = pfrmDesc->mpdu;
+
+                                setFrameType(pf, ST_PROBE_REQ);
+                                pf->body = pfrmDesc->buffer;
+                                body = pf->body;
+                                setAddr1(pf, addr1);
+                                setAddr2(pf, &dot11MacAddress);
+                                setAddr3(pf, &dot11BCAddress);
+                                pf->HdrLen = MAC_HDR_LNG;
+
+                                len = 0;
+                                if (pSsid->buf[1] > 0) {
+                                        elemLen = pSsid->buf[1]+2;
+
+                                        memcpy(&body[len], (U8 *)pSsid, elemLen); //Extended rates
+                                        len += elemLen;
+                                } else {
+                                        body[0] = pSsid->buf[0];
+                                        body[1] = 0; //broadcast SSID
+                                        len += 2;
+                                }
+
+                                elemLen = pSupRates->buf[1]+2;
+                                memcpy(&body[len], (U8 *)pSupRates, elemLen); //Extended rates
+                                len += elemLen;
+
+                                if ((mMacMode != PURE_A_MODE) && (mMacMode != PURE_B_MODE) && (pExtRates)) {
+                                        elemLen = pExtRates->buf[1]+2;
+                                        memcpy(&body[len], (U8 *)pExtRates, elemLen); //Extended rates
+                                        len += elemLen;
+                                }
+
+                                if ((mDynKeyMode == DYN_KEY_TKIP)  && (pWpa)) {
+                                        elemLen = pWpa->buf[1]+2;
+                                        memcpy(&body[len], (U8 *)pWpa, elemLen); //WPA IE
+                                        len += elemLen;
+                                }
+
+                                pf->bodyLen = len;
+                        }
+
+
+                        void mkRe_AsocReqFrm(FrmDesc_t* pfrmDesc, TypeSubtype subType, MacAddr_t *addr1,
+                                             U16 Cap, U16 LisInterval, MacAddr_t *oldAP, Element *pSsid, Element *pSupRates,
+                                             Element *pExtRates, Element *pWpa, U8 vapId)
+                        {
+                                U8 *body;
+                                U8 elemLen;
+                                U16 len;
+                                Frame_t *pf = pfrmDesc->mpdu;
+
+                                setFrameType(pf, subType);
+                                pf->body = pfrmDesc->buffer;
+                                body = pf->body;
+                                setAddr1(pf, addr1);
+                                setAddr2(pf, &dot11MacAddress);
+                                setAddr3(pf, &mBssId);
+                                pf->HdrLen = MAC_HDR_LNG;
+
+                                body[0] = Cap & 0xff;			//Cap
+                                body[1] = (Cap & 0xff00) >> 8;
+                                body[2] = LisInterval & 0xff;	//LisInterval
+                                body[3] = (LisInterval & 0xff00) >> 8;
+                                len = 4;
+
+                                if (subType == ST_REASOC_REQ) {
+                                        memcpy(&body[4], oldAP, 6);
+                                        len = 10;
+                                }
+
+                                elemLen = pSsid->buf[1]+2;
+                                memcpy(&body[len], (U8 *)pSsid, elemLen); 	//SSID
+                                len += elemLen;
+
+#ifdef DEBUG_DUMP_ASSOC_REQ
+
+                                zd1205_dump_data("SSID element:", (U8*) &body[len-elemLen], elemLen);
+#endif
+
+                                elemLen = pSupRates->buf[1]+2;
+                                memcpy(&body[len], (U8 *)pSupRates, elemLen); //Support Rates
+                                len += elemLen;
+#ifdef DEBUG_DUMP_ASSOC_REQ
+
+                                zd1205_dump_data("SupportedRate element:", (U8*) &body[len-elemLen], elemLen);
+#endif
+
+                                if ((mMacMode != PURE_B_MODE) && (mMacMode != PURE_A_MODE)&& (pExtRates)) {
+                                        elemLen = pExtRates->buf[1]+2;
+                                        memcpy(&body[len], (U8 *)pExtRates, elemLen); //Extended rates
+                                        len += elemLen;
+                                }
+
+                                // WPA IE
+                                if (pWpa->buf[1] != 0) {
+                                        elemLen = pWpa->buf[1]+2;
+                                        memcpy(&body[len], (U8 *)pWpa, elemLen); // WPA IE
+                                        len += elemLen;
+                                }
+
+                                pf->bodyLen = len;
+                        }
+
+                        BOOLEAN sendPsPollFrame(Signal_t *signal, FrmDesc_t *pfrmDesc, MacAddr_t *addr1, U16 aid) {
+                                FrmInfo_t *pfrmInfo;
+                                Frame_t *pf = pfrmDesc->mpdu;
+
+                                setFrameType(pf, ST_PS_POLL);
+                                setAid(pf, aid);
+                                setAddr1(pf, addr1);
+                                setAddr2(pf, &dot11MacAddress);
+                                pf->HdrLen = 16;
+                                pf->bodyLen = 0;
+
+                                pfrmDesc->ConfigSet |= PS_POLL_SET;
+                                pfrmDesc->ConfigSet &= ~INTRA_BSS_SET;
+                                pfrmDesc->ConfigSet &= ~EAPOL_FRAME_SET;
+                                pfrmDesc->pHash = NULL;
+                                signal->buf = NULL;
+                                signal->bDataFrm = 0;
+                                //pfrmDesc->bDataFrm = 0;
+
+                                pfrmInfo = &signal->frmInfo;
+                                pfrmInfo->frmDesc = pfrmDesc; //make connection for signal and frmDesc
+                                return SendPkt(signal, pfrmDesc, TRUE);
+                        }
+
+
+                        BOOLEAN sendNullDataFrame(Signal_t *signal, FrmDesc_t *pfrmDesc, MacAddr_t *addr1) {
+                                Frame_t *pf = pfrmDesc->mpdu;
+
+                                setFrameType(pf, ST_NULL_FRAME);
+                                pf->header[1] = TO_DS_BIT;
+
+                                if (mPwrState) {
+                                        pf->header[1] |= PW_SAVE_BIT;
+                                } else
+                                        pf->header[1] &= ~PW_SAVE_BIT;
+
+                                setAddr1(pf, addr1);
+                                setAddr2(pf, &dot11MacAddress);
+                                setAddr3(pf, &mBssId);
+                                pf->HdrLen = MAC_HDR_LNG;
+                                pf->bodyLen = 0;
+
+                                pfrmDesc->ConfigSet &= ~INTRA_BSS_SET;
+                                pfrmDesc->ConfigSet &= ~EAPOL_FRAME_SET;
+                                pfrmDesc->pHash = NULL;
+                                signal->buf = NULL;
+                                signal->bDataFrm = 1;
+
+                                //pfrmDesc->bDataFrm = 0;
+                                mkFragment(signal, pfrmDesc, NULL);
+                                return SendPkt(signal, pfrmDesc, TRUE);
+                        }
+
+
+                        U8 RateConvert(U8 rate) {
+#if defined(OFDM)
+                                switch (rate) {
+                                case 2  :
+                                        return 0;  // 1M
+                                case 4  :
+                                        return 1;  // 2M
+                                case 11 :
+                                        return 2;  // 5.5M
+                                case 22 :
+                                        return 3;  // 11M
+                                case 12 :
+                                        return 4;  // 6M
+                                case 18 :
+                                        return 5;  // 9M
+                                case 24 :
+                                        return 6;  // 12M
+                                case 36 :
+                                        return 7;	// 18M
+                                case 48 :
+                                        return 8;	// 24M
+                                case 72 :
+                                        return 9;	// 36M
+                                case 96 :
+                                        return 0xa;	// 48M
+                                case 108:
+                                        return 0xb;	// 54M
+                                }
+#else
+                                switch (rate) {
+                                case 2  :
+                                        return 0;  // 1M
+                                case 4  :
+                                        return 1;  // 2M
+                                case 11 :
+                                        return 2;  // 5.5M
+                                case 22 :
+                                        return 3;  // 11M
+                                case 33 :
+                                        return 4;  // 16.5M
+                                case 44 :
+                                        return 5;  // 22M
+                                case 55 :
+                                        return 6;  // 27.5M
+#if defined(ECCK_60_5)
+
+                                case 66 :
+                                        return 7;  // 33M
+                                case 77 :
+                                        return 8;  // 38.5M
+                                case 88 :
+                                        return 9;  // 44M
+                                case 99 :
+                                        return 10; // 49.5M
+                                case 110:
+                                        return 11; // 55M
+                                case 121:
+                                        return 12; // 60.5M
+#endif
+
+                                }
+#endif
+
+                                return 3;	// 11M
+                        }
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdshared.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdshared.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdshared.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdshared.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,28 @@
+#ifndef _ZDSHARED_H_
+#define _ZDSHARED_H_
+
+void mkFragment(Signal_t *signal, FrmDesc_t *pfrmDesc, U8 *pEthHdr);
+BOOLEAN sendMgtFrame(Signal_t *signal, FrmDesc_t *pfrmDesc);
+BOOLEAN	getElem(Frame_t *frame, ElementID eID, Element *eElem);
+
+void mkAuthFrm(FrmDesc_t* pfrmDesc, MacAddr_t *addr1, U16 Alg, U16 Seq,
+               U16 Status, U8 *pChalng, U8 vapId);
+void mkRe_AsocRspFrm(FrmDesc_t* pfrmDesc, TypeSubtype subType, MacAddr_t *addr1,
+                     U16 Cap, U16 Status, U16 Aid, Element *pSupRates, Element *pExtRates, U8 vapId);
+void mkProbeReqFrm(FrmDesc_t* pfrmDesc, MacAddr_t *addr1, Element *pSsid, Element *pSupRates,
+                   Element *pExtRates, Element *pWpa, U8 vapId);
+void mkDisAssoc_DeAuthFrm(FrmDesc_t* pfrmDesc, TypeSubtype subType, MacAddr_t *addr1,
+                          U16 Reason, U8 vapId);
+void mkRe_AsocReqFrm(FrmDesc_t* pfrmDesc, TypeSubtype subType, MacAddr_t *addr1,
+                     U16 Cap, U16 LisInterval, MacAddr_t *oldAP, Element *pSsid, Element *pSupRates,
+                     Element *pExtRates, Element *pWpa, U8 vapId);
+void sendProbeRspFrm(MacAddr_t *addr1, U16 BcnInterval, U16 Cap,
+                     Element *pSsid, Element *pSupRates, Element *pDsParms,
+                     Element *pExtRates, Element *pWpa, U8 vapId);
+BOOLEAN sendPsPollFrame(Signal_t *signal, FrmDesc_t *pfrmDesc, MacAddr_t *addr1, U16 aid);
+BOOLEAN sendNullDataFrame(Signal_t *signal, FrmDesc_t *pfrmDesc, MacAddr_t *addr1);
+U8 RateConvert(U8 rate);
+void mkProbeRspFrm(FrmDesc_t* pfrmDesc, MacAddr_t *addr1, U16 BcnInterval,
+                   U16 Cap, Element *pSsid, Element *pSupRates, Element *pDsParms,
+                   Element *pExtRates, Element *pWpa, U8 vapId);
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdsm.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdsm.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdsm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdsm.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,92 @@
+#ifndef __ZDSM_H__
+#define __ZDSM_H__
+
+#include "zdos.h"
+#include "zdsorts.h"
+
+
+typedef struct FrmInfo_s
+{
+        MacAddr_t 	Sta;		//for Disassoc/Deauth STA
+        ReasonCode	rCode;		//for Disassoc/Deauth Reason Code
+        U8			fTot;		//total frag no.
+        U32			eol;		//timestamp for age	(PsQ)
+        FrmDesc_t	*frmDesc;	//
+}
+FrmInfo_t;
+
+
+typedef struct Signal_s
+{
+        struct Signal_s 	*pNext;
+        U8					id;
+        U8					block;
+        U8					vapId;		//virtual AP id
+        U8					bDataFrm;	//data frame
+        void				*buf;		//buffer
+        FrmInfo_t			frmInfo;
+}
+Signal_t ;
+
+
+typedef struct SignalQ_s
+{
+        Signal_t 	*first;
+        Signal_t 	*last;
+        U8			cnt;
+}
+SignalQ_t;
+
+
+#define BLOCK_SYNCH					0x01
+#define BLOCK_AUTH_REQ				0x02
+#define BLOCK_AUTH_RSP				0x03
+#define BLOCK_ASOC					0x04
+
+
+//Auth_Req block, 3 state, 4 signals
+#define STE_AUTH_REQ_IDLE			0x00
+#define STE_WAIT_AUTH_SEQ2			0x01
+#define STE_WAIT_AUTH_SEQ4			0x02
+
+
+#define SIG_DEAUTH_REQ				0x01
+#define SIG_AUTH_REQ				0x02
+#define SIG_AUTH_EVEN				0x03
+#define SIG_TO_AUTH					0x04
+
+
+//Asoc_Svc block, 1 state, 9 signals
+#define SIG_DISASSOC				0x01
+#define SIG_ASSOC					0x02
+#define SIG_REASSOC					0x03
+#define SIG_DIASSOC_REQ				0x04
+#define SIG_ASSOC_REQ				0x05
+#define SIG_REASSOC_REQ				0x06
+#define SIG_ASSOC_RSP				0x07
+#define SIG_REASSOC_RSP				0x08
+#define SIG_TO_ASOC					0x09
+
+
+#define STE_ASOC_IDLE				0x00
+
+#define STE_WAIT_ASOC_RSP			0x01
+
+
+//Auth_Rsp block, 2 state, 3 signals
+#define STE_AUTH_RSP_IDLE			0x00
+#define STE_AUTH_RSP_WAIT_CRSP 		0x01
+
+
+#define SIG_AUTH_ODD				0x01
+#define SIG_DEAUTH					0x02
+#define SIG_TO_CHAL					0x03
+
+
+//Synch block, 1 state, 3 signals
+#define SIG_PROBE					0x01
+#define SIG_PROBE_REQ				0x02
+#define	SIQ_PROBE_RSP_BEACON		0x03
+
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdsorts.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdsorts.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdsorts.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdsorts.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,311 @@
+#ifndef __ZDSORTS_H__
+#define __ZDSORTS_H__
+
+#include "zdtkipseed.h"
+#include "zdmic.h"
+
+#define MAX_MSDU_LNG		1600// only payload
+#define MAC_HDR_LNG			24	// 802.11, not include A4
+#define WEP_ADD_LNG			8	// 4 for IV, 4 for ICV
+#define WDS_ADD_LNG			6	// for Address 4
+#define IV_LNG				4
+#define EIV_LNG				4
+#define ICV_LNG				4
+#define CRC_LNG				4
+#define MIC_LNG				8
+
+#define MIN_FRAG_LNG		256
+#define MAX_FRAG_NUM		(MAX_MSDU_LNG / (MIN_FRAG_LNG - MAC_HDR_LNG - CRC_LNG))
+
+
+#define MAX_AID 			32
+#define MAX_RECORD			(MAX_AID + 1)
+#define BURST_NUM	        64//32
+#define TXQ_THRESHOLD		48
+#define	MCQ_THRESHOLD		15
+#define CHAL_TEXT_LEN		128
+#ifndef HOST_IF_USB
+    #define IDLE_TIMEOUT		(10*60*1000*1000) //10 min
+#else
+    #define IDLE_TIMEOUT		(10*60*100) //10 min
+#endif
+
+#define RISE_RATE_THRESHOLD	4
+#define HIGH_RISE_RATE_THRESHOLD	0xff
+#define AGE_HASH_PERIOD		(10*60) //10 min
+
+#define LONG_PREAMBLE		0
+#define SHORT_PREAMBLE		1
+
+#define OPEN_SYSTEM			0
+#define SHARE_KEY			1
+#define NULL_AUTH			2
+
+
+#define WEP_NOT_USED		0
+#define AES_USED			4
+#define WEP64_USED			1
+#define WEP128_USED			5
+#define TKIP_USED			2
+#define WEP256_USED			6
+
+
+#define	TO_DS_BIT			0x01
+#define FROM_DS_BIT			0x02
+#define MORE_FRAG_BIT		0x04
+
+#define PW_SAVE_BIT			0x10
+#define MORE_DATA_BIT		0x20
+#define WEP_BIT				0x40
+#define ORDER_BIT			0x80
+
+#define EIV_BIT				0x20
+#define KEYID_MASK              0xC0
+#define NON_ERP_PRESENT		0x01
+#define USE_PROTECTION		0x02
+#define BARKER_PREAMBLE		0x04
+//register 0xD40
+#define MIC_BUSY			0x01
+
+
+typedef enum
+{
+        PSMODE_STA_ACTIVE,
+        PSMODE_POWER_SAVE
+} PsMode;
+
+
+typedef enum
+{
+        STATION_STATE_NOT_AUTH,
+        STATION_STATE_AUTH_OPEN,
+        STATION_STATE_AUTH_KEY,
+        STATION_STATE_ASOC,
+        STATION_STATE_DIS_ASOC
+} StationState;
+
+
+typedef struct
+{
+        U8 mac[6];
+}
+MacAddr_t;
+
+
+typedef enum
+{
+        EID_SSID 	= 0,
+        EID_SUPRATES,
+        EID_FHPARMS,
+        EID_DSPARMS,
+        EID_CFPARMS,
+        EID_TIM,
+        EID_IBPARMS,
+        EID_COUNTRY,
+        EID_CTEXT	= 0x10,
+        EID_ERP		= 0x2A,
+        EID_RSN		= 0x30,
+        EID_EXT_RATES	= 0x32,
+        EID_WPA		= 0xDD,
+} ElementID;
+
+typedef struct
+{
+        U8	buf[34+1];	//Max SSID Length = 32
+}
+Element;
+
+
+typedef enum
+{
+        CAP_ESS 	= 0x01,
+        CAP_IBSS	= 0x02,
+        CAP_POLLABLE = 0x04,
+        CAP_POLLREQ = 0x08,
+        CAP_PRIVACY = 0x10,
+        CAP_SHORT_PREAMBLE = 0x20,
+        CAP_PBCC_ENABLE	= 0x40,
+        CAP_SHORT_SLOT_TIME = 0x0400,
+        CAP_DSSS_OFDM_BIT = 0x2000
+} Capability;
+
+
+typedef enum
+{
+        RC_UNSPEC_REASON = 1,
+        RC_AUTH_NOT_VALID,
+        RC_DEAUTH_LEAVE_BSS,
+        RC_INACTIVITY,
+        RC_AP_OVERLOAD,
+        RC_CLASS2_ERROR,
+        RC_CLASS3_ERROR,
+        RC_DISAS_LEAVE_CSS,
+        RC_ASOC_NOT_AUTH,
+        RC_INVALID_IE = 13,
+        RC_MIC_FAIL,
+        RC_4WAY_SHAKE_TIMEOUT,
+        RC_GKEY_UPDATE_TIMEOUT,
+        RC_IE_IMCOMPABILITY,
+        RC_MC_CIPHER_INVALID,
+        RC_UNI_CIPHER_INVALID,
+        RC_AKMP_INVALID,
+        RC_UNSUP_RSNE_VERSION,
+        RC_INVALID_RSNE_CAP,
+        RC_8021X_AUTH_FAIL
+} ReasonCode;
+
+
+typedef enum
+{
+        SC_SUCCESSFUL = 0,
+        SC_UNSPEC_FAILURE,
+        SC_UNSUP_CAP = 10,
+        SC_REASOC_NO_ASOC,
+        SC_FAIL_OTHER,
+        SC_UNSUPT_ALG,
+        SC_AUTH_OUT_OF_SEQ,
+        SC_CHAL_FAIL,
+        SC_AUTH_TIMEOUT,
+        SC_AP_FULL,
+        SC_UNSUP_RATES,
+        SC_UNSUP_SHORT_SLOT_TIME = 25,
+        SC_UNSUP_ER_PBCC = 26,
+        SC_UNSUP_DSSS_OFDM = 27
+} StatusCode;
+
+
+typedef enum
+{
+        ST_ASOC_REQ 	= 0x00,
+        ST_ASOC_RSP 	= 0x10,
+        ST_REASOC_REQ 	= 0x20,
+        ST_REASOC_RSP 	= 0x30,
+        ST_PROBE_REQ 	= 0x40,
+        ST_PROBE_RSP 	= 0x50,
+        ST_BEACON 	= 0x80,
+        ST_ATIM 	= 0x90,
+        ST_DISASOC 	= 0xA0,
+        ST_AUTH 	= 0xB0,
+        ST_DEAUTH 	= 0xC0,
+        ST_PS_POLL 	= 0xA4,
+        ST_RTS 		= 0xB4,
+        ST_CTS 		= 0xC4,
+        ST_ACK 		= 0xD4,
+        ST_CFEND 	= 0xE4,
+        ST_CFEND_ACK 	= 0xF4,
+        ST_DATA 	= 0x08,
+        ST_DATA_ACK 	= 0x18,
+        ST_DATA_POLL 	= 0x28,
+        ST_DATA_POLL_ACK= 0x38,
+        ST_NULL_FRAME 	= 0x48
+} TypeSubtype;
+
+
+typedef struct TrafficMap_s
+{
+        U8	t[(MAX_AID/8)+1];
+}
+TrafficMap_t;
+
+
+#define RATEARRAY_NUM		16
+typedef struct Hash_s
+{
+        struct Hash_s *pNext;
+        U8	mac[6];
+        StationState asoc;
+        StationState auth;
+        PsMode	psm;
+        U16  aid;
+        BOOLEAN	bValid;
+        BOOLEAN	bErpSta;
+        BOOLEAN bJustRiseRate;
+        U8	lsInterval;
+        U8	RxRate;//entry;
+        U8	encryMode;
+        U8	keyLength;
+        U8	pkInstalled;
+        U8	ZydasMode;
+        U8	AlreadyIn;
+        U8	MaxRate;
+        U8	CurrTxRate;
+        U8	ContSuccFrames;
+        U8	Preamble;
+        U8	KeyId;
+        U16 iv16;
+        U32 iv32;
+        U32 ttl;
+        U32 SuccessFrames;
+        U32 FailedFrames;
+        U8	RateArray[RATEARRAY_NUM];// this array is the rate adaption table
+        U8	RateArrayCount;
+        U8	SupportRateArray[RATEARRAY_NUM];
+        U8	SupportRateArrayCount;
+        U8	RiseConditionCount;
+        U8	DownConditionCount;
+        U8	keyContent[16];
+        U8	wepIv[4];
+        U8	vapId;
+        Seedvar	TxSeed;
+        Seedvar	RxSeed;
+        MICvar	TxMicKey;
+        MICvar	RxMicKey;
+#ifdef HOSTAPD_SUPPORT
+
+        Element WPAIE;
+#endif
+}
+Hash_t;
+
+
+typedef struct Frame_s
+{
+        U16		HdrLen;
+        U16		bodyLen;
+        U8		header[32];	//include IV, eIV
+        U8		*body;
+        void	*fragBuf;
+}
+Frame_t;
+
+typedef struct FrmDesc_s
+{
+        struct	FrmDesc_s *pNext;
+        U8		buffer[160]; 			//use mbuf to send boradcast
+        Frame_t mpdu[MAX_FRAG_NUM];		//for fragment
+        BOOLEAN bValid;
+        U8		ConfigSet;
+        U8		signalStrength;
+        U8		signalQuality;
+        U8 		CalMIC[MIC_LNG+1];				//1~8 for MIC, 9==TRUE ,if used.
+        Hash_t	*pHash;
+        //U8		HwMicPhys[12];			// MIC valuse(8). MIC status(4)
+}
+FrmDesc_t;
+
+#define MAX_COUNTRY_INFO_SIZE  50
+typedef struct BssInfo_s
+{
+        MacAddr_t	bssid;
+        U16		bcnInterval;
+        U16		cap;
+        Element		ssid;
+        Element		supRates;
+        Element		Phpm;
+        Element		IbssParms;
+        Element		erp;
+        Element		extRates;
+        Element		country;
+        U8		signalStrength;
+        U8		signalQuality;
+        U8  		apMode;
+        U16		basicRateMap;
+        U16		supRateMap;
+        U8		WPAIe[128];
+        U8		RSNIe[128];
+
+}
+BssInfo_t;
+
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdsynch.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdsynch.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdsynch.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdsynch.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,400 @@
+#ifndef __ZDSYNCH_C__
+#define __ZDSYNCH_C__
+
+#include "zd80211.h"
+extern u8 LastMacMode;
+extern u8 mMacMode;
+//extern CurrScanCH;
+extern const U16 dot11A_Channel[];
+extern u8 LastSetChannel;
+
+void zd_makeRateInfoMAP(U8 *pRates, U16 *basicRateMap, U16 *supRateMap)
+{
+        int j;
+        U8 rate;
+        U8 eleLen = *(pRates+1);
+
+        for (j=0; j<eleLen; j++) {
+                rate =  *(pRates+2+j);
+                switch (rate & 0x7f) {
+                case SR_1M:
+                        *supRateMap |= BIT_0;
+                        if (rate & 0x80)
+                                *basicRateMap |= BIT_0;
+                        break;
+
+                case SR_2M:
+                        *supRateMap |= BIT_1;
+                        if (rate & 0x80)
+                                *basicRateMap |= BIT_1;
+                        break;
+
+                case SR_5_5M:
+                        *supRateMap |= BIT_2;
+                        if (rate & 0x80)
+                                *basicRateMap |= BIT_2;
+                        break;
+
+                case SR_11M:
+                        *supRateMap |= BIT_3;
+                        if (rate & 0x80)
+                                *basicRateMap |= BIT_3;
+                        break;
+
+                case SR_6M:
+                        *supRateMap |= BIT_4;
+                        if (rate & 0x80)
+                                *basicRateMap |= BIT_4;
+                        break;
+
+                case SR_9M:
+                        *supRateMap |= BIT_5;
+                        if (rate & 0x80)
+                                *basicRateMap |= BIT_5;
+                        break;
+
+                case SR_12M:
+                        *supRateMap |= BIT_6;
+                        if (rate & 0x80)
+                                *basicRateMap |= BIT_6;
+                        break;
+
+                case SR_18M:
+                        *supRateMap |= BIT_7;
+                        if (rate & 0x80)
+                                *basicRateMap |= BIT_7;
+                        break;
+
+                case SR_24M:
+                        *supRateMap |= BIT_8;
+                        if (rate & 0x80)
+                                *basicRateMap |= BIT_8;
+                        break;
+
+                case SR_36M:
+                        *supRateMap |= BIT_9;
+                        if (rate & 0x80)
+                                *basicRateMap |= BIT_9;
+                        break;
+
+                case SR_48M:
+                        *supRateMap |= BIT_10;
+                        if (rate & 0x80)
+                                *basicRateMap |= BIT_10;
+                        break;
+
+                case SR_54M:
+                        *supRateMap |= BIT_11;
+                        if (rate & 0x80)
+                                *basicRateMap |= BIT_11;
+                        break;
+
+#if 0
+
+                case SR_16_5M:
+                        *supRateMap |= BIT_12;
+                        if (rate & 0x80)
+                                *basicRateMap |= BIT_12;
+                        break;
+
+                case SR_27_5M:
+                        *supRateMap |= BIT_13;
+                        if (rate & 0x80)
+                                *basicRateMap |= BIT_13;
+                        break;
+#endif
+
+                default:
+
+                        break;
+                }
+        }
+}
+
+BOOLEAN Probe(Signal_t *signal)
+{
+        FrmDesc_t *pfrmDesc;
+        Frame_t *rdu;
+        MacAddr_t sta;
+        Element rSsid;
+        Element *pWPA = NULL;
+        U8 vapId = 0;
+        Element *pExtRate = NULL;
+
+        ZDEBUG("Probe");
+
+        pfrmDesc = signal->frmInfo.frmDesc;
+        rdu = pfrmDesc->mpdu;
+
+        if (mBssType == INFRASTRUCTURE_BSS) {
+                goto release;
+        }
+
+        if (!getElem(rdu, EID_SSID, &rSsid))
+                goto release;
+
+        if (mHiddenSSID) { //discard broadcast ssid
+                if (eLen(&rSsid) == 0) {
+                        goto release;
+                }
+        }
+
+        memcpy((U8*)&sta, (U8*)addr2(rdu), 6);
+        pExtRate = &mExtRates;
+
+        if (eLen(&rSsid) == 0) {
+                //WPA
+                if (mDynKeyMode == DYN_KEY_TKIP || mDynKeyMode==DYN_KEY_AES)
+                        pWPA = &mWPAIe;
+
+                mkProbeRspFrm(pfrmDesc, &sta, mBeaconPeriod, mCap, &dot11DesiredSsid, &mBrates, &mPhpm, pExtRate, (Element *)pWPA, vapId);
+                return sendMgtFrame(signal, pfrmDesc);
+        } else {
+                if (memcmp(&rSsid, &dot11DesiredSsid, eLen(&dot11DesiredSsid)+2) == 0) {
+                        //WPA
+                        if ((mDynKeyMode == DYN_KEY_TKIP) || (mDynKeyMode == DYN_KEY_AES))
+                                pWPA = &mWPAIe;
+
+                        mkProbeRspFrm(pfrmDesc, &sta, mBeaconPeriod, mCap, &dot11DesiredSsid, &mBrates, &mPhpm, pExtRate, (Element *)pWPA, vapId);
+                        return sendMgtFrame(signal, pfrmDesc);
+                }
+        }
+
+release:
+        ZDEBUG("goto release");
+        freeFdesc(pfrmDesc);
+        return TRUE;
+}
+
+BOOLEAN ProbeReq(Signal_t *signal)
+{
+        FrmDesc_t *pfrmDesc;
+        Element	BCSsid;
+        U8 vapId = 0;
+        Element *pSsid = NULL;
+        Element *pExtRate = NULL;
+
+        ZDEBUG("ProbeReq");
+        //FPRINT("ProbeReq");
+
+        pfrmDesc = allocFdesc();
+        if(!pfrmDesc) {
+                sigEnque(pMgtQ, (signal));
+                return FALSE;
+        }
+
+        BCSsid.buf[0] = EID_SSID;
+        BCSsid.buf[1] = 0;
+
+        if (mProbeWithSsid) {
+                //pSsid = &mSsid;
+                pSsid = &dot11DesiredSsid;
+        } else {
+                pSsid = &BCSsid;
+        }
+
+        pExtRate = &mExtRates;
+
+        mkProbeReqFrm(pfrmDesc, &dot11BCAddress, pSsid, &mBrates, pExtRate, NULL, vapId);
+        if (signal->vapId == 0)
+                pdot11Obj->StartTimer(SCAN_TIMEOUT, DO_SCAN);
+        //mProbeWithSsid = FALSE;
+        return sendMgtFrame(signal, pfrmDesc);
+}
+
+BOOLEAN ProbeRsp_Beacon(Signal_t *signal)
+{
+        FrmDesc_t *pfrmDesc;
+        Frame_t *rdu;
+        MacAddr_t *pBssid = NULL;
+        //Element *pWPA = NULL;
+        U16 Cap = 0;
+        U16 BcnInterval = 0;
+        int i;
+        U8 FrmType;
+        BOOLEAN bUpdateInfo = FALSE;
+        U8 index;
+
+        BssInfo_t *pCurrBssInfo;
+
+        ZDEBUG("ProbeRsp_Beacon");
+        pfrmDesc = signal->frmInfo.frmDesc;
+        rdu = pfrmDesc->mpdu;
+
+        FrmType = frmType(rdu);
+
+        if (pdot11Obj->ConfigFlag & ACTIVE_CHANNEL_SCAN_SET) {
+                Cap = cap1(rdu);
+                //FPRINT_V("Cap", Cap);
+                BcnInterval = beaconInt(rdu);
+
+                if (Cap & CAP_IBSS) {
+                        pBssid = addr3(rdu);
+                } else
+                        pBssid = addr2(rdu);
+
+                index = mBssNum;
+                //The following if-statements is used to filter existing AP Info.
+                //The rule is:
+                //1. The bssid is seen before.
+                //2. The old Info.apMode equals to LastMacMode
+                //The meaning is if the incoming ap's bssid == old's bssid and
+                // ap's apMode(judged by LastMacMode) == old's apMode then Drop It.
+                for (i=0; i<mBssNum; i++) {
+                        if ((memcmp((U8 *)&mBssInfo[i].bssid, (U8 *)pBssid, 6) == 0) &&
+                                        ((PURE_A_AP==mBssInfo[i].apMode&& PURE_A_MODE==LastMacMode) ||
+                                         (PURE_A_AP!=mBssInfo[i].apMode&& PURE_A_MODE!=LastMacMode)
+                                        )
+                           ) {
+                                if (FrmType == ST_BEACON) {
+                                        goto release;
+                                } else {
+                                        bUpdateInfo = TRUE;
+                                        index = i;
+                                }
+                        }
+                }
+
+                pCurrBssInfo =  &mBssInfo[index];
+                pCurrBssInfo->basicRateMap = 0;
+                pCurrBssInfo->supRateMap = 0;
+
+                /* Reset supRates, extRates */
+                memset(&pCurrBssInfo->supRates, 0, NUM_SUPPORTED_RATE);
+                memset(&pCurrBssInfo->extRates, 0, NUM_SUPPORTED_RATE);
+
+                //get bssid
+                memcpy((U8 *)&pCurrBssInfo->bssid, (U8 *)pBssid, 6);
+
+                //get beacon interval
+                pCurrBssInfo->bcnInterval = BcnInterval;
+
+                //get capability
+                pCurrBssInfo->cap = Cap;
+
+                if (!getElem(rdu, EID_SSID, &pCurrBssInfo->ssid)) {
+                        goto release;
+                }
+
+                if (!getElem(rdu, EID_SUPRATES, &pCurrBssInfo->supRates)) {
+                        goto release;
+                }
+
+                if (!getElem(rdu, EID_DSPARMS, &pCurrBssInfo->Phpm)) {
+                        pCurrBssInfo->Phpm.buf[0]=0x3;// DS Parameter Set
+                        pCurrBssInfo->Phpm.buf[1]=1;
+                        pCurrBssInfo->Phpm.buf[2]=LastSetChannel;
+
+                        //goto release;
+                }
+                //This is used to filter non-allowed channel beacons
+                if (!((1 << (pCurrBssInfo->Phpm.buf[2]-1)) & pdot11Obj->AllowedChannel)) {
+                        if(PURE_A_MODE != mMacMode)
+                                goto release;
+                }
+
+                if (Cap & CAP_IBSS) {
+                        if (!getElem(rdu, EID_IBPARMS, &pCurrBssInfo->IbssParms)) {
+                                goto release;
+                        }
+                }
+
+                if (getElem(rdu, EID_EXT_RATES, &pCurrBssInfo->extRates)) {
+                        //zd1205_dump_data("Ext Rates", &pCurrBssInfo->extRates.buf[2], pCurrBssInfo->extRates.buf[1]);
+                }
+
+                if (getElem(rdu, EID_ERP, &pCurrBssInfo->erp)) {
+                        //zd1205_dump_data("ERP Info", &pCurrBssInfo->erp.buf[2], pCurrBssInfo->erp.buf[1]);
+                }
+                getElem(rdu, EID_COUNTRY, &pCurrBssInfo->country);
+
+                zd_makeRateInfoMAP((U8 *)&pCurrBssInfo->supRates, &pCurrBssInfo->basicRateMap, &pCurrBssInfo->supRateMap);
+                zd_makeRateInfoMAP((U8 *)&pCurrBssInfo->extRates, &pCurrBssInfo->basicRateMap, &pCurrBssInfo->supRateMap);
+                //FPRINT_V("basicRateMap", pCurrBssInfo->basicRateMap);
+                //FPRINT_V("supRateMap", pCurrBssInfo->supRateMap);
+
+                if (LastMacMode != PURE_A_MODE && pCurrBssInfo->supRateMap > 0x0f) {  //support rates include OFDM rates
+                        if (pCurrBssInfo->basicRateMap & ~0xf) { // basic rates include OFDM rates
+                                pCurrBssInfo->apMode = PURE_G_AP;
+                                //FPRINT("PURE_G_AP");
+                        } else {
+                                pCurrBssInfo->apMode = MIXED_AP;
+                                //FPRINT("MIXED_AP");
+                        }
+                } else if(LastMacMode == PURE_A_MODE) {
+                        pCurrBssInfo->apMode = PURE_A_AP;
+                } else {
+                        pCurrBssInfo->apMode = PURE_B_AP;
+                        //FPRINT("PURE_B_AP");
+                }
+
+                /* Get WPA IE Information */
+                //getElem(rdu, EID_WPA, (Element *)&pCurrBssInfo->WPAIe);
+
+                memset(&pCurrBssInfo->WPAIe,0x00, sizeof(pCurrBssInfo->WPAIe));
+                getElem(rdu, EID_WPA, (Element*)&pCurrBssInfo->WPAIe);
+                memset(&pCurrBssInfo->RSNIe,0x00, sizeof(pCurrBssInfo->RSNIe));
+                getElem(rdu, EID_RSN, (Element*)&pCurrBssInfo->RSNIe);
+
+
+#if 0
+                /* Dump WPA IE */
+                if(pCurrBssInfo->WPAIe[1] != 0) {
+                        int ii;
+                        u8 SSID[34+1];
+
+                        memcpy(SSID, (u8 *)(&pCurrBssInfo->ssid.buf[2]), pCurrBssInfo->ssid.buf[1]);
+                        SSID[pCurrBssInfo->ssid.buf[1]] = '\0';
+
+                        printk(KERN_ERR "WPA IE found in site survey, SSID: %s\n", SSID);
+
+                        for(ii = 0; ii < pCurrBssInfo->WPAIe[1]+2; ) {
+                                printk(KERN_ERR "0x%02x ", pCurrBssInfo->WPAIe[ii]);
+                                ii++;
+                        }
+
+                        printk(KERN_ERR "\n");
+                }
+#endif
+
+                pCurrBssInfo->signalStrength = pfrmDesc->signalStrength;
+                pCurrBssInfo->signalQuality = pfrmDesc->signalQuality;
+
+                if (mBssNum < 63) {
+                        if (!bUpdateInfo)
+                                mBssNum++;
+                }
+        }
+
+release:
+        ZDEBUG("goto release");
+        freeFdesc(pfrmDesc);
+        return TRUE;
+}
+
+
+BOOLEAN SynchEntry(Signal_t *signal)
+{
+        FrmDesc_t *pfrmDesc;
+
+        switch(signal->id) {
+        case SIG_PROBE:
+                return Probe(signal);
+
+        case SIG_PROBE_REQ:
+                return ProbeReq(signal);
+
+        case SIQ_PROBE_RSP_BEACON:
+                return ProbeRsp_Beacon(signal);
+
+        default:
+                goto sync_discard;
+        }
+
+sync_discard:
+        pfrmDesc = signal->frmInfo.frmDesc;
+        freeFdesc(pfrmDesc);
+        return TRUE;
+}
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdtkipseed.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdtkipseed.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdtkipseed.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdtkipseed.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,350 @@
+#include "zd80211.h"
+
+#if!defined(AMAC)
+
+/* The Sbox is reduced to 2 16-bit wide tables, each with 256 entries. */
+/* The 2nd table is the same as the 1st but with the upper and lower   */
+/* bytes swapped. To allow an endian tolerant implementation, the byte */
+/* halves have been expressed independently here.                      */
+unsigned int Tkip_Sbox_Lower[256] =
+        {
+                0xA5,0x84,0x99,0x8D,0x0D,0xBD,0xB1,0x54,
+                0x50,0x03,0xA9,0x7D,0x19,0x62,0xE6,0x9A,
+                0x45,0x9D,0x40,0x87,0x15,0xEB,0xC9,0x0B,
+                0xEC,0x67,0xFD,0xEA,0xBF,0xF7,0x96,0x5B,
+                0xC2,0x1C,0xAE,0x6A,0x5A,0x41,0x02,0x4F,
+                0x5C,0xF4,0x34,0x08,0x93,0x73,0x53,0x3F,
+                0x0C,0x52,0x65,0x5E,0x28,0xA1,0x0F,0xB5,
+                0x09,0x36,0x9B,0x3D,0x26,0x69,0xCD,0x9F,
+                0x1B,0x9E,0x74,0x2E,0x2D,0xB2,0xEE,0xFB,
+                0xF6,0x4D,0x61,0xCE,0x7B,0x3E,0x71,0x97,
+                0xF5,0x68,0x00,0x2C,0x60,0x1F,0xC8,0xED,
+                0xBE,0x46,0xD9,0x4B,0xDE,0xD4,0xE8,0x4A,
+                0x6B,0x2A,0xE5,0x16,0xC5,0xD7,0x55,0x94,
+                0xCF,0x10,0x06,0x81,0xF0,0x44,0xBA,0xE3,
+                0xF3,0xFE,0xC0,0x8A,0xAD,0xBC,0x48,0x04,
+                0xDF,0xC1,0x75,0x63,0x30,0x1A,0x0E,0x6D,
+                0x4C,0x14,0x35,0x2F,0xE1,0xA2,0xCC,0x39,
+                0x57,0xF2,0x82,0x47,0xAC,0xE7,0x2B,0x95,
+                0xA0,0x98,0xD1,0x7F,0x66,0x7E,0xAB,0x83,
+                0xCA,0x29,0xD3,0x3C,0x79,0xE2,0x1D,0x76,
+                0x3B,0x56,0x4E,0x1E,0xDB,0x0A,0x6C,0xE4,
+                0x5D,0x6E,0xEF,0xA6,0xA8,0xA4,0x37,0x8B,
+                0x32,0x43,0x59,0xB7,0x8C,0x64,0xD2,0xE0,
+                0xB4,0xFA,0x07,0x25,0xAF,0x8E,0xE9,0x18,
+                0xD5,0x88,0x6F,0x72,0x24,0xF1,0xC7,0x51,
+                0x23,0x7C,0x9C,0x21,0xDD,0xDC,0x86,0x85,
+                0x90,0x42,0xC4,0xAA,0xD8,0x05,0x01,0x12,
+                0xA3,0x5F,0xF9,0xD0,0x91,0x58,0x27,0xB9,
+                0x38,0x13,0xB3,0x33,0xBB,0x70,0x89,0xA7,
+                0xB6,0x22,0x92,0x20,0x49,0xFF,0x78,0x7A,
+                0x8F,0xF8,0x80,0x17,0xDA,0x31,0xC6,0xB8,
+                0xC3,0xB0,0x77,0x11,0xCB,0xFC,0xD6,0x3A};
+
+
+unsigned int Tkip_Sbox_Upper[256] =
+        {
+                0xC6,0xF8,0xEE,0xF6,0xFF,0xD6,0xDE,0x91,
+                0x60,0x02,0xCE,0x56,0xE7,0xB5,0x4D,0xEC,
+                0x8F,0x1F,0x89,0xFA,0xEF,0xB2,0x8E,0xFB,
+                0x41,0xB3,0x5F,0x45,0x23,0x53,0xE4,0x9B,
+                0x75,0xE1,0x3D,0x4C,0x6C,0x7E,0xF5,0x83,
+                0x68,0x51,0xD1,0xF9,0xE2,0xAB,0x62,0x2A,
+                0x08,0x95,0x46,0x9D,0x30,0x37,0x0A,0x2F,
+                0x0E,0x24,0x1B,0xDF,0xCD,0x4E,0x7F,0xEA,
+                0x12,0x1D,0x58,0x34,0x36,0xDC,0xB4,0x5B,
+                0xA4,0x76,0xB7,0x7D,0x52,0xDD,0x5E,0x13,
+                0xA6,0xB9,0x00,0xC1,0x40,0xE3,0x79,0xB6,
+                0xD4,0x8D,0x67,0x72,0x94,0x98,0xB0,0x85,
+                0xBB,0xC5,0x4F,0xED,0x86,0x9A,0x66,0x11,
+                0x8A,0xE9,0x04,0xFE,0xA0,0x78,0x25,0x4B,
+                0xA2,0x5D,0x80,0x05,0x3F,0x21,0x70,0xF1,
+                0x63,0x77,0xAF,0x42,0x20,0xE5,0xFD,0xBF,
+                0x81,0x18,0x26,0xC3,0xBE,0x35,0x88,0x2E,
+                0x93,0x55,0xFC,0x7A,0xC8,0xBA,0x32,0xE6,
+                0xC0,0x19,0x9E,0xA3,0x44,0x54,0x3B,0x0B,
+                0x8C,0xC7,0x6B,0x28,0xA7,0xBC,0x16,0xAD,
+                0xDB,0x64,0x74,0x14,0x92,0x0C,0x48,0xB8,
+                0x9F,0xBD,0x43,0xC4,0x39,0x31,0xD3,0xF2,
+                0xD5,0x8B,0x6E,0xDA,0x01,0xB1,0x9C,0x49,
+                0xD8,0xAC,0xF3,0xCF,0xCA,0xF4,0x47,0x10,
+                0x6F,0xF0,0x4A,0x5C,0x38,0x57,0x73,0x97,
+                0xCB,0xA1,0xE8,0x3E,0x96,0x61,0x0D,0x0F,
+
+                0xE0,0x7C,0x71,0xCC,0x90,0x06,0xF7,0x1C,
+                0xC2,0x6A,0xAE,0x69,0x17,0x99,0x3A,0x27,
+                0xD9,0xEB,0x2B,0x22,0xD2,0xA9,0x07,0x33,
+                0x2D,0x3C,0x15,0xC9,0x87,0xAA,0x50,0xA5,
+                0x03,0x59,0x09,0x1A,0x65,0xD7,0x84,0xD0,
+                0x82,0x29,0x5A,0x1E,0x7B,0xA8,0x6D,0x2C};
+
+
+unsigned int tkip_sbox(unsigned int index)
+/************************************************************/
+/* tkip_sbox()                                              */
+/* Returns a 16 bit value from a 64K entry table. The Table */
+/* is synthesized from two 256 entry byte wide tables.      */
+/************************************************************/
+{
+        unsigned int index_low;
+        unsigned int index_high;
+        unsigned int left, right;
+
+        index_low = (index & 0xFF);
+        index_high = ((index >> 8) & 0xFF);
+
+        left = Tkip_Sbox_Lower[index_low] + (Tkip_Sbox_Upper[index_low] << 8);
+        right = Tkip_Sbox_Upper[index_high] + (Tkip_Sbox_Lower[index_high] << 8);
+        return (left ^ right);
+}
+
+
+unsigned int rotr1(unsigned int a)
+// rotate right by 1 bit.
+{
+        unsigned int b;
+
+        if (a & 0x01)
+        {
+                b = (a >> 1) | 0x8000;
+        } else
+        {
+                b = (a >> 1) & 0x7fff;
+        }
+
+        return b;
+}
+
+
+/***********************************************************************/
+/*                                                                     */
+/*   FUNCTION DESCRIPTION                   Tkip_clear                 */
+/*                                                                     */
+/*   clear all variable used in tkip seed generation function          */
+/*                                                                     */
+/*   AUTHOR                                                            */
+/*     Liam,Hwu            ZyDAS Technology   Corporation              */
+/*                                                                     */
+/***********************************************************************/
+void Tkip_clear(Seedvar *Seed)
+{
+        memset(Seed, 0, sizeof(Seedvar));
+        //	Seed->IV16=1; // According to WPA std Ver2.0 8.3.2.4.4, TSC should be
+        // initialized to one.
+        return;
+}
+
+
+/***********************************************************************/
+/*                                                                     */
+/*   FUNCTION DESCRIPTION                   Tkip_setkey                */
+/*                                                                     */
+/*   Set Temporal key(TK) and Transmitter Address(TA)                  */
+/*                                                                     */
+/*   AUTHOR                                                            */
+/*     Liam,Hwu            ZyDAS Technology   Corporation              */
+/*                                                                     */
+/***********************************************************************/
+void Tkip_setkey(U8 * key, U8 *ta, Seedvar *Seed)
+{
+        memcpy(Seed->TA, ta, 6);
+        memcpy(Seed->TK, key, 16);
+}
+
+
+/***********************************************************************/
+/*                                                                     */
+/*   FUNCTION DESCRIPTION                   Tkip_Init                  */
+/*                                                                     */
+/*   TKIP seed generation function initialization routine              */
+/*                                                                     */
+/*   AUTHOR                                                            */
+/*     Liam,Hwu            ZyDAS Technology   Corporation              */
+/*                                                                     */
+/***********************************************************************/
+void Tkip_Init(U8 *key, U8 *ta, Seedvar *Seed, U8 *initiv)
+{
+        U16  iv16;
+        U32 iv32;
+        int i;
+
+        Tkip_clear(Seed);
+        Tkip_setkey(key, ta, Seed);
+
+        iv16 = *initiv++;
+        iv16 += *initiv << 8;
+        initiv++;
+        iv32 = 0;
+
+        for (i=0; i<4; i++) {	// initiv is little endian
+                iv32 += *initiv << (i*8);
+                *initiv++;
+        }
+
+        Seed->IV32 = iv32+1; // Force Recaculating on Tkip Phase1
+        Tkip_phase1_key_mix(iv32, Seed);
+
+        Seed->IV16 = iv16;
+        Seed->IV32 = iv32;
+}
+
+
+
+/***********************************************************************/
+/*                                                                     */
+/*   FUNCTION DESCRIPTION                   Tkip_phase1_key_mix        */
+/*                                                                     */
+/*   TKIP seed generation function for phase1 key mixing               */
+/*                                                                     */
+/*   AUTHOR                                                            */
+/*     Liam,Hwu            ZyDAS Technology   Corporation              */
+/*   Return value:													   */
+/*		Return TRUE if expected IV sequence is correct.	               */
+/*                                                                     */
+/***********************************************************************/
+char Tkip_phase1_key_mix(U32 iv32, Seedvar *Seed)
+{
+        unsigned short tsc0;
+        unsigned short tsc1;
+        int i, j;
+
+        if (iv32 == Seed->IV32)    //don't need to proceed this function the same
+                return 1;
+        else {
+                tsc0 = (unsigned short)((iv32 >> 16) & 0xffff); /* msb */
+                tsc1 = (unsigned short)(iv32 & 0xffff);
+
+                /* Phase 1, step 1 */
+                Seed->TTAK[0] = tsc1;
+                Seed->TTAK[1] = tsc0;
+                Seed->TTAK[2] = (unsigned short)(Seed->TA[0] + (Seed->TA[1] <<8));
+                Seed->TTAK[3] = (unsigned short)(Seed->TA[2] + (Seed->TA[3] <<8));
+                Seed->TTAK[4] = (unsigned short)(Seed->TA[4] + (Seed->TA[5] <<8));
+
+                /* Phase 1, step 2 */
+                for (i=0; i<8; i++) {
+                        j = 2*(i & 1);
+                        Seed->TTAK[0] = (Seed->TTAK[0] + tkip_sbox(Seed->TTAK[4]
+                                         ^ Mk16(Seed->TK[1+j],Seed->TK[j]))) & 0xffff;
+                        Seed->TTAK[1] = (Seed->TTAK[1] + tkip_sbox(Seed->TTAK[0]
+                                         ^ Mk16(Seed->TK[5+j],Seed->TK[4+j] ))) & 0xffff;
+                        Seed->TTAK[2] = (Seed->TTAK[2] + tkip_sbox(Seed->TTAK[1]
+                                         ^ Mk16(Seed->TK[9+j],Seed->TK[8+j] ))) & 0xffff;
+                        Seed->TTAK[3] = (Seed->TTAK[3] + tkip_sbox(Seed->TTAK[2]
+                                         ^ Mk16(Seed->TK[13+j],Seed->TK[12+j])))& 0xffff;
+                        Seed->TTAK[4] = (Seed->TTAK[4] + tkip_sbox(Seed->TTAK[3]
+                                         ^ Mk16(Seed->TK[1+j] ,Seed->TK[j]  ))) & 0xffff;
+                        Seed->TTAK[4] = (Seed->TTAK[4] + i) & 0xffff;
+                }
+
+                if (iv32 == (Seed->IV32+1)) {
+                        Seed->iv32tmp = iv32;
+                        return 1;
+                } else
+                        return 0;
+        }
+}
+
+
+/***********************************************************************/
+/*                                                                     */
+/*   FUNCTION DESCRIPTION                   Tkip_phase2_key_mix        */
+/*                                                                     */
+/*   TKIP seed generation function for phase2 key mixing               */
+/*                                                                     */
+/*   AUTHOR                                                            */
+/*     Liam,Hwu            ZyDAS Technology   Corporation              */
+/*   Return value:													   */
+/*		Return TRUE if expected IV sequence is correct.	               */
+/*                                                                     */
+/***********************************************************************/
+char Tkip_phase2_key_mix(U16 iv16, Seedvar *Seed)
+{
+        unsigned int tsc2;
+
+        tsc2 = iv16;
+        /* Phase 2, Step 1 */
+        Seed->ppk[0] = Seed->TTAK[0];
+        Seed->ppk[1] = Seed->TTAK[1];
+        Seed->ppk[2] = Seed->TTAK[2];
+        Seed->ppk[3] = Seed->TTAK[3];
+        Seed->ppk[4] = Seed->TTAK[4];
+        Seed->ppk[5] = (Seed->TTAK[4] + tsc2) & 0xffff;
+
+        /* Phase2, Step 2 */
+        Seed->ppk[0] = Seed->ppk[0] + tkip_sbox(Seed->ppk[5] ^ Mk16(Seed->TK[1],Seed->TK[0])) ;
+        Seed->ppk[1] = Seed->ppk[1] + tkip_sbox(Seed->ppk[0] ^ Mk16(Seed->TK[3],Seed->TK[2])) ;
+        Seed->ppk[2] = Seed->ppk[2]	+ tkip_sbox(Seed->ppk[1] ^ Mk16(Seed->TK[5],Seed->TK[4])) ;
+        Seed->ppk[3] = Seed->ppk[3]	+ tkip_sbox(Seed->ppk[2] ^ Mk16(Seed->TK[7],Seed->TK[6])) ;
+        Seed->ppk[4] = Seed->ppk[4]	+ tkip_sbox(Seed->ppk[3] ^ Mk16(Seed->TK[9],Seed->TK[8] )) ;
+        Seed->ppk[5] = Seed->ppk[5]	+ tkip_sbox(Seed->ppk[4] ^ Mk16(Seed->TK[11],Seed->TK[10])) ;
+
+        Seed->ppk[0] = Seed->ppk[0]	+ rotr1(Seed->ppk[5] ^ Mk16(Seed->TK[13],Seed->TK[12]));
+        Seed->ppk[1] = Seed->ppk[1]	+ rotr1(Seed->ppk[0] ^ Mk16(Seed->TK[15],Seed->TK[14]));
+        Seed->ppk[2] = Seed->ppk[2] + rotr1(Seed->ppk[1]);
+        Seed->ppk[3] = Seed->ppk[3] + rotr1(Seed->ppk[2]);
+        Seed->ppk[4] = Seed->ppk[4] + rotr1(Seed->ppk[3]);
+        Seed->ppk[5] = Seed->ppk[5] + rotr1(Seed->ppk[4]);
+
+        if (iv16 == 0) {
+                if (Seed->IV16 == 0xffff) {
+                        Seed->iv16tmp = 0;
+                        return 1;
+                } else
+                        return 0;
+        } else if (iv16 == (Seed->IV16+1)) {
+                Seed->iv16tmp = iv16;
+                return 1;
+        } else
+                return 0;
+}
+
+
+/***********************************************************************/
+/*                                                                     */
+/*   FUNCTION DESCRIPTION                   Tkip_getseeds              */
+/*                                                                     */
+
+/*   Get RC4Key seeds generated by TKIP                                */
+/*                                                                     */
+/*   AUTHOR                                                            */
+/*     Liam,Hwu            ZyDAS Technology   Corporation              */
+/*                                                                     */
+/***********************************************************************/
+void Tkip_getseeds(U16 iv16, U8 *RC4Key, Seedvar *Seed)
+{
+        RC4Key[0]  = Hi8(iv16);
+        RC4Key[1]  = (Hi8(iv16) | 0x20) & 0x7f;
+        RC4Key[2]  = Lo8(iv16);
+        RC4Key[3]  = ((Seed->ppk[5] ^ Mk16(Seed->TK[1],Seed->TK[0]))>>1) & 0xff;
+        RC4Key[4]  = Seed->ppk[0] & 0xff;
+        RC4Key[5]  = Seed->ppk[0] >> 8  ;
+        RC4Key[6]  = Seed->ppk[1] & 0xff;
+        RC4Key[7]  = Seed->ppk[1] >> 8  ;
+        RC4Key[8]  = Seed->ppk[2] & 0xff;
+        RC4Key[9]  = Seed->ppk[2] >> 8  ;
+        RC4Key[10] = Seed->ppk[3] & 0xff;
+        RC4Key[11] = Seed->ppk[3] >> 8  ;
+        RC4Key[12] = Seed->ppk[4] & 0xff;
+        RC4Key[13] = Seed->ppk[4] >> 8  ;
+        RC4Key[14] = Seed->ppk[5] & 0xff;
+        RC4Key[15] = Seed->ppk[5] >> 8  ;
+}
+
+
+/***********************************************************************/
+/*                                                                     */
+/*   FUNCTION DESCRIPTION                   Tkip_updateiv              */
+/*                                                                     */
+/*   update stored iv value                                            */
+/*                                                                     */
+/*   AUTHOR                                                            */
+/*     Liam,Hwu            ZyDAS Technology   Corporation              */
+/*                                                                     */
+/***********************************************************************/
+void Tkip_updateiv(Seedvar *Seed)
+{
+        Seed->IV16 = Seed->iv16tmp;
+        Seed->IV32 = Seed->iv32tmp;
+}
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdtkipseed.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdtkipseed.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdtkipseed.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdtkipseed.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,58 @@
+#ifndef _ZDTKIPSEED_H_
+#define _ZDTKIPSEED_H_
+
+
+#define Mk16(A, B) 	((A<<8)+B)
+
+#define Lo8(v16)  ((U8)( (v16) & 0xFF))
+#define Hi8(v16)  ((U8)(((v16)>>8) & 0xFF))
+
+
+//variable.
+typedef struct _Seedvar
+{
+        U8		TK[16];		// Key
+        U8		TA[6];
+        U16		TTAK[5];	// TTAK
+        U16		ppk[6];
+        U16		IV16, iv16tmp;
+        U32		IV32, iv32tmp;
+}
+Seedvar, *PSeedvar;
+
+#define Tx  0
+#define Rx  1
+
+#if defined(PHY_1202)
+
+void Tkip_Init(U8 *key, U8 *ta, Seedvar *Seed, U8 *initiv);
+void Tkip_clear(Seedvar *Seed);
+
+// set key and TA
+void Tkip_setkey(U8 *key, U8 *ta, Seedvar *Seed);
+
+// phase1 key mixing function
+char Tkip_phase1_key_mix(U32 IV32, Seedvar *Seed);
+
+// phase2 key mixing function
+char Tkip_phase2_key_mix(U16 IV16, Seedvar *Seed);
+
+// get generated seeds
+void Tkip_getseeds(U16 IV16, U8 *RC4Key, Seedvar *Seed);
+
+// update stored IV.
+void Tkip_updateiv(Seedvar *Seed);
+
+
+/************************************************************/
+/* tkip_sbox()                                              */
+/* Returns a 16 bit value from a 64K entry table. The Table */
+/* is synthesized from two 256 entry byte wide tables.      */
+/************************************************************/
+unsigned int tkip_sbox(unsigned int index);
+
+// rotate right by 1 bit.
+unsigned int rotr1(unsigned int a);
+
+#endif
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdtypes.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdtypes.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdtypes.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdtypes.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,36 @@
+#ifndef __ZDTYPES_H__
+#define __ZDTYPES_H__
+
+#ifndef U8
+typedef unsigned char U8;
+#endif
+
+#ifndef	 U16
+
+typedef unsigned short U16;
+#endif
+
+#ifndef U32
+
+typedef unsigned long U32;
+#endif
+
+#ifndef U64
+
+typedef unsigned long long U64;
+#endif
+
+#ifndef BOOLEAN
+
+typedef U8 BOOLEAN;
+#endif
+
+#ifndef TRUE
+	#define TRUE 	1
+#endif
+
+#ifndef FALSE
+	#define FALSE 	0
+#endif
+
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdusb.c linux-2.4.35.3-mct/drivers/usb/zd1211/zdusb.c
--- linux-2.4.35.3/drivers/usb/zd1211/zdusb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdusb.c	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,430 @@
+/* src/zdusb.c
+*
+* Implements the functions of the ZyDAS zd1211 MAC
+*
+* Copyright (C) 2004 ZyDAS Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+*
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* -------------------------------------------------------------------- */
+
+#include <linux/version.h>
+
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+
+#include <linux/module.h>
+
+#include <linux/usb.h>
+
+#include "zd1205.h"
+#include "zdusb.h"
+#include "zddebug.h"
+#include "zdversion.h"
+#include "zd1211.h"
+
+#define ZD1211_DBG_LEVEL    1
+
+MODULE_AUTHOR("Yarco Yang");
+MODULE_DESCRIPTION("ZyDAS 802.11b/g USB Wireless LAN adapter");
+MODULE_LICENSE("GPL");
+
+#ifdef ZD1211
+static const char driver_name[] = "zd1211";
+#elif defined(ZD1211B)
+static const char driver_name[] = "zd1211b";
+#endif
+
+
+/* table of devices that work with this driver */
+static struct usb_device_id zd1211_ids [] =
+        {
+#ifdef ZD1211B
+                { USB_DEVICE(VENDOR_ZYDAS, 0x1215) },
+#elif defined(ZD1211)
+                /* ath_desc: more USB ids */
+                { USB_DEVICE(0x0586, 0x3401) }, // Zyxel ZyAIR G-220
+                { USB_DEVICE(0x0675, 0x0550) }, // DrayTek Vigor 550
+                { USB_DEVICE(0x079b, 0x004a) }, // Sagem XG 760A
+                { USB_DEVICE(0x07b8, 0x6001) }, // AOpen 802.11g WL54
+                { USB_DEVICE(0x0ace, 0x1211) }, // Airlink+ AWLL3025, X-Micro XWL-11GUZX, Edimax EW-7317UG, Planet WL-U356, Acer WLAN-G-US1, Trendnet TEW-424UB
+                { USB_DEVICE(0x0b05, 0x170c) }, // Asus WL-159g
+                { USB_DEVICE(0x0b3b, 0x5630) }, // Tekram/Siemens USB adapter
+                { USB_DEVICE(0x0df6, 0x9071) }, // Sitecom WL-113
+                { USB_DEVICE(0x0b3b, 0x1630) }, // Yakumo QuickWLAN USB
+                { USB_DEVICE(0x126f, 0xa006) }, // TwinMOS G240
+                { USB_DEVICE(0x129b, 0x1666) }, // Telegent TG54USB
+                { USB_DEVICE(0x1435, 0x0711) }, // iNexQ UR055g
+                { USB_DEVICE(0x14ea, 0xab13) }, // Planex GW-US54Mini
+                { USB_DEVICE(0x157e, 0x300b) }, // Trendnet TEW-429UB
+                { USB_DEVICE(0x2019, 0xc007) }, // Planex GW-US54GZL
+                { USB_DEVICE(0x5173, 0x1809) }, // Sweex wireless USB 54 Mbps
+                { USB_DEVICE(0x6891, 0xa727) }, // 3COM 3CRUSB10075
+                { USB_DEVICE(VENDOR_ZYDAS, PRODUCT_A211) },
+#endif
+                { }					/* Terminating entry */
+        };
+
+
+MODULE_DEVICE_TABLE(usb, zd1211_ids);
+
+
+extern struct net_device *g_dev;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+static void *zd1211_probe(struct usb_device *dev, unsigned int ifnum,
+                          const struct usb_device_id *id)
+#else
+static int zd1211_probe(struct usb_interface *interface,
+                        const struct usb_device_id *id)
+#endif
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+        struct usb_interface *interface = &dev->actconfig->interface[ifnum];
+#else
+
+        struct usb_device *dev = interface_to_usbdev(interface);
+        int locked;
+#endif
+
+        struct net_device *net = NULL;
+        struct zd1205_private *macp = NULL;
+        int vendor_id, product_id;
+        int dev_index = id - zd1211_ids;
+        int result = 0;
+
+       /* ath_desc: workaround for detecting device multiple times */
+       /* Driver doesn't support multiple devices:-( When it does,
+        * global variables like g_dev will go, and so will this test. */
+       if (g_dev) {
+               printk(KERN_ERR "%s is called again. Either you have multiple zd1211 devices, which\n"
+                      "is unsupported, or your device is doubly detected, which is a bug.\n", __FUNCTION__);
+               result = -EBUSY;
+               goto exit;
+       }
+
+        //char serial_number[30];
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+
+        usb_get_dev(dev);
+#endif
+
+        /* ath_desc: bigendian support */
+        /* ath: USB config fields are le16 on kernels >= 2.6.11 only */
+        /* ath: see Greg Kroah-Hartman, http://kernel.org/pub/linux/kernel/v2.6/testing/ChangeLog-2.6.11-rc1 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11))
+        vendor_id = le16_to_cpu(dev->descriptor.idVendor);
+        product_id = le16_to_cpu(dev->descriptor.idProduct);
+#else
+        vendor_id = dev->descriptor.idVendor;
+        product_id = dev->descriptor.idProduct;
+#endif
+
+#ifdef HMAC_DEBUG
+
+        printk(KERN_NOTICE "vendor_id = %04x\n", vendor_id);
+        printk(KERN_NOTICE "product_id = %04x\n", product_id);
+
+        if (dev->speed == USB_SPEED_HIGH)
+                printk(KERN_NOTICE "USB 2.0 Host\n");
+        else
+                printk(KERN_NOTICE "USB 1.1 Host\n");
+#endif
+
+        //memset(serial_number, 0, 30);
+        //usb_string(dev, dev->descriptor.iSerialNumber, serial_number, 29);
+        //printk("Device serial number is %s\n", serial_number);
+
+        // The running firmware seems to "block" ep0.
+        // To avoid timeouts during insmod on ep0 and
+        //   the inability to subsequently reload the driver properly,
+        //   put the device in its initial state.
+        // Since resetting the device is probably a bit crude,
+        //   we do it before the device gets to do any useful work.
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+        usb_reset_device(dev);
+#else
+        locked = usb_lock_device_for_reset(interface_to_usbdev(interface), interface);
+        if (locked >= 0)
+                usb_reset_device(interface_to_usbdev(interface));
+        if (locked > 0)
+                usb_unlock_device(interface_to_usbdev(interface));
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+
+        if (usb_set_configuration(dev, dev->config[0].bConfigurationValue))
+        {
+                printk(KERN_ERR "usb_set_configuration() failed\n");
+                result = -EIO;
+                goto fail;
+        }
+#endif
+
+#if 1
+        //kernel 2.6
+        if (!(macp = kmalloc(sizeof(struct zd1205_private), GFP_KERNEL)))
+        {
+                printk(KERN_ERR "out of memory allocating device structure\n");
+                result = -ENOMEM;
+                goto fail;
+        }
+
+        memset(macp, 0, sizeof(struct zd1205_private));
+        /* ath_desc: fix timer-related race conditions */
+        init_timer(&macp->tm_chal_id);
+        init_timer(&macp->tm_scan_id);
+        init_timer(&macp->tm_auth_id);
+        init_timer(&macp->tm_asoc_id);
+#endif
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+
+        usb_inc_dev_use(dev);
+#endif
+
+        net = alloc_etherdev(0);  //kernel 2.6
+        //net = alloc_etherdev(sizeof (struct zd1205_private));  //kernel 2.4
+
+        if (!net)
+        {
+                printk(KERN_ERR "zd1211: Not able to alloc etherdev struct\n");
+                result = -ENOMEM;
+                goto fail1;
+        }
+
+        g_dev = net;  //save this for CBs use
+        //macp = net->priv; //kernel 2.4
+        net->priv = macp;   //kernel 2.6
+
+        /* ath_desc: use /dev/wlanX as device node */
+        strcpy(net->name, "wlan%d");
+
+        macp->device = net;
+        macp->usb = dev;
+        SET_MODULE_OWNER(net);
+        macp->dev_index = dev_index;
+        /* ath_desc: bigendian support */
+        /* ath: USB config fields are le16 on kernels >= 2.6.11 only */
+        /* ath: see Greg Kroah-Hartman, http://kernel.org/pub/linux/kernel/v2.6/testing/ChangeLog-2.6.11-rc1 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11))
+        macp->release = le16_to_cpu(dev->descriptor.bcdDevice);
+#else
+        macp->release = dev->descriptor.bcdDevice;
+#endif
+        printk(KERN_NOTICE "Release Ver = %04x\n", macp->release);
+        macp->flags = 0;
+        macp->dbg_flag = ZD1211_DBG_LEVEL;
+
+        /* set up the endpoint information */
+        /* check out the endpoints */
+        macp->interface = interface;
+
+        init_waitqueue_head(&macp->regSet_wait);
+        init_waitqueue_head(&macp->iorwRsp_wait);
+        init_waitqueue_head(&macp->term_wait);
+        init_waitqueue_head(&macp->msdelay);
+
+        if (!zd1211_alloc_all_urbs(macp))
+        {
+                result = -ENOMEM;
+                goto fail2;
+        }
+
+        //zd1211_DownLoadUSBCode(macp, "WS11Uext.bin", NULL, cFIRMWARE_EXT_CODE);
+        if (zd1211_Download_IncludeFile(macp) != 0)
+        {
+                printk(KERN_ERR "zd1211_Download_IncludeFile failed\n");
+                result = -EIO;
+                goto fail3;
+        }
+
+        //to enable firmware
+        //#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+        //	if (usb_set_configuration(dev, dev->config[0].bConfigurationValue)) {
+        //#else
+        //	if (usb_set_interface(dev, interface->altsetting[0].desc.bInterfaceNumber, 	0)){
+        // Use the lowest USBD API to issue set_configuration command.
+        if ((usb_control_msg(dev, usb_sndctrlpipe(dev,0),USB_REQ_SET_CONFIGURATION,0, 1, 0, NULL, 0, HZ))<0)
+        {
+                //#endif
+                printk(KERN_ERR "usb_set_configuration() failed\n");
+                result = -EIO;
+                goto fail3;
+        }
+
+        set_bit(ZD1211_RUNNING, &macp->flags);
+        macp->bUSBDeveiceAttached = 1;
+
+        if (!zd1211_InitSetup(net, macp))
+        {
+                result = -EIO;
+                goto fail3;
+        } else
+        {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+                usb_set_intfdata(interface, macp);
+                SET_NETDEV_DEV(net, &interface->dev);
+                //defer_kevent(macp, KEVENT_REGISTER_NET);
+#endif
+
+#if 1 //don't register net
+
+                if (register_netdev(net) != 0) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+                        usb_set_intfdata(interface, NULL);
+#endif
+
+                        goto fail3;
+                }
+#endif
+
+        }
+
+        goto done;
+
+fail3:
+        zd1211_free_all_urbs(macp);
+
+fail2:
+        free_netdev(net);  //kernel 2.6
+        //kfree(net);
+
+fail1:
+        kfree(macp);
+
+fail:
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+
+        usb_put_dev(dev);
+#endif
+
+        macp = NULL;
+        g_dev = NULL;
+        goto exit;
+done:
+        netif_carrier_off(macp->device);
+exit:
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+
+        return macp;
+#else
+
+        return result;
+#endif
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+static void zd1211_disconnect(struct usb_device *dev, void *ptr)
+#else
+static void zd1211_disconnect(struct usb_interface *interface)
+#endif
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+        struct zd1205_private *macp = (struct zd1205_private *) usb_get_intfdata(interface);
+#else
+
+        struct zd1205_private *macp = (struct zd1205_private *)ptr;
+#endif
+
+        if (!macp)
+        {
+                printk(KERN_ERR "unregistering non-existant device\n");
+                return;
+        }
+
+        printk(KERN_ERR "zd1211_disconnect\n");
+
+        set_bit(ZD1211_UNPLUG, &macp->flags);
+        macp->bUSBDeveiceAttached = 0;
+
+        /* ath_desc: fix module deregistering */
+        //assuming we used keventd, it must quiesce too
+        flush_scheduled_work();
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+        usb_set_intfdata(interface, NULL);
+#endif
+
+        unregister_netdev(macp->device);
+        free_netdev(macp->device);  //kernel 2.6
+
+        if (macp->driver_isolated)
+        {
+                if (macp->device->flags & IFF_UP)
+                        zd1205_close(macp->device);
+        }
+
+        mdelay(1);
+        zd1211_unlink_all_urbs(macp);
+        mdelay(1);
+        zd1211_free_all_urbs(macp);
+        mdelay(1);
+        zd1205_clear_structs(macp->device);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+
+        usb_dec_dev_use(dev);
+#else
+
+        usb_put_dev(interface_to_usbdev(interface));
+#endif
+
+        kfree(macp);
+
+       g_dev = NULL;
+        //ZEXIT(0);
+}
+
+static struct usb_driver zd1211_driver =
+        {
+/* ath_desc: usb_driver.owner is gone in Linux 2.6.16 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16))
+                .owner =		THIS_MODULE,
+#endif
+                          .name =		    driver_name,
+                                       .probe =		zd1211_probe,
+                                                 .disconnect =	zd1211_disconnect,
+                                                               .id_table =	    zd1211_ids,
+                                                                       };
+
+
+int __init zd1211_init(void)
+{
+        /* ath_desc: fix printks */
+        printk(KERN_NOTICE "%s - http://zd1211.ath.cx/\n", DRIVER_NAME);
+        printk(KERN_NOTICE "Based on www.zydas.com.tw driver version %s\n",  VERSIONID);
+        return usb_register(&zd1211_driver);
+}
+
+void __exit zd1211_exit(void)
+{
+        usb_deregister(&zd1211_driver);
+}
+
+module_init(zd1211_init);
+module_exit(zd1211_exit);
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdusb.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdusb.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdusb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdusb.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,22 @@
+#ifndef _ZDUSB_H
+#define _ZDUSB_H
+
+#ifndef DRIVER_NAME
+	#ifdef ZD1211
+		#define DRIVER_NAME             "zd1211"
+	#elif defined(ZD1211B)
+		#define DRIVER_NAME             "ZD1211B"
+	#endif
+#endif
+
+/* Define these values to match your device */
+#define VENDOR_ZYDAS	0x0ACE  //ZyDAS
+#define PRODUCT_1211	0x1211
+#define PRODUCT_A211    0xa211
+#define VENDOR_ZYXEL	0x0586  //ZyXEL
+#define PRODUCT_G220	0x3401
+#define VENDOR_3COM     0x6891
+#define PRODUCT_A727    0xA727
+#define PRODUCT_G220F	0x3402
+
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdutils.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdutils.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdutils.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdutils.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,61 @@
+#ifndef __ZDUTILS_H__
+#define __ZDUTILS_H__
+#include "zdsorts.h"
+
+
+#define isGroup(pMac)			(((U8*)pMac)[0] & 0x01)
+#define eLen(elm)				((elm)->buf[1])
+#define body(f, n) 				((f)->body[n])
+
+
+#define addr1(f)				((MacAddr_t*)&((f)->header[4]))
+#define addr2(f)				((MacAddr_t*)&((f)->header[10]))
+#define addr3(f)				((MacAddr_t*)&((f)->header[16]))
+#define addr4(f)				((MacAddr_t*)&((f)->header[24]))
+#define setAddr1(f, addr)		(memcpy((char*)&((f)->header[4]),  (char*)addr, 6))
+#define setAddr2(f, addr)		(memcpy((char*)&((f)->header[10]), (char*)addr, 6))
+#define setAddr3(f, addr)		(memcpy((char*)&((f)->header[16]), (char*)addr, 6))
+#define setAddr4(f, addr)		(memcpy((char*)&((f)->header[24]), (char*)addr, 6))
+#define setFrameType(f, ft)		do {\
+										f->header[0] = ft;\
+										f->header[1] = 0;\
+								} while (0)
+#define baseType(f)				((f)->header[0] & 0x0C)
+#define frmType(f)				((f)->header[0] & 0xFC)
+
+#define wepBit(f) 				(((f)->header[1] & WEP_BIT) ? 1 : 0)
+#define orderBit(f) 			(((f)->header[1] & ORDER_BIT) ? 1 : 0)
+#define durId(f)				(((f)->header[2]) + ((f)->header[3]*256))
+#define setAid(f, aid)			do {\
+										f->header[2] = (U8)aid;\
+										f->header[3] = ((U8)(aid >> 8) | 0xc0);\
+								} while (0)
+
+#define status(f)  				(body(f, 2) + (body(f, 3) * 256))
+#define authType(f) 			(body(f, 0) + (body(f, 1) * 256))
+#define authSeqNum(f)			(body(f, 2) + (body(f, 3) * 256))
+#define authStatus(f) 			(body(f, 4) + (body(f, 5) * 256))
+#define reason(f)				(body(f, 0) + (body(f, 1) * 256))
+#define listenInt(f)			(body(f, 2) + (body(f, 3) * 256))
+#define cap(f)					(body(f, 0) + (body(f, 1) * 256))
+#define setTs(f, loTm, hiTm)  	do {\
+									body(f, 0) = (U8)loTm;\
+									body(f, 1) = (U8)(loTm >> 8);\
+									body(f, 2) = (U8)(loTm >> 16);\
+									body(f, 3) = (U8)(loTm >> 24);\
+									body(f, 4) = (U8)hiTm;\
+									body(f, 5) = (U8)(hiTm >> 8);\
+									body(f, 6) = (U8)(hiTm >> 16);\
+									body(f, 7) = (U8)(hiTm >> 24);\
+								} while (0)
+#define trafficMap(trafficmap, aid)  (((trafficmap)->t[(aid/8)] & (1<<(7-(aid%8))) ) == 0 ? 0 : 1)
+
+
+#define beaconInt(f)			(body(f, 8) + (body(f, 9) * 256))
+#define cap1(f)					(body(f, 10) + (body(f, 11) * 256))
+#define aid(f)					(body(f, 4) + (body(f, 5) * 256))
+#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
+#define MAC2STR(a) (a)[0],(a)[1],(a)[2],(a)[3],(a)[4],(a)[5]
+
+#endif
+
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zdversion.h linux-2.4.35.3-mct/drivers/usb/zd1211/zdversion.h
--- linux-2.4.35.3/drivers/usb/zd1211/zdversion.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zdversion.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,6 @@
+#ifndef _ZD_VERSION_H_
+#define _ZD_VERSION_H_
+
+#define VERSIONID   "2.4.0.0"
+
+#endif
diff -Naru linux-2.4.35.3/drivers/usb/zd1211/zydas_common.h linux-2.4.35.3-mct/drivers/usb/zd1211/zydas_common.h
--- linux-2.4.35.3/drivers/usb/zd1211/zydas_common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.35.3-mct/drivers/usb/zd1211/zydas_common.h	2007-10-03 13:14:27.000000000 +0200
@@ -0,0 +1,71 @@
+#ifndef ZYDAS_COMMON_H
+#define ZYDAS_COMMON_H
+
+#define ZD_IOCTL_WPA			(SIOCDEVPRIVATE + 1)
+#define ZD_IOCTL_PARAM			(SIOCDEVPRIVATE + 2)
+
+#define ZD_PARAM_ROAMING		0x0001
+#define ZD_PARAM_PRIVACY		0x0002
+#define ZD_PARAM_WPA			0x0003
+#define ZD_PARAM_COUNTERMEASURES	0x0004
+#define ZD_PARAM_DROPUNENCRYPTED	0x0005
+#define ZD_PARAM_AUTH_ALGS		0x0006
+
+#define ZD_CMD_SET_ENCRYPT_KEY		0x0001
+#define ZD_CMD_SET_MLME			0x0002
+#define ZD_CMD_SCAN_REQ			0x0003
+#define ZD_CMD_SET_GENERIC_ELEMENT	0x0004
+
+#define ZD_FLAG_SET_TX_KEY              0x0001
+
+#define ZD_GENERIC_ELEMENT_HDR_LEN \
+((int) (&((struct zydas_wlan_param *) 0)->u.generic_elem.data))
+
+#define ZD_CRYPT_ALG_NAME_LEN		16
+#define ZD_MAX_KEY_SIZE			32
+#define ZD_MAX_GENERIC_SIZE		64
+
+/* structure definition */
+
+struct zydas_wlan_param
+{
+        u32 cmd;
+        u8 sta_addr[ETH_ALEN];
+        union {
+                struct {
+                        u8 alg[ZD_CRYPT_ALG_NAME_LEN];
+                        u32 flags;
+                        u32 err;
+                        u8 idx;
+                        u8 seq[8]; /* sequence counter (set: RX, get: TX) */
+                        u16 key_len;
+                        u8 key[ZD_MAX_KEY_SIZE];
+                }
+                crypt;
+                struct {
+                        u32 flags_and;
+                        u32 flags_or;
+                }
+                set_flags_sta;
+                struct {
+                        u8 len;
+                        u8 data[ZD_MAX_GENERIC_SIZE];
+                }
+                generic_elem;
+                struct {
+#define MLME_STA_DEAUTH 0
+#define MLME_STA_DISASSOC 1
+                        u16 cmd;
+                        u16 reason_code;
+                }
+                mlme;
+                struct {
+                        u8 ssid_len;
+                        u8 ssid[32];
+                }
+                scan_req;
+        } u;
+};
+
+#endif
+
