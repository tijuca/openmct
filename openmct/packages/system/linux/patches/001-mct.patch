diff -Naru linux-2.4.32/Makefile linux-2.4.32-mct/Makefile
--- linux-2.4.32/Makefile	2005-11-16 20:12:54.000000000 +0100
+++ linux-2.4.32-mct/Makefile	2006-12-02 15:08:43.000000000 +0100
@@ -1,11 +1,11 @@
 VERSION = 2
 PATCHLEVEL = 4
 SUBLEVEL = 32
-EXTRAVERSION =
+EXTRAVERSION = -mct
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
-ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
+ARCH := mips
 KERNELPATH=kernel-$(shell echo $(KERNELRELEASE) | sed -e "s/-//g")
 
 CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
@@ -17,7 +17,7 @@
 FINDHPATH	= $(HPATH)/asm $(HPATH)/linux $(HPATH)/scsi $(HPATH)/net $(HPATH)/math-emu
 
 HOSTCC  	= gcc
-HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
+HOSTCFLAGS	= -Wall -Wstrict-prototypes -Os -fomit-frame-pointer
 
 CROSS_COMPILE 	=
 
@@ -91,7 +91,7 @@
 
 CPPFLAGS := -D__KERNEL__ -I$(HPATH)
 
-CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -Wno-trigraphs -O2 \
+CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -Wno-trigraphs -Os \
 	  -fno-strict-aliasing -fno-common
 ifndef CONFIG_FRAME_POINTER
 CFLAGS += -fomit-frame-pointer
@@ -201,7 +201,7 @@
 # files removed with 'make clean'
 CLEAN_FILES = \
 	kernel/ksyms.lst include/linux/compile.h \
-	vmlinux System.map \
+	vmlinux vmlinux.bin System.map \
 	.tmp* \
 	drivers/char/consolemap_deftbl.c drivers/video/promcon_tbl.c \
 	drivers/char/conmakehash \
@@ -294,6 +294,7 @@
 		$(LIBS) \
 		--end-group \
 		-o vmlinux
+	$(OBJCOPY) -g -O binary vmlinux vmlinux.bin
 	$(NM) vmlinux | grep -v '\(compiled\)\|\(\.o$$\)\|\( [aUw] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | sort > System.map
 
 symlinks:
diff -Naru linux-2.4.32/arch/mips/Makefile linux-2.4.32-mct/arch/mips/Makefile
--- linux-2.4.32/arch/mips/Makefile	2005-01-19 15:09:26.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/Makefile	2006-12-02 15:08:43.000000000 +0100
@@ -46,8 +46,8 @@
 GCCFLAGS	:= -I $(TOPDIR)/include/asm/gcc
 GCCFLAGS	+= -G 0 -mno-abicalls -fno-pic -pipe
 GCCFLAGS	+= $(call check_gcc, -finline-limit=100000,)
-LINKFLAGS	+= -G 0 -static -n
-MODFLAGS	+= -mlong-calls
+LINKFLAGS	+= -G 0 -static -n -nostdlib
+MODFLAGS	+= -mlong-calls -fno-common
 
 ifdef CONFIG_DEBUG_INFO
 GCCFLAGS	+= -g
@@ -714,6 +714,44 @@
 LOADADDR      += 0x80020000
 endif
 
+ifdef CONFIG_MCT_BOARDS
+LIBS            += arch/mips/mct-boards/generic/mctboards.a
+SUBDIRS         += arch/mips/mct-boards/generic
+CORE_FILES	+= arch/mips/mct-boards/generic/proc.o
+LOADADDR        += 0x80020000
+
+ifdef CONFIG_MCT_SG100
+CORE_FILES      += arch/mips/mct-boards/sgx00/sgx00.o
+SUBDIRS         += arch/mips/mct-boards/sgx00
+FLASHSIZE       = 0x400000
+endif
+ifdef CONFIG_MCT_SG600
+CORE_FILES      += arch/mips/mct-boards/sgx00/sgx00.o
+SUBDIRS         += arch/mips/mct-boards/sgx00
+FLASHSIZE       = 0x400000
+endif
+ifdef CONFIG_MCT_SA100
+CORE_FILES      += arch/mips/mct-boards/sgx00/sgx00.o
+SUBDIRS         += arch/mips/mct-boards/sgx00
+FLASHSIZE       = 0x400000
+endif
+ifdef CONFIG_MCT_SG4100
+CORE_FILES      += arch/mips/mct-boards/sg4x00/sg4x00.o
+SUBDIRS         += arch/mips/mct-boards/sg4x00
+FLASHSIZE       = 0x200000
+endif
+ifdef CONFIG_MCT_SA200
+CORE_FILES      += arch/mips/mct-boards/sg4x00/sg4x00.o
+SUBDIRS         += arch/mips/mct-boards/sg4x00
+ifdef CONFIG_MCT_FLASH_8MB
+FLASHSIZE       = 0x800000
+else
+FLASHSIZE       = 0x400000
+endif
+endif
+endif
+
+
 #
 # Choosing incompatible machines durings configuration will result in
 # error messages during linking.  Select a default linkscript if
@@ -722,7 +760,7 @@
 vmlinux: arch/$(ARCH)/ld.script
 
 arch/$(ARCH)/ld.script: arch/$(ARCH)/ld.script.in arch/$(ARCH)/Makefile
-	sed -e 's/@@LOADADDR@@/$(LOADADDR)/' <$< >$@
+	sed -e 's/@@LOADADDR@@/$(LOADADDR)/' -e 's/@@FLASHSIZE@@/$(FLASHSIZE)/' <$< >$@
 LINKFLAGS	+= -T arch/$(ARCH)/ld.script
 
 HEAD := arch/mips/kernel/head.o arch/mips/kernel/init_task.o
diff -Naru linux-2.4.32/arch/mips/config-shared.in linux-2.4.32-mct/arch/mips/config-shared.in
--- linux-2.4.32/arch/mips/config-shared.in	2005-01-19 15:09:27.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/config-shared.in	2006-12-02 15:08:43.000000000 +0100
@@ -214,6 +214,31 @@
 
 dep_bool 'Support for Toshiba JMR-TX3927 board' CONFIG_TOSHIBA_JMR3927 $CONFIG_MIPS32
 bool 'Support for Toshiba RBTX49[23]7 Reference Board' CONFIG_TOSHIBA_RBTX4927
+bool 'Support for MCT SG100' CONFIG_MCT_SG100
+bool 'Support for MCT SG600' CONFIG_MCT_SG600
+if [ "$CONFIG_MCT_SG600" = "y" ]; then
+   bool '    Support for Single NAS' CONFIG_MCT_NAS
+fi
+bool 'Support for MCT SG4100' CONFIG_MCT_SG4100
+if [ "$CONFIG_MCT_SG4100" = "y" ]; then
+   bool '    SG4100 EVBOARD' CONFIG_MCT_SG4100_EV
+   bool '    Support for Single NAS' CONFIG_MCT_NAS
+fi
+bool 'Support for MCT SA100' CONFIG_MCT_SA100
+if [ "$CONFIG_MCT_SA100" = "y" ]; then
+   bool '    Support for Single NAS' CONFIG_MCT_NAS
+   bool '    Support ATEN_LED' CONFIG_ATEN_LED
+fi
+bool 'Support for MCT SA200' CONFIG_MCT_SA200
+if [ "$CONFIG_MCT_SA200" = "y" ]; then
+   bool '    support 8MB flash' CONFIG_MCT_FLASH_8MB
+   bool '    64MB SDRAM'  CONFIG_TX49_SDRAM_64MB
+   bool '    Support for Single NAS' CONFIG_MCT_NAS
+   bool '    Support ATEN_LED' CONFIG_ATEN_LED
+   bool '    Support 4PORT USB SERVER' CONFIG_4PORT_USB_SERVER
+fi
+
+bool 'Support for MCT HD ENCRYPTION' CONFIG_MCT_HD_ENCRYPTION
 bool 'Support for Victor MP-C303/304' CONFIG_VICTOR_MPC30X
 if [ "$CONFIG_VICTOR_MPC30X" = "y" ]; then
    tristate '  NEC VRC4173 support' CONFIG_VRC4173
@@ -567,6 +592,22 @@
    define_bool CONFIG_ISA y
    define_bool CONFIG_NONCOHERENT_IO y
 fi
+# Magic Control Techonology Boards
+if [ "$CONFIG_MCT_SG100" = "y" -o \
+     "$CONFIG_MCT_SG600" = "y" -o \
+     "$CONFIG_MCT_SA100" = "y" -o \
+     "$CONFIG_MCT_SA200" = "y" -o \
+     "$CONFIG_MCT_SG4100" = "y" ]; then
+   define_bool CONFIG_MCT_BOARDS y
+   define_bool CONFIG_I8259 y
+   define_bool CONFIG_ISA y
+   define_bool CONFIG_PCI y
+   define_bool CONFIG_NEW_TIME_C y
+   define_bool CONFIG_NEW_IRQ y
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
 if [ "$CONFIG_VICTOR_MPC30X" = "y" ]; then
    define_bool CONFIG_IRQ_CPU y
    define_bool CONFIG_NONCOHERENT_IO y
@@ -797,8 +838,12 @@
         "$CONFIG_SIBYTE_SWARM" = "y" -o \
 	"$CONFIG_SNI_RM200_PCI" = "y" ]; then
       define_bool CONFIG_PCI_AUTO n
-   else
-      define_bool CONFIG_PCI_AUTO y
+   else 
+      if [ "$CONFIG_MCT_BOARDS" = "y" ]; then
+         bool 'PCI Auto Configuration' CONFIG_PCI_AUTO
+      else
+         define_bool CONFIG_PCI_AUTO y
+      fi
    fi
 fi
 if [ "$CONFIG_SIBYTE_SB1250" = "y" -o \
diff -Naru linux-2.4.32/arch/mips/kernel/head.S linux-2.4.32-mct/arch/mips/kernel/head.S
--- linux-2.4.32/arch/mips/kernel/head.S	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/kernel/head.S	2006-12-02 15:08:43.000000000 +0100
@@ -21,25 +21,57 @@
 #include <asm/asm.h>
 #include <asm/current.h>
 #include <asm/offset.h>
-#include <asm/pgtable-bits.h>
 #include <asm/processor.h>
 #include <asm/regdef.h>
 #include <asm/cachectl.h>
 #include <asm/mipsregs.h>
 #include <asm/stackframe.h>
 
+		__INIT
+
 		.text
+
 		/*
-		 * Reserved space for exception handlers.
-		 * Necessary for machines which link their kernels at KSEG0.
+		 * Kernel entry point
 		 */
-		.fill	0x400
-
+NESTED(kernel_entry, 16, sp)
+		.set	noreorder
 		/* The following two symbols are used for kernel profiling. */
 		EXPORT(stext)
 		EXPORT(_stext)
 
-		__INIT
+		/*
+		 * Stack for kernel and init, current variable
+		 */
+		la	$28, init_task_union
+		addiu	t0, $28, KERNEL_STACK_SIZE-32
+		subu	sp, t0, 4*SZREG
+
+		sw	t0, kernelsp
+		/* The firmware/bootloader passes argc/argp/envp
+		 * to us as arguments.  But clear bss first because
+		 * the romvec and other important info is stored there
+		 * by prom_init().
+		 */
+		la	t0, _edata
+		sw	zero, (t0)
+		la	t1, (_ebss - 4)
+1:
+		addiu	t0, 4
+		bne	t0, t1, 1b
+		 sw	zero, (t0)
+
+		jal	init_arch
+		 nop
+		END(kernel_entry)
+
+#if 0	/* Removed by Ethan on 04/04/2002 */
+		/*
+		 * Reserved space for exception handlers.
+		 * Necessary for machines which link their kernels at KSEG0.
+		 */
+		.fill	0x280
+#endif	/* Removed by Ethan */
 
 		/* Cache Error */
 		LEAF(except_vec2_generic)
@@ -63,7 +95,7 @@
 		nop
 
 		j	cache_parity_error
-		 nop
+		nop
 		END(except_vec2_generic)
 
 		.set	at
@@ -81,116 +113,43 @@
 		END(except_vec4)
 
 		/*
-		 * EJTAG debug exception handler.
+		 * SBDDP EJTAG debug exception handler.
 		 * The EJTAG debug exception entry point is 0xbfc00480, which
 		 * normally is in the boot PROM, so the boot PROM must do a
 		 * unconditional jump to this vector.
-		 */
+		 */	
 		NESTED(except_vec_ejtag_debug, 0, sp)
 		j	ejtag_debug_handler
 		 nop
 		END(except_vec_ejtag_debug)
 
-		__FINIT
-
 		/*
 		 * EJTAG debug exception handler.
 		 */
 		NESTED(ejtag_debug_handler, PT_SIZE, sp)
 		.set	noat
 		.set	noreorder
-		mtc0	k0, CP0_DESAVE
-		mfc0	k0, CP0_DEBUG
-
-		sll	k0, k0, 30	# Check for SDBBP.
-		bgez	k0, ejtag_return
-
-		 la	k0, ejtag_debug_buffer
-		sw	k1, 0(k0)
 		SAVE_ALL
-		jal	ejtag_exception_handler
-		 move	a0, sp
+		PRINT("SDBBP EJTAG debug exception - not handled yet, just ignored!\n");
+		mfc0	k0, $23         # Get EJTAG Debug register.
+		mfc0    k1, $24         # Get DEPC register.
+		bgez	k0, 1f
+		 addiu	k1, k1, 4	# SBDDP inst. in delay slot.
+		addiu	k1, k1, 4
+1:		mtc0	k1, $24
 		RESTORE_ALL
-		la	k0, ejtag_debug_buffer
-		lw	k1, 0(k0)
-
-ejtag_return:
-		mfc0	k0, CP0_DESAVE
-		.set	mips32
-		deret
-		.set	mips0
+		.word	0x4200001f      # deret, return EJTAG debug exception.
 		 nop
 		.set	at
 		END(ejtag_debug_handler)
 
-		__INIT
-
-		/*
-		* NMI debug exception handler for MIPS reference boards.
-		* The NMI debug exception entry point is 0xbfc00000, which
-		* normally is in the boot PROM, so the boot PROM must do a
-		* unconditional jump to this vector.
-		*/
-		NESTED(except_vec_nmi, 0, sp)
-		j       nmi_handler
-		 nop
-		END(except_vec_nmi)
-
-		__FINIT
-
-		NESTED(nmi_handler, PT_SIZE, sp)
-		.set    noat
-		.set    noreorder
-		.set    mips3
-		SAVE_ALL
-		jal     nmi_exception_handler
-		 move   a0, sp
-		RESTORE_ALL
-		eret
-		.set    at
-		.set    mips0
-		END(nmi_handler)
-
-		__INIT
-
-		/*
-		 * Kernel entry point
-		 */
-		NESTED(kernel_entry, 16, sp)
-		.set	noreorder
-
-		/*
-		 * The firmware/bootloader passes argc/argp/envp
-		 * to us as arguments.  But clear bss first because
-		 * the romvec and other important info is stored there
-		 * by prom_init().
-		 */
-		la	t0, _edata
-		sw	zero, (t0)
-		la	t1, (_end - 4)
-1:
-		addiu	t0, 4
-		bne	t0, t1, 1b
-		 sw	zero, (t0)
-
-		/*
-		 * Stack for kernel and init, current variable
-		 */
-		la	$28, init_task_union
-		addiu	t0, $28, KERNEL_STACK_SIZE-32
-		subu	sp, t0, 4*SZREG
-		sw	t0, kernelsp
-
-		jal	init_arch
-		 nop
-		END(kernel_entry)
 
 
 #ifdef CONFIG_SMP
 
 /*
  * SMP slave cpus entry point.  Board specific code for bootstrap calls this
- * function after setting up the stack and gp registers.
+ * function after setting up the stack and gp registers. 
  */
 		LEAF(smp_bootstrap)
 		.set push
@@ -198,39 +157,42 @@
 		mtc0	zero, CP0_WIRED
 		CLI
 		mfc0	t0, CP0_STATUS
-		li	t1, ~(ST0_CU1|ST0_CU2|ST0_CU3|ST0_KX|ST0_SX|ST0_UX)
+		li	t1, ~(ST0_CU1|ST0_CU2|ST0_CU3|ST0_BEV); 
 		and	t0, t1
-		or	t0, (ST0_CU0);
+		or	t0, (ST0_CU0|ST0_KX|ST0_SX|ST0_FR);
 		jal	start_secondary
-		 mtc0	t0, CP0_STATUS
+		mtc0	t0, CP0_STATUS
 		.set pop
 		END(smp_bootstrap)
 #endif
 
-		__FINIT
-
-		/*
-		 * This buffer is reserved for the use of the EJTAG debug
-		 * handler.
-		 */
-		.data
-		EXPORT(ejtag_debug_buffer)
-		.fill	4
+/*		__FINIT*/ /* XXX: as report Error... */ .text
 
 		.comm	kernelsp,    NR_CPUS * 8, 8
 		.comm	pgd_current, NR_CPUS * 8, 8
 
-	.macro	page name, order=0
-	.globl	\name
-\name:	.size	\name, (_PAGE_SIZE << \order)
-	.org	. + (_PAGE_SIZE << \order)
-	.type	\name, @object
-	.endm
-
-	.data
-	.align	12
-
-	page	swapper_pg_dir, _PGD_ORDER
-	page	empty_bad_page, 0
-	page	empty_bad_page_table, 0
-	page	invalid_pte_table, 0
+		.text
+		.org	0x1000
+EXPORT(swapper_pg_dir)
+
+		.org	0x2000
+EXPORT(empty_bad_page)
+
+		.org	0x3000
+EXPORT(empty_bad_page_table)
+
+		.org	0x4000
+EXPORT(invalid_pte_table)
+
+		.org	0x5000
+/*
+ * Odd MIPS as behaviour but no bug - this label is required to keep as from
+ * trying to be too clever ...
+ */
+dummy:
+
+/*
+ * Align to 8kb boundary for init_task_union which follows in the
+ * .text segment.
+ */
+		.align	13
diff -Naru linux-2.4.32/arch/mips/kernel/setup.c linux-2.4.32-mct/arch/mips/kernel/setup.c
--- linux-2.4.32/arch/mips/kernel/setup.c	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/kernel/setup.c	2006-12-02 15:08:43.000000000 +0100
@@ -678,6 +678,11 @@
                tx4927_setup();
                break;
 #endif
+#ifdef CONFIG_MCT_BOARDS
+        case MACH_GROUP_MCT:
+                mctboards_setup();
+                break;
+#endif
 #ifdef CONFIG_SIBYTE_BOARD
 	case MACH_GROUP_SIBYTE:
 		swarm_setup();
diff -Naru linux-2.4.32/arch/mips/ld.script.in linux-2.4.32-mct/arch/mips/ld.script.in
--- linux-2.4.32/arch/mips/ld.script.in	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/ld.script.in	2006-12-02 15:08:43.000000000 +0100
@@ -9,6 +9,7 @@
   {
     _ftext = . ;
     *(.text)
+    *(.fixup)
     *(.rodata)
     *(.rodata.*)
     *(.rodata1)
@@ -50,6 +51,9 @@
   . = ALIGN(4096);	/* Align double page for init_task_union */
   __init_end = .;
 
+  . = ALIGN(4096);
+  .data.page_aligned : { *(.data.idt) }
+
   . = ALIGN(32);
   .data.cacheline_aligned : { *(.data.cacheline_aligned) }
 
@@ -79,8 +83,8 @@
    . = ALIGN(4096);
    __rd_start = .;
    *(.initrd)
-   . = ALIGN(4096);
    __rd_end = .;
+   . = ALIGN(4096);
 
     CONSTRUCTORS
   }
@@ -109,6 +113,10 @@
    *(.bss)
    *(COMMON)
    .  = ALIGN(4);
+	_ebss = .;
+	__fsysbuf = .;
+	. = . + @@FLASHSIZE@@;
+	__esysbuf = .;
   _end = . ;
   PROVIDE (end = .);
   }
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/Makefile linux-2.4.32-mct/arch/mips/mct-boards/generic/Makefile
--- linux-2.4.32/arch/mips/mct-boards/generic/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/Makefile	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,32 @@
+#
+# Makefile for the Toshiba TX-RISC board generic parts of the kernel
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (C) 1999-2001 Toshiba Corporation
+#
+
+.S.s:
+	$(CPP) $(AFLAGS) $< -o $@
+.S.o:
+	$(CC) $(AFLAGS) -c $< -o $@
+
+all: mctboards.a
+L_TARGET := mctboards.a
+
+export-objs = setup.o irq_tx3927.o irq_tx4927.o irq_tx4925.o dma.o
+
+obj-y	:= setup.o pmon.o pmon-low.o prom.o pci.o proc.o \
+	irq.o irq_tx3927.o irq_tx4927.o irq_tx4925.o int-handler.o \
+	dma.o wbflush.o \
+	irq_jmi39io2isac.o ide-jmi39io2.o kbd-jmi39io2.o basic_io.o \
+	dump_tx3927.o dump_tx4927.o dump_tx4925.o rtl8305.o
+obj-$(CONFIG_REMOTE_DEBUG)	+= gdb_hook.o
+
+include $(TOPDIR)/Rules.make
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/basic_io.c linux-2.4.32-mct/arch/mips/mct-boards/generic/basic_io.c
--- linux-2.4.32/arch/mips/mct-boards/generic/basic_io.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/basic_io.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,317 @@
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+
+#if defined(CONFIG_MCT_SG100) || defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100) || defined(CONFIG_MCT_SA200)
+static int	speaker_on;
+static struct timer_list speaker_timer;
+#endif
+
+#if defined(CONFIG_MCT_SG100)
+#define CPLD_GPIO_ADDR	0xb4000400
+#define	CPLD_GPIO_HBLED_BIT	0x10
+#define CPLD_PASSWD_RESET_BIT	0x01
+
+extern inline void SPK_ON()
+{
+	((*(volatile unsigned char*) CPLD_GPIO_ADDR) |= 0x20);
+	speaker_on = 0;
+}
+
+extern inline void SPK_OFF()
+{
+	((*(volatile unsigned char*) CPLD_GPIO_ADDR) &= 0xdf);
+	speaker_on = 1;
+}
+
+#elif defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100)
+
+#define CPU_PIODO_ADDR	0xfffef500
+#define CPU_PIODI_ADDR	0xfffef504
+#define CPU_GPIO_HBLED_BIT		0x00000100
+#define CPU_GPIO_PASSWD_RESET_BIT	0x00000020
+#define LOCALBUS_DATAIN_ADDR	0xb2000000
+#define LOCALBUS_DATAIN_PASSWD_RESET_BIT 0x04
+
+extern inline void SPK_ON(void)
+{
+	((*(volatile unsigned short *) CPU_PIODO_ADDR) |= 0x0400);
+//marked by louistsai speaker_on = 0;  
+	speaker_on = 1;
+}
+
+extern inline void SPK_OFF(void)
+{	
+	((*(volatile unsigned short *) CPU_PIODO_ADDR) &= 0xfbff);
+//marked by louistsai	speaker_on = 1;
+	speaker_on = 0;
+}
+	
+#elif defined(CONFIG_MCT_SG4100)
+
+#define CPU_PIODO_ADDR	0xff1ff500
+#define CPU_PIODI_ADDR	0xff1ff504
+#define CPU_GPIO_HBLED_BIT	0x00040000
+#define CPU_GPIO_PASSWD_RESET_BIT	0x00000008
+
+#elif defined(CONFIG_MCT_SA200)
+
+#include<asm/tx4925.h>
+#define CPU_PIODO_ADDR	0xff1ff500
+#define CPU_PIODI_ADDR	0xff1ff504
+#define CPU_GPIO_HBLED_BIT		0x00004000
+#define CPU_GPIO_PASSWD_RESET_BIT	0x00000008
+#define CPU_GPIO_SPK_BIT        	0x00100000
+
+extern inline void SPK_ON(void)
+{	
+	tx4925_pioptr->dout = tx4925_pioptr->din | CPU_GPIO_SPK_BIT ;
+	speaker_on = 1;
+}
+
+extern inline void SPK_OFF(void)
+{	
+	tx4925_pioptr->dout = tx4925_pioptr->din & ~CPU_GPIO_SPK_BIT;
+	speaker_on = 0;
+}
+
+#endif
+
+static struct timer_list hbled_timer;
+
+static void hbled_blink(unsigned long dummy)
+{
+#if defined(CONFIG_MCT_SG100)
+	unsigned char	val;
+
+	val = (*(volatile unsigned short*) CPLD_GPIO_ADDR);
+	val = (val & CPLD_GPIO_HBLED_BIT) ?
+		(val & ~CPLD_GPIO_HBLED_BIT) : (val | CPLD_GPIO_HBLED_BIT);
+	(*(volatile unsigned char*) CPLD_GPIO_ADDR) = val;
+#elif defined(CONFIG_MCT_SG4100) || defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100) || defined(CONFIG_MCT_SA200)
+	unsigned long	val;
+	
+	val = *(volatile unsigned long *) CPU_PIODI_ADDR;
+	val = (val & CPU_GPIO_HBLED_BIT) ?
+		(val & ~CPU_GPIO_HBLED_BIT) : (val | CPU_GPIO_HBLED_BIT);
+	(*(volatile unsigned long *) CPU_PIODO_ADDR) = val;
+
+#endif
+		
+	init_timer(&hbled_timer);
+	hbled_timer.function = hbled_blink;
+	hbled_timer.expires = jiffies + HZ / 2;
+	add_timer(&hbled_timer);
+}
+
+void __init hbled_init(void)
+{
+	init_timer(&hbled_timer);
+	hbled_timer.function = hbled_blink;
+	hbled_timer.expires = jiffies + HZ;
+	add_timer(&hbled_timer);
+}
+#if defined(CONFIG_ATEN_LED)
+static struct timer_list aled_timer;
+
+#if defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100) 
+#define ATEN_LED		0xb4000000
+static void aled_blink(unsigned long dummy)
+{
+	static int off_flag = 0 ,direction = 0,step = 0;
+	init_timer(&aled_timer);
+	aled_timer.function = aled_blink;
+	
+//	if(!off_flag) {
+		if(!direction) {
+			if(step==0) 
+				*((volatile unsigned char *) ATEN_LED) = ~(0x01) ;	
+			else 
+				*((volatile unsigned char *) ATEN_LED) = ~(0x03 << step-1) ;
+			
+			if(step!=3) 
+				step++;
+			else 		
+				direction = 1;
+		}
+		else {
+			if(step==3) 
+				*((volatile unsigned char *) ATEN_LED) = ~(0x08) ;	
+			else 
+				*((volatile unsigned char *) ATEN_LED) = ~(0x0c >> -(step-2)) ;
+			
+			if(step!=0) 
+				step--;
+			else 		
+				direction = 0;
+		}
+		
+		
+		aled_timer.expires = jiffies + HZ / 2;
+/*		off_flag = 1;
+	}
+	else
+	{
+		if(!direction) {
+			if(step==0) 
+				*((volatile unsigned char *) ATEN_LED) = ~(0x01) ;	
+			else 
+				*((volatile unsigned char *) ATEN_LED) = ~(0x02 << step-1) ;
+			
+		}
+		else {
+			if(step==3) 
+				*((volatile unsigned char *) ATEN_LED) = ~(0x08) ;	
+			else 
+				*((volatile unsigned char *) ATEN_LED) = ~(0x04 >> -(step-2)) ;
+		}
+		
+		aled_timer.expires = jiffies + HZ / 2;
+		off_flag = 0;
+	}
+*/		
+	
+	add_timer(&aled_timer);
+}
+
+#elif defined(CONFIG_MCT_SA200)
+
+static void aled_blink(unsigned long dummy)
+{
+	static int off_flag = 0 ,direction = 0,step = 0;
+	init_timer(&aled_timer);
+	aled_timer.function = aled_blink;
+	if(!direction) {
+		if(step==0) 
+			tx4925_pioptr->dout = (tx4925_pioptr->din & 0x0fffffff) | (~(0x01))<<28 ;	
+		else 
+			tx4925_pioptr->dout = (tx4925_pioptr->din & 0x0fffffff) | (~(0x03 << step-1))<<28 ;
+			
+		if(step!=3) 
+			step++;
+		else 		
+			direction = 1;
+	}
+	else {
+		if(step==3) 
+			tx4925_pioptr->dout = (tx4925_pioptr->din & 0x0fffffff) | (~(0x08))<<28 ;	
+		else 
+			tx4925_pioptr->dout = (tx4925_pioptr->din & 0x0fffffff) | (~(0x0c >> -(step-2))) <<28 ;
+			
+		if(step!=0) 
+			step--;
+		else 		
+			direction = 0;
+	}
+
+	aled_timer.expires = jiffies + HZ/2 ;
+	add_timer(&aled_timer);
+}
+
+#endif
+
+void __init aled_init(void)
+{
+	printk("init aled\n");
+	init_timer(&aled_timer);
+	aled_timer.function = aled_blink;
+	aled_timer.expires = jiffies + HZ ;
+	add_timer(&aled_timer);
+}
+
+#endif
+
+
+
+static struct timer_list	conf_reset_timer;
+static int	conf_reset_detecting;
+static int	conf_reset_tick_count;
+extern int	conf_reset_in_progress;
+extern wait_queue_head_t	flash_wq;
+
+#if defined(CONFIG_MCT_SG100) || defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100)  || defined(CONFIG_MCT_SA200)
+static void speaker_callback(unsigned long dummy)
+{
+	if ( speaker_on ) {
+		SPK_OFF();
+	} else {
+		SPK_ON();
+	}
+	init_timer(&speaker_timer);
+	speaker_timer.function = speaker_callback;
+	speaker_timer.expires = jiffies + HZ / 2;
+	add_timer(&speaker_timer);
+}
+#endif
+
+static void conf_reset_callback(unsigned long dummy)
+{
+	int	normal_interval;
+#if defined(CONFIG_MCT_SG100) || defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100)
+	unsigned short	val;
+#elif defined(CONFIG_MCT_SG4100) || defined(CONFIG_MCT_SA200)
+	unsigned long	val;
+#endif
+
+	normal_interval = 1;
+#if defined(CONFIG_MCT_SG100)
+	val = (*(volatile unsigned short*) CPLD_GPIO_ADDR);
+	if ( (val & CPLD_PASSWD_RESET_BIT) == 0 && 
+#elif defined(CONFIG_MCT_SG600)
+	val = (*(volatile unsigned short*) LOCALBUS_DATAIN_ADDR);
+	if ( (val & LOCALBUS_DATAIN_PASSWD_RESET_BIT) == 0 &&
+#elif defined(CONFIG_MCT_SA100)
+	val = *(volatile unsigned long *) CPU_PIODI_ADDR;
+	if ( (val & CPU_GPIO_PASSWD_RESET_BIT) == 0 &&
+#elif defined(CONFIG_MCT_SG4100) || defined(CONFIG_MCT_SA200)
+	val = *(volatile unsigned long *) CPU_PIODI_ADDR;
+	if ( (val & CPU_GPIO_PASSWD_RESET_BIT) == 0 &&
+#endif
+			!conf_reset_in_progress ) {	// low active
+		if ( conf_reset_tick_count >= 50 ) {	// trigger "config reset" if the "config reset" button is held at least 5 seconds.
+#if defined(CONFIG_MCT_SG100) || defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100) || defined(CONFIG_MCT_SA200)
+			del_timer(&speaker_timer);
+			SPK_OFF();
+#endif
+
+			conf_reset_in_progress = 1;
+			wake_up_interruptible(&flash_wq);
+		} else if ( conf_reset_detecting ) {
+			conf_reset_tick_count++;
+			normal_interval = 0;
+		} else {
+#if defined(CONFIG_MCT_SG100) || defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100) || defined(CONFIG_MCT_SA200)
+			init_timer(&speaker_timer);
+			speaker_timer.function = speaker_callback;
+			speaker_timer.expires = jiffies + HZ;
+			add_timer(&speaker_timer);
+			SPK_OFF();
+#endif
+
+			conf_reset_tick_count = 0;
+			conf_reset_detecting = 1;
+		}
+	} else {
+#if defined(CONFIG_MCT_SG100) || defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100) || defined(CONFIG_MCT_SA200)
+		del_timer(&speaker_timer);
+		SPK_OFF();
+#endif
+
+		conf_reset_detecting = 0;
+	}
+			
+	init_timer(&conf_reset_timer);
+	conf_reset_timer.function = conf_reset_callback;
+	conf_reset_timer.expires = jiffies + ((normal_interval) ? (HZ / 2) : (HZ / 10));
+	add_timer(&conf_reset_timer);
+}
+
+void __init conf_reset_init(void)
+{
+	init_timer(&conf_reset_timer);
+	conf_reset_timer.function = conf_reset_callback;
+	conf_reset_timer.expires = jiffies + HZ / 2;
+	add_timer(&conf_reset_timer);
+}
+
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/dma.c linux-2.4.32-mct/arch/mips/mct-boards/generic/dma.c
--- linux-2.4.32/arch/mips/mct-boards/generic/dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/dma.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,888 @@
+/*
+ *  linux/arch/mips/toshiba-boards/generic/dma.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/slab.h>
+#include <asm/system.h>
+#include <asm/mipsregs.h>
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/dma.h>
+#include <asm/mct-boards/dma.h>
+#include <asm/mct-boards/irq.h>
+
+#if defined(CONFIG_MCT_SG100) || defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100)
+#include <asm/tx3927.h>
+#define HAVE_3927_DMA
+#endif
+#if defined(CONFIG_TOSHIBA_TX4927EVB) || defined(CONFIG_TOSHIBA_RBTX4927)
+#include <asm/tx4927.h>
+#define HAVE_4927_DMA
+#endif
+#if defined(CONFIG_MCT_SG4100) || defined(CONFIG_MCT_SA200)
+#include <asm/tx4925.h>
+#define HAVE_4925_DMA
+#endif
+
+#ifdef HAVE_3927_DMA
+/* TX3927 stype DMA controller */
+
+/* reset a specific DMA channel */
+static void
+init_tx3927_dma(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx3927_dmaptr->ch[ch].ccr = TX3927_DMA_CCR_CHRST;
+	tx3927_dmaptr->ch[ch].cha = 0;
+	tx3927_dmaptr->ch[ch].sar = 0;
+	tx3927_dmaptr->ch[ch].dar = 0;
+	tx3927_dmaptr->ch[ch].cntr = 0;
+	tx3927_dmaptr->ch[ch].sair = 0;
+	tx3927_dmaptr->ch[ch].dair = 0;
+	tx3927_dmaptr->ch[ch].ccr = 0;
+}
+
+/* enable/disable a specific DMA channel */
+static void
+enable_tx3927_dma(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx3927_dmaptr->ch[ch].ccr |= TX3927_DMA_CCR_XFACT;
+}
+
+static void
+disable_tx3927_dma(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx3927_dmaptr->ch[ch].ccr &= ~TX3927_DMA_CCR_XFACT;
+}
+
+/* set mode for a specific DMA channel */
+static void
+set_tx3927_dma_mode(unsigned int dmanr, unsigned int mode)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx3927_dmaptr->ch[ch].ccr = mode;
+}
+
+/* Set source/destination address for specific DMA channel.
+ */
+static void
+set_tx3927_dma_addr(unsigned int dmanr,
+		    unsigned int sa,
+		    unsigned int da)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx3927_dmaptr->ch[ch].sar = sa;
+	tx3927_dmaptr->ch[ch].dar = da;
+}
+static void
+set_tx3927_dma_addr64(unsigned int dmanr,
+		      unsigned long long sa,
+		      unsigned long long da)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx3927_dmaptr->ch[ch].sar = (unsigned long)sa;
+	tx3927_dmaptr->ch[ch].dar = (unsigned long)da;
+}
+
+/* Set transfer size for a specific DMA channel.
+ */
+static void
+set_tx3927_dma_count(unsigned int dmanr, unsigned int count)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx3927_dmaptr->ch[ch].cntr = count;
+}
+
+/* Set source/destination address increment size for a specific DMA channel.
+ */
+static void
+set_tx3927_dma_inc(unsigned int dmanr, unsigned int sai, unsigned int dai)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx3927_dmaptr->ch[ch].sair = sai;
+	tx3927_dmaptr->ch[ch].dair = dai;
+}
+
+
+/* Get DMA residue count. After a DMA transfer, this
+ * should return zero. Reading this while a DMA transfer is
+ * still in progress will return unpredictable results.
+ */
+static int
+get_tx3927_dma_residue(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	return tx3927_dmaptr->ch[ch].cntr;
+}
+
+/* Get DMA status.
+ */
+static unsigned int
+get_tx3927_dma_status(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	return tx3927_dmaptr->ch[ch].csr;
+}
+
+/* clear DMA status.
+ */
+static void
+clear_tx3927_dma_status(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx3927_dmaptr->ch[ch].csr = 0xffffffff;
+}
+
+/* get DMA completion interrupt number.
+ */
+static int
+get_tx3927_dma_irqno(unsigned int dmanr)
+{
+	if (dmanr < TXX927_DMA_CHANNEL_START ||
+	    dmanr >= TXX927_DMA_CHANNEL_START + MAX_TXX927_DMA_CHANNELS)
+		return -1;
+	return tx3927_irq_to_irq(TX3927_IR_DMA);
+}
+
+/*
+ * chain DMA operations.
+ * txx927_chdma_desc_t is nocache virtual address of the command descriptor.
+ */
+
+static void
+set_tx3927_dma_chain(unsigned int dmanr, txx927_chdma_desc_t cha)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx3927_dmaptr->ch[ch].cha = virt_to_phys(cha);
+}
+
+static txx927_chdma_desc_t
+get_tx3927_dma_chain(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	unsigned int cha = cha = tx3927_dmaptr->ch[ch].cha;
+	if (cha == 0)
+		return 0;
+	return (txx927_chdma_desc_t)KSEG1ADDR(cha);
+}
+
+#define tx3927_chdma_desc(desc)	((struct tx3927_dma_ch_reg*)desc)
+
+static void
+set_tx3927_chdma_mode(txx927_chdma_desc_t desc, unsigned int mode)
+{
+	tx3927_chdma_desc(desc)->ccr = mode;
+}
+
+static void
+set_tx3927_chdma_addr(txx927_chdma_desc_t desc, unsigned int sa, unsigned int da)
+{
+	tx3927_chdma_desc(desc)->sar = sa;
+	tx3927_chdma_desc(desc)->dar = da;
+}
+
+static void
+get_tx3927_chdma_addr(txx927_chdma_desc_t desc, unsigned int *sa, unsigned int *da)
+{
+	*sa = tx3927_chdma_desc(desc)->sar;
+	*da = tx3927_chdma_desc(desc)->dar;
+}
+
+static void
+set_tx3927_chdma_addr64(txx927_chdma_desc_t desc, unsigned long long sa, unsigned long long da)
+{
+	tx3927_chdma_desc(desc)->sar = (unsigned long)sa;
+	tx3927_chdma_desc(desc)->dar = (unsigned long)da;
+}
+
+static void
+get_tx3927_chdma_addr64(txx927_chdma_desc_t desc, unsigned long long *sa, unsigned long long *da)
+{
+	*sa = tx3927_chdma_desc(desc)->sar;
+	*da = tx3927_chdma_desc(desc)->dar;
+}
+
+static void
+set_tx3927_chdma_count(txx927_chdma_desc_t desc, unsigned int count)
+{
+	tx3927_chdma_desc(desc)->cntr = count;
+}
+
+static void
+get_tx3927_chdma_count(txx927_chdma_desc_t desc, unsigned int *count)
+{
+	*count = tx3927_chdma_desc(desc)->cntr;
+}
+
+static void
+set_tx3927_chdma_inc(txx927_chdma_desc_t desc, unsigned int sai, unsigned int dai)
+{
+	tx3927_chdma_desc(desc)->sair = sai;
+	tx3927_chdma_desc(desc)->dair = dai;
+}
+
+static void
+set_tx3927_chdma_chain(txx927_chdma_desc_t desc, txx927_chdma_desc_t cha)
+{
+	tx3927_chdma_desc(desc)->cha = virt_to_phys(cha);
+}
+
+static txx927_chdma_desc_t
+get_tx3927_chdma_chain(txx927_chdma_desc_t desc)
+{
+	unsigned int cha = tx3927_chdma_desc(desc)->cha;
+	if (cha == 0)
+		return 0;
+	return (txx927_chdma_desc_t)KSEG1ADDR(cha);
+}
+
+static txx927_chdma_desc_t
+alloc_tx3927_chdma_cmd(void)
+{
+	void *desc;
+	int size = sizeof(struct tx3927_dma_ch_reg);
+	/* kmalloc always return 32-byte aligned address... */
+	desc = kmalloc(size, GFP_ATOMIC);
+	if (desc) {
+		if ((unsigned int)desc & 31)
+			panic("dma: kmalloc returns unaligned address.");
+		dma_cache_wback_inv((unsigned long)desc, size);
+		desc = (void *)KSEG1ADDR(desc);
+	}
+	return (txx927_chdma_desc_t)desc;
+}
+
+static void
+free_tx3927_chdma_cmd(txx927_chdma_desc_t desc)
+{
+	if (desc)
+		kfree((void *)KSEG0ADDR(desc));
+}
+
+static struct txx927_dma_ops tx3927_dma_ops = {
+	init_dma: init_tx3927_dma,
+	enable_dma: enable_tx3927_dma,
+	disable_dma: disable_tx3927_dma,
+	set_dma_mode: set_tx3927_dma_mode,
+	set_dma_addr: set_tx3927_dma_addr,
+	set_dma_addr64: set_tx3927_dma_addr64,
+	set_dma_count: set_tx3927_dma_count,
+	set_dma_inc: set_tx3927_dma_inc,
+	get_dma_residue: get_tx3927_dma_residue,
+	get_dma_status: get_tx3927_dma_status,
+	clear_dma_status: clear_tx3927_dma_status,
+	get_dma_irqno: get_tx3927_dma_irqno,
+	set_dma_chain: set_tx3927_dma_chain,
+	get_dma_chain: get_tx3927_dma_chain,
+	set_chdma_mode: set_tx3927_chdma_mode,
+	set_chdma_addr: set_tx3927_chdma_addr,
+	get_chdma_addr: get_tx3927_chdma_addr,
+	set_chdma_addr64: set_tx3927_chdma_addr64,
+	get_chdma_addr64: get_tx3927_chdma_addr64,
+	set_chdma_count: set_tx3927_chdma_count,
+	get_chdma_count: get_tx3927_chdma_count,
+	set_chdma_inc: set_tx3927_chdma_inc,
+	set_chdma_chain: set_tx3927_chdma_chain,
+	get_chdma_chain: get_tx3927_chdma_chain,
+	alloc_chdma_cmd: alloc_tx3927_chdma_cmd,
+	free_chdma_cmd: free_tx3927_chdma_cmd
+};
+
+#endif	/* HAVE_3927_DMA */
+
+#ifdef HAVE_4927_DMA
+/* TX4927 stype DMA controller */
+
+/* reset a specific DMA channel */
+static void
+init_tx4927_dma(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4927_dmaptr->ch[ch].ccr = TX4927_DMA_CCR_CHRST;
+	tx4927_dmaptr->ch[ch].cha = 0;
+	tx4927_dmaptr->ch[ch].sar = 0;
+	tx4927_dmaptr->ch[ch].dar = 0;
+	tx4927_dmaptr->ch[ch].cntr = 0;
+	tx4927_dmaptr->ch[ch].sair = 0;
+	tx4927_dmaptr->ch[ch].dair = 0;
+	tx4927_dmaptr->ch[ch].ccr = 0;
+}
+
+/* enable/disable a specific DMA channel */
+static void
+enable_tx4927_dma(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4927_dmaptr->ch[ch].ccr |= TX4927_DMA_CCR_XFACT;
+}
+
+static void
+disable_tx4927_dma(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4927_dmaptr->ch[ch].ccr &= ~TX4927_DMA_CCR_XFACT;
+}
+
+/* set mode for a specific DMA channel */
+static void
+set_tx4927_dma_mode(unsigned int dmanr, unsigned int mode)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+#ifdef __LITTLE_ENDIAN
+	mode |= TX4927_DMA_CCR_LE;
+#endif
+	tx4927_dmaptr->ch[ch].ccr = mode;
+}
+
+/* Set source/destination address for specific DMA channel.
+ */
+static void
+set_tx4927_dma_addr(unsigned int dmanr,
+		    unsigned int sa,
+		    unsigned int da)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4927_dmaptr->ch[ch].sar = sa;
+	tx4927_dmaptr->ch[ch].dar = da;
+}
+static void
+set_tx4927_dma_addr64(unsigned int dmanr,
+		      unsigned long long sa,
+		      unsigned long long da)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4927_dmaptr->ch[ch].sar = sa;
+	tx4927_dmaptr->ch[ch].dar = da;
+}
+
+/* Set transfer size for a specific DMA channel.
+ */
+static void
+set_tx4927_dma_count(unsigned int dmanr, unsigned int count)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4927_dmaptr->ch[ch].cntr = count;
+}
+
+/* Set source/destination address increment size for a specific DMA channel.
+ */
+static void
+set_tx4927_dma_inc(unsigned int dmanr, unsigned int sai, unsigned int dai)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4927_dmaptr->ch[ch].sair = sai;
+	tx4927_dmaptr->ch[ch].dair = dai;
+}
+
+
+/* Get DMA residue count. After a DMA transfer, this
+ * should return zero. Reading this while a DMA transfer is
+ * still in progress will return unpredictable results.
+ */
+static int
+get_tx4927_dma_residue(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	return tx4927_dmaptr->ch[ch].cntr;
+}
+
+/* Get DMA status.
+ */
+static unsigned int
+get_tx4927_dma_status(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	return tx4927_dmaptr->ch[ch].csr;
+}
+
+/* clear DMA status.
+ */
+static void
+clear_tx4927_dma_status(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4927_dmaptr->ch[ch].csr = 0xffffffff;
+}
+
+/* get DMA completion interrupt number.
+ */
+static int
+get_tx4927_dma_irqno(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+
+	if (dmanr < TXX927_DMA_CHANNEL_START ||
+	    dmanr >= TXX927_DMA_CHANNEL_START + MAX_TXX927_DMA_CHANNELS)
+		return -1;
+	return tx4927_irq_to_irq(TX4927_IR_DMA(ch));
+}
+
+/*
+ * chain DMA operations.
+ * txx927_chdma_desc_t is nocache virtual address of the command descriptor.
+ */
+
+static void
+set_tx4927_dma_chain(unsigned int dmanr, txx927_chdma_desc_t cha)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4927_dmaptr->ch[ch].cha = virt_to_phys(cha);
+}
+
+static txx927_chdma_desc_t
+get_tx4927_dma_chain(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	unsigned int cha = (unsigned int)tx4927_dmaptr->ch[ch].cha;
+	if (cha == 0)
+		return 0;
+	return (txx927_chdma_desc_t)KSEG1ADDR(cha);
+}
+
+#define tx4927_chdma_desc(desc)	((struct tx4927_dma_ch_reg*)desc)
+
+static void
+set_tx4927_chdma_mode(txx927_chdma_desc_t desc, unsigned int mode)
+{
+#ifdef __LITTLE_ENDIAN
+	mode |= TX4927_DMA_CCR_LE;
+#endif
+	tx4927_chdma_desc(desc)->ccr = mode;
+}
+
+static void
+set_tx4927_chdma_addr(txx927_chdma_desc_t desc, unsigned int sa, unsigned int da)
+{
+	tx4927_chdma_desc(desc)->sar = sa;
+	tx4927_chdma_desc(desc)->dar = da;
+}
+
+static void
+get_tx4927_chdma_addr(txx927_chdma_desc_t desc, unsigned int *sa, unsigned int *da)
+{
+	*sa = tx4927_chdma_desc(desc)->sar;
+	*da = tx4927_chdma_desc(desc)->dar;
+}
+
+static void
+set_tx4927_chdma_addr64(txx927_chdma_desc_t desc, unsigned long long sa, unsigned long long da)
+{
+	tx4927_chdma_desc(desc)->sar = sa;
+	tx4927_chdma_desc(desc)->dar = da;
+}
+
+static void
+get_tx4927_chdma_addr64(txx927_chdma_desc_t desc, unsigned long long *sa, unsigned long long *da)
+{
+	*sa = tx4927_chdma_desc(desc)->sar;
+	*da = tx4927_chdma_desc(desc)->dar;
+}
+
+static void
+set_tx4927_chdma_count(txx927_chdma_desc_t desc, unsigned int count)
+{
+	tx4927_chdma_desc(desc)->cntr = count;
+}
+
+static void
+get_tx4927_chdma_count(txx927_chdma_desc_t desc, unsigned int *count)
+{
+	*count = tx4927_chdma_desc(desc)->cntr;
+}
+
+static void
+set_tx4927_chdma_inc(txx927_chdma_desc_t desc, unsigned int sai, unsigned int dai)
+{
+	tx4927_chdma_desc(desc)->sair = sai;
+	tx4927_chdma_desc(desc)->dair = dai;
+}
+
+static void
+set_tx4927_chdma_chain(txx927_chdma_desc_t desc, txx927_chdma_desc_t cha)
+{
+	tx4927_chdma_desc(desc)->cha = virt_to_phys(cha);
+}
+
+static txx927_chdma_desc_t
+get_tx4927_chdma_chain(txx927_chdma_desc_t desc)
+{
+	unsigned int cha = (unsigned int)tx4927_chdma_desc(desc)->cha;
+	if (cha == 0)
+		return 0;
+	return (txx927_chdma_desc_t)KSEG1ADDR(cha);
+}
+
+static txx927_chdma_desc_t
+alloc_tx4927_chdma_cmd(void)
+{
+	int size = sizeof(struct tx4927_dma_ch_reg);
+	void *desc;
+	/* kmalloc always return 32-byte aligned address... */
+	desc = kmalloc(size, GFP_ATOMIC);
+	if (desc) {
+		if ((unsigned int)desc & 31)
+			panic("dma: kmalloc returns unaligned address.");
+		dma_cache_wback_inv((unsigned long)desc, size);
+		desc = (void *)KSEG1ADDR(desc);
+	}
+	return (txx927_chdma_desc_t)desc;
+}
+
+static void
+free_tx4927_chdma_cmd(txx927_chdma_desc_t desc)
+{
+	if (desc)
+		kfree((void *)KSEG0ADDR(desc));
+}
+
+static struct txx927_dma_ops tx4927_dma_ops = {
+	init_dma: init_tx4927_dma,
+	enable_dma: enable_tx4927_dma,
+	disable_dma: disable_tx4927_dma,
+	set_dma_mode: set_tx4927_dma_mode,
+	set_dma_addr: set_tx4927_dma_addr,
+	set_dma_addr64: set_tx4927_dma_addr64,
+	set_dma_count: set_tx4927_dma_count,
+	set_dma_inc: set_tx4927_dma_inc,
+	get_dma_residue: get_tx4927_dma_residue,
+	get_dma_status: get_tx4927_dma_status,
+	clear_dma_status: clear_tx4927_dma_status,
+	get_dma_irqno: get_tx4927_dma_irqno,
+	set_dma_chain: set_tx4927_dma_chain,
+	get_dma_chain: get_tx4927_dma_chain,
+	set_chdma_mode: set_tx4927_chdma_mode,
+	set_chdma_addr: set_tx4927_chdma_addr,
+	get_chdma_addr: get_tx4927_chdma_addr,
+	set_chdma_addr64: set_tx4927_chdma_addr64,
+	get_chdma_addr64: get_tx4927_chdma_addr64,
+	set_chdma_count: set_tx4927_chdma_count,
+	get_chdma_count: get_tx4927_chdma_count,
+	set_chdma_inc: set_tx4927_chdma_inc,
+	set_chdma_chain: set_tx4927_chdma_chain,
+	get_chdma_chain: get_tx4927_chdma_chain,
+	alloc_chdma_cmd: alloc_tx4927_chdma_cmd,
+	free_chdma_cmd: free_tx4927_chdma_cmd
+};
+
+#endif	/* HAVE_4927_DMA */
+
+#ifdef HAVE_4925_DMA
+/* TX4925 stype DMA controller */
+
+/* reset a specific DMA channel */
+static void
+init_tx4925_dma(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4925_dmaptr->ch[ch].ccr = TX4925_DMA_CCR_CHRST;
+	tx4925_dmaptr->ch[ch].cha = 0;
+	tx4925_dmaptr->ch[ch].sar = 0;
+	tx4925_dmaptr->ch[ch].dar = 0;
+	tx4925_dmaptr->ch[ch].cntr = 0;
+	tx4925_dmaptr->ch[ch].sair = 0;
+	tx4925_dmaptr->ch[ch].dair = 0;
+	tx4925_dmaptr->ch[ch].ccr = 0;
+}
+
+/* enable/disable a specific DMA channel */
+static void
+enable_tx4925_dma(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4925_dmaptr->ch[ch].ccr |= TX4925_DMA_CCR_XFACT;
+}
+
+static void
+disable_tx4925_dma(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4925_dmaptr->ch[ch].ccr &= ~TX4925_DMA_CCR_XFACT;
+}
+
+/* set mode for a specific DMA channel */
+static void
+set_tx4925_dma_mode(unsigned int dmanr, unsigned int mode)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+#ifdef __LITTLE_ENDIAN
+	mode |= TX4925_DMA_CCR_LE;
+#endif
+	tx4925_dmaptr->ch[ch].ccr = mode;
+}
+
+/* Set source/destination address for specific DMA channel.
+ */
+static void
+set_tx4925_dma_addr(unsigned int dmanr,
+		    unsigned int sa,
+		    unsigned int da)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4925_dmaptr->ch[ch].sar = sa;
+	tx4925_dmaptr->ch[ch].dar = da;
+}
+static void
+set_tx4925_dma_addr64(unsigned int dmanr,
+		      unsigned long long sa,
+		      unsigned long long da)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4925_dmaptr->ch[ch].sar = (unsigned long)sa;
+	tx4925_dmaptr->ch[ch].dar = (unsigned long)da;
+}
+
+/* Set transfer size for a specific DMA channel.
+ */
+static void
+set_tx4925_dma_count(unsigned int dmanr, unsigned int count)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4925_dmaptr->ch[ch].cntr = count;
+}
+
+/* Set source/destination address increment size for a specific DMA channel.
+ */
+static void
+set_tx4925_dma_inc(unsigned int dmanr, unsigned int sai, unsigned int dai)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4925_dmaptr->ch[ch].sair = sai;
+	tx4925_dmaptr->ch[ch].dair = dai;
+}
+
+
+/* Get DMA residue count. After a DMA transfer, this
+ * should return zero. Reading this while a DMA transfer is
+ * still in progress will return unpredictable results.
+ */
+static int
+get_tx4925_dma_residue(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	return tx4925_dmaptr->ch[ch].cntr;
+}
+
+/* Get DMA status.
+ */
+static unsigned int
+get_tx4925_dma_status(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	return tx4925_dmaptr->ch[ch].csr;
+}
+
+/* clear DMA status.
+ */
+static void
+clear_tx4925_dma_status(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4925_dmaptr->ch[ch].csr = 0xffffffff;
+}
+
+/* get DMA completion interrupt number.
+ */
+static int
+get_tx4925_dma_irqno(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+
+	if (dmanr < TXX927_DMA_CHANNEL_START ||
+	    dmanr >= TXX927_DMA_CHANNEL_START + MAX_TXX927_DMA_CHANNELS)
+		return -1;
+	return tx4925_irq_to_irq(TX4925_IR_DMA(ch));
+}
+
+/*
+ * chain DMA operations.
+ * txx927_chdma_desc_t is nocache virtual address of the command descriptor.
+ */
+
+static void
+set_tx4925_dma_chain(unsigned int dmanr, txx927_chdma_desc_t cha)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	tx4925_dmaptr->ch[ch].cha = virt_to_phys(cha);
+}
+
+static txx927_chdma_desc_t
+get_tx4925_dma_chain(unsigned int dmanr)
+{
+	int ch = dmanr - TXX927_DMA_CHANNEL_START;
+	unsigned int cha = tx4925_dmaptr->ch[ch].cha;
+	if (cha == 0)
+		return 0;
+	return (txx927_chdma_desc_t)KSEG1ADDR(cha);
+}
+
+#define tx4925_chdma_desc(desc)	((struct tx4925_dma_ch_reg*)desc)
+
+static void
+set_tx4925_chdma_mode(txx927_chdma_desc_t desc, unsigned int mode)
+{
+#ifdef __LITTLE_ENDIAN
+	mode |= TX4925_DMA_CCR_LE;
+#endif
+	tx4925_chdma_desc(desc)->ccr = mode;
+}
+
+static void
+set_tx4925_chdma_addr(txx927_chdma_desc_t desc, unsigned int sa, unsigned int da)
+{
+	tx4925_chdma_desc(desc)->sar = sa;
+	tx4925_chdma_desc(desc)->dar = da;
+}
+
+static void
+get_tx4925_chdma_addr(txx927_chdma_desc_t desc, unsigned int *sa, unsigned int *da)
+{
+	*sa = tx4925_chdma_desc(desc)->sar;
+	*da = tx4925_chdma_desc(desc)->dar;
+}
+
+static void
+set_tx4925_chdma_addr64(txx927_chdma_desc_t desc, unsigned long long sa, unsigned long long da)
+{
+	tx4925_chdma_desc(desc)->sar = (unsigned long)sa;
+	tx4925_chdma_desc(desc)->dar = (unsigned long)da;
+}
+
+static void
+get_tx4925_chdma_addr64(txx927_chdma_desc_t desc, unsigned long long *sa, unsigned long long *da)
+{
+	*sa = tx4925_chdma_desc(desc)->sar;
+	*da = tx4925_chdma_desc(desc)->dar;
+}
+
+static void
+set_tx4925_chdma_count(txx927_chdma_desc_t desc, unsigned int count)
+{
+	tx4925_chdma_desc(desc)->cntr = count;
+}
+
+static void
+get_tx4925_chdma_count(txx927_chdma_desc_t desc, unsigned int *count)
+{
+	*count = tx4925_chdma_desc(desc)->cntr;
+}
+
+static void
+set_tx4925_chdma_inc(txx927_chdma_desc_t desc, unsigned int sai, unsigned int dai)
+{
+	tx4925_chdma_desc(desc)->sair = sai;
+	tx4925_chdma_desc(desc)->dair = dai;
+}
+
+static void
+set_tx4925_chdma_chain(txx927_chdma_desc_t desc, txx927_chdma_desc_t cha)
+{
+	tx4925_chdma_desc(desc)->cha = virt_to_phys(cha);
+}
+
+static txx927_chdma_desc_t
+get_tx4925_chdma_chain(txx927_chdma_desc_t desc)
+{
+	unsigned int cha = tx4925_chdma_desc(desc)->cha;
+	if (cha == 0)
+		return 0;
+	return (txx927_chdma_desc_t)KSEG1ADDR(cha);
+}
+
+static txx927_chdma_desc_t
+alloc_tx4925_chdma_cmd(void)
+{
+	int size = sizeof(struct tx4925_dma_ch_reg);
+	void *desc;
+	/* kmalloc always return 32-byte aligned address... */
+	desc = kmalloc(size, GFP_ATOMIC);
+	if (desc) {
+		if ((unsigned int)desc & 31)
+			panic("dma: kmalloc returns unaligned address.");
+		dma_cache_wback_inv((unsigned long)desc, size);
+		desc = (txx927_chdma_desc_t)KSEG1ADDR(desc);
+	}
+	return (txx927_chdma_desc_t)desc;
+}
+
+static void
+free_tx4925_chdma_cmd(txx927_chdma_desc_t desc)
+{
+	if (desc)
+		kfree((void *)KSEG0ADDR(desc));
+}
+
+static struct txx927_dma_ops tx4925_dma_ops = {
+	init_dma: init_tx4925_dma,
+	enable_dma: enable_tx4925_dma,
+	disable_dma: disable_tx4925_dma,
+	set_dma_mode: set_tx4925_dma_mode,
+	set_dma_addr: set_tx4925_dma_addr,
+	set_dma_addr64: set_tx4925_dma_addr64,
+	set_dma_count: set_tx4925_dma_count,
+	set_dma_inc: set_tx4925_dma_inc,
+	get_dma_residue: get_tx4925_dma_residue,
+	get_dma_status: get_tx4925_dma_status,
+	clear_dma_status: clear_tx4925_dma_status,
+	get_dma_irqno: get_tx4925_dma_irqno,
+	set_dma_chain: set_tx4925_dma_chain,
+	get_dma_chain: get_tx4925_dma_chain,
+	set_chdma_mode: set_tx4925_chdma_mode,
+	set_chdma_addr: set_tx4925_chdma_addr,
+	get_chdma_addr: get_tx4925_chdma_addr,
+	set_chdma_addr64: set_tx4925_chdma_addr64,
+	get_chdma_addr64: get_tx4925_chdma_addr64,
+	set_chdma_count: set_tx4925_chdma_count,
+	get_chdma_count: get_tx4925_chdma_count,
+	set_chdma_inc: set_tx4925_chdma_inc,
+	set_chdma_chain: set_tx4925_chdma_chain,
+	get_chdma_chain: get_tx4925_chdma_chain,
+	alloc_chdma_cmd: alloc_tx4925_chdma_cmd,
+	free_chdma_cmd: free_tx4925_chdma_cmd
+};
+
+#endif	/* HAVE_4925_DMA */
+
+struct txx927_dma_ops *txx927_dma_ops;	EXPORT_SYMBOL(txx927_dma_ops);
+
+void __init toshibaboards_dma_setup(void)
+{
+	switch (current_cpu_data.cputype) {
+#ifdef HAVE_3927_DMA
+	case CPU_TX3927:
+		txx927_dma_ops = &tx3927_dma_ops;
+		break;
+#endif
+	case CPU_TX49XX:
+		switch (mips_machtype) {
+		case MACH_TOSHIBA_RBTX4925:
+#ifdef HAVE_4925_DMA
+			if (TX4925_REV_PCODE() == 0x4925 ||
+			    TX4925_REV_PCODE() == 0x4926)
+				txx927_dma_ops = &tx4925_dma_ops;
+#endif
+			break;
+		case MACH_TOSHIBA_TX4927EVB:
+		case MACH_TOSHIBA_RBTX4927:
+#ifdef HAVE_4927_DMA
+			if (TX4927_REV_PCODE() == 0x4927)
+				txx927_dma_ops = &tx4927_dma_ops;
+#endif
+			break;
+		}
+		break;
+	}
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/dump_tx3927.c linux-2.4.32-mct/arch/mips/mct-boards/generic/dump_tx3927.c
--- linux-2.4.32/arch/mips/mct-boards/generic/dump_tx3927.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/dump_tx3927.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,38 @@
+/*
+ *  linux/arch/mips/toshiba-boards/generic/dump_tx3927.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <asm/tx3927.h>
+
+void tx3927_dump_pcic_settings(void)
+{
+	printk("tx3927 pcic settings:");
+	{
+		int i;
+		unsigned long *preg = (unsigned long *)tx3927_pcicptr;
+		for (i = 0; i < sizeof(struct tx3927_pcic_reg); i += 4) {
+			if (i % 32 == 0)
+				printk("\n%04x:", i);
+			/* skip registers with side-effects */
+			if (preg == &tx3927_pcicptr->iiadp
+			    || preg == &tx3927_pcicptr->ica
+			    || preg == &tx3927_pcicptr->icd
+				) {
+				printk(" XXXXXXXX");
+				preg++;
+				continue;
+			}
+			printk(" %08lx", *preg++);
+		}
+		printk("\n");
+	}
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/dump_tx4925.c linux-2.4.32-mct/arch/mips/mct-boards/generic/dump_tx4925.c
--- linux-2.4.32/arch/mips/mct-boards/generic/dump_tx4925.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/dump_tx4925.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,120 @@
+/*
+ *  linux/arch/mips/toshiba-boards/generic/dump_tx4925.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <asm/tx4925.h>
+
+void tx4925_dump_pcic_settings(void)
+{
+	int i;
+	unsigned long *preg = (unsigned long *)tx4925_pcicptr;
+
+	printk("tx4925 pcic settings:");
+	for (i = 0; i < sizeof(struct tx4925_pcic_reg); i += 4) {
+		if (i % 32 == 0)
+			printk("\n%04x:", i);
+		/* skip registers with side-effects */
+		if (preg == &tx4925_pcicptr->g2pintack
+		    || preg == &tx4925_pcicptr->g2pspc
+		    || preg == &tx4925_pcicptr->g2pcfgdata
+		    || preg == &tx4925_pcicptr->g2piddata
+		    || preg == &tx4925_pcicptr->g2pidcmd
+			) {
+			printk(" XXXXXXXX");
+			preg++;
+			continue;
+		}
+		printk(" %08lx", *preg++);
+	}
+	printk("\n");
+}
+
+void tx4925_dump_irc_settings(void)
+{
+	int i;
+
+	printk("tx4925 irc settings:\n");
+	printk("cer:\t%08lx\n", tx4925_ircptr->cer);
+	for (i = 0; i < 2; i++)
+		printk("cr%d:\t%08lx\n", i, tx4925_ircptr->cr[i]);
+	for (i = 0; i < 8; i++)
+		printk("ilr%d:\t%08lx\n", i, tx4925_ircptr->ilr[i]);
+	printk("imr:\t%08lx\n", tx4925_ircptr->cer);
+	printk("scr:\t%08lx\n", tx4925_ircptr->scr);
+	printk("ssr:\t%08lx\n", tx4925_ircptr->ssr);
+	printk("csr:\t%08lx\n", tx4925_ircptr->csr);
+}
+
+void tx4925_dump_dmac_settings(int dmach)
+{
+	printk("tx4925 dmac[%d] settings:\n", dmach);
+	printk("cha:\t%08lx\n", tx4925_dmaptr->ch[dmach].cha);
+	printk("sar:\t%08lx\n", tx4925_dmaptr->ch[dmach].sar);
+	printk("dar:\t%08lx\n", tx4925_dmaptr->ch[dmach].dar);
+	printk("cntr:\t%08lx\tsair:\t%08lx\tdair:\t%08lx\n",
+	       tx4925_dmaptr->ch[dmach].cntr,
+	       tx4925_dmaptr->ch[dmach].sair,
+	       tx4925_dmaptr->ch[dmach].dair);
+	printk("ccr:\t%08lx\tcsr:\t%08lx\n",
+	       tx4925_dmaptr->ch[dmach].ccr,
+	       tx4925_dmaptr->ch[dmach].csr);
+}
+
+void tx4925_dump_dmac_settings_all(void)
+{
+	int i;
+
+	printk("tx4925 dmac settings:\n");
+	printk("mcr:\t%08lx\n", tx4925_dmaptr->mcr);
+	for (i = 0; i < 4; i++)
+		tx4925_dump_dmac_settings(i);
+}
+
+void tx4925_report_pcic_status(void)
+{
+	unsigned short pcistatus = (unsigned short)(tx4925_pcicptr->pcistatus >> 16);
+	unsigned long g2pstatus = tx4925_pcicptr->g2pstatus;
+	unsigned long pcicstatus = tx4925_pcicptr->pcicstatus;
+	printk("pcistat:%04x(", pcistatus);
+	if (pcistatus & PCI_STATUS_DETECTED_PARITY)
+		printk("DetectedParityError ");
+	if (pcistatus & PCI_STATUS_SIG_SYSTEM_ERROR)
+		printk("SignaledSystemError ");
+	if (pcistatus & PCI_STATUS_REC_MASTER_ABORT)
+		printk("ReceivedMasterAbort ");
+	if (pcistatus & PCI_STATUS_REC_TARGET_ABORT)
+		printk("ReceivedTargetAbort ");
+	if (pcistatus & PCI_STATUS_SIG_SYSTEM_ERROR)
+		printk("SignaledSystemError ");
+	if (pcistatus & PCI_STATUS_PARITY)
+		printk("MasterParityError ");
+	printk("), g2pstatus:%08lx(", g2pstatus);
+	if (g2pstatus & TX4925_PCIC_G2PSTATUS_MDFE)
+		printk("MDFE ");
+	if (g2pstatus & TX4925_PCIC_G2PSTATUS_MDPE)
+		printk("MDPE ");
+	if (g2pstatus & TX4925_PCIC_G2PSTATUS_IDICC)
+		printk("IDICC ");
+	if (g2pstatus & TX4925_PCIC_G2PSTATUS_MIDPE)
+		printk("MIDPE ");
+	if (g2pstatus & TX4925_PCIC_G2PSTATUS_MIDFE)
+		printk("MIDFE ");
+	if (g2pstatus & TX4925_PCIC_G2PSTATUS_IDTTOE)
+		printk("IDTTOE ");
+	if (g2pstatus & TX4925_PCIC_G2PSTATUS_IDRTOE)
+		printk("IDRTOE ");
+	printk("), pcicstatus:%08lx(", pcicstatus);
+	if (pcicstatus & TX4925_PCIC_PCICSTATUS_SERR)
+		printk("SERR ");
+	printk(")\n");
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/dump_tx4927.c linux-2.4.32-mct/arch/mips/mct-boards/generic/dump_tx4927.c
--- linux-2.4.32/arch/mips/mct-boards/generic/dump_tx4927.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/dump_tx4927.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,130 @@
+/*
+ *  linux/arch/mips/toshiba-boards/generic/dump_tx4927.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <asm/tx4927.h>
+
+static inline void printk_ll(const char *fmt, unsigned long long val)
+{
+	printk(fmt, (unsigned long)(val >> 32), (unsigned long)val);
+}
+
+void tx4927_dump_pcic_settings(void)
+{
+	int i;
+	unsigned long *preg = (unsigned long *)tx4927_pcicptr;
+
+	printk("tx4927 pcic settings:");
+	for (i = 0; i < sizeof(struct tx4927_pcic_reg); i += 4) {
+		if (i % 32 == 0)
+			printk("\n%04x:", i);
+		/* skip registers with side-effects */
+		if (preg == &tx4927_pcicptr->g2pintack
+		    || preg == &tx4927_pcicptr->g2pspc
+		    || preg == &tx4927_pcicptr->g2pcfgadrs
+		    || preg == &tx4927_pcicptr->g2pcfgdata
+			) {
+			printk(" XXXXXXXX");
+			preg++;
+			continue;
+		}
+		printk(" %08lx", *preg++);
+	}
+	printk("\n");
+}
+
+void tx4927_dump_irc_settings(void)
+{
+	int i;
+
+	printk("tx4927 irc settings:\n");
+	printk("cer:\t%08lx\n", tx4927_ircptr->cer);
+	for (i = 0; i < 2; i++)
+		printk("cr%d:\t%08lx\n", i, tx4927_ircptr->cr[i]);
+	for (i = 0; i < 8; i++)
+		printk("ilr%d:\t%08lx\n", i, tx4927_ircptr->ilr[i]);
+	printk("imr:\t%08lx\n", tx4927_ircptr->cer);
+	printk("scr:\t%08lx\n", tx4927_ircptr->scr);
+	printk("ssr:\t%08lx\n", tx4927_ircptr->ssr);
+	printk("csr:\t%08lx\n", tx4927_ircptr->csr);
+}
+
+void tx4927_dump_dmac_settings(int dmach)
+{
+	printk("tx4927 dmac[%d] settings:\n", dmach);
+	printk_ll("cha:\t%08lx_%08lx\n", tx4927_dmaptr->ch[dmach].cha);
+	printk_ll("sar:\t%08lx_%08lx\n", tx4927_dmaptr->ch[dmach].sar);
+	printk_ll("dar:\t%08lx_%08lx\n", tx4927_dmaptr->ch[dmach].dar);
+	printk("cntr:\t%08lx\tsair:\t%08lx\tdair:\t%08lx\n",
+	       tx4927_dmaptr->ch[dmach].cntr,
+	       tx4927_dmaptr->ch[dmach].sair,
+	       tx4927_dmaptr->ch[dmach].dair);
+	printk("ccr:\t%08lx\tcsr:\t%08lx\n",
+	       tx4927_dmaptr->ch[dmach].ccr,
+	       tx4927_dmaptr->ch[dmach].csr);
+}
+
+void tx4927_dump_dmac_settings_all(void)
+{
+	int i;
+
+	printk("tx4927 dmac settings:\n");
+	printk("mcr:\t%08lx\n", tx4927_dmaptr->mcr);
+	for (i = 0; i < 4; i++)
+		tx4927_dump_dmac_settings(i);
+}
+
+void tx4927_report_pcic_status(void)
+{
+	unsigned short pcistatus = (unsigned short)(tx4927_pcicptr->pcistatus >> 16);
+	unsigned long g2pstatus = tx4927_pcicptr->g2pstatus;
+	unsigned long pcicstatus = tx4927_pcicptr->pcicstatus;
+	printk("pcistat:%04x(", pcistatus);
+	if (pcistatus & PCI_STATUS_DETECTED_PARITY)
+		printk("DetectedParityError ");
+	if (pcistatus & PCI_STATUS_SIG_SYSTEM_ERROR)
+		printk("SignaledSystemError ");
+	if (pcistatus & PCI_STATUS_REC_MASTER_ABORT)
+		printk("ReceivedMasterAbort ");
+	if (pcistatus & PCI_STATUS_REC_TARGET_ABORT)
+		printk("ReceivedTargetAbort ");
+	if (pcistatus & PCI_STATUS_SIG_SYSTEM_ERROR)
+		printk("SignaledSystemError ");
+	if (pcistatus & PCI_STATUS_PARITY)
+		printk("MasterParityError ");
+	printk("), g2pstatus:%08lx(", g2pstatus);
+	if (g2pstatus & TX4927_PCIC_G2PSTATUS_TTOE)
+		printk("TIOE ");
+	if (g2pstatus & TX4927_PCIC_G2PSTATUS_RTOE)
+		printk("RTOE ");
+	printk("), pcicstatus:%08lx(", pcicstatus);
+	if (pcicstatus & TX4927_PCIC_PCICSTATUS_PMESID)
+		printk("PMESID ");
+	if (pcicstatus & TX4927_PCIC_PCICSTATUS_TLBD)
+		printk("TLBD ");
+	if (pcicstatus & TX4927_PCIC_PCICSTATUS_NIBD)
+		printk("NIBD ");
+	if (pcicstatus & TX4927_PCIC_PCICSTATUS_ZIBD)
+		printk("ZIBD ");
+	if (pcicstatus & TX4927_PCIC_PCICSTATUS_PERRO)
+		printk("PERRO ");
+	if (pcicstatus & TX4927_PCIC_PCICSTATUS_SERRO)
+		printk("SERRO ");
+	if (pcicstatus & TX4927_PCIC_PCICSTATUS_GBED)
+		printk("GBED ");
+	if (pcicstatus & TX4927_PCIC_PCICSTATUS_IAA)
+		printk("IAA ");
+	if (pcicstatus & TX4927_PCIC_PCICSTATUS_IWB)
+		printk("IWB ");
+	printk(")\n");
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/gdb_hook.c linux-2.4.32-mct/arch/mips/mct-boards/generic/gdb_hook.c
--- linux-2.4.32/arch/mips/mct-boards/generic/gdb_hook.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/gdb_hook.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,451 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ * Modified for TOSHIBA boards (Nov/2001)
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * This is the interface to the remote debugger stub.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/serialP.h>
+#include <linux/serial_reg.h>
+
+#include <asm/serial.h>
+#include <asm/io.h>
+
+static struct irqaction kgdb_irqaction;
+static struct resource kgdb_resource;
+
+static int (*generic_putDebugChar)(char);
+static char (*generic_getDebugChar)(void);
+static void (*generic_setupDebugInterrupt)(void);
+
+int putDebugChar(char c)
+{
+	return generic_putDebugChar(c);
+}
+
+char getDebugChar(void) 
+{
+	return generic_getDebugChar();
+}
+
+void setupDebugInterrupt(void) 
+{
+	if (generic_setupDebugInterrupt)
+		generic_setupDebugInterrupt();
+}
+
+static void do_stop_command(struct pt_regs *regs)
+{
+	extern void set_async_breakpoint(unsigned int epc);
+	extern void breakpoint(void);
+	if (!user_mode(regs))
+		set_async_breakpoint(read_32bit_cp0_register(CP0_EPC));
+	else
+		breakpoint();
+}
+
+#if defined(CONFIG_TOSHIBA_SDB) || defined(CONFIG_TOSHIBA_TX4927EVB)
+
+static struct serial_state rs_kgdb_table[2];
+#define NR_PORTS	(sizeof(rs_kgdb_table)/sizeof(struct serial_state))
+
+static struct async_struct kdb_port_info = {0};
+static int kgdb_baud = 9600;
+
+static __inline__ unsigned int serial_in(struct async_struct *info, int offset)
+{
+	return inb(info->port + offset);
+}
+
+static __inline__ void serial_out(struct async_struct *info, int offset,
+				int value)
+{
+	outb(value, info->port+offset);
+}
+
+static void rs_debug_chipinit(int intson, int baud)
+{
+	int t;
+
+	/*
+	 * Clear all interrupts
+	 */
+	serial_in(&kdb_port_info, UART_LSR);
+	serial_in(&kdb_port_info, UART_RX);
+	serial_in(&kdb_port_info, UART_IIR);
+	serial_in(&kdb_port_info, UART_MSR);
+
+	/*
+	 * Now, initialize the UART 
+	 */
+	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8);	/* reset DLAB */
+	if (kdb_port_info.flags & ASYNC_FOURPORT) {
+		kdb_port_info.MCR = UART_MCR_DTR | UART_MCR_RTS;
+		t = UART_MCR_DTR | UART_MCR_OUT1;
+	} else {
+		kdb_port_info.MCR 
+			= UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2;
+		t = UART_MCR_DTR | UART_MCR_RTS;
+	}
+
+	if (!intson)
+		kdb_port_info.MCR = t;		/* no interrupts, please */
+	serial_out(&kdb_port_info, UART_MCR, kdb_port_info.MCR);
+	if (intson) {
+		/* enable receiver data interrupt */
+		serial_out(&kdb_port_info, UART_IER, UART_IER_RDI);
+	}
+	
+	/*
+	 * and set the speed of the serial port
+	 */
+
+	t = kdb_port_info.state->baud_base / baud;
+	/* set DLAB */
+	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8 | UART_LCR_DLAB);
+	serial_out(&kdb_port_info, UART_DLL, t & 0xff);/* LS of divisor */
+	serial_out(&kdb_port_info, UART_DLM, t >> 8);  /* MS of divisor */
+	/* reset DLAB */
+	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8);
+}
+
+static int rs_putDebugChar(char c)
+{
+
+	if (!kdb_port_info.state) { 	/* need to init device first */
+		return 0;
+	}
+
+	while ((serial_in(&kdb_port_info, UART_LSR) & UART_LSR_THRE) == 0)
+		;
+
+	serial_out(&kdb_port_info, UART_TX, c);
+
+	return 1;
+}
+
+static char rs_getDebugChar(void)
+{
+	if (!kdb_port_info.state) { 	/* need to init device first */
+		return 0;
+	}
+
+	while (!(serial_in(&kdb_port_info, UART_LSR) & 1))
+		;
+
+	return(serial_in(&kdb_port_info, UART_RX));
+}
+
+/*
+ * This is the serial driver's interrupt routine for a debug port
+ */
+static void rs_interrupt_debug(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int status;
+	unsigned char ch;
+	
+	/* Look for kgdb 'stop' character, consult the gdb
+	 * documentation for remote target debugging and
+	 * arch/sparc/kernel/sparc-stub.c (or arch/mips/kernel/gdb-stub.c)
+	 * to see how all this works.
+	 */
+	status = serial_in(&kdb_port_info, UART_LSR);
+	if (status & UART_LSR_DR) {
+		ch = serial_in(&kdb_port_info, UART_RX);
+		if ((ch =='\003'))
+			do_stop_command(regs);
+	}
+	/* clear interrupt source... (required?) */
+	while (!(serial_in(&kdb_port_info, UART_IIR) & UART_IIR_NO_INT)) {
+		if (serial_in(&kdb_port_info, UART_LSR) & UART_LSR_DR) {
+			(void)serial_in(&kdb_port_info, UART_RX);
+		}
+		(void)serial_in(&kdb_port_info, UART_MSR);
+	}
+}
+
+
+static void __init rs_setupDebugInterrupt(void)
+{
+	unsigned long flags;
+
+	/* Enable interrupts because we now want to receive the
+	 * 'control-c' character from the client attached to us
+	 * asynchronously.
+	 */
+	if (!kdb_port_info.state)
+		return;
+	kgdb_irqaction.handler = rs_interrupt_debug;
+	kgdb_irqaction.flags = SA_INTERRUPT;
+	kgdb_irqaction.name = "serial(debug)";
+	save_and_cli(flags);
+	if (setup_irq(kdb_port_info.state->irq, &kgdb_irqaction) == 0) {
+		rs_debug_chipinit(1, kgdb_baud);
+		printk(KERN_INFO "ttyS%02d: enable interrupts for C-c.\n",
+		       kdb_port_info.line);
+	}
+	restore_flags(flags);
+}
+
+void __init rs_kgdb_hook(int tty_no, int baud)
+{
+	struct serial_state *ser = &rs_kgdb_table[tty_no];
+
+	if (tty_no >= NR_PORTS)
+		return;
+	kdb_port_info.state = ser;
+	kdb_port_info.magic = SERIAL_MAGIC;
+	kdb_port_info.port = ser->port;
+	kdb_port_info.flags = ser->flags;
+	kdb_port_info.line = tty_no;
+
+	kgdb_baud = baud;
+
+	/* prevent initialization by driver */
+	kgdb_resource.name = "serial(debug)";
+	kgdb_resource.start = ser->port;
+	kgdb_resource.end = ser->port + 8 - 1;
+	kgdb_resource.flags = IORESOURCE_IO | IORESOURCE_BUSY;
+	request_resource(&ioport_resource, &kgdb_resource);
+
+	rs_debug_chipinit(0, baud);
+
+	generic_putDebugChar = rs_putDebugChar;
+	generic_getDebugChar = rs_getDebugChar;
+	generic_setupDebugInterrupt = rs_setupDebugInterrupt;
+}
+
+int __init early_serial_kgdb_setup(struct serial_struct *req)
+{
+	int i = req->line;
+
+	if (i >= NR_PORTS)
+		return(-ENOENT);
+	rs_kgdb_table[i].magic = 0;
+	rs_kgdb_table[i].baud_base = req->baud_base;
+	rs_kgdb_table[i].port = req->port;
+	rs_kgdb_table[i].irq = req->irq;
+	rs_kgdb_table[i].flags = req->flags;
+	rs_kgdb_table[i].close_delay = req->close_delay;
+	rs_kgdb_table[i].io_type = req->io_type;
+	rs_kgdb_table[i].hub6 = req->hub6;
+	rs_kgdb_table[i].iomem_base = req->iomem_base;
+	rs_kgdb_table[i].iomem_reg_shift = req->iomem_reg_shift;
+	rs_kgdb_table[i].type = req->type;
+	rs_kgdb_table[i].xmit_fifo_size = req->xmit_fifo_size;
+	rs_kgdb_table[i].custom_divisor = req->custom_divisor;
+	rs_kgdb_table[i].closing_wait = req->closing_wait;
+	return(0);
+}
+
+#endif
+
+#if defined(CONFIG_TOSHIBA_JMR3927) || defined(CONFIG_TOSHIBA_TX4927EVB) || \
+	defined(CONFIG_TOSHIBA_RBTX4927) || defined(CONFIG_TOSHIBA_RBTX4925)
+
+#include <asm/txx927.h>
+
+#define TXX927_NR_PORTS	2
+static int txx927_kdb_port = -1;
+
+/*
+ * Hardware specific serial port structure
+ */
+static struct rs_kgdb_port { 	
+	unsigned long		base;
+	int			irq;
+	int			baud_base;
+	int			flags;
+} rs_kgdb_ports[TXX927_NR_PORTS]; 
+
+static inline struct txx927_sio_reg *sio_reg(struct rs_kgdb_port *port)
+{
+	return (struct txx927_sio_reg *)port->base;
+}
+
+int txx927_rs_putDebugChar(char c)
+{
+	struct rs_kgdb_port *port = &rs_kgdb_ports[txx927_kdb_port];
+	if (txx927_kdb_port < 0) { 	/* need to init device first */
+		return 0;
+	}
+
+	while (!(sio_reg(port)->cisr & TXx927_SICISR_TXALS))
+		;
+	sio_reg(port)->tfifo = c;
+
+	return 1;
+}
+
+char txx927_rs_getDebugChar(void)
+{
+	int dicr;
+	char c;
+	struct rs_kgdb_port *port = &rs_kgdb_ports[txx927_kdb_port];
+	if (txx927_kdb_port < 0) { 	/* need to init device first */
+		return 0;
+	}
+	/* diable RX int. */
+	dicr = sio_reg(port)->dicr;
+	sio_reg(port)->dicr = 0;
+
+	/* read char */
+	while (sio_reg(port)->disr & TXx927_SIDISR_UVALID)
+		;
+	c = sio_reg(port)->rfifo;
+
+	/* clear RX int. status */
+	sio_reg(port)->disr &= ~TXx927_SIDISR_RDIS;
+	/* enable RX int. */
+	sio_reg(port)->dicr = dicr;
+
+	return c;
+}
+
+static void txx927_rs_interrupt_debug(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct rs_kgdb_port *port = &rs_kgdb_ports[txx927_kdb_port];
+	int status;
+	unsigned char ch;
+	
+	/* Look for kgdb 'stop' character, consult the gdb
+	 * documentation for remote target debugging and
+	 * arch/sparc/kernel/sparc-stub.c (or arch/mips/kernel/gdb-stub.c)
+	 * to see how all this works.
+	 */
+	status = sio_reg(port)->disr;
+	if (!(status & TXx927_SIDISR_UVALID)) {
+		ch = sio_reg(port)->rfifo;
+		if ((ch =='\003'))
+			do_stop_command(regs);
+	}
+	/* clear interrupt source... (required?) */
+	while (sio_reg(port)->disr & (TXx927_SIDISR_RDIS|TXx927_SIDISR_TOUT)) {
+		if (!(sio_reg(port)->disr & TXx927_SIDISR_UVALID)) {
+			(void)sio_reg(port)->rfifo;
+		}
+		sio_reg(port)->disr &= ~(TXx927_SIDISR_RDIS|TXx927_SIDISR_TOUT);
+	}
+}
+
+static void __init txx927_rs_setupDebugInterrupt(void)
+{
+	unsigned long flags;
+	struct rs_kgdb_port *port = &rs_kgdb_ports[txx927_kdb_port];
+
+	/* Enable interrupts because we now want to receive the
+	 * 'control-c' character from the client attached to us
+	 * asynchronously.
+	 */
+	if (txx927_kdb_port < 0)
+		return;
+	kgdb_irqaction.handler = txx927_rs_interrupt_debug;
+	kgdb_irqaction.flags = SA_INTERRUPT;
+	kgdb_irqaction.name = "serial_txx927(debug)";
+	save_and_cli(flags);
+	if (setup_irq(port->irq, &kgdb_irqaction) == 0) {
+		/* clear FIFO */
+		sio_reg(port)->fcr |=
+			TXx927_SIFCR_TFRST | TXx927_SIFCR_RFRST |
+			TXx927_SIFCR_FRSTE;
+		sio_reg(port)->fcr &=
+			~(TXx927_SIFCR_TFRST | TXx927_SIFCR_RFRST |
+			  TXx927_SIFCR_FRSTE);
+		/* clear interrupts */
+		sio_reg(port)->disr = 0;
+		/* enable receiver data interrupt */
+		sio_reg(port)->dicr |= TXx927_SIDICR_RIE;
+		printk(KERN_INFO "ttySC%02d: enable interrupts for C-c.\n",
+		       txx927_kdb_port);
+	}
+	restore_flags(flags);
+}
+
+void __init txx927_rs_kgdb_hook(int tty_no, int baud)
+{
+	struct rs_kgdb_port *port = &rs_kgdb_ports[tty_no];
+
+	if (tty_no < 0 || tty_no >= TXX927_NR_PORTS)
+		return;
+	if (!port->base)
+		return;
+	txx927_kdb_port = tty_no;
+
+	/*
+	 * Reset the UART.
+	 */
+	sio_reg(port)->fcr = TXx927_SIFCR_SWRST;
+	while (sio_reg(port)->fcr & TXx927_SIFCR_SWRST)
+		;
+
+	/*
+	 * and set the speed of the serial port
+	 * (currently hardwired to 9600 8N1
+	 */
+
+	sio_reg(port)->lcr = TXx927_SILCR_UMODE_8BIT |
+		TXx927_SILCR_USBL_1BIT |
+		TXx927_SILCR_SCS_IMCLK_BG;
+	sio_reg(port)->bgr =
+		((port->baud_base + baud / 2) / baud) |
+		TXx927_SIBGR_BCLK_T0;
+
+	/* no RTS/CTS control */
+	sio_reg(port)->flcr = TXx927_SIFLCR_RTSTL_MAX /* 15 */;
+	/* Enable RX/TX */
+	sio_reg(port)->flcr &= ~(TXx927_SIFLCR_RSDE | TXx927_SIFLCR_TSDE);
+
+	/* prevent initialization by driver */
+	kgdb_resource.name = "serial_txx927(debug)";
+	kgdb_resource.start = port->base;
+	kgdb_resource.end = port->base + 36 - 1;
+	kgdb_resource.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+	if (request_resource(&iomem_resource, &kgdb_resource) == -EBUSY) {
+		/* we must find TX4927 resource... */
+		struct resource *child = iomem_resource.child;
+		while (child) {
+			if (request_resource(child, &kgdb_resource) == 0)
+				break;
+			child = child->sibling;
+		}
+	}
+
+	generic_putDebugChar = txx927_rs_putDebugChar;
+	generic_getDebugChar = txx927_rs_getDebugChar;
+	generic_setupDebugInterrupt = txx927_rs_setupDebugInterrupt;
+}
+
+int __init early_serial_txx927_kgdb_setup(int line, unsigned long base, int irq, int baud_base)
+{
+	if (line >= TXX927_NR_PORTS)
+		return(-ENOENT);
+	rs_kgdb_ports[line].base = base;
+	rs_kgdb_ports[line].irq = irq;
+	rs_kgdb_ports[line].baud_base = baud_base;
+	return(0);
+}
+
+#endif
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/ide-jmi39io2.c linux-2.4.32-mct/arch/mips/mct-boards/generic/ide-jmi39io2.c
--- linux-2.4.32/arch/mips/mct-boards/generic/ide-jmi39io2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/ide-jmi39io2.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,64 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * IDE routines for typical pc-like standard configurations.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/hdreg.h>
+#include <linux/ide.h>
+#include <asm/ptrace.h>
+#include <asm/toshiba-boards/jmi39io2.h>
+
+extern struct ide_ops std_ide_ops;
+static unsigned long jmi39io2_ide_port;
+static int jmi39io2_ide_irq;
+
+static int jmi39io2_ide_default_irq(ide_ioreg_t base)
+{
+	if (base == jmi39io2_ide_port)
+		return jmi39io2_ide_irq;
+	return std_ide_ops.ide_default_irq(base);
+}
+
+static ide_ioreg_t jmi39io2_ide_default_io_base(int index)
+{
+	if (index == 0)
+		return jmi39io2_ide_port;
+	return std_ide_ops.ide_default_io_base(index);
+}
+
+static void jmi39io2_ide_init_hwif_ports(hw_regs_t *hw,
+				    ide_ioreg_t data_port,
+				    ide_ioreg_t ctrl_port,
+				    int *irq)
+{
+	std_ide_ops.ide_init_hwif_ports(hw, data_port, ctrl_port, irq);
+	if (data_port == jmi39io2_ide_port) {
+		if (!ctrl_port)
+			hw->io_ports[IDE_CONTROL_OFFSET] += 0x00100000;
+		if (irq)
+			*irq = jmi39io2_ide_irq;
+	}
+}
+
+static struct ide_ops jmi39io2_ide_ops;
+
+void __init jmi39io2_ide_init(void)
+{
+	jmi39io2_ide_port = JMI39IO2_IDE_ADDR(jmi39io2_iob_base) - mips_io_port_base;
+	/* irq_jmi39io2isac maps ISA irqs automagically... */
+	jmi39io2_ide_irq = 12;
+	/* jmi39io2_ide_irq = jmi39io2_isac_irq_base + JMI39IO2_ISAC_INTB_IRQ12; */
+
+	jmi39io2_ide_ops = std_ide_ops;
+	/* override */
+	jmi39io2_ide_ops.ide_default_irq = jmi39io2_ide_default_irq,
+	jmi39io2_ide_ops.ide_default_io_base = jmi39io2_ide_default_io_base,
+	jmi39io2_ide_ops.ide_init_hwif_ports = jmi39io2_ide_init_hwif_ports,
+	ide_ops = &jmi39io2_ide_ops;
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/int-handler.S linux-2.4.32-mct/arch/mips/mct-boards/generic/int-handler.S
--- linux-2.4.32/arch/mips/mct-boards/generic/int-handler.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/int-handler.S	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,165 @@
+/*
+ *  linux/arch/mips/toshiba-boards/generic/int-handler.S
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+	/* A lot of complication here is taken away because:
+	 *
+	 * 1) We handle one interrupt and return, sitting in a loop
+	 *    and moving across all the pending IRQ bits in the cause
+	 *    register is _NOT_ the answer, the common case is one
+	 *    pending IRQ so optimize in that direction.
+	 *
+	 * 2) We need not check against bits in the status register
+	 *    IRQ mask, that would make this routine slow as hell.
+	 *
+	 * 3) Linux only thinks in terms of all IRQs on or all IRQs
+	 *    off, nothing in between like BSD spl() brain-damage.
+	 *
+	 */
+
+	.text
+	.set	noreorder
+	.set	noat
+	.align	5
+	NESTED(toshibaboards_IRQ, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+	.set	at
+	lw	t0, toshibaboards_irqdispatch
+	jalr	t0
+	 move	a0, sp
+	bltz	v0,1f
+	 nop
+	j	ret_from_irq
+	 nop
+1:
+	j	spurious_interrupt
+	 nop
+	END(toshibaboards_IRQ)
+#if 0 /* EXCEPTION_DEBUG */
+/* XXX debug buggy CPU... (see irq.c also) */
+#define EXCEPTION_LOG_EPC	0
+#if defined(CONFIG_CPU_TX49XX)
+#define EXCEPTION_LOG_COUNT	4
+#endif
+#ifdef CONFIG_CPU_TX39XX
+#define EXCEPTION_LOG_TIMER	4
+#define EXCEPTION_LOG_TIMER_ADDR	0xfffef0f0 /* TX3927 timer */
+#endif
+#define EXCEPTION_LOG_CAUSE	8
+#define EXCEPTION_LOG_BADV	12
+#undef EXCEPTION_LOG_STATUS	12
+#define EXCEPTION_LOG_MAX	16
+	.align	5
+EXPORT(exclog)
+	.word	0 :	EXCEPTION_LOG_MAX*4+1
+	.align	5
+last_random_reg:
+	.word	0
+	.set	noat
+	.set	noreorder
+	NESTED(excdbg_vec0_handler, 0, sp)
+	la	k0, exclog
+	li	k1, KSEG1
+	or	k0, k1
+	lw	k1, (EXCEPTION_LOG_MAX*16)(k0)	/* load logcount */
+	addiu	k1, 1
+	andi	k1, EXCEPTION_LOG_MAX-1
+	sw	k1, (EXCEPTION_LOG_MAX*16)(k0)	/* save logcount */
+	sll	k1, k1, 4
+	addu	k0, k1
+#ifdef EXCEPTION_LOG_EPC
+	mfc0	k1, CP0_EPC
+	sw	k1, EXCEPTION_LOG_EPC(k0)
+#endif
+#ifdef EXCEPTION_LOG_COUNT
+	mfc0	k1, CP0_COUNT
+	sw	k1, EXCEPTION_LOG_COUNT(k0)
+#endif
+#ifdef EXCEPTION_LOG_TIMER
+	lw	k1, EXCEPTION_LOG_TIMER_ADDR
+	sw	k1, EXCEPTION_LOG_TIMER(k0)
+#endif
+#ifdef EXCEPTION_LOG_CAUSE
+	mfc0	k1, CP0_CAUSE
+	ori	k1, 1
+	sw	k1, EXCEPTION_LOG_CAUSE(k0)
+#endif
+#ifdef EXCEPTION_LOG_BADV
+	mfc0	k1, CP0_BADVADDR
+	sw	k1, EXCEPTION_LOG_BADV(k0)
+#endif
+#ifdef EXCEPTION_LOG_STATUS
+	mfc0	k1, CP0_STATUS
+	sw	k1, EXCEPTION_LOG_STATUS(k0)
+#endif
+	/* If the number of TLB refill code is multiple of TLB entries,
+	 * The Random Register may be same value forever. */
+	lw	k0, last_random_reg
+1:
+	mfc0	k1, CP0_RANDOM
+	beq	k0, k1, 1b
+	 nop
+	la	k0, last_random_reg
+	sw	k1, (k0)
+#if defined(CONFIG_CPU_TX49XX)
+	j	except_vec0_r4000
+#endif
+#if defined(CONFIG_CPU_TX39XX)
+	j	except_vec0_r2300
+#endif
+	nop
+	END(excdbg_vec0_handler)
+	NESTED(excdbg_vec3_handler, 0, sp)
+	la	k0, exclog
+	li	k1, KSEG1
+	or	k0, k1
+	lw	k1, (EXCEPTION_LOG_MAX*16)(k0)	/* load logcount */
+	addiu	k1, 1
+	andi	k1, EXCEPTION_LOG_MAX-1
+	sw	k1, (EXCEPTION_LOG_MAX*16)(k0)	/* save logcount */
+	sll	k1, k1, 4
+	addu	k0, k1
+#ifdef EXCEPTION_LOG_EPC
+	mfc0	k1, CP0_EPC
+	sw	k1, EXCEPTION_LOG_EPC(k0)
+#endif
+#ifdef EXCEPTION_LOG_COUNT
+	mfc0	k1, CP0_COUNT
+	sw	k1, EXCEPTION_LOG_COUNT(k0)
+#endif
+#ifdef EXCEPTION_LOG_TIMER
+	lw	k1, EXCEPTION_LOG_TIMER_ADDR
+	sw	k1, EXCEPTION_LOG_TIMER(k0)
+#endif
+#ifdef EXCEPTION_LOG_CAUSE
+	mfc0	k1, CP0_CAUSE
+	sw	k1, EXCEPTION_LOG_CAUSE(k0)
+#endif
+#ifdef EXCEPTION_LOG_BADV
+	mfc0	k1, CP0_BADVADDR
+	sw	k1, EXCEPTION_LOG_BADV(k0)
+#endif
+#ifdef EXCEPTION_LOG_STATUS
+	mfc0	k1, CP0_STATUS
+	sw	k1, EXCEPTION_LOG_STATUS(k0)
+#endif
+	j	except_vec3_generic
+	nop
+	END(excdbg_vec3_handler)
+	.set	at
+	.set	noreorder
+#endif /* EXCEPTION_DEBUG */
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/irq.c linux-2.4.32-mct/arch/mips/mct-boards/generic/irq.c
--- linux-2.4.32/arch/mips/mct-boards/generic/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/irq.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,336 @@
+/*
+ *  linux/arch/mips/toshiba-boards/generic/irq.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+
+#include <asm/system.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/mct-boards/pmon.h>
+#include <asm/mct-boards/irq.h>
+
+/* irq_setup() overrides this */
+int (*toshibaboards_irqdispatch)(struct pt_regs *regs);
+
+/*
+ * PCI-ISA brigde interrupt controller
+ */
+static int i8259_pci_irqno;
+
+/* Explicitly generate a acknowledge cycle. Returns irq number. */
+/* generic but slow... */
+static int i8259_gen_iack(void)
+{
+	int irq;
+	unsigned char isr;
+
+	/* generate acknowledge cycle */
+	outb(0x0c, 0x20);
+	inb(0x20);
+	/* read ISR */
+	outb(0x0b, 0x20);
+	isr = inb(0x20);
+	outb(0x0a, 0x20);	/* restore */
+	if (isr & 0x04) {
+		/* generate acknowledge cycle (slave) */
+		outb(0x0c, 0xa0);
+		inb(0xa0);
+		/* read ISR (slave) */
+		outb(0x0b, 0xa0);
+		isr = inb(0xa0);
+		outb(0x0a, 0xa0);	/* restore */
+		for (irq = 0; irq < 8; irq++)
+			if (isr & (1 << irq))
+				return irq + 8;
+	} else {
+		for (irq = 0; irq < 8; irq++)
+			if (isr & (1 << irq))
+				return irq;
+	}
+	return -1;
+}
+
+/* machine dependent setup routine override this */
+int (*toshibaboards_gen_iack)(void) = i8259_gen_iack;
+
+/* If this is an interrupt from PCI-ISA bridge, convert to i8259 IRQ number. */
+int toshibaboards_i8259_irqroute(int irq)
+{
+	if (irq != i8259_pci_irqno)
+		return irq;	/* return unchanged number */
+	irq = toshibaboards_gen_iack();
+	if (irq >= NR_ISA_IRQS) {
+		printk(KERN_ERR "gen_iack:invalid irq (%d)\n", irq);
+		return -1;
+	}
+	return irq;
+}
+
+static struct irqaction i8259_action = {
+	no_action, SA_INTERRUPT|SA_SHIRQ, 0, "cascade(i8259)", NULL, NULL,
+};
+
+int __init
+toshibaboards_i8259_irq_setup(int irq)
+{
+	int err;
+	unsigned long flags;
+	extern void init_i8259_irqs (void);
+
+	if (i8259_pci_irqno)
+		return 0;
+
+	save_and_cli(flags);
+
+	init_i8259_irqs();
+	err = setup_irq(irq, &i8259_action);
+	if (!err) {
+		printk(KERN_INFO "PCI-ISA bridge PIC (irq %d)\n", irq);
+		i8259_pci_irqno = irq;
+	}
+	restore_flags(flags);
+	return err;
+}
+
+
+#ifdef CONFIG_TX_BRANCH_LIKELY_BUG_WORKAROUND
+static int tx_branch_likely_bug_count = 0;
+static int have_tx_branch_likely_bug = 0;
+void tx_branch_likely_bug_fixup(struct pt_regs *regs)
+{
+	/* TX39/49-BUG: Under this condition, the insn in delay slot
+           of the branch likely insn is executed (not nullified) even
+           the branch condition is false. */
+	if (!have_tx_branch_likely_bug)
+		return;
+	if ((regs->cp0_epc & 0xfff) == 0xffc &&
+	    KSEGX(regs->cp0_epc) != KSEG0 &&
+	    KSEGX(regs->cp0_epc) != KSEG1) {
+		unsigned int insn;
+		if (get_user(insn, (unsigned int *)(regs->cp0_epc - 4)))
+			return;
+		/* beql,bnel,blezl,bgtzl */
+		/* bltzl,bgezl,blezall,bgezall */
+		/* bczfl, bcztl */
+		if ((insn & 0xf0000000) == 0x50000000 ||
+		    (insn & 0xfc0e0000) == 0x04020000 ||
+		    (insn & 0xf3fe0000) == 0x41020000) {
+			regs->cp0_epc -= 4;
+			tx_branch_likely_bug_count++;
+			printk(KERN_INFO
+			       "fix branch-likery bug in %s (insn %08x)\n",
+			       current->comm, insn);
+		}
+	}
+}
+#endif
+
+#ifdef CONFIG_TX_FPU_C_BUG_WORKAROUND
+static int tx_fpu_c_bug_count = 0;
+static int have_tx_fpu_c_bug = 0;
+void tx_fpu_c_bug_fixup(struct pt_regs *regs)
+{
+	/* TX49-BUG: If FP ALU insn were executed immediately after
+	   C.cond.d insn and the FP ALU insn ware interrupted, the
+	   result of the C.cond.d may not be correct. */
+	if (!have_tx_fpu_c_bug)
+		return;
+	if ((regs->cp0_cause & CAUSEF_BD) == 0 &&
+	    KSEGX(regs->cp0_epc) != KSEG0 &&
+	    KSEGX(regs->cp0_epc) != KSEG1) {
+		unsigned int insn, insn2;
+		extern void save_fp(struct task_struct *);
+		extern void restore_fp(struct task_struct *);
+		extern int fpu_emulator_cop1Handler(struct pt_regs *);
+		if (get_user(insn, (unsigned int *)(regs->cp0_epc - 4)))
+			return;
+		/* c.cond.d */
+		if ((insn & 0xffe00030) != 0x46200030)
+			return;
+		if (get_user(insn2, (unsigned int *)regs->cp0_epc))
+			return;
+		/* COP1(s,d) */
+		if ((insn2 & 0xff000000) != 0x46000000)
+			return;
+		/* abs, add, ceil, cvt, floor, mov, neg, round, sub, trunc */
+		if ((2 <= (insn2 & 0x3f) && (insn2 & 0x3f) < 5) ||
+		    16 <= (insn2 & 0x3f))
+			return;
+		printk(KERN_WARNING
+		       "fix FPU bug in %s epc == %08lx, insn == %08x\n",
+		       current->comm, regs->cp0_epc, insn2);
+		tx_fpu_c_bug_count++;
+		regs->cp0_epc -= 4;
+		/* emulate C.cond.d insn.  see do_fpe() */
+		save_fp(current);
+		fpu_emulator_cop1Handler(regs);
+		current->thread.fpu.soft.sr &= ~FPU_CSR_UNI_X;
+		restore_fp(current);
+	}
+}
+#endif
+
+#ifdef CONFIG_REMOTE_DEBUG
+extern char *prom_getcmdline(void);
+extern void rs_kgdb_hook(int, int);
+extern void txx927_rs_kgdb_hook(int, int);
+extern void breakpoint(void);
+extern void set_debug_traps(void);
+extern void setupDebugInterrupt(void);
+#endif
+
+extern asmlinkage void toshibaboards_IRQ(void);
+
+void (*irq_setup)(void);
+
+void __init init_IRQ(void)
+{
+#ifdef CONFIG_REMOTE_DEBUG
+	char *ctype;
+	int line = 0;
+	int baud = 9600;
+	int use_gdb_on_std_serial = 0;
+	int use_gdb_on_txx927_serial = 0;
+#endif
+#ifdef CONFIG_TX_FPU_C_BUG_WORKAROUND
+	unsigned long revid;
+#endif
+
+#ifdef CONFIG_TX_BRANCH_LIKELY_BUG_WORKAROUND
+	/* TX3927A, TX49/H */
+	switch (mips_cpu.processor_id & 0xffff) {
+	case (PRID_IMP_TX39|PRID_REV_TX3927):
+	case (PRID_IMP_TX49|0x2d11): /* TX49/H */
+		have_tx_branch_likely_bug = 1;
+		break;
+	}
+#endif
+#ifdef CONFIG_TX_FPU_C_BUG_WORKAROUND
+	switch (mips_cpu.processor_id & 0xffff) {
+	case (PRID_IMP_TX49|0x2d11): /* TX4955 (TX49/H) */
+	case (PRID_IMP_TX49|0x2d20): /* TX4955A (TX49/H2)*/
+	case (PRID_IMP_TX49|0x2d21): /* TX4927R1 (TX49/H2) */
+	case (PRID_IMP_TX49|0x2d22): /* TX4927R2, TX4925, etc (TX49/H2) */
+	case (PRID_IMP_TX49|0x2d23):
+		/* TX4927#4 does not have this bug. */
+		if (mips_machtype == MACH_TOSHIBA_TX4927EVB ||
+		    mips_machtype == MACH_TOSHIBA_RBTX4927) {
+#ifdef __BIG_ENDIAN
+			revid = *(volatile unsigned long *)0xff1fe00c;
+#else
+			revid = *(volatile unsigned long *)0xff1fe008;
+#endif
+			if ((revid & 0xffff0000) == 0x49270000 &&
+			    (revid & 0x000000ff) >= 0x40)
+				break;
+		}
+		have_tx_fpu_c_bug = 1;
+		break;
+	}
+#endif
+
+	init_generic_irq();
+	set_except_vector(0, toshibaboards_IRQ);
+	irq_setup();	/* board specific setup */
+
+#if 0 /* EXCEPTION_DEBUG */
+/* XXX debug buggy CPU... (see int-handler.S also) */
+	{
+		extern char excdbg_vec0_handler, excdbg_vec3_handler;
+#if defined(CONFIG_CPU_TX49XX)
+		memcpy((void *)KSEG0, &excdbg_vec0_handler, 0x80);
+		memcpy((void *)(KSEG0 + 0x180), &excdbg_vec3_handler, 0x80);
+#endif
+#if defined(CONFIG_CPU_TX39XX)
+		memcpy((void *)KSEG0, &excdbg_vec0_handler, 0x80);
+		memcpy((void *)(KSEG0 + 0x80), &excdbg_vec3_handler, 0x80);
+#endif
+		flush_icache_range(KSEG0, KSEG0 + 0x200);
+	}
+#endif /* EXCEPTION_DEBUG */
+#ifdef CONFIG_REMOTE_DEBUG
+	for (ctype = prom_getcmdline(); *ctype; ctype++) {
+		/*
+		 * If we have both standard and txx927 serial,
+		 * use ttyS0,1 for Standard-SIO, ttySC0,1 for CPU-SIO.
+		 */
+		if ((strncmp(ctype, "kgdb=ttyd", 9) == 0 ||
+		     strncmp(ctype, "kgdb=ttyS", 9) == 0) &&
+		    (ctype[9] == '0' || ctype[9] == '1')) {
+			ctype += 9;
+#if defined(CONFIG_SERIAL)
+			use_gdb_on_std_serial = 1;
+#elif defined(CONFIG_SERIAL_TXX927)
+			use_gdb_on_txx927_serial = 1;
+#endif
+			break;
+		}
+#if defined(CONFIG_SERIAL) && defined(CONFIG_SERIAL_TXX927)
+		if ((strncmp(ctype, "kgdb=ttydc", 10) == 0 ||
+		     strncmp(ctype, "kgdb=ttySC", 10) == 0) &&
+		    (ctype[10] == '0' || ctype[10] == '1')) {
+			ctype += 10;
+			use_gdb_on_txx927_serial = 1;
+			break;
+		}
+#endif
+	}
+	if (use_gdb_on_std_serial || use_gdb_on_txx927_serial) {
+		line = *ctype - '0';
+		ctype++;
+		if (*ctype == ',') {
+			ctype++;
+			baud = simple_strtoul(ctype, NULL, 10);
+		}
+
+		printk("KGDB: Using serial line /dev/%s%d for "
+		       "session (%dbps)\n",
+#if defined(CONFIG_SERIAL) && defined(CONFIG_SERIAL_TXX927)
+		       use_gdb_on_txx927_serial ? "ttySC" : "ttyS",
+#else
+		       "ttyS",
+#endif
+		       line, baud);
+		pmon_printf("Now you can start KGDB session (%dbps).\n", baud);
+		/* flush FIFO :-) */
+		pmon_printf("\r\r\r\r\r\r\r\r\r");
+	}
+#ifdef CONFIG_SERIAL
+	if (use_gdb_on_std_serial) {
+		rs_kgdb_hook(line, baud);
+	}
+#endif
+#ifdef CONFIG_SERIAL_TXX927
+	if (use_gdb_on_txx927_serial) {
+		txx927_rs_kgdb_hook(line, baud);
+	}
+#endif
+	if (use_gdb_on_std_serial || use_gdb_on_txx927_serial) {
+		set_debug_traps();
+		breakpoint();
+		setupDebugInterrupt();
+	} else {
+		set_pmon_debug_traps();
+	}
+#else /* CONFIG_REMOTE_DEBUG */
+	set_pmon_debug_traps();
+#endif /* CONFIG_REMOTE_DEBUG */
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/irq_jmi39io2isac.c linux-2.4.32-mct/arch/mips/mct-boards/generic/irq_jmi39io2isac.c
--- linux-2.4.32/arch/mips/mct-boards/generic/irq_jmi39io2isac.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/irq_jmi39io2isac.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,183 @@
+/*
+ * linux/arch/mips/toshiba-boards/generic/irq_jmi39io2isac.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+
+/*
+ * JMI39IO2 ISAC defines 8 IRQs.
+ *
+ * This file exports one function:
+ *	jmi39io2_isac_irq_init();
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+
+#include <asm/system.h>
+#include <asm/toshiba-boards/jmi39io2.h>
+
+static void jmi39io2_isac_irq_enable(unsigned int irq)
+{
+	int irq_nr = irq - jmi39io2_isac_irq_base;
+	/* 0: mask */
+	unsigned char imask =
+		jmi39io2_isac_reg_in(JMI39IO2_ISAC_INTM_ADDR(jmi39io2_iob_base));
+	unsigned int bit  = 1 << irq_nr;
+	jmi39io2_isac_reg_out(imask | bit, JMI39IO2_ISAC_INTM_ADDR(jmi39io2_iob_base));
+	wbflush();
+}
+static void jmi39io2_isac_irq_disable(unsigned int irq)
+{
+	int irq_nr = irq - jmi39io2_isac_irq_base;
+	/* 0: mask */
+	unsigned char imask =
+		jmi39io2_isac_reg_in(JMI39IO2_ISAC_INTM_ADDR(jmi39io2_iob_base));
+	unsigned int bit  = 1 << irq_nr;
+	jmi39io2_isac_reg_out(imask & ~bit, JMI39IO2_ISAC_INTM_ADDR(jmi39io2_iob_base));
+	wbflush();
+}
+static unsigned int jmi39io2_isac_irq_startup(unsigned int irq)
+{
+	jmi39io2_isac_irq_enable(irq);
+	return 0;
+}
+#define	jmi39io2_isac_irq_shutdown	jmi39io2_isac_irq_disable
+
+static void jmi39io2_isac_irq_ack(unsigned int irq)
+{
+	jmi39io2_isac_irq_disable(irq);
+}
+static void jmi39io2_isac_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		jmi39io2_isac_irq_enable(irq);
+}
+
+static hw_irq_controller jmi39io2_isac_irq_controller = {
+	typename:	"JMI39IO2-ISAC",
+	startup:	jmi39io2_isac_irq_startup,
+	shutdown:	jmi39io2_isac_irq_shutdown,
+	enable:		jmi39io2_isac_irq_enable,
+	disable:	jmi39io2_isac_irq_disable,
+	ack:		jmi39io2_isac_irq_ack,
+	end:		jmi39io2_isac_irq_end,
+	set_affinity:	NULL,
+};
+
+/* for standard irq mappings */
+static int irqmap[16] = {
+	-1, -1, -1, JMI39IO2_ISAC_INTB_IRQ3,
+	JMI39IO2_ISAC_INTB_IRQ4, JMI39IO2_ISAC_INTB_IRQ5, -1, -1,
+	-1, -1, JMI39IO2_ISAC_INTB_IRQ10, -1,
+	JMI39IO2_ISAC_INTB_IRQ12, -1, -1, -1
+};
+static int irqrmap[JMI39IO2_NR_IRQ_ISAC] = {
+	5, -1, -1, 4, 12, 3, 10, -1
+};
+
+static void jmi39io2_isac_stdirq_enable(unsigned int irq)
+{
+	jmi39io2_isac_irq_enable(irqmap[irq] + jmi39io2_isac_irq_base);
+}
+static void jmi39io2_isac_stdirq_disable(unsigned int irq)
+{
+	jmi39io2_isac_irq_disable(irqmap[irq] + jmi39io2_isac_irq_base);
+}
+static unsigned int jmi39io2_isac_stdirq_startup(unsigned int irq)
+{
+	return jmi39io2_isac_irq_startup(irqmap[irq] + jmi39io2_isac_irq_base);
+}
+#define	jmi39io2_isac_stdirq_shutdown	jmi39io2_isac_stdirq_disable
+
+static void jmi39io2_isac_stdirq_ack(unsigned int irq)
+{
+	jmi39io2_isac_irq_ack(irqmap[irq] + jmi39io2_isac_irq_base);
+}
+static void jmi39io2_isac_stdirq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		jmi39io2_isac_irq_enable(irqmap[irq] + jmi39io2_isac_irq_base);
+}
+
+static hw_irq_controller jmi39io2_isac_stdirq_controller = {
+	typename:	"JMI39IO2-ISAC",
+	startup:	jmi39io2_isac_stdirq_startup,
+	shutdown:	jmi39io2_isac_stdirq_shutdown,
+	enable:		jmi39io2_isac_stdirq_enable,
+	disable:	jmi39io2_isac_stdirq_disable,
+	ack:		jmi39io2_isac_stdirq_ack,
+	end:		jmi39io2_isac_stdirq_end,
+	set_affinity:	NULL,
+};
+
+void __init
+jmi39io2_isac_irq_init(void)
+{
+	int i;
+
+	for (i = jmi39io2_isac_irq_base; i < jmi39io2_isac_irq_base + JMI39IO2_NR_IRQ_ISAC; i++) {
+		if (irqrmap[i - jmi39io2_isac_irq_base] >= 0)
+			continue; /* jmi39io2_isac_stdirq_controller */
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &jmi39io2_isac_irq_controller;
+	}
+	for (i = 0; i < 16; i++) {
+		if (irqmap[i] < 0)
+			continue;
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &jmi39io2_isac_stdirq_controller;
+	}
+
+	/* mask all ISAC interrupts */
+	jmi39io2_isac_reg_out(0, JMI39IO2_ISAC_INTM_ADDR(jmi39io2_iob_base));
+	/* setup ISAC interrupt mode (ISAIRQ3,ISAIRQ5:Low Active ???) */
+	jmi39io2_isac_reg_out(JMI39IO2_ISAC_INTF_IRQ3|JMI39IO2_ISAC_INTF_IRQ5,
+			      JMI39IO2_ISAC_INTM_ADDR(jmi39io2_iob_base));
+}
+
+/* find first bit set */
+static inline int ffs8(unsigned char x)
+{
+	int r = 1;
+
+	if (!x)
+		return 0;
+	if (!(x & 0xf)) {
+		x >>= 4;
+		r += 4;
+	}
+	if (!(x & 3)) {
+		x >>= 2;
+		r += 2;
+	}
+	if (!(x & 1)) {
+		x >>= 1;
+		r += 1;
+	}
+	return r;
+}
+
+int jmi39io2_isac_irqroute(void)
+{
+	unsigned char istat = jmi39io2_isac_reg_in(JMI39IO2_ISAC_INTS2_ADDR(jmi39io2_iob_base));
+	int irq = ffs8(istat);
+	if (irq == 0)
+		return -1;
+	irq--;
+	if (irqrmap[irq] >= 0)
+		return irqrmap[irq];
+	return jmi39io2_isac_irq_base + irq;
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/irq_tx3927.c linux-2.4.32-mct/arch/mips/mct-boards/generic/irq_tx3927.c
--- linux-2.4.32/arch/mips/mct-boards/generic/irq_tx3927.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/irq_tx3927.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,125 @@
+/*
+ * linux/arch/mips/toshiba-boards/generic/irq_tx3927.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+
+/*
+ * TX3927 defines 32 IRQs.
+ *
+ * This file exports one function:
+ *	tx3927_irq_init(int irq_base);
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/ptrace.h>
+
+#include <asm/tx3927.h>
+
+#define irc_dlevel	0
+#define irc_elevel	1
+static unsigned char irc_level[TX3927_NUM_IR] = {
+	5, 5, 5, 5, 5, 5,	/* INT[5:0] */
+	7, 7,			/* SIO */
+	5, 5, 5, 0, 0,		/* DMA, PIO, PCI */
+	6, 6, 6			/* TMR */
+};
+
+static int tx3927_irq_base = -1;
+
+static void tx3927_irq_enable(unsigned int irq)
+{
+	int irq_nr = irq - tx3927_irq_base;
+	volatile unsigned long *ilrp = &tx3927_ircptr->ilr[irq_nr / 2];
+	if (irq_nr & 1)
+		*ilrp = (*ilrp & 0x00ff) | (irc_level[irq_nr] << 8);
+	else
+		*ilrp = (*ilrp & 0xff00) | irc_level[irq_nr];
+	/* update IRCSR */
+	tx3927_ircptr->imr = 0;
+	tx3927_ircptr->imr = irc_elevel;
+}
+
+static void tx3927_irq_disable(unsigned int irq)
+{
+	int irq_nr = irq - tx3927_irq_base;
+	volatile unsigned long *ilrp = &tx3927_ircptr->ilr[irq_nr / 2];
+	if (irq_nr & 1)
+		*ilrp = (*ilrp & 0x00ff) | (irc_dlevel << 8);
+	else
+		*ilrp = (*ilrp & 0xff00) | irc_dlevel;
+	/* update IRCSR */
+	tx3927_ircptr->imr = 0;
+	tx3927_ircptr->imr = irc_elevel;
+}
+
+static unsigned int tx3927_irq_startup(unsigned int irq)
+{
+	tx3927_irq_enable(irq);
+	return 0;
+}
+#define	tx3927_irq_shutdown	tx3927_irq_disable
+
+static void tx3927_irq_ack(unsigned int irq)
+{
+	tx3927_irq_disable(irq);
+}
+static void tx3927_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		tx3927_irq_enable(irq);
+}
+
+static hw_irq_controller tx3927_irq_controller = {
+	typename:	"tx3927_irq",
+	startup:	tx3927_irq_startup,
+	shutdown:	tx3927_irq_shutdown,
+	enable:		tx3927_irq_enable,
+	disable:	tx3927_irq_disable,
+	ack:		tx3927_irq_ack,
+	end:		tx3927_irq_end,
+	set_affinity:	NULL,
+};
+
+void __init
+tx3927_irq_init(int irq_base)
+{
+	int i;
+
+	for (i= irq_base; i< irq_base + TX3927_NUM_IR; i++) {
+		/* INT[4], INT[5] pins are multiplexed. */
+		if ((i - irq_base == TX3927_IR_INT(4) ||
+		     i - irq_base == TX3927_IR_INT(5)) &&
+		    (tx3927_ccfgptr->pcfg & TX3927_PCFG_SELSIOC(0)))
+			continue;
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &tx3927_irq_controller;
+	}
+
+	tx3927_irq_base = irq_base;
+
+	/* enable interrupt control */
+	tx3927_ircptr->cer = TX3927_IRCER_ICE;
+	tx3927_ircptr->imr = irc_elevel;
+}
+
+int tx3927_irq_to_irq(int irq)
+{
+	if (irq < 0 || irq > TX3927_NUM_IR)
+		return -1;
+
+	return irq + tx3927_irq_base;
+}
+
+EXPORT_SYMBOL(tx3927_irq_to_irq);
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/irq_tx4925.c linux-2.4.32-mct/arch/mips/mct-boards/generic/irq_tx4925.c
--- linux-2.4.32/arch/mips/mct-boards/generic/irq_tx4925.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/irq_tx4925.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,140 @@
+/*
+ * linux/arch/mips/toshiba-boards/generic/irq_tx4925.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+
+/*
+ * TX4925 defines 32 IRQs.
+ *
+ * This file exports one function:
+ *	tx4925_irq_init(int irq_base);
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/ptrace.h>
+
+#include <asm/tx4925.h>
+
+#define irc_dlevel	0
+#define irc_elevel	1
+static unsigned char irc_level[TX4925_NUM_IR] = {
+	7, 7,			/* reserved, WTOERR */
+	5, 5, 5, 5, 5, 5, 5, 5,	/* INT[7:0] */
+	5, 5,			/* reserved, NAND */
+	7, 7,			/* SIO */
+	5, 5, 5, 5, 5, 5, 5,	/* DMA[3:0], PIO, PDMAC, PCIC */
+	6, 6, 6,		/* TMR[2:0] */
+	5, 5,			/* SPI, RTC */
+	5, 5, 5,		/* ACLC, ACLCPME, CHI */
+	7, 7,			/* PCIERR, PCIPME */
+	0
+};
+
+static int tx4925_irq_base = -1;
+
+static void tx4925_irq_enable(unsigned int irq)
+{
+	int irq_nr = irq - tx4925_irq_base;
+	volatile unsigned long *ilrp = &tx4925_ircptr->ilr[(irq_nr % 16 ) / 2];
+	int ofs = (irq_nr >= 16 ? 16 : 0) + ((irq_nr & 1) ? 8 : 0);
+	*ilrp = (*ilrp & ~(0xff << ofs)) | (irc_level[irq_nr] << ofs);
+	/* update IRCSR */
+	tx4925_ircptr->imr = 0;
+	tx4925_ircptr->imr = irc_elevel;
+}
+
+static void tx4925_irq_disable(unsigned int irq)
+{
+	int irq_nr = irq - tx4925_irq_base;
+	volatile unsigned long *ilrp = &tx4925_ircptr->ilr[(irq_nr % 16) / 2];
+	int ofs = (irq_nr >= 16 ? 16 : 0) + ((irq_nr & 1) ? 8 : 0);
+	*ilrp = (*ilrp & ~(0xff << ofs)) | (irc_dlevel << ofs);
+	/* update IRCSR */
+	tx4925_ircptr->imr = 0;
+	tx4925_ircptr->imr = irc_elevel;
+}
+
+static unsigned int tx4925_irq_startup(unsigned int irq)
+{
+	tx4925_irq_enable(irq);
+	return 0;
+}
+#define	tx4925_irq_shutdown	tx4925_irq_disable
+
+static void tx4925_irq_ack(unsigned int irq)
+{
+	tx4925_irq_disable(irq);
+}
+static void tx4925_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		tx4925_irq_enable(irq);
+}
+
+static hw_irq_controller tx4925_irq_controller = {
+	typename:	"tx4925_irq",
+	startup:	tx4925_irq_startup,
+	shutdown:	tx4925_irq_shutdown,
+	enable:		tx4925_irq_enable,
+	disable:	tx4925_irq_disable,
+	ack:		tx4925_irq_ack,
+	end:		tx4925_irq_end,
+	set_affinity:	NULL,
+};
+
+void __init
+tx4925_irq_init(int irq_base)
+{
+	int i;
+
+	for (i= irq_base; i< irq_base + TX4925_NUM_IR; i++) {
+		/* INT[2:7] pins are multiplexed. */
+		unsigned long pcfg = tx4925_ccfgptr->pcfg;
+		if ((i - irq_base == TX4925_IR_INT(2) ||
+		     i - irq_base == TX4925_IR_INT(3)) &&
+		    ((pcfg & (TX4925_PCFG_SELSIOC(0)|TX4925_PCFG_SELSIO(0))) ==
+		     (TX4925_PCFG_SELSIOC(0)|TX4925_PCFG_SELSIO(0))))
+			continue;
+		if ((i - irq_base == TX4925_IR_INT(4) ||
+		     i - irq_base == TX4925_IR_INT(5)) &&
+		    ((pcfg & (TX4925_PCFG_SELACLC|TX4925_PCFG_SELNAND)) ||
+		     (pcfg & (TX4925_PCFG_SELSIOC(1)|TX4925_PCFG_SELSIO(1))) ==
+		     (TX4925_PCFG_SELSIOC(1)|TX4925_PCFG_SELSIO(1))))
+			continue;
+		if ((i - irq_base == TX4925_IR_INT(6) ||
+		     i - irq_base == TX4925_IR_INT(7)) &&
+		    ((tx4925_ccfgptr->ccfg & TX4925_CCFG_PCTRCE) ||
+		     (pcfg & (TX4925_PCFG_SELCARD(1)|TX4925_PCFG_SELCE(1)))))
+			continue;
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &tx4925_irq_controller;
+	}
+
+	tx4925_irq_base = irq_base;
+
+	/* enable interrupt control */
+	tx4925_ircptr->cer = TX4925_IRCER_ICE;
+	tx4925_ircptr->imr = irc_elevel;
+}
+
+int tx4925_irq_to_irq(int irq)
+{
+	if (irq < 0 || irq > TX4925_NUM_IR)
+		return -1;
+
+	return irq + tx4925_irq_base;
+}
+
+EXPORT_SYMBOL(tx4925_irq_to_irq);
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/irq_tx4927.c linux-2.4.32-mct/arch/mips/mct-boards/generic/irq_tx4927.c
--- linux-2.4.32/arch/mips/mct-boards/generic/irq_tx4927.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/irq_tx4927.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,120 @@
+/*
+ * linux/arch/mips/toshiba-boards/generic/irq_tx4927.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+
+/*
+ * TX4927 defines 32 IRQs.
+ *
+ * This file exports one function:
+ *	tx4927_irq_init(int irq_base);
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/ptrace.h>
+
+#include <asm/tx4927.h>
+
+#define irc_dlevel	0
+#define irc_elevel	1
+static unsigned char irc_level[TX4927_NUM_IR] = {
+	7, 7,			/* ECCERR, WTOERR */
+	5, 5, 5, 5, 5, 5,	/* INT[5:0] */
+	7, 7,			/* SIO */
+	5, 5, 5, 5, 5, 5, 5,	/* DMA[3:0], PIO, PDMAC, PCIC */
+	6, 6, 6, 0, 0,			/* TMR[2:0] */
+	7, 7,			/* PCIERR, PCIPME */
+	5, 5,			/* ACLC, ACLCPME */
+	0, 0, 0, 0, 0, 0
+};
+
+static int tx4927_irq_base = -1;
+
+static void tx4927_irq_enable(unsigned int irq)
+{
+	int irq_nr = irq - tx4927_irq_base;
+	volatile unsigned long *ilrp = &tx4927_ircptr->ilr[(irq_nr % 16 ) / 2];
+	int ofs = (irq_nr >= 16 ? 16 : 0) + ((irq_nr & 1) ? 8 : 0);
+	*ilrp = (*ilrp & ~(0xff << ofs)) | (irc_level[irq_nr] << ofs);
+	/* update IRCSR */
+	tx4927_ircptr->imr = 0;
+	tx4927_ircptr->imr = irc_elevel;
+}
+
+static void tx4927_irq_disable(unsigned int irq)
+{
+	int irq_nr = irq - tx4927_irq_base;
+	volatile unsigned long *ilrp = &tx4927_ircptr->ilr[(irq_nr % 16) / 2];
+	int ofs = (irq_nr >= 16 ? 16 : 0) + ((irq_nr & 1) ? 8 : 0);
+	*ilrp = (*ilrp & ~(0xff << ofs)) | (irc_dlevel << ofs);
+	/* update IRCSR */
+	tx4927_ircptr->imr = 0;
+	tx4927_ircptr->imr = irc_elevel;
+}
+
+static unsigned int tx4927_irq_startup(unsigned int irq)
+{
+	tx4927_irq_enable(irq);
+	return 0;
+}
+#define	tx4927_irq_shutdown	tx4927_irq_disable
+
+static void tx4927_irq_ack(unsigned int irq)
+{
+	tx4927_irq_disable(irq);
+}
+static void tx4927_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		tx4927_irq_enable(irq);
+}
+
+static hw_irq_controller tx4927_irq_controller = {
+	typename:	"tx4927_irq",
+	startup:	tx4927_irq_startup,
+	shutdown:	tx4927_irq_shutdown,
+	enable:		tx4927_irq_enable,
+	disable:	tx4927_irq_disable,
+	ack:		tx4927_irq_ack,
+	end:		tx4927_irq_end,
+	set_affinity:	NULL,
+};
+
+void __init
+tx4927_irq_init(int irq_base)
+{
+	int i;
+
+	for (i= irq_base; i< irq_base + TX4927_NUM_IR; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &tx4927_irq_controller;
+	}
+
+	tx4927_irq_base = irq_base;
+
+	/* enable interrupt control */
+	tx4927_ircptr->cer = TX4927_IRCER_ICE;
+	tx4927_ircptr->imr = irc_elevel;
+}
+
+int tx4927_irq_to_irq(int irq)
+{
+	if (irq < 0 || irq > TX4927_NUM_IR)
+		return -1;
+
+	return irq + tx4927_irq_base;
+}
+
+EXPORT_SYMBOL(tx4927_irq_to_irq);
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/kbd-jmi39io2.c linux-2.4.32-mct/arch/mips/mct-boards/generic/kbd-jmi39io2.c
--- linux-2.4.32/arch/mips/mct-boards/generic/kbd-jmi39io2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/kbd-jmi39io2.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,101 @@
+/* $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ *
+ * Based on arch/mips/lib/kbd-std.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Routines for standard PC style keyboards accessible via I/O ports.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/pc_keyb.h>
+#include <asm/keyboard.h>
+#include <asm/io.h>
+#include <asm/toshiba-boards/jmi39io2.h>
+
+static unsigned long jmi39io2_kbd_port;
+static int jmi39io2_kbd_irq;
+static int jmi39io2_aux_irq;
+
+#define JMI39IO2_KBD_DATA_REG	jmi39io2_kbd_port
+#define JMI39IO2_KBD_STATUS_REG	(jmi39io2_kbd_port+4)
+#define JMI39IO2_KBD_CNTL_REG	(jmi39io2_kbd_port+4)
+
+static void jmi39io2_kbd_request_region(void)
+{
+	request_region(jmi39io2_kbd_port, 16, "keyboard");
+}
+
+static int jmi39io2_kbd_request_irq(void (*handler)(int, void *, struct pt_regs *))
+{
+	return request_irq(jmi39io2_kbd_irq, handler, 0, "keyboard", NULL);
+}
+
+static int jmi39io2_aux_request_irq(void (*handler)(int, void *, struct pt_regs *))
+{
+	return request_irq(jmi39io2_aux_irq, handler, 0, "PS/2 Mouse", NULL);
+}
+
+static void jmi39io2_aux_free_irq(void)
+{
+	free_irq(jmi39io2_aux_irq, NULL);
+}
+
+static unsigned char jmi39io2_kbd_read_input(void)
+{
+	return inb(JMI39IO2_KBD_DATA_REG);
+}
+
+static void jmi39io2_kbd_write_output(unsigned char val)
+{
+	int status;
+
+	do {
+		status = inb(JMI39IO2_KBD_CNTL_REG);
+	} while (status & KBD_STAT_IBF);
+	outb(val, JMI39IO2_KBD_DATA_REG);
+	wbflush();
+}
+
+static void jmi39io2_kbd_write_command(unsigned char val)
+{
+	int status;
+
+	do {
+		status = inb(JMI39IO2_KBD_CNTL_REG);
+	} while (status & KBD_STAT_IBF);
+	outb(val, JMI39IO2_KBD_CNTL_REG);
+	wbflush();
+}
+
+static unsigned char jmi39io2_kbd_read_status(void)
+{
+	return inb(JMI39IO2_KBD_STATUS_REG);
+}
+
+struct kbd_ops jmi39io2_kbd_ops = {
+	jmi39io2_kbd_request_region,
+	jmi39io2_kbd_request_irq,
+
+	jmi39io2_aux_request_irq,
+	jmi39io2_aux_free_irq,
+
+	jmi39io2_kbd_read_input,
+	jmi39io2_kbd_write_output,
+	jmi39io2_kbd_write_command,
+	jmi39io2_kbd_read_status
+};
+
+void __init jmi39io2_kbd_init(void)
+{
+	jmi39io2_kbd_port = JMI39IO2_KBD_ADDR(jmi39io2_iob_base) - mips_io_port_base;
+	jmi39io2_kbd_irq = jmi39io2_isac_irq_base + JMI39IO2_ISAC_INTB_IRQKB;
+	jmi39io2_aux_irq = jmi39io2_isac_irq_base + JMI39IO2_ISAC_INTB_IRQMOUSE;
+	kbd_ops = &jmi39io2_kbd_ops;
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/pci.c linux-2.4.32-mct/arch/mips/mct-boards/generic/pci.c
--- linux-2.4.32/arch/mips/mct-boards/generic/pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/pci.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,351 @@
+/*
+ *  linux/arch/mips/toshiba-boards/generic/pci.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <asm/system.h>
+#include <asm/mipsregs.h>
+#include <asm/pci_channel.h>
+#include <asm/io.h>
+#include <asm/mct-boards/pci.h>
+#include <asm/mct-boards/irq.h>
+
+static int toshibaboards_pci66_check(void)
+{
+	struct pci_dev *dev;
+	u16 stat;
+	int cap66 = -1;
+
+	/* check 66MHz capability */
+	pci_for_each_dev(dev) {
+		if (cap66 < 0)
+			cap66 = 1;
+		if (cap66) {
+			pci_read_config_word(dev, PCI_STATUS, &stat);
+			if (!(stat & PCI_STATUS_66MHZ)) {
+				printk(KERN_DEBUG "PCI: %02x:%02x not 66MHz capable.\n",
+				       dev->bus->number, dev->devfn);
+				cap66 = 0;
+			}
+		}
+	}
+	return cap66 > 0;
+}
+
+static inline u8
+bridge_swizzle(u8 pin, u8 slot) 
+{
+	return (((pin-1) + slot) % 4) + 1;
+}
+
+static u8 __init
+pci_swizzle(struct pci_dev *dev, u8 *pinp)
+{
+	u8 pin = *pinp;
+
+	while (dev->bus->self) {	/* Move up the chain of bridges. */
+		pin = bridge_swizzle(pin, PCI_SLOT(dev->devfn));
+		dev = dev->bus->self;
+	}
+	*pinp = pin;
+
+	return PCI_SLOT(dev->devfn);
+}
+
+int (*toshibaboards_pci_map_irq)(struct pci_dev *dev, u8 slot, u8 pin);
+void (*toshibaboards_pci66_init)(void);
+struct pci_ops *toshibaboards_pci_ops;
+
+struct resource toshibaboards_pci_io_resource =
+	{ "PCI IO", 0x0000, IO_SPACE_LIMIT, IORESOURCE_IO };
+struct resource toshibaboards_pci_mem_resource =
+	{ "PCI mem", 0x0000, 0xffffffff, IORESOURCE_MEM };
+static struct resource toshibaboards_pci_mmio_resource =
+	{ "PCI MMIO", 0x0000, IO_SPACE_LIMIT, IORESOURCE_MEM|IORESOURCE_BUSY };
+struct pci_channel mips_pci_channels[] = {
+        { &toshibaboards_pci_ops, &toshibaboards_pci_io_resource, &toshibaboards_pci_mem_resource,
+         PCI_DEVFN(0x00, 0), PCI_DEVFN(0x14, 7)},
+        {NULL, NULL, NULL, 0, 0}
+};
+
+void __init pcibios_fixup(void)
+{
+	/* nothing to do here */
+}
+
+void __init pcibios_fixup_resources(struct pci_dev *dev)
+{
+        /* will need to fixup IO resources */
+}
+
+void __init pcibios_fixup_irqs(void)
+{
+}
+
+#ifndef CONFIG_PCI_AUTO
+/* arch-dependent pci initialization */
+void __init pcibios_init(void)
+{
+	struct pci_dev *dev;
+
+	if (!toshibaboards_pci_ops)
+		return;
+	printk("PCI: Probing PCI hardware\n");
+
+	/* reserve MMIO area */
+	toshibaboards_pci_mmio_resource.start =
+		virt_to_phys((void *)(toshibaboards_pci_io_resource.start + mips_io_port_base));
+	toshibaboards_pci_mmio_resource.end =
+		virt_to_phys((void *)(toshibaboards_pci_io_resource.end + mips_io_port_base));
+	if (request_resource(&iomem_resource,
+			     &toshibaboards_pci_mmio_resource))
+		return;
+
+	printk("PCI: IO 0x%08lx-0x%08lx MEM 0x%08lx-0x%08lx\n",
+	       toshibaboards_pci_io_resource.start,
+	       toshibaboards_pci_io_resource.end,
+	       toshibaboards_pci_mem_resource.start,
+	       toshibaboards_pci_mem_resource.end);
+
+	pci_scan_bus(0, toshibaboards_pci_ops, NULL);
+
+	if (toshibaboards_pci66_init) {
+		if (toshibaboards_pci66_check()) {
+			toshibaboards_pci66_init();
+		}
+	}
+
+	pci_assign_unassigned_resources();
+
+	pci_fixup_irqs(pci_swizzle, toshibaboards_pci_map_irq);
+
+	pci_for_each_dev(dev) {
+#if 1 /* XXX PCI */
+		unsigned char line_size, bist, latency;
+		line_size = 32 / 4;
+		pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, line_size);
+		pci_read_config_byte(dev, PCI_CACHE_LINE_SIZE, &line_size);
+		pci_write_config_byte(dev, PCI_LATENCY_TIMER, 64);
+		pci_read_config_byte(dev, PCI_LATENCY_TIMER, &latency);
+		printk(KERN_DEBUG "PCI: %02x:%02x LINE %02x LATENCY %02x\n",
+		       dev->bus->number, dev->devfn, line_size, latency);
+
+		/* Do build-in self test */
+		pci_read_config_byte(dev, PCI_BIST, &bist);
+		if (bist & PCI_BIST_CAPABLE) {
+			printk(KERN_INFO "PCI: %02x:%02x BIST...",
+			       dev->bus->number, dev->devfn);
+			pci_write_config_byte(dev, PCI_BIST, PCI_BIST_START);
+			do {
+				pci_read_config_byte(dev, PCI_BIST, &bist);
+			} while (bist & PCI_BIST_START);
+			bist &= PCI_BIST_CODE_MASK;
+			if (bist)
+				printk("failed. (0x%x)\n", bist);
+			else
+				printk("OK.\n");
+		}
+#endif
+	}
+}
+
+void __init pcibios_fixup_bus(struct pci_bus *bus)
+{
+}
+
+int pcibios_enable_device(struct pci_dev *devmask, int mask)
+{
+	/* Nothing to do, since we enable all devices at startup.  */
+	return 0;
+}
+
+char *pcibios_setup(char *str)
+{
+	if (!strcmp(str, "off")) {
+		toshibaboards_pci_ops = NULL;
+		return NULL;
+	}
+	return str;
+}
+
+void pcibios_align_resource(void *data, struct resource *res, unsigned long size, unsigned long align)
+{
+#if 0
+	struct pci_dev *dev = (struct pci_dev *)data;
+#endif
+	unsigned long start = res->start;
+	/* Some PCI-IDE chips (Promise, etc.) needs
+	 * extra space for DMA (reg 4) :-<
+	 * See ide-dma.c and ide-pci.c for more details.
+	 */
+	/* always want the addresses 256 byte aligned... */
+	start = (start + 1024 - 1) & ~(1024 - 1);
+	res->start = start;
+	/* check PCI resource limit */
+	if (res->flags & IORESOURCE_IO) {
+		if (res->end > toshibaboards_pci_io_resource.end - toshibaboards_pci_io_resource.start)
+			res->end = toshibaboards_pci_io_resource.end - toshibaboards_pci_io_resource.start;
+	} else {
+		if (res->start < toshibaboards_pci_mem_resource.start)
+			res->start = toshibaboards_pci_mem_resource.start;
+		if (res->end > toshibaboards_pci_mem_resource.end)
+			res->end = toshibaboards_pci_mem_resource.end;
+	}
+}
+
+void pcibios_update_resource(struct pci_dev *dev, struct resource *root,
+			     struct resource *res, int resource)
+{
+	u32 new, check;
+	int reg;
+
+	new = res->start | (res->flags & PCI_REGION_FLAG_MASK);
+	if (new & PCI_BASE_ADDRESS_SPACE_IO) {
+		struct pci_bus *root_bus;
+		root_bus = dev->bus;
+		while (root_bus->parent)
+			root_bus = root_bus->parent;
+		/* convert to PCI I/O space address */
+		new -= root_bus->resource[0]->start;
+	}
+	if (resource < 6) {
+		reg = PCI_BASE_ADDRESS_0 + 4*resource;
+	} else if (resource == PCI_ROM_RESOURCE) {
+		res->flags |= PCI_ROM_ADDRESS_ENABLE;
+		new |= PCI_ROM_ADDRESS_ENABLE;
+		reg = dev->rom_base_reg;
+	} else {
+		/* Somebody might have asked allocation of a non-standard resource */
+		return;
+	}
+	
+	pci_write_config_dword(dev, reg, new);
+	pci_read_config_dword(dev, reg, &check);
+	if ((new ^ check) & ((new & PCI_BASE_ADDRESS_SPACE_IO) ? PCI_BASE_ADDRESS_IO_MASK : PCI_BASE_ADDRESS_MEM_MASK)) {
+		printk(KERN_ERR "PCI: Error while updating region "
+		       "%s/%d (%08x != %08x)\n", dev->slot_name, resource,
+		       new, check);
+	}
+}
+#endif
+
+void __init pcibios_update_irq(struct pci_dev *dev, int irq)
+{
+	u8 line;
+	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
+	pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &line);
+	printk(KERN_DEBUG "PCI: %02x:%02x IRQ %02x\n",
+	       dev->bus->number, dev->devfn, line);
+}
+
+void __init pcibios_fixup_pbus_ranges(struct pci_bus *bus,
+				      struct pbus_set_ranges_data *ranges)
+{
+	ranges->io_start -= bus->resource[0]->start;
+	ranges->io_end -= bus->resource[0]->start;
+	ranges->mem_start -= bus->resource[1]->start;
+	ranges->mem_end -= bus->resource[1]->start;
+}
+
+unsigned __init int pcibios_assign_all_busses(void)
+{
+	return 1;
+}
+
+static void __init quirk_slc90e66_bridge(struct pci_dev *dev)
+{
+	int irq;	/* PCI/ISA Bridge interrupt */
+	unsigned char dat;
+	u32 ddat;
+	extern void toshibaboards_fdc37m81x_init(unsigned long port_base);
+
+	printk(KERN_INFO "PCI: %02x:%02x",
+	       dev->bus->number, dev->devfn);
+	/* enable Serial IRQ */
+	pci_read_config_dword(dev, 0xb0, &ddat);
+	ddat |= 0x10000;	/* SERIRQ/GP17 select */
+	pci_write_config_dword(dev, 0xb0, ddat);
+	pci_read_config_dword(dev, 0xb0, &ddat);
+	printk(" GENCFG %08x", ddat);
+	pci_read_config_byte(dev, 0x64, &dat);
+	dat |= 0xc0;	/* Serial IRQ enable (Continuous mode) */
+	pci_write_config_byte(dev, 0x64, dat);
+	pci_read_config_byte(dev, 0x64, &dat);
+	printk(" SERIRQC %02x", dat);
+	printk("\n");
+
+	irq = toshibaboards_pci_map_irq(dev, PCI_SLOT(dev->devfn), 1 /* INTA */);
+	if (!irq)
+		return;
+	toshibaboards_i8259_irq_setup(irq);
+
+	/* initialize SuperIO on PCI Backplane board */
+	toshibaboards_fdc37m81x_init(0);
+}
+
+static void __init quirk_slc90e66_ide(struct pci_dev *dev)
+{
+	unsigned char dat;
+	int regs[2] = {0x41, 0x43};
+	int i;
+
+	printk(KERN_INFO "PCI: %02x:%02x",
+	       dev->bus->number, dev->devfn);
+	/* SMSC SLC90E66 IDE uses irq 14, 15 (default) */
+	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, 14);
+	pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &dat);
+	printk(" IRQ %02x", dat);
+#if 1
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, 64);
+	pci_read_config_byte(dev, PCI_LATENCY_TIMER, &dat);
+	printk(" LATENCY %02x", dat);
+#endif
+	/* enable SMSC SLC90E66 IDE */
+	for (i = 0; i < sizeof(regs) / sizeof(regs[0]); i++) {
+		pci_read_config_byte(dev, regs[i], &dat);
+		pci_write_config_byte(dev, regs[i], dat | 0x80);
+		pci_read_config_byte(dev, regs[i], &dat);
+		printk(" IDETIM%d %02x", i, dat);
+	}
+	printk("\n");
+}
+
+#ifndef CONFIG_PCI_AUTO
+struct pci_fixup pcibios_fixups[] = {
+	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_EFAR,	PCI_DEVICE_ID_EFAR_SLC90E66_0,	quirk_slc90e66_bridge },
+	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_EFAR,	PCI_DEVICE_ID_EFAR_SLC90E66_1,	quirk_slc90e66_ide },
+	{ 0 }
+};
+#endif
+
+/* debugging... */
+void toshibaboards_dump_pci_config(void)
+{
+	struct pci_dev *dev;
+	unsigned short w;
+	int i, j;
+
+	pci_for_each_dev(dev) {
+		printk("PCICONFIG: %02x:%02x\n",
+		       dev->bus->number, dev->devfn);
+		for (i = 0; i < 0x40; i+=0x10) {
+			printk("%02x:", i);
+			for (j = 0; j < 0x10; j+=2) {
+				pci_read_config_word(dev, i + j, &w);
+				printk(" %04x", w);
+			}
+			printk("\n");
+		}
+	}
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/pmon-low.S linux-2.4.32-mct/arch/mips/mct-boards/generic/pmon-low.S
--- linux-2.4.32/arch/mips/mct-boards/generic/pmon-low.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/pmon-low.S	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,50 @@
+/*
+ *  linux/arch/mips/toshiba-boards/generic/pmon-low.S
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/addrspace.h>
+#include <asm/stackframe.h>
+#include <asm/isadep.h>
+
+	.align 5
+	NESTED(pmon_trap_low, PT_SIZE, sp)
+	.set	noat
+	.set	noreorder
+	mfc0	k0,CP0_STATUS
+	andi	k0,KU_MASK     		/* extract K/U bit */
+	xori	k0,KU_KERN
+	beqz	k0,1f
+	 nop
+	/*
+	 * Trap from user mode - invoke user exception handler
+	 * set up in pmon.c
+	 */
+	mfc0	k1,CP0_CAUSE
+	andi	k1,k1,0x7c
+	la	k0,pmon_user_exception_handler
+	addu	k0,k0,k1
+	lw	k0,0(k0)
+	nop
+	jr	k0
+	nop
+1:
+	/* jump into PMON */
+	la	k0, pmon_vector
+	lw	k0, (k0)
+	lw	k0, 48(k0)	/* 12:_exception */
+	jr	k0
+	 nop
+	.set	at
+	.set	reorder
+	END(pmon_trap_low)
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/pmon.c linux-2.4.32-mct/arch/mips/mct-boards/generic/pmon.c
--- linux-2.4.32/arch/mips/mct-boards/generic/pmon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/pmon.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,59 @@
+/*
+ *  linux/arch/mips/toshiba-boards/generic/pmon.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <asm/system.h>
+#include <asm/mipsregs.h>
+#include <asm/mct-boards/pmon.h>
+
+struct pmon_vector *pmon_vector = (struct pmon_vector *)PMON_VECTOR;
+
+void pmon_halt(void)
+{
+	if (pmon_vector && pmon_vector->exit)
+		pmon_vector->exit(0);
+	cli();
+	while (1)
+		;
+}
+
+static char ppbuf[1024];
+
+void pmon_printf(char *fmt, ...)
+{
+	va_list args;
+	if (!pmon_vector)
+		return;
+	va_start(args, fmt);
+	pmon_vector->vsprintf(ppbuf, fmt, args);
+	va_end(args);
+	pmon_vector->write(1/*STDOUT*/, ppbuf, strlen(ppbuf));
+}
+
+extern asmlinkage void pmon_trap_low(void);
+unsigned long pmon_user_exception_handler[32];
+extern unsigned long exception_handlers[32];
+void set_pmon_debug_traps(void)
+{
+	unsigned long flags;
+	int tt = 9;	/* beakpoint only */
+
+	if (!pmon_vector)
+		return;
+	save_and_cli(flags);
+	/* save original handlers (for user-mode exceptions) */
+	pmon_user_exception_handler[tt] = exception_handlers[tt];
+	set_except_vector(tt, pmon_trap_low);
+	restore_flags(flags);
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/proc.c linux-2.4.32-mct/arch/mips/mct-boards/generic/proc.c
--- linux-2.4.32/arch/mips/mct-boards/generic/proc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/proc.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,429 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/netdevice.h>
+#include <asm/uaccess.h>
+#include <asm-mips/mconfig.h>
+
+#define MODULE_VERSION "0.2"
+#define MODULE_NAME "mct"
+
+
+
+#if defined(CONFIG_MCT_SA100)
+
+#define CPU_PIODO_ADDR	0xfffef500
+#define CPU_PIODI_ADDR	0xfffef504
+#define CPU_GPIO_HBLED_BIT		0x00000100
+#define ETHER_LED		0xb4000000
+
+#elif defined(CONFIG_MCT_SA200)
+
+#include<asm/tx4925.h>
+#define CPU_PIODO_ADDR	0xff1ff500
+#define CPU_PIODI_ADDR	0xff1ff504
+#define CPU_GPIO_HBLED_BIT		0x00004000
+#define ETHER_IN_LED(i)         tx4925_pioptr->dout = (tx4925_pioptr->din & 0xf0ffffff) | (((((unsigned long) 0xff) << i) & 0x0f) << 24);
+#define ETHER_OUT_LED(i)        tx4925_pioptr->dout = (tx4925_pioptr->din & 0x0fffffff) | (((((unsigned long) 0xff) << i) & 0x0f) << 28);
+
+#endif
+
+struct switch_t {
+	char parent_name[2];
+	struct proc_dir_entry *parent,*speed, *fullduplex, *linkup;
+};
+
+static struct proc_dir_entry *mct_dir, *mct_led_dir, *mct_switch_dir, *hb_entry, *in_entry, *out_entry;
+static struct switch_t switch_dirs[4];
+
+struct hb_data_t {
+	char mode[10];
+	int v_on;
+	int v_off;
+};
+struct net_data_t {
+	char iface[10];
+	char mode;
+	int max_kbps;
+};
+struct hb_data_t hb_data;
+struct net_data_t in_data,out_data;
+
+void __init _hbled_init(void);
+static int proc_read_hb(char *page, char **start,off_t off, int count,int *eof, void *data) {
+	int len;
+	MOD_INC_USE_COUNT;
+	if (strcmp(hb_data.mode,"blink")==0) {
+		len = sprintf (page,"%s %i/%i\n",hb_data.mode,hb_data.v_on,hb_data.v_off);
+	} else {
+		len = sprintf (page,"%s\n",hb_data.mode);
+	}
+	MOD_DEC_USE_COUNT;
+	return len;
+}
+static int proc_write_hb(struct file *file,const char *buffer,unsigned long count,void *data) {
+	unsigned long len;
+	char b[64],mode[64];
+	int ontime,offtime,p;
+	MOD_INC_USE_COUNT;
+	if (count>64) len=64; else len=count;
+	copy_from_user(b,buffer,len);
+	b[count]=0;
+	p = sscanf (b,"%64s %d %d",mode,&ontime,&offtime);
+	if (p>0) strcpy(hb_data.mode,mode);
+	if (p>1) hb_data.v_on = ontime;
+	if (p>2) hb_data.v_off = offtime;
+	if (hb_data.v_on > 5000) hb_data.v_on = 5000;
+	if (hb_data.v_on < 1) hb_data.v_on = 1;
+	if (hb_data.v_off > 5000) hb_data.v_off = 5000;
+	if (hb_data.v_off < 1) hb_data.v_off = 1;
+	MOD_DEC_USE_COUNT;
+	return len;
+}
+
+static struct timer_list hbled_timer;
+static unsigned long pre_uptime,pre_idle;
+extern struct task_struct *init_tasks[NR_CPUS];
+
+static void hbled_blink(unsigned long dummy) {
+	unsigned long val,uptime,idle,u,i,next;
+	int is_on;
+	
+	val = *(volatile unsigned long *) CPU_PIODI_ADDR;
+	is_on = val & CPU_GPIO_HBLED_BIT;
+	if (strcmp("blink",hb_data.mode)==0) {
+		(*(volatile unsigned long *) CPU_PIODO_ADDR) = is_on ? (val & ~CPU_GPIO_HBLED_BIT) : (val | CPU_GPIO_HBLED_BIT);
+		next = is_on ? hb_data.v_on : hb_data.v_off;
+	} else if (strcmp("on",hb_data.mode)==0) {
+		(*(volatile unsigned long *) CPU_PIODO_ADDR) = val & ~CPU_GPIO_HBLED_BIT;
+		next = HZ / 5;
+	} else if (strcmp("off",hb_data.mode)==0) {
+		(*(volatile unsigned long *) CPU_PIODO_ADDR) = val | CPU_GPIO_HBLED_BIT;
+		next = HZ / 5;
+	} else if (strcmp("cpu",hb_data.mode)==0) {
+		(*(volatile unsigned long *) CPU_PIODO_ADDR) = is_on ? (val & ~CPU_GPIO_HBLED_BIT) : (val | CPU_GPIO_HBLED_BIT);
+		if (! is_on) {
+			next = 3;
+		} else {
+			uptime = jiffies;
+			idle = init_tasks[0]->times.tms_utime + init_tasks[0]->times.tms_stime;
+			u = uptime - pre_uptime;
+			i = idle - pre_idle;
+			if (u > 0) next = 5 + ((i * 162)) / u; else next = 167;
+			pre_uptime = uptime;
+			pre_idle = idle;
+		}
+	} else {
+		next = HZ / 5;
+	}
+	init_timer(&hbled_timer);
+	hbled_timer.function = hbled_blink;
+	hbled_timer.expires = jiffies + next;
+	add_timer(&hbled_timer);
+}
+
+void __init _hbled_init(void) {
+	init_timer(&hbled_timer);
+	hbled_timer.function = hbled_blink;
+	hbled_timer.expires = jiffies + HZ / 5;
+	add_timer(&hbled_timer);
+}
+
+
+
+static int proc_read_in(char *page, char **start,off_t off, int count,int *eof, void *data) {
+	int len;
+	MOD_INC_USE_COUNT;
+	len = sprintf (page,"%s %c %i\n",in_data.iface,in_data.mode,in_data.max_kbps);
+	MOD_DEC_USE_COUNT;
+	return len;
+}
+static int proc_write_in(struct file *file,const char *buffer,unsigned long count,void *data) {
+	unsigned long len;
+	char b[64],iface[64],mode;
+	int max_kbps,p;
+	MOD_INC_USE_COUNT;
+	if (count>64) len=64; else len = count;
+	copy_from_user(b,buffer,len);
+	b[count]=0;
+	p = sscanf (b,"%64s %1s %d",iface,&mode,&max_kbps);
+	if (p>0) strcpy(in_data.iface,iface);
+	if (p>1) in_data.mode = mode;
+	if (p>2) in_data.max_kbps = max_kbps;
+	MOD_DEC_USE_COUNT;
+	return len;
+}
+static int proc_read_out(char *page, char **start,off_t off, int count,int *eof, void *data) {
+	int len;
+	MOD_INC_USE_COUNT;
+	len = sprintf (page,"%s %c %i\n",out_data.iface,out_data.mode,out_data.max_kbps);
+	MOD_DEC_USE_COUNT;
+	return len;
+}
+static int proc_write_out(struct file *file,const char *buffer,unsigned long count,void *data) {
+	unsigned long len;
+	char b[64],iface[64],mode;
+	int max_kbps,p;
+	MOD_INC_USE_COUNT;
+	if (count>64) len=64; else len = count;
+	copy_from_user(b,buffer,len);
+	b[count]=0;
+	p = sscanf (b,"%64s %1s %d",iface,&mode,&max_kbps);
+	if (p>0) strcpy(out_data.iface,iface);
+	if (p>1) out_data.mode = mode;
+	if (p>2) out_data.max_kbps = max_kbps;
+	MOD_DEC_USE_COUNT;
+	return len;
+}
+static struct timer_list inout_timer;
+static unsigned long last_in,last_out;
+unsigned long getDevRx(char *devName) {
+	struct net_device *dev;
+	unsigned long val=0;
+	read_lock(&dev_base_lock);
+	for (dev = dev_base; dev != NULL; dev = dev->next) {
+		if (strcmp(dev->name,devName)==0) {
+			struct net_device_stats *stats = (dev->get_stats ? dev->get_stats(dev): NULL);
+			if (stats) val = stats->rx_bytes;
+		}
+	}
+	read_unlock(&dev_base_lock);
+	return val;
+}
+unsigned long getDevTx(char *devName) {
+	struct net_device *dev;
+	unsigned long val=0;
+	read_lock(&dev_base_lock);
+	for (dev = dev_base; dev != NULL; dev = dev->next) {
+		if (strcmp(dev->name,devName)==0) {
+			struct net_device_stats *stats = (dev->get_stats ? dev->get_stats(dev): NULL);
+			if (stats) val = stats->tx_bytes;
+		}
+	}
+	read_unlock(&dev_base_lock);
+	return val;
+}
+static void inout_led(unsigned long dummy) {
+	int in_led,out_led;
+	unsigned long val;
+
+	if (strcmp("off",in_data.iface)==0) {
+		in_led = 0;
+	} else 	if (strcmp("on",in_data.iface)==0) {
+		in_led = 4;
+	} else {
+		val = in_data.mode=='r' ? getDevRx(in_data.iface) : getDevTx(in_data.iface);
+		in_led = ((val-last_in)*4) / (in_data.max_kbps * 1024);
+		last_in = val;
+	}
+	if (strcmp("off",out_data.iface)==0) {
+		out_led = 0;
+	} else 	if (strcmp("on",out_data.iface)==0) {
+		out_led = 4;
+	} else {
+		val = out_data.mode=='r' ? getDevRx(out_data.iface) : getDevTx(out_data.iface);
+		out_led = ((val-last_out)*4) / (out_data.max_kbps * 1024);
+		last_out = val;
+	}
+#if defined(CONFIG_MCT_SA100)
+	*((volatile unsigned char *) ETHER_LED) = (0x0f >> out_led) | ((0xff >> in_led) & 0xf0);
+#elif defined(CONFIG_MCT_SA200)
+	ETHER_IN_LED(in_led)
+	ETHER_OUT_LED(out_led)
+#endif
+	
+	
+	init_timer(&inout_timer);
+	inout_timer.function = inout_led;
+	inout_timer.expires = jiffies + HZ/10;
+	add_timer(&inout_timer);
+}
+
+void __init inout_init(void) {
+	init_timer(&inout_timer);
+	inout_timer.function = inout_led;
+	inout_timer.expires = jiffies + HZ/10;
+	add_timer(&inout_timer);
+}
+
+extern void get_switch_status(SWITCH_STATUS *status);
+static int proc_read_speed(char *page, char **start,off_t off, int count,int *eof, void *data) {
+	int len;
+	SWITCH_STATUS status;
+	struct switch_t *switch_data = (struct switch_t *)data;
+	MOD_INC_USE_COUNT;
+	get_switch_status(&status);
+	len = sprintf (page,"%i\n",status.speed[switch_data->parent_name[0]-'0']);
+	MOD_DEC_USE_COUNT;
+	return len;
+}
+static int proc_read_fullduplex(char *page, char **start,off_t off, int count,int *eof, void *data) {
+	int len;
+	SWITCH_STATUS status;
+	struct switch_t *switch_data = (struct switch_t *)data;
+	MOD_INC_USE_COUNT;
+	get_switch_status(&status);
+	len = sprintf (page,"%i\n",status.full_duplex[switch_data->parent_name[0]-'0']);
+	MOD_DEC_USE_COUNT;
+	return len;
+}
+static int proc_read_linkup(char *page, char **start,off_t off, int count,int *eof, void *data) {
+	int len;
+	SWITCH_STATUS status;
+	struct switch_t *switch_data = (struct switch_t *)data;
+	MOD_INC_USE_COUNT;
+	get_switch_status(&status);
+	len = sprintf (page,"%i\n",status.linkup[switch_data->parent_name[0]-'0']);
+	MOD_DEC_USE_COUNT;
+	return len;
+}
+
+int __init switch_init(struct switch_t *dir_data,char *parent_name) {
+	strcpy(dir_data->parent_name,parent_name);
+	dir_data->parent = proc_mkdir(parent_name,mct_switch_dir);
+	if (dir_data->parent == NULL) {
+		return -ENOMEM;
+	}
+	dir_data->speed = create_proc_entry("speed",0444,dir_data->parent);
+	if (dir_data->speed == NULL) {
+		remove_proc_entry(parent_name,mct_switch_dir);
+		return -ENOMEM;
+	}
+	dir_data->speed->data = dir_data;
+	dir_data->speed->read_proc = proc_read_speed;
+	dir_data->speed->owner = THIS_MODULE;
+	dir_data->fullduplex = create_proc_entry("fullduplex",0444,dir_data->parent);
+	if (dir_data->fullduplex == NULL) {
+		remove_proc_entry("speed",dir_data->parent);
+		remove_proc_entry(parent_name,mct_switch_dir);
+		return -ENOMEM;
+	}
+	dir_data->fullduplex->data = dir_data;
+	dir_data->fullduplex->read_proc = proc_read_fullduplex;
+	dir_data->fullduplex->owner = THIS_MODULE;
+	dir_data->linkup = create_proc_entry("linkup",0444,dir_data->parent);
+	if (dir_data->linkup == NULL) {
+		remove_proc_entry("fullduplex",dir_data->parent);
+		remove_proc_entry("speed",dir_data->parent);
+		remove_proc_entry(parent_name,mct_switch_dir);
+		return -ENOMEM;
+	}
+	dir_data->linkup->data = dir_data;
+	dir_data->linkup->read_proc = proc_read_linkup;
+	dir_data->linkup->owner = THIS_MODULE;
+	return 0;
+}
+
+static void __exit cleanup_switch(struct switch_t *data) {
+	remove_proc_entry("linkup",data->parent);
+	remove_proc_entry("fullduplex",data->parent);
+	remove_proc_entry("speed",data->parent);
+	remove_proc_entry(data->parent_name,mct_switch_dir);
+}
+
+static int __init init_procfs_mct(void) {
+	int rv = 0;
+	int i,j;
+	char switch_name[2];
+	/* create directory */
+	mct_dir = proc_mkdir(MODULE_NAME, NULL);
+	if(mct_dir == NULL) {
+		rv = -ENOMEM;
+		goto out;
+	}
+	mct_dir->owner = THIS_MODULE;
+	/* create led directory */
+	mct_led_dir = proc_mkdir("led",mct_dir);
+	if(mct_led_dir == NULL) {
+		rv = -ENOMEM;
+		goto no_led;
+	}
+	mct_led_dir->owner = THIS_MODULE;
+	hb_entry = create_proc_entry ("hb",0644,mct_led_dir);
+	if(hb_entry == NULL) {
+		rv = -ENOMEM;
+		goto no_hb;
+	}
+	strcpy(hb_data.mode,"on");
+	hb_data.v_off = HZ /2;
+	hb_data.v_on = HZ / 2;
+	hb_entry->data = &hb_data;
+	hb_entry->read_proc = proc_read_hb;
+	hb_entry->write_proc = proc_write_hb;
+	hb_entry->owner = THIS_MODULE;
+	_hbled_init();
+	in_entry = create_proc_entry ("in",0644,mct_led_dir);
+	if(in_entry == NULL) {
+		rv = -ENOMEM;
+		goto no_in;
+	}
+	strcpy(in_data.iface,"eth0");
+	in_data.mode = 'r';
+	in_data.max_kbps = 100;
+	in_entry->data = &in_data;
+	in_entry->read_proc = proc_read_in;
+	in_entry->write_proc = proc_write_in;
+	in_entry->owner = THIS_MODULE;
+	out_entry = create_proc_entry ("out",0644,mct_led_dir);
+	if(out_entry == NULL) {
+		rv = -ENOMEM;
+		goto no_out;
+	}
+	strcpy(out_data.iface,"eth0");
+	out_data.mode = 't';
+	out_data.max_kbps = 100;
+	out_entry->data = &out_data;;
+	out_entry->read_proc = proc_read_out;
+	out_entry->write_proc = proc_write_out;
+	out_entry->owner = THIS_MODULE;
+	inout_init();
+	
+	mct_switch_dir = proc_mkdir("switch",mct_dir);
+	if (mct_switch_dir == NULL) {
+		rv = -ENOMEM;
+		goto no_switch;
+	}
+	switch_name[1]=0;
+	for (i=0;i<4;i++) {
+		switch_name[0] = '0'+i;
+		 if (switch_init(&switch_dirs[i],switch_name) != 0) goto no_switch_dir;
+	}
+	/* everything OK */
+	printk(KERN_INFO "%s %s initialised\n",MODULE_NAME, MODULE_VERSION);
+	return rv;
+no_switch_dir:
+	for (j=0;j<i;j++) cleanup_switch(&switch_dirs[j]);
+no_switch:
+	remove_proc_entry("out",mct_led_dir);
+no_out:
+	remove_proc_entry("in",mct_led_dir);
+no_in:	
+	remove_proc_entry("hb",mct_led_dir);
+no_hb:	
+	remove_proc_entry("led",mct_dir);
+no_led:
+	remove_proc_entry(MODULE_NAME, NULL);
+out:
+	return rv;
+}
+
+static void __exit cleanup_procfs_mct(void) {
+	int i;
+	for (i=0;i<4;i++) cleanup_switch(&switch_dirs[i]);
+	remove_proc_entry("switch",mct_dir);
+	remove_proc_entry("out",mct_led_dir);
+	remove_proc_entry("in",mct_led_dir);
+	remove_proc_entry("hb",mct_led_dir);
+	remove_proc_entry("led",mct_dir);
+	remove_proc_entry(MODULE_NAME, NULL);
+	printk(KERN_INFO "%s %s removed\n",MODULE_NAME, MODULE_VERSION);
+}
+
+module_init(init_procfs_mct);
+module_exit(cleanup_procfs_mct);
+
+MODULE_AUTHOR("Udo Hegel");
+MODULE_DESCRIPTION("Mct proc support");
+EXPORT_NO_SYMBOLS;
\ No newline at end of file
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/prom.c linux-2.4.32-mct/arch/mips/mct-boards/generic/prom.c
--- linux-2.4.32/arch/mips/mct-boards/generic/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/prom.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,387 @@
+/*
+ *  linux/arch/mips/toshiba-boards/generic/prom.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1999-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#ifdef CONFIG_BLK_DEV_INITRD
+#include <linux/blk.h>
+#endif
+#include <asm/system.h>
+#include <asm/mipsregs.h>
+#include <asm/io.h>
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/mct-boards/pmon.h>
+
+/* mips/kernel/setup.c use this. */
+char arcs_cmdline[CL_SIZE];
+
+extern int tsdb_prom_init(int argc, char **argv, char **envp);
+extern int jmr3927_prom_init(int argc, char **argv, char **envp);
+extern int tx4927evb_prom_init(int argc, char **argv, char **envp);
+extern int rbtx4927_prom_init(int argc, char **argv, char **envp);
+extern int rbtx4925_prom_init(int argc, char **argv, char **envp);
+
+unsigned long toshibaboards_memory_upper;
+
+#ifdef CONFIG_CPU_TX49XX
+//extern int mips_configk0; // Udo
+int mips_configk0;
+#endif
+int mips_ic_disable = 0, mips_dc_disable = 0;
+int mips_config_cwfon = 1;
+int mips_config_wbon = 1;
+
+int __init prom_init(int argc, char **argv, char **envp)
+{
+	int i;
+	int (*arch_prom_init)(int argc, char **argv, char **envp) = 0;
+	unsigned int conf;
+	char *envstr = NULL;
+
+#ifdef CONFIG_IP_PNP
+	int use_pmon_ipaddr = 0;
+#endif
+#ifdef CONFIG_BLK_DEV_INITRD
+	/* see arch/mips/kernel/setup.c */
+	unsigned long tmp;
+	unsigned long* initrd_header;
+	extern char _end;
+	tmp = (((unsigned long)&_end + PAGE_SIZE-1) & PAGE_MASK) - 8; 
+	if (tmp < (unsigned long)&_end) 
+		tmp += PAGE_SIZE;
+	initrd_header = (unsigned long *)tmp;
+	initrd_header[0] = 0;	/* default: do not use initrd_header */
+#endif
+#if defined(CONFIG_CPU_TX39XX) && defined(CONFIG_TOSHIBA_SDB)
+	if ((current_cpu_data.processor_id & 0xffff) == (PRID_IMP_TX39 | 0x0050)) {
+		/* TX39H3: support core-mode only */
+		current_cpu_data.cputype = CPU_TX39XX;
+		current_cpu_data.tlbsize = 32;
+		current_cpu_data.icache.ways = 2;
+		current_cpu_data.dcache.ways = 2;
+	}
+	if (current_cpu_data.cputype == CPU_TX3927) {
+		/* check core-mode */
+		if ((*(volatile u32 *)0xfffee004 >> 16) != 0x3927)
+			current_cpu_data.cputype = CPU_TX39XX;
+	}
+#endif /* CONFIG_CPU_TX39XX && CONFIG_TOSHIBA_SDB */
+	switch(current_cpu_data.cputype) {
+	case CPU_TX3912:
+	case CPU_TX3922:
+	case CPU_TX3927:
+	case CPU_TX39XX:
+		pmon_vector = (struct pmon_vector *)PMON_VECTOR_TX39;
+		break;
+	case CPU_R4300:
+	case CPU_TX49XX:
+		pmon_vector = (struct pmon_vector *)PMON_VECTOR_R4K;
+		break;
+	}
+	if (argc <= 0 || strncmp(argv[0], "HCP", 3) == 0)
+		pmon_vector = NULL;
+
+#if 1	/* Modified by Ethan on 04/21/2002 */
+#if defined(CONFIG_MCT_SG4100)
+	toshibaboards_memory_upper = 0x80ffff00; /* 16 MB */
+#elif !defined(CONFIG_TX49_SDRAM_64MB)
+	toshibaboards_memory_upper = 0x81ffff00; /* at least 32M (we hope) */
+#else
+	toshibaboards_memory_upper = 0x83ffff00; /* at least 64M (we hope) */
+#endif
+
+#else
+	if (pmon_vector) {
+		envstr = pmon_vector->getenv("clienttop");
+		if (envstr)
+			toshibaboards_memory_upper =
+				KSEG0ADDR(simple_strtoul(envstr, NULL, 16));
+	}
+#endif
+	/* "mem=" option can override this */
+	add_memory_region(0, PHYSADDR(toshibaboards_memory_upper), BOOT_MEM_RAM);
+
+	mips_machgroup = MACH_GROUP_MCT;
+	/* first, determine by "board=" argument */
+	envstr = NULL;
+	for (i = 1; i < argc; i++) {
+		if (strncmp(argv[i], "board=", 6) == 0)
+			envstr = argv[i] + 6;
+	}
+
+#if 0	/* Removed by Ethan on 04/21/2002 */
+	/* next, determine by "board" envvar */
+	if (!envstr && pmon_vector)
+		envstr = pmon_vector->getenv("board");
+#endif
+
+	if (!envstr)
+		envstr = "";
+	if (strcmp(envstr, "TSDB") == 0)
+		mips_machtype = MACH_TOSHIBA_SDB;
+	else if (strcmp(envstr, "JMR") == 0)
+		mips_machtype = MACH_TOSHIBA_JMR3927;
+	else if (strcmp(envstr, "TX4927EVB") == 0)
+		mips_machtype = MACH_TOSHIBA_TX4927EVB;
+	else if (strcmp(envstr, "RBTX4927") == 0)
+		mips_machtype = MACH_TOSHIBA_RBTX4927;
+	else if (strcmp(envstr, "RBTX4925") == 0)
+		mips_machtype = MACH_TOSHIBA_RBTX4925;
+	else {
+		/* determine by cputype, PRid */
+		switch (current_cpu_data.cputype) {
+		case CPU_R4300:
+			mips_machtype = MACH_TOSHIBA_SDB;
+			break;
+		case CPU_TX49XX:
+			switch (current_cpu_data.processor_id & 0xffff) {
+			case PRID_IMP_TX49 | 0x2d11: /* TX4955 */
+			case PRID_IMP_TX49 | 0x2d20: /* TX4955A */
+				mips_machtype = MACH_TOSHIBA_SDB;
+				break;
+			case PRID_IMP_TX49 | 0x2d21: /* TX4927R1 */
+			case PRID_IMP_TX49 | 0x2d22: /* TX4927R2 */
+			case PRID_IMP_TX49 | 0x2d23:
+				/* heuristic check for TX4925/TX4926... */
+				if ((*(volatile unsigned int *)0xff1fe004) >> 16 == 0x4925 ||
+				    (*(volatile unsigned int *)0xff1fe004) >> 16 == 0x4926) {
+#ifdef CONFIG_MCT_BOARDS
+					mips_machtype = MACH_MCT_SG4100;
+#else
+					mips_machtype = MACH_TOSHIBA_RBTX4925;
+#endif
+				} else {
+#ifdef CONFIG_TOSHIBA_RBTX4927
+					mips_machtype = MACH_TOSHIBA_RBTX4927;
+#else
+					mips_machtype = MACH_TOSHIBA_TX4927EVB;
+#endif
+				}
+				break;
+			}
+			break;
+		case CPU_TX3927:
+#ifdef CONFIG_MCT_SG100
+			mips_machtype = MACH_MCT_SG100;
+#elif defined(CONFIG_MCT_SG600)
+			mips_machtype = MACH_MCT_SG600;
+#elif defined(CONFIG_MCT_SA100)
+			mips_machtype = MACH_MCT_SA100;
+#endif
+			break;
+		case CPU_TX39XX:
+			mips_machtype = MACH_TOSHIBA_SDB;
+			break;
+		}
+	}
+	switch (mips_machtype) {
+#ifdef CONFIG_TOSHIBA_SDB
+	case MACH_TOSHIBA_SDB:
+		arch_prom_init = tsdb_prom_init;
+		break;
+#endif
+#ifdef CONFIG_TOSHIBA_JMR3927
+	case MACH_TOSHIBA_JMR3927:
+		arch_prom_init = jmr3927_prom_init;
+		break;
+#endif
+#ifdef CONFIG_TOSHIBA_TX4927EVB
+	case MACH_TOSHIBA_TX4927EVB:
+		arch_prom_init = tx4927evb_prom_init;
+		break;
+#endif
+#ifdef CONFIG_TOSHIBA_RBTX4927
+	case MACH_TOSHIBA_RBTX4927:
+		arch_prom_init = rbtx4927_prom_init;
+		break;
+#endif
+#ifdef CONFIG_TOSHIBA_RBTX4925
+	case MACH_TOSHIBA_RBTX4925:
+	case 0x2d22:
+	case 0x2d23:
+		arch_prom_init = rbtx4925_prom_init;
+		break;
+#endif
+#if defined(CONFIG_MCT_SG100) || defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100)
+	case MACH_MCT_SG100:
+	case MACH_MCT_SG600:
+	case MACH_MCT_SA100:
+		pmon_printf("Processor ID: %x\n", current_cpu_data.processor_id);
+		arch_prom_init = jmr3927_prom_init;
+		break;
+#endif
+#if defined(CONFIG_MCT_SG4100) || defined(CONFIG_MCT_SA200)
+	case MACH_MCT_SG4100:
+		arch_prom_init = rbtx4925_prom_init;
+		break;
+#endif
+	}
+
+	if (arch_prom_init == 0) {
+		pmon_printf("unknown arch. (PRid %x)\n", current_cpu_data.processor_id);
+		pmon_halt();
+	}
+
+	/* command from ROM Monitor */
+	arcs_cmdline[0] = '\0';
+	pmon_printf("boot:");
+	/* argv[0] = "g" (go command) */
+	for (i = 1; i < argc; i++) {
+		char *str = argv[i];
+		pmon_printf(" %s", str);
+		/* check board specific options */
+		if (arch_prom_init(-1, &str, NULL)) {
+			continue;	/* skip (do not pass to "init") */
+		}
+		if (strncmp(str, "board=", 6) == 0) {
+			continue;
+#ifdef CONFIG_CPU_TX49XX
+		} else if (strncmp(str, "configk0=", 9) == 0) {
+			mips_configk0 = str[9] - '0';
+			continue;
+#endif
+		} else if (strcmp(str, "icdisable") == 0) {
+			mips_ic_disable = 1;
+			continue;
+		} else if (strcmp(str, "dcdisable") == 0) {
+			mips_dc_disable = 1;
+			continue;
+		} else if (strcmp(str, "cwfoff") == 0) {
+			mips_config_cwfon = 0;
+			continue;
+		} else if (strcmp(str, "wboff") == 0) {
+			mips_config_wbon = 0;
+			continue;
+#ifdef CONFIG_IP_PNP
+		}else if (strncmp(str, "ip=", 3) == 0) {
+			if (strcmp(str + 3, "pmon") == 0) {
+				use_pmon_ipaddr = 1;
+				continue;
+			} else {
+				use_pmon_ipaddr = -1;
+			}
+		}
+#endif
+#ifdef CONFIG_BLK_DEV_INITRD
+		else if (strncmp(str, "initrd=", 7) == 0) {
+			/* "initrd=start,size" */
+			int ints[3];
+			get_options(str+7, ARRAY_SIZE(ints), ints);
+			if (ints[0] == 2) {
+				/* see arch/mips/kernel/setup.c */
+				initrd_header[0] = 0x494E5244;
+				initrd_header[1] = (unsigned long)ints[2];
+				memmove(&initrd_header[2], (void *)ints[1],
+					ints[2]);
+				/* now setup_arch can find initrd */
+			}
+			continue;
+		}
+#endif
+		strcat(arcs_cmdline, str);
+		if (i < argc - 1)
+			strcat(arcs_cmdline, " ");
+	}
+	pmon_printf("\n");
+
+#if 0	/* Removed by Ethan on 04/21/2002 */
+#ifdef CONFIG_IP_PNP
+	/* use PMON's ipaddr if not specified */
+#if !(defined(CONFIG_IP_PNP_BOOTP) || defined(CONFIG_IP_PNP_DHCP) || \
+	defined(CONFIG_IP_PNP_RARP))
+	if (use_pmon_ipaddr == 0) {
+		use_pmon_ipaddr = 1;
+		/* if "root=/dev/xxx" (except for /dev/nfs) is
+		   specified, "ip=" may not be needed. */
+		for (i = 1; i < argc; i++) {
+			if (strncmp(argv[i], "root=", 5) == 0 &&
+			    strcmp(argv[i]+5, "/dev/nfs") != 0) {
+				use_pmon_ipaddr = 0;
+				break;
+			}
+		}
+	}
+#endif
+	if (use_pmon_ipaddr > 0) {
+		char *ipaddr = NULL;
+		char tmpstr[128];
+		if (pmon_vector)
+			ipaddr = pmon_vector->getenv("ipaddr");
+		if (!ipaddr)
+			ipaddr = "";
+		sprintf(tmpstr, "ip=%s:::::eth0:", ipaddr);
+		if (arcs_cmdline[0])
+			strcat(arcs_cmdline, " ");
+		strcat(arcs_cmdline, tmpstr);
+	}
+#endif /* CONFIG_IP_PNP */
+#endif
+
+	/* if cache enabled, flush and disable here */
+	switch (current_cpu_data.processor_id & 0xff00) {
+	case PRID_IMP_TX39:	/* TX39 core */
+		conf = read_c0_conf();
+		if ((conf & (TX39_CONF_ICE | TX39_CONF_DCE)) != 0 &&
+		    pmon_vector) {
+			pmon_vector->flush_cache(1/*DCACHE*/);
+			pmon_vector->flush_cache(0/*ICACHE*/);
+			conf &= ~(TX39_CONF_ICE | TX39_CONF_DCE);
+			write_c0_conf(conf);
+		}
+		break;
+	case PRID_IMP_TX49:	/* TX49 core */
+		conf = read_c0_config();
+		if ((conf & (TX49_CONF_IC | TX49_CONF_DC)) != (TX49_CONF_IC | TX49_CONF_DC) &&
+		    pmon_vector) {
+			pmon_vector->flush_cache(1/*DCACHE*/);
+			pmon_vector->flush_cache(0/*ICACHE*/);
+			conf |= (TX49_CONF_IC | TX49_CONF_DC);
+			write_c0_config(conf);
+		}
+		break;
+	}
+
+	return arch_prom_init(argc, argv, envp);
+}
+
+char * __init prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
+
+const char *get_system_type(void)
+{
+	static char system[32];
+	int called = 0;
+	const char *toshiba_system_strings[] = {
+#if 1 /* does not support */
+		"Unknown", "Unknown", "Unknown",
+#else
+		"Pallas", "TopasCE", "JMR",
+#endif
+		"JMR TX3927", "SDB R4xxx", "TX4927 EVB", "RBTX4927", "RBTX4925"
+	};
+
+	if (called == 0) {
+		called = 1;
+		strcpy(system, "Toshiba ");
+		strcat(system, toshiba_system_strings[mips_machtype]);
+	}
+
+	return system;
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/rtl8305.c linux-2.4.32-mct/arch/mips/mct-boards/generic/rtl8305.c
--- linux-2.4.32/arch/mips/mct-boards/generic/rtl8305.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/rtl8305.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,175 @@
+#include <linux/config.h>
+#include <asm/delay.h>
+#include <asm/mconfig.h>
+
+#define sdelay()        udelay(2)
+#define ldelay()        udelay(200) 
+
+#if defined(CONFIG_MCT_SG100)
+
+#define SWITCH_SMI_REG	0xb4000000
+#define SWITCH_SMI_MDIO	0x01
+#define SWITCH_SMI_MDC	0x02
+
+#define SMI_CL_DL()	*(volatile unsigned char *) SWITCH_SMI_REG = 0x00
+#define SMI_CL_DH()	*(volatile unsigned char *) SWITCH_SMI_REG = SWITCH_SMI_MDIO
+#define SMI_CH_DL()	*(volatile unsigned char *) SWITCH_SMI_REG = SWITCH_SMI_MDC
+#define SMI_CH_DH()	*(volatile unsigned char *) SWITCH_SMI_REG = SWITCH_SMI_MDC | SWITCH_SMI_MDIO
+
+#define SMI_DATA()	(*(volatile unsigned char *) SWITCH_SMI_REG) & SWITCH_SMI_MDIO
+
+#elif defined(CONFIG_MCT_SA100)
+#include <asm/tx3927.h>
+
+#define CPU_GPIO_SCK_BIT	0x00002000
+#define CPU_GPIO_SDA_BIT	0x00001000
+
+#define SMI_CL_DL()	tx3927_pioptr->dout = tx3927_pioptr->din & ~(CPU_GPIO_SCK_BIT|CPU_GPIO_SDA_BIT)
+#define SMI_CL_DH()	tx3927_pioptr->dout = (tx3927_pioptr->din & ~(CPU_GPIO_SCK_BIT)) | CPU_GPIO_SDA_BIT
+#define SMI_CH_DL()	tx3927_pioptr->dout = (tx3927_pioptr->din & ~(CPU_GPIO_SDA_BIT)) | CPU_GPIO_SCK_BIT
+#define SMI_CH_DH()	tx3927_pioptr->dout = tx3927_pioptr->din | (CPU_GPIO_SCK_BIT|CPU_GPIO_SDA_BIT)
+
+#define SMI_DATA()	tx3927_pioptr->din & CPU_GPIO_SDA_BIT
+
+#elif defined(CONFIG_MCT_SG4100) || defined(CONFIG_MCT_SA200)
+#include <asm/tx4925.h>
+
+#define CPU_GPIO_SCK_BIT	0x00001000
+#define CPU_GPIO_SDA_BIT	0x00002000
+
+#define SMI_CL_DL()	tx4925_pioptr->dout = tx4925_pioptr->din & ~(CPU_GPIO_SCK_BIT|CPU_GPIO_SDA_BIT)
+#define SMI_CL_DH()	tx4925_pioptr->dout = (tx4925_pioptr->din & ~(CPU_GPIO_SCK_BIT)) | CPU_GPIO_SDA_BIT
+#define SMI_CH_DL()	tx4925_pioptr->dout = (tx4925_pioptr->din & ~(CPU_GPIO_SDA_BIT)) | CPU_GPIO_SCK_BIT
+#define SMI_CH_DH()	tx4925_pioptr->dout = tx4925_pioptr->din | (CPU_GPIO_SCK_BIT|CPU_GPIO_SDA_BIT)
+
+#define SMI_DATA()	tx4925_pioptr->din & CPU_GPIO_SDA_BIT
+
+#endif
+
+//#define SMI_ADDR(phy, reg)	((phy<<5) | reg)
+
+static void send_smi(unsigned int val, int count)
+{
+	int		i;
+	unsigned int	mask;
+
+	mask = 0x80000000;
+	for (i = 0; i < count; i++, mask>>=1) {
+		if ( val & mask ) {
+			sdelay();
+			//outb(SMI_MDIO, CPLD_SMI_REG);
+			SMI_CL_DH();
+			sdelay();
+			//outb(SMI_MDC|SMI_MDIO, CPLD_SMI_REG);
+			SMI_CH_DH();
+		} else {
+			sdelay();
+			//outb(0x00, CPLD_SMI_REG);
+			SMI_CL_DL();
+			sdelay();
+			//outb(SMI_MDC, CPLD_SMI_REG);
+			SMI_CH_DL();
+		}
+	}
+}
+
+static unsigned short smi_read_data(void)
+{
+	unsigned short val;
+	int		i, signal;
+
+	val = 0;
+	for (i = 0; i < 16; i++) {
+		sdelay();
+		//outb(SMI_MDIO, CPLD_SMI_REG);
+		SMI_CL_DH();
+		sdelay();
+		//outb(SMI_MDC|SMI_MDIO, CPLD_SMI_REG);
+		SMI_CH_DH();
+		sdelay();
+		//signal = inb(CPLD_SMI_REG) & SMI_MDIO;
+		signal = SMI_DATA();
+		if ( signal ) {
+			val = (val << 1) | 0x01;
+		} else {
+			val <<= 1;
+		}
+	}
+
+	return val;
+}
+
+static void smi_write_data(unsigned short val)
+{
+	int	i;
+	unsigned short mask;
+
+	for (i = 0, mask=0x8000; i < 16; i++, mask>>=1) {
+		if ( val & mask ) {
+			//outb(SMI_MDIO, CPLD_SMI_REG);
+			SMI_CL_DH();
+			sdelay();
+			//outb(SMI_MDC|SMI_MDIO, CPLD_SMI_REG);
+			SMI_CH_DH();
+			sdelay();
+		} else {
+			//outb(SMI_MDIO, CPLD_SMI_REG);
+			SMI_CL_DH();
+			sdelay();
+			//outb(SMI_MDC, CPLD_SMI_REG);
+			SMI_CH_DL();
+			sdelay();
+		}
+	}
+}
+
+static unsigned short smi_read(unsigned int addr)
+{
+	unsigned short	val;
+
+	/* send preamble sequence */
+	send_smi(0xffffffff, 32);
+	send_smi(0x60000000, 4);	/* Start bit and OP code for read operation */
+	send_smi(addr<<22, 10);
+	send_smi(0xc0000000, 1);	/* Turn around cycle */
+	val = smi_read_data();
+
+	/* place both MDC and MDIO signal in high impedance state */
+	sdelay();
+	//outb(SMI_MDC|SMI_MDIO, CPLD_SMI_REG);
+	SMI_CH_DH();
+
+	return val;
+}
+
+static void smi_write(unsigned int addr, unsigned short val)
+{
+	/* send preamble sequence */
+	send_smi(0xffffffff, 32);
+	send_smi(0x50000000, 4);	/* Start bit and OP code for write operation */
+	send_smi(addr<<22, 10);
+	send_smi(0x80000000, 2);	/* Turn around cycle */
+	smi_write_data(val);
+
+	sdelay();
+	//outb(SMI_MDC|SMI_MDIO, CPLD_SMI_REG);
+	SMI_CH_DH();
+}
+
+void get_switch_status(SWITCH_STATUS *status)
+{
+	unsigned short	phy;
+	unsigned short	phy_ctrl, phy_status;
+
+	for (phy = 0; phy < 4; phy++) {
+        	phy_ctrl = smi_read((phy << 5) | 0x00);
+		status->speed[phy] = (phy_ctrl & 0x2000) ? 100 : 10;
+		status->full_duplex[phy] = (phy_ctrl & 0x0100) ? 1 : 0;
+	}
+
+	for (phy = 0; phy < 4; phy++) {
+        	phy_status = smi_read((phy << 5) | 0x01);
+		status->linkup[phy] = (phy_status & 0x0004) ? 1 : 0;
+	}
+}
+
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/setup.c linux-2.4.32-mct/arch/mips/mct-boards/generic/setup.c
--- linux-2.4.32/arch/mips/mct-boards/generic/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/setup.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,613 @@
+/*
+ * linux/arch/mips/toshiba-boards/generic/setup.c
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ *
+ * Setup pointers to hardware-dependent routines.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+
+#include <linux/config.h>
+#include <linux/console.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/fdc37m81x.h>
+#include <asm/mct-boards/pmon.h>
+#include <asm/mct-boards/jmi39io2.h>
+#ifdef CONFIG_BLK_DEV_IDE
+#include <asm/mct-boards/pci.h>
+#endif
+#ifdef CONFIG_BLK_DEV_IDEPCI
+#include <linux/hdreg.h>
+#include <asm/ptrace.h>
+#include <linux/ide.h>
+extern struct ide_ops std_ide_ops;
+#endif
+#if 0 /* ANDI */
+#ifdef CONFIG_PC_KEYB
+#include <asm/keyboard.h>
+extern struct kbd_ops no_kbd_ops;
+extern struct kbd_ops std_kbd_ops;
+#endif
+#endif
+
+extern int mips_configk0;
+extern int mips_ic_disable, mips_dc_disable;
+extern int mips_config_cwfon;
+extern int mips_config_wbon;
+
+static void __init toshibaboards_cache_setup(void)
+{
+	unsigned int conf;
+
+	/* enable cache here */
+	switch (current_cpu_data.processor_id & 0xff00) {
+	case PRID_IMP_TX39:	/* TX39 core */
+		conf = read_c0_conf();
+		conf &= ~(TX39_CONF_ICE | TX39_CONF_DCE | TX39_CONF_WBON | TX39_CONF_CWFON);
+		conf |= mips_ic_disable ? 0 : TX39_CONF_ICE;
+		conf |= mips_dc_disable ? 0 : TX39_CONF_DCE;
+		conf |= mips_config_wbon ? TX39_CONF_WBON : 0;
+		conf |= mips_config_cwfon ? TX39_CONF_CWFON : 0;
+		write_c0_conf(conf);
+		write_c0_cache(0);
+		break;
+	case PRID_IMP_TX49:	/* TX49 core */
+		conf = read_c0_config();
+		conf &= ~(TX49_CONF_IC | TX49_CONF_DC | TX49_CONF_CWFON);
+		conf |= mips_ic_disable ? TX49_CONF_IC : 0;
+		conf |= mips_dc_disable ? TX49_CONF_DC : 0;
+		/* only TX49/H2(and upper) have CWFON bit */
+		if ((current_cpu_data.processor_id & 0x00ff) != 0x11) /* TX4955 (TX49/H) */
+			conf |= (mips_config_cwfon && !mips_dc_disable) ? TX49_CONF_CWFON : 0;
+		write_c0_config(conf);
+		break;
+	}
+}
+
+static void __init toshibaboards_cache_report(void)
+{
+	unsigned int conf;
+
+	switch (current_cpu_data.processor_id & 0xff00) {
+	case PRID_IMP_TX39:	/* TX39 core */
+		conf = read_c0_conf();
+		if (!(conf & TX39_CONF_ICE))
+			printk("TX39XX I-Cache disabled.\n");
+		if (!(conf & TX39_CONF_DCE))
+			printk("TX39XX D-Cache disabled.\n");
+		else if (!(conf & TX39_CONF_WBON))
+			printk("TX39XX D-Cache WriteThrough.\n");
+		else if (!(conf & TX39_CONF_CWFON))
+			printk("TX39XX D-Cache WriteBack.\n");
+		else
+			printk("TX39XX D-Cache WriteBack (CWF) .\n");
+		break;
+	case PRID_IMP_TX49:	/* TX49 core */
+		conf = read_c0_config();
+		if (conf & TX49_CONF_IC)
+			printk("TX49XX I-Cache disabled.\n");
+		if (conf & TX49_CONF_DC)
+			printk("TX49XX D-Cache disabled.\n");
+		break;
+	}
+
+	switch(current_cpu_data.cputype) {
+	case CPU_R4300:
+	case CPU_TX49XX:
+		/* r4k generic */
+		conf = read_c0_config();
+		switch (conf & CONF_CM_CMASK) {
+		case CONF_CM_CACHABLE_NO_WA:
+			printk("KSEG0 writethru(no-WA).\n");
+			break;
+		case CONF_CM_CACHABLE_WA:
+			printk("KSEG0 writethru(WA).\n");
+			break;
+		case CONF_CM_UNCACHED:
+			printk("KSEG0 uncached.\n");
+			break;
+		case CONF_CM_CACHABLE_NONCOHERENT:
+			if (current_cpu_data.cputype == CPU_TX49XX &&
+			    (conf & TX49_CONF_CWFON))
+				printk("TX49XX D-Cache WriteBack (CWF).\n");
+			break;
+		}
+		break;
+	}
+}
+
+static int panic_event(struct notifier_block *this, unsigned long event,
+                      void *ptr)
+{
+	extern void breakpoint(void);
+	extern int panic_timeout;
+	/* called when panic happens. enter to monitor. */
+#ifdef CONFIG_REMOTE_DEBUG
+	breakpoint();
+#endif
+	if (!panic_timeout)
+		pmon_halt();
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block panic_block = {
+	panic_event,
+	NULL,
+	0
+};
+
+int __init toshibaboards_probe_ieee1394_board(unsigned long base)
+{
+	volatile unsigned long *pr3;
+	unsigned long pr3_ver;
+	int found = 0;
+
+	/* check JMY-IEEE1394IF board */
+	pr3 = (volatile unsigned long *)base;
+	pr3_ver = pr3[0];
+	pr3[0] = 0xffffffff;
+	if ((pr3[0] & 0xff00ff00) == 0) { /* PR3_VERSION */
+		unsigned long tmp = pr3[0x50>>2];
+		pr3[0x50>>2] = 0xffff0000; /* PR3_ADDR: initial value */
+		if (pr3[0x50>>2] == 0xffff0000) {
+			pr3[0x50>>2] = 0x0000ffff; /* PR3_ADDR: reverse */
+			if (pr3[0x50>>2] == 0x0000ffff)
+				found = 1;
+		}
+		pr3[0x50>>2] = tmp;
+	} else {
+		pr3[0] = pr3_ver;
+	}
+	if (found)
+		printk(KERN_DEBUG "IEEE1394 Link Board found.\n");
+	else
+		printk(KERN_DEBUG "IEEE1394 Link Board not found.\n");
+	return found ? 0 : -ENODEV;
+}
+
+unsigned long jmi39io2_iob_base;
+int jmi39io2_isac_irq_base;
+extern int early_i82365_setup(u_long iobase, u_long membase, u_int irqmask, int levelirq);
+void __init jmi39io2_init(unsigned long base, int isac_irq)
+{
+	jmi39io2_iob_base = base;
+	jmi39io2_isac_irq_base = isac_irq;
+	if (!base)
+		return;
+	printk("TJSYS JMI-TX39IO2 (at %08lx) --- ISAC(Rev %d) DIPSW:%01x\n",
+	       jmi39io2_iob_base,
+	       jmi39io2_isac_reg_in(JMI39IO2_ISAC_REV_ADDR(base)) & JMI39IO2_REV_MASK,
+	       jmi39io2_io_dipsw(base));
+	jmi39io2_io_led_set(base, 0);
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_I82365)
+	/* IRQ3, IRQ5 are used for PC Card Controller */
+	early_i82365_setup(JMI39IO2_ISAIO_BASE(base) - mips_io_port_base,
+			   PHYSADDR(JMI39IO2_ISAMEM_BASE(base)),
+			   (1 << 3) | (1 << 5), 1 /* level */);
+#endif
+}
+
+/* Initialize SuperIO on PCI Backplane board */
+void __init toshibaboards_fdc37m81x_init(unsigned long port_base)
+{
+	unsigned long port = port_base + 0x3f0;
+
+	outb(FDC37M81x_CONFIG_ENTER, port + FDC37M81x_CONFIG_INDEX);
+	if (fdc37m81x_readb(port, FDC37M81x_DID) != 0x4d)
+		return;
+
+	/* Init Serial port1 */
+	fdc37m81x_writeb(port, FDC37M81x_DNUM, FDC37M81x_SERIAL1);
+	fdc37m81x_writeb(port, FDC37M81x_ACTIVE, 0x01);
+	fdc37m81x_writeb(port, FDC37M81x_BASEADDR0, 0x03);
+	fdc37m81x_writeb(port, FDC37M81x_BASEADDR1, 0xf8);
+
+	/* Init Serial port2 */
+	fdc37m81x_writeb(port, FDC37M81x_DNUM, FDC37M81x_SERIAL2);
+	fdc37m81x_writeb(port, FDC37M81x_ACTIVE, 0x01);
+	fdc37m81x_writeb(port, FDC37M81x_BASEADDR0, 0x02);
+	fdc37m81x_writeb(port, FDC37M81x_BASEADDR1, 0xf8);
+
+	/* Init Keyboard */
+	fdc37m81x_writeb(port, FDC37M81x_DNUM, FDC37M81x_KBD);
+	fdc37m81x_writeb(port, FDC37M81x_ACTIVE, 0x01);
+	fdc37m81x_writeb(port, FDC37M81x_INT, 1);
+	fdc37m81x_writeb(port, FDC37M81x_INT2, 12);
+
+	outb(FDC37M81x_CONFIG_EXIT, port + FDC37M81x_CONFIG_INDEX);
+
+#if 0 /* ANDI */
+#ifdef CONFIG_PC_KEYB
+	/* do not override any onboard keyboard controller */
+	if (kbd_ops == &no_kbd_ops)
+		kbd_ops = &std_kbd_ops;
+#endif
+#endif
+}
+
+#ifdef CONFIG_HAVE_BOARD_IO_FUNCS
+#ifdef __LITTLE_ENDIAN
+/* for Little Endian, we can use standard IO macros. */
+#warning using CONFIG_HAVE_BOARD_IO_FUNCS in LittleEndian
+#endif
+/* default IO functions for BigEndian. */
+/*
+ * We do byte-swap by software for PCI region in big endian because
+ * TX4927/TX3927 PCIC does not have "smart" swap feature :-<
+ */
+/* Board specific setup routine can override those functions. */
+#define IS_SWAPPED_PORT(port) \
+	(toshibaboards_pci_io_resource.start <= (port) && \
+	 (port) <= toshibaboards_pci_io_resource.end)
+#define __inb(port) (*(volatile u8 *)(mips_io_port_base + (port)))
+#define __inw(port) (*(volatile u16 *)(mips_io_port_base + (port)))
+#define __inl(port) (*(volatile u32 *)(mips_io_port_base + (port)))
+#define __outb(val,port)						\
+do {									\
+	*(volatile u8 *)(mips_io_port_base + (port)) = (val);		\
+} while(0)
+
+#define __outw(val,port)						\
+do {									\
+	*(volatile u16 *)(mips_io_port_base + (port)) = (val);		\
+} while(0)
+
+#define __outl(val,port)						\
+do {									\
+	*(volatile u32 *)(mips_io_port_base + (port)) = (val);		\
+} while(0)
+static inline void __outsb(unsigned long port, const void *addr, unsigned int count)
+{
+	while (count--) {
+		__outb(*(u8 *)addr, port);
+		addr++;
+	}
+}
+static inline void __insb(unsigned long port, void *addr, unsigned int count)
+{
+	while (count--) {
+		*(u8 *)addr = __inb(port);
+		addr++;
+	}
+}
+static inline void __outsw(unsigned long port, const void *addr, unsigned int count)
+{
+	while (count--) {
+		__outw(*(u16 *)addr, port);
+		addr += 2;
+	}
+}
+static inline void __insw(unsigned long port, void *addr, unsigned int count)
+{
+	while (count--) {
+		*(u16 *)addr = __inw(port);
+		addr += 2;
+	}
+}
+static inline void __outsl(unsigned long port, const void *addr, unsigned int count)
+{
+	while (count--) {
+		__outl(*(u32 *)addr, port);
+		addr += 4;
+	}
+}
+static inline void __insl(unsigned long port, void *addr, unsigned int count)
+{
+	while (count--) {
+		*(u32 *)addr = __inl(port);
+		addr += 4;
+	}
+}
+static inline void insw_swap(unsigned long port, void *addr, unsigned int count)
+{
+	unsigned short *ptr = (unsigned short *)addr;
+	while (count--) {
+		*ptr++ = le16_to_cpu(__inw(port));
+	}
+}
+static inline void insl_swap(unsigned long port, void *addr, unsigned int count)
+{
+	unsigned int *ptr = (unsigned int *)addr;
+	while (count--) {
+		*ptr++ = le32_to_cpu(__inl(port));
+	}
+}
+static inline void outsw_swap(unsigned long port, const void *addr, unsigned int count)
+{
+	unsigned short *ptr = (unsigned short *)addr;
+	while (count--) {
+		__outw(cpu_to_le16(*ptr), port);
+		ptr++;
+	}
+}
+static inline void outsl_swap(unsigned long port, const void *addr, unsigned int count)
+{
+	unsigned int *ptr = (unsigned int *)addr;
+	while (count--) {
+		__outl(cpu_to_le32(*ptr), port);
+		ptr++;
+	}
+}
+static void tx_writeb(unsigned char b, volatile unsigned char *addr) {
+	*addr = b;
+}
+static void tx_writew(unsigned short b, volatile unsigned short *addr) {
+	*addr = cpu_to_le16(b);
+}
+static void tx_writel(unsigned int b, volatile unsigned int *addr) {
+	*addr = cpu_to_le32(b);
+}
+static unsigned char tx_readb(volatile unsigned char *addr) {
+	return *addr;
+}
+static unsigned short tx_readw(volatile unsigned short *addr) {
+	return le16_to_cpu(*addr);
+}
+static unsigned int tx_readl(volatile unsigned int *addr) {
+	return le32_to_cpu(*addr);
+}
+static void tx_outb(unsigned int value, unsigned long port) {
+	__outb(value, port);
+}
+static void tx_outw(unsigned int value, unsigned long port) {
+	if (IS_SWAPPED_PORT(port))
+		__outw(cpu_to_le16(value), port);
+	else
+		__outw(value, port);
+}
+static void tx_outl(unsigned int value, unsigned long port) {
+	if (IS_SWAPPED_PORT(port))
+		__outl(cpu_to_le32(value), port);
+	else
+		__outw(value, port);
+}
+static unsigned char tx_inb(unsigned long port) {
+	return __inb(port);
+}
+static unsigned short tx_inw(unsigned long port) {
+	if (IS_SWAPPED_PORT(port))
+		return le16_to_cpu(__inw(port));
+	return __inw(port);
+}
+static unsigned int tx_inl(unsigned long port) {
+	if (IS_SWAPPED_PORT(port))
+		return le32_to_cpu(__inl(port));
+	return __inl(port);
+}
+static void tx_outsb(unsigned long port, const void *addr, unsigned int count) {
+	__outsb(port, addr, count);
+}
+static void tx_outsw(unsigned long port, const void *addr, unsigned int count) {
+	if (IS_SWAPPED_PORT(port)) {
+		outsw_swap(port, addr, count);
+	} else {
+		__outsw(port, addr, count);
+	}
+}
+static void tx_outsl(unsigned long port, const void *addr, unsigned int count) {
+	if (IS_SWAPPED_PORT(port)) {
+		outsl_swap(port, addr, count);
+	} else {
+		__outsl(port, addr, count);
+	}
+}
+static void tx_insb(unsigned long port, void *addr, unsigned int count) {
+	__insb(port, addr, count);
+}
+static void tx_insw(unsigned long port, void *addr, unsigned int count) {
+	if (IS_SWAPPED_PORT(port)) {
+		insw_swap(port, addr, count);
+	} else {
+		__insw(port, addr, count);
+	}
+}
+static void tx_insl(unsigned long port, void *addr, unsigned int count) {
+	if (IS_SWAPPED_PORT(port)) {
+		insl_swap(port, addr, count);
+	} else {
+		__insl(port, addr, count);
+	}
+}
+static void tx_memset_io(volatile void *addr, int c, int len) {
+	volatile unsigned char *ptr = (volatile unsigned char *)addr;
+	while (len--)
+		*ptr++ = c;
+}
+static void tx_memcpy_fromio(void *to, volatile void *from, int len) {
+	volatile unsigned char *fromptr = (volatile unsigned char *)from;
+	volatile unsigned char *toptr = (volatile unsigned char *)to;
+	while (len--)
+		*toptr++ = *fromptr++;
+}
+static void tx_memcpy_toio(volatile void *to, const void *from, int len) {
+	volatile unsigned char *fromptr = (volatile unsigned char *)from;
+	volatile unsigned char *toptr = (volatile unsigned char *)to;
+	while (len--)
+		*toptr++ = *fromptr++;
+}
+
+struct mips_io_funcs mips_io_funcs = {
+	writeb:	tx_writeb,
+	writew:	tx_writew,
+	writel:	tx_writel,
+	readb:	tx_readb,
+	readw:	tx_readw,
+	readl:	tx_readl,
+	outb:	tx_outb,
+	outw:	tx_outw,
+	outl:	tx_outl,
+	inb:	tx_inb,
+	inw:	tx_inw,
+	inl:	tx_inl,
+	outsb:	tx_outsb,
+	outsw:	tx_outsw,
+	outsl:	tx_outsl,
+	insb:	tx_insb,
+	insw:	tx_insw,
+	insl:	tx_insl,
+	memset_io:	tx_memset_io,
+	memcpy_fromio:	tx_memcpy_fromio,
+	memcpy_toio:	tx_memcpy_toio,
+};
+EXPORT_SYMBOL(mips_io_funcs);
+#endif /* CONFIG_HAVE_BOARD_IO_FUNCS */
+
+#if defined(CONFIG_BLK_DEV_IDE) && defined(__BIG_ENDIAN)
+/* Ugly hack... */
+static void
+ideproc_noswap(ide_ide_action_t action,
+	       ide_drive_t *drive, void *buffer, unsigned int wcount)
+{
+	byte io_32bit;
+	io_32bit = drive->io_32bit;
+	switch (action) {
+	case ideproc_ide_input_data:
+	case ideproc_atapi_input_bytes:
+		if (io_32bit)
+			__insl(IDE_DATA_REG, buffer, wcount);
+		else
+			__insw(IDE_DATA_REG, buffer, wcount<<1);
+		break;
+	case ideproc_ide_output_data:
+	case ideproc_atapi_output_bytes:
+		if (io_32bit)
+			__outsl(IDE_DATA_REG, buffer, wcount);
+		else
+			__outsw(IDE_DATA_REG, buffer, wcount<<1);
+		break;
+	}
+}
+static void
+ideproc_swap(ide_ide_action_t action,
+	     ide_drive_t *drive, void *buffer, unsigned int wcount)
+{
+	byte io_32bit;
+	io_32bit = drive->io_32bit;
+	switch (action) {
+	case ideproc_ide_input_data:
+	case ideproc_atapi_input_bytes:
+		if (io_32bit)
+			insl_swap(IDE_DATA_REG, buffer, wcount);
+		else
+			insw_swap(IDE_DATA_REG, buffer, wcount<<1);
+		break;
+	case ideproc_ide_output_data:
+	case ideproc_atapi_output_bytes:
+		if (io_32bit)
+			outsl_swap(IDE_DATA_REG, buffer, wcount);
+		else
+			outsw_swap(IDE_DATA_REG, buffer, wcount<<1);
+		break;
+	}
+}
+static ide_ioreg_t (*org_ide_default_io_base)(int index);
+static ide_ioreg_t ide_initialize_hook(int index)
+{
+	ide_ioreg_t base = org_ide_default_io_base(index);
+	/* install our ideproc */
+	/* use swapped IO for JMI39IO2 IDE */
+	if(jmi39io2_iob_base &&
+	   base == JMI39IO2_IDE_ADDR(jmi39io2_iob_base) - mips_io_port_base)
+		ide_hwifs[index].ideproc = ideproc_swap;
+	else
+		ide_hwifs[index].ideproc = ideproc_noswap;
+	return base;
+}
+#endif /* CONFIG_BLK_DEV_IDE && __BIG_ENDIAN */
+
+int mips_parport_base;
+int mips_parport_irq;
+extern void wbflush_setup(void);
+extern void toshibaboards_dma_setup(void);
+extern void tsdb_setup(void);
+extern void jmr3927_setup(void);
+extern void tx4927evb_setup(void);
+extern void rbtx4927_setup(void);
+extern void rbtx4925_setup(void);
+
+void __init mctboards_setup(void)
+{
+	clear_c0_status(ST0_RE);
+
+	toshibaboards_cache_setup();
+
+	wbflush_setup();
+
+	notifier_chain_register(&panic_notifier_list, &panic_block);
+
+	toshibaboards_dma_setup();
+
+	/* setup resource limits */
+	ioport_resource.start = 0;
+	ioport_resource.end = 0xffffffff;	/* no limit */
+	iomem_resource.start = 0;
+	iomem_resource.end = 0x1fffffff;	/* 512MB */
+
+#ifdef CONFIG_VT
+	conswitchp = &dummy_con;
+#endif
+#ifdef CONFIG_BLK_DEV_IDEPCI
+	ide_ops = &std_ide_ops;
+#endif
+	switch (mips_machtype) {
+#ifdef CONFIG_TOSHIBA_SDB
+	case MACH_TOSHIBA_SDB:
+		tsdb_setup();
+		break;
+#endif
+#ifdef CONFIG_TOSHIBA_JMR3927
+	case MACH_TOSHIBA_JMR3927:
+		jmr3927_setup();
+		break;
+#endif
+#ifdef CONFIG_TOSHIBA_TX4927EVB
+	case MACH_TOSHIBA_TX4927EVB:
+		tx4927evb_setup();
+		break;
+#endif
+#ifdef CONFIG_TOSHIBA_RBTX4927
+	case MACH_TOSHIBA_RBTX4927:
+		rbtx4927_setup();
+		break;
+#endif
+#ifdef CONFIG_TOSHIBA_RBTX4925
+	case MACH_TOSHIBA_RBTX4925:
+		rbtx4925_setup();
+		break;
+#endif
+#if defined(CONFIG_MCT_SG100) || defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100)
+	case MACH_MCT_SG100:
+	case MACH_MCT_SG600:
+	case MACH_MCT_SA100:
+		sgx00_setup();
+		break;
+#endif
+#if defined(CONFIG_MCT_SG4100) || defined(CONFIG_MCT_SA200)
+	case MACH_MCT_SG4100:
+		sg4x00_setup();
+		break;
+#endif
+	default:
+		panic("Unsupported type");
+	}
+
+#if defined(CONFIG_BLK_DEV_IDE) && defined(__BIG_ENDIAN)
+	/* Ugly hack... */
+	org_ide_default_io_base = ide_ops->ide_default_io_base;
+	ide_ops->ide_default_io_base = ide_initialize_hook;
+#endif
+	toshibaboards_cache_report();
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/generic/wbflush.c linux-2.4.32-mct/arch/mips/mct-boards/generic/wbflush.c
--- linux-2.4.32/arch/mips/mct-boards/generic/wbflush.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/generic/wbflush.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,70 @@
+/*
+ * Setup the right wbflush routine for TOSHIBA TX-RISC.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ */
+
+#include <linux/init.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+
+void (*__wbflush) (void);
+
+static void wbflush_generic(void)
+{
+	*(volatile int *)KSEG1;
+}
+
+static void wbflush_tx39(void)
+{
+        /*
+         * The status of the writeback buffer is available
+         * via the Coprocessor 0 condition
+         */
+	__asm__ __volatile__(
+		".set    push\n\t"
+		".set    noreorder\n\t"
+		"1: bc0f    1b\n\t"
+		"nop\n\t"
+		".set pop"
+	);
+}
+static void wbflush_tx49(void)
+{
+	__asm__ __volatile__(
+		".set    push\n\t"
+		".set    mips2\n\t"
+		"sync\n\t"
+		".set pop"
+	);
+}
+
+
+void __init wbflush_setup(void)
+{
+	switch(current_cpu_data.cputype) {
+	case CPU_TX3912:
+	case CPU_TX3922:
+	case CPU_TX3927:
+	case CPU_TX39XX:
+		if ((current_cpu_data.processor_id & 0xffff) == (PRID_IMP_TX39 | 0x0050))
+			__wbflush = wbflush_tx49; /* TX39H3 */
+		else
+			__wbflush = wbflush_tx39;
+		break;
+	case CPU_TX49XX:
+		__wbflush = wbflush_tx49;
+		break;
+	default:
+		__wbflush = wbflush_generic;
+	}
+}
+
diff -Naru linux-2.4.32/arch/mips/mct-boards/sg4x00/Makefile linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/Makefile
--- linux-2.4.32/arch/mips/mct-boards/sg4x00/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/Makefile	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,24 @@
+#
+# Makefile for the TOSHIBA RBTX4925 board specific parts of the kernel
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (C) 2001 Toshiba Corporation
+#
+
+.S.s:
+	$(CPP) $(AFLAGS) $< -o $@
+.S.o:
+	$(CC) $(AFLAGS) -c $< -o $@
+
+all: sg4x00.o
+O_TARGET := sg4x00.o
+obj-y	 := irq.o time.o setup.o pci.o prom.o s3511a.o power.o wdtmr.o
+
+include $(TOPDIR)/Rules.make
diff -Naru linux-2.4.32/arch/mips/mct-boards/sg4x00/irq.c linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/irq.c
--- linux-2.4.32/arch/mips/mct-boards/sg4x00/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/irq.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,461 @@
+/*
+ *  linux/arch/mips/toshiba-boards/rbtx4925/irq.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+
+#include <linux/errno.h>
+#include <linux/kernel_stat.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#ifdef CONFIG_BLK_DEV_IDEPCI
+#include <linux/pci.h>
+#endif
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+
+#include <asm/ptrace.h>
+#include <asm/processor.h>
+#include <asm/mct-boards/irq.h>
+#include <asm/mct-boards/rbtx4925.h>
+#include <asm/mct-boards/jmi39io2.h>
+
+#if RBTX4925_IRQ_END > NR_IRQS
+#error RBTX4925_IRQ_END > NR_IRQS
+#endif
+
+#define RBTX4925_IRQ_ISACINT	RBTX4925_IRQ_IRC_INT(JMI39IO2_INT_ISAC)
+
+static int rbtx4925_gen_iack(void)
+{
+	/* generate ACK cycle */
+#ifdef __BIG_ENDIAN
+	return (tx4925_pcicptr->g2pintack >> 24) & 0xff;
+#else
+	return tx4925_pcicptr->g2pintack & 0xff;
+#endif
+}
+
+/*
+ * RBTX4925 IOC controller definition
+ */
+
+#define flush_wb()	\
+	__asm__ __volatile__( \
+		".set push\n\t" \
+		".set mips2\n\t" \
+		"sync\n\t" \
+		".set pop\n\t")
+
+#if 0
+static void rbtx4925_ioc_irq_enable(unsigned int irq)
+{
+	int irq_nr = irq - RBTX4925_IRQ_IOC;
+	/* 0: mask */
+	*rbtx4925_imask_ptr |= 1 << irq_nr;
+	flush_wb();
+}
+
+static void rbtx4925_ioc_irq_disable(unsigned int irq)
+{
+	int irq_nr = irq - RBTX4925_IRQ_IOC;
+	/* 0: mask */
+	*rbtx4925_imask_ptr &= ~(1 << irq_nr);
+	flush_wb();
+}
+
+static unsigned int rbtx4925_ioc_irq_startup(unsigned int irq)
+{
+	rbtx4925_ioc_irq_enable(irq);
+	return 0;
+}
+#define	rbtx4925_ioc_irq_shutdown	rbtx4925_ioc_irq_disable
+
+#define rbtx4925_ioc_irq_ack	rbtx4925_ioc_irq_disable
+static void rbtx4925_ioc_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		rbtx4925_ioc_irq_enable(irq);
+}
+
+static hw_irq_controller rbtx4925_ioc_irq_controller = {
+	typename:	"IOC",
+	startup:	rbtx4925_ioc_irq_startup,
+	shutdown:	rbtx4925_ioc_irq_shutdown,
+	enable:		rbtx4925_ioc_irq_enable,
+	disable:	rbtx4925_ioc_irq_disable,
+	ack:		rbtx4925_ioc_irq_ack,
+	end:		rbtx4925_ioc_irq_end,
+	set_affinity:	NULL,
+};
+
+static void rbtx4925_ioc2_irq_enable(unsigned int irq)
+{
+	int irq_nr = irq - RBTX4925_IRQ_IOC2;
+	/* 0: mask */
+	*rbtx4925_imask2_ptr |= 1 << irq_nr;
+	flush_wb();
+}
+
+static void rbtx4925_ioc2_irq_disable(unsigned int irq)
+{
+	int irq_nr = irq - RBTX4925_IRQ_IOC2;
+	/* 0: mask */
+	*rbtx4925_imask2_ptr &= ~(1 << irq_nr);
+	flush_wb();
+}
+
+static unsigned int rbtx4925_ioc2_irq_startup(unsigned int irq)
+{
+	rbtx4925_ioc2_irq_enable(irq);
+	return 0;
+}
+#define	rbtx4925_ioc2_irq_shutdown	rbtx4925_ioc2_irq_disable
+
+#define rbtx4925_ioc2_irq_ack	rbtx4925_ioc2_irq_disable
+static void rbtx4925_ioc2_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		rbtx4925_ioc2_irq_enable(irq);
+}
+
+static hw_irq_controller rbtx4925_ioc2_irq_controller = {
+	typename:	"IOC2",
+	startup:	rbtx4925_ioc2_irq_startup,
+	shutdown:	rbtx4925_ioc2_irq_shutdown,
+	enable:		rbtx4925_ioc2_irq_enable,
+	disable:	rbtx4925_ioc2_irq_disable,
+	ack:		rbtx4925_ioc2_irq_ack,
+	end:		rbtx4925_ioc2_irq_end,
+	set_affinity:	NULL,
+};
+
+static void rbtx4925_pcmcia_irq_enable(unsigned int irq)
+{
+	int irq_nr = irq - RBTX4925_IRQ_PCMCIA;
+	L1121_outb(L1121_inb(L1121_IER) | (1 << irq_nr), L1121_IER);
+	flush_wb();
+}
+
+static void rbtx4925_pcmcia_irq_disable(unsigned int irq)
+{
+	int irq_nr = irq - RBTX4925_IRQ_PCMCIA;
+	L1121_outb(L1121_inb(L1121_IER) & ~(1 << irq_nr), L1121_IER);
+	flush_wb();
+}
+
+static unsigned int rbtx4925_pcmcia_irq_startup(unsigned int irq)
+{
+	int irq_nr = irq - RBTX4925_IRQ_PCMCIA;
+	/* setup edge sense based on current state */
+	L1121_outb((L1121_inb(L1121_ESNR) & ~(1 << irq_nr)) |
+		   (L1121_inb(L1121_SR) & (1 << irq_nr)),
+		   L1121_ESNR);
+	rbtx4925_pcmcia_irq_enable(irq);
+	return 0;
+}
+#define	rbtx4925_pcmcia_irq_shutdown	rbtx4925_pcmcia_irq_disable
+
+static void rbtx4925_pcmcia_irq_ack(unsigned int irq)
+{
+	int irq_nr = irq - RBTX4925_IRQ_PCMCIA;
+	/* setup edge sense based on current state */
+	L1121_outb((L1121_inb(L1121_ESNR) & ~(1 << irq_nr)) |
+		   (L1121_inb(L1121_SR) & (1 << irq_nr)),
+		   L1121_ESNR);
+	/* clear edge interrupt */
+	L1121_outb(1 << irq_nr, L1121_ECLR);
+	rbtx4925_pcmcia_irq_disable(irq);
+}
+
+static void rbtx4925_pcmcia_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		rbtx4925_pcmcia_irq_enable(irq);
+}
+
+/* IOC2 of RBTX4925 has only one PCMCIA interrupt.  To distinguish CS
+   interrupt from CARD interrupt, we install the irq_controller for
+   L1121 PCMCIA controller */
+static hw_irq_controller rbtx4925_pcmcia_irq_controller = {
+	typename:	"PCMCIA",
+	startup:	rbtx4925_pcmcia_irq_startup,
+	shutdown:	rbtx4925_pcmcia_irq_shutdown,
+	enable:		rbtx4925_pcmcia_irq_enable,
+	disable:	rbtx4925_pcmcia_irq_disable,
+	ack:		rbtx4925_pcmcia_irq_ack,
+	end:		rbtx4925_pcmcia_irq_end,
+	set_affinity:	NULL,
+};
+
+/* find first bit set */
+static inline int ffs8(unsigned char x)
+{
+	int r = 1;
+
+	if (!x)
+		return 0;
+	if (!(x & 0xf)) {
+		x >>= 4;
+		r += 4;
+	}
+	if (!(x & 3)) {
+		x >>= 2;
+		r += 2;
+	}
+	if (!(x & 1)) {
+		x >>= 1;
+		r += 1;
+	}
+	return r;
+}
+
+static int rbtx4925_ioc_irqroute(void)
+{
+	unsigned char istat = *rbtx4925_imstat_ptr;
+	int irq = ffs8(istat);
+	if (irq != 0)
+		return RBTX4925_IRQ_IOC + (irq - 1);
+	/* if no IOC interrupt, check IOC2 interrupt */
+	istat = *rbtx4925_imstat2_ptr;
+	irq = ffs8(istat);
+	if (irq != 0)
+		return RBTX4925_IRQ_IOC2 + (irq - 1);
+	return -1;
+}
+#endif
+
+extern int rbtx4925_use_r4k_timer;
+static int rbtx4925_irc_irqdispatch(struct pt_regs *regs)
+{
+	int irq = 0;
+	unsigned int csr = (unsigned int)-1;
+
+#ifdef CONFIG_TX_FPU_C_BUG_WORKAROUND
+	tx_fpu_c_bug_fixup(regs);
+#endif
+	if (rbtx4925_use_r4k_timer && (regs->cp0_cause & CAUSEF_IP7)) {
+		irq = RBTX4925_IRQ_LOCAL_TIMER;
+	} else if ((regs->cp0_cause & CAUSEF_IP0)) {
+		irq = RBTX4925_IRQ_LOCAL_SOFT0;
+	} else if ((regs->cp0_cause & CAUSEF_IP1)) {
+		irq = RBTX4925_IRQ_LOCAL_SOFT1;
+	} else {
+		csr = tx4925_ircptr->csr;
+		if (csr & TX4925_IRCSR_IF)
+			return -1;
+		irq = RBTX4925_IRQ_IRC + (csr & 0x1f);
+
+#if 0
+		/* redirect IOC interrupts */
+		switch (irq) {
+		case RBTX4925_IRQ_IOCINT:
+			irq = rbtx4925_ioc_irqroute();
+#if 1	/* someone forgot flushing writebuffer...? */
+			if (irq < 0)
+				return -1;
+#endif
+			/* redirect PCMCIA interrupts */
+			if (irq == RBTX4925_IRQ_IOC_PCMCIA) {
+				irq = ffs8(L1121_inb(L1121_ISR));
+				if (irq != 0)
+					irq = RBTX4925_IRQ_PCMCIA + (irq - 1);
+				else
+					irq = -1;
+				break;
+			}
+			irq = toshibaboards_i8259_irqroute(irq);
+			break;
+		case RBTX4925_IRQ_ISACINT:
+			irq = jmi39io2_isac_irqroute();
+			break;
+		}
+		if (irq < 0)
+			return -1;
+#endif
+	}
+
+	do_IRQ(irq, regs);
+	flush_wb();
+	return 0;
+}
+
+#if 0
+static struct irqaction ioc_action = {
+	no_action, 0, 0, "cascade(IOC)", NULL, NULL,
+};
+static struct irqaction pcmcia_action = {
+	no_action, 0, 0, "cascade(PCMCIA)", NULL, NULL,
+};
+static struct irqaction isac_action = {
+	no_action, 0, 0, "cascade(JMI39IO2 ISAC)", NULL, NULL,
+};
+#endif
+static struct irqaction irc_action = {
+	no_action, 0, 0, "cascade(IRC)", NULL, NULL,
+};
+
+static void rbtx4925_pcierr_interrupt(int irq, void * dev_id, struct pt_regs * regs)
+{
+	extern void tx4925_report_pcic_status(void);
+	extern void tx4925_dump_pcic_settings(void);
+	extern void toshibaboards_dump_pci_config(void);
+	extern struct pci_ops *toshibaboards_pci_ops;
+	if (!toshibaboards_pci_ops) {
+		printk("PCI disabled. disable %s interrupt (%d)\n",
+		       irq == RBTX4925_IRQ_IRC_PCIC ? "PCIC" : "PCIERR", irq);
+		disable_irq_nosync(irq);
+		return;
+	}
+#ifdef CONFIG_BLK_DEV_IDEPCI
+	/* ignore MasterAbort for ide probing... */
+	if (irq == RBTX4925_IRQ_IRC_PCIERR &&
+	    ((tx4925_pcicptr->pcistatus >> 16) & 0xf900) == PCI_STATUS_REC_MASTER_ABORT) {
+		tx4925_pcicptr->pcistatus =
+			(tx4925_pcicptr->pcistatus & 0x0000ffff) |
+			(PCI_STATUS_REC_MASTER_ABORT << 16);
+		return;
+	}
+#endif
+	if (irq == RBTX4925_IRQ_IRC_PCIC)
+		printk("PCIC interrupt (irq 0x%x)", irq);
+	else
+		printk("PCIERR interrupt (irq 0x%x)", irq);
+	printk(" at 0x%08lx.\n", regs->cp0_epc);
+        printk("ccfg:%08lx, toea:%08lx\n",
+	       tx4925_ccfgptr->ccfg, tx4925_ccfgptr->toea);
+	tx4925_report_pcic_status();
+	show_regs(regs);
+	tx4925_dump_pcic_settings();
+	toshibaboards_dump_pci_config();
+	panic("PCI error.");
+}
+static struct irqaction pcierr_action = {
+	rbtx4925_pcierr_interrupt, SA_INTERRUPT, 0, "PCI error", NULL, NULL,
+};
+
+#if 0
+static void rbtx4925_isaerr_interrupt(int irq, void * dev_id, struct pt_regs * regs)
+{
+#if 1
+	printk("ISA error interrupt (irq 0x%x).\n", irq);
+#endif
+}
+static struct irqaction isaerr_action = {
+	rbtx4925_isaerr_interrupt, SA_INTERRUPT, 0, "ISA error", NULL, NULL,
+};
+#endif
+
+static int tx4925_print_irc_settings = 0;
+extern void rbtx4925_setup_be_board_handler(void);
+
+void __init rbtx4925_irq_setup(void)
+{
+	int i;
+
+#if 0
+	/* Now, interrupt control disabled, */
+	/* all IRC interrupts are masked, */
+	/* all IRC interrupt mode are Low Active. */
+
+	/* mask all IOC interrupts */
+	*rbtx4925_imask_ptr = 0;
+
+	/* clear SoftInt interrupts */
+	*rbtx4925_softint_ptr = 0;
+
+	/* Onboard Ether: High Active */
+	tx4925_ircptr->cr[(RBTX4925_IRQ_ETHER - RBTX4925_IRQ_IRC) / 8] |=
+		TX4925_IRCR_HIGH << (((RBTX4925_IRQ_ETHER - RBTX4925_IRQ_IRC) % 8) * 2);
+#ifdef CONFIG_JMI39IO2_NET
+	if (have_jmi39io2()) {
+		/* JMI90IO2 ETHER (NE2000 compatible 10M-Ether): High Active */
+		tx4925_ircptr->cr[TX4925_IR_INT(JMI39IO2_INT_ETHER) / 8] |=
+			TX4925_IRCR_HIGH << ((TX4925_IR_INT(JMI39IO2_INT_ETHER) % 8) * 2);
+	}
+#endif
+
+#endif
+	toshibaboards_irqdispatch = rbtx4925_irc_irqdispatch;
+
+	/* setup irq descriptors */
+	mips_cpu_irq_init(RBTX4925_IRQ_LOCAL);
+	tx4925_irq_init(RBTX4925_IRQ_IRC);
+#if 0
+	for (i = RBTX4925_IRQ_IOC; i < RBTX4925_IRQ_IOC + RBTX4925_NR_IRQ_IOC; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &rbtx4925_ioc_irq_controller;
+	}
+	for (i = RBTX4925_IRQ_IOC2; i < RBTX4925_IRQ_IOC2 + RBTX4925_NR_IRQ_IOC2; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &rbtx4925_ioc2_irq_controller;
+	}
+	for (i = RBTX4925_IRQ_PCMCIA; i < RBTX4925_IRQ_PCMCIA + RBTX4925_NR_IRQ_PCMCIA; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &rbtx4925_pcmcia_irq_controller;
+	}
+#endif
+
+	setup_irq(RBTX4925_IRQ_LOCAL_IRC, &irc_action);
+#if 0
+	if (*rbtx4925_fpga_rev_ptr != 0x1f) {
+#endif
+		/* PCI is not supported on FPGA Ver 1f */
+		setup_irq(RBTX4925_IRQ_IRC_PCIC, &pcierr_action);
+		setup_irq(RBTX4925_IRQ_IRC_PCIERR, &pcierr_action);
+#if 0
+	}
+#endif
+
+#if 0
+	if (have_jmi39io2()) {
+		/* JMI39IO2 pulls down INT0.  So we can not use IOC
+                   interrupt (including PCI interrupt). */
+		printk(KERN_INFO "IOC interrupts not available.\n");
+
+		jmi39io2_isac_irq_init();
+		setup_irq(RBTX4925_IRQ_ISACINT, &isac_action);
+		setup_irq(RBTX4925_IRQ_ISAC + JMI39IO2_ISAC_INTB_ISAER, &isaerr_action);
+	} else {
+		setup_irq(RBTX4925_IRQ_IOCINT, &ioc_action);
+		setup_irq(RBTX4925_IRQ_IOC_PCMCIA, &pcmcia_action);
+	}
+#endif
+
+	toshibaboards_gen_iack = rbtx4925_gen_iack;
+
+#if 0
+	if (tx4925_print_irc_settings) {
+		extern void tx4925_dump_irc_settings(void);
+		tx4925_dump_irc_settings();
+	}
+#endif
+
+	rbtx4925_setup_be_board_handler();
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/sg4x00/pci.c linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/pci.c
--- linux-2.4.32/arch/mips/mct-boards/sg4x00/pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/pci.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,210 @@
+/* $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ *
+ * TX4925 specific PCI support.
+ *
+ * based on arch/mips/sni/pci.c
+ * Copyright (C) 1997, 1998 Ralf Baechle
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ */
+#include <linux/config.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <asm/byteorder.h>
+#include <asm/mct-boards/rbtx4925.h>
+
+#ifdef CONFIG_PCI
+
+int rbtx4925_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+#if 0
+	int irq = pin;
+
+	/* IRQ rotation */
+	irq--;	/* 0-3 */
+	if (dev->bus->parent == NULL &&
+	    (slot == TX4925_PCIC_IDSEL_AD_TO_SLOT(23))) {
+		/* PCI CardSlot (IDSEL=A23) */
+		/* PCIA => PCIA */
+		irq = (irq + 0 + slot) % 4;
+	} else {
+		/* PCI Backplane */
+		irq = (irq + 3 + slot) % 4;
+	}
+	irq++;	/* 1-4 */
+
+	switch (irq) {
+	case 1:
+		irq = RBTX4925_IRQ_IOC_PCIA;
+		break;
+	case 2:
+		irq = RBTX4925_IRQ_IOC_PCIB;
+		break;
+	case 3:
+		irq = RBTX4925_IRQ_IOC_PCIC;
+		break;
+	case 4:
+		irq = RBTX4925_IRQ_IOC_PCID;
+		break;
+	}
+	return irq;
+#else
+	int irq = 0;
+
+	if ( dev->bus->parent == NULL ) {
+		switch ( slot ) {
+		case 12:
+			irq = 26;
+			break;
+		case 13:
+#if defined(CONFIG_4PORT_USB_SERVER)
+			irq = 28;	
+#else
+			irq = 27;
+#endif
+			break;
+		case 14:
+#if defined(CONFIG_4PORT_USB_SERVER)
+			irq = 27;
+#else
+			irq = 28;
+#endif
+			break;
+		case 15:
+			irq = 29;
+			break;
+		}
+	}
+
+	return irq;
+#endif
+}
+
+
+static int
+mkaddr(struct pci_dev *dev, int where)
+{
+	if (dev->bus->number == 0 &&
+	    dev->devfn >= PCI_DEVFN(TX4925_PCIC_MAX_DEVNU, 0))
+		return -1;
+	tx4925_pcicptr->g2pcfgadrs = ((dev->bus->number & 0xff) << 0x10) |
+				     ((dev->devfn & 0xff) << 0x08) |
+				     (where  & 0xfc);
+	/* clear M_ABORT and Disable M_ABORT Int. */
+	tx4925_pcicptr->pcistatus =
+		(tx4925_pcicptr->pcistatus & 0x0000ffff) |
+		(PCI_STATUS_REC_MASTER_ABORT << 16);
+	return 0;
+}
+
+static int
+check_abort(void)
+{
+	int code = PCIBIOS_SUCCESSFUL;
+	if (tx4925_pcicptr->pcistatus & (PCI_STATUS_REC_MASTER_ABORT << 16)) {
+		tx4925_pcicptr->pcistatus =
+			(tx4925_pcicptr->pcistatus & 0x0000ffff) |
+			(PCI_STATUS_REC_MASTER_ABORT << 16);
+		code = PCIBIOS_DEVICE_NOT_FOUND;
+	}
+	return code;
+}
+
+static inline u8 icd_readb(int offset)
+{
+	return *(volatile u8 *)((ulong)&tx4925_pcicptr->g2pcfgdata | offset);
+}
+static inline u16 icd_readw(int offset)
+{
+	return *(volatile u16 *)((ulong)&tx4925_pcicptr->g2pcfgdata | offset);
+}
+static inline u32 icd_readl(void)
+{
+	return tx4925_pcicptr->g2pcfgdata;
+}
+static inline void icd_writeb(u8 val, int offset)
+{
+	*(volatile u8 *)((ulong)&tx4925_pcicptr->g2pcfgdata | offset) = val;
+}
+static inline void icd_writew(u16 val, int offset)
+{
+	*(volatile u16 *)((ulong)&tx4925_pcicptr->g2pcfgdata | offset) = val;
+}
+static inline void icd_writel(u32 val)
+{
+	tx4925_pcicptr->g2pcfgdata = val;
+}
+
+/*
+ * We can't address 8 and 16 bit words directly.  Instead we have to
+ * read/write a 32bit word and mask/modify the data we actually want.
+ */
+static int rbtx4925_pci_read_config_byte(struct pci_dev *dev, int where,
+					  u8 *val)
+{
+	if (mkaddr(dev, where))
+		return -1;
+	*val = icd_readb(where & 3);
+	return check_abort();
+}
+
+static int rbtx4925_pci_read_config_word(struct pci_dev *dev, int where,
+					  u16 *val)
+{
+	if (mkaddr(dev, where))
+		return -1;
+	*val = le16_to_cpu(icd_readw(where & 3));
+	return check_abort();
+}
+
+static int rbtx4925_pci_read_config_dword(struct pci_dev *dev, int where,
+					   u32 *val)
+{
+	if (mkaddr(dev, where))
+		return -1;
+	*val = le32_to_cpu(icd_readl());
+	return check_abort();
+}
+
+static int rbtx4925_pci_write_config_byte(struct pci_dev *dev, int where,
+					   u8 val)
+{
+	if (mkaddr(dev, where))
+		return -1;
+	icd_writeb(val, where & 3);
+	return check_abort();
+}
+
+static int rbtx4925_pci_write_config_word(struct pci_dev *dev, int where,
+					   u16 val)
+{
+	if (mkaddr(dev, where))
+		return -1;
+	icd_writew(cpu_to_le16(val), where & 3);
+	return check_abort();
+}
+
+static int rbtx4925_pci_write_config_dword(struct pci_dev *dev, int where,
+					    u32 val)
+{
+	if (mkaddr(dev, where))
+		return -1;
+	icd_writel(cpu_to_le32(val));
+	return check_abort();
+}
+
+struct pci_ops rbtx4925_pci_ops = {
+	read_byte:      rbtx4925_pci_read_config_byte,
+	read_word:      rbtx4925_pci_read_config_word,
+	read_dword:     rbtx4925_pci_read_config_dword,
+	write_byte:     rbtx4925_pci_write_config_byte,
+	write_word:     rbtx4925_pci_write_config_word,
+	write_dword:    rbtx4925_pci_write_config_dword
+};
+
+#endif /* CONFIG_PCI */
diff -Naru linux-2.4.32/arch/mips/mct-boards/sg4x00/power.c linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/power.c
--- linux-2.4.32/arch/mips/mct-boards/sg4x00/power.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/power.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,157 @@
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/init.h>
+#include <linux/reboot.h>
+#include <asm/tx4925.h>
+#include <linux/mount.h>
+#include <asm/reboot.h>
+#include <linux/delay.h>
+
+/*static*/ DECLARE_WAIT_QUEUE_HEAD(shutdown_wq);
+int shutdown_type = LINUX_REBOOT_CMD_POWER_OFF;
+
+
+static char task_name[][16] = {
+	"smbd", "nmbd", "nfsd", "atalkd", "ftpd"
+};
+
+#define MAX_SERVICES	256
+
+typedef struct {
+	struct list_head list;
+	int	pid;
+	char	*task_name;
+} SERVICE;
+
+SERVICE service[MAX_SERVICES];
+
+static LIST_HEAD(service_list);
+#if 0 // udo
+extern struct list_head vfsmntlist;
+#endif
+extern int do_umount(struct vfsmount *mnt, int flags);
+
+static int shutdown_thread(void *dummy)
+{
+	int	i, nservices;
+	struct list_head *slist;
+	SERVICE	*pservice;
+
+	struct task_struct *p;
+        struct task_struct *tsk = current;
+	DECLARE_WAITQUEUE(wait, tsk);
+	struct list_head *pmnt;
+	struct vfsmount *vfsmnt;
+
+        tsk->session = 1;
+        tsk->pgrp = 1;
+        tsk->flags |= PF_MEMALLOC;
+        strcpy(tsk->comm, "shutdownd");
+        tsk->tty = NULL;
+        spin_lock_irq(&tsk->sigmask_lock);
+        sigfillset(&tsk->blocked);
+        recalc_sigpending(tsk);
+        spin_unlock_irq(&tsk->sigmask_lock);
+
+	add_wait_queue(&shutdown_wq, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule();
+
+	nservices = 0;
+	for (i = 0; i < sizeof(task_name) / sizeof(task_name[0]); i++) {
+		for_each_task(p) {
+			if ( nservices >= MAX_SERVICES )
+				break;
+			if ( strcmp(task_name[i], p->comm) == 0 ) {
+				list_add_tail(&service[nservices].list, &service_list);
+				service[nservices].pid = p->pid;
+				service[nservices].task_name = task_name[i];
+				nservices++;
+				printk("Sending termination signal to %s(%d)\n", p->comm, p->pid);
+				force_sig(SIGTERM, p);
+			}
+		}
+	}
+		
+        while ( 1 ) {
+		struct list_head *slist_next;
+		for (slist = service_list.next; slist != &service_list; ) {
+			pservice = (SERVICE *) list_entry(slist, SERVICE, list);
+			for_each_task(p) {
+				if ( strcmp(pservice->task_name, p->comm) == 0 && pservice->pid == p->pid )
+					break;
+			}
+
+			slist_next = slist->next;
+			if ( p == &init_task ) {
+				printk("Shutdown %s(%d)\tOK\n", pservice->task_name, pservice->pid);
+				list_del(slist);
+			}
+			slist = slist_next;
+		}
+
+		if ( list_empty(&service_list) )
+			break;
+		schedule_timeout(HZ);
+	}
+
+#if 1
+#if 0 // Udo
+	list_for_each(pmnt, &vfsmntlist) {
+		vfsmnt = list_entry(pmnt, struct vfsmount, mnt_list);	
+		//printk("devname = %s\n", vfsmnt->mnt_devname);
+		if ( strcmp("/dev/hda1", vfsmnt->mnt_devname) == 0 ) {
+			printk("trying umount /dev/hda1\n");
+			do_umount(vfsmnt, 0);
+			break;
+		}
+	}
+#endif
+#else
+	printk("Umount file system\n");
+	sys_umount("/dev/hda1", 0);
+#endif
+
+	sys_sync();
+	sys_reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, shutdown_type, NULL);
+
+        return 0;
+}
+
+static void power_interrupt(int irq, void *dev_id, struct pt_regs *pregs)
+{
+	printk("Power: power button pressed\n");
+	
+	// clear edge interrupt
+	tx4925_ircptr->scr = 0x105;
+
+	free_irq(31, NULL);
+	
+	wake_up_interruptible(&shutdown_wq);
+}
+
+static int __init power_init(void)
+{
+	int	result;
+
+	// set falling edge trigger
+	tx4925_ircptr->cr[0] = (tx4925_ircptr->cr[0] & 0xffff3fff) | 0x00008000;
+	kernel_thread(shutdown_thread, NULL, CLONE_FS|CLONE_FILES|CLONE_SIGHAND);
+
+	result = request_irq(31, power_interrupt, SA_INTERRUPT, "power", NULL);
+	if ( result ) {
+		printk("Power: fail to request power interrupt.\n");
+		return result;
+	}
+
+	printk("Power: function of power button was initialised\n");
+
+	return 0;
+}
+#if !defined(CONFIG_4PORT_USB_SERVER)
+__initcall(power_init);
+#endif
+
diff -Naru linux-2.4.32/arch/mips/mct-boards/sg4x00/prom.c linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/prom.c
--- linux-2.4.32/arch/mips/mct-boards/sg4x00/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/prom.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,37 @@
+/*
+ *  linux/arch/mips/toshiba-boards/rbtx4925/prom.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <asm/toshiba-boards/pmon.h>
+#include <asm/toshiba-boards/rbtx4925.h>
+
+extern int rbtx4925_ccfg_toeon;
+extern int rbtx4925_pcic_trdyto;
+
+int __init rbtx4925_prom_init(int argc, char **argv, char **envp)
+{
+	if (argc == -1) {
+		if (strcmp(*argv, "toeoff") == 0)
+			rbtx4925_ccfg_toeon = 0;
+		else if (strncmp(*argv, "trdyto=", 7) == 0) {
+			rbtx4925_pcic_trdyto =
+				simple_strtoul(*argv + 7, NULL, 0);
+		} else
+			return 0;
+		return 1;
+	}
+
+	return 0;
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/sg4x00/s3511a.c linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/s3511a.c
--- linux-2.4.32/arch/mips/mct-boards/sg4x00/s3511a.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/s3511a.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,324 @@
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/rtc.h>		// for struct rtc_time
+#include <asm/io.h>
+#include <asm/delay.h>
+#include <asm/time.h>		// for rtc_set_time/rtc_get_time
+#include <asm/mct-boards/rbtx4925.h>
+
+//#define DEBUG_S3511A
+
+struct timer_list s3511a_timer;
+
+#if defined(CONFIG_MCT_SA200)
+
+#define CPU_GPIO_RTC_CS_BIT     0x00200000
+#define CPU_GPIO_RTC_SDA_BIT    0x00400000
+#define CPU_GPIO_RTC_SCK_BIT    0x00800000
+
+#define RTC_INACTIVE()	tx4925_pioptr->dout = (tx4925_pioptr->din & ~(CPU_GPIO_RTC_CS_BIT)) | CPU_GPIO_RTC_SCK_BIT | CPU_GPIO_RTC_SDA_BIT
+#define RTC_CL_DL()	tx4925_pioptr->dout = (tx4925_pioptr->din & ~(CPU_GPIO_RTC_SCK_BIT|CPU_GPIO_RTC_SDA_BIT)) | CPU_GPIO_RTC_CS_BIT
+#define RTC_CL_DH()	tx4925_pioptr->dout = (tx4925_pioptr->din & ~(CPU_GPIO_RTC_SCK_BIT)) | CPU_GPIO_RTC_SDA_BIT | CPU_GPIO_RTC_CS_BIT
+#define RTC_CH_DL()	tx4925_pioptr->dout = (tx4925_pioptr->din & ~(CPU_GPIO_RTC_SDA_BIT)) | CPU_GPIO_RTC_SCK_BIT | CPU_GPIO_RTC_CS_BIT
+#define RTC_CH_DH()	tx4925_pioptr->dout = tx4925_pioptr->din | (CPU_GPIO_RTC_SCK_BIT|CPU_GPIO_RTC_SDA_BIT|CPU_GPIO_RTC_CS_BIT)
+#define RTC_DATA()	tx4925_pioptr->din & CPU_GPIO_RTC_SDA_BIT
+#endif
+
+#define S3511A_CMD_READ			0x01
+#define S3511A_CMD_WRITE		0x00
+
+#define S3511A_CMD_RESET		0x60
+#define S3511A_CMD_STATUS		0x62
+#define S3511A_CMD_REAL_TIME_DATA1	0x64
+#define S3511A_CMD_REAL_TIME_DATA2	0x66
+#define S3511A_CMD_FREQ			0x68
+
+#define S3511A_STATUS_POWER		0x80
+#define S3511A_STATUS_24EXPR		0x40
+#define S3511A_STATUS_INTAE		0x20
+#define S3511A_STATUS_INTME		0x08
+#define S3511A_STATUS_INTFE		0x02
+
+#ifndef BCD_TO_BIN
+#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)
+#endif
+
+#ifndef BIN_TO_BCD
+#define BIN_TO_BCD(val) ((val)=(((val)/10)<<4) + (val)%10)
+#endif
+
+#define s3511a_delay()		udelay(2)	// clock pulse width at least 1us
+#define s3511a_short_delay()	udelay(1)	// setup/hold time at least 0.2us
+
+void s3511a_access_prolog(void)
+{
+	//*(volatile unsigned char*) S3511A_ADDR = S3511A_SCK | S3511A_SIO;
+	RTC_INACTIVE();
+	s3511a_short_delay();	// setup time before CS rising
+	//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK | S3511A_SIO;	
+	RTC_CH_DH();
+	s3511a_short_delay();	// hold time after CS rising
+}
+
+void s3511a_access_epilog(void)
+{
+	//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK | S3511A_SIO;
+	RTC_CH_DH();
+	s3511a_short_delay();	// setup time before CS falling
+	//*(volatile unsigned char*) S3511A_ADDR = S3511A_SCK | S3511A_SIO;
+	RTC_INACTIVE();
+	s3511a_short_delay();	// hold time after CS falling
+}
+
+unsigned char s3511a_read_byte(void)
+{
+	int	i;
+	unsigned char	val;
+
+	val = 0;
+	for (i = 0; i < 8; i++)
+	{
+		s3511a_delay();
+		//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SIO;
+		RTC_CL_DH();
+		s3511a_delay();
+		//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK | S3511A_SIO;
+		RTC_CH_DH();
+		s3511a_delay();
+		//regval = *(volatile unsigned char*) S3511A_ADDR;
+
+		// Any read/write operation performed by the real-time data
+		// access command sends or receives the data from LSB.
+		if ( RTC_DATA() )
+			val |= (1 << i);
+	}
+
+	return val;
+}
+
+void s3511a_write_byte(unsigned char data)
+{
+	unsigned char	mask;
+
+	for (mask = 0x01; mask != 0; mask <<= 1)
+	{
+		if ( mask & data )
+		{
+			s3511a_delay();
+			//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SIO;
+			RTC_CL_DH();
+			s3511a_delay();
+			//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK | S3511A_SIO;
+			RTC_CH_DH();
+		}
+		else
+		{
+			s3511a_delay();
+			//*(volatile unsigned char *) S3511A_ADDR = S3511A_CS;
+			RTC_CL_DL();
+			s3511a_delay();
+			//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK;
+			RTC_CH_DL();
+		}
+	}
+}
+
+// command should be sent from MSB to LSB.
+void s3511a_write_command(unsigned char cmd)
+{
+	unsigned char	mask;
+
+	for (mask = 0x80; mask != 0; mask >>= 1)
+	{
+		if ( mask & cmd )
+		{
+			s3511a_delay();
+			//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SIO;
+			RTC_CL_DH();
+			s3511a_delay();
+			//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK | S3511A_SIO;
+			RTC_CH_DH();
+		}
+		else
+		{
+			s3511a_delay();
+			//*(volatile unsigned char *) S3511A_ADDR = S3511A_CS;
+			RTC_CL_DL();
+			s3511a_delay();
+			//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK;
+			RTC_CH_DL();
+		}
+	}
+}
+
+unsigned long s3511a_get_time(void)
+{
+	int	i;
+	unsigned char	val, rtctime[7];
+	unsigned char	year, month, mday, hour, minute, second;
+
+	s3511a_access_prolog();
+	s3511a_write_command(S3511A_CMD_REAL_TIME_DATA1 | S3511A_CMD_READ);
+	for (i = 0; i < 7; i++)
+	{
+		val = s3511a_read_byte();
+		rtctime[i] = val;
+	}
+	s3511a_access_epilog();
+
+	// clear AM/PM bit
+	rtctime[4] &= 0x7f;
+	
+	year = BCD_TO_BIN(rtctime[0]);
+	month = BCD_TO_BIN(rtctime[1]);
+	mday = BCD_TO_BIN(rtctime[2]);
+	hour = BCD_TO_BIN(rtctime[4]);
+	minute = BCD_TO_BIN(rtctime[5]);
+	second = BCD_TO_BIN(rtctime[6]);
+
+//#ifdef DEBUG_S3511A
+#if 1
+	printk("\nS3511A: %02x %02x %02x %02x %02x %02x %02x\n",
+		rtctime[0], rtctime[1], rtctime[2],
+		rtctime[3], rtctime[4], rtctime[5], rtctime[6]);
+#endif
+
+	return mktime(year+2000, month, mday, hour, minute, second);
+}
+
+int s3511a_set_time(unsigned long time)
+{
+	int		year;
+	unsigned char	month, mday, wday, hour, minute, second;
+	struct rtc_time tm;
+
+	to_tm(time, &tm);
+
+	year = tm.tm_year % 100;
+	month = tm.tm_mon + 1;
+	mday = tm.tm_mday;
+	wday = tm.tm_wday;
+	hour = tm.tm_hour;
+	minute = tm.tm_min;
+	second = tm.tm_sec;
+
+#ifdef DEBUG_S3511A
+	printk("S3511A SET: %02d/%02d/%02d %02d:%02d:%02d\n", year, month, mday, hour, minute, second);
+#endif
+
+	BIN_TO_BCD(year);
+	BIN_TO_BCD(month);
+	BIN_TO_BCD(mday);
+	BIN_TO_BCD(wday);
+	BIN_TO_BCD(hour);
+	BIN_TO_BCD(minute);
+	BIN_TO_BCD(second);
+
+	s3511a_access_prolog();
+	s3511a_write_command(S3511A_CMD_REAL_TIME_DATA1 | S3511A_CMD_WRITE);
+
+	s3511a_write_byte(year);
+	s3511a_write_byte(month);
+	s3511a_write_byte(mday);
+	s3511a_write_byte(wday);
+	s3511a_write_byte(hour);
+	s3511a_write_byte(minute);
+	s3511a_write_byte(second);
+
+	s3511a_access_epilog();
+
+	return 0;
+}
+
+void s3511a_reset(void)
+{
+	s3511a_access_prolog();
+	s3511a_write_command(S3511A_CMD_RESET | S3511A_CMD_WRITE);
+	s3511a_access_epilog();
+}
+
+unsigned char s3511a_get_status(void)
+{
+	unsigned char	val;
+
+	s3511a_access_prolog();
+	s3511a_write_command(S3511A_CMD_STATUS | S3511A_CMD_READ);
+	val = s3511a_read_byte();
+	s3511a_access_epilog();
+	return val;
+}
+
+void s3511a_set_status(unsigned char status)
+{
+	s3511a_access_prolog();
+	s3511a_write_command(S3511A_CMD_STATUS | S3511A_CMD_WRITE);
+	s3511a_write_byte(status);
+	s3511a_access_prolog();
+}
+
+void s3511a_set_frequency(unsigned short freq)
+{
+	s3511a_access_prolog();
+	s3511a_write_command(S3511A_CMD_FREQ | S3511A_CMD_WRITE);
+	s3511a_write_byte((unsigned char) (freq & 0xff));
+	s3511a_write_byte((unsigned char) ((freq >> 8) & 0xff));
+	s3511a_access_epilog();
+}
+
+#include <linux/time.h>
+#include <asm/time.h>
+extern rwlock_t xtime_lock;
+void s3511a_callback(unsigned long dummy)
+{
+	unsigned char status;
+        status = s3511a_get_status();
+	if(status & S3511A_STATUS_POWER ) {
+		init_timer(&s3511a_timer);
+		s3511a_timer.function = s3511a_callback;
+		s3511a_timer.expires = jiffies + HZ;
+		add_timer(&s3511a_timer);
+	}
+	else {
+		write_lock_irq (&xtime_lock);
+		time_adjust = 0;                        /* stop active adjtime() */
+	        time_status |= STA_UNSYNC;
+		time_maxerror = NTP_PHASE_LIMIT;
+	        time_esterror = NTP_PHASE_LIMIT;	
+				
+		xtime.tv_sec = rtc_get_time();
+		xtime.tv_usec = 0;
+		write_unlock_irq (&xtime_lock);
+	}
+}
+			
+void __init s3511a_init(void)
+{
+	unsigned char status;
+	unsigned long count=0;
+
+	status = s3511a_get_status();
+#ifdef DEBUG_S3511A
+	printk("S3511A: status = %02x\n", status);
+#endif
+	if ( status & S3511A_STATUS_POWER )
+	{
+		s3511a_reset();
+	}
+
+	// Make the INT# signal output using selected frequency.
+	// INTFE = 1
+	s3511a_set_frequency(0x0010);	// 2kHz
+	s3511a_set_status(S3511A_STATUS_24EXPR | S3511A_STATUS_INTFE);
+
+	rtc_set_time = s3511a_set_time;
+	rtc_get_time = s3511a_get_time;
+#if 1 
+	init_timer(&s3511a_timer);
+	s3511a_timer.function = s3511a_callback;
+	s3511a_timer.expires = jiffies + HZ;
+	add_timer(&s3511a_timer);
+#endif 
+}
+
diff -Naru linux-2.4.32/arch/mips/mct-boards/sg4x00/setup.c linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/setup.c
--- linux-2.4.32/arch/mips/mct-boards/sg4x00/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/setup.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,721 @@
+/*
+ * linux/arch/mips/toshiba-boards/rbtx4925/setup.c
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ *
+ * Setup pointers to hardware-dependent routines.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ */
+
+
+#include <linux/config.h>
+#include <linux/hdreg.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/kdev_t.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <asm/system.h>
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mct-boards/pmon.h>
+#include <asm/mct-boards/pci.h>
+#include <asm/mct-boards/rbtx4925.h>
+#include <asm/mct-boards/jmi39io2.h>
+#include <asm/mc146818rtc.h>	/* bad name... */
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/pci.h>
+#include <asm/time.h>
+#include <asm/mipsregs.h>
+#include <asm/ptrace.h>
+#include <asm/keyboard.h>
+#include <asm/wbflush.h>
+#include <linux/ide.h>
+#if defined(CONFIG_SERIAL_TXX927)
+#include <asm/serial_txx927.h>
+#endif
+
+
+/*static*/ int rbtx4925_ccfg_toeon = 1;
+/*static*/ int rbtx4925_pcic_trdyto = 0;	/* default: disabled */
+
+extern struct pci_ops rbtx4925_pci_ops;
+extern int rbtx4925_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin);
+extern void rbtx4925_irq_setup(void) __init;
+extern void rbtx4925_time_init(void) __init;
+extern void rbtx4925_timer_setup(struct irqaction *irq) __init;
+
+#ifdef CONFIG_REMOTE_DEBUG
+extern int __init early_serial_txx927_kgdb_setup(int line, unsigned long base, int irq, int baud_base);
+extern void breakpoint(void);
+#define TOMON(s) printk(s); breakpoint(); pmon_halt()
+#else
+#define TOMON(s) pmon_printf(s); pmon_halt()
+#endif
+//extern void wait_for_keypress(void);
+
+static void rbtx4925_machine_restart(char *command)
+{
+	unsigned long addr = 0xbfc00000;
+
+	cli();
+
+	__asm__ __volatile__(
+		"j %0\n"
+		:
+		: "r" (addr)
+		);
+}
+
+#if defined(CONFIG_MCT_SA200)
+static void sa200_machine_halt(void)
+{
+        tx4925_pioptr->dout = 0xffffffff;
+}
+#endif
+
+static void rbtx4925_machine_halt(void)
+{
+	cli();
+	printk("Press any key to reboot.\n");
+//	wait_for_keypress();
+	*rbtx4925_softresetlock_ptr = 1;
+	*rbtx4925_softreset_ptr = 1;
+	wbflush(); 
+	while(1);
+}
+
+static void rbtx4925_machine_power_off(void)
+{
+	cli();
+	printk("Press any key to reboot.\n");
+//	wait_for_keypress();
+	*rbtx4925_softresetlock_ptr = 1;
+	*rbtx4925_softreset_ptr = 1;
+	wbflush(); 
+	while(1);
+}
+
+//extern void (*ibe_board_handler)(struct pt_regs *regs); Udo
+//extern void (*dbe_board_handler)(struct pt_regs *regs); Udo
+extern int (*board_be_handler)(struct pt_regs *regs, int is_fixup);
+
+static void rbtx4925_be_board_handler(struct pt_regs *regs, int fixup /* Udo */)
+{
+	extern void tx4925_report_pcic_status(void);
+	printk("%cBE exception at 0x%08lx\n",
+	       (regs->cp0_cause & (1<<2)) ? 'D' : 'I', regs->cp0_epc);
+	printk("ccfg:%08lx, toea:%08lx\n",
+	       tx4925_ccfgptr->ccfg, tx4925_ccfgptr->toea);
+	tx4925_report_pcic_status();
+	show_regs(regs);
+	TOMON("BusError!\n");
+	while(1);
+}
+void __init rbtx4925_setup_be_board_handler(void)
+{
+//	ibe_board_handler = rbtx4925_be_board_handler; Udo
+//	dbe_board_handler = rbtx4925_be_board_handler; Udo
+	board_be_handler = rbtx4925_be_board_handler;
+}
+
+static int rbtx4925_cpu_clock;
+
+unsigned long rbtx4925_ce_base[8];
+static unsigned long rbtx4925_ce_size[8];
+
+static unsigned long __init
+rbtx4925_find_free_region(int n,
+			  unsigned long *bases,
+			  unsigned long *sizes,
+			  unsigned long begin,
+			  unsigned long end,
+			  unsigned long *size)
+{
+	unsigned long base;
+	unsigned long sz = *size;
+	int i;
+
+	for (; sz; sz /= 2) {
+		for (base = begin / sz * sz; base < end; base += sz) {
+			for (i = 0; i < n; i++) {
+				if (sizes[i] &&
+				    base <= bases[i] + (sizes[i] - 1) &&
+				    base + (sz - 1) >= bases[i])
+					break;
+			}
+			if (i == n) {
+				*size = sz;
+				return base;
+			}
+		}
+	}
+	return 0;
+}
+
+#ifdef CONFIG_PCI
+/* setup rbtx4925_pci_{mem,io}_{base,size} */
+static unsigned long rbtx4925_pci_mem_base;
+static unsigned long rbtx4925_pci_mem_size = 0x08000000; /* MAX 128M */
+static unsigned long rbtx4925_pci_io_base;
+static unsigned long rbtx4925_pci_io_size = 0x01000000;	/* MAX 16M */
+
+static void __init rbtx4925_setup_pci_regions(void)
+{
+	unsigned long base[4+8+1];
+	unsigned long size[4+8+1];
+	unsigned long mbegin, mend;
+	int i;
+
+	if (rbtx4925_pci_mem_base || rbtx4925_pci_io_base)
+		return;	/* done */
+
+	for (i = 0; i < sizeof(base) / sizeof(base[0]); i++)
+		base[i] = size[i] = 0;
+	for (i = 0; i < 4; i++) {
+		if (!(tx4925_sdramcptr->cr[i] & 0x00000200))
+			continue;	/* disabled */
+		base[i] = tx4925_sdramcptr->cr[i] & 0xffe00000;
+		size[i] = ((tx4925_sdramcptr->cr[i] >> 10) + 1) << 21;
+	}
+	for (i = 0; i < 8; i++) {
+		if (!(tx4925_ebuscptr->ch[i].cr & 0x8))
+			continue;	/* disabled */
+		base[i+4] = rbtx4925_ce_base[i];
+		size[i+4] = rbtx4925_ce_size[i];
+	}
+	mbegin = base[0] + size[0];	/* end of SDRAM ch 0 */
+	mend = base[4];	/* begin of CE0 */
+
+	rbtx4925_pci_mem_base =
+		rbtx4925_find_free_region(sizeof(base) / sizeof(base[0]),
+					  base, size, mbegin, mend,
+					  &rbtx4925_pci_mem_size);
+	base[4+8] = rbtx4925_pci_mem_base;
+	size[4+8] = rbtx4925_pci_mem_size;
+
+	rbtx4925_pci_io_base =
+		rbtx4925_find_free_region(sizeof(base) / sizeof(base[0]),
+					  base, size, mbegin, mend,
+					  &rbtx4925_pci_io_size);
+}
+
+static void __init rbtx4925_pci_setup(void)
+{
+	unsigned long sdram_size;
+
+	/* SDRAMC are configured by PROM */
+	sdram_size = 1;
+	while (sdram_size + KSEG0 < toshibaboards_memory_upper)
+		sdram_size <<= 1;
+
+	printk("TX4925 PCIC -- DID:%04x VID:%04x RID:%02x Arbiter:%s\n",
+	       (unsigned short)(tx4925_pcicptr->pciid >> 16),
+	       (unsigned short)(tx4925_pcicptr->pciid & 0xffff),
+	       (unsigned short)(tx4925_pcicptr->pciccrev & 0xff),
+	       (tx4925_ccfgptr->ccfg & TX4925_CCFG_PCIARB) ? "External" : "Internal");
+
+	/* GB->PCI mappings */
+	tx4925_pcicptr->g2pcfg = 0 /* | TX4925_PCIC_G2PCFG_IRBER */;
+#ifdef __BIG_ENDIAN
+	tx4925_pcicptr->g2pcfg |=
+		TX4925_PCIC_G2PCFG_BSWAPM0 |
+		TX4925_PCIC_G2PCFG_BSWAPM1 |
+		TX4925_PCIC_G2PCFG_BSWAPM2 |
+		TX4925_PCIC_G2PCFG_BSWAPIO |
+		TX4925_PCIC_G2PCFG_BSWAPI;
+#endif
+	tx4925_pcicptr->g2piomask = rbtx4925_pci_io_size - 1;
+	tx4925_pcicptr->g2piogbase = rbtx4925_pci_io_base;
+	tx4925_pcicptr->g2piopbase = 0;
+	tx4925_pcicptr->g2pmmask[0] = rbtx4925_pci_mem_size - 1;
+	tx4925_pcicptr->g2pm0gbase = rbtx4925_pci_mem_base;
+	tx4925_pcicptr->g2pm0pbase = rbtx4925_pci_mem_base;
+	tx4925_pcicptr->g2pmmask[1] = 0;
+	tx4925_pcicptr->g2pm1gbase = 0;
+	tx4925_pcicptr->g2pm1pbase = 0;
+	tx4925_pcicptr->g2pmmask[2] = 0;
+	tx4925_pcicptr->g2pm2gbase = 0;
+	tx4925_pcicptr->g2pm2pbase = 0;
+	/* PCI->GB mappings (I/O disable) */
+	tx4925_pcicptr->p2gioctr = 0;
+	/* PCI->GB mappings (MEM) */
+	tx4925_pcicptr->p2gm0plbase = 0;
+	tx4925_pcicptr->p2gm0gbase = 0;
+	tx4925_pcicptr->p2gm0ctr =
+		((sdram_size - 1) & TX4925_PCIC_P2GMnCTR_AM) |
+		TX4925_PCIC_P2GMnCTR_TPRBL_8DW |
+		TX4925_PCIC_P2GMnCTR_TMCE |
+		TX4925_PCIC_P2GMnCTR_PE |
+#ifdef __BIG_ENDIAN
+		TX4925_PCIC_P2GMnCTR_BSWAP |
+#endif
+		TX4925_PCIC_P2GMnCTR_EN;
+	tx4925_pcicptr->p2gm1ctr = 0;
+	tx4925_pcicptr->p2gm2ctr = 0;
+
+	/* Enable Initiator Memory Space */
+	if (rbtx4925_pci_mem_base)
+		tx4925_pcicptr->g2pcfg |= TX4925_PCIC_G2PCFG_G2PM0EN;
+	if (rbtx4925_pci_io_base)
+		tx4925_pcicptr->g2pcfg |= TX4925_PCIC_G2PCFG_G2PIOEN;
+	/* Enable Target access */
+	tx4925_pcicptr->pciccfg &= TX4925_PCIC_PCICCFG_GBWC_MASK;
+	tx4925_pcicptr->pciccfg |=
+		TX4925_PCIC_PCICCFG_TCAR;
+
+	/* Do not use MEMMUL, MEMINF: YMFPCI card causes M_ABORT. */
+	tx4925_pcicptr->pcicfg1 = 0;
+
+	if (rbtx4925_pcic_trdyto >= 0) {
+		tx4925_pcicptr->g2ptocnt &= ~0xff;
+		tx4925_pcicptr->g2ptocnt |= (rbtx4925_pcic_trdyto & 0xff);
+		printk(KERN_DEBUG "TX4925 PCIC -- TRDYTO:%02lx\n",
+		       tx4925_pcicptr->g2ptocnt & 0xff);
+	}
+
+	/* Clear All Local Bus Status */
+	tx4925_pcicptr->pcicstatus = TX4925_PCIC_PCICSTATUS_ALL;
+	/* Enable All Local Bus Interrupts */
+	tx4925_pcicptr->pcicmask = TX4925_PCIC_PCICSTATUS_ALL;
+	/* Clear All Initiator Status */
+	tx4925_pcicptr->g2pstatus = TX4925_PCIC_G2PSTATUS_ALL;
+	/* Enable All Initiator Interrupts */
+	tx4925_pcicptr->g2pmask = TX4925_PCIC_G2PSTATUS_ALL;
+#if 1
+	/* PCI configuration access, IO port probing cause MDFE. ignore it. */
+	tx4925_pcicptr->g2pmask &= ~TX4925_PCIC_G2PSTATUS_MDFE;
+#endif
+	/* Clear All PCI Status Error */
+	tx4925_pcicptr->pcistatus =
+		(tx4925_pcicptr->pcistatus & 0x0000ffff) |
+		(TX4925_PCIC_PCISTATUS_ALL << 16);
+	/* Enable All PCI Status Error Interrupts */
+	tx4925_pcicptr->pcimask = TX4925_PCIC_PCISTATUS_ALL;
+
+	/* PCIC Int => IRC IRQ16 */
+	tx4925_pcicptr->pcicfg2 =
+		(tx4925_pcicptr->pcicfg2 & 0xffffff00) |
+		TX4925_IR_PCIC;
+
+	if (tx4925_ccfgptr->ccfg & TX4925_CCFG_PCIARB) {
+		/* XXX */
+	} else {
+		/* Reset Bus Arbiter */
+		tx4925_pcicptr->pbacfg = TX4925_PCIC_PBACFG_RPBA;
+		/*
+		 * swap reqBP and reqXP (raise priority of PCI-ISA bridge).
+		 * SLC90E66(PCI-ISA bridge) are connected to REQ2 on
+		 * PCI Backplane board.
+		 */
+		tx4925_pcicptr->pbareqport = 0x72543610;
+		tx4925_pcicptr->pbabm = 0;
+		/* Use Fixed ParkMaster (required by PCI-ISA bridge) */
+		tx4925_pcicptr->pbacfg = TX4925_PCIC_PBACFG_FIXPA;
+		/* Enable Bus Arbiter */
+		tx4925_pcicptr->pbacfg |= TX4925_PCIC_PBACFG_PBAEN;
+	}
+
+	tx4925_pcicptr->pcistatus = PCI_COMMAND_MASTER |
+		PCI_COMMAND_MEMORY |
+		PCI_COMMAND_PARITY | PCI_COMMAND_SERR;
+}
+#endif /* CONFIG_PCI */
+
+#if 0
+/* use CE5,6,7 for PCMCIA (ATTR,MEM:64MB, IO:1MB) */
+static void __init rbtx4925_pcmcia_setup(void)
+{
+	unsigned long sp = (tx4925_ccfgptr->ccfg >> 6) & 3; /* SYSSP */
+	unsigned long pcm[] = { 3 /*ATTR*/, 1 /*MEM*/, 2 /*IO*/ };
+	unsigned long pcm_ce[] = { 7, 6, 5 };
+	unsigned long pcm_size[] = { 0x4000000, 0x4000000, 0x100000 };
+	/* use high memory address for ATTR, MEM */
+	unsigned long pcm_begin[] = { 0xf0000000, 0xf0000000, 0x10000000 };
+	unsigned long pcm_end[] = { 0xff000000, 0xff000000, 0x1c000000 };
+	int i;
+
+	for (i = 0; i < sizeof(pcm) / sizeof(pcm[0]); i++) {
+		if (rbtx4925_ce_base[pcm_ce[i]])
+			return;
+	}
+	for (i = 0; i < sizeof(pcm) / sizeof(pcm[0]); i++) {
+		/* find free regions */
+		unsigned long ce_base, ce_size;
+		ce_size = pcm_size[i];
+		ce_base = rbtx4925_find_free_region(8,
+						    rbtx4925_ce_base,
+						    rbtx4925_ce_size,
+						    pcm_begin[i], pcm_end[i],
+						    &ce_size);
+		if (ce_base && ce_size == pcm_size[i]) {
+			int cs = 0;
+			while ((0x100000 << cs) < ce_size)
+				cs++;
+			tx4925_ebuscptr->ch[pcm_ce[i]].bar = ce_base;
+				/* 16bit width, SYSCLK speed */
+				/* FIXME: tune PWT,WT,SHWT */
+			tx4925_ebuscptr->ch[pcm_ce[i]].cr =
+				0x0063f04f |
+				(pcm[i] << 24) | (cs << 8) | (sp << 4);
+			rbtx4925_ce_base[pcm_ce[i]] = ce_base;
+			rbtx4925_ce_size[pcm_ce[i]] = ce_size;
+		}
+	}
+}
+#endif
+
+static void __init tx4925_setup(void)
+{
+	int i;
+
+	/* SDRAMC,EBUSC are configured by PROM */
+	for (i = 0; i < 8; i++) {
+		if (!(tx4925_ebuscptr->ch[i].cr & 0x8))
+			continue;	/* disabled */
+		rbtx4925_ce_base[i] = tx4925_ebuscptr->ch[i].bar;
+		rbtx4925_ce_size[i] = 0x00100000 << ((tx4925_ebuscptr->ch[i].cr >> 8) & 0xf);
+	}
+
+#if 0
+	/* use CE5,6,7 for PCMCIA (ATTR,MEM:64MB, IO:1MB) */
+	if (!(tx4925_ccfgptr->ccfg & TX4925_CCFG_PCTRCE) &&
+	    (tx4925_ccfgptr->pcfg & TX4925_PCFG_SELCARD(0))) {
+		rbtx4925_pcmcia_setup();
+	}
+#endif
+
+	rbtx4925_cpu_clock = RBTX4925_MASTER_CLOCK * 4 * 5 / 2;
+	switch (tx4925_ccfgptr->ccfg & TX4925_CCFG_RF_MASK) {
+	case TX4925_CCFG_RF_DIV2:	rbtx4925_cpu_clock /= 2; break;
+	case TX4925_CCFG_RF_DIV4:	rbtx4925_cpu_clock /= 4; break;
+	case TX4925_CCFG_RF_DIV8:	rbtx4925_cpu_clock /= 8; break;
+	}
+
+	/* CCFG */
+	/* enable Timeout BusError */
+	if (rbtx4925_ccfg_toeon)
+		tx4925_ccfgptr->ccfg |= TX4925_CCFG_TOE;
+
+	/* clear BusErrorOnWrite flag */
+	tx4925_ccfgptr->ccfg &= ~TX4925_CCFG_BEOW;
+
+	/* DMA selection */
+	tx4925_ccfgptr->drqctr = 0;
+
+	printk("TX4925 -- %dMHz(M%dMHz) REVID:%08lx CCFG:%08lx PCFG:%08lx\n",
+	       rbtx4925_cpu_clock / 1000000, RBTX4925_MASTER_CLOCK / 1000000,
+	       tx4925_ccfgptr->revid,
+	       tx4925_ccfgptr->ccfg, tx4925_ccfgptr->pcfg);
+
+	printk("TX4925 SDRAMC --");
+	for (i = 0; i < 4; i++) {
+		if (!(tx4925_sdramcptr->cr[i] & 0x00000200))
+			continue;	/* disabled */
+		printk(" CR%d:%08lx", i, tx4925_sdramcptr->cr[i]);
+	}
+	printk(" TR:%08lx\n", tx4925_sdramcptr->tr);
+
+	/* IRC */
+	/* disable interrupt control */
+	tx4925_ircptr->cer = 0;
+	/* mask all IRC interrupts */
+	tx4925_ircptr->imr = 0;
+	for (i = 0; i < TX4925_NUM_IR / 4; i++) {
+		tx4925_ircptr->ilr[i] = 0;
+	}
+	/* setup IRC interrupt mode (Low Active) */
+	for (i = 0; i < TX4925_NUM_IR / 16; i++) {
+		tx4925_ircptr->cr[i] = 0;
+	}
+
+	/* TMR */
+	/* disable all timers */
+	for (i = 0; i < TX4925_NR_TMR; i++) {
+		tx4925_tmrptr(i)->tcr = TXx927_TMTCR_CRE;
+		tx4925_tmrptr(i)->tisr = 0;
+		tx4925_tmrptr(i)->cpra = 0xffffffff;
+		tx4925_tmrptr(i)->itmr = 0;
+		tx4925_tmrptr(i)->ccdr = 0;
+		tx4925_tmrptr(i)->pgmr = 0;
+	}
+
+	/* DMA */
+	tx4925_dmaptr->mcr = 0;
+	for (i = 0; i < sizeof(tx4925_dmaptr->ch) / sizeof(tx4925_dmaptr->ch[0]); i++) {
+		/* reset channel */
+		tx4925_dmaptr->ch[i].ccr = TX4925_DMA_CCR_CHRST;
+#ifdef __BIG_ENDIAN
+		tx4925_dmaptr->ch[i].ccr = 0;
+#else
+		tx4925_dmaptr->ch[i].ccr = TX4925_DMA_CCR_LE;
+#endif
+	}
+	/* enable DMA */
+	tx4925_dmaptr->mcr = TX4925_DMA_MCR_MSTEN;
+
+	/* PCIC */
+#ifdef CONFIG_PCI
+	rbtx4925_setup_pci_regions();
+
+#if 0
+	if (*rbtx4925_fpga_rev_ptr == 0x1f) {
+		/* PCI is not supported on FPGA Ver 1f */
+		/* Reset PCIC */
+		tx4925_ccfgptr->clkctr &= ~TX4925_CLKCTR_PCIRSTI;
+	} else {
+		/* Reset PCI Bus */
+		*rbtx4925_pcireset_ptr = 1;
+		/* Reset PCIC */
+		tx4925_ccfgptr->clkctr &= ~TX4925_CLKCTR_PCIRSTI;
+		udelay(10000);
+		/* clear PCIC reset */
+		tx4925_ccfgptr->clkctr |= TX4925_CLKCTR_PCIRSTI;
+		*rbtx4925_pcireset_ptr = 0;
+	}
+#endif
+	rbtx4925_pci_setup();
+#endif
+
+	/* PIO */
+#if 0
+	/* PIO[2,0]: DIPSW , PIO[3,1]: LEDs */
+	tx4925_pioptr->dir = 0x0000000a;
+	tx4925_pioptr->maskcpu = 0;
+	tx4925_pioptr->maskext = 0;
+#endif
+}
+
+#if 0
+#define JMI_CE	3
+
+static int rbtx4925_check_iob(void)
+{
+	unsigned char idt;
+	unsigned long flags;
+	unsigned long romcr;
+	save_and_cli(flags);
+	romcr = tx4925_ebuscptr->ch[JMI_CE].cr;
+	tx4925_ebuscptr->ch[JMI_CE].cr = romcr & ~0x40001000ull;	/* do not wait infinitely */
+	idt = jmi39io2_isac_reg_in(JMI39IO2_ISAC_REV_ADDR(RBTX4925_IOB_BASE))
+		& JMI39IO2_IDT_MASK;
+	tx4925_ebuscptr->ch[JMI_CE].cr = romcr;
+	restore_flags(flags);
+	return idt == JMI39IO2_ISAC_IDT;
+}
+#endif
+
+static struct resource rbtx4925_ebus_resources[8] = {
+	{ "EBUS0", 0, 0, IORESOURCE_MEM },
+	{ "EBUS1", 0, 0, IORESOURCE_MEM },
+	{ "EBUS2", 0, 0, IORESOURCE_MEM },
+	{ "EBUS3", 0, 0, IORESOURCE_MEM },
+	{ "EBUS4", 0, 0, IORESOURCE_MEM },
+	{ "EBUS5", 0, 0, IORESOURCE_MEM },
+	{ "EBUS6", 0, 0, IORESOURCE_MEM },
+	{ "EBUS7", 0, 0, IORESOURCE_MEM },
+};
+static struct resource tx4925_reg_resource = {
+	"TX4925", TX4925_REG_BASE, TX4925_REG_BASE+TX4925_REG_SIZE, IORESOURCE_MEM
+};
+
+static struct resource rbtx4925_fpga_resource;
+static struct resource rbtx4925_pcmcia_resource;
+
+void __init sg4x00_setup(void)
+{
+	int i;
+	unsigned long pcfg;
+
+	tx4925_setup();
+
+	board_time_init = rbtx4925_time_init;
+	board_timer_setup = rbtx4925_timer_setup;
+	irq_setup = rbtx4925_irq_setup;
+	/* map ioport 0 to PCI I/O space address 0 */
+	set_io_port_base(KSEG1ADDR(rbtx4925_pci_io_base));
+
+	/* setup PCI area */
+	toshibaboards_pci_io_resource.start = 0;
+	toshibaboards_pci_io_resource.end = rbtx4925_pci_io_size - 1;
+	toshibaboards_pci_mem_resource.start = rbtx4925_pci_mem_base;
+	toshibaboards_pci_mem_resource.end =
+		rbtx4925_pci_mem_base + rbtx4925_pci_mem_size - 1;
+
+	/* TX4925 internal registers */
+	iomem_resource.end = 0xffffffff;	/* 4GB */
+	request_resource(&iomem_resource, &tx4925_reg_resource);
+	/* reserve EBUS area */
+	for (i = 0; i < 8; i++) {
+		rbtx4925_ebus_resources[i].start = rbtx4925_ce_base[i];
+		rbtx4925_ebus_resources[i].end =
+			rbtx4925_ce_base[i] + rbtx4925_ce_size[i] - 1;
+		if (rbtx4925_ebus_resources[i].start) {
+			request_resource(&iomem_resource,
+					 &rbtx4925_ebus_resources[i]);
+		}
+	}
+#if 0
+	rbtx4925_fpga_resource.name = "FPGA Registers";
+	rbtx4925_fpga_resource.start =
+		virt_to_bus((void *)RBTX4925_FPGA_REG_ADDR);
+	rbtx4925_fpga_resource.end =
+		virt_to_bus((void *)RBTX4925_FPGA_REG_ADDR) + 0xffff;
+	rbtx4925_fpga_resource.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+	request_resource(&rbtx4925_ebus_resources[2], &rbtx4925_fpga_resource);
+
+	rbtx4925_pcmcia_resource.name = "PCMCIA Interface";
+	rbtx4925_pcmcia_resource.start =
+		virt_to_bus((void *)RBTX4925_PCMCIA_BASE);
+	rbtx4925_pcmcia_resource.end =
+		virt_to_bus((void *)RBTX4925_PCMCIA_BASE) + 0x48;
+	rbtx4925_pcmcia_resource.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+	request_resource(&rbtx4925_ebus_resources[2], &rbtx4925_pcmcia_resource);
+
+	/* disable all OnBoard I/O interrupts */
+	*rbtx4925_imask_ptr = 0;
+	*rbtx4925_imask2_ptr = 0;
+#endif
+
+#if defined(CONFIG_MCT_SA200)
+	_machine_restart = rbtx4925_machine_restart;
+	_machine_halt = sa200_machine_halt;
+	_machine_power_off = sa200_machine_halt;
+#else
+	_machine_restart = rbtx4925_machine_restart;
+	_machine_halt = rbtx4925_machine_halt;
+	_machine_power_off = rbtx4925_machine_power_off;
+#endif
+	toshibaboards_pci_ops = &rbtx4925_pci_ops;
+	toshibaboards_pci_map_irq = rbtx4925_pci_map_irq;
+
+	/* TX4925-SIO0 DTR on */
+	*rbtx4925_siodtr_ptr = 0;
+	/* setting PIOSEL by PCFG */
+	pcfg = tx4925_ccfgptr->pcfg;
+	*rbtx4925_piosel_ptr |= RBTX4925_PIOSEL_SIO(0);	/* always use SIO0 */
+	*rbtx4925_piosel_ptr |= RBTX4925_PIOSEL_NOPCTOE;
+#if 0
+	if (pcfg & TX4925_PCFG_SELACLC) {
+		/* disable SIO1, NAND */
+		*rbtx4925_piosel_ptr &= ~RBTX4925_PIOSEL_SIO(1);
+		*rbtx4925_piosel_ptr |= RBTX4925_PIOSEL_NOSMART;
+		/* Enable ACLC */
+		*rbtx4925_piosel_ptr &= ~RBTX4925_PIOSEL_NOACLINK;
+	} else {
+		/* disable ACLC */
+		*rbtx4925_piosel_ptr |= RBTX4925_PIOSEL_NOACLINK;
+		if (pcfg & TX4925_PCFG_SELNAND) {
+			/* disable SIO1 */
+			*rbtx4925_piosel_ptr &= ~RBTX4925_PIOSEL_SIO(1);
+			/* enable NAND */
+			*rbtx4925_piosel_ptr &= ~RBTX4925_PIOSEL_NOSMART;
+		} else {
+			/* disable NAND */
+			*rbtx4925_piosel_ptr |= RBTX4925_PIOSEL_NOSMART;
+			if (pcfg & TX4925_PCFG_SELSIO(1)) {
+				/* enable SIO1 */
+				*rbtx4925_piosel_ptr |= RBTX4925_PIOSEL_SIO(1);
+			} else {
+				/* disable SIO1 */
+				*rbtx4925_piosel_ptr &= ~RBTX4925_PIOSEL_SIO(1);
+			}
+		}
+	}
+	if (!(tx4925_ccfgptr->ccfg & TX4925_CCFG_PCTRCE) &&
+	    (pcfg & TX4925_PCFG_SELCARD(0))) {
+		/* enable PCMCIA */
+		*rbtx4925_piosel_ptr &= ~RBTX4925_PIOSEL_NOPCMCIA;
+	} else {
+		/* disable PCMCIA */
+		*rbtx4925_piosel_ptr |= RBTX4925_PIOSEL_NOPCMCIA;
+	}
+
+	*rbtx4925_led_ptr = 0xff;
+	printk("TOSHIBA RBTX4925 (Rev %02x) --- FPGA(Rev %02x)",
+	       *rbtx4925_board_rev_ptr, *rbtx4925_fpga_rev_ptr);
+	printk(" DIPSW:%02x PIOSEL:%02x\n",
+	       *rbtx4925_dipsw_ptr, *rbtx4925_piosel_ptr);
+
+	if (*rbtx4925_fpga_rev_ptr == 0x1f) {
+		/* PCI is not supported on FPGA Ver 1f */
+		toshibaboards_pci_ops = NULL;
+	}
+
+	if (rbtx4925_check_iob())
+		jmi39io2_init(RBTX4925_IOB_BASE, RBTX4925_IRQ_ISAC);
+	if (have_jmi39io2()) {
+		/* XXX JMI39IO2 pulls down INT0.  So we can not use
+                   IOC interrupt (including PCI interrupt). */
+		toshibaboards_pci_ops = NULL;
+		jmi39io2_kbd_init();
+#ifdef CONFIG_BLK_DEV_IDE
+		/* overrides PCI-IDE */
+		jmi39io2_ide_init();
+#endif
+	}
+#endif
+
+#if defined(CONFIG_SERIAL_TXX927)
+	for(i = 0; i < 2; i++) {
+		if (i == 1) {
+			/* disable SIO1 by PCFG setting */
+			if ((pcfg & TX4925_PCFG_SELACLC) ||
+			    (pcfg & TX4925_PCFG_SELNAND) ||
+			    !(pcfg & TX4925_PCFG_SELSIO(1)))
+				continue;
+		}
+		/* use Pre-scaler T0 (1/2) */
+		early_serial_txx927_setup(i,
+					  TX4925_SIO_REG(i),
+					  RBTX4925_IRQ_IRC_SIO(i),
+					  RBTX4925_IMCLK / 2 / 16,
+					  0);
+#ifdef CONFIG_REMOTE_DEBUG
+		early_serial_txx927_kgdb_setup(i,
+					       TX4925_SIO_REG(i),
+					       RBTX4925_IRQ_IRC_SIO(i),
+					       RBTX4925_IMCLK / 2 / 16);
+#endif
+	}
+#endif
+
+#if 0
+#ifdef CONFIG_JMI39IO2_NET
+	if (have_jmi39io2()) {
+		early_jmi39io2_ether_setup(JMI39IO2_ETHER_ADDR(RBTX4925_IOB_BASE) - mips_io_port_base,
+					   RBTX4925_IRQ_IRC_INT(JMI39IO2_INT_ETHER));
+	}
+#endif
+#ifdef CONFIG_FB_E1355
+	if (have_jmi39io2()) {
+		early_e1355_setup(JMI39IO2_LCDVGA_REG_BASE(RBTX4925_IOB_BASE),
+				  JMI39IO2_LCDVGA_MEM_BASE(RBTX4925_IOB_BASE));
+	}
+#endif
+	if (!(*rbtx4925_piosel_ptr & RBTX4925_PIOSEL_NOPCMCIA)) {
+		printk("PC Card Interface (ID %02x %02x %02x %02x)\n",
+		       L1121_inb(L1121_IDR1),
+		       L1121_inb(L1121_IDR2),
+		       L1121_inb(L1121_IDR3),
+		       L1121_inb(L1121_IDR4));
+		/* do soft reset */
+		L1121_outb(L1121_CR1_RESET, L1121_CR1);
+		L1121_outb(0, L1121_CR1);
+
+		/* disable all interrupt */
+		L1121_outb(0, L1121_IER);
+		/* edge trigger */
+		L1121_outb(0xff, L1121_ITSR);
+		/* clear pending interrupt */
+		L1121_outb(0xff, L1121_ECLR);
+	}
+#endif
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/sg4x00/time.c linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/time.c
--- linux-2.4.32/arch/mips/mct-boards/sg4x00/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/time.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,105 @@
+/*
+ *  linux/arch/mips/toshiba-boards/rbtx4925/time.c
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/time.h>
+
+#include <asm/toshiba-boards/rbtx4925.h>
+extern void s3511a_init(void);
+/* ne use onchip r4k counter or TMR timer as our system wide timer interrupt running at 100HZ. */
+int rbtx4925_use_r4k_timer;
+#define rbtx4925_tmrptr		tx4925_tmrptr(0)	/* TMR0 */
+
+/* Tick Timer divider */
+#define RBTX4925_TIMER_CCD	0	/* 1/2 */
+#define RBTX4925_TIMER_CLK	(RBTX4925_IMCLK / (2 << RBTX4925_TIMER_CCD))
+
+static void
+rbtx4925_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	rbtx4925_tmrptr->tisr = 0;	/* ack interrupt */
+	timer_interrupt(irq, dev_id, regs);
+}
+
+void __init rbtx4925_time_init(void)
+{
+	unsigned int ct0;
+	int i;
+
+	s3511a_init();
+	if (tx4925_ccfgptr->ccfg & TX4925_CCFG_TINTDIS) {
+		printk("Tick timer: use TX4925 timer0 interrupt.\n");
+		rbtx4925_use_r4k_timer = 0;
+	} else {
+		printk("Tick timer: use r4k counter interrupt.\n");
+		rbtx4925_use_r4k_timer = 1;
+	}
+
+	printk("calculating counter_frequency... ");
+
+	rbtx4925_tmrptr->cpra = RBTX4925_TIMER_CLK / HZ;
+	rbtx4925_tmrptr->itmr = TXx927_TMTITMR_TIIE | TXx927_TMTITMR_TZCE;
+	rbtx4925_tmrptr->ccdr = RBTX4925_TIMER_CCD;
+	rbtx4925_tmrptr->tcr =
+		TXx927_TMTCR_TCE | TXx927_TMTCR_CCDE | TXx927_TMTCR_TMODE_ITVL;
+
+	/* clear interval timer Int. */
+	rbtx4925_tmrptr->tisr = 0;
+	/* waiting for a new tick. */
+	while (!(rbtx4925_tmrptr->tisr & TXx927_TMTISR_TIIS))
+		;
+	ct0 = read_32bit_cp0_register(CP0_COUNT);
+	for (i = 0; i < 16; i++) {
+		/* clear interval timer Int. */
+		rbtx4925_tmrptr->tisr = 0;
+		/* waiting for a next tick. */
+		while (!(rbtx4925_tmrptr->tisr & TXx927_TMTISR_TIIS))
+			;
+	}
+//	mips_counter_frequency = // wg. SA200 - Udo
+	mips_hpt_frequency = 
+		(read_32bit_cp0_register(CP0_COUNT) - ct0) / 16 * HZ;
+}
+
+extern int setup_irq(unsigned int irq, struct irqaction *irqaction);
+void __init rbtx4925_timer_setup(struct irqaction *irq)
+{
+	if (rbtx4925_use_r4k_timer) {
+		unsigned int count;
+
+		/* we are using the cpu counter for timer interrupts */
+		setup_irq(RBTX4925_IRQ_LOCAL_TIMER, irq);
+
+		/* to generate the first timer interrupt */
+		count = read_32bit_cp0_register(CP0_COUNT);
+//		write_32bit_cp0_register(CP0_COMPARE, count + mips_counter_frequency / HZ); // wg. SA200 - Udo
+		write_32bit_cp0_register(CP0_COMPARE, count + mips_hpt_frequency / HZ);
+	} else {
+		/* wrap default timer interupt handler */
+		irq->handler = rbtx4925_timer_interrupt;
+#if 0	/* disabled by TINTDIS */
+		/* disable counter interrupt(IM7) */
+		set_cp0_status(STATUSF_IP7, 0);
+#endif
+		/* enable timer interrupt */
+		setup_irq(RBTX4925_IRQ_IRC_TMR(0), irq);
+	}
+//	printk("%08x(%d)\n", mips_counter_frequency, mips_counter_frequency); // wg. SA200 - udo
+	printk("%08x(%d)\n", mips_hpt_frequency, mips_hpt_frequency);
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/sg4x00/wdtmr.c linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/wdtmr.c
--- linux-2.4.32/arch/mips/mct-boards/sg4x00/wdtmr.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sg4x00/wdtmr.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,65 @@
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <asm/ptrace.h>		// for struct pt_regs
+
+#include <asm/mct-boards/rbtx4925.h>
+
+#define watchdog_tmrptr	tx4925_tmrptr(2)
+#define WATCHDOG_IRQ	RBTX4925_IRQ_IRC_TMR
+
+#define WATCHDOG_TIMER_CCD	0	// 1/2
+#define WATCHDOG_TIMER_CLK	(RBTX4925_IMCLK / (2 << WATCHDOG_TIMER_CCD))
+
+static struct timer_list	wdog_timer;
+
+static void wdog_callback(unsigned long dummy)
+{
+	watchdog_tmrptr->wtmr |= TXx927_TMTWTMR_TWC;
+	
+	init_timer(&wdog_timer);
+	wdog_timer.function = wdog_callback;
+	wdog_timer.expires = jiffies + HZ/2;
+	add_timer(&wdog_timer);
+}
+
+#if 0
+void enable_watchdog(void)
+{
+	watchdog_tmrptr->tcr = TXx927_TMTCR_TCE | TXx927_TMTCR_CCDE | TXx927_TMTCR_TMODE_WDOG;
+
+	init_timer(&wdog_timer);
+	wdog_timer.function = wdog_callback;
+	wdog_timer.expires = jiffies + HZ/2;
+	add_timer(&wdog_timer);
+}
+
+void disable_watchdog(void)
+{
+	// WDIS  = 1
+	watchdog_tmrptr->wtmr = TXx927_TMTWTMR_WDIS | TXx927_TMTWTMR_TWC;
+	// TCE = 0
+	watchdog_tmrptr->tcr = TXx927_TMTCR_TMODE_WDOG;
+
+	del_timer(&wdog_timer);
+}
+#endif
+
+/* Notice that the watchdog timer interrupt request is connected to the internal Reset circuit.
+ * This setting was completed during system boot(setup.c).
+ */
+void __init watchdog_init(void)
+{
+	printk("TXx927 Watchdog Driver Initialize\n");
+	watchdog_tmrptr->cpra = WATCHDOG_TIMER_CLK;
+	watchdog_tmrptr->wtmr = TXx927_TMTWTMR_TWIE | TXx927_TMTWTMR_TWC;
+	watchdog_tmrptr->ccdr = WATCHDOG_TIMER_CCD;
+	watchdog_tmrptr->tcr = TXx927_TMTCR_TCE | TXx927_TMTCR_CCDE | TXx927_TMTCR_TMODE_WDOG;
+
+	init_timer(&wdog_timer);
+	wdog_timer.function = wdog_callback;
+	wdog_timer.expires = jiffies + HZ/2;
+	add_timer(&wdog_timer);
+}
+
diff -Naru linux-2.4.32/arch/mips/mct-boards/sgx00/Makefile linux-2.4.32-mct/arch/mips/mct-boards/sgx00/Makefile
--- linux-2.4.32/arch/mips/mct-boards/sgx00/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sgx00/Makefile	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,32 @@
+#
+# Makefile for the TJSYS JMR-TX3927 board specific parts of the kernel
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (C) 2000-2001 Toshiba Corporation
+#
+
+.S.s:
+	$(CPP) $(AFLAGS) $< -o $@
+.S.o:
+	$(CC) $(AFLAGS) -c $< -o $@
+
+all: sgx00.o
+O_TARGET := sgx00.o
+obj-y	 := irq.o time.o setup.o pci.o prom.o s3511a.o wdtmr.o 
+
+ifeq ($(CONFIG_MCT_SG600),y) 
+obj-y	+= power.o
+endif
+
+ifeq ($(CONFIG_MCT_SA100),y) 
+obj-y	+= power.o
+endif
+
+include $(TOPDIR)/Rules.make
diff -Naru linux-2.4.32/arch/mips/mct-boards/sgx00/irq.c linux-2.4.32-mct/arch/mips/mct-boards/sgx00/irq.c
--- linux-2.4.32/arch/mips/mct-boards/sgx00/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sgx00/irq.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,327 @@
+/*
+ *  linux/arch/mips/mct-boards/jmr3927/irq.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+
+#include <linux/errno.h>
+#include <linux/kernel_stat.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#ifdef CONFIG_BLK_DEV_IDEPCI
+#include <linux/pci.h>
+#endif
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+
+#include <asm/ptrace.h>
+#include <asm/processor.h>
+#include <asm/mct-boards/irq.h>
+#include <asm/mct-boards/jmr3927.h>
+#include <asm/mct-boards/jmi39io2.h>
+
+#if JMR3927_IRQ_END > NR_IRQS
+#error JMR3927_IRQ_END > NR_IRQS
+#endif
+
+#define flush_wb()	\
+	__asm__ __volatile__( \
+		".set    push\n\t" \
+		".set    noreorder\n\t" \
+		"1: bc0f    1b\n\t" \
+		"nop\n\t" \
+		".set pop" \
+	)
+
+#if 0	/* Removed by Ethan on 04/07/2002 */
+
+#define JMR3927_IRQ_ISACINT JMR3927_IRQ_IRC_INT(JMI39IO2_INT_ISAC)
+
+static int jmr3927_gen_iack(void)
+{
+	/* generate ACK cycle */
+#ifdef __BIG_ENDIAN
+	return (tx3927_pcicptr->iiadp >> 24) & (NR_ISA_IRQS - 1);
+#else
+	return tx3927_pcicptr->iiadp & (NR_ISA_IRQS - 1);
+#endif
+}
+
+#define flush_wb()	\
+	__asm__ __volatile__( \
+		".set    push\n\t" \
+		".set    noreorder\n\t" \
+		"1: bc0f    1b\n\t" \
+		"nop\n\t" \
+		".set pop" \
+	)
+
+/*
+ * JMR3927 IOC controller definition
+ */
+static void jmr_ioc_irq_enable(unsigned int irq)
+{
+	int irq_nr = irq - JMR3927_IRQ_IOC;
+	/* 0: mask */
+	unsigned char imask =
+		jmr3927_ioc_reg_in(JMR3927_IOC_INTM_ADDR);
+	unsigned int bit = 1 << irq_nr;
+	jmr3927_ioc_reg_out(imask | bit, JMR3927_IOC_INTM_ADDR);
+	flush_wb();
+}
+static void jmr_ioc_irq_disable(unsigned int irq)
+{
+	int irq_nr = irq - JMR3927_IRQ_IOC;
+	/* 0: mask */
+	unsigned char imask =
+		jmr3927_ioc_reg_in(JMR3927_IOC_INTM_ADDR);
+	unsigned int bit = 1 << irq_nr;
+	jmr3927_ioc_reg_out(imask & ~bit, JMR3927_IOC_INTM_ADDR);
+	flush_wb();
+}
+static unsigned int jmr_ioc_irq_startup(unsigned int irq)
+{
+	jmr_ioc_irq_enable(irq);
+	return 0;
+}
+#define	jmr_ioc_irq_shutdown	jmr_ioc_irq_disable
+
+static void jmr_ioc_irq_ack(unsigned int irq)
+{
+	jmr_ioc_irq_disable(irq);
+}
+static void jmr_ioc_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		jmr_ioc_irq_enable(irq);
+}
+
+static hw_irq_controller jmr_ioc_irq_controller = {
+	typename:	"IOC",
+	startup:	jmr_ioc_irq_startup,
+	shutdown:	jmr_ioc_irq_shutdown,
+	enable:		jmr_ioc_irq_enable,
+	disable:	jmr_ioc_irq_disable,
+	ack:		jmr_ioc_irq_ack,
+	end:		jmr_ioc_irq_end,
+	set_affinity:	NULL,
+};
+
+static inline int jmr3927_ioc_irqroute(void)
+{
+	unsigned char istat = jmr3927_ioc_reg_in(JMR3927_IOC_INTS2_ADDR);
+	int i, irq;
+	for (i = 0; i < JMR3927_NR_IRQ_IOC; i++) {
+		if (istat & (1 << i)) {
+			irq = JMR3927_IRQ_IOC + i;
+			return toshibaboards_i8259_irqroute(irq);
+		}
+	}
+	return -1;
+}
+
+static int jmr3927_irc_irqdispatch(struct pt_regs *regs)
+{
+	int irq;
+#ifdef CONFIG_TX_BRANCH_LIKELY_BUG_WORKAROUND
+	tx_branch_likely_bug_fixup(regs);
+#endif
+	if ((regs->cp0_cause & CAUSEF_IP7) == 0)
+		return -1;
+	irq = (regs->cp0_cause >> CAUSEB_IP2) & 0x0f;
+#if 1 /* XXX DEBUG */
+	jmr3927_led_set(irq);
+#endif
+
+	irq += JMR3927_IRQ_IRC;
+	switch (irq) {
+	case JMR3927_IRQ_IOCINT:
+		irq = jmr3927_ioc_irqroute();
+		break;
+	case JMR3927_IRQ_ISACINT:
+		irq = jmi39io2_isac_irqroute();
+		break;
+	}
+	if (irq < 0)
+		return -1;
+	do_IRQ(irq, regs);
+	flush_wb();
+	return 0;
+}
+
+static struct irqaction ioc_action = {
+	no_action, 0, 0, "cascade(IOC)", NULL, NULL,
+};
+
+static struct irqaction isac_action = {
+	no_action, 0, 0, "cascade(JMI39IO2 ISAC)", NULL, NULL,
+};
+
+static void jmr3927_isaerr_interrupt(int irq, void * dev_id, struct pt_regs * regs)
+{
+#if 1
+	printk("ISA error interrupt (irq 0x%x).\n", irq);
+#endif
+}
+static struct irqaction isaerr_action = {
+	jmr3927_isaerr_interrupt, SA_INTERRUPT, 0, "ISA error", NULL, NULL,
+};
+#endif	/* Removed by Ethan */
+
+static void jmr3927_pcierr_interrupt(int irq, void * dev_id, struct pt_regs * regs)
+{
+#ifdef CONFIG_BLK_DEV_IDEPCI
+	/* ignore MasterAbort for ide probing... */
+	if ((tx3927_pcicptr->pcistat & 0xf900) == PCI_STATUS_REC_MASTER_ABORT) {
+		tx3927_pcicptr->pcistat |= PCI_STATUS_REC_MASTER_ABORT;
+		return;
+	}
+#endif
+#if 1
+	printk("PCI error interrupt (irq 0x%x).\n", irq);
+	printk("pcistat:%02x, lbstat:%04lx\n",
+	       tx3927_pcicptr->pcistat, tx3927_pcicptr->lbstat);
+#endif
+}
+static struct irqaction pcierr_action = {
+	jmr3927_pcierr_interrupt, SA_INTERRUPT, 0, "PCI error", NULL, NULL,
+};
+
+int jmi_ether_irq = 0;
+
+static int jmr3927_irc_irqdispatch(struct pt_regs *regs)
+{
+	int	irq;
+
+#ifdef CONFIG_TX_BRANCH_LIKELY_BUG_WORKAROUND
+	tx_branch_likely_bug_fixup(regs);
+#endif
+	if ((regs->cp0_cause & CAUSEF_IP7) == 0)
+		return -1;
+	irq = (regs->cp0_cause >> CAUSEB_IP2) & 0x0f;
+
+	irq += JMR3927_IRQ_IRC;
+/*
+	switch (irq) {
+	case JMR3927_IRQ_IOCINT:
+		irq = jmr3927_ioc_irqroute();
+		break;
+	case JMR3927_IRQ_ISACINT:
+		irq = jmi39io2_isac_irqroute();
+		break;
+	}
+*/
+	if (irq < 0)
+		return -1;
+	do_IRQ(irq, regs);
+	flush_wb();
+	return 0;
+}
+
+void __init jmr3927_irq_setup(void)
+{
+#if 1	/* Modified by Ethan on 04/07/2002 */
+
+	toshibaboards_irqdispatch = jmr3927_irc_irqdispatch;
+	/* setup irq descriptors */
+	tx3927_irq_init(JMR3927_IRQ_IRC);
+#if !defined(CONFIG_MCT_SA100)
+	setup_irq(JMR3927_IRQ_IRC_PCI, &pcierr_action);
+#endif
+	/* enable TX3927 IRC interrupt */
+	set_c0_status(CAUSEF_IP7);
+
+#else
+	int have_isac = have_jmi39io2();
+	int i;
+
+	/* Now, interrupt control disabled, */
+	/* all IRC interrupts are masked, */
+	/* all IRC interrupt mode are Low Active. */
+
+#ifdef CONFIG_JMI39IO2_NET
+	if (have_isac) {
+		/* JMI90IO2 ETHER (NE2000 compatible 10M-Ether) parameter setup */
+		/* temporary enable interrupt control */
+		tx3927_ircptr->cer = 1;
+		/* JMI39IO2 ETHER Int. Is High-Active. */
+		if (tx3927_ircptr->ssr & (1 << TX3927_IR_INT(JMI39IO2_INT_ETHER_ALT)))
+			jmi_ether_irq = JMR3927_IRQ_IRC_INT(JMI39IO2_INT_ETHER_ALT);
+#if 0	/* INT3 may be asserted by onboard PCI ether (even after reboot...) */
+		else if (tx3927_ircptr->ssr & (1 << TX3927_IR_INT(JMI39IO2_INT_ETHER)))
+			jmi_ether_irq = JMR3927_IRQ_IRC_INT(JMI39IO2_INT_ETHER);
+#endif
+		/* disable interrupt control */
+		tx3927_ircptr->cer = 0;
+
+		/* Ether1: High Active */
+		if (jmi_ether_irq) {
+			int ether_irc = jmi_ether_irq - JMR3927_IRQ_IRC;
+			printk(KERN_DEBUG "JMI39IO2 ether uses irq %d\n", jmi_ether_irq);
+			tx3927_ircptr->cr[ether_irc / 8] |=
+				TX3927_IRCR_HIGH << ((ether_irc % 8) * 2);
+			early_jmi39io2_ether_setup(JMI39IO2_ETHER_ADDR(JMR3927_IOB_BASE) - mips_io_port_base,
+						   jmi_ether_irq);
+		}
+	}
+#endif
+
+	/* mask all IOC interrupts */
+	jmr3927_ioc_reg_out(0, JMR3927_IOC_INTM_ADDR);
+	/* setup IOC interrupt mode (SOFT:High Active, Others:Low Active) */
+	jmr3927_ioc_reg_out(JMR3927_IOC_INTF_SOFT, JMR3927_IOC_INTP_ADDR);
+
+	/* clear PCI Soft interrupts */
+	jmr3927_ioc_reg_out(0, JMR3927_IOC_INTS1_ADDR);
+	/* clear PCI Reset interrupts */
+	jmr3927_ioc_reg_out(0, JMR3927_IOC_RESET_ADDR);
+
+	toshibaboards_irqdispatch = jmr3927_irc_irqdispatch;
+
+	/* setup irq descriptors */
+	tx3927_irq_init(JMR3927_IRQ_IRC);
+	for (i = JMR3927_IRQ_IOC; i < JMR3927_IRQ_IOC + JMR3927_NR_IRQ_IOC; i++) {
+#if 1
+		/* MODEM int always asserted. (We can not change polarity... bug?) */
+		if (i == JMR3927_IRQ_IOC_MODEM)
+			continue;
+#endif
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &jmr_ioc_irq_controller;
+	}
+
+	setup_irq(JMR3927_IRQ_IOCINT, &ioc_action);
+	if (have_isac) {
+		jmi39io2_isac_irq_init();
+		setup_irq(JMR3927_IRQ_ISACINT, &isac_action);
+		setup_irq(JMR3927_IRQ_ISAC + JMI39IO2_ISAC_INTB_ISAER, &isaerr_action);
+	}
+	setup_irq(JMR3927_IRQ_IRC_PCI, &pcierr_action);
+	/* enable TX3927 IRC interrupt */
+	set_c0_status(CAUSEF_IP7);
+
+	toshibaboards_gen_iack = jmr3927_gen_iack;
+#endif	/* Modified by Ethan */
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/sgx00/pci.c linux-2.4.32-mct/arch/mips/mct-boards/sgx00/pci.c
--- linux-2.4.32/arch/mips/mct-boards/sgx00/pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sgx00/pci.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,202 @@
+/* $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ *
+ * TX3927 specific PCI support.
+ *
+ * based on arch/mips/sni/pci.c
+ * Copyright (C) 1997, 1998 Ralf Baechle
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#include <linux/config.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <asm/mct-boards/jmr3927.h>
+
+#ifdef CONFIG_PCI
+
+int jmr3927_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+#if 1	/* Modified by Ethan on 04/07/2002 */
+
+#define PCI_IDSEL_ADDR_TO_SLOT(addr)	(addr - 11)
+
+	int	irq = 0;
+
+	if ( dev->bus->parent == NULL )
+	{
+		switch ( slot )
+		{
+		case PCI_IDSEL_ADDR_TO_SLOT(23):
+			irq = 16;
+			break;
+		case PCI_IDSEL_ADDR_TO_SLOT(24):
+			irq = 17;
+			break;
+		case PCI_IDSEL_ADDR_TO_SLOT(25):
+			irq = 18;	
+			break;
+		case PCI_IDSEL_ADDR_TO_SLOT(26):
+			irq = 19;	
+			break;
+		}
+	}
+
+	return irq;
+#else 
+	int irq = pin;
+
+	/* IRQ rotation (PICMG) */
+	irq--;	/* 0-3 */
+	if (dev->bus->parent == NULL &&
+	    slot == TX3927_PCIC_IDSEL_AD_TO_SLOT(23)) {
+		/* PCI CardSlot (IDSEL=A23, DevNu=12) */
+		/* PCIA => PCIC (IDSEL=A23) */
+		/* NOTE: JMR3927 JP1 must be set to OPEN */
+		irq = (irq + 2) % 4;
+	} else if (dev->bus->parent == NULL &&
+		   slot == TX3927_PCIC_IDSEL_AD_TO_SLOT(22)) {
+		/* PCI CardSlot (IDSEL=A22, DevNu=11) */
+		/* PCIA => PCIA (IDSEL=A22) */
+		/* NOTE: JMR3927 JP1 must be set to OPEN */
+		irq = (irq + 0) % 4;
+	} else {
+		/* PCI Backplane */
+		irq = (irq + 3 + slot) % 4;
+	}
+	irq++;	/* 1-4 */
+
+	printk("PCI: %04x:%04x, slot = %d, pin = %d, irq = %d\n", dev->vendor, dev->device, slot, pin, irq);
+	printk("PCI: PCIA = %d, PCIB = %d, PCIC = %d, PCID = %d\n",
+		JMR3927_IRQ_IOC_PCIA, JMR3927_IRQ_IOC_PCIB,
+		JMR3927_IRQ_IOC_PCIC, JMR3927_IRQ_IOC_PCID);
+
+	switch (irq) {
+	case 1:
+		irq = JMR3927_IRQ_IOC_PCIA;
+		break;
+	case 2:
+		irq = JMR3927_IRQ_IOC_PCIB;
+		break;
+	case 3:
+		irq = JMR3927_IRQ_IOC_PCIC;
+		break;
+	case 4:
+		irq = JMR3927_IRQ_IOC_PCID;
+		break;
+	}
+
+	/* Check OnBoard Ethernet (IDSEL=A24, DevNu=13) */
+	if (dev->bus->parent == NULL &&
+	    slot == TX3927_PCIC_IDSEL_AD_TO_SLOT(24)) {
+		extern int jmi_ether_irq;
+		/* check this irq line was reserved for JMI39IO2 ether */
+		if (jmi_ether_irq != JMR3927_IRQ_ETHER)
+			irq = JMR3927_IRQ_ETHER;
+		else
+			irq = 0;	/* disable */
+	}
+	return irq;
+#endif
+}
+
+
+static int
+mkaddr(struct pci_dev *dev, int where)
+{
+	if (dev->bus->number == 0 &&
+	    dev->devfn >= PCI_DEVFN(TX3927_PCIC_MAX_DEVNU, 0))
+		return -1;
+	tx3927_pcicptr->ica = ((dev->bus->number & 0xff) << 0x10) |
+	                      ((dev->devfn & 0xff) << 0x08) |
+	                      (where & 0xfc);
+	/* clear M_ABORT and Disable M_ABORT Int. */
+	tx3927_pcicptr->pcistat |= PCI_STATUS_REC_MASTER_ABORT;
+	tx3927_pcicptr->pcistatim &= ~PCI_STATUS_REC_MASTER_ABORT;
+	return 0;
+}
+
+static int
+check_abort(void)
+{
+	int code = PCIBIOS_SUCCESSFUL;
+	if (tx3927_pcicptr->pcistat & PCI_STATUS_REC_MASTER_ABORT) {
+		tx3927_pcicptr->pcistat |= PCI_STATUS_REC_MASTER_ABORT;
+		tx3927_pcicptr->pcistatim |= PCI_STATUS_REC_MASTER_ABORT;
+		code =PCIBIOS_DEVICE_NOT_FOUND;
+	}
+	return code;
+}
+
+/*
+ * We can't address 8 and 16 bit words directly.  Instead we have to
+ * read/write a 32bit word and mask/modify the data we actually want.
+ */
+static int jmr3927_pci_read_config_byte(struct pci_dev *dev, int where,
+					u8 *val)
+{
+	if (mkaddr(dev, where))
+		return -1;
+	*val = *(volatile u8 *)((ulong)&tx3927_pcicptr->icd | (where&3));
+	return check_abort();
+}
+
+static int jmr3927_pci_read_config_word(struct pci_dev *dev, int where,
+					u16 *val)
+{
+	if (mkaddr(dev, where))
+		return -1;
+	*val = le16_to_cpu(*(volatile u16 *)((ulong)&tx3927_pcicptr->icd | (where&3)));
+	return check_abort();
+}
+
+static int jmr3927_pci_read_config_dword(struct pci_dev *dev, int where,
+					 u32 *val)
+{
+	if (mkaddr(dev, where))
+		return -1;
+	*val = le32_to_cpu(tx3927_pcicptr->icd);
+	return check_abort();
+}
+
+static int jmr3927_pci_write_config_byte(struct pci_dev *dev, int where,
+					 u8 val)
+{
+	if (mkaddr(dev, where))
+		return -1;
+	*(volatile u8 *)((ulong)&tx3927_pcicptr->icd | (where&3)) = val;
+	return check_abort();
+}
+
+static int jmr3927_pci_write_config_word(struct pci_dev *dev, int where,
+					 u16 val)
+{
+	if (mkaddr(dev, where))
+		return -1;
+	*(volatile u16 *)((ulong)&tx3927_pcicptr->icd | (where&3)) = cpu_to_le16(val);
+	return check_abort();
+}
+
+static int jmr3927_pci_write_config_dword(struct pci_dev *dev, int where,
+					  u32 val)
+{
+	if (mkaddr(dev, where))
+		return -1;
+	tx3927_pcicptr->icd = cpu_to_le32(val);
+	return check_abort();
+}
+
+struct pci_ops jmr3927_pci_ops = {
+	read_byte:      jmr3927_pci_read_config_byte,
+	read_word:      jmr3927_pci_read_config_word,
+	read_dword:     jmr3927_pci_read_config_dword,
+	write_byte:     jmr3927_pci_write_config_byte,
+	write_word:     jmr3927_pci_write_config_word,
+	write_dword:    jmr3927_pci_write_config_dword
+};
+
+#endif /* CONFIG_PCI */
diff -Naru linux-2.4.32/arch/mips/mct-boards/sgx00/power.c linux-2.4.32-mct/arch/mips/mct-boards/sgx00/power.c
--- linux-2.4.32/arch/mips/mct-boards/sgx00/power.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sgx00/power.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,175 @@
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/init.h>
+#include <linux/reboot.h>
+#include <asm/tx3927.h>
+#include <linux/mount.h>
+#include <asm/reboot.h>
+#include <linux/delay.h>
+
+/*static*/ DECLARE_WAIT_QUEUE_HEAD(shutdown_wq);
+int shutdown_type = LINUX_REBOOT_CMD_POWER_OFF;
+
+#if 0
+static struct tq_struct shutdown_task;
+
+static void shutdown_routine(void *data)
+{
+	sys_reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, LINUX_REBOOT_CMD_POWER_OFF, NULL);
+}
+#endif
+
+static char task_name[][16] = {
+	"smbd", "nmbd", "nfsd", "atalkd", "ftpd"
+};
+
+#define MAX_SERVICES	256
+
+typedef struct {
+	struct list_head list;
+	int	pid;
+	char	*task_name;
+} SERVICE;
+
+SERVICE service[MAX_SERVICES];
+
+static LIST_HEAD(service_list);
+
+#if 0 /* ANDI */
+extern struct list_head vfsmntlist;
+#endif
+extern int do_umount(struct vfsmount *mnt, int flags);
+
+static int shutdown_thread(void *dummy)
+{
+	int	i, nservices;
+	struct list_head *slist;
+	SERVICE	*pservice;
+
+	struct task_struct *p;
+        struct task_struct *tsk = current;
+	DECLARE_WAITQUEUE(wait, tsk);
+	struct list_head *pmnt;
+	struct vfsmount *vfsmnt;
+
+        tsk->session = 1;
+        tsk->pgrp = 1;
+        tsk->flags |= PF_MEMALLOC;
+        strcpy(tsk->comm, "shutdownd");
+        tsk->tty = NULL;
+        spin_lock_irq(&tsk->sigmask_lock);
+        sigfillset(&tsk->blocked);
+        recalc_sigpending(tsk);
+        spin_unlock_irq(&tsk->sigmask_lock);
+
+	add_wait_queue(&shutdown_wq, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule();
+
+	nservices = 0;
+	for (i = 0; i < sizeof(task_name) / sizeof(task_name[0]); i++) {
+		for_each_task(p) {
+			if ( nservices >= MAX_SERVICES )
+				break;
+			if ( strcmp(task_name[i], p->comm) == 0 ) {
+				list_add_tail(&service[nservices].list, &service_list);
+				service[nservices].pid = p->pid;
+				service[nservices].task_name = task_name[i];
+				nservices++;
+				printk("Sending termination signal to %s(%d)\n", p->comm, p->pid);
+				force_sig(SIGTERM, p);
+			}
+		}
+	}
+		
+        while ( 1 ) {
+		struct list_head *slist_next;
+		for (slist = service_list.next; slist != &service_list; ) {
+			pservice = (SERVICE *) list_entry(slist, SERVICE, list);
+			for_each_task(p) {
+				if ( strcmp(pservice->task_name, p->comm) == 0 && pservice->pid == p->pid )
+					break;
+			}
+
+			slist_next = slist->next;
+			if ( p == &init_task ) {
+				printk("Shutdown %s(%d)\tOK\n", pservice->task_name, pservice->pid);
+				list_del(slist);
+			}
+			slist = slist_next;
+		}
+
+		if ( list_empty(&service_list) )
+			break;
+		schedule_timeout(HZ);
+	}
+
+#if 1
+#if 0 /* ANDI */
+	list_for_each(pmnt, &vfsmntlist) {
+		vfsmnt = list_entry(pmnt, struct vfsmount, mnt_list);	
+		//printk("devname = %s\n", vfsmnt->mnt_devname);
+		if ( strcmp("/dev/hda1", vfsmnt->mnt_devname) == 0 ) {
+			printk("trying umount /dev/hda1\n");
+			do_umount(vfsmnt, 0);
+			break;
+		}
+	}
+#endif
+#else
+	printk("Umount file system\n");
+	sys_umount("/dev/hda1", 0);
+#endif
+
+	sys_sync();
+	sys_reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, shutdown_type, NULL);
+
+        return 0;
+}
+
+static void power_interrupt(int irq, void *dev_id, struct pt_regs *pregs)
+{
+	printk("Power: power button pressed\n");
+	
+	// clear edge interrupt
+	tx3927_ircptr->scr = 0x105;
+
+#if 0
+	// disable interrupt
+	tx3927_ircptr->ilr[2] = 0;//tx3927_ircptr->ilr[2] & 0xffff00ff;
+#endif
+	free_irq(21, NULL);
+
+#if 0
+	shutdown_task.routine = shutdown_routine;
+	shutdown_task.data = 0;
+	queue_task(&shutdown_task, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+#endif
+	
+	wake_up_interruptible(&shutdown_wq);
+}
+
+static int __init power_init(void)
+{
+	int	result;
+
+	// set falling edge trigger
+	tx3927_ircptr->cr[0] = (tx3927_ircptr->cr[0] & 0xfffff3ff) | 0x00000800;
+
+	kernel_thread(shutdown_thread, NULL, CLONE_FS|CLONE_FILES|CLONE_SIGHAND);
+
+	result = request_irq(21, power_interrupt, SA_INTERRUPT, "power", NULL);
+	if ( result ) {
+		printk("Power: fail to request power interrupt.\n");
+		return result;
+	}
+
+	printk("Power: function of power button was initialised\n");
+
+	return 0;
+}
+__initcall(power_init);
diff -Naru linux-2.4.32/arch/mips/mct-boards/sgx00/prom.c linux-2.4.32-mct/arch/mips/mct-boards/sgx00/prom.c
--- linux-2.4.32/arch/mips/mct-boards/sgx00/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sgx00/prom.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,38 @@
+/*
+ *  linux/arch/mips/toshiba-boards/jmr3927/prom.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <asm/mct-boards/pmon.h>
+#include <asm/mct-boards/jmr3927.h>
+
+int __init jmr3927_prom_init(int argc, char **argv, char **envp)
+{
+#if 0
+	if (argc == -1) {
+		extern int jmr3927_ccfg_toeon;
+		if (strcmp(*argv, "toeon") == 0)
+			jmr3927_ccfg_toeon = 1;
+		else
+			return 0;
+		return 1;
+	}
+#endif
+
+	/* CCFG */
+	if ((tx3927_ccfgptr->ccfg & TX3927_CCFG_TLBOFF) == 0)
+		pmon_printf("Warnning: TX3927 TLB off\n");
+
+	return 0;
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/sgx00/rtc.c linux-2.4.32-mct/arch/mips/mct-boards/sgx00/rtc.c
--- linux-2.4.32/arch/mips/mct-boards/sgx00/rtc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sgx00/rtc.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,35 @@
+/*
+ *  linux/arch/mips/toshiba-boards/jmr3927/rtc.c
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ *
+ * RTC routines for Dallas chip.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 200-2001 Toshiba Corporation
+ */
+#include <asm/mc146818rtc.h>	/* bad name... */
+#include <asm/mct-boards/jmr3927.h>
+
+static unsigned char jmr3927_rtc_read_data(unsigned long addr)
+{
+	return jmr3927_nvram_in(addr);
+}
+
+static void jmr3927_rtc_write_data(unsigned char data, unsigned long addr)
+{
+	jmr3927_nvram_out(data, addr);
+}
+
+static int jmr3927_rtc_bcd_mode(void)
+{
+	return 1;
+}
+
+struct rtc_ops jmr3927_rtc_ops = {
+	&jmr3927_rtc_read_data,
+	&jmr3927_rtc_write_data,
+	&jmr3927_rtc_bcd_mode
+};
diff -Naru linux-2.4.32/arch/mips/mct-boards/sgx00/s3511a.c linux-2.4.32-mct/arch/mips/mct-boards/sgx00/s3511a.c
--- linux-2.4.32/arch/mips/mct-boards/sgx00/s3511a.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sgx00/s3511a.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,353 @@
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/rtc.h>		// for struct rtc_time
+#include <asm/io.h>
+#include <asm/delay.h>
+#include <asm/time.h>		// for rtc_set_time/rtc_get_time
+#include <asm/tx3927.h>
+
+//#define DEBUG_S3511A
+
+#ifdef DEBUG_S3511A
+struct timer_list s3511a_timer;
+#endif
+
+#if defined(CONFIG_MCT_SG100)
+#define S3511A_ADDR	0xb4001000
+#define S3511A_SCK	0x04
+#define S3511A_CS	0x02
+#define S3511A_SIO	0x01
+
+#define RTC_INACTIVE()	*(volatile unsigned char*) S3511A_ADDR = S3511A_SCK | S3511A_SIO;
+#define RTC_CL_DL()	*(volatile unsigned char *) S3511A_ADDR = S3511A_CS;
+#define RTC_CL_DH()	*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SIO;
+#define RTC_CH_DL()	*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK;
+#define RTC_CH_DH()	*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK | S3511A_SIO;	
+#define RTC_DATA()	(*(volatile unsigned char*) S3511A_ADDR)  & S3511A_SIO
+
+/*
+#define RTC_INACTIVE()	outb(S3511A_SCK | S3511A_SIO, S3511A_ADDR)
+#define RTC_CL_DL()	outb(S3511A_CS, S3511A_ADDR)
+#define RTC_CL_DH()	outb(S3511A_CS | S3511A_SIO, S3511A_ADDR)
+#define RTC_CH_DL()	outb(S3511A_CS | S3511A_SCK, S3511A_ADDR)
+#define RTC_CH_DH()	outb(S3511A_CS | S3511A_SCK | S3511A_SIO, S3511A_ADDR)
+#define RTC_DATA()	inb(S3511A_ADDR) & S3511A_SIO
+*/
+#elif defined(CONFIG_MCT_SA100)
+
+#if 0
+#define CPU_PIODO	0xfffef500
+#define CPU_PIODI	0xfffef504
+#endif
+
+#define CPU_GPIO_RTC_CS_BIT	0x00000200
+#define CPU_GPIO_RTC_SCK_BIT	0x00004000
+#define CPU_GPIO_RTC_SDA_BIT	0x00008000
+
+#if 0
+#define RTC_INACTIVE()	outl((inl(CPU_PIODI) & ~(CPU_GPIO_RTC_CS_BIT)) | CPU_GPIO_RTC_SCK_BIT | CPU_GPIO_RTC_SDA_BIT, CPU_PIODO)
+#define RTC_CL_DL()	outl((inl(CPU_PIODI) & ~(CPU_GPIO_RTC_SCK_BIT|CPU_GPIO_RTC_SDA_BIT)) | CPU_GPIO_RTC_CS_BIT, CPU_PIODO)
+#define RTC_CL_DH()	outl((inl(CPU_PIODI) & ~(CPU_GPIO_RTC_SCK_BIT)) | CPU_GPIO_RTC_SDA_BIT | CPU_GPIO_RTC_CS_BIT, CPU_PIODO)
+#define RTC_CH_DL()	outl((inl(CPU_PIODI) & ~(CPU_GPIO_RTC_SDA_BIT)) | CPU_GPIO_RTC_SCK_BIT | CPU_GPIO_RTC_CS_BIT, CPU_PIODO)
+#define RTC_CH_DH()	outl(inl(CPU_PIODI) | (CPU_GPIO_RTC_SCK_BIT|CPU_GPIO_RTC_SDA_BIT|CPU_GPIO_RTC_CS_BIT), CPU_PIODO)
+#define RTC_DATA()	inl(CPU_PIODI) & CPU_GPIO_RTC_SDA_BIT
+#else
+#define RTC_INACTIVE()	tx3927_pioptr->dout = (tx3927_pioptr->din & ~(CPU_GPIO_RTC_CS_BIT)) | CPU_GPIO_RTC_SCK_BIT | CPU_GPIO_RTC_SDA_BIT
+#define RTC_CL_DL()	tx3927_pioptr->dout = (tx3927_pioptr->din & ~(CPU_GPIO_RTC_SCK_BIT|CPU_GPIO_RTC_SDA_BIT)) | CPU_GPIO_RTC_CS_BIT
+#define RTC_CL_DH()	tx3927_pioptr->dout = (tx3927_pioptr->din & ~(CPU_GPIO_RTC_SCK_BIT)) | CPU_GPIO_RTC_SDA_BIT | CPU_GPIO_RTC_CS_BIT
+#define RTC_CH_DL()	tx3927_pioptr->dout = (tx3927_pioptr->din & ~(CPU_GPIO_RTC_SDA_BIT)) | CPU_GPIO_RTC_SCK_BIT | CPU_GPIO_RTC_CS_BIT
+#define RTC_CH_DH()	tx3927_pioptr->dout = tx3927_pioptr->din | (CPU_GPIO_RTC_SCK_BIT|CPU_GPIO_RTC_SDA_BIT|CPU_GPIO_RTC_CS_BIT)
+#define RTC_DATA()	tx3927_pioptr->din & CPU_GPIO_RTC_SDA_BIT
+#endif
+
+#endif
+
+#define S3511A_CMD_READ			0x01
+#define S3511A_CMD_WRITE		0x00
+
+#define S3511A_CMD_RESET		0x60
+#define S3511A_CMD_STATUS		0x62
+#define S3511A_CMD_REAL_TIME_DATA1	0x64
+#define S3511A_CMD_REAL_TIME_DATA2	0x66
+#define S3511A_CMD_FREQ			0x68
+
+#define S3511A_STATUS_POWER		0x80
+#define S3511A_STATUS_24EXPR		0x40
+#define S3511A_STATUS_INTAE		0x20
+#define S3511A_STATUS_INTME		0x08
+#define S3511A_STATUS_INTFE		0x02
+
+#ifndef BCD_TO_BIN
+#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)
+#endif
+
+#ifndef BIN_TO_BCD
+#define BIN_TO_BCD(val) ((val)=(((val)/10)<<4) + (val)%10)
+#endif
+
+#define s3511a_delay()		udelay(2)	// clock pulse width at least 1us
+#define s3511a_short_delay()	udelay(1)	// setup/hold time at least 0.2us
+
+void s3511a_access_prolog(void)
+{
+	//*(volatile unsigned char*) S3511A_ADDR = S3511A_SCK | S3511A_SIO;
+	RTC_INACTIVE();
+	s3511a_short_delay();	// setup time before CS rising
+	//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK | S3511A_SIO;	
+	RTC_CH_DH();
+	s3511a_short_delay();	// hold time after CS rising
+}
+
+void s3511a_access_epilog(void)
+{
+	//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK | S3511A_SIO;
+	RTC_CH_DH();
+	s3511a_short_delay();	// setup time before CS falling
+	//*(volatile unsigned char*) S3511A_ADDR = S3511A_SCK | S3511A_SIO;
+	RTC_INACTIVE();
+	s3511a_short_delay();	// hold time after CS falling
+}
+
+unsigned char s3511a_read_byte(void)
+{
+	int	i;
+	unsigned char	val;
+
+	val = 0;
+	for (i = 0; i < 8; i++)
+	{
+		s3511a_delay();
+		//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SIO;
+		RTC_CL_DH();
+		s3511a_delay();
+		//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK | S3511A_SIO;
+		RTC_CH_DH();
+		s3511a_delay();
+		//regval = *(volatile unsigned char*) S3511A_ADDR;
+
+		// Any read/write operation performed by the real-time data
+		// access command sends or receives the data from LSB.
+		if ( RTC_DATA() )
+			val |= (1 << i);
+	}
+
+	return val;
+}
+
+void s3511a_write_byte(unsigned char data)
+{
+	unsigned char	mask;
+
+	for (mask = 0x01; mask != 0; mask <<= 1)
+	{
+		if ( mask & data )
+		{
+			s3511a_delay();
+			//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SIO;
+			RTC_CL_DH();
+			s3511a_delay();
+			//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK | S3511A_SIO;
+			RTC_CH_DH();
+		}
+		else
+		{
+			s3511a_delay();
+			//*(volatile unsigned char *) S3511A_ADDR = S3511A_CS;
+			RTC_CL_DL();
+			s3511a_delay();
+			//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK;
+			RTC_CH_DL();
+		}
+	}
+}
+
+// command should be sent from MSB to LSB.
+void s3511a_write_command(unsigned char cmd)
+{
+	unsigned char	mask;
+
+	for (mask = 0x80; mask != 0; mask >>= 1)
+	{
+		if ( mask & cmd )
+		{
+			s3511a_delay();
+			//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SIO;
+			RTC_CL_DH();
+			s3511a_delay();
+			//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK | S3511A_SIO;
+			RTC_CH_DH();
+		}
+		else
+		{
+			s3511a_delay();
+			//*(volatile unsigned char *) S3511A_ADDR = S3511A_CS;
+			RTC_CL_DL();
+			s3511a_delay();
+			//*(volatile unsigned char*) S3511A_ADDR = S3511A_CS | S3511A_SCK;
+			RTC_CH_DL();
+		}
+	}
+}
+
+unsigned long s3511a_get_time(void)
+{
+	int	i;
+	unsigned char	val, rtctime[7];
+	unsigned char	year, month, mday, hour, minute, second;
+
+	s3511a_access_prolog();
+	s3511a_write_command(S3511A_CMD_REAL_TIME_DATA1 | S3511A_CMD_READ);
+	for (i = 0; i < 7; i++)
+	{
+		val = s3511a_read_byte();
+		rtctime[i] = val;
+	}
+	s3511a_access_epilog();
+
+	// clear AM/PM bit
+	rtctime[4] &= 0x7f;
+	
+	year = BCD_TO_BIN(rtctime[0]);
+	month = BCD_TO_BIN(rtctime[1]);
+	mday = BCD_TO_BIN(rtctime[2]);
+	hour = BCD_TO_BIN(rtctime[4]);
+	minute = BCD_TO_BIN(rtctime[5]);
+	second = BCD_TO_BIN(rtctime[6]);
+
+//#ifdef DEBUG_S3511A
+#if 1
+	printk("S3511A: %02x %02x %02x %02x %02x %02x %02x\n",
+		rtctime[0], rtctime[1], rtctime[2],
+		rtctime[3], rtctime[4], rtctime[5], rtctime[6]);
+#endif
+
+	return mktime(year+2000, month, mday, hour, minute, second);
+}
+
+int s3511a_set_time(unsigned long time)
+{
+	int		year;
+	unsigned char	month, mday, wday, hour, minute, second;
+	struct rtc_time tm;
+
+	to_tm(time, &tm);
+
+	year = tm.tm_year % 100;
+	month = tm.tm_mon + 1;
+	mday = tm.tm_mday;
+	wday = tm.tm_wday;
+	hour = tm.tm_hour;
+	minute = tm.tm_min;
+	second = tm.tm_sec;
+
+#ifdef DEBUG_S3511A
+	printk("S3511A SET: %02d/%02d/%02d %02d:%02d:%02d\n", year, month, mday, hour, minute, second);
+#endif
+
+	BIN_TO_BCD(year);
+	BIN_TO_BCD(month);
+	BIN_TO_BCD(mday);
+	BIN_TO_BCD(wday);
+	BIN_TO_BCD(hour);
+	BIN_TO_BCD(minute);
+	BIN_TO_BCD(second);
+
+	s3511a_access_prolog();
+	s3511a_write_command(S3511A_CMD_REAL_TIME_DATA1 | S3511A_CMD_WRITE);
+
+	s3511a_write_byte(year);
+	s3511a_write_byte(month);
+	s3511a_write_byte(mday);
+	s3511a_write_byte(wday);
+	s3511a_write_byte(hour);
+	s3511a_write_byte(minute);
+	s3511a_write_byte(second);
+
+	s3511a_access_epilog();
+
+	return 0;
+}
+
+void s3511a_reset(void)
+{
+	s3511a_access_prolog();
+	s3511a_write_command(S3511A_CMD_RESET | S3511A_CMD_WRITE);
+	s3511a_access_epilog();
+}
+
+unsigned char s3511a_get_status(void)
+{
+	unsigned char	val;
+
+	s3511a_access_prolog();
+	s3511a_write_command(S3511A_CMD_STATUS | S3511A_CMD_READ);
+	val = s3511a_read_byte();
+	s3511a_access_epilog();
+	return val;
+}
+
+void s3511a_set_status(unsigned char status)
+{
+	s3511a_access_prolog();
+	s3511a_write_command(S3511A_CMD_STATUS | S3511A_CMD_WRITE);
+	s3511a_write_byte(status);
+	s3511a_access_prolog();
+}
+
+void s3511a_set_frequency(unsigned short freq)
+{
+	s3511a_access_prolog();
+	s3511a_write_command(S3511A_CMD_FREQ | S3511A_CMD_WRITE);
+	s3511a_write_byte((unsigned char) (freq & 0xff));
+	s3511a_write_byte((unsigned char) ((freq >> 8) & 0xff));
+	s3511a_access_epilog();
+}
+
+#ifdef DEBUG_S3511A
+void s3511a_callback(unsigned long dummy)
+{
+	s3511a_get_time();
+	init_timer(&s3511a_timer);
+	s3511a_timer.function = s3511a_callback;
+	s3511a_timer.expires = jiffies + HZ;
+	add_timer(&s3511a_timer);
+}
+#endif
+			
+void __init s3511a_init(void)
+{
+	unsigned char status;
+
+#if defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100)
+	//fix bootloader v1.06 bug , resetup the rtc pin to open-drain
+	(*(volatile unsigned long *) 0xfffef50c) = 0x00004fff;
+//	printk("pio = %x\n",*(volatile unsigned long *) 0xfffef50c);
+#endif
+	status = s3511a_get_status();
+
+#ifdef DEBUG_S3511A
+	printk("S3511A: status = %02x\n", status);
+#endif
+	if ( status & S3511A_STATUS_POWER )
+	{
+		s3511a_reset();
+	}
+
+	// Make the INT# signal output using selected frequency.
+	// INTFE = 1
+	s3511a_set_frequency(0x0010);	// 2kHz
+	s3511a_set_status(S3511A_STATUS_24EXPR | S3511A_STATUS_INTFE);
+
+	rtc_set_time = s3511a_set_time;
+	rtc_get_time = s3511a_get_time;
+
+#ifdef DEBUG_S3511A
+	init_timer(&s3511a_timer);
+	s3511a_timer.function = s3511a_callback;
+	s3511a_timer.expires = jiffies + HZ;
+	add_timer(&s3511a_timer);
+#endif
+}
+
diff -Naru linux-2.4.32/arch/mips/mct-boards/sgx00/setup.c linux-2.4.32-mct/arch/mips/mct-boards/sgx00/setup.c
--- linux-2.4.32/arch/mips/mct-boards/sgx00/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sgx00/setup.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,449 @@
+/*
+ * linux/arch/mips/toshiba-boards/jmr3927/setup.c
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ *
+ * Setup pointers to hardware-dependent routines.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+
+#include <linux/config.h>
+#include <linux/hdreg.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/kdev_t.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <asm/system.h>
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mct-boards/pmon.h>
+#include <asm/mct-boards/pci.h>
+#include <asm/mct-boards/jmr3927.h>
+#include <asm/mct-boards/jmi39io2.h>
+#include <asm/mc146818rtc.h>	/* bad name... */
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/pci.h>
+#include <asm/time.h>
+#include <asm/mipsregs.h>
+#include <asm/ptrace.h>
+#include <asm/keyboard.h>
+#include <linux/ide.h>
+#if defined(CONFIG_SERIAL_TXX927)
+#include <asm/serial_txx927.h>
+#endif
+
+/*static*/ int jmr3927_ccfg_toeon = 0;
+
+#if 0	/* Removed by Ethan on 05/16/2002 */
+extern struct rtc_ops jmr3927_rtc_ops;
+#endif
+extern struct pci_ops jmr3927_pci_ops;
+extern int jmr3927_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin);
+extern void jmr3927_irq_setup(void) __init;
+extern void jmr3927_time_init(void) __init;
+extern void jmr3927_timer_setup(struct irqaction *irq) __init;
+
+#ifdef CONFIG_REMOTE_DEBUG
+extern int __init early_serial_txx927_kgdb_setup(int line, unsigned long base, int irq, int baud_base);
+extern void breakpoint(void);
+#define TOMON(s) printk(s); breakpoint()
+#else
+#define TOMON(s) pmon_printf(s); pmon_halt()
+#endif
+extern void wait_for_keypress(void);
+
+#if 1	/* Modified by Ethan on 04/04/2002 */
+static void sgboard_restart(void)
+{
+	unsigned long addr = 0xbfc00000;
+
+	/* added by Ethan on 07/17/2002 */
+	/* reset PCI local bus controller */
+	tx3927_pcicptr->lbc = tx3927_pcicptr->lbc | 0x00000800;
+
+	__asm__ __volatile__(
+		"j %0\n"
+		:
+		: "r" (addr)
+		);
+}
+
+static void sgboard_halt(void)
+{
+#if defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100)
+	tx3927_pioptr->dout = tx3927_pioptr->din | 0x0c00;
+#endif
+	while ( 1 );
+}
+#else
+static inline void do_reset(void)
+{
+#if 1	/* Resetting PCI bus */
+	jmr3927_ioc_reg_out(0, JMR3927_IOC_RESET_ADDR);
+	jmr3927_ioc_reg_out(JMR3927_IOC_RESET_PCI, JMR3927_IOC_RESET_ADDR);
+	(void)jmr3927_ioc_reg_in(JMR3927_IOC_RESET_ADDR);	/* flush WB */
+	mdelay(1);
+	jmr3927_ioc_reg_out(0, JMR3927_IOC_RESET_ADDR);
+#endif
+	jmr3927_ioc_reg_out(JMR3927_IOC_RESET_CPU, JMR3927_IOC_RESET_ADDR);
+}
+
+static void jmr3927_machine_restart(char *command)
+{
+	cli();
+	printk("Rebooting...");
+	do_reset();
+}
+
+static void jmr3927_machine_halt(void)
+{
+	cli();
+	printk("Press any key to reboot.\n");
+	wait_for_keypress();
+	do_reset();
+}
+
+static void jmr3927_machine_power_off(void)
+{
+	cli();
+	printk("Press any key to reboot.\n");
+	wait_for_keypress();
+	do_reset();
+}
+#endif	/* Modified by Ethan */
+
+static void __init tx3927_setup(void)
+{
+	int i;
+	unsigned long sdram_size;
+
+	/* SDRAMC are configured by PROM */
+	sdram_size = 1;
+	while (sdram_size + KSEG0 < toshibaboards_memory_upper)
+		sdram_size <<= 1;
+
+	/* ROMC */
+#if 0	/* Removed by Ethan on 04/06/2002 */
+	if (!(tx3927_romcptr->cr[1] & 8)) {
+		/* Flash1 or Flash-3 */
+		tx3927_romcptr->cr[1] =
+			(tx3927_romcptr->cr[0] & 0x000fffff) | JMR3927_ROMCE1;
+		/* CE1 is 32bit mode (Flash-1) if CE0 is 16bit mode(Flash-3) */
+		tx3927_romcptr->cr[1] ^= 0x08;
+	}
+#endif
+
+	// Ethan: the following setting may not work for some boards.
+	// Hence, the ROMCE2 configuration will follow the setting of boot loader.
+#if 0	/* Removed by Ethan on 05/16/2002 */
+	//tx3927_romcptr->cr[2] = JMR3927_ROMCE2 | 0x000064c8;
+	tx3927_romcptr->cr[2] = JMR3927_ROMCE2 | 0x0000f41f;
+#endif
+
+#if 0	/* Removed by Ethan on 04/06/2002 */
+	tx3927_romcptr->cr[3] = JMR3927_ROMCE3 | 0x0003f698;
+	tx3927_romcptr->cr[5] = JMR3927_ROMCE5 | 0x0000f218;
+#endif	/* Removed by Ethan */
+
+	/* CCFG */
+	/* enable Timeout BusError */
+	if (jmr3927_ccfg_toeon)
+		tx3927_ccfgptr->ccfg |= TX3927_CCFG_TOE;
+
+	/* Added by Ethan on 04/29/2002 */
+	/* Watchdog timer interrupt is connected to TX3927 internal reset. */
+	tx3927_ccfgptr->ccfg |= TX3927_CCFG_WR;
+
+	/* clear BusErrorOnWrite flag */
+	tx3927_ccfgptr->ccfg &= ~TX3927_CCFG_BEOW;
+	/* Disable PCI snoop */
+	tx3927_ccfgptr->ccfg &= ~TX3927_CCFG_PSNP;
+
+	/* Pin selection */
+#if 1	/* Modified by Ethan on 04/06/2002 */
+	tx3927_ccfgptr->pcfg = TX3927_PCFG_SDRCLKEN(0) | TX3927_PCFG_SELSIO(0) |
+#if defined(CONFIG_MCT_SG600) || defined(CONFIG_MCT_SA100)
+		TX3927_PCFG_PCICLKEN(0) | TX3927_PCFG_PCICLKEN(1) | TX3927_PCFG_PCICLKEN(2) | TX3927_PCFG_PCICLKEN(3);
+#else
+
+ 		TX3927_PCFG_PCICLKEN(0) | TX3927_PCFG_PCICLKEN(1);
+#endif
+
+#else
+	tx3927_ccfgptr->pcfg &= ~TX3927_PCFG_SELALL;
+	tx3927_ccfgptr->pcfg |=
+		TX3927_PCFG_SELSIOC(0) | TX3927_PCFG_SELSIO_ALL |
+		(TX3927_PCFG_SELDMA_ALL & ~TX3927_PCFG_SELDMA(1));
+#endif
+
+	printk("TX3927 -- CRIR:%08lx CCFG:%08lx PCFG:%08lx\n",
+	       tx3927_ccfgptr->crir,
+	       tx3927_ccfgptr->ccfg, tx3927_ccfgptr->pcfg);
+
+	/* IRC */
+	/* disable interrupt control */
+	tx3927_ircptr->cer = 0;
+	/* mask all IRC interrupts */
+	tx3927_ircptr->imr = 0;
+	for (i = 0; i < TX3927_NUM_IR / 2; i++) {
+		tx3927_ircptr->ilr[i] = 0;
+	}
+	/* setup IRC interrupt mode (Low Active) */
+	for (i = 0; i < TX3927_NUM_IR / 8; i++) {
+		tx3927_ircptr->cr[i] = 0;
+	}
+
+	/* TMR */
+	/* disable all timers */
+	for (i = 0; i < TX3927_NR_TMR; i++) {
+		tx3927_tmrptr(i)->tcr = TXx927_TMTCR_CRE;
+		tx3927_tmrptr(i)->tisr = 0;
+		tx3927_tmrptr(i)->cpra = 0xffffffff;
+		tx3927_tmrptr(i)->itmr = 0;
+		tx3927_tmrptr(i)->ccdr = 0;
+		tx3927_tmrptr(i)->pgmr = 0;
+	}
+
+	/* DMA */
+	tx3927_dmaptr->mcr = 0;
+	for (i = 0; i < sizeof(tx3927_dmaptr->ch) / sizeof(tx3927_dmaptr->ch[0]); i++) {
+		/* reset channel */
+		tx3927_dmaptr->ch[i].ccr = TX3927_DMA_CCR_CHRST;
+		tx3927_dmaptr->ch[i].ccr = 0;
+	}
+	/* enable DMA */
+#ifdef __BIG_ENDIAN
+	tx3927_dmaptr->mcr = TX3927_DMA_MCR_MSTEN;
+#else
+	tx3927_dmaptr->mcr = TX3927_DMA_MCR_MSTEN | TX3927_DMA_MCR_LE;
+#endif
+
+	/* PCIC */
+	printk("TX3927 PCIC -- DID:%04x VID:%04x RID:%02x Arbiter:",
+	       tx3927_pcicptr->did, tx3927_pcicptr->vid,
+	       tx3927_pcicptr->rid);
+	if (!(tx3927_ccfgptr->ccfg & TX3927_CCFG_PCIXARB)) {
+		printk("External\n");
+		/* XXX */
+	} else {
+		printk("Internal\n");
+
+#if 0	/* Removed by Ethan on 04/04/2002 */
+		/* Reset PCI Bus */
+		jmr3927_ioc_reg_out(0, JMR3927_IOC_RESET_ADDR);
+		udelay(100);
+		jmr3927_ioc_reg_out(JMR3927_IOC_RESET_PCI,
+				    JMR3927_IOC_RESET_ADDR);
+		udelay(100);
+		jmr3927_ioc_reg_out(0, JMR3927_IOC_RESET_ADDR);
+#endif	/* Removed by Ethan */
+
+		/* Disable PCI SNOOP */
+		tx3927_ccfgptr->ccfg &= ~TX3927_CCFG_PSNP;
+
+		/* Disable External PCI Config. Access */
+		tx3927_pcicptr->lbc = TX3927_PCIC_LBC_EPCAD;
+#ifdef __BIG_ENDIAN
+		tx3927_pcicptr->lbc |= TX3927_PCIC_LBC_IBSE |
+			TX3927_PCIC_LBC_TIBSE |
+			TX3927_PCIC_LBC_TMFBSE | TX3927_PCIC_LBC_MSDSE;
+#endif
+		/* LB->PCI mappings */
+		tx3927_pcicptr->iomas = ~(JMR3927_PCIIO_SIZE - 1);
+		tx3927_pcicptr->ilbioma = JMR3927_PCIIO;
+		tx3927_pcicptr->ipbioma = 0;
+		tx3927_pcicptr->mmas = ~(JMR3927_PCIMEM_SIZE - 1);
+		tx3927_pcicptr->ilbmma = JMR3927_PCIMEM;
+		tx3927_pcicptr->ipbmma = JMR3927_PCIMEM;
+		/* PCI->LB mappings */
+		tx3927_pcicptr->iobas = 0xffffffff;
+		tx3927_pcicptr->ioba = 0;
+		tx3927_pcicptr->tlbioma = 0;
+		tx3927_pcicptr->mbas = ~(sdram_size - 1);
+		tx3927_pcicptr->mba = (0 & PCI_BASE_ADDRESS_MEM_MASK);
+		tx3927_pcicptr->tlbmma = 0;
+		/* Enable Direct mapping Address Space Decoder */
+		tx3927_pcicptr->lbc |= TX3927_PCIC_LBC_ILMDE | TX3927_PCIC_LBC_ILIDE;
+
+
+		/* Clear All Local Bus Status */
+		tx3927_pcicptr->lbstat = TX3927_PCIC_LBIM_ALL;
+		/* Enable All Local Bus Interrupts */
+		tx3927_pcicptr->lbim = TX3927_PCIC_LBIM_ALL;
+		/* Clear All PCI Status Error */
+		tx3927_pcicptr->pcistat = TX3927_PCIC_PCISTATIM_ALL;
+		/* Enable All PCI Status Error Interrupts */
+		tx3927_pcicptr->pcistatim = TX3927_PCIC_PCISTATIM_ALL;
+
+		/* PCIC Int => IRC IRQ10 */
+		tx3927_pcicptr->il = TX3927_IR_PCI;
+#if 0
+		/* Target Control (???) */
+		tx3927_pcicptr->tc = TX3927_PCIC_TC_OF16E | TX3927_PCIC_TC_IF8E;
+#endif
+
+		/* Enable Bus Arbiter */
+#if 0
+		tx3927_pcicptr->req_trace = 0x73737373;
+#endif
+		tx3927_pcicptr->pbapmc = TX3927_PCIC_PBAPMC_PBAEN;
+		tx3927_pcicptr->tbl = 0x00000995;
+
+		tx3927_pcicptr->pcicmd = PCI_COMMAND_MASTER |
+			PCI_COMMAND_MEMORY |
+			PCI_COMMAND_IO
+#if !defined(CONFIG_MCT_SA100)
+			| PCI_COMMAND_PARITY | 
+			PCI_COMMAND_SERR
+#endif
+			;
+	}
+
+#if 0	/* Removed by Ethan on 05/16/2002 */
+	/* PIO */
+	/* PIO[15:12] connected to LEDs */
+	tx3927_pioptr->dir = 0x0000f000;
+	tx3927_pioptr->maskcpu = 0;
+	tx3927_pioptr->maskext = 0;
+#endif
+}
+
+#if 0	/* Removed by Ethan on 04/04/2002 */
+extern int early_premier3_setup(unsigned long base, int irq);
+extern int toshibaboards_probe_ieee1394_board(unsigned long base);
+static void __init jmr3927_check_ieee1394_board(void)
+{
+	unsigned long rccr5;
+
+	rccr5 = tx3927_romcptr->cr[5];
+	tx3927_romcptr->cr[5] =
+		(rccr5 & 0xfff00000) | 0x0000f218;	/* normal submode */
+	printk(KERN_DEBUG "RCCR5 %08lx\n", tx3927_romcptr->cr[5]);
+	if (toshibaboards_probe_ieee1394_board(JMR3927_PREMIER3_BASE) == 0) {
+		tx3927_romcptr->cr[5] =
+			(rccr5 & 0xfffc0000) | 0x0003f218;	/* ext.Ack */
+#ifdef CONFIG_IEEE1394_PREMIER3
+		early_premier3_setup(JMR3927_PREMIER3_BASE, JMR3927_IRQ_PREMIER3);
+#endif
+	} else {
+		tx3927_romcptr->cr[5] = rccr5;
+	}
+	printk(KERN_DEBUG "RCCR5 %08lx\n", tx3927_romcptr->cr[5]);
+}
+
+static int jmr3927_check_iob(void)
+{
+	unsigned char idt;
+	unsigned long flags;
+	unsigned long romcr3;
+	save_and_cli(flags);
+	romcr3 = tx3927_romcptr->cr[3];
+	tx3927_romcptr->cr[3] &= 0xffffefff;	/* do not wait infinitely */
+	idt = jmi39io2_isac_reg_in(JMI39IO2_ISAC_REV_ADDR(JMR3927_IOB_BASE)) & JMI39IO2_IDT_MASK;
+	tx3927_romcptr->cr[3] = romcr3;
+	restore_flags(flags);
+	return idt == JMI39IO2_ISAC_IDT;
+}
+#endif 	/* Removed by Ethan */
+
+static struct resource tx3927_reg_resource = {
+	"TX3927", TX3927_REG_BASE, TX3927_REG_BASE+TX3927_REG_SIZE, IORESOURCE_MEM
+};
+
+void __init sgx00_setup(void)
+{
+#if defined(CONFIG_SERIAL_TXX927)
+	int i;
+#endif
+	toshibaboards_pci_io_resource.start = 0;
+	toshibaboards_pci_io_resource.end = JMR3927_PCIIO_SIZE - 1;
+	toshibaboards_pci_mem_resource.start = JMR3927_PCIMEM;
+	toshibaboards_pci_mem_resource.end =
+		JMR3927_PCIMEM + JMR3927_PCIMEM_SIZE - 1;
+
+	tx3927_setup();
+
+	/* TX3927 internal registers */
+	iomem_resource.end = 0xffffffff;	/* 4GB */
+	request_resource(&iomem_resource, &tx3927_reg_resource);
+
+	board_time_init = jmr3927_time_init;
+	board_timer_setup = jmr3927_timer_setup;
+	irq_setup = jmr3927_irq_setup;
+	/* map ioport 0 to PCI I/O space address 0 */
+	set_io_port_base(KSEG1ADDR(JMR3927_PCIIO));
+
+#if 1	/* Modified by Ethan on 04/04/2002 */
+	_machine_restart = sgboard_restart;
+	_machine_halt = sgboard_halt;
+	_machine_power_off = sgboard_halt;
+#else
+	_machine_restart = jmr3927_machine_restart;
+	_machine_halt = jmr3927_machine_halt;
+	_machine_power_off = jmr3927_machine_power_off;
+#endif
+
+#if 0	/* Removed by Ethan on 05/16/2002 */
+	if (jmr3927_have_nvram()) {
+		rtc_ops = &jmr3927_rtc_ops;
+	}
+#endif
+	toshibaboards_pci_ops = &jmr3927_pci_ops;
+	toshibaboards_pci_map_irq = jmr3927_pci_map_irq;
+
+#if 0	/* Removed by Ethan on 04/04/2002 */
+	/* SIO0 DTR on */
+	jmr3927_ioc_reg_out(0, JMR3927_IOC_DTR_ADDR);
+
+	jmr3927_led_set(0);
+	printk("TJSYS JMR-TX3927 (Rev %d) --- IOC(Rev %d) DIPSW:%d,%d,%d,%d\n",
+	       jmr3927_ioc_reg_in(JMR3927_IOC_BREV_ADDR) & JMR3927_REV_MASK,
+	       jmr3927_ioc_reg_in(JMR3927_IOC_REV_ADDR) & JMR3927_REV_MASK,
+	       jmr3927_dipsw1(), jmr3927_dipsw2(),
+	       jmr3927_dipsw3(), jmr3927_dipsw4());
+
+	if (jmr3927_check_iob())
+		jmi39io2_init(JMR3927_IOB_BASE, JMR3927_IRQ_ISAC);
+	if (have_jmi39io2()) {
+		jmi39io2_kbd_init();
+#ifdef CONFIG_BLK_DEV_IDE
+		/* overrides PCI-IDE */
+		jmi39io2_ide_init();
+#endif
+	}
+
+	jmr3927_check_ieee1394_board();
+#endif	/* Removed by Ethan */
+
+#if defined(CONFIG_SERIAL_TXX927)
+	/* loop until early_txx927_serial_setup() returns error. */
+	for(i = 0; i < 2; i++) {
+		/* use Pre-scaler T0 (1/2) */
+		early_serial_txx927_setup(i,
+					  TX3927_SIO_REG(i),
+					  JMR3927_IRQ_IRC_SIO(i),
+					  JMR3927_IMCLK / 2 / 16,
+					  (i == 0) ? TXx927_SERIAL_HAVE_CTS_LINE : 0);
+#ifdef CONFIG_REMOTE_DEBUG
+		early_serial_txx927_kgdb_setup(i,
+					       TX3927_SIO_REG(i),
+					       JMR3927_IRQ_IRC_SIO(i),
+					       JMR3927_IMCLK / 2 / 16);
+#endif
+	}
+#endif
+#ifdef CONFIG_FB_E1355
+	if (have_jmi39io2()) {
+		early_e1355_setup(JMI39IO2_LCDVGA_REG_BASE(JMR3927_IOB_BASE),
+				  JMI39IO2_LCDVGA_MEM_BASE(JMR3927_IOB_BASE));
+	}
+#endif
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/sgx00/time.c linux-2.4.32-mct/arch/mips/mct-boards/sgx00/time.c
--- linux-2.4.32/arch/mips/mct-boards/sgx00/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sgx00/time.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,98 @@
+/*
+ *  linux/arch/mips/toshiba-boards/jmr3927/time.c
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/time.h>
+
+#include <asm/mct-boards/jmr3927.h>
+
+/* Tick Timer divider */
+#define JMR3927_TIMER_CCD	0	/* 1/2 */
+#define JMR3927_TIMER_CLK	(JMR3927_IMCLK / (2 << JMR3927_TIMER_CCD))
+
+/* This is for machines which generate the exact clock. */
+#define USECS_PER_JIFFY (1000000/HZ)
+
+static unsigned long jmr3927_do_gettimeoffset(void)
+{
+	unsigned long count;
+	unsigned long res = 0;
+
+	/* MUST read TRR before TISR. */
+	count = jmr3927_tmrptr->trr;
+
+	if (jmr3927_tmrptr->tisr & TXx927_TMTISR_TIIS) {
+		/* timer interrupt is pending.  use Max value. */
+		res = USECS_PER_JIFFY - 1;
+	} else {
+		/* convert to usec */
+		/* res = count / (JMR3927_TIMER_CLK / 1000000); */
+		res = (count << 7) / ((JMR3927_TIMER_CLK << 7) / 1000000);
+
+		/*
+		 * Due to possible jiffies inconsistencies, we need to check 
+		 * the result so that we'll get a timer that is monotonic.
+		 */
+		if (res >= USECS_PER_JIFFY)
+			res = USECS_PER_JIFFY-1;
+	}
+
+	return res;
+}
+
+static void
+jmr3927_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	jmr3927_tmrptr->tisr = 0;	/* ack interrupt */
+	timer_interrupt(irq, dev_id, regs);
+}
+
+extern void rtc_ds1742_init(void);
+extern void s3511a_init(void);
+
+void __init jmr3927_time_init(void)
+{
+#if 1	/* Modified by Ethan on 04/04/2002 */
+	s3511a_init();
+#else
+	if (jmr3927_have_nvram()) {
+		rtc_ds1742_init();
+	}
+#endif	/* Modified by Ethan */
+}
+
+extern int setup_irq(unsigned int irq, struct irqaction *irqaction);
+void __init jmr3927_timer_setup(struct irqaction *irq)
+{
+	/* override default gettimeoffset routine */
+	do_gettimeoffset = jmr3927_do_gettimeoffset;
+
+	/* wrap default timer interupt handler */
+	irq->handler = jmr3927_timer_interrupt;
+
+	/* enable timer counter */
+	jmr3927_tmrptr->cpra = JMR3927_TIMER_CLK / HZ;
+	jmr3927_tmrptr->itmr = TXx927_TMTITMR_TIIE | TXx927_TMTITMR_TZCE;
+	jmr3927_tmrptr->ccdr = JMR3927_TIMER_CCD;
+	jmr3927_tmrptr->tcr =
+		TXx927_TMTCR_TCE | TXx927_TMTCR_CCDE | TXx927_TMTCR_TMODE_ITVL;
+
+	/* enable timer interrupt */
+	setup_irq(JMR3927_IRQ_TICK, irq);
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/sgx00/wdtmr.c linux-2.4.32-mct/arch/mips/mct-boards/sgx00/wdtmr.c
--- linux-2.4.32/arch/mips/mct-boards/sgx00/wdtmr.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/sgx00/wdtmr.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,64 @@
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <asm/ptrace.h>		// for struct pt_regs
+
+#include <asm/mct-boards/jmr3927.h>
+
+#define watchdog_tmrptr	tx3927_tmrptr(2)
+#define WATCHDOG_IRQ	JMR3927_IRQ_IRC_TMR(2)
+
+#define WATCHDOG_TIMER_CCD	0	// 1/2
+#define WATCHDOG_TIMER_CLK	(JMR3927_IMCLK / (2 << WATCHDOG_TIMER_CCD))
+
+static struct timer_list	wdog_timer;
+
+static void wdog_callback(unsigned long dummy)
+{
+	watchdog_tmrptr->wtmr |= TXx927_TMTWTMR_TWC;
+	
+	init_timer(&wdog_timer);
+	wdog_timer.function = wdog_callback;
+	wdog_timer.expires = jiffies + HZ/2;
+	add_timer(&wdog_timer);
+}
+
+#if 0
+void enable_watchdog(void)
+{
+	watchdog_tmrptr->tcr = TXx927_TMTCR_TCE | TXx927_TMTCR_CCDE | TXx927_TMTCR_TMODE_WDOG;
+
+	init_timer(&wdog_timer);
+	wdog_timer.function = wdog_callback;
+	wdog_timer.expires = jiffies + HZ/2;
+	add_timer(&wdog_timer);
+}
+
+void disable_watchdog(void)
+{
+	// WDIS  = 1
+	watchdog_tmrptr->wtmr = TXx927_TMTWTMR_WDIS | TXx927_TMTWTMR_TWC;
+	// TCE = 0
+	watchdog_tmrptr->tcr = TXx927_TMTCR_TMODE_WDOG;
+
+	del_timer(&wdog_timer);
+}
+#endif
+
+/* Notice that the watchdog timer interrupt request is connected to the internal Reset circuit.
+ * This setting was completed during system boot(setup.c).
+ */
+void __init watchdog_init(void)
+{
+	watchdog_tmrptr->cpra = WATCHDOG_TIMER_CLK;
+	watchdog_tmrptr->wtmr = TXx927_TMTWTMR_TWIE | TXx927_TMTWTMR_TWC;
+	watchdog_tmrptr->ccdr = WATCHDOG_TIMER_CCD;
+	watchdog_tmrptr->tcr = TXx927_TMTCR_TCE | TXx927_TMTCR_CCDE | TXx927_TMTCR_TMODE_WDOG;
+
+	init_timer(&wdog_timer);
+	wdog_timer.function = wdog_callback;
+	wdog_timer.expires = jiffies + HZ/2;
+	add_timer(&wdog_timer);
+}
+
diff -Naru linux-2.4.32/arch/mips/mct-boards/tsdb/Makefile linux-2.4.32-mct/arch/mips/mct-boards/tsdb/Makefile
--- linux-2.4.32/arch/mips/mct-boards/tsdb/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/tsdb/Makefile	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,24 @@
+#
+# Makefile for the Toshiba SDB CPU board specific parts of the kernel
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (C) 1999-2001 Toshiba Corporation
+#
+
+.S.s:
+	$(CPP) $(AFLAGS) $< -o $@
+.S.o:
+	$(CC) $(AFLAGS) -c $< -o $@
+
+all: tsdb.o
+O_TARGET := tsdb.o
+obj-y	 := int-handler.o irq.o time.o rtc.o setup.o pci.o prom.o
+
+include $(TOPDIR)/Rules.make
diff -Naru linux-2.4.32/arch/mips/mct-boards/tsdb/int-handler.S linux-2.4.32-mct/arch/mips/mct-boards/tsdb/int-handler.S
--- linux-2.4.32/arch/mips/mct-boards/tsdb/int-handler.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/tsdb/int-handler.S	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,114 @@
+/*
+ *  linux/arch/mips/toshiba-boards/tsdb/int-handler.S
+ *
+ * Copyright (C) 1999-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/toshiba-boards/tsdb.h>
+
+	/* A lot of complication here is taken away because:
+	 *
+	 * 1) We handle one interrupt and return, sitting in a loop
+	 *    and moving across all the pending IRQ bits in the cause
+	 *    register is _NOT_ the answer, the common case is one
+	 *    pending IRQ so optimize in that direction.
+	 *
+	 * 2) We need not check against bits in the status register
+	 *    IRQ mask, that would make this routine slow as hell.
+	 *
+	 * 3) Linux only thinks in terms of all IRQs on or all IRQs
+	 *    off, nothing in between like BSD spl() brain-damage.
+	 *
+	 * We handle the IRQ according to _our_ priority which is:
+	 *
+	 * Highest ----     R4k Timer
+	 *                  USC (HeartBeat, etc.)
+	 *                  IOC (UART, etc.)
+	 *                  OnBoard Ether
+	 * Lowest  ----     PCI
+	 *
+	 * then we just return, if multiple IRQs are pending then
+	 * we will just take another exception, big deal.
+	 */
+
+	.text
+	.set	noreorder
+	.set	noat
+	.align	5
+	NESTED(tsdb_IRQ, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+	.set	at
+	lw	s0, PT_CAUSE(sp)
+#if 1
+	lw	t0, PT_STATUS(sp)		# get enabled interrupts
+	and	s0, t0		# isolate allowed ones
+#endif
+#if 1 /* XXX DEBUG */
+	srl	t0, s0, 8
+	nor	t0, zero, t0
+	lui	t1, %hi(TSDB_LED_ADDR)
+	sb	t0, %lo(TSDB_LED_ADDR)(t1)
+#endif
+	andi	t0, s0, (CAUSEF_IP0 << TSDB_TIMER_INT)
+#if 1 /* in case of tsdb_use_ext_timer != 0 */
+	beqz	t0, 1f
+	 nop
+	mfc0	t0, CP0_STATUS
+	andi	t0, (STATUSF_IP0 << TSDB_TIMER_INT)
+#endif
+	bnez	t0, local_int
+	 li	a1, TSDB_IRQ_LOCAL_TIMER
+1:
+	andi	t0, s0, (CAUSEF_IP0 << TSDB_USC_INT)
+	bnez	t0, usc_int
+	 nop
+	andi	t0, s0, (CAUSEF_IP0 << TSDB_IOC_INT)
+	bnez	t0, ioc_int
+	 nop
+	andi	t0, s0, (CAUSEF_IP0 << TSDB_ETHER_INT)
+	bnez	t0, local_int
+	 li	a1, TSDB_IRQ_LOCAL_ETHER
+	andi	t0, s0, (CAUSEF_IP0 << TSDB_PCI_INT)
+	bnez	t0, pci_int
+	 nop
+	andi	t0, s0, (CAUSEF_IP0 << TSDB_SOFT_INT0)
+	bnez	t0, local_int
+	 li	a1, TSDB_IRQ_LOCAL_SOFT0
+	andi	t0, s0, (CAUSEF_IP0 << TSDB_SOFT_INT1)
+	bnez	t0, local_int
+	 li	a1, TSDB_IRQ_LOCAL_SOFT1
+	j	spurious_interrupt
+	 nop
+local_int:
+	jal	tsdb_local_irqdispatch
+	 move	a0, sp
+	j	ret_from_irq
+	 nop
+usc_int:
+	jal	tsdb_usc_irqdispatch
+	 move	a0, sp
+	j	ret_from_irq
+	 nop
+ioc_int:
+	jal	tsdb_ioc_irqdispatch
+	 move	a0, sp
+	j	ret_from_irq
+	 nop
+pci_int:
+	jal	tsdb_pci_irqdispatch
+	 move	a0, sp
+	bltz	v0,1f
+	 nop
+	j	ret_from_irq
+	 nop
+1:
+	j	spurious_interrupt
+	 nop
+	END(tsdb_IRQ)
diff -Naru linux-2.4.32/arch/mips/mct-boards/tsdb/irq.c linux-2.4.32-mct/arch/mips/mct-boards/tsdb/irq.c
--- linux-2.4.32/arch/mips/mct-boards/tsdb/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/tsdb/irq.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,456 @@
+/*
+ *  linux/arch/mips/toshiba-boards/tsdb/irq.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1999-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+
+#include <linux/errno.h>
+#include <linux/kernel_stat.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#ifdef CONFIG_BLK_DEV_IDEPCI
+#include <linux/pci.h>
+#endif
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+
+#include <asm/ptrace.h>
+#include <asm/processor.h>
+#include <asm/toshiba-boards/irq.h>
+#include <asm/toshiba-boards/tsdb.h>
+
+#if TSDB_IRQ_END > NR_IRQS
+#error TSDB_IRQ_END > NR_IRQS
+#endif
+
+#if 0
+static int tsdb_gen_iack(void)
+{
+	/* generate ACK cycle */
+	unsigned long saved_base;
+	unsigned long vector;
+	struct v320usc_reg *usc = (struct v320usc_reg *)TSDB_USC_BASE;
+	/* generate ACK cycle */
+	saved_base = usc->lb_pci_base[0];
+	usc->lb_pci_base[0] =
+		(saved_base & ~(USC_LB_PCI_BASE_PCI_CMD_MASK |
+				USC_LB_PCI_BASE_PREFETCH |
+				USC_LB_PCI_BASE_ERR_EN)) |
+		USC_LB_PCI_BASE_PCI_CMD_IACK;
+	vector = *(volatile unsigned long *)KSEG1ADDR(TSDB_LB_PCI_APERTURE_0);
+	usc->lb_pci_base[0] = saved_base;
+	return vector & 0xff;
+}
+#endif
+
+extern asmlinkage void tsdb_IRQ(void);
+
+static void tsdb_pci_irq_enable(unsigned int irq)
+{
+	int irq_nr = irq - TSDB_IRQ_PCI;
+	if (irq_nr == TSDB_INTB_PCI_ENUM) {
+		struct v320usc_reg *usc = (struct v320usc_reg *)TSDB_USC_BASE;
+		usc->int_cfg[1] |= USC_INTF_INT3;
+	} else {
+		/* 0: mask */
+		*tsdb_pci_imask_ptr = *tsdb_pci_imask_ptr | (1 << irq_nr);
+		(void)*tsdb_pci_imask_ptr;	/* flush... */
+	}
+	wbflush();
+}
+static void tsdb_pci_irq_disable(unsigned int irq)
+{
+	int irq_nr = irq - TSDB_IRQ_PCI;
+	if (irq_nr == TSDB_INTB_PCI_ENUM) {
+		struct v320usc_reg *usc = (struct v320usc_reg *)TSDB_USC_BASE;
+		usc->int_cfg[1] &= ~USC_INTF_INT3;
+	} else {
+		/* 0: mask */
+		*tsdb_pci_imask_ptr = *tsdb_pci_imask_ptr & ~(1 << irq_nr);
+		(void)*tsdb_pci_imask_ptr;	/* flush... */
+	}
+	wbflush();
+}
+static unsigned int tsdb_pci_irq_startup(unsigned int irq)
+{
+	tsdb_pci_irq_enable(irq);
+	return 0;
+}
+#define	tsdb_pci_irq_shutdown	tsdb_pci_irq_disable
+
+static void tsdb_pci_irq_ack(unsigned int irq)
+{
+	tsdb_pci_irq_disable(irq);
+}
+static void tsdb_pci_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		tsdb_pci_irq_enable(irq);
+}
+
+static hw_irq_controller tsdb_pci_irq_controller = {
+	typename:	"PCI",
+	startup:	tsdb_pci_irq_startup,
+	shutdown:	tsdb_pci_irq_shutdown,
+	enable:		tsdb_pci_irq_enable,
+	disable:	tsdb_pci_irq_disable,
+	ack:		tsdb_pci_irq_ack,
+	end:		tsdb_pci_irq_end,
+	set_affinity:	NULL,
+};
+
+
+static void tsdb_ioc_irq_enable(unsigned int irq)
+{
+	int irq_nr = irq - TSDB_IRQ_IOC;
+	/* 0: mask */
+	*tsdb_ioc_imask_ptr = *tsdb_ioc_imask_ptr | (1 << irq_nr);
+	(void)*tsdb_ioc_imask_ptr;	/* flush... */
+	wbflush();
+}
+static void tsdb_ioc_irq_disable(unsigned int irq)
+{
+	int irq_nr = irq - TSDB_IRQ_IOC;
+	/* 0: mask */
+	*tsdb_ioc_imask_ptr = *tsdb_ioc_imask_ptr & ~(1 << irq_nr);
+	(void)*tsdb_ioc_imask_ptr;	/* flush... */
+	wbflush();
+}
+static unsigned int tsdb_ioc_irq_startup(unsigned int irq)
+{
+	tsdb_ioc_irq_enable(irq);
+	return 0;
+}
+#define	tsdb_ioc_irq_shutdown	tsdb_ioc_irq_disable
+
+static void tsdb_ioc_irq_ack(unsigned int irq)
+{
+	tsdb_ioc_irq_disable(irq);
+}
+static void tsdb_ioc_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		tsdb_ioc_irq_enable(irq);
+}
+
+static hw_irq_controller tsdb_ioc_irq_controller = {
+	typename:	"IOC",
+	startup:	tsdb_ioc_irq_startup,
+	shutdown:	tsdb_ioc_irq_shutdown,
+	enable:		tsdb_ioc_irq_enable,
+	disable:	tsdb_ioc_irq_disable,
+	ack:		tsdb_ioc_irq_ack,
+	end:		tsdb_ioc_irq_end,
+	set_affinity:	NULL,
+};
+
+
+static void tsdb_usc_irq_enable(unsigned int irq)
+{
+	int irq_nr = irq - TSDB_IRQ_USC;
+	/* 1: enable */
+	struct v320usc_reg *usc = (struct v320usc_reg *)TSDB_USC_BASE;
+	usc->int_cfg[0] |= 1 << irq_nr;
+	wbflush();
+}
+static void tsdb_usc_irq_disable(unsigned int irq)
+{
+	int irq_nr = irq - TSDB_IRQ_USC;
+	/* 1: enable */
+	struct v320usc_reg *usc = (struct v320usc_reg *)TSDB_USC_BASE;
+	usc->int_cfg[0] &= ~(1 << irq_nr);
+	wbflush();
+}
+static unsigned int tsdb_usc_irq_startup(unsigned int irq)
+{
+	tsdb_usc_irq_enable(irq);
+	return 0;
+}
+#define	tsdb_usc_irq_shutdown	tsdb_usc_irq_disable
+
+static void tsdb_usc_irq_ack(unsigned int irq)
+{
+	struct v320usc_reg *usc = (struct v320usc_reg *)TSDB_USC_BASE;
+
+	tsdb_usc_irq_disable(irq);
+
+	/* clear interrupts */
+	switch (irq - TSDB_IRQ_USC) {
+	case USC_INTB_DRAM_PI:
+		break;
+	case USC_INTB_DI0:
+	case USC_INTB_DI1:
+		usc->int_stat = USC_INTF_DI_EN;
+		break;
+	default:
+		usc->int_stat = 1 << (irq - TSDB_IRQ_USC);
+	}
+}
+static void tsdb_usc_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		tsdb_usc_irq_enable(irq);
+}
+
+static hw_irq_controller tsdb_usc_irq_controller = {
+	typename:	"USC",
+	startup:	tsdb_usc_irq_startup,
+	shutdown:	tsdb_usc_irq_shutdown,
+	enable:		tsdb_usc_irq_enable,
+	disable:	tsdb_usc_irq_disable,
+	ack:		tsdb_usc_irq_ack,
+	end:		tsdb_usc_irq_end,
+	set_affinity:	NULL,
+};
+
+static struct irqaction pci_action = {
+	no_action, 0, 0, "cascade(PCI)", NULL, NULL
+};
+static struct irqaction ioc_action = {
+	no_action, 0, 0, "cascade(IOC)", NULL, NULL
+};
+static struct irqaction usc_action = {
+	no_action, 0, 0, "cascade(USC)", NULL, NULL
+};
+
+
+static void tsdb_pushsw_interrupt(int irq, void * dev_id, struct pt_regs * regs)
+{
+#if 1
+	tsdb_leddisp_put(regs->cp0_epc);
+#endif
+	*tsdb_ioc_istat_ptr = TSDB_INTF_IOC_PUSHSW;
+}
+static struct irqaction pushsw_action = {
+	tsdb_pushsw_interrupt, SA_INTERRUPT, 0, "INT Switch", NULL, NULL,
+};
+
+static void tsdb_uscerr_interrupt(int irq, void * dev_id, struct pt_regs * regs)
+{
+	char *s;
+#ifdef CONFIG_BLK_DEV_IDEPCI
+	/* ignore MasterAbort for ide probing... */
+	if (irq == TSDB_IRQ_USC_PCI_M_ABORT) {
+		struct v320usc_reg *usc = (struct v320usc_reg *)TSDB_USC_BASE;
+		usc->pci_stat |= PCI_STATUS_REC_MASTER_ABORT;
+		usc->int_stat |= USC_INTF_PCI_M_ABORT;
+		/* avoid spurious interrupt...(why?) */
+		*tsdb_fpga_rev_ptr = *tsdb_fpga_rev_ptr;
+		wbflush();
+		return;
+	}
+#endif
+	switch (irq) {
+	case TSDB_IRQ_USC_PSLAVE_PI: s = "PSLAVE_PI"; break;
+	case TSDB_IRQ_USC_PMASTER_PI: s = "PMASTER_PI"; break;
+	case TSDB_IRQ_USC_PCI_T_ABORT: s = "PCI_T_ABORT"; break;
+	case TSDB_IRQ_USC_PCI_M_ABORT: s = "PCI_M_ABORT"; break;
+	case TSDB_IRQ_USC_DRAM_PI: s = "DRAM_PI"; break;
+	default: s = "UNKNOWN";
+	}
+	printk(KERN_ERR "USC error (%s) interrupt at 0x%08lx.\n", s, regs->cp0_epc);
+}
+static struct irqaction uscerr_action = {
+	tsdb_uscerr_interrupt, SA_INTERRUPT, 0, "USC error", NULL, NULL,
+};
+static void tsdb_pcierr_interrupt(int irq, void * dev_id, struct pt_regs * regs)
+{
+#if 1
+	printk("PCI error interrupt (irq 0x%x).\n", irq);
+#endif
+}
+static struct irqaction pci_perr_action = {
+	tsdb_pcierr_interrupt, SA_INTERRUPT, 0, "PCI PERR", NULL, NULL,
+};
+static struct irqaction pci_serr_action = {
+	tsdb_pcierr_interrupt, SA_INTERRUPT, 0, "PCI SERR", NULL, NULL,
+};
+
+void tsdb_local_irqdispatch(struct pt_regs *regs, int irq)
+{
+#ifdef CONFIG_TX_BRANCH_LIKELY_BUG_WORKAROUND
+	tx_branch_likely_bug_fixup(regs);
+#endif
+#ifdef CONFIG_TX_FPU_C_BUG_WORKAROUND
+	tx_fpu_c_bug_fixup(regs);
+#endif
+	do_IRQ(irq, regs);
+	wbflush();
+}
+
+void tsdb_usc_irqdispatch(struct pt_regs *regs)
+{
+	struct v320usc_reg *usc = (struct v320usc_reg *)TSDB_USC_BASE;
+	unsigned long istat = usc->int_stat;
+	int i;
+#ifdef CONFIG_TX_BRANCH_LIKELY_BUG_WORKAROUND
+	tx_branch_likely_bug_fixup(regs);
+#endif
+#ifdef CONFIG_TX_FPU_C_BUG_WORKAROUND
+	tx_fpu_c_bug_fixup(regs);
+#endif
+	/* only check INT_CFG0 */
+	istat &= usc->int_cfg[0];
+	for (i = 0; i < TSDB_NR_IRQ_USC; i++) {
+		if (istat & (1 << i)) {
+			do_IRQ(TSDB_IRQ_USC + i, regs);
+			break;
+		}
+	}
+	wbflush();
+}
+
+void tsdb_ioc_irqdispatch(struct pt_regs *regs)
+{
+	unsigned char istat = *tsdb_ioc_istat_ptr;	/* 0: int */
+	unsigned char imask = *tsdb_ioc_imask_ptr;	/* 0: mask */
+	int i;
+#ifdef CONFIG_TX_BRANCH_LIKELY_BUG_WORKAROUND
+	tx_branch_likely_bug_fixup(regs);
+#endif
+#ifdef CONFIG_TX_FPU_C_BUG_WORKAROUND
+	tx_fpu_c_bug_fixup(regs);
+#endif
+	istat = (~istat) & imask;
+	for (i = 0; i < TSDB_NR_IRQ_IOC; i++) {
+		if (istat & (1 << i)) {
+			do_IRQ(TSDB_IRQ_IOC + i, regs);
+			break;
+		}
+	}
+	wbflush();
+}
+
+int tsdb_pci_irqdispatch(struct pt_regs *regs)
+{
+	struct v320usc_reg *usc = (struct v320usc_reg *)TSDB_USC_BASE;
+	unsigned char istat = *tsdb_pci_istat_ptr;	/* 0: int */
+	unsigned char imask = *tsdb_pci_imask_ptr;	/* 0: mask */
+	int i;
+	int irq;
+	istat = (~istat) & imask;
+
+#ifdef CONFIG_TX_BRANCH_LIKELY_BUG_WORKAROUND
+	tx_branch_likely_bug_fixup(regs);
+#endif
+#ifdef CONFIG_TX_FPU_C_BUG_WORKAROUND
+	tx_fpu_c_bug_fixup(regs);
+#endif
+	/* check ENUM */
+	if ((usc->int_cfg[1] & USC_INTF_INT3) &&
+	    (usc->int_stat & USC_INTF_INT3)) {
+		do_IRQ(TSDB_IRQ_PCI_ENUM, regs);
+		wbflush();
+		return 0;
+	}
+
+	for (i = 0; i < TSDB_NR_IRQ_PCI; i++) {
+		if (istat & (1 << i)) {
+			irq = TSDB_IRQ_PCI + i;
+			irq = toshibaboards_i8259_irqroute(irq);
+			if (irq < 0)
+				return -1;
+			do_IRQ(irq, regs);
+			break;
+		}
+	}
+	wbflush();
+	return 0;
+}
+
+void __init tsdb_irq_setup(void)
+{
+	struct v320usc_reg *usc = (struct v320usc_reg *)TSDB_USC_BASE;
+	int i;
+
+	/* mask all IOC/PCI interrupts */
+	*tsdb_ioc_imask_ptr = 0;
+	*tsdb_pci_imask_ptr = 0;
+
+	/* clear PushSW/NMI interrupts */
+	*tsdb_ioc_istat_ptr = TSDB_INTF_IOC_PUSHSW;
+	*tsdb_nmi_istat_ptr = TSDB_INTF_NMI_NMI;
+
+	/* clear SoftReset/SoftInt interrupts */
+	*tsdb_softreset_ptr = 1;
+	*tsdb_softint_ptr = 1;
+
+	/* clear PCI Reset interrupts */
+	*tsdb_pcireset_ptr = 1;
+
+	/* inputs from INT2,INT3 generate an INT1 interrupt. */
+	usc->int_cfg[0] = 0;
+	usc->int_cfg[1] = USC_INTF_INT2;
+	usc->int_cfg[2] = 0;
+	usc->int_cfg3 = 0;
+
+	set_except_vector(0, tsdb_IRQ);
+
+	/* setup irq descriptors */
+	mips_cpu_irq_init(TSDB_IRQ_LOCAL);
+	for (i = TSDB_IRQ_PCI; i < TSDB_IRQ_PCI + TSDB_NR_IRQ_PCI; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &tsdb_pci_irq_controller;
+	}
+	for (i = TSDB_IRQ_IOC; i < TSDB_IRQ_IOC + TSDB_NR_IRQ_IOC; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &tsdb_ioc_irq_controller;
+	}
+	for (i = TSDB_IRQ_USC; i < TSDB_IRQ_USC + TSDB_NR_IRQ_USC; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &tsdb_usc_irq_controller;
+	}
+
+	setup_irq(TSDB_IRQ_LOCAL_PCI, &pci_action);
+	setup_irq(TSDB_IRQ_LOCAL_IOC, &ioc_action);
+	setup_irq(TSDB_IRQ_LOCAL_USC, &usc_action);
+
+	/* enable pushsw int. */
+	setup_irq(TSDB_IRQ_IOC_PUSHSW, &pushsw_action);
+
+#if 0	/* XXX */
+	/* enable ENUM int. */
+	if ((usc->int_stat & USC_INTF_INT3) == 0) {
+		setup_irq(TSDB_IRQ_PCI_ENUM, &enum_action);
+	}
+#endif
+
+	setup_irq(TSDB_IRQ_USC_PSLAVE_PI, &uscerr_action);
+	setup_irq(TSDB_IRQ_USC_PMASTER_PI, &uscerr_action);
+	setup_irq(TSDB_IRQ_USC_PCI_T_ABORT, &uscerr_action);
+	setup_irq(TSDB_IRQ_USC_PCI_M_ABORT, &uscerr_action);
+	setup_irq(TSDB_IRQ_USC_DRAM_PI, &uscerr_action);
+	
+	setup_irq(TSDB_IRQ_PCI_SERR, &pci_serr_action);
+	setup_irq(TSDB_IRQ_PCI_PERR, &pci_perr_action);
+
+#if 0
+	toshibaboards_gen_iack = tsdb_gen_iack;
+#endif
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/tsdb/pci.c linux-2.4.32-mct/arch/mips/mct-boards/tsdb/pci.c
--- linux-2.4.32/arch/mips/mct-boards/tsdb/pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/tsdb/pci.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,210 @@
+/* $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ *
+ * TOSHIBA SDB specific PCI support.
+ *
+ * based on arch/mips/sni/pci.c
+ * Copyright (C) 1997, 1998 Ralf Baechle
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1999-2001 Toshiba Corporation
+ */
+#include <linux/config.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <asm/toshiba-boards/tsdb.h>
+
+#ifdef CONFIG_PCI
+
+int tsdb_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq = pin;
+
+	/* IRQ rotation (see CompactPCI Specification) */
+	irq--;	/* 0-3 */
+	irq = (irq + 32 - slot) % 4;
+	irq++;	/* 1-4 */
+
+	switch (irq) {
+	case 1:
+		irq = TSDB_IRQ_PCI_INTA;
+		break;
+	case 2:
+		irq = TSDB_IRQ_PCI_INTB;
+		break;
+	case 3:
+		irq = TSDB_IRQ_PCI_INTC;
+		break;
+	case 4:
+		irq = TSDB_IRQ_PCI_INTD;
+		break;
+	}
+	return irq;
+}
+
+
+#define	TSDB_PCI_CONFIG_BASE	KSEG1ADDR(TSDB_LB_PCI_APERTURE_0)
+
+#ifdef __BIG_ENDIAN
+#define DO_AUTOSWAP
+#endif
+
+static struct v320usc_reg * const usc_reg = (struct v320usc_reg *)TSDB_USC_BASE;
+
+/* setup PCI Aperture 0 for Configuration Read/Write */
+static unsigned long
+config_begin(struct pci_dev *dev, int where,
+	     unsigned long *basep)
+{
+	unsigned long new_base;
+	unsigned long addr;
+
+	*basep = usc_reg->lb_pci_base[0];
+	new_base = USC_LB_PCI_BASE_BASE(TSDB_LB_PCI_APERTURE_0) |
+		USC_LB_PCI_BASE_PCI_CMD_CONFIG |
+#ifdef DO_AUTOSWAP
+		USC_LB_PCI_BASE_SWAP(USC_AUTOSWAP) |
+#else
+		USC_LB_PCI_BASE_SWAP(USC_NOSWAP) |
+#endif
+		USC_LB_PCI_BASE_SIZE_16M |
+		USC_LB_PCI_BASE_ERR_EN;
+	if (dev->bus->number == 0) {
+		unsigned long sel;
+		/* IDSEL pin of each board is connected to AD31:25 */
+		/* Additional PCI devices may use AD24:11 */
+		/* (see CompactPCI Specification) */
+		sel = PCI_SLOT(dev->devfn) ?
+			0x80000000UL >> (PCI_SLOT(dev->devfn) - 1): 0;
+		new_base |= USC_LB_PCI_BASE_MAP_ADR(sel) |
+			0x0 /* Type 0 */;
+		addr = TSDB_PCI_CONFIG_BASE +
+			((sel & 0xfff800) | ((dev->devfn & 0x07) << 0x08) | where);
+	} else {
+		new_base |= USC_LB_PCI_BASE_MAP_ADR(0) |
+			0x1 /* Type 1 */;
+		addr = TSDB_PCI_CONFIG_BASE +
+			((dev->bus->number << 0x10) | (dev->devfn << 0x08) | where);
+	}
+	usc_reg->lb_pci_base[0] = new_base;
+	/* clear M_ABORT */
+	usc_reg->pci_stat |= PCI_STATUS_REC_MASTER_ABORT;
+	usc_reg->int_stat |= USC_INTF_PCI_M_ABORT;
+	return addr;
+}
+static int
+config_end(unsigned long base)
+{
+	int abort = (usc_reg->pci_stat & PCI_STATUS_REC_MASTER_ABORT);
+	usc_reg->lb_pci_base[0] = base;
+	if (abort) {
+		usc_reg->pci_stat |= PCI_STATUS_REC_MASTER_ABORT;
+		usc_reg->int_stat |= USC_INTF_PCI_M_ABORT;
+		/* avoid spurious interrupt...(why?) */
+		*tsdb_fpga_rev_ptr = *tsdb_fpga_rev_ptr;
+		wbflush();
+	}
+	return abort;
+}
+
+static int tsdb_pci_read_config_byte(struct pci_dev *dev, int where,
+				     u8 *val)
+{
+	unsigned long base;
+
+	*val = *(volatile u8 *)config_begin(dev, where, &base);
+	if (config_end(base))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int tsdb_pci_read_config_word(struct pci_dev *dev, int where,
+				     u16 *val)
+{
+	u16 res;
+	unsigned long base;
+
+	res = *(volatile u16 *)config_begin(dev, where, &base);
+#ifndef DO_AUTOSWAP
+	res = le32_to_cpu(res);
+#endif
+	*val = res;
+	if (config_end(base))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int tsdb_pci_read_config_dword(struct pci_dev *dev, int where,
+				      u32 *val)
+{
+	u32 res;
+	unsigned long base;
+
+	res = *(volatile u32 *)config_begin(dev, where, &base);
+#ifndef DO_AUTOSWAP
+	res = le32_to_cpu(res);
+#endif
+	*val = res;
+	if (config_end(base))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int tsdb_pci_write_config_byte(struct pci_dev *dev, int where,
+				      u8 val)
+{
+	unsigned long base;
+
+	*(volatile u8 *)config_begin(dev, where, &base) = val;
+	if (config_end(base))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int tsdb_pci_write_config_word(struct pci_dev *dev, int where,
+				      u16 val)
+{
+	unsigned long base;
+
+#ifndef DO_AUTOSWAP
+	val = cpu_to_le16(val);
+#endif
+	*(volatile u16 *)config_begin(dev, where, &base) = val;
+	if (config_end(base))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int tsdb_pci_write_config_dword(struct pci_dev *dev, int where,
+				       u32 val)
+{
+	unsigned long base;
+
+#ifndef DO_AUTOSWAP
+	val = cpu_to_le32(val);
+#endif
+	*(volatile u32 *)config_begin(dev, where, &base) = val;
+	if (config_end(base))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops tsdb_pci_ops = {
+	read_byte:      tsdb_pci_read_config_byte,
+	read_word:      tsdb_pci_read_config_word,
+	read_dword:     tsdb_pci_read_config_dword,
+	write_byte:     tsdb_pci_write_config_byte,
+	write_word:     tsdb_pci_write_config_word,
+	write_dword:    tsdb_pci_write_config_dword
+};
+
+#endif /* CONFIG_PCI */
diff -Naru linux-2.4.32/arch/mips/mct-boards/tsdb/prom.c linux-2.4.32-mct/arch/mips/mct-boards/tsdb/prom.c
--- linux-2.4.32/arch/mips/mct-boards/tsdb/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/tsdb/prom.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,40 @@
+/*
+ *  linux/arch/mips/toshiba-boards/tsdb/prom.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1999-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <asm/mipsregs.h>
+#include <asm/cpu.h>
+#include <asm/toshiba-boards/pmon.h>
+#include <asm/toshiba-boards/tsdb.h>
+
+#ifdef CONFIG_CPU_TX49XX
+extern int mips_configk0;
+#endif
+extern int mips_config_cwfon;
+
+int __init tsdb_prom_init(int argc, char *argv[])
+{
+	if (argc == -1)
+		return 0;
+#if defined(CONFIG_CPU_TX49XX)
+	/* TSDB-BUG: Kernel space must be uncached. (V320USC R4300 mode bug) */
+	if ((mips_cpu.processor_id & 0xff00) == PRID_IMP_R4300)
+		mips_configk0 = CONF_CM_UNCACHED;
+#endif
+#if 1	/* XXX ? */
+	mips_config_cwfon = 0;
+#endif
+
+	return 0;
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/tsdb/rtc.c linux-2.4.32-mct/arch/mips/mct-boards/tsdb/rtc.c
--- linux-2.4.32/arch/mips/mct-boards/tsdb/rtc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/tsdb/rtc.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,45 @@
+/*
+ *  linux/arch/mips/toshiba-boards/tsdb/rtc.c
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ *
+ * RTC routines for Dallas chip.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1999-2001 Toshiba Corporation
+ */
+#include <linux/kernel.h>
+#include <asm/mc146818rtc.h>	/* bad name... */
+#include <asm/byteorder.h>
+#include <asm/toshiba-boards/tsdb.h>
+
+static unsigned char tsdb_rtc_read_data(unsigned long addr)
+{
+#ifdef	__BIG_ENDIAN
+	return *(tsdb_bramrtc_ptr + (addr^3));
+#else
+	return *(tsdb_bramrtc_ptr + (addr));
+#endif
+}
+
+static void tsdb_rtc_write_data(unsigned char data, unsigned long addr)
+{
+#ifdef	__BIG_ENDIAN
+	*(tsdb_bramrtc_ptr + (addr^3)) = data;
+#else
+	*(tsdb_bramrtc_ptr + (addr)) = data;
+#endif
+}
+
+static int tsdb_rtc_bcd_mode(void)
+{
+	return 1;
+}
+
+struct rtc_ops tsdb_rtc_ops = {
+	&tsdb_rtc_read_data,
+	&tsdb_rtc_write_data,
+	&tsdb_rtc_bcd_mode
+};
diff -Naru linux-2.4.32/arch/mips/mct-boards/tsdb/setup.c linux-2.4.32-mct/arch/mips/mct-boards/tsdb/setup.c
--- linux-2.4.32/arch/mips/mct-boards/tsdb/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/tsdb/setup.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,464 @@
+/*
+ * linux/arch/mips/toshiba-boards/tsdb/setup.c
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ *
+ * Setup pointers to hardware-dependent routines.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1999-2001 Toshiba Corporation
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/kdev_t.h>
+#include <linux/parport.h>
+#include <linux/pci.h>
+#include <asm/system.h>
+#include <asm/param.h>
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/toshiba-boards/pmon.h>
+#include <asm/toshiba-boards/pci.h>
+#include <asm/toshiba-boards/tsdb.h>
+#include <asm/mc146818rtc.h>	/* bad name... */
+#include <asm/ns87338.h>
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/pci.h>
+#include <asm/time.h>
+#if defined(CONFIG_SERIAL)
+#include <linux/serial.h>
+#include <asm/serial.h>
+#endif
+
+extern struct rtc_ops tsdb_rtc_ops;
+extern struct pci_ops tsdb_pci_ops;
+extern int tsdb_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin);
+extern void tsdb_irq_setup(void) __init;
+extern void tsdb_time_init(void) __init;
+extern void tsdb_timer_setup(struct irqaction *irq) __init;
+extern int mips_parport_base;
+extern int mips_parport_irq;
+
+#ifdef CONFIG_REMOTE_DEBUG
+extern int __init early_serial_kgdb_setup(struct serial_struct *req);
+extern void breakpoint(void);
+#define TOMON(s) printk(s); breakpoint()
+#else
+#define TOMON(s) pmon_printf(s); pmon_halt()
+#endif
+extern void wait_for_keypress(void);
+
+static void tsdb_machine_restart(char *command)
+{
+	cli();
+	printk("Rebooting...");
+	*tsdb_softreset_ptr = 0;
+}
+
+static void tsdb_machine_halt(void)
+{
+	cli();
+	printk("Press any key to reboot.\n");
+	wait_for_keypress();
+	*tsdb_softreset_ptr = 0;
+}
+
+static void tsdb_machine_power_off(void)
+{
+	cli();
+	printk("Press any key to reboot.\n");
+	wait_for_keypress();
+	*tsdb_softreset_ptr = 0;
+}
+
+/* utility routines for LED Display */
+void tsdb_leddisp_puts(const char *s)
+{
+	int i;
+	for (i = 0; i < 8; i++) {
+		char c;
+		if (*s)
+			c = *s++;
+		else
+			c = ' ';
+		tsdb_leddisp_putc(i, c);
+	}
+}
+void tsdb_leddisp_put(unsigned long val)
+{
+	int i;
+	for (i = 7; i >= 0; i--) {
+		unsigned char v = val & 0x0f;
+		char c = v < 10 ? (v + '0') : (v - 10 + 'A');
+		tsdb_leddisp_putc(i, c);
+		val >>= 4;
+	}
+}
+
+#ifdef __BIG_ENDIAN
+#undef DO_AUTOSWAP
+#endif
+
+static void __init tsdb_usc_setup(void)
+{
+	struct v320usc_reg * const usc_reg = (struct v320usc_reg *)TSDB_USC_BASE;
+	int sdram_adbits = TSDB_SDRAM_APERTURE_ADBITS;
+
+	/* set sdram_adbits as large as possible to cache BusWatch Timeout */
+	while (((0xffffffff << (32 - sdram_adbits)) &
+		(PHYSADDR(toshibaboards_memory_upper) - 1))
+	       == 0)
+		sdram_adbits++;
+	/* MINIMUM 64M */
+	if (sdram_adbits > 6)
+		sdram_adbits = 6;
+
+	usc_reg->int_cfg[0] = 0;
+	usc_reg->int_cfg[1] = 0;
+	usc_reg->int_cfg[2] = 0;
+	usc_reg->int_cfg3 = 0;
+
+	/* Setup REG Aperture */
+	if (usc_reg->lb_reg_base !=
+	    USC_LB_REG_BASE_BASE(TSDB_LB_USCREG_APERTURE)) {
+		printk("PCI setup: LB_REG_BASE mismatch.\n");
+		return;
+	}
+	usc_reg->pci_reg_base = TSDB_PCI_USCREG_APERTURE; /* disabled */
+	/* Setup RAM Aperture */
+	if ((usc_reg->lb_dram_base & USC_LB_DRAM_BASE_BASE_MASK) !=
+	    USC_LB_DRAM_BASE_BASE(TSDB_LB_SDRAM_APERTURE)) {
+		printk("PCI setup: LB_SDRAM_BASE mismatch.\n");
+		return;
+	}
+	usc_reg->lb_dram_base = USC_LB_DRAM_BASE_BASE(TSDB_LB_SDRAM_APERTURE) |
+		USC_LB_DRAM_BASE_SIZE(sdram_adbits) |
+		USC_LB_DRAM_BASE_ENABLE;
+	usc_reg->pci_mem_base = TSDB_PCI_SDRAM_APERTURE |
+		PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32 |
+		PCI_BASE_ADDRESS_MEM_PREFETCH;
+	usc_reg->pci_mem_map = USC_PCI_MEM_MAP_MAP_ADR(TSDB_LB_SDRAM_APERTURE) |
+		USC_PCI_MEM_MAP_SIZE(sdram_adbits) |
+#ifdef __BIG_ENDIAN
+		USC_PCI_MEM_MAP_SWAP(USC_SWAP8) |
+#else
+		USC_PCI_MEM_MAP_SWAP(USC_NOSWAP) |
+#endif
+		USC_PCI_MEM_MAP_REG_EN |
+		USC_PCI_MEM_MAP_ENABLE;
+	/* Setup PCI Aperture 0 (for I/O Space) */
+	usc_reg->lb_pci_base[0] =
+		USC_LB_PCI_BASE_BASE(TSDB_LB_PCI_APERTURE_0) |
+		USC_LB_PCI_BASE_MAP_ADR(TSDB_PCI_PCI_APERTURE_0) |
+		USC_LB_PCI_BASE_PCI_CMD_IO |
+#ifdef __BIG_ENDIAN
+#ifdef DO_AUTOSWAP
+		USC_LB_PCI_BASE_SWAP(USC_AUTOSWAP) |
+#else
+		USC_LB_PCI_BASE_SWAP(USC_SWAP8) |
+#endif
+#else
+		USC_LB_PCI_BASE_SWAP(USC_NOSWAP) |
+#endif
+		USC_LB_PCI_BASE_SIZE(TSDB_PCI_APERTURE_0_ADBITS) |
+		USC_LB_PCI_BASE_ERR_EN;
+	/* Setup PCI Aperture 1 (for Memory Space) */
+	usc_reg->lb_pci_base[1] =
+		USC_LB_PCI_BASE_BASE(TSDB_LB_PCI_APERTURE_1) |
+		USC_LB_PCI_BASE_MAP_ADR(TSDB_PCI_PCI_APERTURE_1) |
+#if 1
+		/* Do not use MEMMUL, MEMINF: YMFPCI card causes M_ABORT. */
+		USC_LB_PCI_BASE_PCI_CMD_MEM |
+#else
+		USC_LB_PCI_BASE_PCI_CMD_MEMINV |
+#endif
+#ifdef __BIG_ENDIAN
+#ifdef DO_AUTOSWAP
+		USC_LB_PCI_BASE_SWAP(USC_AUTOSWAP) |
+#else
+		USC_LB_PCI_BASE_SWAP(USC_SWAP8) |
+#endif
+#else
+		USC_LB_PCI_BASE_SWAP(USC_NOSWAP) |
+#endif
+		USC_LB_PCI_BASE_SIZE(TSDB_PCI_APERTURE_1_ADBITS) |
+		USC_LB_PCI_BASE_ERR_EN;
+	/* Setup PCU Aperture */
+	usc_reg->lb_pcu_base = USC_LB_PCU_BASE_BASE(TSDB_LB_PCU_APERTURE) |
+		USC_LB_PCU_BASE_SIZE(TSDB_PCU_APERTURE_ADBITS) |
+		USC_LB_PCU_BASE_ENABLE;
+	usc_reg->pci_pcu_base = PCI_PCU_ADDRESS_SIZE_DISABLED;
+	/* Setup ROM Aperture */
+	usc_reg->lb_rom_base = USC_LB_ROM_BASE_BASE(TSDB_LB_ROM_APERTURE) |
+		USC_LB_ROM_BASE_SIZE(TSDB_ROM_APERTURE_ADBITS) |
+		USC_LB_ROM_BASE_WE;
+	usc_reg->pci_rom_base = PCI_ROM_ADDRESS_SIZE_DISABLED;
+
+	/* Enable Bus Watch Timeout and SDRAM Parity Error */
+	usc_reg->lb_bus_cfg |= USC_LB_BUS_CFG_BW_TC_MASK;
+	usc_reg->lb_bus_cfg |= USC_LB_BUS_CFG_ERR_EN | USC_LB_BUS_CFG_MERR_EN;
+
+	usc_reg->pci_bus_cfg = USC_PCI_BUS_CFG_FAST_SCL |
+#ifdef __BIG_ENDIAN
+#ifdef DO_AUTOSWAP
+		USC_PCI_BUS_CFG_PCU_SWAP(USC_AUTOSWAP) |
+#else
+		USC_PCI_BUS_CFG_PCU_SWAP(USC_SWAP8) |
+#endif
+#else
+		USC_PCI_BUS_CFG_PCU_SWAP(USC_NOSWAP) |
+#endif
+#if 1 /* XXX PCI */
+		USC_PCI_BUS_CFG_RBRST_MAX_256	/* burst support (256 words) */
+#else
+		USC_PCI_BUS_CFG_RBRST_MAX_4
+#endif
+		;
+
+	usc_reg->pci_cmd |=
+		PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+#if 1 /* XXX PCI */
+	usc_reg->pci_cmd |= PCI_COMMAND_INVALIDATE;
+#endif
+	usc_reg->pci_cmd |=
+		PCI_COMMAND_PARITY | PCI_COMMAND_SERR;
+
+	/* set USC heartbeat constant (XXX MasterClock 66MHz) */
+	usc_reg->wd_hbi = (66*1000*1000 / 4096 / HZ) << USC_HB_TC_SHIFT;
+
+	if (mips_cpu.cputype == CPU_TX39XX) {
+		int mclk = 8250000;	/* perhaps MasterClock is 08MHz... */
+		if ((mips_cpu.processor_id & 0xffff) == (PRID_IMP_TX39 | 0x0050)) {
+			/* TX39H3 */
+			switch (*tsdb_dipsw2_ptr & TSDB_DIPSW2_CLOCK_MASK) {
+			case TSDB_DIPSW2_CLOCK_4:	/* 1:1 */
+				mclk = 33000000;	/* 33MHz */
+				break;
+			case TSDB_DIPSW2_CLOCK_2_5:	/* 1:2 */
+				mclk = 16500000;	/* 16.5MHz */
+				break;
+			case TSDB_DIPSW2_CLOCK_2:	/* 1:3 */
+				mclk = 11000000;	/* 11MHz */
+				break;
+			case TSDB_DIPSW2_CLOCK_3:	/* 1:4 */
+				mclk = 8250000;		/* 8.25MHz */
+				break;
+			}
+		}
+		usc_reg->wd_hbi = (mclk / 4096 / HZ) << USC_HB_TC_SHIFT;
+	}
+#if 0 /* XXX */
+	switch (*tsdb_dipsw2_ptr & TSDB_DIPSW2_CLOCK_MASK) {
+	case TSDB_DIPSW2_CLOCK_4:
+	case TSDB_DIPSW2_CLOCK_3:
+		/* XXX perhaps MasterClock is 33MHz... */
+		usc_reg->wd_hbi = (33*1000*1000 / 4096 / HZ) << USC_HB_TC_SHIFT;
+		break;
+	}
+#endif
+
+#if 1
+	/* Lock USC */
+	usc_reg->system |= USC_SYSTEM_LOCK | USC_SYSTEM_CFG_LOCK;
+#endif
+}
+
+#ifdef CONFIG_HAVE_BOARD_IO_FUNCS
+#ifdef __LITTLE_ENDIAN
+/* for Little Endian, we can use standard IO macros. */
+#warning using CONFIG_HAVE_BOARD_IO_FUNCS in LittleEndian
+#endif
+static struct mips_io_funcs saved_io_funcs;
+#define IS_PCU_PORT(port) \
+	((PHYSADDR(mips_io_port_base + (port)) & ~(0xffffffff >> TSDB_PCU_APERTURE_ADBITS)) == TSDB_LB_PCU_APERTURE)
+/* We may be able to use AUTP-SWAP features on USC... (but currently don't) */
+/* Note: do not use read[bwl]/write[bwl] for PCU.. */
+static void tsdb_outb(unsigned int value, unsigned long port) {
+#ifdef __BIG_ENDIAN
+	if (IS_PCU_PORT(port))
+		port ^= 3;
+#endif
+	(*saved_io_funcs.outb)(value, port);
+}
+static void tsdb_outw(unsigned int value, unsigned long port) {
+#ifdef __BIG_ENDIAN
+	if (IS_PCU_PORT(port))
+		port ^= 2;
+#endif
+	(*saved_io_funcs.outw)(value, port);
+}
+static unsigned char tsdb_inb(unsigned long port) {
+#ifdef __BIG_ENDIAN
+	if (IS_PCU_PORT(port))
+		port ^= 3;
+#endif
+	return (*saved_io_funcs.inb)(port);
+}
+static unsigned short tsdb_inw(unsigned long port) {
+#ifdef __BIG_ENDIAN
+	if (IS_PCU_PORT(port))
+		port ^= 2;
+#endif
+	return (*saved_io_funcs.inw)(port);
+}
+static void tsdb_outsb(unsigned long port, const void *addr, unsigned int count) {
+#ifdef __BIG_ENDIAN
+	if (IS_PCU_PORT(port))
+		port ^= 3;
+#endif
+	(*saved_io_funcs.outsb)(port, addr, count);
+}
+static void tsdb_outsw(unsigned long port, const void *addr, unsigned int count) {
+#ifdef __BIG_ENDIAN
+	if (IS_PCU_PORT(port))
+		port ^= 2;
+#endif
+	(*saved_io_funcs.outsw)(port, addr, count);
+}
+static void tsdb_insb(unsigned long port, void *addr, unsigned int count) {
+#ifdef __BIG_ENDIAN
+	if (IS_PCU_PORT(port))
+		port ^= 3;
+#endif
+	(*saved_io_funcs.insb)(port, addr, count);
+}
+static void tsdb_insw(unsigned long port, void *addr, unsigned int count) {
+#ifdef __BIG_ENDIAN
+	if (IS_PCU_PORT(port))
+		port ^= 3;
+#endif
+	(*saved_io_funcs.insw)(port, addr, count);
+}
+#endif /* CONFIG_HAVE_BOARD_IO_FUNCS */
+
+void __init tsdb_setup(void)
+{
+	struct v320usc_reg *usc = (struct v320usc_reg *)TSDB_USC_BASE;
+#if defined(CONFIG_SERIAL)
+	int i;
+	struct serial_struct req;
+#endif
+	unsigned long spio_config;
+
+	toshibaboards_pci_io_resource.start = 0;
+	toshibaboards_pci_io_resource.end = (1 << (32 - TSDB_PCI_APERTURE_0_ADBITS)) - 1;
+	toshibaboards_pci_mem_resource.start = TSDB_LB_PCI_APERTURE_1;
+	toshibaboards_pci_mem_resource.end = TSDB_LB_PCI_APERTURE_1 +
+		(1 << (32 - TSDB_PCI_APERTURE_1_ADBITS)) - 1;
+
+	tsdb_usc_setup();
+
+	board_time_init = tsdb_time_init;
+	board_timer_setup = tsdb_timer_setup;
+	irq_setup = tsdb_irq_setup;
+	/* map ioport 0 to PCI I/O space address 0 */
+	set_io_port_base(KSEG1ADDR(TSDB_LB_PCI_APERTURE_0));
+
+#ifdef CONFIG_HAVE_BOARD_IO_FUNCS
+	saved_io_funcs = mips_io_funcs;
+	mips_io_funcs.outb = tsdb_outb;
+	mips_io_funcs.outw = tsdb_outw;
+	mips_io_funcs.inb = tsdb_inb;
+	mips_io_funcs.inw = tsdb_inw;
+	mips_io_funcs.outsb = tsdb_outsb;
+	mips_io_funcs.outsw = tsdb_outsw;
+	mips_io_funcs.insb = tsdb_insb;
+	mips_io_funcs.insw = tsdb_insw;
+#endif /* CONFIG_HAVE_BOARD_IO_FUNCS */
+
+	/* disable all OnBoard I/O interrupts */
+	*tsdb_ioc_imask_ptr = 0;
+	*tsdb_pci_imask_ptr = 0;
+
+	_machine_restart = tsdb_machine_restart;
+	_machine_halt = tsdb_machine_halt;
+	_machine_power_off = tsdb_machine_power_off;
+
+	rtc_ops = &tsdb_rtc_ops;
+
+	if (*tsdb_dipsw2_ptr & TSDB_DIPSW2_BUSE) {
+		toshibaboards_pci_ops = &tsdb_pci_ops;
+		toshibaboards_pci_map_irq = tsdb_pci_map_irq;
+	}
+
+	/* Enable Parallel Port (XXX done by Monitor?) */
+	spio_config = TSDB_SUPERIO_CONFIG - mips_io_port_base;
+	ns87338_writeb(spio_config, FER,
+		       ns87338_readb(spio_config, FER) | FER_LPT);
+	ns87338_writeb(spio_config, FAR,
+		       (ns87338_readb(spio_config, FAR) & ~FAR_LPT_MASK) | FAR_LPTB);
+
+	*tsdb_led_ptr = 0xff;
+	tsdb_leddisp_puts("SDB rev");
+	tsdb_leddisp_putc(7, *tsdb_board_rev_ptr + '0');
+	printk("TOSHIBA SDB (Rev %d) --- FPGA(Rev %d) USC(Dev %04x Rev %04x) SuperIO(ID %x) DIPSW:%02x,%02x\n",
+	       *tsdb_board_rev_ptr, *tsdb_fpga_rev_ptr,
+	       usc->pci_device, usc->pci_cc_rev.rev,
+	       ns87338_readb(spio_config, SID),
+	       *tsdb_dipsw1_ptr, *tsdb_dipsw2_ptr);
+
+#if defined(CONFIG_SERIAL)
+	/* loop until early_serial_setup() returns error. */
+	for(i = 0; ; i++) {
+		memset(&req, 0, sizeof(struct serial_struct));
+		req.line = i;
+		if (i < 2) {
+			unsigned long base =
+				(i == 0) ? TSDB_UART0_BASE : TSDB_UART1_BASE;
+			req.baud_base = TSDB_BASE_BAUD;
+			req.port = base - mips_io_port_base;
+			req.irq = TSDB_IRQ_IOC_UART(i);
+			req.flags = STD_COM_FLAGS;
+			req.io_type = SERIAL_IO_PORT;
+			req.type = PORT_16550A;
+		}
+		if (early_serial_setup(&req))
+			break;
+#ifdef CONFIG_REMOTE_DEBUG
+		early_serial_kgdb_setup(&req);
+#endif
+	}
+#endif
+
+	if (ns87338_readb(spio_config, SID) != 0xff) {
+		unsigned long tmp;
+		mips_parport_base = TSDB_LPT_ADDR - mips_io_port_base;
+		mips_parport_irq = TSDB_IRQ_IOC_PAR;
+		/* TSDB-BUG: SDB always assert INT signal if we mask parport interrupt
+		   by setting zero to bit4 of Control Register. */
+		if (!(*tsdb_ioc_istat_ptr & TSDB_INTF_IOC_PAR))
+			mips_parport_irq = PARPORT_IRQ_NONE;
+
+		/* Enable ECP mode, set bit 2 of the CTR first */
+		outb(0x04, mips_parport_base + 2);
+		tmp = ns87338_readb(spio_config, PCR);
+#if 0
+		tmp |= PCR_EPP_ENABLE;
+#endif
+		tmp |= (PCR_EPP_IEEE | PCR_ECP_ENABLE | PCR_ECP_CLK_ENA);
+		ns87338_writeb(spio_config, PCR, tmp);
+
+		/* LPT CTR bit 5 controls direction of parallel port */
+		tmp = ns87338_readb(spio_config, PTR);
+		tmp |= PTR_LPT_REG_DIR;
+		ns87338_writeb(spio_config, PTR, tmp);
+
+		/* Configure IRQ to Push Pull, Level Low */
+		tmp = ns87338_readb(spio_config, PCR);
+		tmp &= ~(PCR_IRQ_ODRAIN);
+		tmp |= PCR_IRQ_POLAR;
+		ns87338_writeb(spio_config, PCR, tmp);
+
+		/* Enable Zero Wait State for ECP */
+		tmp = ns87338_readb(spio_config, FCR);
+		tmp |= FCR_ZWS_ENA;
+		ns87338_writeb(spio_config, FCR, tmp);
+	}
+}
diff -Naru linux-2.4.32/arch/mips/mct-boards/tsdb/time.c linux-2.4.32-mct/arch/mips/mct-boards/tsdb/time.c
--- linux-2.4.32/arch/mips/mct-boards/tsdb/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/mct-boards/tsdb/time.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,105 @@
+/*
+ *  linux/arch/mips/toshiba-boards/tsdb/time.c
+ *
+ * Copyright (C) 1999-2001 Toshiba Corporation
+ *
+ * $Id: linux-2.4.31-mct.diff,v 1.1.1.1 2005/10/04 20:57:53 andi Exp $
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/cpu.h>
+#include <asm/time.h>
+
+#include <asm/toshiba-boards/tsdb.h>
+
+#if 1	/* XXX */
+int tsdb_timer_led = 0;
+#endif
+
+static void
+tsdb_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	timer_interrupt(irq, dev_id, regs);
+
+#if 1	/* XXX blink led */
+	if (tsdb_timer_led && jiffies % HZ == 0)
+		tsdb_led_toggle(0);
+#endif
+}
+
+
+/* We use onchip r4k counter or USC timer as our system wide timer interrupt running at 100HZ. */
+int tsdb_use_ext_timer = 0;
+
+extern void rtc_ds1742_init(void);
+extern void rtc_ds1553_init(void);
+
+void __init tsdb_time_init(void)
+{
+	unsigned int ct0;
+	struct v320usc_reg *usc = (struct v320usc_reg *)TSDB_USC_BASE;
+	int i;
+
+	if (mips_cpu.cputype == CPU_TX39XX)
+		tsdb_use_ext_timer = 1;
+
+	if (tsdb_old_rtc()) {
+		rtc_ds1742_init();
+	} else {
+		rtc_ds1553_init();
+	}
+
+	printk("calculating counter_frequency... ");
+
+	/* clear HeartBeat Int. */
+	usc->int_stat = USC_INTF_HBI;
+	/* waiting for a new tick. */
+	while (!(usc->int_stat & USC_INTF_HBI))
+		;
+	ct0 = read_32bit_cp0_register(CP0_COUNT);
+	for (i = 0; i < 16; i++) {
+		/* clear HeartBeat Int. */
+		usc->int_stat = USC_INTF_HBI;
+		/* waiting for a next tick. */
+		while (!(usc->int_stat & USC_INTF_HBI))
+			;
+	}
+	mips_counter_frequency =
+		(read_32bit_cp0_register(CP0_COUNT) - ct0) / 16 * HZ;
+}
+
+extern int setup_irq(unsigned int irq, struct irqaction *irqaction);
+void __init tsdb_timer_setup(struct irqaction *irq)
+{
+	/* wrap default timer interupt handler */
+	irq->handler = tsdb_timer_interrupt;
+
+	if (tsdb_use_ext_timer) {
+		/* disable counter interrupt(IM7) */
+		clear_cp0_status(STATUSF_IP7);
+
+		/* enable USC heartbeat interrupt */
+		setup_irq(TSDB_IRQ_USC_HBI, irq);
+	} else {
+		unsigned int count;
+
+		/* we are using the cpu counter for timer interrupts */
+		setup_irq(TSDB_IRQ_LOCAL_TIMER, irq);
+
+		/* to generate the first timer interrupt */
+		count = read_32bit_cp0_register(CP0_COUNT);
+		write_32bit_cp0_register(CP0_COMPARE, count + mips_counter_frequency / HZ);
+	}
+	printk("%08x(%d)\n", mips_counter_frequency, mips_counter_frequency);
+}
diff -Naru linux-2.4.32/arch/mips/pci/pci.c linux-2.4.32-mct/arch/mips/pci/pci.c
--- linux-2.4.32/arch/mips/pci/pci.c	2005-01-19 15:09:29.000000000 +0100
+++ linux-2.4.32-mct/arch/mips/pci/pci.c	2006-12-02 15:08:43.000000000 +0100
@@ -12,6 +12,7 @@
 
 #include <asm/pci_channel.h>
 
+#ifndef CONFIG_MCT_BOARDS
 void
 pcibios_update_resource(struct pci_dev *dev, struct resource *root,
 			struct resource *res, int resource)
@@ -66,6 +67,7 @@
 		}
 	}
 }
+#endif
 
 /*
  *  If we set up a device for bus mastering, we need to check the latency
@@ -87,10 +89,12 @@
 	pci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);
 }
 
+#ifndef CONFIG_MCT_BOARDS
 char * __devinit pcibios_setup(char *str)
 {
 	return str;
 }
+#endif
 
 static int pcibios_enable_resources(struct pci_dev *dev, int mask)
 {
@@ -124,10 +128,12 @@
 	return 0;
 }
 
+#ifndef CONFIG_MCT_BOARDS
 int pcibios_enable_device(struct pci_dev *dev, int mask)
 {
 	return pcibios_enable_resources(dev, mask);
 }
+#endif
 
 #ifdef CONFIG_PCI_NEW
 /*
diff -Naru linux-2.4.32/drivers/char/Config.in linux-2.4.32-mct/drivers/char/Config.in
--- linux-2.4.32/drivers/char/Config.in	2004-08-08 01:26:04.000000000 +0200
+++ linux-2.4.32-mct/drivers/char/Config.in	2006-12-02 15:08:43.000000000 +0100
@@ -104,6 +104,8 @@
       if [ "$CONFIG_TXX927_SERIAL" = "y" ]; then
          bool '    TXx927 SIO Console support' CONFIG_TXX927_SERIAL_CONSOLE  
       fi                             
+      bool '  TMPTXx927 serial port support' CONFIG_SERIAL_TXX927
+      dep_bool '     Console on TMPTXx927 serial port' CONFIG_SERIAL_TXX927_CONSOLE $CONFIG_SERIAL_TXX927
       if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
          bool '  Support for BCM1xxx onchip DUART' CONFIG_SIBYTE_SB1250_DUART
          if [ "$CONFIG_SIBYTE_SB1250_DUART" = "y" ]; then
diff -Naru linux-2.4.32/drivers/char/Makefile linux-2.4.32-mct/drivers/char/Makefile
--- linux-2.4.32/drivers/char/Makefile	2004-08-08 01:26:04.000000000 +0200
+++ linux-2.4.32-mct/drivers/char/Makefile	2006-12-02 15:08:43.000000000 +0100
@@ -217,6 +217,7 @@
 obj-$(CONFIG_HVC_CONSOLE) += hvc_console.o
 obj-$(CONFIG_SERIAL_TX3912) += generic_serial.o serial_tx3912.o
 obj-$(CONFIG_TXX927_SERIAL) += serial_txx927.o
+obj-$(CONFIG_SERIAL_TXX927) += generic_serial.o serial_mct_txx927.o
 obj-$(CONFIG_SERIAL_TXX9) += generic_serial.o serial_txx9.o
 obj-$(CONFIG_IP22_SERIAL) += sgiserial.o
 obj-$(CONFIG_AU1X00_UART) += au1x00-serial.o
diff -Naru linux-2.4.32/drivers/char/serial_mct_txx927.c linux-2.4.32-mct/drivers/char/serial_mct_txx927.c
--- linux-2.4.32/drivers/char/serial_mct_txx927.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/drivers/char/serial_mct_txx927.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,1349 @@
+/*
+ *  drivers/char/serial_txx927.c
+ *
+ *  Copyright (C) 1999 Harald Koerfgen
+ *  Copyright (C) 2000 Jim Pick <jim@jimpick.com>
+ *  Copyright (C) 2001 Steven J. Hill (sjhill@realitydiluted.com)
+ *  Copyright (C) 2000-2001 Toshiba Corporation
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *  
+ *  Serial driver for TX3927/TX4927 processors
+ */
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/tty.h>
+#include <linux/major.h>
+#include <linux/ptrace.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <asm/wbflush.h>
+#include <asm/txx927.h>
+#include <asm/serial_txx927.h>
+#include <linux/serial.h>
+#include <linux/generic_serial.h>
+#ifdef CONFIG_MAGIC_SYSRQ
+#include <linux/sysrq.h>
+#endif
+
+static char *serial_version = "0.21";
+static char *serial_name = "TXx927 Serial driver";
+
+#define GS_INTERNAL_FLAGS (GS_TX_INTEN|GS_RX_INTEN|GS_ACTIVE)
+
+#define TXX927_SERIAL_MAGIC 0x39274927
+
+#ifdef CONFIG_SERIAL
+/* "ttyS","cua" is used for standard serial driver */
+#define TXX927_TTY_NAME "ttySC"
+#define TXX927_TTY_DEVFS_NAME "ttsc/%d"
+#define TXX927_TTY_MINOR_START	(64 + 64)	/* ttySC0(128), ttySC1(129) */
+#define TXX927_CU_NAME "cuac"
+#define TXX927_CU_DEVFS_NAME "cuac/%d"
+#else
+/* acts like standard serial driver */
+#define TXX927_TTY_NAME "ttyS"
+#define TXX927_TTY_DEVFS_NAME "tts/%d"
+#define TXX927_TTY_MINOR_START	64
+#define TXX927_CU_NAME "cua"
+#define TXX927_CU_DEVFS_NAME "cua/%d"
+#endif
+#define TXX927_TTY_MAJOR	TTY_MAJOR
+#define TXX927_TTYAUX_MAJOR	TTYAUX_MAJOR
+
+/*
+ * Number of serial ports
+ */
+#define NR_PORTS  2
+
+/*
+ * Hardware specific serial port structure
+ */
+static struct rs_port { 	
+	struct gs_port		gs;		/* Must be first field! */
+
+	unsigned long		base;
+	int			irq;
+	int			baud_base;
+	int			flags;
+        struct async_icount	icount;
+	int			x_char;		/* XON/XOFF character */
+	int			read_status_mask;
+	int			ignore_status_mask;
+	int			quot;
+} rs_ports[NR_PORTS]; 
+
+static inline struct txx927_sio_reg *sio_reg(struct rs_port *port)
+{
+	return (struct txx927_sio_reg *)port->base;
+}
+
+/*
+ * Forward declarations for serial routines
+ */
+static void rs_disable_tx_interrupts (void * ptr);
+static void rs_enable_tx_interrupts (void * ptr); 
+static void rs_disable_rx_interrupts (void * ptr); 
+static void rs_enable_rx_interrupts (void * ptr); 
+static int rs_get_CD (void * ptr); 
+static void rs_shutdown_port (void * ptr); 
+static int rs_set_real_termios (void *ptr);
+static int rs_chars_in_buffer (void * ptr); 
+static void rs_hungup (void *ptr);
+static void rs_close (void *ptr);
+
+/*
+ * Used by generic serial driver to access hardware
+ */
+static struct real_driver rs_real_driver = { 
+	disable_tx_interrupts: rs_disable_tx_interrupts, 
+	enable_tx_interrupts:  rs_enable_tx_interrupts, 
+	disable_rx_interrupts: rs_disable_rx_interrupts, 
+	enable_rx_interrupts:  rs_enable_rx_interrupts, 
+	get_CD:                rs_get_CD, 
+	shutdown_port:         rs_shutdown_port,  
+	set_real_termios:      rs_set_real_termios,  
+	chars_in_buffer:       rs_chars_in_buffer, 
+	close:                 rs_close, 
+	hungup:                rs_hungup,
+}; 
+
+/*
+ * Structures and such for TTY sessions and usage counts
+ */
+static struct tty_driver rs_driver, rs_callout_driver;
+static struct tty_struct *rs_table[NR_PORTS];
+static struct termios *rs_termios[NR_PORTS];
+static struct termios *rs_termios_locked[NR_PORTS];
+int rs_refcount;
+int rs_initialized = 0;
+
+#ifdef CONFIG_SERIAL_TXX927_CONSOLE
+static struct console sercons;
+#endif
+#if defined(CONFIG_SERIAL_TXX927_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+static unsigned long break_pressed; /* break, really ... */
+#endif
+
+static inline void receive_chars(struct rs_port *port,
+				 int *status, struct pt_regs *regs)
+{
+	struct tty_struct *tty = port->gs.tty;
+	unsigned char ch;
+	struct	async_icount *icount;
+	int	max_count = 256;
+
+	icount = &port->icount;
+	do {
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+			tty->flip.tqueue.routine((void *) tty);
+			if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+				return;		// if TTY_DONT_FLIP is set
+		}
+		ch = sio_reg(port)->rfifo;
+		*tty->flip.char_buf_ptr = ch;
+		icount->rx++;
+		
+		*tty->flip.flag_buf_ptr = 0;
+		if (*status & (TXx927_SIDISR_UBRK | TXx927_SIDISR_UPER |
+			       TXx927_SIDISR_UFER | TXx927_SIDISR_UOER)) {
+			/*
+			 * For statistics only
+			 */
+			if (*status & TXx927_SIDISR_UBRK) {
+				*status &= ~(TXx927_SIDISR_UFER | TXx927_SIDISR_UPER);
+				icount->brk++;
+				/*
+				 * We do the SysRQ and SAK checking
+				 * here because otherwise the break
+				 * may get masked by ignore_status_mask
+				 * or read_status_mask.
+				 */
+#if defined(CONFIG_SERIAL_TXX927_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+				if (port == &rs_ports[sercons.index]) {
+					if (!break_pressed) {
+						break_pressed = jiffies;
+						goto ignore_char;
+					}
+					break_pressed = 0;
+				}
+#endif
+				if (port->gs.flags & ASYNC_SAK)
+					do_SAK(tty);
+			} else if (*status & TXx927_SIDISR_UPER)
+				icount->parity++;
+			else if (*status & TXx927_SIDISR_UFER)
+				icount->frame++;
+			if (*status & TXx927_SIDISR_UOER)
+				icount->overrun++;
+
+			/*
+			 * Mask off conditions which should be ignored.
+			 */
+			*status &= port->read_status_mask;
+		
+#ifdef CONFIG_SERIAL_TXX927_CONSOLE
+			/* Break flag is updated by reading RFIFO. */
+#endif
+			if (*status & (TXx927_SIDISR_UBRK)) {
+				*tty->flip.flag_buf_ptr = TTY_BREAK;
+			} else if (*status & TXx927_SIDISR_UPER)
+				*tty->flip.flag_buf_ptr = TTY_PARITY;
+			else if (*status & TXx927_SIDISR_UFER)
+				*tty->flip.flag_buf_ptr = TTY_FRAME;
+		}
+#if defined(CONFIG_SERIAL_TXX927_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+		if (break_pressed && port == &rs_ports[sercons.index]) {
+			if (ch != 0 &&
+			    time_before(jiffies, break_pressed + HZ*5)) {
+				handle_sysrq(ch, regs, NULL, NULL);
+				break_pressed = 0;
+				goto ignore_char;
+			}
+			break_pressed = 0;
+		}
+#endif
+		if ((*status & port->ignore_status_mask) == 0) {
+			tty->flip.flag_buf_ptr++;
+			tty->flip.char_buf_ptr++;
+			tty->flip.count++;
+		}
+		if ((*status & TXx927_SIDISR_UOER) &&
+		    (tty->flip.count < TTY_FLIPBUF_SIZE)) {
+			/*
+			 * Overrun is special, since it's reported
+			 * immediately, and doesn't affect the current
+			 * character
+			 */
+			*tty->flip.flag_buf_ptr = TTY_OVERRUN;
+			tty->flip.count++;
+			tty->flip.flag_buf_ptr++;
+			tty->flip.char_buf_ptr++;
+		}
+#if defined(CONFIG_SERIAL_TXX927_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+	ignore_char:
+#endif
+		*status = sio_reg(port)->disr;
+	} while ((!(*status & TXx927_SIDISR_UVALID)) && (max_count-- > 0));
+	tty_flip_buffer_push(tty);
+}
+
+static inline void transmit_chars(struct rs_port *port)
+{
+	int count;
+
+	if (port->x_char) {
+		sio_reg(port)->tfifo = port->x_char;
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (port->gs.xmit_cnt <= 0
+	    || port->gs.tty->stopped
+	    || port->gs.tty->hw_stopped) {
+		rs_disable_tx_interrupts(port);
+		return;
+	}
+
+	count = TXx927_SIO_TX_FIFO;
+	do {
+		sio_reg(port)->tfifo = port->gs.xmit_buf[port->gs.xmit_tail++];
+		port->gs.xmit_tail &= SERIAL_XMIT_SIZE-1;
+		port->icount.tx++;
+		if (--port->gs.xmit_cnt <= 0)
+			break;
+	} while (--count > 0);
+	
+	if (port->gs.xmit_cnt <= 0 || port->gs.tty->stopped ||
+	     port->gs.tty->hw_stopped) {
+		rs_disable_tx_interrupts(port);
+	}
+	
+	if (port->gs.xmit_cnt <= port->gs.wakeup_chars) {
+                if ((port->gs.tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+                    port->gs.tty->ldisc.write_wakeup)
+                        (port->gs.tty->ldisc.write_wakeup)(port->gs.tty);
+                wake_up_interruptible(&port->gs.tty->write_wait);
+	}
+}
+
+static inline void check_modem_status(struct rs_port *port)
+{
+        /* We don't have a carrier detect line - but just respond
+           like we had one anyways so that open() becomes unblocked */
+	wake_up_interruptible(&port->gs.open_wait);
+}
+
+#define RS_ISR_PASS_LIMIT 256
+
+static void rs_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+{
+	struct rs_port * port = (struct rs_port *)dev_id;
+	unsigned long flags;
+	int status;
+	int pass_counter = 0;
+
+	save_and_cli(flags);
+	
+	if (!port || !port->gs.tty) {
+		restore_flags(flags);
+		return;
+	}
+
+	do {
+		status = sio_reg(port)->disr;
+		if (!(sio_reg(port)->dicr & TXx927_SIDICR_TIE))
+			status &= ~TXx927_SIDISR_TDIS;
+		if (!(status & (TXx927_SIDISR_TDIS | TXx927_SIDISR_RDIS | TXx927_SIDISR_TOUT)))
+			break;
+
+		if (status & TXx927_SIDISR_RDIS)
+			receive_chars(port, &status, regs);
+#if 0		/* RTS/CTS are controled by HW. (if possible) */
+		check_modem_status(port);
+#endif
+		if (status & TXx927_SIDISR_TDIS)
+			transmit_chars(port);
+		/* Clear TX/RX Int. Status */
+		sio_reg(port)->disr &= ~(TXx927_SIDISR_TDIS | TXx927_SIDISR_RDIS | TXx927_SIDISR_TOUT);
+
+		if (pass_counter++ > RS_ISR_PASS_LIMIT) {
+			break;
+		}
+	} while (1);
+	restore_flags(flags);
+}
+
+/*
+ ***********************************************************************
+ *                Here are the routines that actually                  *
+ *              interface with the generic_serial driver               *
+ ***********************************************************************
+ */
+static void rs_disable_tx_interrupts (void * ptr) 
+{
+	struct rs_port *port = ptr; 
+	unsigned long flags;
+
+	save_and_cli(flags);
+        port->gs.flags &= ~GS_TX_INTEN;
+	sio_reg(port)->dicr &= ~TXx927_SIDICR_TIE;
+	restore_flags(flags);
+}
+
+static void rs_enable_tx_interrupts (void * ptr) 
+{
+	struct rs_port *port = ptr; 
+	unsigned long flags;
+
+	save_and_cli(flags);
+	sio_reg(port)->dicr |= TXx927_SIDICR_TIE;
+	restore_flags(flags);
+}
+
+static void rs_disable_rx_interrupts (void * ptr) 
+{
+	struct rs_port *port = ptr;
+	unsigned long flags;
+
+	save_and_cli(flags);
+	port->read_status_mask &= ~TXx927_SIDISR_RDIS;
+#if 0
+	sio_reg(port)->dicr &= ~TXx927_SIDICR_RIE;
+#endif
+	restore_flags(flags);
+}
+
+static void rs_enable_rx_interrupts (void * ptr) 
+{
+	struct rs_port *port = ptr;
+	sio_reg(port)->dicr |= TXx927_SIDICR_RIE;
+}
+
+
+static int rs_get_CD (void * ptr) 
+{
+	/* No Carried Detect in Hardware - just return true */
+	return (1);
+}
+
+static void rs_shutdown_port (void * ptr) 
+{
+	struct rs_port *port = ptr; 
+
+	port->gs.flags &= ~GS_ACTIVE;
+
+	free_irq(port->irq, port);
+	sio_reg(port)->dicr = 0;	/* disable all intrs */
+	/* disable break condition */
+	sio_reg(port)->flcr &= ~TXx927_SIFLCR_TBRK;
+
+#ifdef CONFIG_SERIAL_TXX927_CONSOLE
+	if (port == &rs_ports[sercons.index]) {
+#endif
+	if (!port->gs.tty || (port->gs.tty->termios->c_cflag & HUPCL)) {
+		/* drop RTS */
+		sio_reg(port)->flcr |= TXx927_SIFLCR_RTSSC|TXx927_SIFLCR_RSDE;
+		/* TXx927-SIO can not control DTR... */
+	}
+
+	/* reset FIFO's */	
+	sio_reg(port)->fcr |= TXx927_SIFCR_TFRST | TXx927_SIFCR_RFRST |
+		TXx927_SIFCR_FRSTE;
+	/* clear reset */
+	sio_reg(port)->fcr &= ~(TXx927_SIFCR_TFRST | TXx927_SIFCR_RFRST |
+				TXx927_SIFCR_FRSTE);
+	/* Disable RX/TX */
+	sio_reg(port)->flcr |= TXx927_SIFLCR_RSDE | TXx927_SIFLCR_TSDE;
+#ifdef CONFIG_SERIAL_TXX927_CONSOLE
+	}
+#endif
+}
+
+static int rs_set_real_termios (void *ptr)
+{
+	struct rs_port *port = ptr;
+	int	quot = 0, baud_base, baud;
+	unsigned cflag, cval, fcr = 0;
+	int	bits;
+	unsigned long	flags;
+
+	if (!port->gs.tty || !port->gs.tty->termios)
+		return 0;
+	cflag = port->gs.tty->termios->c_cflag;
+	cval = sio_reg(port)->lcr;
+	/* byte size and parity */
+	cval &= ~TXx927_SILCR_UMODE_MASK;
+	switch (cflag & CSIZE) {
+	case CS7:
+		cval |= TXx927_SILCR_UMODE_7BIT;
+		bits = 9;
+		break;
+	case CS5:	/* not supported */
+	case CS6:	/* not supported */
+	case CS8:
+	default:
+		cval |= TXx927_SILCR_UMODE_8BIT;
+		bits = 10;
+		break;
+	}
+	cval &= ~TXx927_SILCR_USBL_MASK;
+	if (cflag & CSTOPB) {
+		cval |= TXx927_SILCR_USBL_2BIT;
+		bits++;
+	} else {
+		cval |= TXx927_SILCR_USBL_1BIT;
+	}
+
+	cval &= ~(TXx927_SILCR_UPEN|TXx927_SILCR_UEPS);
+	if (cflag & PARENB) {
+		cval |= TXx927_SILCR_UPEN;
+		bits++;
+	}
+	if (!(cflag & PARODD))
+		cval |= TXx927_SILCR_UEPS;
+
+	/* Determine divisor based on baud rate */
+	baud = tty_get_baud_rate(port->gs.tty);
+	if (!baud)
+		baud = 9600;	/* B0 transition handled in rs_set_termios */
+	baud_base = port->baud_base;
+	quot = (baud_base + baud / 2) / baud;
+	/* As a last resort, if the quotient is zero, default to 9600 bps */
+	if (!quot)
+		quot = (baud_base + 9600 / 2) / 9600;
+	port->quot = quot;
+
+	/* Set up FIFO's */
+	/* TX Int by FIFO Empty, RX Int by Receiving 1 char. */
+	fcr = TXx927_SIFCR_TDIL_MAX | TXx927_SIFCR_RDIL_1;
+
+	/* CTS flow control flag */
+	if (cflag & CRTSCTS) {
+		port->gs.flags |= ASYNC_CTS_FLOW;
+		if (port->flags & TXx927_SERIAL_HAVE_CTS_LINE)
+			sio_reg(port)->flcr = TXx927_SIFLCR_RCS | TXx927_SIFLCR_TES |
+				TXx927_SIFLCR_RTSTL_MAX /* 15 */;
+	} else {
+		port->gs.flags &= ~ASYNC_CTS_FLOW;
+		sio_reg(port)->flcr &= ~(TXx927_SIFLCR_RCS | TXx927_SIFLCR_TES | TXx927_SIFLCR_RSDE | TXx927_SIFLCR_TSDE);
+	}
+
+	/*
+	 * Set up parity check flag
+	 */
+#define RELEVANT_IFLAG(iflag) (iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
+
+	port->read_status_mask = TXx927_SIDISR_UOER |
+		TXx927_SIDISR_TDIS | TXx927_SIDISR_RDIS;
+	if (I_INPCK(port->gs.tty))
+		port->read_status_mask |= TXx927_SIDISR_UFER | TXx927_SIDISR_UPER;
+	if (I_BRKINT(port->gs.tty) || I_PARMRK(port->gs.tty))
+		port->read_status_mask |= TXx927_SIDISR_UBRK;
+	
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (I_IGNPAR(port->gs.tty))
+		port->ignore_status_mask |= TXx927_SIDISR_UPER | TXx927_SIDISR_UFER;
+	if (I_IGNBRK(port->gs.tty)) {
+		port->ignore_status_mask |= TXx927_SIDISR_UBRK;
+		/*
+		 * If we're ignore parity and break indicators, ignore 
+		 * overruns too.  (For real raw support).
+		 */
+		if (I_IGNPAR(port->gs.tty))
+			port->ignore_status_mask |= TXx927_SIDISR_UOER;
+	}
+#if 0	/* XXX: This cause problem with some programs(init, mingetty, etc) */
+	/*
+	 * !!! ignore all characters if CREAD is not set
+	 */
+	if ((cflag & CREAD) == 0)
+		port->ignore_status_mask |= TXx927_SIDISR_RDIS;
+#endif
+	save_and_cli(flags);
+	cval &= ~TXx927_SILCR_SCS_IMCLK;
+	sio_reg(port)->lcr = cval | TXx927_SILCR_SCS_IMCLK_BG;
+	sio_reg(port)->bgr = quot | TXx927_SIBGR_BCLK_T0;
+	sio_reg(port)->fcr = fcr;
+	restore_flags(flags);
+	return 0;
+}
+
+static int rs_chars_in_buffer (void * ptr) 
+{
+	struct rs_port *port = ptr;
+
+	/* return 0 if transmitter disabled. */
+	if (sio_reg(port)->flcr & TXx927_SIFLCR_TSDE)
+		return 0;
+	return (sio_reg(port)->cisr & TXx927_SICISR_TXALS) ? 0 : 1;
+}
+
+/* ********************************************************************** *
+ *                Here are the routines that actually                     *
+ *               interface with the rest of the system                    *
+ * ********************************************************************** */
+static int rs_open (struct tty_struct * tty, struct file * filp)
+{
+	struct rs_port *port;
+	int retval, line;
+
+	if (!rs_initialized) {
+		return -EIO;
+	}
+
+	line = MINOR(tty->device) - tty->driver.minor_start;
+
+	if ((line < 0) || (line >= NR_PORTS))
+		return -ENODEV;
+
+	/* Pre-initialized already */
+	port = & rs_ports[line];
+
+	tty->driver_data = port;
+	port->gs.tty = tty;
+	port->gs.count++;
+
+	/*
+	 * Start up serial port
+	 */
+	retval = gs_init_port(&port->gs);
+	if (retval) {
+		port->gs.count--;
+		return retval;
+	}
+
+	port->gs.flags |= GS_ACTIVE;
+
+	if (port->gs.count == 1) {
+		MOD_INC_USE_COUNT;
+
+		/*
+		 * Clear the FIFO buffers and disable them
+		 * (they will be reenabled in rs_set_real_termios())
+		 */
+		sio_reg(port)->fcr |= TXx927_SIFCR_TFRST | TXx927_SIFCR_RFRST |
+			TXx927_SIFCR_FRSTE;
+		/* clear reset */
+		sio_reg(port)->fcr &= ~(TXx927_SIFCR_TFRST | TXx927_SIFCR_RFRST |
+					TXx927_SIFCR_FRSTE);
+		sio_reg(port)->dicr = 0;
+
+		retval = request_irq(port->irq, rs_interrupt, SA_INTERRUPT, "serial_txx927", port);
+		if (retval) {
+			printk(KERN_ERR "serial_txx927: request_irq: err %d\n", retval);
+			MOD_DEC_USE_COUNT;
+			port->gs.count--;
+			return retval;
+		}
+		/*
+		 * Clear the interrupt registers.
+		 */
+		sio_reg(port)->disr = 0;
+
+		/* HW RTS/CTS control */
+		if (port->flags & TXx927_SERIAL_HAVE_CTS_LINE)
+			sio_reg(port)->flcr = TXx927_SIFLCR_RCS | TXx927_SIFLCR_TES |
+				TXx927_SIFLCR_RTSTL_MAX /* 15 */;
+	}
+
+	/* Enable RX/TX */
+	sio_reg(port)->flcr &= ~(TXx927_SIFLCR_RSDE | TXx927_SIFLCR_TSDE);
+	
+	/*
+	 * Finally, enable interrupts
+	 */
+	rs_enable_rx_interrupts(port); 
+
+	/*
+	 * and set the speed of the serial port
+	 */
+	rs_set_real_termios(port);
+
+	retval = gs_block_til_ready(&port->gs, filp);
+
+	if (retval) {
+		if (port->gs.count == 1) {
+			free_irq(port->irq, port);
+			MOD_DEC_USE_COUNT;
+		}
+		port->gs.count--;
+		return retval;
+	}
+	/* tty->low_latency = 1; */
+
+	if ((port->gs.count == 1) && (port->gs.flags & ASYNC_SPLIT_TERMIOS)) {
+		if (tty->driver.subtype == SERIAL_TYPE_NORMAL)
+			*tty->termios = port->gs.normal_termios;
+		else 
+			*tty->termios = port->gs.callout_termios;
+		rs_set_real_termios(port);
+	}
+#ifdef CONFIG_SERIAL_TXX927_CONSOLE
+	if (sercons.cflag && sercons.index == line) {
+		tty->termios->c_cflag = sercons.cflag;
+		sercons.cflag = 0;
+		rs_set_real_termios(port);
+	}
+#endif
+	port->gs.session = current->session;
+	port->gs.pgrp = current->pgrp;
+	return 0;
+}
+
+/*
+ * /proc fs routines....
+ */
+
+static inline int line_info(char *buf, struct rs_port *port)
+{
+	char	stat_buf[30];
+	int	ret;
+	unsigned long flags;
+
+	ret = sprintf(buf, "%d: uart:txx927 iomem:%lx irq:%d",
+		      port - &rs_ports[0], port->base, port->irq);
+
+	if (!port->base) {
+		ret += sprintf(buf+ret, "\n");
+		return ret;
+	}
+
+	/*
+	 * Figure out the current RS-232 lines
+	 */
+	stat_buf[0] = 0;
+	stat_buf[1] = 0;
+	save_and_cli(flags);
+	if (!(sio_reg(port)->flcr & TXx927_SIFLCR_RTSSC))
+		strcat(stat_buf, "|RTS");
+	if (!(sio_reg(port)->cisr & TXx927_SICISR_CTSS))
+		strcat(stat_buf, "|CTS");
+	restore_flags(flags); 
+
+	if (port->quot) {
+		ret += sprintf(buf+ret, " baud:%d",
+			       port->baud_base / port->quot);
+	}
+
+	ret += sprintf(buf+ret, " tx:%d rx:%d",
+		       port->icount.tx, port->icount.rx);
+
+	if (port->icount.frame)
+		ret += sprintf(buf+ret, " fe:%d", port->icount.frame);
+	
+	if (port->icount.parity)
+		ret += sprintf(buf+ret, " pe:%d", port->icount.parity);
+	
+	if (port->icount.brk)
+		ret += sprintf(buf+ret, " brk:%d", port->icount.brk);	
+
+	if (port->icount.overrun)
+		ret += sprintf(buf+ret, " oe:%d", port->icount.overrun);
+
+	/*
+	 * Last thing is the RS-232 status lines
+	 */
+	ret += sprintf(buf+ret, " %s\n", stat_buf+1);
+	return ret;
+}
+
+static int rs_read_proc(char *page, char **start, off_t off, int count,
+			int *eof, void *data)
+{
+	int i, len = 0, l;
+	off_t	begin = 0;
+
+	len += sprintf(page, "serinfo:1.0 driver:%s\n", serial_version);
+	for (i = 0; i < NR_PORTS && len < 4000; i++) {
+		l = line_info(page + len, &rs_ports[i]);
+		len += l;
+		if (len+begin > off+count)
+			goto done;
+		if (len+begin < off) {
+			begin += len;
+			len = 0;
+		}
+	}
+	*eof = 1;
+done:
+	if (off >= len+begin)
+		return 0;
+	*start = page + (begin-off);
+	return ((count < begin+len-off) ? count : begin+len-off);
+}
+
+static void rs_close (void *ptr)
+{
+#if 0
+	struct rs_port *port = ptr;
+	free_irq(port->irq, port);
+#endif
+	MOD_DEC_USE_COUNT;
+}
+
+/* I haven't the foggiest why the decrement use count has to happen
+   here. The whole linux serial drivers stuff needs to be redesigned.
+   My guess is that this is a hack to minimize the impact of a bug
+   elsewhere. Thinking about it some more. (try it sometime) Try
+   running minicom on a serial port that is driven by a modularized
+   driver. Have the modem hangup. Then remove the driver module. Then
+   exit minicom.  I expect an "oops".  -- REW */
+static void rs_hungup (void *ptr)
+{
+	MOD_DEC_USE_COUNT;
+}
+
+/*
+ * rs_break() --- routine which turns the break handling on or off
+ */
+static void rs_break(struct tty_struct *tty, int break_state)
+{
+	struct rs_port *port = tty->driver_data;
+	unsigned long flags;
+
+	if (!port->base)
+		return;
+	save_and_cli(flags);
+	if (break_state == -1)
+		sio_reg(port)->flcr |= TXx927_SIFLCR_TBRK;
+	else
+		sio_reg(port)->flcr &= ~TXx927_SIFLCR_TBRK;
+	restore_flags(flags);
+}
+
+static int get_modem_info(struct rs_port *port, unsigned int *value)
+{
+	unsigned int result;
+	unsigned long flags;
+
+	save_and_cli(flags);
+	result =  ((sio_reg(port)->flcr & TXx927_SIFLCR_RTSSC) ? 0 : TIOCM_RTS)
+		| ((sio_reg(port)->cisr & TXx927_SICISR_CTSS) ? 0 : TIOCM_CTS);
+	restore_flags(flags);
+	return put_user(result,value);
+}
+
+static int set_modem_info(struct rs_port *port, unsigned int cmd,
+			  unsigned int *value)
+{
+	int error = 0;
+	unsigned int arg;
+	unsigned long flags;
+
+	if (copy_from_user(&arg, value, sizeof(int)))
+		return -EFAULT;
+
+	save_and_cli(flags);
+	switch (cmd) {
+	case TIOCMBIS: 
+		if (arg & TIOCM_RTS)
+			sio_reg(port)->flcr &= ~(TXx927_SIFLCR_RTSSC|TXx927_SIFLCR_RSDE);
+		break;
+	case TIOCMBIC:
+		if (arg & TIOCM_RTS)
+			sio_reg(port)->flcr |= TXx927_SIFLCR_RTSSC|TXx927_SIFLCR_RSDE;
+		break;
+	case TIOCMSET:
+		sio_reg(port)->flcr =
+			(sio_reg(port)->flcr & ~(TXx927_SIFLCR_RTSSC|TXx927_SIFLCR_RSDE)) |
+			((arg & TIOCM_RTS) ? 0 : TXx927_SIFLCR_RTSSC|TXx927_SIFLCR_RSDE);
+		break;
+	default:
+		error = -EINVAL;
+	}
+	restore_flags(flags);
+	return error;
+}
+
+static int rs_ioctl (struct tty_struct * tty, struct file * filp, 
+                     unsigned int cmd, unsigned long arg)
+{
+	int rc;
+	struct rs_port *port = tty->driver_data;
+	int ival;
+
+	rc = 0;
+	switch (cmd) {
+	case TIOCMGET:
+		return get_modem_info(port, (unsigned int *) arg);
+	case TIOCMBIS:
+	case TIOCMBIC:
+	case TIOCMSET:
+		return set_modem_info(port, cmd, (unsigned int *) arg);
+		return 0;
+	case TIOCGSOFTCAR:
+		rc = put_user(((tty->termios->c_cflag & CLOCAL) ? 1 : 0),
+		              (unsigned int *) arg);
+		break;
+	case TIOCSSOFTCAR:
+		if ((rc = verify_area(VERIFY_READ, (void *) arg,
+		                      sizeof(int))) == 0) {
+			get_user(ival, (unsigned int *) arg);
+			tty->termios->c_cflag =
+				(tty->termios->c_cflag & ~CLOCAL) |
+				(ival ? CLOCAL : 0);
+		}
+		break;
+	case TIOCGSERIAL:
+		if ((rc = verify_area(VERIFY_WRITE, (void *) arg,
+		                      sizeof(struct serial_struct))) == 0)
+			gs_getserial(&port->gs, (struct serial_struct *) arg);
+		break;
+	case TIOCSSERIAL:
+		if ((rc = verify_area(VERIFY_READ, (void *) arg,
+		                      sizeof(struct serial_struct))) == 0)
+			rc = gs_setserial(&port->gs, (struct serial_struct *) arg);
+		break;
+	default:
+		rc = -ENOIOCTLCMD;
+		break;
+	}
+
+	return rc;
+}
+
+
+/*
+ * This function is used to send a high-priority XON/XOFF character to
+ * the device
+ */
+static void rs_send_xchar(struct tty_struct * tty, char ch)
+{
+	struct rs_port *port = (struct rs_port *)tty->driver_data;
+	
+	port->x_char = ch;
+	if (ch) {
+		/* Make sure transmit interrupts are on */
+		rs_enable_tx_interrupts(tty);
+	}
+}
+
+
+/*
+ * ------------------------------------------------------------
+ * rs_throttle()
+ * 
+ * This routine is called by the upper-layer tty layer to signal that
+ * incoming characters should be throttled.
+ * ------------------------------------------------------------
+ */
+static void rs_throttle(struct tty_struct * tty)
+{
+	struct rs_port *port = (struct rs_port *)tty->driver_data;
+	unsigned long flags;
+
+	if (I_IXOFF(tty))
+		rs_send_xchar(tty, STOP_CHAR(tty));
+	if (tty->termios->c_cflag & CRTSCTS) {
+		save_and_cli(flags);
+		/* drop RTS */
+		sio_reg(port)->flcr |= TXx927_SIFLCR_RTSSC|TXx927_SIFLCR_RSDE;
+		restore_flags(flags);
+	}
+}
+
+static void rs_unthrottle(struct tty_struct * tty)
+{
+	struct rs_port *port = tty->driver_data;
+	unsigned long flags;
+
+	if (I_IXOFF(tty)) {
+		if (port->x_char)
+			port->x_char = 0;
+		else
+			rs_send_xchar(tty, START_CHAR(tty));
+	}
+	if (tty->termios->c_cflag & CRTSCTS) {
+		save_and_cli(flags);
+		sio_reg(port)->flcr &= ~(TXx927_SIFLCR_RTSSC|TXx927_SIFLCR_RSDE);
+		restore_flags(flags);
+	}
+}
+
+/* ********************************************************************** *
+ *                    Here are the initialization routines.               *
+ * ********************************************************************** */
+
+static inline void show_serial_version(void)
+{
+ 	printk(KERN_INFO "%s version %s\n", serial_name, serial_version);
+}
+
+static int rs_init_portstructs(void)
+{
+	struct rs_port *port;
+	int i;
+
+	/* Adjust the values in the "driver" */
+	rs_driver.termios = rs_termios;
+	rs_driver.termios_locked = rs_termios_locked;
+
+	port = rs_ports;
+	for (i=0; i < NR_PORTS;i++) {
+		if (!port->base)
+			continue;
+		port->gs.callout_termios = tty_std_termios;
+		port->gs.normal_termios	= tty_std_termios;
+		port->gs.magic = TXX927_SERIAL_MAGIC;
+		port->gs.close_delay = HZ/2;
+		port->gs.closing_wait = 30 * HZ;
+		port->gs.rd = &rs_real_driver;
+#ifdef NEW_WRITE_LOCKING
+		port->gs.port_write_sem = MUTEX;
+#endif
+#ifdef DECLARE_WAITQUEUE
+		init_waitqueue_head(&port->gs.open_wait);
+		init_waitqueue_head(&port->gs.close_wait);
+#endif
+		port++;
+	}
+
+	return 0;
+}
+
+static int rs_init_drivers(void)
+{
+	int error;
+
+	memset(&rs_driver, 0, sizeof(rs_driver));
+	rs_driver.magic = TTY_DRIVER_MAGIC;
+	rs_driver.driver_name = "serial_txx927";
+#if defined(CONFIG_DEVFS_FS)
+	rs_driver.name = TXX927_TTY_DEVFS_NAME;
+#else
+	rs_driver.name = TXX927_TTY_NAME;
+#endif
+	rs_driver.major = TXX927_TTY_MAJOR;
+	rs_driver.minor_start = TXX927_TTY_MINOR_START;
+	rs_driver.num = NR_PORTS;
+	rs_driver.type = TTY_DRIVER_TYPE_SERIAL;
+	rs_driver.subtype = SERIAL_TYPE_NORMAL;
+	rs_driver.init_termios = tty_std_termios;
+	rs_driver.init_termios.c_cflag =
+		B115200 | CS8 | CREAD | HUPCL | CLOCAL;
+	rs_driver.refcount = &rs_refcount;
+	rs_driver.table = rs_table;
+	rs_driver.termios = rs_termios;
+	rs_driver.termios_locked = rs_termios_locked;
+
+	rs_driver.open	= rs_open;
+	rs_driver.close = gs_close;
+	rs_driver.write = gs_write;
+	rs_driver.put_char = gs_put_char; 
+	rs_driver.flush_chars = gs_flush_chars;
+	rs_driver.write_room = gs_write_room;
+	rs_driver.chars_in_buffer = gs_chars_in_buffer;
+	rs_driver.flush_buffer = gs_flush_buffer;
+	rs_driver.ioctl = rs_ioctl;
+	rs_driver.throttle = rs_throttle;
+	rs_driver.unthrottle = rs_unthrottle;
+	rs_driver.set_termios = gs_set_termios;
+	rs_driver.stop = gs_stop;
+	rs_driver.start = gs_start;
+	rs_driver.hangup = gs_hangup;
+	rs_driver.break_ctl = rs_break;
+	rs_driver.read_proc = rs_read_proc;
+
+	rs_callout_driver = rs_driver;
+#if defined(CONFIG_DEVFS_FS)
+	rs_callout_driver.name = TXX927_CU_DEVFS_NAME;
+#else
+	rs_callout_driver.name = TXX927_CU_NAME;
+#endif
+	rs_callout_driver.major = TXX927_TTYAUX_MAJOR;
+	rs_callout_driver.subtype = SERIAL_TYPE_CALLOUT;
+	rs_callout_driver.read_proc = 0;
+	rs_callout_driver.proc_entry = 0;
+
+	if ((error = tty_register_driver(&rs_driver))) {
+		printk(KERN_ERR "Couldn't register serial driver, error = %d\n",
+		       error);
+		return 1;
+	}
+	if ((error = tty_register_driver(&rs_callout_driver))) {
+		tty_unregister_driver(&rs_driver);
+		printk(KERN_ERR "Couldn't register callout driver, error = %d\n",
+		       error);
+		return 1;
+	}
+
+	return 0;
+}
+
+
+static int __init txx927_rs_init(void)
+{
+	int rc;
+	struct rs_port *port;
+	unsigned long flags;
+	int i;
+
+	for (i = 0, port = &rs_ports[0]; i < NR_PORTS; i++,port++) {
+		if (port->base)
+			goto config_ok;
+	}
+	return -ENODEV;
+ config_ok:
+
+	show_serial_version();
+	rc = rs_init_portstructs ();
+	rs_init_drivers ();
+	for (i = 0, port = &rs_ports[0]; i < NR_PORTS; i++,port++) {
+		if (!port->base)
+			continue;
+		if (check_mem_region(port->base, 36))
+			continue;
+		if (i != sercons.index) {
+			save_and_cli(flags);
+			/*
+			 * Reset the UART.
+			 */
+			sio_reg(port)->fcr = TXx927_SIFCR_SWRST;
+#if 1
+			/* TX4925 BUG WORKAROUND.  Accessing SIOC
+			 * register immediately after soft reset
+			 * causes bus error. */
+			wbflush();
+			udelay(1);
+#endif
+			while (sio_reg(port)->fcr & TXx927_SIFCR_SWRST)
+				;
+			/* TX Int by FIFO Empty, RX Int by Receiving 1 char. */
+			sio_reg(port)->fcr |= TXx927_SIFCR_TDIL_MAX | TXx927_SIFCR_RDIL_1;
+			/* initial settings */
+			sio_reg(port)->lcr = TXx927_SILCR_UMODE_8BIT |
+				TXx927_SILCR_USBL_1BIT |
+				TXx927_SILCR_SCS_IMCLK_BG;
+			sio_reg(port)->bgr =
+				((port->baud_base + 9600 / 2) / 9600) | TXx927_SIBGR_BCLK_T0;
+			restore_flags(flags);
+		}
+		request_mem_region(port->base, 36, "serial_txx927");
+		printk(KERN_INFO "%s%02d at 0x%08lx (irq = %d) is a TXx927 SIO\n",
+		       TXX927_TTY_NAME, i, port->base, port->irq);
+	}
+
+	/* Note: I didn't do anything to enable the second UART */
+	if (rc >= 0) 
+		rs_initialized++;
+	return 0;
+}
+
+/*
+ * This is for use by architectures that know their serial console 
+ * attributes only at run time. Not to be invoked after rs_init().
+ */
+int __init early_serial_txx927_setup(int line, unsigned long base, int irq, int baud_base, int flags)
+{
+	if (line >= NR_PORTS)
+		return(-ENOENT);
+	rs_ports[line].base = base;
+	rs_ports[line].irq = irq;
+	rs_ports[line].baud_base = baud_base;
+	rs_ports[line].flags = flags;
+	return(0);
+}
+
+static void __exit txx927_rs_fini(void) 
+{
+	unsigned long flags;
+	int e1, e2;
+	int i;
+
+	save_and_cli(flags);
+	if ((e1 = tty_unregister_driver(&rs_driver)))
+		printk("serial: failed to unregister serial driver (%d)\n",
+		       e1);
+	if ((e2 = tty_unregister_driver(&rs_callout_driver)))
+		printk("serial: failed to unregister callout driver (%d)\n", 
+		       e2);
+	restore_flags(flags);
+
+	for (i = 0; i < NR_PORTS; i++) {
+		release_mem_region(rs_ports[i].base, 8);
+	}
+}
+
+module_init(txx927_rs_init);
+module_exit(txx927_rs_fini);
+MODULE_DESCRIPTION("TXx927 serial driver");
+MODULE_AUTHOR("TOSHIBA Corporation");
+MODULE_LICENSE("GPL");
+
+/*
+ * Begin serial console routines
+ */
+#ifdef CONFIG_SERIAL_TXX927_CONSOLE
+
+/*
+ *	Wait for transmitter & holding register to empty
+ */
+static inline void wait_for_xmitr(struct rs_port *port)
+{
+	unsigned int tmout = 1000000;
+
+	do {
+		if (--tmout == 0) break;
+	} while (!(sio_reg(port)->cisr & TXx927_SICISR_TXALS));
+
+	/* Wait for flow control if necessary */
+#if (ASYNC_INTERNAL_FLAGS & GS_INTERNAL_FLAGS) == 0	/* check conflict... */
+	if (port->gs.flags & ASYNC_CONS_FLOW) {
+		tmout = 1000000;
+		while (--tmout &&
+		       (sio_reg(port)->cisr & TXx927_SICISR_CTSS));
+	}	
+#endif
+}
+
+/*
+ *	Print a string to the serial port trying not to disturb
+ *	any possible real use of the port...
+ *
+ *	The console_lock must be held when we get here.
+ */
+static void serial_console_write(struct console *co, const char *s,
+				 unsigned count)
+{
+	struct rs_port *port = &rs_ports[co->index];
+	int ier;
+	unsigned i;
+
+	/*
+	 *	First save the IER then disable the interrupts
+	 */
+	ier = sio_reg(port)->dicr;
+	sio_reg(port)->dicr = 0;
+
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++, s++) {
+		wait_for_xmitr(port);
+
+		/*
+		 *	Send the character out.
+		 *	If a LF, also do CR...
+		 */
+		sio_reg(port)->tfifo = *s;
+		if (*s == 10) {
+			wait_for_xmitr(port);
+			sio_reg(port)->tfifo = 13;
+		}
+	}
+
+	/*
+	 *	Finally, Wait for transmitter & holding register to empty
+	 * 	and restore the IER
+	 */
+	wait_for_xmitr(port);
+	sio_reg(port)->dicr = ier;
+}
+
+/*
+ *	Receive character from the serial port
+ */
+static int serial_console_wait_key(struct console *co)
+{
+	struct rs_port *port = &rs_ports[co->index];
+	int ier;
+	int c;
+
+	/*
+	 *	First save the IER then disable the interrupts so
+	 *	that the real driver for the port does not get the
+	 *	character.
+	 */
+	ier = sio_reg(port)->dicr;
+	sio_reg(port)->dicr = 0;
+
+	while (sio_reg(port)->disr & TXx927_SIDISR_UVALID)
+		;
+	c = sio_reg(port)->rfifo;
+
+	/*
+	 *	Restore the interrupts
+	 */
+	sio_reg(port)->dicr = ier;
+
+	return c;
+}
+
+static kdev_t serial_console_device(struct console *c)
+{
+	return MKDEV(TXX927_TTY_MAJOR, TXX927_TTY_MINOR_START + c->index);
+}
+
+static __init int serial_console_setup(struct console *co, char *options)
+{
+	struct rs_port *port;
+	unsigned cval;
+	int	baud = 115200;
+	int	bits = 8;
+	int	parity = 'n';
+	int	doflow = 0;
+	int	cflag = CREAD | HUPCL | CLOCAL;
+	int	quot = 0;
+	char	*s;
+
+	if (co->index < 0 || co->index >= NR_PORTS)
+		return -1;
+	if (options) {
+		baud = simple_strtoul(options, NULL, 10);
+		s = options;
+		while(*s >= '0' && *s <= '9')
+			s++;
+		if (*s) parity = *s++;
+		if (*s) bits   = *s - '0';
+		if (*s) doflow = (*s++ == 'r');
+	}
+
+	/*
+	 *	Now construct a cflag setting.
+	 */
+	switch(baud) {
+	case 1200:	cflag |= B1200;	break;
+	case 2400:	cflag |= B2400;	break;
+	case 4800:	cflag |= B4800;	break;
+	case 19200:	cflag |= B19200;	break;
+	case 38400:	cflag |= B38400;	break;
+	case 57600:	cflag |= B57600;	break;
+	case 115200:	cflag |= B115200;	break;
+	default:
+		/*
+		 * Set this to a sane value to prevent a divide error
+		 */
+		baud  = 9600;
+	case 9600:	cflag |= B9600;		break;
+	}
+	switch(bits) {
+	case 7:		cflag |= CS7;	break;
+	default:
+	case 8:		cflag |= CS8;	break;
+	}
+	switch(parity) {
+	case 'o': case 'O':	cflag |= PARODD;	break;
+	case 'e': case 'E':	cflag |= PARENB;	break;
+	}
+	co->cflag = cflag;
+
+	port = &rs_ports[co->index];
+	if (!port->base)
+		return -1;
+	/*
+	 *	Divisor, bytesize and parity
+	 */
+#if (ASYNC_INTERNAL_FLAGS & GS_INTERNAL_FLAGS) == 0	/* check conflict... */
+	if (doflow)
+		port->gs.flags |= ASYNC_CONS_FLOW;
+#endif
+	quot = port->baud_base / baud;
+	switch (cflag & CSIZE) {
+	case CS7: cval = TXx927_SILCR_UMODE_7BIT; break;
+	default:
+	case CS8: cval = TXx927_SILCR_UMODE_8BIT; break;
+	}
+	if (cflag & CSTOPB)
+		cval |= TXx927_SILCR_USBL_2BIT;
+	else
+		cval |= TXx927_SILCR_USBL_1BIT;
+	if (cflag & PARENB)
+		cval |= TXx927_SILCR_UPEN;
+	if (!(cflag & PARODD))
+		cval |= TXx927_SILCR_UEPS;
+
+	/*
+	 *	Disable UART interrupts, set DTR and RTS high
+	 *	and set speed.
+	 */
+	/* added by Ethan on 11/11/2002. force the baud rate to be set to 115200 */
+#ifdef CONFIG_CPU_TX49XX
+	quot = 11;
+#elif defined(CONFIG_CPU_TX39XX)
+	quot = 9;
+#endif
+
+	sio_reg(port)->dicr = 0;
+	sio_reg(port)->lcr = cval | TXx927_SILCR_SCS_IMCLK_BG;
+	sio_reg(port)->bgr = quot | TXx927_SIBGR_BCLK_T0;
+	/* no RTS/CTS control */
+	sio_reg(port)->flcr = TXx927_SIFLCR_RTSTL_MAX /* 15 */;
+	/* Enable RX/TX */
+	sio_reg(port)->flcr &= ~(TXx927_SIFLCR_RSDE | TXx927_SIFLCR_TSDE);
+
+	/* console port should not use RTC/CTS. */
+	port->flags &= ~TXx927_SERIAL_HAVE_CTS_LINE;
+
+	return 0;
+}
+
+static struct console sercons = {
+	name:		TXX927_TTY_NAME,
+	write:		serial_console_write,
+	device:		serial_console_device,
+	setup:		serial_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+};
+
+void __init txx927_serial_console_init(void)
+{
+	register_console(&sercons);
+}
+
+#endif
diff -Naru linux-2.4.32/drivers/char/tty_io.c linux-2.4.32-mct/drivers/char/tty_io.c
--- linux-2.4.32/drivers/char/tty_io.c	2005-01-19 15:09:53.000000000 +0100
+++ linux-2.4.32-mct/drivers/char/tty_io.c	2006-12-02 15:08:43.000000000 +0100
@@ -164,6 +164,9 @@
 extern void sb1250_serial_console_init(void);
 extern void arc_console_init(void);
 extern int hvc_console_init(void);
+#ifdef CONFIG_SERIAL_TXX927_CONSOLE
+extern void txx927_serial_console_init();
+#endif
 
 #ifndef MIN
 #define MIN(a,b)	((a) < (b) ? (a) : (b))
@@ -2725,6 +2728,9 @@
 #ifdef CONFIG_TXX927_SERIAL_CONSOLE
 	txx927_console_init();
 #endif
+#ifdef CONFIG_SERIAL_TXX927_CONSOLE
+	txx927_serial_console_init();
+#endif
 #ifdef CONFIG_SERIAL_TXX9_CONSOLE
 	txx9_serial_console_init();
 #endif
diff -Naru linux-2.4.32/drivers/ide/Config.in linux-2.4.32-mct/drivers/ide/Config.in
--- linux-2.4.32/drivers/ide/Config.in	2004-11-17 12:54:21.000000000 +0100
+++ linux-2.4.32-mct/drivers/ide/Config.in	2006-12-02 15:08:43.000000000 +0100
@@ -60,6 +60,7 @@
 	    dep_mbool    '      HPT34X AUTODMA support (WIP)' CONFIG_HPT34X_AUTODMA $CONFIG_BLK_DEV_HPT34X $CONFIG_IDEDMA_PCI_WIP
 	    dep_tristate '    HPT36X/37X chipset support' CONFIG_BLK_DEV_HPT366 $CONFIG_BLK_DEV_IDEDMA_PCI
 	    dep_tristate '    Intel PIIXn chipsets support' CONFIG_BLK_DEV_PIIX $CONFIG_BLK_DEV_IDEDMA_PCI
+	    dep_tristate '    ITE 821X chipset support' CONFIG_BLK_DEV_ITE821X $CONFIG_BLK_DEV_IDEDMA_PCI
 	    if [ "$CONFIG_MIPS_ITE8172" = "y" -o "$CONFIG_MIPS_IVR" = "y" ]; then
 	       dep_mbool '    IT8172 IDE support' CONFIG_BLK_DEV_IT8172 $CONFIG_BLK_DEV_IDEDMA_PCI
 	    fi
diff -Naru linux-2.4.32/drivers/ide/ide-iops.c linux-2.4.32-mct/drivers/ide/ide-iops.c
--- linux-2.4.32/drivers/ide/ide-iops.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4.32-mct/drivers/ide/ide-iops.c	2006-12-02 15:08:43.000000000 +0100
@@ -1099,7 +1099,7 @@
 	   use. When they take an IRQ they check STS but also that
 	   the DMA count is not zero (see hpt's own driver)
 	*/
-	ndelay(400);
+	udelay(1);
 	spin_unlock_irqrestore(&io_request_lock, flags);
 }
 
diff -Naru linux-2.4.32/drivers/ide/ide-probe.c linux-2.4.32-mct/drivers/ide/ide-probe.c
--- linux-2.4.32/drivers/ide/ide-probe.c	2004-04-14 15:05:29.000000000 +0200
+++ linux-2.4.32-mct/drivers/ide/ide-probe.c	2006-12-02 15:08:43.000000000 +0100
@@ -460,6 +460,19 @@
 	ide_delay_50ms();
 	SELECT_DRIVE(drive);
 	ide_delay_50ms();
+
+	if (hwif->INB(IDE_SELECT_REG) == 0x80) {
+		unsigned long timeout = jiffies + 20*HZ;
+		byte stat;
+		printk("%s: waiting hd firmware boot. stat=%x\n", hwif->name,stat);
+		do {
+			ide_delay_50ms();
+			stat = hwif->INB(IDE_SELECT_REG);
+//			printk("%s: waiting hd firmware boot. stat=%x\n", hwif->name,stat);
+			if(!stat) hwif->OUTB(drive->select.all, IDE_SELECT_REG);
+		} while ((stat != drive->select.all) && 0 < (signed long)(timeout - jiffies));
+	}
+	
 	if (hwif->INB(IDE_SELECT_REG) != drive->select.all && !drive->present) {
 		if (drive->select.b.unit != 0) {
 			/* exit with drive0 selected */
diff -Naru linux-2.4.32/drivers/ide/pci/Makefile linux-2.4.32-mct/drivers/ide/pci/Makefile
--- linux-2.4.32/drivers/ide/pci/Makefile	2004-11-17 12:54:21.000000000 +0100
+++ linux-2.4.32-mct/drivers/ide/pci/Makefile	2006-12-02 15:08:43.000000000 +0100
@@ -23,6 +23,7 @@
 obj-$(CONFIG_BLK_DEV_PDC202XX_OLD)	+= pdc202xx_old.o
 obj-$(CONFIG_BLK_DEV_PDC202XX_NEW)	+= pdc202xx_new.o
 obj-$(CONFIG_BLK_DEV_PIIX)		+= piix.o
+obj-$(CONFIG_BLK_DEV_ITE821X)	+= it821x.o
 obj-$(CONFIG_BLK_DEV_RZ1000)		+= rz1000.o
 obj-$(CONFIG_BLK_DEV_SVWKS)		+= serverworks.o
 obj-$(CONFIG_BLK_DEV_SC1200)		+= sc1200.o
diff -Naru linux-2.4.32/drivers/ide/pci/it821x.c linux-2.4.32-mct/drivers/ide/pci/it821x.c
--- linux-2.4.32/drivers/ide/pci/it821x.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/drivers/ide/pci/it821x.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,850 @@
+
+/*
+ * linux/drivers/ide/pci/it821x.c		Version 0.09	December 2004
+ *
+ * Copyright (C) 2004		Red Hat <alan@redhat.com>
+ *
+ *  May be copied or modified under the terms of the GNU General Public License
+ *  Based in part on the ITE vendor provided SCSI driver.
+ *
+ *  Documentation available from
+ * 	http://www.ite.com.tw/pc/IT8212F_V04.pdf
+ *  Some other documents are NDA.
+ *
+ *  The ITE8212 isn't exactly a standard IDE controller. It has two
+ *  modes. In pass through mode then it is an IDE controller. In its smart
+ *  mode its actually quite a capable hardware raid controller disguised
+ *  as an IDE controller. Smart mode only understands DMA read/write and
+ *  identify, none of the fancier commands apply. The IT8211 is identical
+ *  in other respects but lacks the raid mode.
+ *
+ *  Errata:
+ *  o	Rev 0x10 also requires master/slave hold the same DMA timings and
+ *	cannot do ATAPI MWDMA.
+ *  o	The identify data for raid volumes lacks CHS info (technically ok)
+ *	but also fails to set the LBA28 and other bits. We fix these in
+ *	the IDE probe quirk code.
+ *  o	If you write LBA48 sized I/O's (ie > 256 sector) in smart mode
+ *	raid then the controller firmware dies
+ *  o	Smart mode without RAID doesn't clear all the necessary identify
+ *	bits to reduce the command set to the one used
+ *
+ *  This has a few impacts on the driver
+ *  - In pass through mode we do all the work you would expect
+ *  - In smart mode the clocking set up is done by the controller generally
+ *    but we must watch the other limits and filter.
+ *  - There are a few extra vendor commands that actually talk to the
+ *    controller but only work PIO with no IRQ.
+ *
+ *  Vendor areas of the identify block in smart mode are used for the
+ *  timing and policy set up. Each HDD in raid mode also has a serial
+ *  block on the disk. The hardware extra commands are get/set chip status,
+ *  rebuild, get rebuild status.
+ *
+ *  In Linux the driver supports pass through mode as if the device was
+ *  just another IDE controller. If the smart mode is running then
+ *  volumes are managed by the controller firmware and each IDE "disk"
+ *  is a raid volume. Even more cute - the controller can do automated
+ *  hotplug and rebuild.
+ *
+ *  The pass through controller itself is a little demented. It has a
+ *  flaw that it has a single set of PIO/MWDMA timings per channel so
+ *  non UDMA devices restrict each others performance. It also has a
+ *  single clock source per channel so mixed UDMA100/133 performance
+ *  isn't perfect and we have to pick a clock. Thankfully none of this
+ *  matters in smart mode. ATAPI DMA is not currently supported.
+ *
+ *  It seems the smart mode is a win for RAID1/RAID10 but otherwise not.
+ *
+ *  TODO
+ *	-	ATAPI UDMA is ok but not MWDMA it seems
+ *	-	RAID configuration ioctls
+ *	-	Move to libata once it grows up
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/hdreg.h>
+#include <linux/ide.h>
+#include <linux/init.h>
+
+#include "ide_modes.h"
+#include <asm/io.h>
+
+struct it821x_dev
+{
+	unsigned int smart:1,		/* Are we in smart raid mode */
+		timing10:1;		/* Rev 0x10 */
+	u8	clock_mode;		/* 0, ATA_50 or ATA_66 */
+	u8	want[2][2];		/* Mode/Pri log for master slave */
+	/* We need these for switching the clock when DMA goes on/off
+	   The high byte is the 66Mhz timing */
+	u16	pio[2];			/* Cached PIO values */
+	u16	mwdma[2];		/* Cached MWDMA values */
+	u16	udma[2];		/* Cached UDMA values (per drive) */
+};
+
+#define ATA_66		0
+#define ATA_50		1
+#define ATA_ANY		2
+
+#define UDMA_OFF	0
+#define MWDMA_OFF	0
+
+#if 0 // Udo
+static void ide_dma_start(ide_drive_t *drive)
+{
+        ide_hwif_t *hwif        = HWIF(drive);
+        u8 dma_cmd              = inb(hwif->dma_base);
+
+        /* Note that this is done *after* the cmd has
+         * been issued to the drive, as per the BM-IDE spec.
+         * The Promise Ultra33 doesn't work correctly when
+         * we do this part before issuing the drive cmd.
+         */
+        /* start DMA */
+        outb(dma_cmd|1, hwif->dma_base);
+//        hwif->dma = 1;
+        wmb();
+}
+
+/*
+ *	We allow users to force the card into non raid mode without
+ *	flashing the alternative BIOS. This is also neccessary right now
+ *	for embedded platforms that cannot run a PC BIOS but are using this
+ *	device.
+ */
+
+static int it8212_noraid;
+#endif // Udo
+/**
+ *	it821x_program	-	program the PIO/MWDMA registers
+ *	@drive: drive to tune
+ *
+ *	Program the PIO/MWDMA timing for this channel according to the
+ *	current clock.
+ */
+
+static void it821x_program(ide_drive_t *drive, u16 timing)
+{
+	ide_hwif_t *hwif	= drive->hwif;
+	struct it821x_dev *itdev = ide_get_hwifdata(hwif);
+	int channel = hwif->channel;
+	u8 conf;
+
+	/* Program PIO/MWDMA timing bits */
+	if(itdev->clock_mode == ATA_66)
+		conf = timing >> 8;
+	else
+		conf = timing & 0xFF;
+	pci_write_config_byte(hwif->pci_dev, 0x54 + 4 * channel, conf);
+}
+
+/**
+ *	it821x_program_udma	-	program the UDMA registers
+ *	@drive: drive to tune
+ *
+ *	Program the UDMA timing for this drive according to the
+ *	current clock.
+ */
+
+static void it821x_program_udma(ide_drive_t *drive, u16 timing)
+{
+	ide_hwif_t *hwif	= drive->hwif;
+	struct it821x_dev *itdev = ide_get_hwifdata(hwif);
+	int channel = hwif->channel;
+	int unit = drive->select.b.unit;
+	u8 conf;
+
+	/* Program UDMA timing bits */
+	if(itdev->clock_mode == ATA_66)
+		conf = timing >> 8;
+	else
+		conf = timing & 0xFF;
+	if(itdev->timing10 == 0)
+		pci_write_config_byte(hwif->pci_dev, 0x56 + 4 * channel + unit, conf);
+	else {
+		pci_write_config_byte(hwif->pci_dev, 0x56 + 4 * channel, conf);
+		pci_write_config_byte(hwif->pci_dev, 0x56 + 4 * channel + 1, conf);
+	}
+}
+
+
+/**
+ *	it821x_clock_strategy
+ *	@hwif: hardware interface
+ *
+ *	Select between the 50 and 66Mhz base clocks to get the best
+ *	results for this interface.
+ */
+
+static void it821x_clock_strategy(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct it821x_dev *itdev = ide_get_hwifdata(hwif);
+
+	u8 unit = drive->select.b.unit;
+	ide_drive_t *pair = &hwif->drives[1-unit];
+
+	int clock, altclock;
+	u8 v;
+	int sel = 0;
+
+	if(itdev->want[0][0] > itdev->want[1][0]) {
+		clock = itdev->want[0][1];
+		altclock = itdev->want[1][1];
+	} else {
+		clock = itdev->want[1][1];
+		altclock = itdev->want[0][1];
+	}
+
+	/* Master doesn't care does the slave ? */
+	if(clock == ATA_ANY)
+		clock = altclock;
+
+	/* Nobody cares - keep the same clock */
+	if(clock == ATA_ANY)
+		return;
+	/* No change */
+	if(clock == itdev->clock_mode)
+		return;
+
+	/* Load this into the controller ? */
+	if(clock == ATA_66)
+		itdev->clock_mode = ATA_66;
+	else {
+		itdev->clock_mode = ATA_50;
+		sel = 1;
+	}
+	pci_read_config_byte(hwif->pci_dev, 0x50, &v);
+	v &= ~(1 << (1 + hwif->channel));
+	v |= sel << (1 + hwif->channel);
+	pci_write_config_byte(hwif->pci_dev, 0x50, v);
+
+	/*
+	 *	Reprogram the UDMA/PIO of the pair drive for the switch
+	 *	MWDMA will be dealt with by the dma switcher
+	 */
+	if(pair && itdev->udma[1-unit] != UDMA_OFF) {
+		it821x_program_udma(pair, itdev->udma[1-unit]);
+		it821x_program(pair, itdev->pio[1-unit]);
+	}
+	/*
+	 *	Reprogram the UDMA/PIO of our drive for the switch.
+	 *	MWDMA will be dealt with by the dma switcher
+	 */
+	if(itdev->udma[unit] != UDMA_OFF) {
+		it821x_program_udma(drive, itdev->udma[unit]);
+		it821x_program(drive, itdev->pio[unit]);
+	}
+}
+
+/**
+ *	it821x_ratemask	-	Compute available modes
+ *	@drive: IDE drive
+ *
+ *	Compute the available speeds for the devices on the interface. This
+ *	is all modes to ATA133 clipped by drive cable setup.
+ */
+
+static u8 it821x_ratemask (ide_drive_t *drive)
+{
+	u8 mode	= 4;
+	if (!eighty_ninty_three(drive))
+		mode = min(mode, (u8)1);
+	return mode;
+}
+
+/**
+ *	it821x_tuneproc	-	tune a drive
+ *	@drive: drive to tune
+ *	@mode_wanted: the target operating mode
+ *
+ *	Load the timing settings for this device mode into the
+ *	controller. By the time we are called the mode has been
+ *	modified as neccessary to handle the absence of seperate
+ *	master/slave timers for MWDMA/PIO.
+ *
+ *	This code is only used in pass through mode.
+ */
+
+static void it821x_tuneproc (ide_drive_t *drive, byte mode_wanted)
+{
+	ide_hwif_t *hwif	= drive->hwif;
+	struct it821x_dev *itdev = ide_get_hwifdata(hwif);
+	int unit = drive->select.b.unit;
+
+	/* Spec says 89 ref driver uses 88 */
+	static u16 pio[]	= { 0xAA88, 0xA382, 0xA181, 0x3332, 0x3121 };
+	static u8 pio_want[]    = { ATA_66, ATA_66, ATA_66, ATA_66, ATA_ANY };
+
+	if(itdev->smart)
+		return;
+
+	/* We prefer 66Mhz clock for PIO 0-3, don't care for PIO4 */
+	itdev->want[unit][1] = pio_want[mode_wanted];
+	itdev->want[unit][0] = 1;	/* PIO is lowest priority */
+	itdev->pio[unit] = pio[mode_wanted];
+	it821x_clock_strategy(drive);
+	it821x_program(drive, itdev->pio[unit]);
+}
+
+/**
+ *	it821x_tune_mwdma	-	tune a channel for MWDMA
+ *	@drive: drive to set up
+ *	@mode_wanted: the target operating mode
+ *
+ *	Load the timing settings for this device mode into the
+ *	controller when doing MWDMA in pass through mode. The caller
+ *	must manage the whole lack of per device MWDMA/PIO timings and
+ *	the shared MWDMA/PIO timing register.
+ */
+
+static void it821x_tune_mwdma (ide_drive_t *drive, byte mode_wanted)
+{
+	ide_hwif_t *hwif	= drive->hwif;
+	struct it821x_dev *itdev = (void *)ide_get_hwifdata(hwif);
+	int unit = drive->select.b.unit;
+	int channel = hwif->channel;
+	u8 conf;
+
+	static u16 dma[]	= { 0x8866, 0x3222, 0x3121 };
+	static u8 mwdma_want[]	= { ATA_ANY, ATA_66, ATA_ANY };
+
+	itdev->want[unit][1] = mwdma_want[mode_wanted];
+	itdev->want[unit][0] = 2;	/* MWDMA is low priority */
+	itdev->mwdma[unit] = dma[mode_wanted];
+	itdev->udma[unit] = UDMA_OFF;
+
+	/* UDMA bits off - Revision 0x10 do them in pairs */
+	pci_read_config_byte(hwif->pci_dev, 0x50, &conf);
+	if(itdev->timing10)
+		conf |= channel ? 0x60: 0x18;
+	else
+		conf |= 1 << (3 + 2 * channel + unit);
+	pci_write_config_byte(hwif->pci_dev, 0x50, conf);
+
+	it821x_clock_strategy(drive);
+	/* FIXME: do we need to program this ? */
+	/* it821x_program(drive, itdev->mwdma[unit]); */
+}
+
+/**
+ *	it821x_tune_udma	-	tune a channel for UDMA
+ *	@drive: drive to set up
+ *	@mode_wanted: the target operating mode
+ *
+ *	Load the timing settings for this device mode into the
+ *	controller when doing UDMA modes in pass through.
+ */
+
+static void it821x_tune_udma (ide_drive_t *drive, byte mode_wanted)
+{
+	ide_hwif_t *hwif	= drive->hwif;
+	struct it821x_dev *itdev = ide_get_hwifdata(hwif);
+	int unit = drive->select.b.unit;
+	int channel = hwif->channel;
+	u8 conf;
+
+	static u16 udma[]	= { 0x4433, 0x4231, 0x3121, 0x2121, 0x1111, 0x2211, 0x1111 };
+	static u8 udma_want[]	= { ATA_ANY, ATA_50, ATA_ANY, ATA_66, ATA_66, ATA_50, ATA_66 };
+
+	itdev->want[unit][1] = udma_want[mode_wanted];
+	itdev->want[unit][0] = 3;	/* UDMA is high priority */
+	itdev->mwdma[unit] = MWDMA_OFF;
+	itdev->udma[unit] = udma[mode_wanted];
+	if(mode_wanted >= 5)
+		itdev->udma[unit] |= 0x8080;	/* UDMA 5/6 select on */
+
+	/* UDMA on. Again revision 0x10 must do the pair */
+	pci_read_config_byte(hwif->pci_dev, 0x50, &conf);
+	if(itdev->timing10)
+		conf &= channel ? 0x9F: 0xE7;
+	else
+		conf &= ~ (1 << (3 + 2 * channel + unit));
+	pci_write_config_byte(hwif->pci_dev, 0x50, conf);
+
+	it821x_clock_strategy(drive);
+	it821x_program_udma(drive, itdev->udma[unit]);
+
+}
+
+/**
+ *	config_it821x_chipset_for_pio	-	set drive timings
+ *	@drive: drive to tune
+ *	@speed we want
+ *
+ *	Compute the best pio mode we can for a given device. We must
+ *	pick a speed that does not cause problems with the other device
+ *	on the cable.
+ */
+
+static void config_it821x_chipset_for_pio (ide_drive_t *drive, byte set_speed)
+{
+	u8 unit = drive->select.b.unit;
+	ide_hwif_t *hwif = drive->hwif;
+	ide_drive_t *pair = &hwif->drives[1-unit];
+	u8 speed = 0, set_pio	= ide_get_best_pio_mode(drive, 255, 5, NULL);
+	u8 pair_pio;
+
+	/* We have to deal with this mess in pairs */
+	if(pair != NULL) {
+		pair_pio = ide_get_best_pio_mode(pair, 255, 5, NULL);
+		/* Trim PIO to the slowest of the master/slave */
+		if(pair_pio < set_pio)
+			set_pio = pair_pio;
+	}
+	it821x_tuneproc(drive, set_pio);
+	speed = XFER_PIO_0 + set_pio;
+	/* XXX - We trim to the lowest of the pair so the other drive
+	   will always be fine at this point until we do hotplug passthru */
+
+	if (set_speed)
+		(void) ide_config_drive_speed(drive, speed);
+}
+
+/**
+ *	it821x_dma_read	-	DMA hook
+ *	@drive: drive for DMA
+ *
+ *	The IT821x has a single timing register for MWDMA and for PIO
+ *	operations. As we flip back and forth we have to reload the
+ *	clock. In addition the rev 0x10 device only works if the same
+ *	timing value is loaded into the master and slave UDMA clock
+ * 	so we must also reload that.
+ *
+ *	FIXME: we could figure out in advance if we need to do reloads
+ */
+
+static int it821x_dma_begin(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct it821x_dev *itdev = ide_get_hwifdata(hwif);
+	int unit = drive->select.b.unit;
+	if(itdev->mwdma[unit] != MWDMA_OFF)
+		it821x_program(drive, itdev->mwdma[unit]);
+	else if(itdev->udma[unit] != UDMA_OFF && itdev->timing10)
+		it821x_program_udma(drive, itdev->udma[unit]);
+	return __ide_dma_begin(drive);
+}
+
+/**
+ *	it821x_dma_write	-	DMA hook
+ *	@drive: drive for DMA stop
+ *
+ *	The IT821x has a single timing register for MWDMA and for PIO
+ *	operations. As we flip back and forth we have to reload the
+ *	clock.
+ */
+
+static int it821x_dma_end(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	int unit = drive->select.b.unit;
+	struct it821x_dev *itdev = ide_get_hwifdata(hwif);
+	int ret = __ide_dma_end(drive);
+	if(itdev->mwdma[unit] != MWDMA_OFF)
+		it821x_program(drive, itdev->pio[unit]);
+	return ret;
+}
+
+
+/**
+ *	it821x_tune_chipset	-	set controller timings
+ *	@drive: Drive to set up
+ *	@xferspeed: speed we want to achieve
+ *
+ *	Tune the ITE chipset for the desired mode. If we can't achieve
+ *	the desired mode then tune for a lower one, but ultimately
+ *	make the thing work.
+ */
+
+static int it821x_tune_chipset (ide_drive_t *drive, byte xferspeed)
+{
+
+	ide_hwif_t *hwif	= drive->hwif;
+	struct it821x_dev *itdev = ide_get_hwifdata(hwif);
+	u8 speed		= ide_rate_filter(it821x_ratemask(drive), xferspeed);
+
+	if(!itdev->smart) {
+		switch(speed) {
+			case XFER_PIO_4:
+			case XFER_PIO_3:
+			case XFER_PIO_2:
+			case XFER_PIO_1:
+			case XFER_PIO_0:
+				it821x_tuneproc(drive, (speed - XFER_PIO_0));
+				break;
+			/* MWDMA tuning is really hard because our MWDMA and PIO
+			   timings are kept in the same place. We can switch in the
+			   host dma on/off callbacks */
+			case XFER_MW_DMA_2:
+			case XFER_MW_DMA_1:
+			case XFER_MW_DMA_0:
+				it821x_tune_mwdma(drive, (speed - XFER_MW_DMA_0));
+				break;
+			case XFER_UDMA_6:
+			case XFER_UDMA_5:
+			case XFER_UDMA_4:
+			case XFER_UDMA_3:
+			case XFER_UDMA_2:
+			case XFER_UDMA_1:
+			case XFER_UDMA_0:
+				it821x_tune_udma(drive, (speed - XFER_UDMA_0));
+				break;
+			default:
+				return 1;
+		}
+	}
+	/*
+	 *	In smart mode the clocking is done by the host controller
+	 * 	snooping the mode we picked. The rest of it is not our problem
+	 */
+	return ide_config_drive_speed(drive, speed);
+}
+
+/**
+ *	config_chipset_for_dma	-	configure for DMA
+ *	@drive: drive to configure
+ *
+ *	Called by the IDE layer when it wants the timings set up.
+ */
+
+static int config_chipset_for_dma (ide_drive_t *drive)
+{
+	u8 speed	= ide_dma_speed(drive, it821x_ratemask(drive));
+
+	config_it821x_chipset_for_pio(drive, !speed);
+	it821x_tune_chipset(drive, speed);
+	return ide_dma_enable(drive);
+}
+
+/**
+ *	it821x_configure_drive_for_dma	-	set up for DMA transfers
+ *	@drive: drive we are going to set up
+ *
+ *	Set up the drive for DMA, tune the controller and drive as
+ *	required. If the drive isn't suitable for DMA or we hit
+ *	other problems then we will drop down to PIO and set up
+ *	PIO appropriately
+ */
+
+static int it821x_config_drive_for_dma (ide_drive_t *drive)
+{
+	
+	ide_hwif_t *hwif	= drive->hwif;
+
+	if (__ide_dma_on(drive)) {
+		if (config_chipset_for_dma(drive))
+			return hwif->ide_dma_on(drive);
+	}
+	config_it821x_chipset_for_pio(drive, 1);
+	return hwif->ide_dma_off_quietly(drive);
+	
+}
+
+/**
+ *	ata66_it821x	-	check for 80 pin cable
+ *	@hwif: interface to check
+ *
+ *	Check for the presence of an ATA66 capable cable on the
+ *	interface. Problematic as it seems some cards don't have
+ *	the needed logic onboard.
+ */
+
+static unsigned int __devinit ata66_it821x(ide_hwif_t *hwif)
+{
+	/* The reference driver also only does disk side */
+	return 1;
+}
+
+/**
+ *	it821x_fixup	-	post init callback
+ *	@hwif: interface
+ *
+ *	This callback is run after the drives have been probed but
+ *	before anything gets attached. It allows drivers to do any
+ *	final tuning that is needed, or fixups to work around bugs.
+ */
+
+#if 0 // Udo
+static void __devinit it821x_fixups(ide_hwif_t *hwif)
+{
+	struct it821x_dev *itdev = ide_get_hwifdata(hwif);
+	int i;
+
+	if(!itdev->smart) {
+		/*
+		 *	If we are in pass through mode then not much
+		 *	needs to be done, but we do bother to clear the
+		 *	IRQ mask as we may well be in PIO (eg rev 0x10)
+		 *	for now and we know unmasking is safe on this chipset.
+		 */
+		for (i = 0; i < 2; i++) {
+			ide_drive_t *drive = &hwif->drives[i];
+			if(drive->present)
+				drive->unmask = 1;
+		}
+		return;
+	}
+	/*
+	 *	Perform fixups on smart mode. We need to "lose" some
+	 *	capabilities the firmware lacks but does not filter, and
+	 *	also patch up some capability bits that it forgets to set
+	 *	in RAID mode.
+	 */
+
+	for(i = 0; i < 2; i++) {
+		ide_drive_t *drive = &hwif->drives[i];
+		struct hd_driveid *id;
+		u16 *idbits;
+
+		if(!drive->present)
+			continue;
+		id = drive->id;
+		idbits = (u16 *)drive->id;
+
+		/* Check for RAID v native */
+		if(strstr(id->model, "Integrated Technology Express")) {
+			/* In raid mode the ident block is slightly buggy
+			   We need to set the bits so that the IDE layer knows
+			   LBA28. LBA48 and DMA ar valid */
+			id->capability |= 3;		/* LBA28, DMA */
+			id->command_set_2 |= 0x0400;	/* LBA48 valid */
+			id->cfs_enable_2 |= 0x0400;	/* LBA48 on */
+			/* Reporting logic */
+			printk(KERN_INFO "%s: IT8212 %sRAID %d volume",
+				drive->name,
+				idbits[147] ? "Bootable ":"",
+				idbits[129]);
+				if(idbits[129] != 1)
+					printk("(%dK stripe)", idbits[146]);
+				printk(".\n");
+			/* Now the core code will have wrongly decided no DMA
+			   so we need to fix this */
+			hwif->ide_dma_off_quietly(drive);
+#ifdef CONFIG_IDEDMA_ONLYDISK
+			if (drive->media == ide_disk)
+#endif
+				hwif->ide_dma_check(drive);
+		} else {
+			/* Non RAID volume. Fixups to stop the core code
+			   doing unsupported things */
+			id->field_valid &= 1;
+			id->queue_depth = 0;
+			id->command_set_1 = 0;
+			id->command_set_2 &= 0xC400;
+			id->cfsse &= 0xC000;
+			id->cfs_enable_1 = 0;
+			id->cfs_enable_2 &= 0xC400;
+			id->csf_default &= 0xC000;
+			id->word127 = 0;
+			id->dlf = 0;
+			id->csfo = 0;
+			id->cfa_power = 0;
+			printk(KERN_INFO "%s: Performing identify fixups.\n",
+				drive->name);
+		}
+	}
+
+}
+#endif //udo
+/**
+ *	init_hwif_it821x	-	set up hwif structs
+ *	@hwif: interface to set up
+ *
+ *	We do the basic set up of the interface structure. The IT8212
+ *	requires several custom handlers so we override the default
+ *	ide DMA handlers appropriately
+ */
+
+static void __devinit init_hwif_it821x(ide_hwif_t *hwif)
+{
+	struct it821x_dev *idev = kmalloc(sizeof(struct it821x_dev), GFP_KERNEL);
+	u8 conf;
+
+	if(idev == NULL) {
+		printk(KERN_ERR "it821x: out of memory, falling back to legacy behaviour.\n");
+		goto fallback;
+	}
+	memset(idev, 0, sizeof(struct it821x_dev));
+	ide_set_hwifdata(hwif, idev);
+
+	pci_read_config_byte(hwif->pci_dev, 0x50, &conf);
+	if(conf & 1) {
+		idev->smart = 1;
+		hwif->atapi_dma = 0;
+		/* Long I/O's although allowed in LBA48 space cause the
+		   onboard firmware to enter the twighlight zone */
+		hwif->rqsize = 256;
+	}
+
+	/* Pull the current clocks from 0x50 also */
+	if (conf & (1 << (1 + hwif->channel)))
+		idev->clock_mode = ATA_50;
+	else
+		idev->clock_mode = ATA_66;
+
+	idev->want[0][1] = ATA_ANY;
+	idev->want[1][1] = ATA_ANY;
+
+	/*
+	 *	Not in the docs but according to the reference driver
+	 *	this is neccessary.
+	 */
+
+	pci_read_config_byte(hwif->pci_dev, 0x08, &conf);
+	if(conf == 0x10) {
+		idev->timing10 = 1;
+		hwif->atapi_dma = 0;
+		if(!idev->smart)
+			printk(KERN_WARNING "it821x: Revision 0x10, workarounds activated.\n");
+	}
+
+	hwif->speedproc = &it821x_tune_chipset;
+	hwif->tuneproc	= &it821x_tuneproc;
+
+	/* MWDMA/PIO clock switching for pass through mode */
+	if(!idev->smart) {
+		hwif->ide_dma_begin = &it821x_dma_begin;
+		hwif->ide_dma_end = &it821x_dma_end;
+	}
+
+	hwif->drives[0].autotune = 1;
+	hwif->drives[1].autotune = 1;
+
+	if (!hwif->dma_base)
+		goto fallback;
+
+	hwif->ultra_mask = 0x7f;
+	hwif->mwdma_mask = 0x07;
+	hwif->swdma_mask = 0x07;
+
+	hwif->ide_dma_check = &it821x_config_drive_for_dma;
+	if (!(hwif->udma_four))
+		hwif->udma_four = ata66_it821x(hwif);
+
+	/*
+	 *	The BIOS often doesn't set up DMA on this controller
+	 *	so we always do it.
+	 */
+
+	hwif->autodma = 1;
+	hwif->drives[0].autodma = hwif->autodma;
+	hwif->drives[1].autodma = hwif->autodma;
+	return;
+fallback:
+	hwif->autodma = 0;
+	return;
+}
+
+static void __devinit it8212_disable_raid(struct pci_dev *dev)
+{
+	/* Reset local CPU, and set BIOS not ready */
+	pci_write_config_byte(dev, 0x5E, 0x01);
+
+	/* Set to bypass mode, and reset PCI bus */
+	pci_write_config_byte(dev, 0x50, 0x00);
+	pci_write_config_word(dev, PCI_COMMAND,
+			      PCI_COMMAND_PARITY | PCI_COMMAND_IO |
+			      PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
+	pci_write_config_word(dev, 0x40, 0xA0F3);
+
+	pci_write_config_dword(dev,0x4C, 0x02040204);
+	pci_write_config_byte(dev, 0x42, 0x36);
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0);
+}
+
+static unsigned int __devinit init_chipset_it821x(struct pci_dev *dev, const char *name)
+{
+	u8 conf;
+	static char *mode[2] = { "pass through", "smart" };
+
+	/* Force the card into bypass mode if so requested */
+	if (1) {
+	//if (it8212_noraid) { Udo
+		printk(KERN_INFO "it8212: forcing bypass mode.\n");
+		it8212_disable_raid(dev);
+	}
+	pci_read_config_byte(dev, 0x50, &conf);
+	printk(KERN_INFO "it821x: controller in %s mode.\n", mode[conf & 1]);
+	return 0;
+}
+
+/*
+#define DECLARE_ITE_DEV(name_str)			\
+	{						\
+		.vendor		= PCI_VENDOR_ID_ITE, \
+		.device		= PCI_DEVICE_ID_ITE_8211, \
+		.name		= name_str,		\
+		.init_chipset	= init_chipset_it821x,	\
+		.init_hwif	= init_hwif_it821x,	\
+		.channels	= 2,			\
+		.autodma	= AUTODMA,		\
+		.bootable	= ON_BOARD,		\
+		.fixup	 	= it821x_fixups		\
+	}
+*/
+#define DECLARE_ITE_DEV(name_str,device_id)			\
+	{						\
+		.vendor		= PCI_VENDOR_ID_ITE, \
+		.device		= PCI_DEVICE_ID_ITE_8211, \
+		.name		= name_str,		\
+		.init_chipset	= init_chipset_it821x,	\
+		.init_hwif	= init_hwif_it821x,	\
+		.channels	= 2,			\
+		.autodma	= AUTODMA,		\
+		.bootable	= ON_BOARD		\
+	}
+
+static ide_pci_device_t it821x_chipsets[] __devinitdata = {
+	/* 0 */ DECLARE_ITE_DEV("IT8211",PCI_DEVICE_ID_ITE_8211),
+	/* 1 */ DECLARE_ITE_DEV("IT8212",PCI_DEVICE_ID_ITE_8212),
+};
+
+/**
+ *	it821x_init_one	-	pci layer discovery entry
+ *	@dev: PCI device
+ *	@id: ident table entry
+ *
+ *	Called by the PCI code when it finds an ITE821x controller.
+ *	We then use the IDE PCI generic helper to do most of the work.
+ */
+
+static int __devinit it821x_init_one(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	ide_setup_pci_device(dev, &it821x_chipsets[id->driver_data]);
+	return 0;
+}
+
+static struct pci_device_id it821x_pci_tbl[] = {
+	{ PCI_VENDOR_ID_ITE, PCI_DEVICE_ID_ITE_8211,  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ PCI_VENDOR_ID_ITE, PCI_DEVICE_ID_ITE_8212,  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ 0, },
+};
+
+MODULE_DEVICE_TABLE(pci, it821x_pci_tbl);
+
+static struct pci_driver driver = {
+	.name		= "ITE821x IDE",
+	.id_table	= it821x_pci_tbl,
+	.probe		= it821x_init_one,
+};
+
+static int __init it821x_ide_init(void)
+{
+	return ide_pci_register_driver(&driver);
+}
+
+module_init(it821x_ide_init);
+
+// Udo
+//module_param_named(noraid, it8212_noraid, int, S_IRUGO); 
+//MODULE_PARM_DESC(it8212_noraid, "Force card into bypass mode");
+
+MODULE_AUTHOR("Alan Cox");
+MODULE_DESCRIPTION("PCI driver module for the ITE 821x (Backport to 2.4.31 by Udo Hegel <udo@email.com>)");
+MODULE_LICENSE("GPL");
diff -Naru linux-2.4.32/drivers/mtd/maps/Config.in linux-2.4.32-mct/drivers/mtd/maps/Config.in
--- linux-2.4.32/drivers/mtd/maps/Config.in	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.32-mct/drivers/mtd/maps/Config.in	2006-12-02 15:08:43.000000000 +0100
@@ -63,6 +63,7 @@
       int '    Bus width in octets' CONFIG_MTD_CSTM_MIPS_IXX_BUSWIDTH 2
    fi
    dep_tristate '  Momenco Ocelot boot flash device' CONFIG_MTD_OCELOT $CONFIG_MOMENCO_OCELOT
+   dep_tristate '  Flash chip mapping on MCT board' CONFIG_MTD_MCT $CONFIG_MCT_BOARDS
    dep_tristate '  LASAT flash device' CONFIG_MTD_LASAT $CONFIG_MTD_CFI $CONFIG_LASAT
 fi
 
diff -Naru linux-2.4.32/drivers/mtd/maps/Makefile linux-2.4.32-mct/drivers/mtd/maps/Makefile
--- linux-2.4.32/drivers/mtd/maps/Makefile	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.32-mct/drivers/mtd/maps/Makefile	2006-12-02 15:08:43.000000000 +0100
@@ -61,5 +61,7 @@
 obj-$(CONFIG_MTD_UCLINUX)	+= uclinux.o
 obj-$(CONFIG_MTD_NETtel)	+= nettel.o
 obj-$(CONFIG_MTD_SCB2_FLASH)	+= scb2_flash.o
+obj-$(CONFIG_MTD_MCT)		+= mct.o
+
 
 include $(TOPDIR)/Rules.make
diff -Naru linux-2.4.32/drivers/mtd/maps/mct.c linux-2.4.32-mct/drivers/mtd/maps/mct.c
--- linux-2.4.32/drivers/mtd/maps/mct.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/drivers/mtd/maps/mct.c	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,249 @@
+/*
+ * MCT flash driver
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+
+/* partition_info gives details on the logical partitions that the split the
+ * single flash device into. If the size if zero we use up to the end of the
+ * device. */
+static struct mtd_partition partition_info[] = {
+	{
+		name: "Bootloader",
+		size: 128 * 1024,
+		offset: 0,
+		mask_flags: 0
+	},
+        {
+                name: "Kernel",
+                size: 1088 * 1024,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: 0
+        },
+        {
+                name: "Root",
+#ifdef CONFIG_MCT_SA200
+                size: 5888 * 1024,
+#else		      
+                size: 2048 * 1024,
+#endif		
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: 0
+        },
+        {
+                name: "etc",
+#ifdef CONFIG_MCT_SA200
+                size: 1024 * 1024,
+#else		      
+                size: 768 * 1024,
+#endif		
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: 0
+        },
+	{
+		name: "Reserved",
+		size: 64 * 1024,
+		offset: MTDPART_OFS_APPEND,
+		mask_flags: MTD_WRITEABLE,
+	},
+	{
+		name: "Flash (without Bootloader)",
+#ifdef CONFIG_MCT_SA200
+		size: 8064 * 1024,
+#else		      
+		size: 3968 * 1024,
+#endif		
+		offset: 128 * 1024,
+		mask_flags: 0
+	}
+};
+
+#define NUM_PARTITIONS (sizeof(partition_info) / sizeof(partition_info[0]))
+
+#ifdef CONFIG_MCT_SA200
+#define WINDOW_ADDR 0x1FC00000
+#define WINDOW_SIZE 0x800000
+#define WINDOW_ADDR_2 0x1C000000
+#define WINDOW_SIZE_2 0x800000
+#else
+#define WINDOW_ADDR 0x1FC00000
+#define WINDOW_SIZE 0x400000
+#endif
+
+static struct mtd_info *mymtd;
+
+__u8 mct_flash_read8(struct map_info *map, unsigned long ofs)
+{
+#ifdef CONFIG_MCT_SA200
+	if (ofs >= 0x400000) 
+		return __raw_readb(map->map_priv_2 + ofs - 0x400000);
+	else
+#endif		
+		return __raw_readb(map->map_priv_1 + ofs);
+
+}
+
+__u16 mct_flash_read16(struct map_info *map, unsigned long ofs)
+{
+#ifdef CONFIG_MCT_SA200
+	if (ofs >= 0x400000) 
+		return __raw_readw(map->map_priv_2 + ofs - 0x400000);
+	else
+#endif
+		return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 mct_flash_read32(struct map_info *map, unsigned long ofs)
+{
+#ifdef CONFIG_MCT_SA200
+	if (ofs >= 0x400000) 
+		return __raw_readl(map->map_priv_2 + ofs - 0x400000);
+	else
+#endif		
+		return __raw_readl(map->map_priv_1 + ofs);
+}
+
+void mct_flash_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+#ifdef CONFIG_MCT_SA200
+	if (from >= 0x400000)
+		memcpy_fromio(to, map->map_priv_2 + from - 0x400000, len);
+	else if (from + len >= 0x400000) {
+		ssize_t diff = 0x400000 - from;
+		memcpy_fromio(to, map->map_priv_1 + from, diff);
+		memcpy_fromio(to + diff, map->map_priv_2, len - diff);
+	} else
+#endif
+		memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void mct_flash_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+#ifdef CONFIG_MCT_SA200
+	if (adr >= 0x400000)
+		__raw_writeb(d, map->map_priv_2 + adr - 0x400000);
+	else
+#endif		
+		__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void mct_flash_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+#ifdef CONFIG_MCT_SA200
+	if (adr >= 0x400000)
+		__raw_writew(d, map->map_priv_2 + adr - 0x400000);
+	else
+#endif		
+		__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void mct_flash_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+#ifdef CONFIG_MCT_SA200
+	if (adr >= 0x400000)
+		__raw_writel(d, map->map_priv_2 + adr - 0x400000);
+	else
+#endif		
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void mct_flash_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+#ifdef CONFIG_MCT_SA200
+	if (to >= 0x400000)
+		memcpy_toio(map->map_priv_2 + to - 0x400000, from, len);
+	else if (to + len >= 0x400000) {
+		ssize_t diff = 0x400000 - to;
+		memcpy_toio(map->map_priv_1 + to, from, diff);
+		memcpy_toio(map->map_priv_2, from + diff, len - diff);
+	} else
+#endif		
+		memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info mct_flash_map = {
+	name: "MCT flash memory",
+	size: WINDOW_SIZE,
+	buswidth: 4,
+	read8: mct_flash_read8,
+	read16: mct_flash_read16,
+	read32: mct_flash_read32,
+	copy_from: mct_flash_copy_from,
+	write8: mct_flash_write8,
+	write16: mct_flash_write16,
+	write32: mct_flash_write32,
+	copy_to: mct_flash_copy_to
+};
+
+int __init init_mct_flash(void)
+{
+       	printk(KERN_NOTICE "MCT flash driver (size->0x%X mem->0x%X)\n", WINDOW_SIZE, WINDOW_ADDR);
+	mct_flash_map.map_priv_1 = (unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+#ifdef CONFIG_MCT_SA200
+	mct_flash_map.map_priv_2 = (unsigned long)ioremap(WINDOW_ADDR_2, WINDOW_SIZE_2);
+#endif
+
+	if (!mct_flash_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+
+	mymtd = do_map_probe("cfi_probe", &mct_flash_map);
+	if (!mymtd) {
+	    mct_flash_map.buswidth = 2;
+	
+	    mymtd = do_map_probe("cfi_probe", &mct_flash_map);
+	}
+
+	    
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+
+                /* Create MTD devices for each partition. */
+	        add_mtd_partitions(mymtd, partition_info, NUM_PARTITIONS);
+		
+		return 0;
+	}
+
+	iounmap((void *)mct_flash_map.map_priv_1);
+#ifdef CONFIG_MCT_SA200
+	iounmap((void *)mct_flash_map.map_priv_2);
+#endif
+	return -ENXIO;
+}
+
+static void __exit cleanup_mct_flash(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (mct_flash_map.map_priv_1) {
+		iounmap((void *)mct_flash_map.map_priv_1);
+		mct_flash_map.map_priv_1 = 0;
+	}
+#ifdef CONFIG_MCT_SA200
+	if (mct_flash_map.map_priv_2) {
+		iounmap((void *)mct_flash_map.map_priv_2);
+		mct_flash_map.map_priv_1 = 0;
+	}
+#endif
+}
+
+module_init(init_mct_flash);
+module_exit(cleanup_mct_flash);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andi <andi@void.at>");
+MODULE_DESCRIPTION("MTD map driver for MCT boards");
diff -Naru linux-2.4.32/drivers/pci/Makefile linux-2.4.32-mct/drivers/pci/Makefile
--- linux-2.4.32/drivers/pci/Makefile	2003-08-25 13:44:42.000000000 +0200
+++ linux-2.4.32-mct/drivers/pci/Makefile	2006-12-02 15:08:43.000000000 +0100
@@ -29,6 +29,7 @@
 obj-$(CONFIG_SUPERH) += setup-bus.o setup-irq.o
 obj-$(CONFIG_PPC32) += setup-irq.o
 obj-$(CONFIG_SGI_IP27) += setup-irq.o
+obj-$(CONFIG_MCT_BOARDS) += setup-bus.o setup-irq.o
 
 ifndef CONFIG_X86
 obj-y += syscall.o
diff -Naru linux-2.4.32/include/asm-mips/bootinfo.h linux-2.4.32-mct/include/asm-mips/bootinfo.h
--- linux-2.4.32/include/asm-mips/bootinfo.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/bootinfo.h	2006-12-02 15:08:43.000000000 +0100
@@ -36,6 +36,7 @@
 #define MACH_GROUP_NEC_VR41XX  19 /* NEC Vr41xx based boards/gadgets        */
 #define MACH_GROUP_HP_LJ       20 /* Hewlett Packard LaserJet               */
 #define MACH_GROUP_LASAT       21
+#define MACH_GROUP_MCT         21
 #define MACH_GROUP_TITAN       22 /* PMC-Sierra Titan 			    */
 
 /*
@@ -156,12 +157,23 @@
 #define MACH_TOPAS		1
 #define MACH_JMR		2
 #define MACH_TOSHIBA_JMR3927	3	/* JMR-TX3927 CPU/IO board */
-#define MACH_TOSHIBA_RBTX4927	4
+#define MACH_TOSHIBA_SDB        4       /* R43xx/R49xx CPU board */
+#define MACH_TOSHIBA_TX4927EVB  5       /* TX4927 CPU board */
 #define MACH_TOSHIBA_RBTX4937	5
+#define MACH_TOSHIBA_RBTX4927   6       /* RBTX4927 board */
+#define MACH_TOSHIBA_RBTX4925   7       /* RBTX4925 board */
 #define GROUP_TOSHIBA_NAMES	{ "Pallas", "TopasCE", "JMR", "JMR TX3927", \
 				  "RBTX4927", "RBTX4937" }
 
 /*
+ *  * Valid machtypes for group MCT
+ *   */
+#define MACH_MCT_SG100          0
+#define MACH_MCT_SG600          1
+#define MACH_MCT_SG4100         2
+#define MACH_MCT_SA100          3
+
+/*
  * Valid machtype for group LASAT
  */
 #define MACH_LASAT_100		0	/* Masquerade II/SP100/SP50/SP25 */
diff -Naru linux-2.4.32/include/asm-mips/cpu.h linux-2.4.32-mct/include/asm-mips/cpu.h
--- linux-2.4.32/include/asm-mips/cpu.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/cpu.h	2006-12-02 15:08:43.000000000 +0100
@@ -158,6 +158,7 @@
 #define CPU_VR41XX		41
 #define CPU_R5500		42
 #define CPU_TX49XX		43
+#define CPU_TX39XX              44
 #define CPU_AU1500		44
 #define CPU_20KC		45
 #define CPU_VR4111		46
diff -Naru linux-2.4.32/include/asm-mips/delay.h linux-2.4.32-mct/include/asm-mips/delay.h
--- linux-2.4.32/include/asm-mips/delay.h	2005-01-19 15:10:11.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/delay.h	2006-12-02 15:08:43.000000000 +0100
@@ -10,13 +10,11 @@
 #define _ASM_DELAY_H
 
 #include <linux/config.h>
-#include <linux/param.h>
-
-#include <asm/compiler.h>
 
 extern unsigned long loops_per_jiffy;
 
-static __inline__ void __delay(unsigned long loops)
+extern __inline__ void
+__delay(unsigned long loops)
 {
 	__asm__ __volatile__ (
 		".set\tnoreorder\n"
@@ -28,7 +26,7 @@
 }
 
 /*
- * Division by multiplication: you don't have to worry about
+ * division by multiplication: you don't have to worry about
  * loss of precision.
  *
  * Use only for very small delays ( < 1 msec).  Should probably use a
@@ -37,38 +35,17 @@
  * first constant multiplications gets optimized away if the delay is
  * a constant)
  */
-static __inline__ void __udelay(unsigned long usecs, unsigned long lpj)
+extern __inline__ void __udelay(unsigned long usecs, unsigned long lpj)
 {
 	unsigned long lo;
 
-	/*
-	 * Excessive precission?  Probably ...
-	 */
-	usecs *= (unsigned long) (((0x8000000000000000ULL / (500000 / HZ)) +
-	                           0x80000000ULL) >> 32);
+	usecs *= 0x00068db8;		/* 2**32 / (1000000 / HZ) */
 	__asm__("multu\t%2,%3"
-		: "=h" (usecs), "=l" (lo)
-		: "r" (usecs), "r" (lpj)
-		: GCC_REG_ACCUM);
+		:"=h" (usecs), "=l" (lo)
+		:"r" (usecs),"r" (lpj));
 	__delay(usecs);
 }
 
-static __inline__ void __ndelay(unsigned long nsecs, unsigned long lpj)
-{
-	unsigned long lo;
-
-	/*
-	 * Excessive precission?  Probably ...
-	 */
-	nsecs *= (unsigned long) (((0x8000000000000000ULL / (500000000 / HZ)) +
-	                           0x80000000ULL) >> 32);
-	__asm__("multu\t%2,%3"
-		: "=h" (nsecs), "=l" (lo)
-		: "r" (nsecs), "r" (lpj)
-		: GCC_REG_ACCUM);
-	__delay(nsecs);
-}
-
 #ifdef CONFIG_SMP
 #define __udelay_val cpu_data[smp_processor_id()].udelay_val
 #else
@@ -76,6 +53,5 @@
 #endif
 
 #define udelay(usecs) __udelay((usecs),__udelay_val)
-#define ndelay(nsecs) __ndelay((nsecs),__udelay_val)
 
 #endif /* _ASM_DELAY_H */
diff -Naru linux-2.4.32/include/asm-mips/dma.h linux-2.4.32-mct/include/asm-mips/dma.h
--- linux-2.4.32/include/asm-mips/dma.h	2003-08-25 13:44:43.000000000 +0200
+++ linux-2.4.32-mct/include/asm-mips/dma.h	2006-12-02 15:08:43.000000000 +0100
@@ -75,7 +75,14 @@
  *
  */
 
-#define MAX_DMA_CHANNELS	8
+#if defined(CONFIG_TOSHIBA_BOARDS) || defined(CONFIG_MCT_BOARDS)
+#define MAX_STD_DMA_CHANNELS   8
+#define TXX927_DMA_CHANNEL_START       MAX_STD_DMA_CHANNELS
+#define MAX_TXX927_DMA_CHANNELS        4
+#define MAX_DMA_CHANNELS       (MAX_STD_DMA_CHANNELS + MAX_TXX927_DMA_CHANNELS)
+#else
+#define MAX_DMA_CHANNELS       8
+#endif
 
 /*
  * The maximum address in KSEG0 that we can perform a DMA transfer to on this
diff -Naru linux-2.4.32/include/asm-mips/fdc37m81x.h linux-2.4.32-mct/include/asm-mips/fdc37m81x.h
--- linux-2.4.32/include/asm-mips/fdc37m81x.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/fdc37m81x.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,71 @@
+/*
+ * fdc37m81x.h: Configuration Register Description for the
+ *            SMSC FDC37M81x (SuperIO).
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ */
+
+#ifndef _ASM_FDC37M81X_H
+#define _ASM_FDC37M81X_H
+
+/*
+ * Controll Register Index Values
+ */
+/* Global Config Registers */
+#define FDC37M81x_CONFIG_INDEX	0x00
+#define FDC37M81x_CONFIG_DATA	0x01
+#define FDC37M81x_CONF		0x02
+#define FDC37M81x_INDEX		0x03
+#define FDC37M81x_DNUM		0x07
+#define FDC37M81x_DID		0x20
+#define FDC37M81x_DREV		0x21
+#define FDC37M81x_PCNT		0x22
+#define FDC37M81x_PMGT		0x23
+#define FDC37M81x_OSC		0x24
+#define FDC37M81x_CONFPA0	0x26
+#define FDC37M81x_CONFPA1	0x27
+#define FDC37M81x_TEST4		0x2B
+#define FDC37M81x_TEST5		0x2C
+#define FDC37M81x_TEST1		0x2D
+#define FDC37M81x_TEST2		0x2E
+#define FDC37M81x_TEST3		0x2F
+
+/* Logical device number */
+#define FDC37M81x_SERIAL1	0x04
+#define FDC37M81x_SERIAL2	0x05
+#define FDC37M81x_KBD	0x07
+
+/* Logical Config Registers */
+#define FDC37M81x_ACTIVE	0x30
+#define FDC37M81x_BASEADDR0	0x60
+#define FDC37M81x_BASEADDR1	0x61
+#define FDC37M81x_INT		0x70
+#define FDC37M81x_INT2		0x72
+#define FDC37M81x_MODE		0xF0
+
+#define FDC37M81x_CONFIG_ENTER	0x55
+#define FDC37M81x_CONFIG_EXIT	0xaa
+
+#ifdef __KERNEL__
+#include <asm/io.h>
+
+static inline unsigned char
+fdc37m81x_readb(unsigned long port, unsigned char index)
+{
+	outb(index, port + FDC37M81x_CONFIG_INDEX);
+	return inb(port + FDC37M81x_CONFIG_DATA);
+}
+static inline void
+fdc37m81x_writeb(unsigned long port, unsigned char index, unsigned char data)
+{
+	outb(index, port + FDC37M81x_CONFIG_INDEX);
+	outb(data, port + FDC37M81x_CONFIG_DATA);
+}
+
+#endif
+
+#endif
diff -Naru linux-2.4.32/include/asm-mips/mconfig.h linux-2.4.32-mct/include/asm-mips/mconfig.h
--- linux-2.4.32/include/asm-mips/mconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/mconfig.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,800 @@
+/********************************************************************************
+*
+*	Copyright (c) 2002  Magic Control Technology Co.  All Rights Reserved.
+*
+*	FILE:
+*		mconfig.h
+*
+*	Abstract: 
+*		header file for MCT configuration library
+*		
+*	HISTORY:
+*		2001/12/1	Ethan Wang Created
+*		2002/1/21	Louis Tsai Added
+*	COMMENT:
+*		MAX_XXX		represents the maximun value of some variable
+*		EN_XXX		represents to enable some feature
+*		
+*********************************************************************************/
+
+#ifndef __ASM_MCONFIG_H__
+#define __ASM_MCONFIG_H__
+
+// The next include file should be specified instead of <linux/types.h>
+// because it will generate "redefinition" error message.
+#include <asm/types.h>
+
+#ifdef __KERNEL__
+
+#include <linux/time.h>
+
+#if defined(CONFIG_MCT_SG100)
+#define SG100
+#elif defined(CONFIG_MCT_SG600)
+#define SA100
+#elif defined(CONFIG_MCT_SG4100)
+#define SG4100
+#elif defined(CONFIG_MCT_SA100)
+#define SA100
+#endif
+
+#else
+#include <time.h>
+#endif	// __KERNEL__
+
+
+#ifndef MCT_ES
+#undef 	TRUE
+#undef 	FALSE
+enum { FALSE = 0, TRUE = 1};
+typedef unsigned char	BOOL;
+#endif
+
+// define IP address in network order.
+#define IPADDR(a, b, c, d)	((a) | (b << 8) | (c << 16) | (d << 24))
+
+#define USER_NAME_LEN		21
+#define GROUP_NAME_LEN		21
+#define USER_PASSWD_LEN		11
+#define MAX_GROUP_NUM		512
+#define MAX_USER_NUM		200
+
+#define HOST_NAME_SIZE		64
+#define DOMAIN_NAME_SIZE	30
+#define IPSEC_ID_SIZE		10
+
+#define URL_NAME_SIZE		64
+#define CONN_NAME_SIZE		20
+#define PPPOE_USERNAME_LEN	48
+#define PPPOE_PASSWORD_LEN	12
+#define PPTP_USERNAME_LEN	PPPOE_USERNAME_LEN
+#define PPTP_PASSWORD_LEN	PPPOE_PASSWORD_LEN
+#define SMB_PRINTER_NAME_SIZE	32
+#define SMB_SERVER_STRING_SIZE	32
+#define SMB_WORKGROUP_SIZE	32
+#define ADMIN_PASSWORD_LEN	30
+#define DDNS_USERNAME_LEN	30
+#define DDNS_PASSWORD_LEN	30
+
+// DEFINE MAXIMUN SYSTEM NUMBERS
+#define MAX_DHCP_RANGE_LISTS	10
+#define MAX_MACMAPPING_SIZE	20
+#define MAX_HOSTMAPPING_SIZE	20
+#define MAX_IPSEC_CONNECTIONS	20
+#define MAX_VSERVER_RULES	10
+#define MAX_DHCP_LEASES_RECORDS	((0x4000-8)/sizeof(REG_IP_LEASES))	
+#define MAX_URL_ACCESS_RULES	10
+#define MAX_IP_ACCESS_GROUPS	5
+#define MAX_LOGS_LENGTH		120
+#define MAX_LOGS_NUM		60
+#define MAX_ROUTE_SIZE		5
+
+/* type of external interface interface */
+enum {
+	PUBIF_PPPOE = 1,
+	PUBIF_PPTPC,
+	PUBIF_DHCPC,
+	PUBIF_FIXED,
+};
+
+#define SYSIMAGE_ADDR		0x00020000
+#define SYSIMAGE_SECTOR_SIZE	(64*1024)
+
+/* system image state */
+#define SI_NORMAL	0
+#define SI_LOADING	1
+#define SI_LOADED	2
+#define SI_WRITING	3
+#define SI_COMPLETED	4
+#define SI_ERROR	5
+#define SI_BOOT_LOADED  6
+
+/* error level of event log */
+enum {
+	LEVEL_NORMAL,
+	LEVEL_WARNING,
+	LEVEL_URGENT,
+};
+
+/* ipsec remote host type */
+enum {
+	IPSEC_REMOTE_FIXEDIP,
+	IPSEC_REMOTE_DYNAMICIP,
+	IPSEC_REMOTE_CLIENT,
+};
+
+/* interface token for static route */
+enum {
+	WAN_INTERFACE,
+	LAN_INTERFACE,
+};
+
+typedef struct {
+	char	hostname[20];
+	unsigned char chaddr[6];
+	__u32	yiaddr;
+	__u32	expires;
+} DHCP_OFFERED_ADDR;
+
+typedef struct {
+	unsigned int	state;
+	unsigned char	percentage;
+} FIRMWARE_STATUS;
+
+/* FIRST ARGUMENT TYPE OF "READ_CONFIG" AND "WRITE_CONFIG" */
+enum {
+	MC_NET_CONFIG,
+	MC_IPALIAS_CONFIG,
+	MC_MNAT_CONFIG,
+	MC_DHCP_CONFIG,
+	MC_DHCP_LEASE,
+	MC_MACMAPPING_CONFIG,
+	MC_HOSTMAPPING_CONFIG,
+	MC_ROUTE_CONFIG,
+	MC_PPPOE_CONFIG,
+	MC_IPSEC_CONFIG,
+	MC_PPTP_CONFIG,
+	MC_VSERVER_CONFIG,
+	MC_IP_ACCESS_CONFIG,
+	MC_URL_ACCESS_CONFIG,
+	MC_ANTIHACK_CONFIG,
+	MC_SAMBA_CONFIG,
+	MC_ALARM_CONFIG,
+	MC_ADMIN_CONFIG,
+	MC_DDNS_CONFIG,
+	MC_SNMP_CONFIG,
+	MC_USER_CONFIG,
+	MC_EVENTLOG_CONFIG,
+
+	MC_GET_FWVER,
+	MC_RESET_CONFIG,	// reset to factory settings.
+
+	MC_UPDATE_SYSTEM_START,
+	MC_UPDATE_SYSTEM,
+	MC_UPDATE_SYSTEM_END,
+	
+	MC_UPDATE_STATUS,
+
+	MC_EVENTLOG_GET_CNT,
+	MC_EVENTLOG_GET,
+	MC_EVENTLOG_ADD,
+	MC_EVENTLOG_CLEAR,
+
+	MC_DHCP_ADD_LEASE,
+	MC_DHCP_FIND_LEASE_BY_CHADDR,
+	MC_DHCP_FIND_LEASE_BY_YIADDR,
+	MC_DHCP_CLEAR_LEASE,
+//#if defined(SG600) || defined(NAS100) || defined(SA100)
+	MC_USER,
+	MC_GROUP,
+	MC_SHARE,
+//	MC_USERSHARE,	// update user & group & share block at the same time
+	MC_NFS_CONFIG,
+	MC_IDESMART_CONFIG,
+	MC_MAIL_CONFIG,
+	MC_W3S_CONFIG,
+	MC_TIMEZONE_CONFIG,
+	MC_UPDATE_ALL_PID_TIMEZONE,
+//#endif
+	MC_POWER_DOWN,
+	MC_SWITCH_STATUS,
+	MC_DEFAULT_USR_GRP_SHARE,
+	MC_START_HEARTBEAT,
+	MC_FTP_PORT,
+	MC_UPNP_DEVICE_CONFIG,
+	MC_UPNP_MMS_CONFIG,
+	MC_RWMEM,
+	MC_BPA_CONFIG,
+	MC_PPPOE_MTU,
+	MC_NTP_CONFIG,
+	MC_DPING,
+	MC_SAMBA_LANG,
+};
+
+enum {
+	IDS_SYSTEM_START,	
+	IDS_DHCPC_NO_LEASE,
+	IDS_DHCP_COLLISION,
+	IDS_DHCP_AUTO_ADD_NEW_RANGE, // prevent no legal ip from being assigned to client 
+	IDS_DOS_ATTACK,
+	IDS_IPSEC_CONFLICTING_SETTING,
+
+	IDS_EVENTLOG_NORMAL = 100,
+	IDS_EVENTLOG_WARNING,
+	IDS_EVENTLOG_URGENT,
+	IDS_ONLINE,
+	IDS_OFFLINE,
+	IDS_CONNECT,
+	IDS_DISCONNECT,
+	IDS_DYNAMIC,
+	IDS_PASS,
+	IDS_FAIL,
+	IDS_NOT_SUPPORT,
+	IDS_DISABLE,
+	IDS_UNMOUNTING,
+	IDS_MOUNTING,		
+	IDS_SCANNING,	
+	IDS_FORMATTING,
+	IDS_READY,
+	IDS_IOERR,
+	IDS_MOUNTERR,
+	IDS_UNINITIAL,
+};
+
+
+typedef struct {
+	unsigned long	dest_addr;
+	unsigned int	size;
+	unsigned char 	*buf;
+} MEM_ACCESS;
+
+typedef struct {
+	unsigned int	speed[4];
+	unsigned int	full_duplex[4];
+	unsigned int	linkup[4];
+} SWITCH_STATUS;
+
+/*BASIC NETWORK CONFIGURATION DATA STUCTURE*/
+typedef struct {
+	BOOL	enable_nat;
+	char	hostname[HOST_NAME_SIZE];
+	__u32	private_ip, private_netmask;
+	__u32 	dns0, dns1, dns2;
+	int	public_if;
+
+	// Fixed IP
+	__u32	public_ip, public_netmask;
+	__u32	gateway;
+
+	// DHCP Client
+	__u8	mac[6];
+
+	// PPPoE related settings
+	BOOL	demand;
+	char	username[PPPOE_USERNAME_LEN];
+	char	password[PPPOE_PASSWORD_LEN];
+	int	idle;
+
+	// PPTP Client
+	char	pptp_username[PPTP_USERNAME_LEN];
+	char	pptp_password[PPTP_PASSWORD_LEN];
+	__u32	my_ip;
+	__u32	remote_ip;
+} REG_NET_CONF __attribute__ ((packed));
+
+typedef struct {
+	__u32	alias_ip0, alias_netmask0;
+	__u32	alias_ip1, alias_netmask1;
+	__u32	alias_ip2, alias_netmask2;
+} REG_IPALIAS_CONF __attribute__ ((packed));
+
+typedef struct {
+	__u32   mnat_in_ipstart0,mnat_in_ipstart1;
+	__u32   mnat_ext_ipstart0,mnat_ext_ipstart1;
+	__u8	mnat_in_nm0, mnat_in_nm1;
+	__u8	mnat_ext_end0, mnat_ext_end1;
+} REG_MNAT_CONF __attribute__ ((packed));
+
+/*DHCP CONFIGURATION DATA STUCTURE*/
+
+typedef struct {
+	BOOL	enable;
+	__u32	wins;
+	int	lease_time;		/* max. lease time */
+	int	min_lease_time;		/* min. lease time (obsolete field) */
+	char 	domain_name[DOMAIN_NAME_SIZE];
+	__u32	range_start0, range_end0;
+	__u32	range_start1, range_end1;
+	__u32	range_start2, range_end2;
+	__u32	range_start3, range_end3;
+} REG_DHCP_CONF __attribute__ ((packed));
+
+typedef struct {
+	__u32	ip;
+	time_t	start, end;
+	unsigned char mac[6];
+	char	hostname[20];
+} REG_IP_LEASES __attribute__ ((packed));
+
+typedef struct {
+	int 	lease_count;
+	REG_IP_LEASES item[MAX_DHCP_LEASES_RECORDS];
+} REG_DHCP_LEASE __attribute__ ((packed));
+
+typedef struct {
+	unsigned char hwaddr[6];
+	__u32	ipaddr;
+} REG_MACMAPPING_TABLE;
+
+typedef struct {
+	int	count;
+	REG_MACMAPPING_TABLE table[MAX_MACMAPPING_SIZE];
+} REG_MACMAPPING_CONF;
+
+typedef struct {
+	char	hostname[20];
+	__u32	ipaddr;
+} REG_HOSTMAPPING_TABLE;
+
+typedef struct {
+	int	count;
+	REG_HOSTMAPPING_TABLE table[MAX_HOSTMAPPING_SIZE];
+} REG_HOSTMAPPING_CONF;
+
+typedef struct {
+	__u32	dest_ip;
+	__u32	gateway;
+	__u8	dest_cidr;
+	__u8	metric;
+	__u8	interface;	// unused 
+} REG_ROUTE_ITEM;
+
+typedef struct {
+	BOOL	enable;
+	REG_ROUTE_ITEM	route_entry[MAX_ROUTE_SIZE];
+} REG_ROUTE_CONF;
+
+/*IPSEC CONFIGURATION*/
+typedef struct {
+	char	name[CONN_NAME_SIZE]; 	//connection name
+	char	remote_id[IPSEC_ID_SIZE];
+	__u32	remote_gw;		//remote gateway
+	__u32	remote_subnet;		//remote subnet ip
+	__u32	remote_nm;		//remote subnet mask
+	int	remote_type;		//0: fixed ip gw , 1: dynamic ip gw , 2: client 
+	char	secret_key[65];		//128-bits encrypted
+	unsigned int keylife;		//key life
+	BOOL	bootup;			//established connection while system boot
+} REG_IPSEC_CONNECTION_ITEM __attribute__ ((packed));
+
+typedef struct {
+	BOOL	enable;
+	int  	conn_count;
+	char 	host_id[IPSEC_ID_SIZE];
+	REG_IPSEC_CONNECTION_ITEM conn[MAX_IPSEC_CONNECTIONS]; // allow 20 ipsec connections
+} REG_IPSEC_CONF __attribute__ ((packed));
+
+typedef struct {
+	BOOL	enable;
+	unsigned char serverip,startip,endip;   /*added by louistsai 2003/1/2*/
+} REG_PPTP_CONF __attribute__ ((packed));
+
+/* VIRTUAL SERVER CONFIGURATION*/
+typedef struct {
+	char 	protocol; // 0:TCP , 1:UDP , 2:BOTH
+	__u16	port_end;
+	__u16 	port;
+	__u32	redirect_ip;	
+} REG_VSERVER_POLICY __attribute__ ((packed));
+
+typedef struct {
+	BOOL	enable;
+	REG_VSERVER_POLICY	rule[MAX_VSERVER_RULES];
+} REG_VSERVER_CONF __attribute__ ((packed));
+
+/*URL ACCESS CONFIGURATION*/
+
+typedef struct {
+	BOOL	enable;
+	BOOL	access; 	// unused 
+	char url[MAX_URL_ACCESS_RULES][URL_NAME_SIZE];
+} REG_URL_ACCESS_CONF __attribute__ ((packed));
+
+/*IP_ACCESS_CONFIGURATION*/
+typedef struct {
+	__u32	ip;
+	int	CIDR_mask_no;
+	int	block_port[4];
+	int	block_range_start,block_range_end;
+	char	proto; // 0:TCP , 1: UDP , 2:ALL
+} REG_ACCESS_RULE __attribute__ ((packed));
+
+typedef struct {
+	BOOL 	enable;
+	REG_ACCESS_RULE rule[MAX_IP_ACCESS_GROUPS];	
+} REG_IP_ACCESS_CONF __attribute__ ((packed));
+
+/*SAMBA & PRINTER CONFIGURATION*/
+typedef struct {
+	char 	workgroup[SMB_WORKGROUP_SIZE];
+	char 	printer_name[SMB_PRINTER_NAME_SIZE];
+	char 	server_string[SMB_SERVER_STRING_SIZE];
+} REG_SAMBA_CONF __attribute__ ((packed));
+
+/*ANTI-HACK CONFIGURATION*/
+typedef struct {
+	int	syn_limit, icmp_limit, udp_limit;		// per second to be acceptable for gatway!
+	BOOL	enable;					// firewall enable
+	BOOL	EN_SYNFLOOD, EN_ICMPFLOOD, EN_UDPFLOOD;   // Limit the number of TCP SYN,ICMP,UDP requests
+	BOOL	EN_PING_DEATH;	
+	BOOL	EN_IP_SPOOF;
+	BOOL	EN_PORT_SCAN;
+	BOOL	EN_TEAR_DROP;	
+} REG_ANTIHACK_CONF __attribute__ ((packed));
+
+typedef struct {
+	BOOL 	enable;
+	char 	server[64];
+	char 	admin_email[256];
+	int  	alarm_level;       
+} REG_ALARM_CONF __attribute__ ((packed));
+
+typedef struct {
+	char	password[ADMIN_PASSWORD_LEN];
+	BOOL	enable_ext;
+	int	ext_webport;
+} REG_ADMIN_CONF __attribute__ ((packed));
+
+
+enum {
+	DDNS_DHS = 0,
+	DDNS_DYNDNS,
+	DDNS_DYNS,
+	DDNS_EASYDNS,
+	DDNS_JUSTLINUX,
+	DDNS_ODS,
+	DDNS_PGPOW,
+	DDNS_TZO,
+};
+// unused structure
+typedef struct {
+	BOOL	enable;
+	char	service_type; //0:DHS 1:DYNDNS 2:DYNS 3:EASYDNS 4:JUSTLINUX
+			      //5:ODS 6:PGPOW 7:TZO
+	char	username[DDNS_USERNAME_LEN];
+	char	password[DDNS_PASSWORD_LEN];
+	char	hostname[HOST_NAME_SIZE];
+} REG_DDNS_CONF __attribute__ ((packed));
+
+#define MAX_SNMP_COMMUNITY_LEN 20
+#define MAX_SNMP_CONTACT_LEN 32
+#define MAX_SNMP_LOCATION_LEN 32
+typedef struct {
+	BOOL	enable;	
+	char 	community[MAX_SNMP_COMMUNITY_LEN];
+	char 	contact[MAX_SNMP_CONTACT_LEN];
+	char 	location[MAX_SNMP_LOCATION_LEN];
+} REG_SNMP_CONF __attribute__ ((packed));
+
+
+#define MAX_NFS_MOUNTS 200
+
+typedef struct {
+	int	local_uid,remote_uid;
+	__u32	remote_ip;
+	__u8	mask_no;
+	__u8	type;
+} REG_NFS_CONF_ITEM __attribute__ ((packed));
+
+typedef struct {
+	BOOL enable;	
+	int count;
+	REG_NFS_CONF_ITEM nfs_item[MAX_NFS_MOUNTS];
+} REG_NFS_CONF __attribute__ ((packed));
+
+typedef struct {
+	__u8	local_uid,remote_uid;
+	__u32	remote_ip;
+	__u8	mask_no;
+	__u8	type;
+} OLD_REG_NFS_CONF_ITEM __attribute__ ((packed));
+
+typedef struct {
+	BOOL enable;	
+	int count;
+	OLD_REG_NFS_CONF_ITEM nfs_item[MAX_NFS_MOUNTS];
+} OLD_REG_NFS_CONF __attribute__ ((packed));
+
+
+typedef struct {
+	BOOL enable;
+	unsigned char stimer;
+} REG_IDESMART_CONF __attribute__ ((packed));
+
+
+
+typedef struct {
+	  char name[USER_NAME_LEN];
+	  char passwd[USER_PASSWD_LEN];
+	  unsigned char pptp_ip_offset; /* added by louistsai 2003/1/2 */
+} USER_INFO __attribute__ ((packed));
+
+typedef struct {
+	int	count;
+	USER_INFO user[MAX_USER_NUM];
+} REG_USER_CONF __attribute__ ((packed));
+
+#define collision_ip	u.uevent_collision_ip
+//#define vpn_conn_id	u.vpn_conn_id
+
+typedef struct {
+	unsigned char	level;	
+	unsigned char	msgid;
+	unsigned int	time;
+	union {
+		__u32	uevent_collision_ip;
+		__u8	vpn_conn_id;
+	} u;
+} EVENTLOG_ENTRY __attribute__ ((packed));
+
+typedef struct {
+	int	head, tail;
+	EVENTLOG_ENTRY	eventlog[MAX_LOGS_NUM];
+} REG_EVENTLOG_CONF __attribute__ ((packed));
+
+#define MAX_MAIL_DOMAIN_NAME	100
+typedef struct {
+	BOOL 	enable;
+	char 	domain_name[MAX_MAIL_DOMAIN_NAME];
+	int	user_quota,max_mail_size;
+} REG_MAIL_CONF __attribute__ ((packed));
+
+typedef struct {
+	BOOL 	enable;
+	int	port_num;
+} REG_W3S_CONF __attribute__ ((packed));
+
+typedef struct {
+	BOOL 	enable;
+	char 	username[32];
+	char 	passwd[64];
+} REG_BPA_CONF __attribute__ ((packed));
+
+
+typedef struct {
+	BOOL 	enable;
+	char 	server[64];
+	int	interval;
+} REG_NTP_CONF __attribute__ ((packed));
+
+/* block definition without checksum */
+typedef struct {
+	REG_NET_CONF 		net_conf;
+	REG_IPALIAS_CONF	ipalias_conf;
+	REG_MNAT_CONF		mnat_conf;	
+	REG_DHCP_CONF 		dhcp_conf;
+	REG_MACMAPPING_CONF	macmapping_conf;
+	REG_HOSTMAPPING_CONF	hostmapping_conf;
+	REG_ROUTE_CONF		route_conf;
+	REG_VSERVER_CONF 	vserver_conf;
+	REG_IP_ACCESS_CONF 	ip_access_conf;
+	REG_URL_ACCESS_CONF 	url_access_conf;
+	REG_IPSEC_CONF		ipsec_conf;
+	REG_PPTP_CONF		pptp_conf;
+	REG_SAMBA_CONF		smbprn_conf;
+	REG_ANTIHACK_CONF	antihack_conf;
+	REG_ALARM_CONF		alarm_conf;
+	REG_ADMIN_CONF		admin_conf;
+	REG_DDNS_CONF		ddns_conf;
+	REG_SNMP_CONF		snmp_conf;
+//#if defined(SG600) || defined(NAS100) || defined(SA100)
+	REG_IDESMART_CONF	idesmart_conf;	
+	OLD_REG_NFS_CONF	nfs_conf;
+//#endif
+} GENCONF_BLOCK;
+
+typedef struct {
+	REG_USER_CONF		useraccount_conf;
+} USERACCOUNT_BLOCK;
+
+typedef struct {
+	REG_NFS_CONF		nfs_conf;
+	REG_MAIL_CONF		mail_conf;
+	REG_W3S_CONF		w3s_conf;
+	int			time_zone;
+	int			upnp_device_enable;
+	int			upnp_mms_enable;
+	int			ftp_port_num;
+	REG_BPA_CONF		bpa_conf;
+	int			pppoe_mtu;
+	REG_NTP_CONF		ntp_conf;
+	int			en_dping;
+	int			smb_lang;
+} EXTCONF_BLOCK;
+
+
+typedef struct {
+	REG_DHCP_LEASE 		dhcplease_conf;
+} DHCPLEASE_BLOCK;
+
+typedef struct {
+	REG_EVENTLOG_CONF	eventlog_conf;
+} EVENTLOG_BLOCK;
+
+/* block definition with checksum */
+typedef struct {
+	GENCONF_BLOCK		genconf_block;
+	unsigned int		cksum;
+} GENCONF_CKSUM_BLOCK;
+
+typedef struct {
+	USERACCOUNT_BLOCK	useraccount_block;
+	unsigned int		cksum;
+} USERACCOUNT_CKSUM_BLOCK;
+
+typedef struct {
+	EXTCONF_BLOCK		extconf_block;
+	unsigned int		cksum;
+} EXTCONF_CKSUM_BLOCK;
+
+
+typedef struct {
+	DHCPLEASE_BLOCK		dhcplease_block;
+	unsigned int		cksum;
+} DHCPLEASE_CKSUM_BLOCK;
+
+typedef struct {
+	EVENTLOG_BLOCK		eventlog_block;
+	unsigned int		cksum;
+} EVENTLOG_CKSUM_BLOCK;
+
+//previous user database ,remain here for back compatible 
+
+
+#define MAX_USERS			256
+#define MAX_PASSWORD_LEN		20
+#define MAX_USERNAME_LEN		21
+#define MAX_GROUPS			256
+#define	MAX_GROUPNAME_LEN	 	21
+#define MAX_SHARENAME_LEN	 	13
+#define MAX_SHARES		 	50
+#define MAX_WORKGROUP_NAME_LEN	 	16
+#define MAX_COMPUTER_DESCRIPTION 	41
+
+#define MCT_E2FSCK_SCANNING	1
+#define MCT_E2FSCK_COMPLETE	0
+#define MCT_E2FSCK_CANNOT_FIX	-1
+#define MCT_E2FSCK_NO_DEVICE	-2
+
+#define MCT_HDINIT_PARTITION 	1
+#define MCT_HDINIT_FORMATTING 	2
+#define MCT_HDINIT_COMPLETE	3
+
+#define MCT_E3FORMAT_SHMID	7878
+#define MCT_BRUNCD_SHMID	7879
+
+typedef struct {
+	unsigned char status;
+	int	percent;
+} MCT_HD_PROGRESS;
+
+typedef struct {
+	char	name[MAX_USERNAME_LEN];
+	char	password[MAX_PASSWORD_LEN];
+	__u8	uid;
+} USER_DATA __attribute__ ((packed));
+
+typedef struct {
+	__u32	bitstr[8];	//each bit indicates whether each one buffer in array have been used
+	__u32	pptp_on[8];	//
+	USER_DATA	usrdata[MAX_USERS];
+} USERS __attribute__ ((packed));
+
+typedef struct {
+	char	name[MAX_GROUPNAME_LEN];
+	__u8	gid;
+	__u32	members[8];	//used bitstr to represent each member
+} GROUP_DATA __attribute__ ((packed));
+
+typedef struct {
+	__u32	bitstr[8];	//each bit represents to a unique user ,total 256 bits
+	__u32	pptp_on[8];	//
+	GROUP_DATA	grpdata[MAX_GROUPS];
+} GROUPS __attribute__ ((packed));
+
+typedef struct {
+	char	name[MAX_SHARENAME_LEN];
+	__u8	attr;
+	__u32	r_users[8], r_grps[8];	//used bitstr to represent each member
+	__u32	w_users[8], w_grps[8];	//used bitstr to represent each member
+} SHARE_DATA __attribute__ ((packed));
+
+typedef struct {
+	BOOL		cifs_enable,mac_enable,ftp_enable;
+	char		applezone[MAX_WORKGROUP_NAME_LEN]; 			
+	__u8		count;
+	char		workgrp_name[MAX_WORKGROUP_NAME_LEN];
+	char		computer_des[MAX_COMPUTER_DESCRIPTION];
+	SHARE_DATA	shadata[MAX_SHARES];
+} SHARES __attribute__ ((packed));
+
+typedef struct {
+	USERS	users;
+	GROUPS	groups;
+	SHARES	shares;
+} USERSHARE_BLOCK;
+
+typedef struct {
+	USERSHARE_BLOCK	usershare_block;
+	unsigned int	cksum;
+} USERSHARE_CKSUM_BLOCK;
+
+
+// Definition for Large Account(1024) database
+
+#define LA_MAX_USERS			256	
+//#define LA_MAX_GRP_MEMBERS		200
+
+typedef struct {
+	char	name[MAX_USERNAME_LEN];
+	char	password[MAX_PASSWORD_LEN];
+	__u16	uid;
+} LA_USER_DATA __attribute__ ((packed));
+
+typedef struct {
+	__u32	bitstr[LA_MAX_USERS/32];	//each bit indicates whether each one buffer in array have been used
+	__u32	pptp_on[LA_MAX_USERS/32];	//
+	LA_USER_DATA	usrdata[LA_MAX_USERS];
+} LA_USERS __attribute__ ((packed));
+
+typedef struct {
+	char	name[MAX_GROUPNAME_LEN];
+	__u8	gid;
+	__u32	members[LA_MAX_USERS/32];	//used bitstr to represent each member
+} LA_GROUP_DATA __attribute__ ((packed));
+
+typedef struct {
+	__u32	bitstr[MAX_GROUPS/32];	//each bit represents to a unique user ,total 256 bits
+	__u32	pptp_on[MAX_GROUPS/32];	//
+	LA_GROUP_DATA	grpdata[MAX_GROUPS];
+} LA_GROUPS __attribute__ ((packed));
+
+typedef struct {
+	char	name[MAX_SHARENAME_LEN];
+	__u8	attr;
+	__u32	r_users[LA_MAX_USERS/32], r_grps[MAX_GROUPS/32];	//used bitstr to represent each member
+	__u32	w_users[LA_MAX_USERS/32], w_grps[MAX_GROUPS/32];	//used bitstr to represent each member
+} LA_SHARE_DATA __attribute__ ((packed));
+
+typedef struct {
+	BOOL		cifs_enable,mac_enable,ftp_enable;
+	char		applezone[MAX_WORKGROUP_NAME_LEN]; 			
+	__u8		count;
+	char		workgrp_name[MAX_WORKGROUP_NAME_LEN];
+	char		computer_des[MAX_COMPUTER_DESCRIPTION];
+	LA_SHARE_DATA	shadata[MAX_SHARES];
+} LA_SHARES __attribute__ ((packed));
+
+typedef struct {
+	LA_USERS	users;
+} LA_USERS_BLOCK;
+
+typedef struct {
+	LA_USERS_BLOCK	users_block;
+	unsigned int	cksum;
+} LA_USERS_CKSUM_BLOCK;
+
+typedef struct {
+	LA_GROUPS	groups;
+	LA_SHARES	shares;
+} LA_GRPSHARE_BLOCK;
+
+typedef struct {
+	LA_GRPSHARE_BLOCK	grpshare_block;
+	unsigned int	cksum;
+} LA_GRPSHARE_CKSUM_BLOCK;
+
+
+
+
+#endif	// __ASM_MCONFIG_H__
diff -Naru linux-2.4.32/include/asm-mips/mct-boards/dma.h linux-2.4.32-mct/include/asm-mips/mct-boards/dma.h
--- linux-2.4.32/include/asm-mips/mct-boards/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/mct-boards/dma.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,150 @@
+/*
+ *  linux/arch/mips/toshiba-boards/generic/dma.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ */
+
+#ifndef __ASM_TOSHIBA_BOARDS_DMA_H
+#define __ASM_TOSHIBA_BOARDS_DMA_H
+
+/* TX3927/TX4927 stype DMA controllers */
+
+/* bits for set_txx927_dma_mode() */
+#define TXx927_DMA_CCR_DBINH	0x04000000
+#define TXx927_DMA_CCR_SBINH	0x02000000
+#define TXx927_DMA_CCR_CHRST	0x01000000
+#define TXx927_DMA_CCR_RVBYTE	0x00800000
+#define TXx927_DMA_CCR_ACKPOL	0x00400000
+#define TXx927_DMA_CCR_REQPL	0x00200000
+#define TXx927_DMA_CCR_EGREQ	0x00100000
+#define TXx927_DMA_CCR_CHDN	0x00080000
+#define TXx927_DMA_CCR_DNCTL	0x00060000
+#define TXx927_DMA_CCR_EXTRQ	0x00010000
+#define TXx927_DMA_CCR_INTRQD	0x0000e000
+#define TXx927_DMA_CCR_INTENE	0x00001000
+#define TXx927_DMA_CCR_INTENC	0x00000800
+#define TXx927_DMA_CCR_INTENT	0x00000400
+#define TXx927_DMA_CCR_CHNEN	0x00000200
+#define TXx927_DMA_CCR_XFACT	0x00000100
+#define TXx927_DMA_CCR_XFSZ(order)	(((order) << 2) & 0x0000001c)
+#define TXx927_DMA_CCR_XFSZ_1B	TXx927_DMA_CCR_XFSZ(0)
+#define TXx927_DMA_CCR_XFSZ_1W	TXx927_DMA_CCR_XFSZ(2)
+#define TXx927_DMA_CCR_XFSZ_4W	TXx927_DMA_CCR_XFSZ(4)
+#define TXx927_DMA_CCR_XFSZ_8W	TXx927_DMA_CCR_XFSZ(5)
+#define TXx927_DMA_CCR_XFSZ_16W	TXx927_DMA_CCR_XFSZ(6)
+#define TXx927_DMA_CCR_XFSZ_32W	TXx927_DMA_CCR_XFSZ(7)
+#define TXx927_DMA_CCR_MEMIO	0x00000002
+#define TXx927_DMA_CCR_SNGAD	0x00000001
+
+/* dual address, 1 word size transfer mode */
+#define TXx927_DMA_MODE_DUAL_1W	\
+	(TXx927_DMA_CCR_INTENE|TXx927_DMA_CCR_INTENT|TXx927_DMA_CCR_XFSZ_1W)
+/* Internal I/O, 1 word size transfer mode */
+#define TXx927_DMA_MODE_IIO_1W	\
+	(TXx927_DMA_CCR_EXTRQ|TXx927_DMA_CCR_INTENE|TXx927_DMA_CCR_INTENT|TXx927_DMA_CCR_XFSZ_1W)
+
+/* bits for get_txx927_dma_status() */
+#define TXx927_DMA_STATUS_CHNACT	0x00000100
+#define TXx927_DMA_STATUS_ABCHC	0x00000080
+#define TXx927_DMA_STATUS_NCHNC	0x00000040
+#define TXx927_DMA_STATUS_NTRNFC	0x00000020
+#define TXx927_DMA_STATUS_EXTDN	0x00000010
+#define TXx927_DMA_STATUS_CFERR	0x00000008
+#define TXx927_DMA_STATUS_CHERR	0x00000004
+#define TXx927_DMA_STATUS_DESERR	0x00000002
+#define TXx927_DMA_STATUS_SORERR	0x00000001
+
+/* chained DMA descriptor */
+typedef void* txx927_chdma_desc_t;
+
+struct txx927_dma_ops {
+	void (*init_dma)(unsigned int dmanr);
+	void (*enable_dma)(unsigned int dmanr);
+	void (*disable_dma)(unsigned int dmanr);
+	void (*set_dma_mode)(unsigned int dmanr, unsigned int mode);
+	void (*set_dma_addr)(unsigned int dmanr, unsigned int sa, unsigned int da);
+	void (*set_dma_addr64)(unsigned int dmanr, unsigned long long sa, unsigned long long da);
+	void (*set_dma_count)(unsigned int dmanr, unsigned int count);
+	void (*set_dma_inc)(unsigned int dmanr, unsigned int sai, unsigned int dai);
+	int (*get_dma_residue)(unsigned int dmanr);
+	unsigned int (*get_dma_status)(unsigned int dmanr);
+	void (*clear_dma_status)(unsigned int dmanr);
+	int (*get_dma_irqno)(unsigned int dmanr);
+	/* for chain operation */
+	void (*set_dma_chain)(unsigned int dmanr, txx927_chdma_desc_t cha);
+	txx927_chdma_desc_t (*get_dma_chain)(unsigned int dmanr);
+	void (*set_chdma_mode)(txx927_chdma_desc_t desc, unsigned int mode);
+	void (*set_chdma_addr)(txx927_chdma_desc_t desc, unsigned int sa, unsigned int da);
+	void (*get_chdma_addr)(txx927_chdma_desc_t desc, unsigned int *sa, unsigned int *da);
+	void (*set_chdma_addr64)(txx927_chdma_desc_t desc, unsigned long long sa, unsigned long long da);
+	void (*get_chdma_addr64)(txx927_chdma_desc_t desc, unsigned long long *sa, unsigned long long *da);
+	void (*set_chdma_count)(txx927_chdma_desc_t desc, unsigned int count);
+	void (*get_chdma_count)(txx927_chdma_desc_t desc, unsigned int *count);
+	void (*set_chdma_inc)(txx927_chdma_desc_t desc, unsigned int sai, unsigned int dai);
+	void (*set_chdma_chain)(txx927_chdma_desc_t desc, txx927_chdma_desc_t cha);
+	txx927_chdma_desc_t (*get_chdma_chain)(txx927_chdma_desc_t desc);
+	txx927_chdma_desc_t (*alloc_chdma_cmd)(void);
+	void (*free_chdma_cmd)(txx927_chdma_desc_t desc);
+};
+extern struct txx927_dma_ops *txx927_dma_ops;
+
+#define init_txx927_dma(dmanr) \
+	(*txx927_dma_ops->init_dma)(dmanr)
+#define enable_txx927_dma(dmanr) \
+	(*txx927_dma_ops->enable_dma)(dmanr)
+#define disable_txx927_dma(dmanr) \
+	(*txx927_dma_ops->disable_dma)(dmanr)
+#define set_txx927_dma_mode(dmanr, mode) \
+	(*txx927_dma_ops->set_dma_mode)(dmanr, mode)
+#define set_txx927_dma_addr(dmanr, sa, da) \
+	(*txx927_dma_ops->set_dma_addr)(dmanr, sa, da)
+#define set_txx927_dma_addr64(dmanr, sa, da) \
+	(*txx927_dma_ops->set_dma_addr64)(dmanr, sa, da)
+#define set_txx927_dma_count(dmanr, count) \
+	(*txx927_dma_ops->set_dma_count)(dmanr, count)
+#define set_txx927_dma_inc(dmanr, sai, dai) \
+	(*txx927_dma_ops->set_dma_inc)(dmanr, sai, dai)
+#define get_txx927_dma_residue(dmanr) \
+	(*txx927_dma_ops->get_dma_residue)(dmanr)
+#define get_txx927_dma_status(dmanr) \
+	(*txx927_dma_ops->get_dma_status)(dmanr)
+#define clear_txx927_dma_status(dmanr) \
+	(*txx927_dma_ops->clear_dma_status)(dmanr)
+#define get_txx927_dma_irqno(dmanr) \
+	(*txx927_dma_ops->get_dma_irqno)(dmanr)
+/* for chain operation */
+#define set_txx927_dma_chain(dmanr, cha) \
+	(*txx927_dma_ops->set_dma_chain)(dmanr, cha)
+#define get_txx927_dma_chain(dmanr) \
+	(*txx927_dma_ops->get_dma_chain)(dmanr)
+#define set_txx927_chdma_mode(desc, mode) \
+	(*txx927_dma_ops->set_chdma_mode)(desc, mode)
+#define set_txx927_chdma_addr(desc, sa, da) \
+	(*txx927_dma_ops->set_chdma_addr)(desc, sa, da)
+#define get_txx927_chdma_addr(desc, sa, da) \
+	(*txx927_dma_ops->get_chdma_addr)(desc, sa, da)
+#define set_txx927_chdma_addr64(desc, sa, da) \
+	(*txx927_dma_ops->set_chdma_addr64)(desc, sa, da)
+#define get_txx927_chdma_addr64(desc, sa, da) \
+	(*txx927_dma_ops->get_chdma_addr64)(desc, sa, da)
+#define set_txx927_chdma_count(desc, count) \
+	(*txx927_dma_ops->set_chdma_count)(desc, count)
+#define get_txx927_chdma_count(desc, count) \
+	(*txx927_dma_ops->get_chdma_count)(desc, count)
+#define set_txx927_chdma_inc(desc, sai, dai) \
+	(*txx927_dma_ops->set_chdma_inc)(desc, sai, dai)
+#define set_txx927_chdma_chain(desc, cha) \
+	(*txx927_dma_ops->set_chdma_chain)(desc, cha)
+#define get_txx927_chdma_chain(desc) \
+	(*txx927_dma_ops->get_chdma_chain)(desc)
+#define alloc_txx927_chdma_cmd() \
+	(*txx927_dma_ops->alloc_chdma_cmd)()
+#define free_txx927_chdma_cmd(desc) \
+	(*txx927_dma_ops->free_chdma_cmd)(desc)
+
+#endif /* __ASM_TOSHIBA_BOARDS_DMA_H */
diff -Naru linux-2.4.32/include/asm-mips/mct-boards/irq.h linux-2.4.32-mct/include/asm-mips/mct-boards/irq.h
--- linux-2.4.32/include/asm-mips/mct-boards/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/mct-boards/irq.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,46 @@
+/*
+ *  linux/include/asm-mips/toshiba-boards/irq.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_IRQ_H
+#define __ASM_TOSHIBA_BOARDS_IRQ_H
+
+#ifndef _LANGUAGE_ASSEMBLY
+#include <asm/irq.h>
+
+struct pt_regs;
+
+#ifdef CONFIG_TX_BRANCH_LIKELY_BUG_WORKAROUND
+extern void tx_branch_likely_bug_fixup(struct pt_regs *regs);
+#endif
+#ifdef CONFIG_TX_FPU_C_BUG_WORKAROUND
+extern void tx_fpu_c_bug_fixup(struct pt_regs *regs);
+#endif
+
+struct resource;
+extern int (*toshibaboards_gen_iack)(void);
+extern int toshibaboards_i8259_irqroute(int irq);
+extern int toshibaboards_i8259_irq_setup(int irq);
+
+extern void mips_cpu_irq_init(u32 irq_base);
+extern void tx3927_irq_init(int irq_base);
+extern void tx4927_irq_init(int irq_base);
+extern void tx4925_irq_init(int irq_base);
+extern int tx3927_irq_to_irq(int irq);
+extern int tx4927_irq_to_irq(int irq);
+extern int tx4925_irq_to_irq(int irq);
+
+extern asmlinkage unsigned int do_IRQ(int irq, struct pt_regs *regs);
+extern int (*toshibaboards_irqdispatch)(struct pt_regs *regs);
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+#define NR_ISA_IRQS 16
+
+#endif /* __ASM_TOSHIBA_BOARDS_IRQ_H */
diff -Naru linux-2.4.32/include/asm-mips/mct-boards/jmi39io2.h linux-2.4.32-mct/include/asm-mips/mct-boards/jmi39io2.h
--- linux-2.4.32/include/asm-mips/mct-boards/jmi39io2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/mct-boards/jmi39io2.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,106 @@
+/*
+ * Defines for the TJSYS JMI-3927IO2.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_JMI39IO2_H 
+#define __ASM_TOSHIBA_BOARDS_JMI39IO2_H 
+
+#define JMI39IO2_ISAMEM_BASE(base)	(base)
+#define JMI39IO2_ISAIO_BASE(base)	((base) + 0x01000000)
+#define JMI39IO2_ISAC_BASE(base)	((base) + 0x02000000)
+#define JMI39IO2_LCDVGA_REG_BASE(base)	((base) + 0x03000000)
+#define JMI39IO2_LCDVGA_MEM_BASE(base)	((base) + 0x03800000)
+
+#define JMI39IO2_ISAC_REV_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00000000)
+#define JMI39IO2_ISAC_EINTS_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00200000)
+#define JMI39IO2_ISAC_EINTM_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00300000)
+#define JMI39IO2_ISAC_NMI_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00400000)
+#define JMI39IO2_ISAC_LED_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00500000)
+#define JMI39IO2_ISAC_INTP_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00800000)
+#define JMI39IO2_ISAC_INTS1_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00900000)
+#define JMI39IO2_ISAC_INTS2_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00a00000)
+#define JMI39IO2_ISAC_INTM_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00b00000)
+
+/* bits for ISAC_REV (high byte) */
+#define JMI39IO2_IDT_MASK	0xfc
+#define JMI39IO2_REV_MASK	0x03
+#define JMI39IO2_ISAC_IDT	0x20
+
+/* bits for ISAC_EINTS/ISAC_EINTM (high byte) */
+#define JMI39IO2_ISAC_EINTB_IOCHK	2
+#define JMI39IO2_ISAC_EINTB_BWTH	4
+#define JMI39IO2_ISAC_EINTF_IOCHK	(1 << JMI39IO2_ISAC_EINTB_IOCHK)
+#define JMI39IO2_ISAC_EINTF_BWTH	(1 << JMI39IO2_ISAC_EINTB_BWTH)
+
+/* bits for ISAC_LED (high byte) */
+#define JMI39IO2_ISAC_LED_ISALED	0x01
+#define JMI39IO2_ISAC_LED_USRLED	0x02
+
+#define JMI39IO2_NR_IRQ_ISAC	8
+
+/* bits for ISAC_INTS/ISAC_INTM/ISAC_INTP (high byte) */
+#define JMI39IO2_ISAC_INTB_IRQ5	0
+#define JMI39IO2_ISAC_INTB_IRQKB	1
+#define JMI39IO2_ISAC_INTB_IRQMOUSE	2
+#define JMI39IO2_ISAC_INTB_IRQ4	3
+#define JMI39IO2_ISAC_INTB_IRQ12	4
+#define JMI39IO2_ISAC_INTB_IRQ3	5
+#define JMI39IO2_ISAC_INTB_IRQ10	6
+#define JMI39IO2_ISAC_INTB_ISAER	7
+#define JMI39IO2_ISAC_INTF_IRQ5		(1 << JMI39IO2_ISAC_INTB_IRQ5)
+#define JMI39IO2_ISAC_INTF_IRQKB	(1 << JMI39IO2_ISAC_INTB_IRQKB)
+#define JMI39IO2_ISAC_INTF_IRQMOUSE	(1 << JMI39IO2_ISAC_INTB_IRQMOUSE)
+#define JMI39IO2_ISAC_INTF_IRQ4		(1 << JMI39IO2_ISAC_INTB_IRQ4)
+#define JMI39IO2_ISAC_INTF_IRQ12	(1 << JMI39IO2_ISAC_INTB_IRQ12)
+#define JMI39IO2_ISAC_INTF_IRQ3		(1 << JMI39IO2_ISAC_INTB_IRQ3)
+#define JMI39IO2_ISAC_INTF_IRQ10	(1 << JMI39IO2_ISAC_INTB_IRQ10)
+#define JMI39IO2_ISAC_INTF_ISAER	(1 << JMI39IO2_ISAC_INTB_ISAER)
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+#define jmi39io2_isac_reg_out(d, a)	((*(volatile unsigned char *)(a)) = (d))
+#define jmi39io2_isac_reg_in(a)		(*(volatile unsigned char *)(a))
+
+/* LED macro */
+#define jmi39io2_io_led_set(base, n/*0-3*/)	jmi39io2_isac_reg_out((n), JMI39IO2_ISAC_LED_ADDR(base))
+
+/* DIPSW macro */
+#define jmi39io2_io_dipsw(base)	(jmi39io2_isac_reg_in(JMI39IO2_ISAC_LED_ADDR(base)) >> 4)
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+/* INTs */
+
+/* RTL8019AS 10M Ether (JMI-3927IO2:JPW2:2-3 Short) */
+#define JMI39IO2_INT_ETHER	3
+/* RTL8019AS 10M Ether (JMI-3927IO2:JPW2:1-2 Short) */
+#define JMI39IO2_INT_ETHER_ALT	0
+/* ISAC (ISA, PCMCIA, KEYBOARD, MOUSE) */
+#define JMI39IO2_INT_ISAC	2
+
+/* I/O Ports */
+/* RTL8019AS 10M Ether */
+#define JMI39IO2_ETHER_ADDR(base)	(JMI39IO2_ISAIO_BASE(base) + 0x280)
+#define JMI39IO2_PCMCIA_ADDR(base)	(JMI39IO2_ISAIO_BASE(base) + 0x3e0)
+#define JMI39IO2_KBD_ADDR(base)	(JMI39IO2_ISAIO_BASE(base) + 0x00800060)
+#define JMI39IO2_IDE_ADDR(base)	(JMI39IO2_ISAIO_BASE(base) + 0x001001f0)
+
+#ifndef _LANGUAGE_ASSEMBLY
+extern unsigned long jmi39io2_iob_base;
+extern int jmi39io2_isac_irq_base;
+extern void jmi39io2_init(unsigned long base, int isac_irq);
+#define have_jmi39io2()	(jmi39io2_iob_base != 0)
+extern void jmi39io2_isac_irq_init(void);
+extern int jmi39io2_isac_irqroute(void);
+extern void jmi39io2_kbd_init(void);
+extern void jmi39io2_ide_init(void);
+extern int early_jmi39io2_ether_setup(unsigned long port, int irq);
+extern int early_e1355_setup(unsigned long reg_base, unsigned long fb_base);
+#endif /* _LANGUAGE_ASSEMBLY */
+
+#endif /* __ASM_TOSHIBA_BOARDS_JMI39IO2_H */
diff -Naru linux-2.4.32/include/asm-mips/mct-boards/jmr3927.h linux-2.4.32-mct/include/asm-mips/mct-boards/jmr3927.h
--- linux-2.4.32/include/asm-mips/mct-boards/jmr3927.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/mct-boards/jmr3927.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,206 @@
+/*
+ * Defines for the TJSYS JMR-TX3927
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_JMR3927_H 
+#define __ASM_TOSHIBA_BOARDS_JMR3927_H 
+
+#include <asm/tx3927.h>
+#include <asm/addrspace.h>
+#include <asm/toshiba-boards/irq.h>
+
+/* CS */
+#define JMR3927_ROMCE0	0x1fc00000	/* 4M */
+#define JMR3927_ROMCE1	0x1e000000	/* 4M */
+#define JMR3927_ROMCE2	0x14000000	/* 16M */
+#define JMR3927_ROMCE3	0x10000000	/* 64M */
+#define JMR3927_ROMCE5	0x1d000000	/* 4M */
+#define JMR3927_SDCS0	0x00000000	/* 32M */
+#define JMR3927_SDCS1	0x02000000	/* 32M */
+/* PCI Direct Mappings */
+#define JMR3927_PCIMEM	0x08000000
+#define JMR3927_PCIMEM_SIZE	0x08000000	/* 128M */
+#define JMR3927_PCIIO	0x15000000
+#define JMR3927_PCIIO_SIZE	0x01000000	/* 16M */
+
+/* Address map (virtual address) */
+#define JMR3927_ROM0_BASE	(KSEG1 + JMR3927_ROMCE0)
+#define JMR3927_ROM1_BASE	(KSEG1 + JMR3927_ROMCE1)
+#define JMR3927_IOC_BASE	(KSEG1 + JMR3927_ROMCE2)
+#define JMR3927_IOB_BASE	(KSEG1 + JMR3927_ROMCE3)
+#define JMR3927_JMY1394_BASE	(KSEG1 + JMR3927_ROMCE5)
+#define JMR3927_PREMIER3_BASE	(JMR3927_JMY1394_BASE + 0x00100000)
+#define JMR3927_PCIMEM_BASE	(KSEG1 + JMR3927_PCIMEM)
+#define JMR3927_PCIIO_BASE	(KSEG1 + JMR3927_PCIIO)
+
+#define JMR3927_IOC_REV_ADDR	(JMR3927_IOC_BASE + 0x00000000)
+#define JMR3927_IOC_NVRAMB_ADDR	(JMR3927_IOC_BASE + 0x00010000)
+#define JMR3927_IOC_LED_ADDR	(JMR3927_IOC_BASE + 0x00020000)
+#define JMR3927_IOC_DIPSW_ADDR	(JMR3927_IOC_BASE + 0x00030000)
+#define JMR3927_IOC_BREV_ADDR	(JMR3927_IOC_BASE + 0x00040000)
+#define JMR3927_IOC_DTR_ADDR	(JMR3927_IOC_BASE + 0x00050000)
+#define JMR3927_IOC_INTS1_ADDR	(JMR3927_IOC_BASE + 0x00080000)
+#define JMR3927_IOC_INTS2_ADDR	(JMR3927_IOC_BASE + 0x00090000)
+#define JMR3927_IOC_INTM_ADDR	(JMR3927_IOC_BASE + 0x000a0000)
+#define JMR3927_IOC_INTP_ADDR	(JMR3927_IOC_BASE + 0x000b0000)
+#define JMR3927_IOC_RESET_ADDR	(JMR3927_IOC_BASE + 0x000f0000)
+
+/* bits for IOC_REV/IOC_BREV/ISAC_REV (high byte) */
+#define JMR3927_IDT_MASK	0xfc
+#define JMR3927_REV_MASK	0x03
+#define JMR3927_IOC_IDT		0xe0
+
+/* bits for IOC_INTS1/IOC_INTS2/IOC_INTM/IOC_INTP (high byte) */
+#define JMR3927_IOC_INTB_PCIA	0
+#define JMR3927_IOC_INTB_PCIB	1
+#define JMR3927_IOC_INTB_PCIC	2
+#define JMR3927_IOC_INTB_PCID	3
+#define JMR3927_IOC_INTB_MODEM	4
+#define JMR3927_IOC_INTB_INT6	5
+#define JMR3927_IOC_INTB_INT7	6
+#define JMR3927_IOC_INTB_SOFT	7
+#define JMR3927_IOC_INTF_PCIA	(1 << JMR3927_IOC_INTF_PCIA)
+#define JMR3927_IOC_INTF_PCIB	(1 << JMR3927_IOC_INTB_PCIB)
+#define JMR3927_IOC_INTF_PCIC	(1 << JMR3927_IOC_INTB_PCIC)
+#define JMR3927_IOC_INTF_PCID	(1 << JMR3927_IOC_INTB_PCID)
+#define JMR3927_IOC_INTF_MODEM	(1 << JMR3927_IOC_INTB_MODEM)
+#define JMR3927_IOC_INTF_INT6	(1 << JMR3927_IOC_INTB_INT6)
+#define JMR3927_IOC_INTF_INT7	(1 << JMR3927_IOC_INTB_INT7)
+#define JMR3927_IOC_INTF_SOFT	(1 << JMR3927_IOC_INTB_SOFT)
+
+/* bits for IOC_RESET (high byte) */
+#define JMR3927_IOC_RESET_CPU	1
+#define JMR3927_IOC_RESET_PCI	2
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+#if 0
+#define jmr3927_ioc_reg_out(d, a)	((*(volatile unsigned short *)(a)) = (d) << 8)
+#define jmr3927_ioc_reg_in(a)		(((*(volatile unsigned short *)(a)) >> 8) & 0xff)
+#else
+#if defined(__BIG_ENDIAN)
+#define jmr3927_ioc_reg_out(d, a)	((*(volatile unsigned char *)(a)) = (d))
+#define jmr3927_ioc_reg_in(a)		(*(volatile unsigned char *)(a))
+#elif defined(__LITTLE_ENDIAN)
+#define jmr3927_ioc_reg_out(d, a)	((*(volatile unsigned char *)((a)^1)) = (d))
+#define jmr3927_ioc_reg_in(a)		(*(volatile unsigned char *)((a)^1))
+#else
+#error "No Endian"
+#endif
+#endif
+
+#define jmr3927_have_nvram() \
+	((jmr3927_ioc_reg_in(JMR3927_IOC_REV_ADDR) & JMR3927_IDT_MASK) == JMR3927_IOC_IDT)
+
+/* NVRAM macro */
+#define jmr3927_nvram_in(ofs) \
+	jmr3927_ioc_reg_in(JMR3927_IOC_NVRAMB_ADDR + ((ofs) << 1))
+#define jmr3927_nvram_out(d, ofs) \
+	jmr3927_ioc_reg_out(d, JMR3927_IOC_NVRAMB_ADDR + ((ofs) << 1))
+
+/* LED macro */
+#define jmr3927_led_set(n/*0-16*/)	jmr3927_ioc_reg_out(~(n), JMR3927_IOC_LED_ADDR)
+
+/* DIPSW macro */
+#define jmr3927_dipsw1()	((tx3927_pioptr->din & (1 << 11)) == 0)
+#define jmr3927_dipsw2()	((tx3927_pioptr->din & (1 << 10)) == 0)
+#define jmr3927_dipsw3()	((jmr3927_ioc_reg_in(JMR3927_IOC_DIPSW_ADDR) & 2) == 0)
+#define jmr3927_dipsw4()	((jmr3927_ioc_reg_in(JMR3927_IOC_DIPSW_ADDR) & 1) == 0)
+
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+
+/*
+ * IRQ mappings
+ */
+
+/* These are the virtual IRQ numbers, we divide all IRQ's into
+ * 'spaces', the 'space' determines where and how to enable/disable
+ * that particular IRQ on an JMR machine.  Add new 'spaces' as new
+ * IRQ hardware is supported.
+ */
+#define JMR3927_NR_IRQ_IRC	16	/* On-Chip IRC */
+#define JMR3927_NR_IRQ_IOC	8	/* PCI/MODEM/INT[6:7] */
+#define JMR3927_NR_IRQ_ISAC	8	/* ISA */
+
+
+#define JMR3927_IRQ_IRC	NR_ISA_IRQS
+
+#if 1
+#define JMR3927_IRQ_END 32
+#else
+#define JMR3927_IRQ_IOC	(JMR3927_IRQ_IRC + JMR3927_NR_IRQ_IRC)
+#define JMR3927_IRQ_ISAC	(JMR3927_IRQ_IOC + JMR3927_NR_IRQ_IOC)
+#define JMR3927_IRQ_END	(JMR3927_IRQ_ISAC + JMR3927_NR_IRQ_ISAC)
+#endif
+
+#define JMR3927_IRQ_IS_IRC(irq)	(JMR3927_IRQ_IRC <= (irq) && (irq) < JMR3927_IRQ_IOC)
+#define JMR3927_IRQ_IS_IOC(irq)		(JMR3927_IRQ_IOC <= (irq) && (irq) < JMR3927_IRQ_ISAC)
+#define JMR3927_IRQ_IS_ISAC(irq)	(JMR3927_IRQ_ISAC <= (irq) && (irq) < JMR3927_IRQ_END)
+
+#define JMR3927_IRQ_IRC_INT(ch/*0-5*/)	(JMR3927_IRQ_IRC + TX3927_IR_INT(ch))
+#define JMR3927_IRQ_IRC_SIO(ch)	(JMR3927_IRQ_IRC + TX3927_IR_SIO(ch))
+#define JMR3927_IRQ_IRC_DMA	(JMR3927_IRQ_IRC + TX3927_IR_DMA)
+#define JMR3927_IRQ_IRC_PIO	(JMR3927_IRQ_IRC + TX3927_IR_PIO)
+#define JMR3927_IRQ_IRC_PCI	(JMR3927_IRQ_IRC + TX3927_IR_PCI)
+#define JMR3927_IRQ_IRC_TMR(ch)	(JMR3927_IRQ_IRC + TX3927_IR_TMR(ch))
+#define JMR3927_IRQ_IOC_PCIA	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_PCIA)
+#define JMR3927_IRQ_IOC_PCIB	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_PCIB)
+#define JMR3927_IRQ_IOC_PCIC	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_PCIC)
+#define JMR3927_IRQ_IOC_PCID	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_PCID)
+#define JMR3927_IRQ_IOC_MODEM	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_MODEM)
+#define JMR3927_IRQ_IOC_INT6	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_INT6)
+#define JMR3927_IRQ_IOC_INT7	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_INT7)
+#define JMR3927_IRQ_IOC_SOFT	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_SOFT)
+
+#if 0	/* auto detect */
+/* RTL8019AS 10M Ether (JMI-3927IO2:JPW2:1-2 Short) */
+#define JMR3927_IRQ_IOB_ETHER	JMR3927_IRQ_IRC_INT(0)
+#endif
+/* IOC (PCI, MODEM) */
+#define JMR3927_IRQ_IOCINT	JMR3927_IRQ_IRC_INT(1)
+/* TC35815 100M Ether */
+#define JMR3927_IRQ_ETHER	JMR3927_IRQ_IRC_INT(3)
+/* Clock Tick (10ms) */
+#define JMR3927_IRQ_TICK	JMR3927_IRQ_IRC_TMR(0)
+
+/* IEEE1394 (Note that this may conflicts with RTL8019AS 10M Ether...) */
+#define JMR3927_IRQ_PREMIER3	JMR3927_IRQ_IRC_INT(0)
+
+/* Clocks */
+#define JMR3927_CORECLK	132710400	/* 132.7MHz */
+#define JMR3927_GBUSCLK	(JMR3927_CORECLK / 2)	/* 66.35MHz */
+#define JMR3927_IMCLK	(JMR3927_CORECLK / 4)	/* 33.17MHz */
+
+#define jmr3927_tmrptr		tx3927_tmrptr(0)	/* TMR0 */
+
+
+/*
+ * TX3927 Pin Configuration:
+ *
+ *	PCFG bits		Avail			Dead
+ *	SELSIO[1:0]:11		RXD[1:0], TXD[1:0]	PIO[6:3]
+ *	SELSIOC[0]:1		CTS[0], RTS[0]		INT[5:4]
+ *	SELSIOC[1]:0,SELDSF:0,	GSDAO[0],GPCST[3]	CTS[1], RTS[1],DSF,
+ *	  GDBGE*					  PIO[2:1]
+ *	SELDMA[2]:1		DMAREQ[2],DMAACK[2]	PIO[13:12]
+ *	SELTMR[2:0]:000					TIMER[1:0]
+ *	SELCS:0,SELDMA[1]:0	PIO[11;10]		SDCS_CE[7:6],
+ *							  DMAREQ[1],DMAACK[1]
+ *	SELDMA[0]:1		DMAREQ[0],DMAACK[0]	PIO[9:8]
+ *	SELDMA[3]:1		DMAREQ[3],DMAACK[3]	PIO[15:14]
+ *	SELDONE:1		DMADONE			PIO[7]
+ *
+ * Usable pins are:
+ *	RXD[1;0],TXD[1:0],CTS[0],RTS[0],
+ *	DMAREQ[0,2,3],DMAACK[0,2,3],DMADONE,PIO[0,10,11]
+ *	INT[3:0]
+ */
+
+#endif /* __ASM_TOSHIBA_BOARDS_JMR3927_H */
diff -Naru linux-2.4.32/include/asm-mips/mct-boards/pci.h linux-2.4.32-mct/include/asm-mips/mct-boards/pci.h
--- linux-2.4.32/include/asm-mips/mct-boards/pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/mct-boards/pci.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,23 @@
+/*
+ *  linux/include/asm-mips/toshiba-boards/pci.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_PCI_H
+#define __ASM_TOSHIBA_BOARDS_PCI_H
+
+extern struct resource toshibaboards_pci_io_resource;
+extern struct resource toshibaboards_pci_mem_resource;
+
+struct pci_dev;
+
+extern int (*toshibaboards_pci_map_irq)(struct pci_dev *dev, u8 slot, u8 pin);
+extern void (*toshibaboards_pci66_init)(void);
+extern struct pci_ops *toshibaboards_pci_ops;
+
+#endif /* __ASM_TOSHIBA_BOARDS_PCI_H */
diff -Naru linux-2.4.32/include/asm-mips/mct-boards/pmon.h linux-2.4.32-mct/include/asm-mips/mct-boards/pmon.h
--- linux-2.4.32/include/asm-mips/mct-boards/pmon.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/mct-boards/pmon.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,49 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_PMON_H 
+#define __ASM_TOSHIBA_BOARDS_PMON_H 
+
+#ifndef _LANGUAGE_ASSEMBLY
+struct pmon_vector {
+	int (*read)(int fd, char *buf, int size);
+	int (*write)(int fd, char *buf, int size);
+	int (*open)(char *name, int mode);
+	int (*close)(int fd);
+	int (*ioctl)(int fd, int request, void* arg);
+	int (*printf)(char *fmstr, ...);
+	int (*vsprintf)(char *dst, char *fmtstr, ...);
+	int (*ttctl)(int fd, int op, int ap1, int ap2);
+	void (*exit)(int status);
+	char *(*getenv)(char *name);
+	void (*onintr)(int code, long *dat);
+	void (*flush_cache)(int cache);
+	void (*_exception)(void);
+	int (*_fpstatesz)(void);
+	void (*_fpinit)(void);
+	void *(*_fpstate)(void);
+	void (*cop1)(void);
+	int (*adr2symoff)(char *dst, int value, int width);
+	int (*sym2adr)(long *v, char *label);
+	int (*getclkfreq)(void);
+	void (*_clkinit)(void);
+};
+
+extern struct pmon_vector *pmon_vector;
+
+extern void pmon_printf(char *fmt, ...);
+extern void pmon_halt(void);
+extern void set_pmon_debug_traps(void);
+extern unsigned long toshibaboards_memory_upper;
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+#define PMON_VECTOR	0xbfc00200
+#define PMON_VECTOR_R4K	0xbfc00500 /* with R4KEXCEPTIONS */
+#define PMON_VECTOR_TX39	0xbfc00500 /* with TX39_DEBUG_EXCEPTIONS */
+
+#endif /* __ASM_TOSHIBA_BOARDS_PMON_H */
diff -Naru linux-2.4.32/include/asm-mips/mct-boards/rbtx4925.h linux-2.4.32-mct/include/asm-mips/mct-boards/rbtx4925.h
--- linux-2.4.32/include/asm-mips/mct-boards/rbtx4925.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/mct-boards/rbtx4925.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,277 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_RBTX4925_H 
+#define __ASM_TOSHIBA_BOARDS_RBTX4925_H 
+
+#include <asm/tx4925.h>
+#include <asm/addrspace.h>
+#include <asm/mct-boards/irq.h>
+
+/* CS */
+#if 1
+/* use PMON's setting */
+extern unsigned long rbtx4925_ce_base[8];
+#define RBTX4925_CE0	rbtx4925_ce_base[0]
+#define RBTX4925_CE1	rbtx4925_ce_base[1]
+#define RBTX4925_CE2	rbtx4925_ce_base[2]
+#define RBTX4925_CE3	rbtx4925_ce_base[3]
+#define RBTX4925_CE4	rbtx4925_ce_base[4]
+#define RBTX4925_CE5	rbtx4925_ce_base[5]
+#define RBTX4925_CE6	rbtx4925_ce_base[6]
+#define RBTX4925_CE7	rbtx4925_ce_base[7]
+#else
+#define RBTX4925_CE0	0x1fc00000	/* 16M */
+#define RBTX4925_CE1	0x1e000000	/* 16M */
+#endif
+
+/* Address map */
+#define RBTX4925_FPGA_REG_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00000000)
+#define RBTX4925_BOARD_REV_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00000000)
+#define RBTX4925_FPGA_REV_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00000002)
+#define RBTX4925_CFGA_STAT_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00000004)
+#define RBTX4925_CFGD_STAT_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00000006)
+#define RBTX4925_LED_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00001000)
+#define RBTX4925_DIPSW_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00001002)
+#define RBTX4925_IMASK_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00002000)
+#define RBTX4925_INTPOL_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00002002)
+#define RBTX4925_ISTAT_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00002004)
+#define RBTX4925_IMSTAT_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00002006)
+#define RBTX4925_SOFTINT_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00003000)
+#define RBTX4925_SIODTR_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00003002)
+#define RBTX4925_IMASK2_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00004000)
+#define RBTX4925_INTPOL2_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00004002)
+#define RBTX4925_ISTAT2_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00004004)
+#define RBTX4925_IMSTAT2_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00004006)
+#define RBTX4925_PIOSEL_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00005000)
+#define RBTX4925_SSFDC_WP_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00005002)
+#define RBTX4925_SOFTRESET_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00007000)
+#define RBTX4925_SOFTRESETLOCK_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00007002)
+#define RBTX4925_PCIRESET_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00007004)
+#define RBTX4925_PCMCIA_BASE	(KSEG1 + RBTX4925_CE2 + 0x00010000)
+#define RBTX4925_ETHER_BASE	(KSEG1 + RBTX4925_CE2 + 0x00020000)
+
+/* JMI-TX39IO2 */
+#define RBTX4925_IOB_BASE	(KSEG1 + RBTX4925_CE3)
+
+/* Ethernet port address */
+#define RBTX4925_ETHER_ADDR	(RBTX4925_ETHER_BASE + 0x280)
+
+/* bits for ISTAT/IMASK/IMSTAT */
+#define RBTX4925_INTB_PCID	0
+#define RBTX4925_INTB_PCIC	1
+#define RBTX4925_INTB_PCIB	2
+#define RBTX4925_INTB_PCIA	3
+#define RBTX4925_INTB_DSR	4
+#define RBTX4925_INTB_INT2	5
+#define RBTX4925_INTB_INT3	6
+#define RBTX4925_INTB_SWI	7
+#define RBTX4925_INTF_PCID	(1 << RBTX4925_INTB_PCID)
+#define RBTX4925_INTF_PCIC	(1 << RBTX4925_INTB_PCIC)
+#define RBTX4925_INTF_PCIB	(1 << RBTX4925_INTB_PCIB)
+#define RBTX4925_INTF_PCIA	(1 << RBTX4925_INTB_PCIA)
+#define RBTX4925_INTF_DSR	(1 << RBTX4925_INTB_DSR)
+#define RBTX4925_INTF_INT2	(1 << RBTX4925_INTB_INT2)
+#define RBTX4925_INTF_INT3	(1 << RBTX4925_INTB_INT3)
+#define RBTX4925_INTF_SWI	(1 << RBTX4925_INTB_SWI)
+/* bits for ISTAT2/IMASK2/IMSTAT2 */
+#define RBTX4925_INT2B_PCMCIA	0
+#define RBTX4925_INT2F_PCMCIA	(1 << RBTX4925_INT2B_PCMCIA)
+/* bits for PIOSEL */
+#define RBTX4925_PIOSEL_SIO(ch)	(0x01<<(ch))
+#define RBTX4925_PIOSEL_NOPCTOE	0x04
+#define RBTX4925_PIOSEL_NOSMART	0x08
+#define RBTX4925_PIOSEL_NOACLINK	0x10
+#define RBTX4925_PIOSEL_NOPCMCIA	0x20
+
+#ifndef _LANGUAGE_ASSEMBLY
+#define rbtx4925_board_rev_ptr	\
+	((volatile unsigned char *)RBTX4925_BOARD_REV_ADDR)
+#define rbtx4925_fpga_rev_ptr	\
+	((volatile unsigned char *)RBTX4925_FPGA_REV_ADDR)
+#define rbtx4925_cfga_ptr	\
+	((volatile unsigned char *)RBTX4925_CFGA_ADDR)
+#define rbtx4925_cfgd_ptr	\
+	((volatile unsigned char *)RBTX4925_CFGD_ADDR)
+#define rbtx4925_led_ptr	\
+	((volatile unsigned char *)RBTX4925_LED_ADDR)
+#define rbtx4925_dipsw_ptr	\
+	((volatile unsigned char *)RBTX4925_DIPSW_ADDR)
+#define rbtx4925_imask_ptr	\
+	((volatile unsigned char *)RBTX4925_IMASK_ADDR)
+#define rbtx4925_intpol_ptr	\
+	((volatile unsigned char *)RBTX4925_INTPOL_ADDR)
+#define rbtx4925_istat_ptr	\
+	((volatile unsigned char *)RBTX4925_ISTAT_ADDR)
+#define rbtx4925_imstat_ptr	\
+	((volatile unsigned char *)RBTX4925_IMSTAT_ADDR)
+#define rbtx4925_softint_ptr	\
+	((volatile unsigned char *)RBTX4925_SOFTINT_ADDR)
+#define rbtx4925_siodtr_ptr	\
+	((volatile unsigned char *)RBTX4925_SIODTR_ADDR)
+#define rbtx4925_imask2_ptr	\
+	((volatile unsigned char *)RBTX4925_IMASK2_ADDR)
+#define rbtx4925_intpol2_ptr	\
+	((volatile unsigned char *)RBTX4925_INTPOL2_ADDR)
+#define rbtx4925_istat2_ptr	\
+	((volatile unsigned char *)RBTX4925_ISTAT2_ADDR)
+#define rbtx4925_imstat2_ptr	\
+	((volatile unsigned char *)RBTX4925_IMSTAT2_ADDR)
+#define rbtx4925_piosel_ptr	\
+	((volatile unsigned char *)RBTX4925_PIOSEL_ADDR)
+#define rbtx4925_ssfdc_wp_ptr	\
+	((volatile unsigned char *)RBTX4925_SSFDC_WP_ADDR)
+#define rbtx4925_softreset_ptr	\
+	((volatile unsigned char *)RBTX4925_SOFTRESET_ADDR)
+#define rbtx4925_softresetlock_ptr	\
+	((volatile unsigned char *)RBTX4925_SOFTRESETLOCK_ADDR)
+#define rbtx4925_pcireset_ptr	\
+	((volatile unsigned char *)RBTX4925_PCIRESET_ADDR)
+
+#define rbtx4925_led_on(n)	(*rbtx4925_led_ptr |= 1<<(n))
+#define rbtx4925_led_off(n)	(*rbtx4925_led_ptr = *rbtx4925_led_ptr &~ (1<<(n)))
+#define rbtx4925_led_toggle(n)	(*rbtx4925_led_ptr = *rbtx4925_led_ptr ^(1<<(n)))
+
+/* clock */
+#define RBTX4925_MASTER_CLOCK	20000000 /* 20MHz */
+#define RBTX4925_GBUSCLK	(RBTX4925_MASTER_CLOCK * 4) /* fixed */
+#define RBTX4925_IMCLK		(RBTX4925_GBUSCLK / 2) /* fixed */
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+
+/*
+ * IRQ mappings
+ */
+
+#define RBTX4925_SOFT_INT0	0	/* not used */
+#define RBTX4925_SOFT_INT1	1	/* not used */
+#define RBTX4925_IRC_INT	2
+#define RBTX4925_TIMER_INT	7
+
+/* These are the virtual IRQ numbers, we divide all IRQ's into
+ * 'spaces', the 'space' determines where and how to enable/disable
+ * that particular IRQ on an RBTX4925 machine.  Add new 'spaces' as new
+ * IRQ hardware is supported.
+ */
+#define RBTX4925_NR_IRQ_LOCAL	8
+#define RBTX4925_NR_IRQ_IRC	32	/* On-Chip IRC */
+#define RBTX4925_NR_IRQ_IOC	8
+#define RBTX4925_NR_IRQ_IOC2	8
+#define RBTX4925_NR_IRQ_PCMCIA	8
+#define RBTX4925_NR_IRQ_ISAC	8	/* JMI-TX39IO2 ISA */
+
+#define RBTX4925_IRQ_LOCAL	NR_ISA_IRQS
+#define RBTX4925_IRQ_IRC	(RBTX4925_IRQ_LOCAL + RBTX4925_NR_IRQ_LOCAL)
+#define RBTX4925_IRQ_IOC	(RBTX4925_IRQ_IRC + RBTX4925_NR_IRQ_IRC)
+#define RBTX4925_IRQ_IOC2	(RBTX4925_IRQ_IOC + RBTX4925_NR_IRQ_IOC)
+#define RBTX4925_IRQ_PCMCIA	(RBTX4925_IRQ_IOC2 + RBTX4925_NR_IRQ_IOC2)
+#define RBTX4925_IRQ_ISAC	(RBTX4925_IRQ_PCMCIA + RBTX4925_NR_IRQ_PCMCIA)
+#define RBTX4925_IRQ_END	RBTX4925_IRQ_ISAC
+
+#define RBTX4925_IRQ_LOCAL_SOFT0	(RBTX4925_IRQ_LOCAL + RBTX4925_SOFT_INT0)
+#define RBTX4925_IRQ_LOCAL_SOFT1	(RBTX4925_IRQ_LOCAL + RBTX4925_SOFT_INT0)
+#define RBTX4925_IRQ_LOCAL_IRC	(RBTX4925_IRQ_LOCAL + RBTX4925_IRC_INT)
+#define RBTX4925_IRQ_LOCAL_TIMER	(RBTX4925_IRQ_LOCAL + RBTX4925_TIMER_INT)
+#define RBTX4925_IRQ_IRC_WTOERR	(RBTX4925_IRQ_IRC + TX4925_IR_WTOERR)
+#define RBTX4925_IRQ_IRC_INT(n)	(RBTX4925_IRQ_IRC + TX4925_IR_INT(n))
+#define RBTX4925_IRQ_IRC_NDFMC	(RBTX4925_IRQ_IRC + TX4925_IR_NDFMD)
+#define RBTX4925_IRQ_IRC_SIO(n)	(RBTX4925_IRQ_IRC + TX4925_IR_SIO(n))
+#define RBTX4925_IRQ_IRC_DMA(n)	(RBTX4925_IRQ_IRC + TX4925_IR_DMA(n))
+#define RBTX4925_IRQ_IRC_PIO	(RBTX4925_IRQ_IRC + TX4925_IR_PIO)
+#define RBTX4925_IRQ_IRC_PDMAC	(RBTX4925_IRQ_IRC + TX4925_IR_PDMAC)
+#define RBTX4925_IRQ_IRC_PCIC	(RBTX4925_IRQ_IRC + TX4925_IR_PCIC)
+#define RBTX4925_IRQ_IRC_TMR(n)	(RBTX4925_IRQ_IRC + TX4925_IR_TMR(n))
+#define RBTX4925_IRQ_IRC_SPI	(RBTX4925_IRQ_IRC + TX4925_IR_SPI)
+#define RBTX4925_IRQ_IRC_RTC	(RBTX4925_IRQ_IRC + TX4925_IR_RTC)
+#define RBTX4925_IRQ_IRC_ACLC	(RBTX4925_IRQ_IRC + TX4925_IR_ACLC)
+#define RBTX4925_IRQ_IRC_ACLCPME	(RBTX4925_IRQ_IRC + TX4925_IR_ACLCPME)
+#define RBTX4925_IRQ_IRC_CHI	(RBTX4925_IRQ_IRC + TX4925_IR_CHI)
+#define RBTX4925_IRQ_IRC_PCIERR	(RBTX4925_IRQ_IRC + TX4925_IR_PCIERR)
+#define RBTX4925_IRQ_IRC_PCIPME	(RBTX4925_IRQ_IRC + TX4925_IR_PCIPME)
+#define RBTX4925_IRQ_IOC_PCID	(RBTX4925_IRQ_IOC + RBTX4925_INTB_PCID)
+#define RBTX4925_IRQ_IOC_PCIC	(RBTX4925_IRQ_IOC + RBTX4925_INTB_PCIC)
+#define RBTX4925_IRQ_IOC_PCIB	(RBTX4925_IRQ_IOC + RBTX4925_INTB_PCIB)
+#define RBTX4925_IRQ_IOC_PCIA	(RBTX4925_IRQ_IOC + RBTX4925_INTB_PCIA)
+#define RBTX4925_IRQ_IOC_DSR	(RBTX4925_IRQ_IOC + RBTX4925_INTB_DSR)
+#define RBTX4925_IRQ_IOC_INT2	(RBTX4925_IRQ_IOC + RBTX4925_INTB_INT2)
+#define RBTX4925_IRQ_IOC_INT3	(RBTX4925_IRQ_IOC + RBTX4925_INTB_INT3)
+#define RBTX4925_IRQ_IOC_SWI	(RBTX4925_IRQ_IOC + RBTX4925_INTB_SWI)
+#define RBTX4925_IRQ_IOC_PCMCIA	(RBTX4925_IRQ_IOC2 + RBTX4925_INT2B_PCMCIA)
+
+/* Modem (Do not use this. Set W1 to OPEN and use RBTX4925_IRQ_IOC_DSR */
+/* #define RBTX4925_IRQ_MODEM	RBTX4925_IRQ_IRC_INT(5) */
+/* IOC (PCI, etc) */
+#define RBTX4925_IRQ_IOCINT	RBTX4925_IRQ_IRC_INT(0)
+/* Onboard 10M Ether */
+#define RBTX4925_IRQ_ETHER	RBTX4925_IRQ_IRC_INT(1)
+
+
+/* LinkUp L1121 register definitions */
+#define L1121_IDR1	0x00
+#define L1121_IDR2	0x04
+#define L1121_IDR3	0x08
+#define L1121_IDR4	0x0c
+#define L1121_SR	0x10
+#define L1121_ISR	0x14
+#define L1121_EISR	0x18
+#define L1121_CR1	0x24
+#define L1121_CR2	0x28
+#define L1121_IER	0x2c
+#define L1121_ESNR	0x30
+#define L1121_ITSR	0x34
+#define L1121_ECLR	0x38
+#define L1121_CR3	0x3c
+#define L1121_DACCR	0x40
+#define L1121_DACDR	0x44
+
+#define L1121_IDR1_VAL	0x01
+#define L1121_IDR2_VAL	0x10
+#define L1121_IDR3_VAL	0x12
+#define L1121_IDR4_VAL	0x01
+/* for SR, ISR, EISR, IER, ESNR, ITSR, ECLR */
+#define L1121_CD1	7
+#define L1121_CD2	6
+#define L1121_IOIS16	5 /* IOIS16/WRP */
+#define L1121_VS1	4
+#define L1121_VS2	3
+#define L1121_BVD1	2
+#define L1121_BVD2	1
+#define L1121_RDY	0
+#define L1121_SR_CD1	(1<<L1121_CD1)
+#define L1121_SR_CD2	(1<<L1121_CD2)
+#define L1121_SR_IOIS16	(1<<L1121_IOIS16)
+#define L1121_SR_VS1	(1<<L1121_VS1)
+#define L1121_SR_VS2	(1<<L1121_VS2)
+#define L1121_SR_BVD1	(1<<L1121_BVD1)
+#define L1121_SR_BVD2	(1<<L1121_BVD2)
+#define L1121_SR_RDY	(1<<L1121_RDY)
+#define L1121_CR1_SOE	0x80
+#define L1121_CR1_APOE	0x20
+#define L1121_CR1_RESET	0x10
+#define L1121_CR1_STOE	0x08
+#define L1121_CR1_BIG	0x04
+#define L1121_CR1_IRQP	0x02
+#define L1121_CR1_DIRP	0x01
+#define L1121_CR2_PDCS	0x80
+#define L1121_CR2_RTRIM2	0x40
+#define L1121_CR2_RTRIM1	0x20
+#define L1121_CR2_DISS	0x10
+#define L1121_CR2_S4	0x08
+#define L1121_CR2_S3	0x04
+#define L1121_CR2_S2	0x02
+#define L1121_CR2_S1	0x01
+#define L1121_CR3_MIO	0x10
+#define L1121_CR3_CCDIE	0x08
+#define L1121_CR3_WIRQE	0x04
+#define L1121_CR3_WOR16E	0x02
+#define L1121_CR3_WORWE	0x01
+
+#define L1121_inb(reg)  (*(volatile unsigned char *)(RBTX4925_PCMCIA_BASE + (reg)))
+#define L1121_outb(val, reg)  (*(volatile unsigned char *)(RBTX4925_PCMCIA_BASE + (reg)) = (val))
+
+#endif /* __ASM_TOSHIBA_BOARDS_RBTX4925_H */
diff -Naru linux-2.4.32/include/asm-mips/mct-boards/rbtx4927.h linux-2.4.32-mct/include/asm-mips/mct-boards/rbtx4927.h
--- linux-2.4.32/include/asm-mips/mct-boards/rbtx4927.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/mct-boards/rbtx4927.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,181 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_RBTX4927_H 
+#define __ASM_TOSHIBA_BOARDS_RBTX4927_H 
+
+#include <asm/tx4927.h>
+#include <asm/addrspace.h>
+#include <asm/toshiba-boards/irq.h>
+
+/* CS */
+#if 1
+/* use PMON's setting */
+extern unsigned long rbtx4927_ce_base[8];
+#define RBTX4927_CE0	rbtx4927_ce_base[0]
+#define RBTX4927_CE1	rbtx4927_ce_base[1]
+#define RBTX4927_CE2	rbtx4927_ce_base[2]
+#define RBTX4927_CE3	rbtx4927_ce_base[3]
+#define RBTX4927_CE4	rbtx4927_ce_base[4]
+#define RBTX4927_CE5	rbtx4927_ce_base[5]
+#define RBTX4927_CE6	rbtx4927_ce_base[6]
+#define RBTX4927_CE7	rbtx4927_ce_base[7]
+#else
+#define RBTX4927_CE0	0x1f000000	/* 16M */
+#define RBTX4927_CE1	0x1e000000	/* 16M */
+#define RBTX4927_CE2	0x1c000000	/* 1M */
+#define RBTX4927_CE3	0x10000000	/* 64M */
+#endif
+
+/* Address map */
+#define RBTX4927_FPGA_REG_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00000000)
+#define RBTX4927_BOARD_REV_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00000000)
+#define RBTX4927_FPGA_REV_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00000002)
+#define RBTX4927_LED_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00001000)
+#define RBTX4927_DIPSW_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00001002)
+#define RBTX4927_IMASK_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00002000)
+#define RBTX4927_INTPOL_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00002002)
+#define RBTX4927_ISTAT_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00002004)
+#define RBTX4927_IMSTAT_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00002006)
+#define RBTX4927_SOFTINT_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00003000)
+#define RBTX4927_CFGA_STAT_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00004000)
+#define RBTX4927_CFGD_STAT_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00004002)
+#define RBTX4927_SOFTRESET_ADDR	(KSEG1 + RBTX4927_CE2 + 0x0000f000)
+#define RBTX4927_SOFTRESETLOCK_ADDR	(KSEG1 + RBTX4927_CE2 + 0x0000f002)
+#define RBTX4927_PCIRESET_ADDR	(KSEG1 + RBTX4927_CE2 + 0x0000f006)
+#define RBTX4927_BRAMRTC_BASE	(KSEG1 + RBTX4927_CE2 + 0x00010000)
+#define RBTX4927_ETHER_BASE	(KSEG1 + RBTX4927_CE2 + 0x00020000)
+
+/* JMI-TX39IO2 */
+#define RBTX4927_IOB_BASE	(KSEG1 + RBTX4927_CE3)
+
+/* Ethernet port address */
+#define RBTX4927_ETHER_ADDR	(RBTX4927_ETHER_BASE + 0x280)
+
+/* IEEE1394 board */
+#define RBTX4927_JMY1394_BASE	(KSEG1 + RBTX4927_CE5)
+#define RBTX4927_PREMIER3_BASE	(RBTX4927_JMY1394_BASE + 0x00100000)
+
+/* bits for ISTAT/IMASK/IMSTAT */
+#define RBTX4927_INTB_PCID	0
+#define RBTX4927_INTB_PCIC	1
+#define RBTX4927_INTB_PCIB	2
+#define RBTX4927_INTB_PCIA	3
+#define RBTX4927_INTB_DSR	4
+#define RBTX4927_INTB_SWI	5
+#define RBTX4927_INTF_PCID	(1 << RBTX4927_INTB_PCID)
+#define RBTX4927_INTF_PCIC	(1 << RBTX4927_INTB_PCIC)
+#define RBTX4927_INTF_PCIB	(1 << RBTX4927_INTB_PCIB)
+#define RBTX4927_INTF_PCIA	(1 << RBTX4927_INTB_PCIA)
+#define RBTX4927_INTF_DSR	(1 << RBTX4927_INTB_DSR)
+#define RBTX4927_INTF_SWI	(1 << RBTX4927_INTB_SWI)
+
+#ifndef _LANGUAGE_ASSEMBLY
+#define rbtx4927_board_rev_ptr	\
+	((volatile unsigned char *)RBTX4927_BOARD_REV_ADDR)
+#define rbtx4927_fpga_rev_ptr	\
+	((volatile unsigned char *)RBTX4927_FPGA_REV_ADDR)
+#define rbtx4927_led_ptr	\
+	((volatile unsigned char *)RBTX4927_LED_ADDR)
+#define rbtx4927_dipsw_ptr	\
+	((volatile unsigned char *)RBTX4927_DIPSW_ADDR)
+#define rbtx4927_imask_ptr	\
+	((volatile unsigned char *)RBTX4927_IMASK_ADDR)
+#define rbtx4927_intpol_ptr	\
+	((volatile unsigned char *)RBTX4927_INTPOL_ADDR)
+#define rbtx4927_istat_ptr	\
+	((volatile unsigned char *)RBTX4927_ISTAT_ADDR)
+#define rbtx4927_imstat_ptr	\
+	((volatile unsigned char *)RBTX4927_IMSTAT_ADDR)
+#define rbtx4927_softint_ptr	\
+	((volatile unsigned char *)RBTX4927_SOFTINT_ADDR)
+#define rbtx4927_cfga_ptr	\
+	((volatile unsigned char *)RBTX4927_CFGA_ADDR)
+#define rbtx4927_cfgd_ptr	\
+	((volatile unsigned char *)RBTX4927_CFGD_ADDR)
+#define rbtx4927_softreset_ptr	\
+	((volatile unsigned char *)RBTX4927_SOFTRESET_ADDR)
+#define rbtx4927_softresetlock_ptr	\
+	((volatile unsigned char *)RBTX4927_SOFTRESETLOCK_ADDR)
+#define rbtx4927_pcireset_ptr	\
+	((volatile unsigned char *)RBTX4927_PCIRESET_ADDR)
+#define rbtx4927_bramrtc_ptr	\
+	((volatile unsigned char *)RBTX4927_BRAMRTC_BASE)
+
+#define rbtx4927_led_on(n)	(*rbtx4927_led_ptr |= 1<<(n))
+#define rbtx4927_led_off(n)	(*rbtx4927_led_ptr = *rbtx4927_led_ptr &~ (1<<(n)))
+#define rbtx4927_led_toggle(n)	(*rbtx4927_led_ptr = *rbtx4927_led_ptr ^(1<<(n)))
+
+/* clock */
+extern int rbtx4927_master_clock;
+extern int rbtx4927_gbus_clock;
+#define RBTX4927_GBUSCLK	rbtx4927_gbus_clock
+#define RBTX4927_IMCLK		(RBTX4927_GBUSCLK / 2)
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+
+/*
+ * IRQ mappings
+ */
+
+#define RBTX4927_SOFT_INT0	0	/* not used */
+#define RBTX4927_SOFT_INT1	1	/* not used */
+#define RBTX4927_IRC_INT	2
+#define RBTX4927_TIMER_INT	7
+
+/* These are the virtual IRQ numbers, we divide all IRQ's into
+ * 'spaces', the 'space' determines where and how to enable/disable
+ * that particular IRQ on an RBTX4927 machine.  Add new 'spaces' as new
+ * IRQ hardware is supported.
+ */
+#define RBTX4927_NR_IRQ_LOCAL	8
+#define RBTX4927_NR_IRQ_IRC	32	/* On-Chip IRC */
+#define RBTX4927_NR_IRQ_IOC	8	/* IOC */
+#define RBTX4927_NR_IRQ_ISAC	8	/* JMI-TX39IO2 ISA */
+
+#define RBTX4927_IRQ_LOCAL	NR_ISA_IRQS
+#define RBTX4927_IRQ_IRC	(RBTX4927_IRQ_LOCAL + RBTX4927_NR_IRQ_LOCAL)
+#define RBTX4927_IRQ_IOC	(RBTX4927_IRQ_IRC + RBTX4927_NR_IRQ_IRC)
+#define RBTX4927_IRQ_ISAC	(RBTX4927_IRQ_IOC + RBTX4927_NR_IRQ_IOC)
+#define RBTX4927_IRQ_END	RBTX4927_IRQ_ISAC
+
+#define RBTX4927_IRQ_LOCAL_SOFT0	(RBTX4927_IRQ_LOCAL + RBTX4927_SOFT_INT0)
+#define RBTX4927_IRQ_LOCAL_SOFT1	(RBTX4927_IRQ_LOCAL + RBTX4927_SOFT_INT0)
+#define RBTX4927_IRQ_LOCAL_IRC	(RBTX4927_IRQ_LOCAL + RBTX4927_IRC_INT)
+#define RBTX4927_IRQ_LOCAL_TIMER	(RBTX4927_IRQ_LOCAL + RBTX4927_TIMER_INT)
+#define RBTX4927_IRQ_IRC_ECCERR	(RBTX4927_IRQ_IRC + TX4927_IR_ECCERR)
+#define RBTX4927_IRQ_IRC_WTOERR	(RBTX4927_IRQ_IRC + TX4927_IR_WTOERR)
+#define RBTX4927_IRQ_IRC_INT(n)	(RBTX4927_IRQ_IRC + TX4927_IR_INT(n))
+#define RBTX4927_IRQ_IRC_SIO(n)	(RBTX4927_IRQ_IRC + TX4927_IR_SIO(n))
+#define RBTX4927_IRQ_IRC_DMA(n)	(RBTX4927_IRQ_IRC + TX4927_IR_DMA(n))
+#define RBTX4927_IRQ_IRC_PIO	(RBTX4927_IRQ_IRC + TX4927_IR_PIO)
+#define RBTX4927_IRQ_IRC_PDMAC	(RBTX4927_IRQ_IRC + TX4927_IR_PDMAC)
+#define RBTX4927_IRQ_IRC_PCIC	(RBTX4927_IRQ_IRC + TX4927_IR_PCIC)
+#define RBTX4927_IRQ_IRC_TMR(n)	(RBTX4927_IRQ_IRC + TX4927_IR_TMR(n))
+#define RBTX4927_IRQ_IRC_PCIERR	(RBTX4927_IRQ_IRC + TX4927_IR_PCIERR)
+#define RBTX4927_IRQ_IRC_PCIPMA	(RBTX4927_IRQ_IRC + TX4927_IR_PCIPMA)
+#define RBTX4927_IRQ_IRC_ACLC	(RBTX4927_IRQ_IRC + TX4927_IR_ACLC)
+#define RBTX4927_IRQ_IRC_ACKCPMA	(RBTX4927_IRQ_IRC + TX4927_IR_ACKCPMA)
+#define RBTX4927_IRQ_IOC_PCID	(RBTX4927_IRQ_IOC + RBTX4927_INTB_PCID)
+#define RBTX4927_IRQ_IOC_PCIC	(RBTX4927_IRQ_IOC + RBTX4927_INTB_PCIC)
+#define RBTX4927_IRQ_IOC_PCIB	(RBTX4927_IRQ_IOC + RBTX4927_INTB_PCIB)
+#define RBTX4927_IRQ_IOC_PCIA	(RBTX4927_IRQ_IOC + RBTX4927_INTB_PCIA)
+#define RBTX4927_IRQ_IOC_DSR	(RBTX4927_IRQ_IOC + RBTX4927_INTB_DSR)
+#define RBTX4927_IRQ_IOC_SWI	(RBTX4927_IRQ_IOC + RBTX4927_INTB_SWI)
+
+/* Modem (Do not use this. Set W28 to OPEN and use RBTX4927_IRQ_IOC_DSR */
+/* #define RBTX4927_IRQ_MODEM	RBTX4927_IRQ_IRC_INT(0) */
+/* IOC (PCI, etc) */
+#define RBTX4927_IRQ_IOCINT	RBTX4927_IRQ_IRC_INT(1)
+/* Onboard 10M Ether */
+#define RBTX4927_IRQ_ETHER	RBTX4927_IRQ_IRC_INT(3)
+
+/* IEEE1394 (Note that this may conflicts with JMI-TX39IO2 10M Ether...) */
+#define RBTX4927_IRQ_PREMIER3	RBTX4927_IRQ_IRC_INT(0)
+
+#endif /* __ASM_TOSHIBA_BOARDS_RBTX4927_H */
diff -Naru linux-2.4.32/include/asm-mips/mct-boards/tsdb.h linux-2.4.32-mct/include/asm-mips/mct-boards/tsdb.h
--- linux-2.4.32/include/asm-mips/mct-boards/tsdb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/mct-boards/tsdb.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,275 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1999-2001 Toshiba Corporation
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_TSDB_H 
+#define __ASM_TOSHIBA_BOARDS_TSDB_H 
+
+#include <asm/v320usc.h>
+#include <asm/addrspace.h>
+#include <asm/toshiba-boards/irq.h>
+
+/* LocalBus/PCI address */
+#if 1
+/*
+ * These definitions are differ from "SDB Hardware Specification" because:
+ *	1. MIPS/Linux is hard to use high(>=0x20000000) physaddr.
+ *	2. Many codes assume that 'bus(PCI) address' == 'physical address'.
+ */
+/* SDRAM Aperture */
+#define	TSDB_LB_SDRAM_APERTURE	0x00000000
+#define	TSDB_PCI_SDRAM_APERTURE	TSDB_LB_SDRAM_APERTURE
+#define	TSDB_SDRAM_APERTURE_ADBITS	4	/* 256M(AD[31:28]) */
+/* ROM Aperture */
+#define	TSDB_LB_ROM_APERTURE	0x1c000000
+#define	TSDB_PCI_ROM_APERTURE	0x00000000	/* NOT USED */
+#define	TSDB_ROM_APERTURE_ADBITS	6	/* 64M(AD[31:26]) */
+/* PCU Aperture LB/PCI address */
+#define	TSDB_LB_PCU_APERTURE	0x10000000
+#define	TSDB_PCI_PCU_APERTURE	0x00000000	/* NOT USED */
+#define	TSDB_PCU_APERTURE_ADBITS	5	/* 128M(AD[31:27]) */
+/* USC REG Aperture (64K) */
+#define	TSDB_LB_USCREG_APERTURE	0x18000000
+#define	TSDB_PCI_USCREG_APERTURE	TSDB_LB_USCREG_APERTURE
+/* PCI Aperture  */
+#define	TSDB_LB_PCI_APERTURE_0	0x19000000
+#define	TSDB_PCI_PCI_APERTURE_0	0x00000000
+#define	TSDB_PCI_APERTURE_0_ADBITS	8	/* 16M(AD[31:24]) */
+#define	TSDB_LB_PCI_APERTURE_1	0x08000000
+#define	TSDB_PCI_PCI_APERTURE_1	TSDB_LB_PCI_APERTURE_1
+#define	TSDB_PCI_APERTURE_1_ADBITS	5	/* 128M(AD[31:27]) */
+
+#else	/* definitions in SDB Hardware Specification */
+
+/* SDRAM Aperture */
+#define	TSDB_LB_SDRAM_APERTURE	0x00000000
+#define	TSDB_PCI_SDRAM_APERTURE	0x10000000
+#define	TSDB_SDRAM_APERTURE_ADBITS	4	/* 256M(AD[31:28]) */
+/* ROM Aperture */
+#define	TSDB_LB_ROM_APERTURE	0x1c000000
+#define	TSDB_PCI_ROM_APERTURE	0x00000000	/* NOT USED */
+#define	TSDB_ROM_APERTURE_ADBITS	6	/* 64M(AD[31:26]) */
+/* PCU Aperture */
+#define	TSDB_LB_PCU_APERTURE	0x10000000
+#define	TSDB_PCI_PCU_APERTURE	0x00000000	/* NOT USED */
+#define	TSDB_PCU_APERTURE_ADBITS	5	/* 128M(AD[31:27]) */
+/* USC REG Aperture (64K) */
+#define	TSDB_LB_USCREG_APERTURE	0x18000000
+#define	TSDB_PCI_USCREG_APERTURE	0x02000000
+/* PCI Aperture */
+#define	TSDB_LB_PCI_APERTURE_0	0x1a000000
+#define	TSDB_PCI_PCI_APERTURE_0	0x00000000
+#define	TSDB_PCI_APERTURE_0_ADBITS	7	/* 32M(AD[31:25]) */
+#define	TSDB_LB_PCI_APERTURE_1	0x40000000
+#define	TSDB_PCI_PCI_APERTURE_1	0x40000000
+#define	TSDB_PCI_APERTURE_1_ADBITS	3	/* 512M(AD[31:29) */
+
+#endif
+
+/* Address map */
+#define TSDB_SUPERIO_BASE	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x04000000)
+#define TSDB_BRAMRTC_BASE	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05000000)
+#define TSDB_DIPSW1_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05100000)
+#define TSDB_DIPSW2_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05100010)
+#define TSDB_LED_ADDR		(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05100020)
+#define TSDB_FLASHWP_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05100030)
+#define TSDB_LEDDISP_BASE	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05200000)
+#define TSDB_PCI_ISTAT_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05300000)
+#define TSDB_IOC_ISTAT_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05300010)
+#define TSDB_NMI_ISTAT_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05300020)
+#define TSDB_PCI_IMASK_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05300030)
+#define TSDB_IOC_IMASK_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05300040)
+#define TSDB_SOFTRESET_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05400000)
+#define TSDB_PCIRESET_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05500000)
+#define TSDB_SOFTINT_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05600000)
+#define TSDB_FPGA_REV_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05700000)
+#define TSDB_BOARD_REV_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05700010)
+#define TSDB_ETHER_BASE		(KSEG1 + TSDB_LB_PCU_APERTURE + 0x06000000)
+#define TSDB_USC_BASE		(KSEG1 + TSDB_LB_USCREG_APERTURE)
+
+/* SuperIO Configuration Register */
+#define TSDB_SUPERIO_CONFIG	(TSDB_SUPERIO_BASE + 0x398)
+/* SuperIO SCC base address */
+#define TSDB_UART0_BASE	(TSDB_SUPERIO_BASE + 0x3f8)
+#define TSDB_UART1_BASE	(TSDB_SUPERIO_BASE + 0x2f8)
+#if 1
+#define TSDB_BASE_BAUD	(24000000 / 13 / 16)	/* 24MHz, prescaler:13 */
+#else
+#define TSDB_BASE_BAUD	(14318180 / 13 / 16)	/* 14.318MHz, prescaler:13 */
+#endif
+/* SuperIO Parallel port address (LPTB) */
+#define TSDB_LPT_ADDR	(TSDB_SUPERIO_BASE + 0x378)
+
+/* Ethernet port address */
+#define TSDB_ETHER_ADDR	(TSDB_ETHER_BASE + 0x300)
+
+
+/* bits for DIPSW1 */
+#define	TSDB_DIPSW1_APL5	0x80
+#define	TSDB_DIPSW1_APL4	0x40
+#define	TSDB_DIPSW1_APL3	0x20
+#define	TSDB_DIPSW1_APL2	0x10
+#define	TSDB_DIPSW1_APL1	0x08
+#define	TSDB_DIPSW1_FLASH_WP	0x04	/* System Flash Write Protect */
+#define	TSDB_DIPSW1_COMM	0x02	/* Debug Comm: Serial/Ether */
+#define	TSDB_DIPSW1_BOOTROM	0x01	/* Boot from Boot PROM */
+
+/* bits for DIPSW2 */
+#define	TSDB_DIPSW2_BUSE	0x80	/* Board Usage: CPCI/StandAlone */
+#define	TSDB_DIPSW2_CLOCK_4	0x00	/* 1:4 (reserved at TX43) */
+#define	TSDB_DIPSW2_CLOCK_2_5	0x20	/* 1:2.5 (1:1.5 at TX43) */
+#define	TSDB_DIPSW2_CLOCK_2	0x40	/* 1:2 */
+#define	TSDB_DIPSW2_CLOCK_3	0x60	/* 1:3 */
+#define	TSDB_DIPSW2_CLOCK_MASK	0x60	/* MaskterClock:SystemClock */
+#define	TSDB_DIPSW2_BIGENDIAN	0x10
+#define	TSDB_DIPSW2_BPROM_AC	0x08	/* Boot PROM can be accessed */
+#define	TSDB_DIPSW2_EPROMBOOT	0x04	/* Boot from ROM Emulator */
+#define	TSDB_DIPSW2_EXTROM_AC	0x02	/* Ext. ROM Can be accessed */
+#define	TSDB_DIPSW2_SYSIF_R43	0x01	/* Syscmd type: 43mode/49mode */
+
+/* bits for PCI_ISTAT/PCI_IMASK */
+#define TSDB_INTB_PCI_SERR	0
+#define TSDB_INTB_PCI_PERR	1
+#define TSDB_INTB_PCI_INTD	2
+#define TSDB_INTB_PCI_INTC	3
+#define TSDB_INTB_PCI_INTB	4
+#define TSDB_INTB_PCI_INTA	5
+#define TSDB_INTB_PCI_ENUM	6
+#define TSDB_INTF_PCI_INTA	(1 << TSDB_INTB_PCI_INTA)
+#define TSDB_INTF_PCI_INTB	(1 << TSDB_INTB_PCI_INTB)
+#define TSDB_INTF_PCI_INTC	(1 << TSDB_INTB_PCI_INTC)
+#define TSDB_INTF_PCI_INTD	(1 << TSDB_INTB_PCI_INTD)
+#define TSDB_INTF_PCI_PERR	(1 << TSDB_INTB_PCI_PERR)
+#define TSDB_INTF_PCI_SERR	(1 << TSDB_INTB_PCI_SERR)
+#define TSDB_INTF_PCI_ENUM	(1 << TSDB_INTB_PCI_ENUM)
+
+/* bits for IOC_ISTAT/IOC_IMASK */
+#define TSDB_INTB_IOC_SOFTINT	0
+#define TSDB_INTB_IOC_PUSHSW	1	/* Int. SW */
+#define TSDB_INTB_IOC_PAR	2	/* Parallel Port */
+#define TSDB_INTB_IOC_UART0	3	/* Debug UART */
+#define TSDB_INTB_IOC_UART1	4	/* User UART */
+#define TSDB_INTB_IOC_UART(ch)	(3 + (ch))
+#define TSDB_INTB_IOC_RTC	5
+#define TSDB_INTF_IOC_SOFTINT	(1 << TSDB_INTB_IOC_SOFTINT)
+#define TSDB_INTF_IOC_PUSHSW	(1 << TSDB_INTB_IOC_PUSHSW)
+#define TSDB_INTF_IOC_PAR	(1 << TSDB_INTB_IOC_PAR)
+#define TSDB_INTF_IOC_UART1	(1 << TSDB_INTB_IOC_UART1)
+#define TSDB_INTF_IOC_UART0	(1 << TSDB_INTB_IOC_UART0)
+#define TSDB_INTF_IOC_UART(ch)	(1 << TSDB_INTB_IOC_UART(ch))
+#define TSDB_INTF_IOC_RTC	(1 << TSDB_INTB_IOC_RTC)
+
+/* bits for NMI_ISTAT */
+#define TSDB_INTB_NMI_DEG	1
+#define TSDB_INTB_NMI_NMI	2
+#define TSDB_INTF_NMI_DEG	(1 << TSDB_INTB_NMI_DEG)
+#define TSDB_INTF_NMI_NMI	(1 << TSDB_INTB_NMI_NMI)
+
+#ifndef _LANGUAGE_ASSEMBLY
+#define tsdb_bramrtc_ptr	((volatile unsigned char *)TSDB_BRAMRTC_BASE)
+#define tsdb_dipsw1_ptr		((volatile unsigned char *)TSDB_DIPSW1_ADDR)
+#define tsdb_dipsw2_ptr		((volatile unsigned char *)TSDB_DIPSW2_ADDR)
+#define tsdb_led_ptr		((volatile unsigned char *)TSDB_LED_ADDR)
+#define tsdb_flashwp_ptr	((volatile unsigned char *)TSDB_FLASHWP_ADDR)
+#define tsdb_leddisp_ptr	((volatile unsigned char *)TSDB_LEDDISP_BASE)
+#define tsdb_pci_istat_ptr	((volatile unsigned char *)TSDB_PCI_ISTAT_ADDR)
+#define tsdb_ioc_istat_ptr	((volatile unsigned char *)TSDB_IOC_ISTAT_ADDR)
+#define tsdb_nmi_istat_ptr	((volatile unsigned char *)TSDB_NMI_ISTAT_ADDR)
+#define tsdb_pci_imask_ptr	((volatile unsigned char *)TSDB_PCI_IMASK_ADDR)
+#define tsdb_ioc_imask_ptr	((volatile unsigned char *)TSDB_IOC_IMASK_ADDR)
+#define tsdb_softreset_ptr	((volatile unsigned char *)TSDB_SOFTRESET_ADDR)
+#define tsdb_pcireset_ptr	((volatile unsigned char *)TSDB_PCIRESET_ADDR)
+#define tsdb_softint_ptr	((volatile unsigned char *)TSDB_SOFTINT_ADDR)
+#define tsdb_fpga_rev_ptr	((volatile unsigned char *)TSDB_FPGA_REV_ADDR)
+#define tsdb_board_rev_ptr	((volatile unsigned char *)TSDB_BOARD_REV_ADDR)
+
+#define tsdb_old_rtc()	(*tsdb_fpga_rev_ptr < 9)
+
+#define tsdb_led_on(n)		(*tsdb_led_ptr |= 1<<(n))
+#define tsdb_led_off(n)		(*tsdb_led_ptr = *tsdb_led_ptr &~ (1<<(n)))
+#define tsdb_led_toggle(n)	(*tsdb_led_ptr = *tsdb_led_ptr ^(1<<(n)))
+#define tsdb_leddisp_addr(addr)	(tsdb_leddisp_ptr+((addr)<<2))
+#define tsdb_leddisp_putc(n, c)	(*tsdb_leddisp_addr(0x38|((n)&7)) = (c))
+extern void tsdb_leddisp_puts(const char *s);
+extern void tsdb_leddisp_put(unsigned long val);
+#endif /* _LANGUAGE_ASSEMBLY */
+
+
+/*
+ * MIPS-IRQ mappings
+ *
+ *	USC0	MIPS-IP2(INT0)	USC Internal Interrupt
+ *	USC1	MIPS-IP3(INT1)	PCI Bus Interrupt, ENUM
+ *	ETHER	MIPS-IP5(INT3)	OnBoard Ether
+ *	IOC	MIPS-IP6(INT4)	UART, Parallel, PushSwitch
+ */
+#define TSDB_SOFT_INT0	0	/* not used */
+#define TSDB_SOFT_INT1	1	/* not used */
+#define TSDB_USC_INT	2
+#define TSDB_PCI_INT	3
+#define TSDB_STACK_INT0	4
+#define TSDB_STACK_INT1	5
+#define TSDB_ETHER_INT	5
+#define TSDB_IOC_INT	6
+#define TSDB_TIMER_INT	7
+
+
+/* These are the virtual IRQ numbers, we divide all IRQ's into
+ * 'spaces', the 'space' determines where and how to enable/disable
+ * that particular IRQ on an TSDB machine.  Add new 'spaces' as new
+ * IRQ hardware is supported.
+ */
+#define TSDB_NR_IRQ_LOCAL	8
+#define TSDB_NR_IRQ_PCI		8
+#define TSDB_NR_IRQ_IOC		16
+#define TSDB_NR_IRQ_USC		32
+
+#define TSDB_IRQ_LOCAL	NR_ISA_IRQS
+#define TSDB_IRQ_PCI	(TSDB_IRQ_LOCAL + TSDB_NR_IRQ_LOCAL)
+#define TSDB_IRQ_IOC	(TSDB_IRQ_PCI + TSDB_NR_IRQ_PCI)
+#define TSDB_IRQ_USC	(TSDB_IRQ_IOC + TSDB_NR_IRQ_IOC)
+#define TSDB_IRQ_END	(TSDB_IRQ_USC + TSDB_NR_IRQ_USC)
+#define TSDB_IRQ_IS_LOCAL(irq)	(TSDB_IRQ_LOCAL <= (irq) && (irq) < TSDB_IRQ_PCI)
+#define TSDB_IRQ_IS_PCI(irq)	(TSDB_IRQ_PCI <= (irq) && (irq) < TSDB_IRQ_IOC)
+#define TSDB_IRQ_IS_IOC(irq)	(TSDB_IRQ_IOC <= (irq) && (irq) < TSDB_IRQ_USC)
+#define TSDB_IRQ_IS_USC(irq)	(TSDB_IRQ_USC <= (irq) && (irq) < TSDB_IRQ_END)
+
+#define TSDB_IRQ_LOCAL_SOFT0	(TSDB_IRQ_LOCAL + TSDB_SOFT_INT0)
+#define TSDB_IRQ_LOCAL_SOFT1	(TSDB_IRQ_LOCAL + TSDB_SOFT_INT0)
+#define TSDB_IRQ_LOCAL_USC	(TSDB_IRQ_LOCAL + TSDB_USC_INT)
+#define TSDB_IRQ_LOCAL_PCI	(TSDB_IRQ_LOCAL + TSDB_PCI_INT)
+#define TSDB_IRQ_LOCAL_STACK0	(TSDB_IRQ_LOCAL + TSDB_STACK_INT0)
+#define TSDB_IRQ_LOCAL_STACK1	(TSDB_IRQ_LOCAL + TSDB_STACK_INT1)
+#define TSDB_IRQ_LOCAL_ETHER	(TSDB_IRQ_LOCAL + TSDB_ETHER_INT)
+#define TSDB_IRQ_LOCAL_IOC	(TSDB_IRQ_LOCAL + TSDB_IOC_INT)
+#define TSDB_IRQ_LOCAL_TIMER	(TSDB_IRQ_LOCAL + TSDB_TIMER_INT)
+#define TSDB_IRQ_PCI_INTA	(TSDB_IRQ_PCI + TSDB_INTB_PCI_INTA)
+#define TSDB_IRQ_PCI_INTB	(TSDB_IRQ_PCI + TSDB_INTB_PCI_INTB)
+#define TSDB_IRQ_PCI_INTC	(TSDB_IRQ_PCI + TSDB_INTB_PCI_INTC)
+#define TSDB_IRQ_PCI_INTD	(TSDB_IRQ_PCI + TSDB_INTB_PCI_INTD)
+#define TSDB_IRQ_PCI_PERR	(TSDB_IRQ_PCI + TSDB_INTB_PCI_PERR)
+#define TSDB_IRQ_PCI_SERR	(TSDB_IRQ_PCI + TSDB_INTB_PCI_SERR)
+#define TSDB_IRQ_PCI_ENUM	(TSDB_IRQ_PCI + TSDB_INTB_PCI_ENUM)
+#define TSDB_IRQ_IOC_SOFTINT	(TSDB_IRQ_IOC + TSDB_INTB_IOC_SOFTINT)
+#define TSDB_IRQ_IOC_PUSHSW	(TSDB_IRQ_IOC + TSDB_INTB_IOC_PUSHSW)
+#define TSDB_IRQ_IOC_PAR	(TSDB_IRQ_IOC + TSDB_INTB_IOC_PAR)
+#define TSDB_IRQ_IOC_UART0	(TSDB_IRQ_IOC + TSDB_INTB_IOC_UART0)
+#define TSDB_IRQ_IOC_UART1	(TSDB_IRQ_IOC + TSDB_INTB_IOC_UART1)
+#define TSDB_IRQ_IOC_UART(ch)	(TSDB_IRQ_IOC + TSDB_INTB_IOC_UART(ch))
+#define TSDB_IRQ_USC_TIMER0	(TSDB_IRQ_USC + USC_INTB_TIMER0)
+#define TSDB_IRQ_USC_TIMER1	(TSDB_IRQ_USC + USC_INTB_TIMER1)
+#define TSDB_IRQ_USC_DMA0	(TSDB_IRQ_USC + USC_INTB_DMA0)
+#define TSDB_IRQ_USC_DMA1	(TSDB_IRQ_USC + USC_INTB_DMA1)
+#define TSDB_IRQ_USC_HBI	(TSDB_IRQ_USC + USC_INTB_HBI)
+#define TSDB_IRQ_USC_WDI	(TSDB_IRQ_USC + USC_INTB_WDI)
+#define TSDB_IRQ_USC_BWI	(TSDB_IRQ_USC + USC_INTB_BWI)
+#define TSDB_IRQ_USC_PSLAVE_PI	(TSDB_IRQ_USC + USC_INTB_PSLAVE_PI)
+#define TSDB_IRQ_USC_PMASTER_PI	(TSDB_IRQ_USC + USC_INTB_PMASTER_PI)
+#define TSDB_IRQ_USC_PCI_T_ABORT	(TSDB_IRQ_USC + USC_INTB_PCI_T_ABORT)
+#define TSDB_IRQ_USC_PCI_M_ABORT	(TSDB_IRQ_USC + USC_INTB_PCI_M_ABORT)
+#define TSDB_IRQ_USC_DRAM_PI	(TSDB_IRQ_USC + USC_INTB_DRAM_PI)
+
+#endif /* __ASM_TOSHIBA_BOARDS_TSDB_H */
diff -Naru linux-2.4.32/include/asm-mips/mct-boards/tx4927evb.h linux-2.4.32-mct/include/asm-mips/mct-boards/tx4927evb.h
--- linux-2.4.32/include/asm-mips/mct-boards/tx4927evb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/mct-boards/tx4927evb.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,275 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_TX4927EVB_H 
+#define __ASM_TOSHIBA_BOARDS_TX4927EVB_H 
+
+#include <asm/tx4927.h>
+#include <asm/addrspace.h>
+#include <asm/toshiba-boards/irq.h>
+
+/* CS */
+#if 1
+/* use PMON's setting */
+extern unsigned long tx4927evb_ce_base[8];
+#define TX4927EVB_CE0	tx4927evb_ce_base[0]
+#define TX4927EVB_CE1	tx4927evb_ce_base[1]
+#define TX4927EVB_CE2	tx4927evb_ce_base[2]
+#define TX4927EVB_CE3	tx4927evb_ce_base[3]
+#define TX4927EVB_CE4	tx4927evb_ce_base[4]
+#define TX4927EVB_CE5	tx4927evb_ce_base[5]
+#define TX4927EVB_CE6	tx4927evb_ce_base[6]
+#define TX4927EVB_CE7	tx4927evb_ce_base[7]
+#else
+#define TX4927EVB_CE0	0x1f000000	/* 16M */
+#define TX4927EVB_CE1	0x1e000000	/* 16M */
+#define TX4927EVB_CE2	0x1d000000	/* 16M */
+#define TX4927EVB_CE3	0x17f00000	/* 1M */
+#define TX4927EVB_CE4	0x14000000	/* 32M */
+#define TX4927EVB_CE5	0x17000000	/* 4M */
+#define TX4927EVB_CE6	0x16000000	/* 4M */
+#define TX4927EVB_CE7	0x16400000	/* 4M */
+#endif
+
+/* Address map */
+#define TX4927EVB_LEDDISP_BASE	(KSEG1 + TX4927EVB_CE3 + 0x00000000)
+#define TX4927EVB_BRAMRTC_BASE	(KSEG1 + TX4927EVB_CE3 + 0x00010000)
+#define TX4927EVB_SUPERIO_BASE	(KSEG1 + TX4927EVB_CE3 + 0x00020000)
+#define TX4927EVB_KBD_BASE	(KSEG1 + TX4927EVB_CE3 + 0x00030000)
+#define TX4927EVB_FPGA_REG_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040000)
+#define TX4927EVB_DIPSW3_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040000)
+#define TX4927EVB_DIPSW6_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040001)
+#define TX4927EVB_LED_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040002)
+#define TX4927EVB_SOFTRESET_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040003)
+#define TX4927EVB_PCIRESET_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040004)
+#define TX4927EVB_SOFTINT_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040005)
+#define TX4927EVB_INTPOL_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040006)
+#define TX4927EVB_INTPOL2_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040007)
+#define TX4927EVB_NUM_IOC_INTREGS	5
+#define TX4927EVB_ISTAT_ADDR(n)	(KSEG1 + TX4927EVB_CE3 + 0x00040010 + (n))
+#define TX4927EVB_IMASK_ADDR(n)	(KSEG1 + TX4927EVB_CE3 + 0x00040015 + (n))
+#define TX4927EVB_IMSTAT_ADDR(n)	(KSEG1 + TX4927EVB_CE3 + 0x0004001a + (n))
+#define TX4927EVB_NMI_STAT_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x0004001f)
+#define TX4927EVB_PCI_CLK_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040020)
+#define TX4927EVB_EXB_STAT_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040021)
+#define TX4927EVB_SIO_STAT_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040022)
+#define TX4927EVB_FPGA_REV_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040030)
+#define TX4927EVB_BOARD_REV_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040031)
+
+#define TX4927EVB_ETHER_BASE		(KSEG1 + TX4927EVB_CE4)
+
+#define TX4927EVB_EXB0_BASE		(KSEG1 + TX4927EVB_CE6)
+#define TX4927EVB_EXB1_BASE		(KSEG1 + TX4927EVB_CE7)
+
+/* SuperIO Configuration Register */
+#define TX4927EVB_SUPERIO_CONFIG	(TX4927EVB_SUPERIO_BASE + 0x398)
+/* SuperIO SCC base address */
+#define TX4927EVB_UART0_BASE	(TX4927EVB_SUPERIO_BASE + 0x3f8)
+#define TX4927EVB_UART1_BASE	(TX4927EVB_SUPERIO_BASE + 0x2f8)
+#if 1
+#define TX4927EVB_BASE_BAUD	(24000000 / 13 / 16)	/* 24MHz, prescaler:13 */
+#else
+#define TX4927EVB_BASE_BAUD	(14318180 / 13 / 16)	/* 14.318MHz, prescaler:13 */
+#endif
+/* SuperIO Parallel port address (LPTB) */
+#define TX4927EVB_LPT_ADDR	(TX4927EVB_SUPERIO_BASE + 0x378)
+
+/* Ethernet port address (Jumperless Mode) */
+#define TX4927EVB_ETHER_ADDR	(TX4927EVB_ETHER_BASE + 0x01000280)
+
+/* Keyboard/Mouse */
+#define TX4927EVB_KBD_ADDR	(TX4927EVB_KBD_BASE + 0x60)
+
+/* IEEE1394 board */
+#define TX4927EVB_JMY1394_BASE	(KSEG1 + TX4927EVB_CE2)
+#define TX4927EVB_PREMIER3_BASE	(TX4927EVB_JMY1394_BASE + 0x00100000)
+
+/* bits for ISTAT0/IMASK0/IMSTAT0 */
+#define TX4927EVB_INT0B_RTC	0
+#define TX4927EVB_INT0B_MOUSE	1
+#define TX4927EVB_INT0B_KB	2
+#define TX4927EVB_INT0B_PIO	3
+#define TX4927EVB_INT0B_SIO(n)	(4 + (n))
+#define TX4927EVB_INT0F_RTC	(1 << TX4927EVB_INT0B_RTC)
+#define TX4927EVB_INT0F_MOUSE	(1 << TX4927EVB_INT0B_MOUSE)
+#define TX4927EVB_INT0F_KB	(1 << TX4927EVB_INT0B_KB)
+#define TX4927EVB_INT0F_PIO	(1 << TX4927EVB_INT0B_PIO)
+#define TX4927EVB_INT0F_SIO(n)	(1 << TX4927EVB_INT0B_SIO(n))
+
+/* bits for ISTAT1/IMASK1/IMSTAT1 */
+#define TX4927EVB_INT1B_EXBINT(n)	(n)
+#define TX4927EVB_INT1B_EXPIN	2
+#define TX4927EVB_INT1B_IDSR(n)	(3 + (n) * 2)
+#define TX4927EVB_INT1B_IDCD(n)	(4 + (n) * 2)
+#define TX4927EVB_INT1F_EXBINT(n)	(1 << TX4927EVB_INT1B_EXBINT(n))
+#define TX4927EVB_INT1F_EXPIN	(1 << TX4927EVB_INT1B_EXPIN)
+#define TX4927EVB_INT1F_IDSR(n)	(1 << TX4927EVB_INT1B_IDSR(n))
+#define TX4927EVB_INT1F_IDCD(n)	(1 << TX4927EVB_INT1B_IDCD(n))
+
+/* bits for ISTAT2/IMASK2/IMSTAT2 */
+#define TX4927EVB_INT2B_SOFTINT	0
+#define TX4927EVB_INT2B_PUSHSW	1
+#define TX4927EVB_INT2F_SOFTINT	(1 << TX4927EVB_INT2B_SOFTINT)
+#define TX4927EVB_INT2F_PUSHSW	(1 << TX4927EVB_INT2B_PUSHSW)
+
+/* bits for ISTAT3/IMASK3/IMSTAT3 */
+#define TX4927EVB_INT3B_PCID	0
+#define TX4927EVB_INT3B_PCIC	1
+#define TX4927EVB_INT3B_PCIB	2
+#define TX4927EVB_INT3B_PCIA	3
+#define TX4927EVB_INT3F_PCID	(1 << TX4927EVB_INT3B_PCID)
+#define TX4927EVB_INT3F_PCIC	(1 << TX4927EVB_INT3B_PCIC)
+#define TX4927EVB_INT3F_PCIB	(1 << TX4927EVB_INT3B_PCIB)
+#define TX4927EVB_INT3F_PCIA	(1 << TX4927EVB_INT3B_PCIA)
+
+/* bits for ISTAT4/IMASK4/IMSTAT4 */
+#define TX4927EVB_INT4B_LANC	0
+#define TX4927EVB_INT4F_LANC	(1 << TX4927EVB_INT4B_LANC)
+
+/* bits for NMI_STAT */
+#define TX4927EVB_INTB_NMI_EXB	0
+#define TX4927EVB_INTB_NMI_EXP	1
+#define TX4927EVB_INTB_NMI_PSW	2
+#define TX4927EVB_INTF_NMI_EXB	(1 << TX4927EVB_INTB_NMI_EXB)
+#define TX4927EVB_INTF_NMI_EXP	(1 << TX4927EVB_INTB_NMI_EXP)
+#define TX4927EVB_INTF_NMI_PSW	(1 << TX4927EVB_INTB_NMI_PSW)
+
+/* bits for PCI_CLK (S6) */
+#define TX4927EVB_PCI_CLK_HOST	0x80
+#define TX4927EVB_PCI_CLK_MASK	(0x0f << 3)
+#define TX4927EVB_PCI_CLK_33	(0x01 << 3)
+#define TX4927EVB_PCI_CLK_25	(0x04 << 3)
+#define TX4927EVB_PCI_CLK_66	(0x09 << 3)
+#define TX4927EVB_PCI_CLK_50	(0x0c << 3)
+#define TX4927EVB_PCI_CLK_ACK	0x04
+#define TX4927EVB_PCI_CLK_ACE	0x02
+#define TX4927EVB_PCI_CLK_ENDIAN	0x01
+
+/* bits for SIO_STAT */
+#define TX4927EVB_SIO_STAT_RI(ch)	(0x01 << (ch * 4))
+#define TX4927EVB_SIO_STAT_DSR(ch)	(0x02 << (ch * 4))
+#define TX4927EVB_SIO_STAT_DCD(ch)	(0x04 << (ch * 4))
+#define TX4927EVB_SIO_STAT_DTR(ch)	(0x08 << (ch * 4))
+
+#ifndef _LANGUAGE_ASSEMBLY
+#define tx4927evb_leddisp_ptr	\
+	((volatile unsigned char *)TX4927EVB_LEDDISP_BASE)
+#define tx4927evb_bramrtc_ptr	\
+	((volatile unsigned char *)TX4927EVB_BRAMRTC_BASE)
+#define tx4927evb_dipsw3_ptr	\
+	((volatile unsigned char *)TX4927EVB_DIPSW3_ADDR)
+#define tx4927evb_dipsw6_ptr	\
+	((volatile unsigned char *)TX4927EVB_DIPSW6_ADDR)
+#define tx4927evb_led_ptr	\
+	((volatile unsigned char *)TX4927EVB_LED_ADDR)
+#define tx4927evb_softreset_ptr	\
+	((volatile unsigned char *)TX4927EVB_SOFTRESET_ADDR)
+#define tx4927evb_pcireset_ptr	\
+	((volatile unsigned char *)TX4927EVB_PCIRESET_ADDR)
+#define tx4927evb_softint_ptr	\
+	((volatile unsigned char *)TX4927EVB_SOFTINT_ADDR)
+#define tx4927evb_intpol_ptr	\
+	((volatile unsigned char *)TX4927EVB_INTPOL_ADDR)
+#define tx4927evb_intpol2_ptr	\
+	((volatile unsigned char *)TX4927EVB_INTPOL2_ADDR)
+#define tx4927evb_istat_ptr(n)	\
+	((volatile unsigned char *)TX4927EVB_ISTAT_ADDR(n))
+#define tx4927evb_imask_ptr(n)	\
+	((volatile unsigned char *)TX4927EVB_IMASK_ADDR(n))
+#define tx4927evb_imstat_ptr(n)	\
+	((volatile unsigned char *)TX4927EVB_IMSTAT_ADDR(n))
+#define tx4927evb_nmi_stat_ptr	\
+	((volatile unsigned char *)TX4927EVB_NMI_STAT_ADDR)
+#define tx4927evb_pci_clk_ptr	\
+	((volatile unsigned char *)TX4927EVB_PCI_CLK_ADDR)
+#define tx4927evb_exb_stat_ptr	\
+	((volatile unsigned char *)TX4927EVB_EXB_STAT_ADDR)
+#define tx4927evb_sio_stat_ptr	\
+	((volatile unsigned char *)TX4927EVB_SIO_STAT_ADDR)
+#define tx4927evb_fpga_rev_ptr	\
+	((volatile unsigned char *)TX4927EVB_FPGA_REV_ADDR)
+#define tx4927evb_board_rev_ptr	\
+	((volatile unsigned char *)TX4927EVB_BOARD_REV_ADDR)
+
+#define tx4927evb_led_on(n)	(*tx4927evb_led_ptr |= 1<<(n))
+#define tx4927evb_led_off(n)	(*tx4927evb_led_ptr = *tx4927evb_led_ptr &~ (1<<(n)))
+#define tx4927evb_led_toggle(n)	(*tx4927evb_led_ptr = *tx4927evb_led_ptr ^(1<<(n)))
+#define tx4927evb_leddisp_addr(addr)	(tx4927evb_leddisp_ptr+((addr)<<2))
+#define tx4927evb_leddisp_putc(n, c)	(*tx4927evb_leddisp_addr(0x38|((n)&7)) = (c))
+extern void tx4927evb_leddisp_puts(const char *s);
+extern void tx4927evb_leddisp_put(unsigned long val);
+
+/* clock */
+extern int tx4927evb_master_clock;
+extern int tx4927evb_gbus_clock;
+#define TX4927EVB_GBUSCLK	tx4927evb_gbus_clock
+#define TX4927EVB_IMCLK		(TX4927EVB_GBUSCLK / 2)
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+
+/*
+ * IRQ mappings
+ */
+
+#define TX4927EVB_SOFT_INT0	0	/* not used */
+#define TX4927EVB_SOFT_INT1	1	/* not used */
+#define TX4927EVB_IRC_INT	2
+#define TX4927EVB_TIMER_INT	7
+
+/* These are the virtual IRQ numbers, we divide all IRQ's into
+ * 'spaces', the 'space' determines where and how to enable/disable
+ * that particular IRQ on an TX4927EVB machine.  Add new 'spaces' as new
+ * IRQ hardware is supported.
+ */
+#define TX4927EVB_NR_IRQ_LOCAL	8
+#define TX4927EVB_NR_IRQ_IRC	32	/* On-Chip IRC */
+#define TX4927EVB_NR_IRQ_IOC	8	/* IOC0, ... IOC4 */
+
+#define TX4927EVB_IRQ_LOCAL	NR_ISA_IRQS
+#define TX4927EVB_IRQ_IRC	(TX4927EVB_IRQ_LOCAL + TX4927EVB_NR_IRQ_LOCAL)
+#define TX4927EVB_IRQ_IOC0	(TX4927EVB_IRQ_IRC + TX4927EVB_NR_IRQ_IRC)
+#define TX4927EVB_IRQ_IOC(n)	(TX4927EVB_IRQ_IOC0 + TX4927EVB_NR_IRQ_IOC*(n))
+#define TX4927EVB_IRQ_END	TX4927EVB_IRQ_IOC(5)
+
+#define TX4927EVB_IRQ_LOCAL_SOFT0	(TX4927EVB_IRQ_LOCAL + TX4927EVB_SOFT_INT0)
+#define TX4927EVB_IRQ_LOCAL_SOFT1	(TX4927EVB_IRQ_LOCAL + TX4927EVB_SOFT_INT0)
+#define TX4927EVB_IRQ_LOCAL_IRC	(TX4927EVB_IRQ_LOCAL + TX4927EVB_IRC_INT)
+#define TX4927EVB_IRQ_LOCAL_TIMER	(TX4927EVB_IRQ_LOCAL + TX4927EVB_TIMER_INT)
+#define TX4927EVB_IRQ_IRC_ECCERR	(TX4927EVB_IRQ_IRC + TX4927_IR_ECCERR)
+#define TX4927EVB_IRQ_IRC_WTOERR	(TX4927EVB_IRQ_IRC + TX4927_IR_WTOERR)
+#define TX4927EVB_IRQ_IRC_INT(n)	(TX4927EVB_IRQ_IRC + TX4927_IR_INT(n))
+#define TX4927EVB_IRQ_IRC_SIO(n)	(TX4927EVB_IRQ_IRC + TX4927_IR_SIO(n))
+#define TX4927EVB_IRQ_IRC_DMA(n)	(TX4927EVB_IRQ_IRC + TX4927_IR_DMA(n))
+#define TX4927EVB_IRQ_IRC_PIO	(TX4927EVB_IRQ_IRC + TX4927_IR_PIO)
+#define TX4927EVB_IRQ_IRC_PDMAC	(TX4927EVB_IRQ_IRC + TX4927_IR_PDMAC)
+#define TX4927EVB_IRQ_IRC_PCIC	(TX4927EVB_IRQ_IRC + TX4927_IR_PCIC)
+#define TX4927EVB_IRQ_IRC_TMR(n)	(TX4927EVB_IRQ_IRC + TX4927_IR_TMR(n))
+#define TX4927EVB_IRQ_IRC_PCIERR	(TX4927EVB_IRQ_IRC + TX4927_IR_PCIERR)
+#define TX4927EVB_IRQ_IRC_PCIPMA	(TX4927EVB_IRQ_IRC + TX4927_IR_PCIPMA)
+#define TX4927EVB_IRQ_IRC_ACLC	(TX4927EVB_IRQ_IRC + TX4927_IR_ACLC)
+#define TX4927EVB_IRQ_IRC_ACKCPMA	(TX4927EVB_IRQ_IRC + TX4927_IR_ACKCPMA)
+#define TX4927EVB_IRQ_IOC_RTC	(TX4927EVB_IRQ_IOC(0) + TX4927EVB_INT0B_RTC)
+#define TX4927EVB_IRQ_IOC_MOUSE	(TX4927EVB_IRQ_IOC(0) + TX4927EVB_INT0B_MOUSE)
+#define TX4927EVB_IRQ_IOC_KB	(TX4927EVB_IRQ_IOC(0) + TX4927EVB_INT0B_KB)
+#define TX4927EVB_IRQ_IOC_PIO	(TX4927EVB_IRQ_IOC(0) + TX4927EVB_INT0B_PIO)
+#define TX4927EVB_IRQ_IOC_SIO(n)	(TX4927EVB_IRQ_IOC(0) + TX4927EVB_INT0B_SIO(n))
+#define TX4927EVB_IRQ_IOC_EXBINT(n)	(TX4927EVB_IRQ_IOC(1) + TX4927EVB_INT1B_EXBINT(n))
+#define TX4927EVB_IRQ_IOC_EXPIN	(TX4927EVB_IRQ_IOC(1) + TX4927EVB_INT1B_EXPIN)
+#define TX4927EVB_IRQ_IOC_IDSR(n)	(TX4927EVB_IRQ_IOC(1) + TX4927EVB_INT1B_IDSR(n))
+#define TX4927EVB_IRQ_IOC_IDCD(n)	(TX4927EVB_IRQ_IOC(1) + TX4927EVB_INT1B_IDCD(n))
+#define TX4927EVB_IRQ_IOC_SOFTINT	(TX4927EVB_IRQ_IOC(2) + TX4927EVB_INT2B_SOFTINT)
+#define TX4927EVB_IRQ_IOC_PUSHSW	(TX4927EVB_IRQ_IOC(2) + TX4927EVB_INT2B_PUSHSW)
+#define TX4927EVB_IRQ_IOC_PCID	(TX4927EVB_IRQ_IOC(3) + TX4927EVB_INT3B_PCID)
+#define TX4927EVB_IRQ_IOC_PCIC	(TX4927EVB_IRQ_IOC(3) + TX4927EVB_INT3B_PCIC)
+#define TX4927EVB_IRQ_IOC_PCIB	(TX4927EVB_IRQ_IOC(3) + TX4927EVB_INT3B_PCIB)
+#define TX4927EVB_IRQ_IOC_PCIA	(TX4927EVB_IRQ_IOC(3) + TX4927EVB_INT3B_PCIA)
+#define TX4927EVB_IRQ_IOC_LANC	(TX4927EVB_IRQ_IOC(4) + TX4927EVB_INT4B_LANC)
+
+#define TX4927EVB_IRQ_PREMIER3	TX4927EVB_IRQ_IOC_EXBINT(0)
+
+#endif /* __ASM_TOSHIBA_BOARDS_TX4927EVB_H */
diff -Naru linux-2.4.32/include/asm-mips/mipsregs.h linux-2.4.32-mct/include/asm-mips/mipsregs.h
--- linux-2.4.32/include/asm-mips/mipsregs.h	2005-01-19 15:10:12.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/mipsregs.h	2006-12-02 15:08:43.000000000 +0100
@@ -553,6 +553,62 @@
         : : "r" (val));
 
 /*
+ * Macros to access the system control coprocessor (Copied From Claxan Sources - Udo)
+ */
+#define read_32bit_cp0_register(source)                         \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "mfc0\t%0,"STR(source)"\n\t"                            \
+	".set\tpop"						\
+        : "=r" (__res));                                        \
+        __res;})
+
+#define read_32bit_cp0_set1_register(source)                    \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "cfc0\t%0,"STR(source)"\n\t"                            \
+	".set\tpop"						\
+        : "=r" (__res));                                        \
+        __res;})
+
+/*
+ * For now use this only with interrupts disabled!
+ */
+#define read_64bit_cp0_register(source)                         \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+        ".set\tmips3\n\t"                                       \
+        "dmfc0\t%0,"STR(source)"\n\t"                           \
+        ".set\tmips0"                                           \
+        : "=r" (__res));                                        \
+        __res;})
+
+#define write_32bit_cp0_register(register,value)                \
+        __asm__ __volatile__(                                   \
+        "mtc0\t%0,"STR(register)"\n\t"				\
+	"nop"							\
+        : : "r" (value));
+
+#define write_32bit_cp0_set1_register(register,value)           \
+        __asm__ __volatile__(                                   \
+        "ctc0\t%0,"STR(register)"\n\t"				\
+	"nop"							\
+        : : "r" (value));
+
+#define write_64bit_cp0_register(register,value)                \
+        __asm__ __volatile__(                                   \
+        ".set\tmips3\n\t"                                       \
+        "dmtc0\t%0,"STR(register)"\n\t"                         \
+        ".set\tmips0"                                           \
+        : : "r" (value))
+
+// *End SA-200 - Udo
+
+/*
  * Macros to access the system control coprocessor
  */
 
diff -Naru linux-2.4.32/include/asm-mips/parport.h linux-2.4.32-mct/include/asm-mips/parport.h
--- linux-2.4.32/include/asm-mips/parport.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.32-mct/include/asm-mips/parport.h	2006-12-02 15:08:43.000000000 +0100
@@ -6,10 +6,26 @@
 #ifndef _ASM_PARPORT_H
 #define _ASM_PARPORT_H
 
+#include <linux/config.h>
+#if defined(CONFIG_TOSHIBA_BOARDS) || defined(CONFIG_MCT_BOARDS)
+extern int mips_parport_base;
+extern int mips_parport_irq;
+static int __devinit parport_pc_find_nonpci_ports (int autoirq, int autodma)
+{
+	if (mips_parport_base && mips_parport_irq &&
+	    parport_pc_probe_port(mips_parport_base,
+				  mips_parport_base + 0x400,
+				  mips_parport_irq,
+				  PARPORT_DMA_NONE, NULL))
+	    return 1;
+	return 0;
+}
+#else
 static int __devinit parport_pc_find_isa_ports (int autoirq, int autodma);
 static int __devinit parport_pc_find_nonpci_ports (int autoirq, int autodma)
 {
 	return parport_pc_find_isa_ports (autoirq, autodma);
 }
+#endif
 
 #endif /* _ASM_PARPORT_H */
diff -Naru linux-2.4.32/include/asm-mips/pci.h linux-2.4.32-mct/include/asm-mips/pci.h
--- linux-2.4.32/include/asm-mips/pci.h	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/pci.h	2006-12-02 15:08:43.000000000 +0100
@@ -49,6 +49,13 @@
 #define PCIBIOS_MIN_MEM		0x1000000
 #endif
 
+#if defined(CONFIG_TOSHIBA_BOARDS) || defined(CONFIG_MCT_BOARDS)
+#undef PCIBIOS_MIN_IO
+#undef PCIBIOS_MIN_MEM
+#define PCIBIOS_MIN_IO          0x8000  /* reserve regacy I/O space */
+#define PCIBIOS_MIN_MEM         0
+#endif
+
 struct pci_dev;
 
 /*
diff -Naru linux-2.4.32/include/asm-mips/ptrace.h linux-2.4.32-mct/include/asm-mips/ptrace.h
--- linux-2.4.32/include/asm-mips/ptrace.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/ptrace.h	2006-12-02 15:08:43.000000000 +0100
@@ -73,12 +73,12 @@
 #endif /* !__ASSEMBLY__ */
 
 /* Arbitrarily choose the same ptrace numbers as used by the Sparc code. */
-/* #define PTRACE_GETREGS		12 */
-/* #define PTRACE_SETREGS		13 */
-/* #define PTRACE_GETFPREGS		14 */
-/* #define PTRACE_SETFPREGS		15 */
-/* #define PTRACE_GETFPXREGS		18 */
-/* #define PTRACE_SETFPXREGS		19 */
+#define PTRACE_GETREGS		12
+#define PTRACE_SETREGS		13
+#define PTRACE_GETFPREGS		14
+#define PTRACE_SETFPREGS		15
+#define PTRACE_GETFPXREGS		18
+#define PTRACE_SETFPXREGS		19
 
 #define PTRACE_SETOPTIONS	21
 
diff -Naru linux-2.4.32/include/asm-mips/serial_txx927.h linux-2.4.32-mct/include/asm-mips/serial_txx927.h
--- linux-2.4.32/include/asm-mips/serial_txx927.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/serial_txx927.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,17 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ */
+
+#ifndef __ASM_SERIAL_TXX927_H 
+#define __ASM_SERIAL_TXX927_H 
+
+/* flags */
+#define TXx927_SERIAL_HAVE_CTS_LINE	1
+
+extern int early_serial_txx927_setup(int line, unsigned long base, int irq, int baud_base, int flags) __init;
+
+#endif /* __ASM_SERIAL_TXX927_H */
diff -Naru linux-2.4.32/include/asm-mips/toshiba-boards/dma.h linux-2.4.32-mct/include/asm-mips/toshiba-boards/dma.h
--- linux-2.4.32/include/asm-mips/toshiba-boards/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/toshiba-boards/dma.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,150 @@
+/*
+ *  linux/arch/mips/toshiba-boards/generic/dma.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ */
+
+#ifndef __ASM_TOSHIBA_BOARDS_DMA_H
+#define __ASM_TOSHIBA_BOARDS_DMA_H
+
+/* TX3927/TX4927 stype DMA controllers */
+
+/* bits for set_txx927_dma_mode() */
+#define TXx927_DMA_CCR_DBINH	0x04000000
+#define TXx927_DMA_CCR_SBINH	0x02000000
+#define TXx927_DMA_CCR_CHRST	0x01000000
+#define TXx927_DMA_CCR_RVBYTE	0x00800000
+#define TXx927_DMA_CCR_ACKPOL	0x00400000
+#define TXx927_DMA_CCR_REQPL	0x00200000
+#define TXx927_DMA_CCR_EGREQ	0x00100000
+#define TXx927_DMA_CCR_CHDN	0x00080000
+#define TXx927_DMA_CCR_DNCTL	0x00060000
+#define TXx927_DMA_CCR_EXTRQ	0x00010000
+#define TXx927_DMA_CCR_INTRQD	0x0000e000
+#define TXx927_DMA_CCR_INTENE	0x00001000
+#define TXx927_DMA_CCR_INTENC	0x00000800
+#define TXx927_DMA_CCR_INTENT	0x00000400
+#define TXx927_DMA_CCR_CHNEN	0x00000200
+#define TXx927_DMA_CCR_XFACT	0x00000100
+#define TXx927_DMA_CCR_XFSZ(order)	(((order) << 2) & 0x0000001c)
+#define TXx927_DMA_CCR_XFSZ_1B	TXx927_DMA_CCR_XFSZ(0)
+#define TXx927_DMA_CCR_XFSZ_1W	TXx927_DMA_CCR_XFSZ(2)
+#define TXx927_DMA_CCR_XFSZ_4W	TXx927_DMA_CCR_XFSZ(4)
+#define TXx927_DMA_CCR_XFSZ_8W	TXx927_DMA_CCR_XFSZ(5)
+#define TXx927_DMA_CCR_XFSZ_16W	TXx927_DMA_CCR_XFSZ(6)
+#define TXx927_DMA_CCR_XFSZ_32W	TXx927_DMA_CCR_XFSZ(7)
+#define TXx927_DMA_CCR_MEMIO	0x00000002
+#define TXx927_DMA_CCR_SNGAD	0x00000001
+
+/* dual address, 1 word size transfer mode */
+#define TXx927_DMA_MODE_DUAL_1W	\
+	(TXx927_DMA_CCR_INTENE|TXx927_DMA_CCR_INTENT|TXx927_DMA_CCR_XFSZ_1W)
+/* Internal I/O, 1 word size transfer mode */
+#define TXx927_DMA_MODE_IIO_1W	\
+	(TXx927_DMA_CCR_EXTRQ|TXx927_DMA_CCR_INTENE|TXx927_DMA_CCR_INTENT|TXx927_DMA_CCR_XFSZ_1W)
+
+/* bits for get_txx927_dma_status() */
+#define TXx927_DMA_STATUS_CHNACT	0x00000100
+#define TXx927_DMA_STATUS_ABCHC	0x00000080
+#define TXx927_DMA_STATUS_NCHNC	0x00000040
+#define TXx927_DMA_STATUS_NTRNFC	0x00000020
+#define TXx927_DMA_STATUS_EXTDN	0x00000010
+#define TXx927_DMA_STATUS_CFERR	0x00000008
+#define TXx927_DMA_STATUS_CHERR	0x00000004
+#define TXx927_DMA_STATUS_DESERR	0x00000002
+#define TXx927_DMA_STATUS_SORERR	0x00000001
+
+/* chained DMA descriptor */
+typedef void* txx927_chdma_desc_t;
+
+struct txx927_dma_ops {
+	void (*init_dma)(unsigned int dmanr);
+	void (*enable_dma)(unsigned int dmanr);
+	void (*disable_dma)(unsigned int dmanr);
+	void (*set_dma_mode)(unsigned int dmanr, unsigned int mode);
+	void (*set_dma_addr)(unsigned int dmanr, unsigned int sa, unsigned int da);
+	void (*set_dma_addr64)(unsigned int dmanr, unsigned long long sa, unsigned long long da);
+	void (*set_dma_count)(unsigned int dmanr, unsigned int count);
+	void (*set_dma_inc)(unsigned int dmanr, unsigned int sai, unsigned int dai);
+	int (*get_dma_residue)(unsigned int dmanr);
+	unsigned int (*get_dma_status)(unsigned int dmanr);
+	void (*clear_dma_status)(unsigned int dmanr);
+	int (*get_dma_irqno)(unsigned int dmanr);
+	/* for chain operation */
+	void (*set_dma_chain)(unsigned int dmanr, txx927_chdma_desc_t cha);
+	txx927_chdma_desc_t (*get_dma_chain)(unsigned int dmanr);
+	void (*set_chdma_mode)(txx927_chdma_desc_t desc, unsigned int mode);
+	void (*set_chdma_addr)(txx927_chdma_desc_t desc, unsigned int sa, unsigned int da);
+	void (*get_chdma_addr)(txx927_chdma_desc_t desc, unsigned int *sa, unsigned int *da);
+	void (*set_chdma_addr64)(txx927_chdma_desc_t desc, unsigned long long sa, unsigned long long da);
+	void (*get_chdma_addr64)(txx927_chdma_desc_t desc, unsigned long long *sa, unsigned long long *da);
+	void (*set_chdma_count)(txx927_chdma_desc_t desc, unsigned int count);
+	void (*get_chdma_count)(txx927_chdma_desc_t desc, unsigned int *count);
+	void (*set_chdma_inc)(txx927_chdma_desc_t desc, unsigned int sai, unsigned int dai);
+	void (*set_chdma_chain)(txx927_chdma_desc_t desc, txx927_chdma_desc_t cha);
+	txx927_chdma_desc_t (*get_chdma_chain)(txx927_chdma_desc_t desc);
+	txx927_chdma_desc_t (*alloc_chdma_cmd)(void);
+	void (*free_chdma_cmd)(txx927_chdma_desc_t desc);
+};
+extern struct txx927_dma_ops *txx927_dma_ops;
+
+#define init_txx927_dma(dmanr) \
+	(*txx927_dma_ops->init_dma)(dmanr)
+#define enable_txx927_dma(dmanr) \
+	(*txx927_dma_ops->enable_dma)(dmanr)
+#define disable_txx927_dma(dmanr) \
+	(*txx927_dma_ops->disable_dma)(dmanr)
+#define set_txx927_dma_mode(dmanr, mode) \
+	(*txx927_dma_ops->set_dma_mode)(dmanr, mode)
+#define set_txx927_dma_addr(dmanr, sa, da) \
+	(*txx927_dma_ops->set_dma_addr)(dmanr, sa, da)
+#define set_txx927_dma_addr64(dmanr, sa, da) \
+	(*txx927_dma_ops->set_dma_addr64)(dmanr, sa, da)
+#define set_txx927_dma_count(dmanr, count) \
+	(*txx927_dma_ops->set_dma_count)(dmanr, count)
+#define set_txx927_dma_inc(dmanr, sai, dai) \
+	(*txx927_dma_ops->set_dma_inc)(dmanr, sai, dai)
+#define get_txx927_dma_residue(dmanr) \
+	(*txx927_dma_ops->get_dma_residue)(dmanr)
+#define get_txx927_dma_status(dmanr) \
+	(*txx927_dma_ops->get_dma_status)(dmanr)
+#define clear_txx927_dma_status(dmanr) \
+	(*txx927_dma_ops->clear_dma_status)(dmanr)
+#define get_txx927_dma_irqno(dmanr) \
+	(*txx927_dma_ops->get_dma_irqno)(dmanr)
+/* for chain operation */
+#define set_txx927_dma_chain(dmanr, cha) \
+	(*txx927_dma_ops->set_dma_chain)(dmanr, cha)
+#define get_txx927_dma_chain(dmanr) \
+	(*txx927_dma_ops->get_dma_chain)(dmanr)
+#define set_txx927_chdma_mode(desc, mode) \
+	(*txx927_dma_ops->set_chdma_mode)(desc, mode)
+#define set_txx927_chdma_addr(desc, sa, da) \
+	(*txx927_dma_ops->set_chdma_addr)(desc, sa, da)
+#define get_txx927_chdma_addr(desc, sa, da) \
+	(*txx927_dma_ops->get_chdma_addr)(desc, sa, da)
+#define set_txx927_chdma_addr64(desc, sa, da) \
+	(*txx927_dma_ops->set_chdma_addr64)(desc, sa, da)
+#define get_txx927_chdma_addr64(desc, sa, da) \
+	(*txx927_dma_ops->get_chdma_addr64)(desc, sa, da)
+#define set_txx927_chdma_count(desc, count) \
+	(*txx927_dma_ops->set_chdma_count)(desc, count)
+#define get_txx927_chdma_count(desc, count) \
+	(*txx927_dma_ops->get_chdma_count)(desc, count)
+#define set_txx927_chdma_inc(desc, sai, dai) \
+	(*txx927_dma_ops->set_chdma_inc)(desc, sai, dai)
+#define set_txx927_chdma_chain(desc, cha) \
+	(*txx927_dma_ops->set_chdma_chain)(desc, cha)
+#define get_txx927_chdma_chain(desc) \
+	(*txx927_dma_ops->get_chdma_chain)(desc)
+#define alloc_txx927_chdma_cmd() \
+	(*txx927_dma_ops->alloc_chdma_cmd)()
+#define free_txx927_chdma_cmd(desc) \
+	(*txx927_dma_ops->free_chdma_cmd)(desc)
+
+#endif /* __ASM_TOSHIBA_BOARDS_DMA_H */
diff -Naru linux-2.4.32/include/asm-mips/toshiba-boards/irq.h linux-2.4.32-mct/include/asm-mips/toshiba-boards/irq.h
--- linux-2.4.32/include/asm-mips/toshiba-boards/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/toshiba-boards/irq.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,46 @@
+/*
+ *  linux/include/asm-mips/toshiba-boards/irq.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_IRQ_H
+#define __ASM_TOSHIBA_BOARDS_IRQ_H
+
+#ifndef _LANGUAGE_ASSEMBLY
+#include <asm/irq.h>
+
+struct pt_regs;
+
+#ifdef CONFIG_TX_BRANCH_LIKELY_BUG_WORKAROUND
+extern void tx_branch_likely_bug_fixup(struct pt_regs *regs);
+#endif
+#ifdef CONFIG_TX_FPU_C_BUG_WORKAROUND
+extern void tx_fpu_c_bug_fixup(struct pt_regs *regs);
+#endif
+
+struct resource;
+extern int (*toshibaboards_gen_iack)(void);
+extern int toshibaboards_i8259_irqroute(int irq);
+extern int toshibaboards_i8259_irq_setup(int irq);
+
+extern void mips_cpu_irq_init(u32 irq_base);
+extern void tx3927_irq_init(int irq_base);
+extern void tx4927_irq_init(int irq_base);
+extern void tx4925_irq_init(int irq_base);
+extern int tx3927_irq_to_irq(int irq);
+extern int tx4927_irq_to_irq(int irq);
+extern int tx4925_irq_to_irq(int irq);
+
+extern asmlinkage unsigned int do_IRQ(int irq, struct pt_regs *regs);
+extern int (*toshibaboards_irqdispatch)(struct pt_regs *regs);
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+#define NR_ISA_IRQS 16
+
+#endif /* __ASM_TOSHIBA_BOARDS_IRQ_H */
diff -Naru linux-2.4.32/include/asm-mips/toshiba-boards/jmi39io2.h linux-2.4.32-mct/include/asm-mips/toshiba-boards/jmi39io2.h
--- linux-2.4.32/include/asm-mips/toshiba-boards/jmi39io2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/toshiba-boards/jmi39io2.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,106 @@
+/*
+ * Defines for the TJSYS JMI-3927IO2.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_JMI39IO2_H 
+#define __ASM_TOSHIBA_BOARDS_JMI39IO2_H 
+
+#define JMI39IO2_ISAMEM_BASE(base)	(base)
+#define JMI39IO2_ISAIO_BASE(base)	((base) + 0x01000000)
+#define JMI39IO2_ISAC_BASE(base)	((base) + 0x02000000)
+#define JMI39IO2_LCDVGA_REG_BASE(base)	((base) + 0x03000000)
+#define JMI39IO2_LCDVGA_MEM_BASE(base)	((base) + 0x03800000)
+
+#define JMI39IO2_ISAC_REV_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00000000)
+#define JMI39IO2_ISAC_EINTS_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00200000)
+#define JMI39IO2_ISAC_EINTM_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00300000)
+#define JMI39IO2_ISAC_NMI_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00400000)
+#define JMI39IO2_ISAC_LED_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00500000)
+#define JMI39IO2_ISAC_INTP_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00800000)
+#define JMI39IO2_ISAC_INTS1_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00900000)
+#define JMI39IO2_ISAC_INTS2_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00a00000)
+#define JMI39IO2_ISAC_INTM_ADDR(base)	(JMI39IO2_ISAC_BASE(base) + 0x00b00000)
+
+/* bits for ISAC_REV (high byte) */
+#define JMI39IO2_IDT_MASK	0xfc
+#define JMI39IO2_REV_MASK	0x03
+#define JMI39IO2_ISAC_IDT	0x20
+
+/* bits for ISAC_EINTS/ISAC_EINTM (high byte) */
+#define JMI39IO2_ISAC_EINTB_IOCHK	2
+#define JMI39IO2_ISAC_EINTB_BWTH	4
+#define JMI39IO2_ISAC_EINTF_IOCHK	(1 << JMI39IO2_ISAC_EINTB_IOCHK)
+#define JMI39IO2_ISAC_EINTF_BWTH	(1 << JMI39IO2_ISAC_EINTB_BWTH)
+
+/* bits for ISAC_LED (high byte) */
+#define JMI39IO2_ISAC_LED_ISALED	0x01
+#define JMI39IO2_ISAC_LED_USRLED	0x02
+
+#define JMI39IO2_NR_IRQ_ISAC	8
+
+/* bits for ISAC_INTS/ISAC_INTM/ISAC_INTP (high byte) */
+#define JMI39IO2_ISAC_INTB_IRQ5	0
+#define JMI39IO2_ISAC_INTB_IRQKB	1
+#define JMI39IO2_ISAC_INTB_IRQMOUSE	2
+#define JMI39IO2_ISAC_INTB_IRQ4	3
+#define JMI39IO2_ISAC_INTB_IRQ12	4
+#define JMI39IO2_ISAC_INTB_IRQ3	5
+#define JMI39IO2_ISAC_INTB_IRQ10	6
+#define JMI39IO2_ISAC_INTB_ISAER	7
+#define JMI39IO2_ISAC_INTF_IRQ5		(1 << JMI39IO2_ISAC_INTB_IRQ5)
+#define JMI39IO2_ISAC_INTF_IRQKB	(1 << JMI39IO2_ISAC_INTB_IRQKB)
+#define JMI39IO2_ISAC_INTF_IRQMOUSE	(1 << JMI39IO2_ISAC_INTB_IRQMOUSE)
+#define JMI39IO2_ISAC_INTF_IRQ4		(1 << JMI39IO2_ISAC_INTB_IRQ4)
+#define JMI39IO2_ISAC_INTF_IRQ12	(1 << JMI39IO2_ISAC_INTB_IRQ12)
+#define JMI39IO2_ISAC_INTF_IRQ3		(1 << JMI39IO2_ISAC_INTB_IRQ3)
+#define JMI39IO2_ISAC_INTF_IRQ10	(1 << JMI39IO2_ISAC_INTB_IRQ10)
+#define JMI39IO2_ISAC_INTF_ISAER	(1 << JMI39IO2_ISAC_INTB_ISAER)
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+#define jmi39io2_isac_reg_out(d, a)	((*(volatile unsigned char *)(a)) = (d))
+#define jmi39io2_isac_reg_in(a)		(*(volatile unsigned char *)(a))
+
+/* LED macro */
+#define jmi39io2_io_led_set(base, n/*0-3*/)	jmi39io2_isac_reg_out((n), JMI39IO2_ISAC_LED_ADDR(base))
+
+/* DIPSW macro */
+#define jmi39io2_io_dipsw(base)	(jmi39io2_isac_reg_in(JMI39IO2_ISAC_LED_ADDR(base)) >> 4)
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+/* INTs */
+
+/* RTL8019AS 10M Ether (JMI-3927IO2:JPW2:2-3 Short) */
+#define JMI39IO2_INT_ETHER	3
+/* RTL8019AS 10M Ether (JMI-3927IO2:JPW2:1-2 Short) */
+#define JMI39IO2_INT_ETHER_ALT	0
+/* ISAC (ISA, PCMCIA, KEYBOARD, MOUSE) */
+#define JMI39IO2_INT_ISAC	2
+
+/* I/O Ports */
+/* RTL8019AS 10M Ether */
+#define JMI39IO2_ETHER_ADDR(base)	(JMI39IO2_ISAIO_BASE(base) + 0x280)
+#define JMI39IO2_PCMCIA_ADDR(base)	(JMI39IO2_ISAIO_BASE(base) + 0x3e0)
+#define JMI39IO2_KBD_ADDR(base)	(JMI39IO2_ISAIO_BASE(base) + 0x00800060)
+#define JMI39IO2_IDE_ADDR(base)	(JMI39IO2_ISAIO_BASE(base) + 0x001001f0)
+
+#ifndef _LANGUAGE_ASSEMBLY
+extern unsigned long jmi39io2_iob_base;
+extern int jmi39io2_isac_irq_base;
+extern void jmi39io2_init(unsigned long base, int isac_irq);
+#define have_jmi39io2()	(jmi39io2_iob_base != 0)
+extern void jmi39io2_isac_irq_init(void);
+extern int jmi39io2_isac_irqroute(void);
+extern void jmi39io2_kbd_init(void);
+extern void jmi39io2_ide_init(void);
+extern int early_jmi39io2_ether_setup(unsigned long port, int irq);
+extern int early_e1355_setup(unsigned long reg_base, unsigned long fb_base);
+#endif /* _LANGUAGE_ASSEMBLY */
+
+#endif /* __ASM_TOSHIBA_BOARDS_JMI39IO2_H */
diff -Naru linux-2.4.32/include/asm-mips/toshiba-boards/jmr3927.h linux-2.4.32-mct/include/asm-mips/toshiba-boards/jmr3927.h
--- linux-2.4.32/include/asm-mips/toshiba-boards/jmr3927.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/toshiba-boards/jmr3927.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,206 @@
+/*
+ * Defines for the TJSYS JMR-TX3927
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_JMR3927_H 
+#define __ASM_TOSHIBA_BOARDS_JMR3927_H 
+
+#include <asm/tx3927.h>
+#include <asm/addrspace.h>
+#include <asm/toshiba-boards/irq.h>
+
+/* CS */
+#define JMR3927_ROMCE0	0x1fc00000	/* 4M */
+#define JMR3927_ROMCE1	0x1e000000	/* 4M */
+#define JMR3927_ROMCE2	0x14000000	/* 16M */
+#define JMR3927_ROMCE3	0x10000000	/* 64M */
+#define JMR3927_ROMCE5	0x1d000000	/* 4M */
+#define JMR3927_SDCS0	0x00000000	/* 32M */
+#define JMR3927_SDCS1	0x02000000	/* 32M */
+/* PCI Direct Mappings */
+#define JMR3927_PCIMEM	0x08000000
+#define JMR3927_PCIMEM_SIZE	0x08000000	/* 128M */
+#define JMR3927_PCIIO	0x15000000
+#define JMR3927_PCIIO_SIZE	0x01000000	/* 16M */
+
+/* Address map (virtual address) */
+#define JMR3927_ROM0_BASE	(KSEG1 + JMR3927_ROMCE0)
+#define JMR3927_ROM1_BASE	(KSEG1 + JMR3927_ROMCE1)
+#define JMR3927_IOC_BASE	(KSEG1 + JMR3927_ROMCE2)
+#define JMR3927_IOB_BASE	(KSEG1 + JMR3927_ROMCE3)
+#define JMR3927_JMY1394_BASE	(KSEG1 + JMR3927_ROMCE5)
+#define JMR3927_PREMIER3_BASE	(JMR3927_JMY1394_BASE + 0x00100000)
+#define JMR3927_PCIMEM_BASE	(KSEG1 + JMR3927_PCIMEM)
+#define JMR3927_PCIIO_BASE	(KSEG1 + JMR3927_PCIIO)
+
+#define JMR3927_IOC_REV_ADDR	(JMR3927_IOC_BASE + 0x00000000)
+#define JMR3927_IOC_NVRAMB_ADDR	(JMR3927_IOC_BASE + 0x00010000)
+#define JMR3927_IOC_LED_ADDR	(JMR3927_IOC_BASE + 0x00020000)
+#define JMR3927_IOC_DIPSW_ADDR	(JMR3927_IOC_BASE + 0x00030000)
+#define JMR3927_IOC_BREV_ADDR	(JMR3927_IOC_BASE + 0x00040000)
+#define JMR3927_IOC_DTR_ADDR	(JMR3927_IOC_BASE + 0x00050000)
+#define JMR3927_IOC_INTS1_ADDR	(JMR3927_IOC_BASE + 0x00080000)
+#define JMR3927_IOC_INTS2_ADDR	(JMR3927_IOC_BASE + 0x00090000)
+#define JMR3927_IOC_INTM_ADDR	(JMR3927_IOC_BASE + 0x000a0000)
+#define JMR3927_IOC_INTP_ADDR	(JMR3927_IOC_BASE + 0x000b0000)
+#define JMR3927_IOC_RESET_ADDR	(JMR3927_IOC_BASE + 0x000f0000)
+
+/* bits for IOC_REV/IOC_BREV/ISAC_REV (high byte) */
+#define JMR3927_IDT_MASK	0xfc
+#define JMR3927_REV_MASK	0x03
+#define JMR3927_IOC_IDT		0xe0
+
+/* bits for IOC_INTS1/IOC_INTS2/IOC_INTM/IOC_INTP (high byte) */
+#define JMR3927_IOC_INTB_PCIA	0
+#define JMR3927_IOC_INTB_PCIB	1
+#define JMR3927_IOC_INTB_PCIC	2
+#define JMR3927_IOC_INTB_PCID	3
+#define JMR3927_IOC_INTB_MODEM	4
+#define JMR3927_IOC_INTB_INT6	5
+#define JMR3927_IOC_INTB_INT7	6
+#define JMR3927_IOC_INTB_SOFT	7
+#define JMR3927_IOC_INTF_PCIA	(1 << JMR3927_IOC_INTF_PCIA)
+#define JMR3927_IOC_INTF_PCIB	(1 << JMR3927_IOC_INTB_PCIB)
+#define JMR3927_IOC_INTF_PCIC	(1 << JMR3927_IOC_INTB_PCIC)
+#define JMR3927_IOC_INTF_PCID	(1 << JMR3927_IOC_INTB_PCID)
+#define JMR3927_IOC_INTF_MODEM	(1 << JMR3927_IOC_INTB_MODEM)
+#define JMR3927_IOC_INTF_INT6	(1 << JMR3927_IOC_INTB_INT6)
+#define JMR3927_IOC_INTF_INT7	(1 << JMR3927_IOC_INTB_INT7)
+#define JMR3927_IOC_INTF_SOFT	(1 << JMR3927_IOC_INTB_SOFT)
+
+/* bits for IOC_RESET (high byte) */
+#define JMR3927_IOC_RESET_CPU	1
+#define JMR3927_IOC_RESET_PCI	2
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+#if 0
+#define jmr3927_ioc_reg_out(d, a)	((*(volatile unsigned short *)(a)) = (d) << 8)
+#define jmr3927_ioc_reg_in(a)		(((*(volatile unsigned short *)(a)) >> 8) & 0xff)
+#else
+#if defined(__BIG_ENDIAN)
+#define jmr3927_ioc_reg_out(d, a)	((*(volatile unsigned char *)(a)) = (d))
+#define jmr3927_ioc_reg_in(a)		(*(volatile unsigned char *)(a))
+#elif defined(__LITTLE_ENDIAN)
+#define jmr3927_ioc_reg_out(d, a)	((*(volatile unsigned char *)((a)^1)) = (d))
+#define jmr3927_ioc_reg_in(a)		(*(volatile unsigned char *)((a)^1))
+#else
+#error "No Endian"
+#endif
+#endif
+
+#define jmr3927_have_nvram() \
+	((jmr3927_ioc_reg_in(JMR3927_IOC_REV_ADDR) & JMR3927_IDT_MASK) == JMR3927_IOC_IDT)
+
+/* NVRAM macro */
+#define jmr3927_nvram_in(ofs) \
+	jmr3927_ioc_reg_in(JMR3927_IOC_NVRAMB_ADDR + ((ofs) << 1))
+#define jmr3927_nvram_out(d, ofs) \
+	jmr3927_ioc_reg_out(d, JMR3927_IOC_NVRAMB_ADDR + ((ofs) << 1))
+
+/* LED macro */
+#define jmr3927_led_set(n/*0-16*/)	jmr3927_ioc_reg_out(~(n), JMR3927_IOC_LED_ADDR)
+
+/* DIPSW macro */
+#define jmr3927_dipsw1()	((tx3927_pioptr->din & (1 << 11)) == 0)
+#define jmr3927_dipsw2()	((tx3927_pioptr->din & (1 << 10)) == 0)
+#define jmr3927_dipsw3()	((jmr3927_ioc_reg_in(JMR3927_IOC_DIPSW_ADDR) & 2) == 0)
+#define jmr3927_dipsw4()	((jmr3927_ioc_reg_in(JMR3927_IOC_DIPSW_ADDR) & 1) == 0)
+
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+
+/*
+ * IRQ mappings
+ */
+
+/* These are the virtual IRQ numbers, we divide all IRQ's into
+ * 'spaces', the 'space' determines where and how to enable/disable
+ * that particular IRQ on an JMR machine.  Add new 'spaces' as new
+ * IRQ hardware is supported.
+ */
+#define JMR3927_NR_IRQ_IRC	16	/* On-Chip IRC */
+#define JMR3927_NR_IRQ_IOC	8	/* PCI/MODEM/INT[6:7] */
+#define JMR3927_NR_IRQ_ISAC	8	/* ISA */
+
+
+#define JMR3927_IRQ_IRC	NR_ISA_IRQS
+
+#if 1
+#define JMR3927_IRQ_END 32
+#else
+#define JMR3927_IRQ_IOC	(JMR3927_IRQ_IRC + JMR3927_NR_IRQ_IRC)
+#define JMR3927_IRQ_ISAC	(JMR3927_IRQ_IOC + JMR3927_NR_IRQ_IOC)
+#define JMR3927_IRQ_END	(JMR3927_IRQ_ISAC + JMR3927_NR_IRQ_ISAC)
+#endif
+
+#define JMR3927_IRQ_IS_IRC(irq)	(JMR3927_IRQ_IRC <= (irq) && (irq) < JMR3927_IRQ_IOC)
+#define JMR3927_IRQ_IS_IOC(irq)		(JMR3927_IRQ_IOC <= (irq) && (irq) < JMR3927_IRQ_ISAC)
+#define JMR3927_IRQ_IS_ISAC(irq)	(JMR3927_IRQ_ISAC <= (irq) && (irq) < JMR3927_IRQ_END)
+
+#define JMR3927_IRQ_IRC_INT(ch/*0-5*/)	(JMR3927_IRQ_IRC + TX3927_IR_INT(ch))
+#define JMR3927_IRQ_IRC_SIO(ch)	(JMR3927_IRQ_IRC + TX3927_IR_SIO(ch))
+#define JMR3927_IRQ_IRC_DMA	(JMR3927_IRQ_IRC + TX3927_IR_DMA)
+#define JMR3927_IRQ_IRC_PIO	(JMR3927_IRQ_IRC + TX3927_IR_PIO)
+#define JMR3927_IRQ_IRC_PCI	(JMR3927_IRQ_IRC + TX3927_IR_PCI)
+#define JMR3927_IRQ_IRC_TMR(ch)	(JMR3927_IRQ_IRC + TX3927_IR_TMR(ch))
+#define JMR3927_IRQ_IOC_PCIA	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_PCIA)
+#define JMR3927_IRQ_IOC_PCIB	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_PCIB)
+#define JMR3927_IRQ_IOC_PCIC	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_PCIC)
+#define JMR3927_IRQ_IOC_PCID	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_PCID)
+#define JMR3927_IRQ_IOC_MODEM	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_MODEM)
+#define JMR3927_IRQ_IOC_INT6	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_INT6)
+#define JMR3927_IRQ_IOC_INT7	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_INT7)
+#define JMR3927_IRQ_IOC_SOFT	(JMR3927_IRQ_IOC + JMR3927_IOC_INTB_SOFT)
+
+#if 0	/* auto detect */
+/* RTL8019AS 10M Ether (JMI-3927IO2:JPW2:1-2 Short) */
+#define JMR3927_IRQ_IOB_ETHER	JMR3927_IRQ_IRC_INT(0)
+#endif
+/* IOC (PCI, MODEM) */
+#define JMR3927_IRQ_IOCINT	JMR3927_IRQ_IRC_INT(1)
+/* TC35815 100M Ether */
+#define JMR3927_IRQ_ETHER	JMR3927_IRQ_IRC_INT(3)
+/* Clock Tick (10ms) */
+#define JMR3927_IRQ_TICK	JMR3927_IRQ_IRC_TMR(0)
+
+/* IEEE1394 (Note that this may conflicts with RTL8019AS 10M Ether...) */
+#define JMR3927_IRQ_PREMIER3	JMR3927_IRQ_IRC_INT(0)
+
+/* Clocks */
+#define JMR3927_CORECLK	132710400	/* 132.7MHz */
+#define JMR3927_GBUSCLK	(JMR3927_CORECLK / 2)	/* 66.35MHz */
+#define JMR3927_IMCLK	(JMR3927_CORECLK / 4)	/* 33.17MHz */
+
+#define jmr3927_tmrptr		tx3927_tmrptr(0)	/* TMR0 */
+
+
+/*
+ * TX3927 Pin Configuration:
+ *
+ *	PCFG bits		Avail			Dead
+ *	SELSIO[1:0]:11		RXD[1:0], TXD[1:0]	PIO[6:3]
+ *	SELSIOC[0]:1		CTS[0], RTS[0]		INT[5:4]
+ *	SELSIOC[1]:0,SELDSF:0,	GSDAO[0],GPCST[3]	CTS[1], RTS[1],DSF,
+ *	  GDBGE*					  PIO[2:1]
+ *	SELDMA[2]:1		DMAREQ[2],DMAACK[2]	PIO[13:12]
+ *	SELTMR[2:0]:000					TIMER[1:0]
+ *	SELCS:0,SELDMA[1]:0	PIO[11;10]		SDCS_CE[7:6],
+ *							  DMAREQ[1],DMAACK[1]
+ *	SELDMA[0]:1		DMAREQ[0],DMAACK[0]	PIO[9:8]
+ *	SELDMA[3]:1		DMAREQ[3],DMAACK[3]	PIO[15:14]
+ *	SELDONE:1		DMADONE			PIO[7]
+ *
+ * Usable pins are:
+ *	RXD[1;0],TXD[1:0],CTS[0],RTS[0],
+ *	DMAREQ[0,2,3],DMAACK[0,2,3],DMADONE,PIO[0,10,11]
+ *	INT[3:0]
+ */
+
+#endif /* __ASM_TOSHIBA_BOARDS_JMR3927_H */
diff -Naru linux-2.4.32/include/asm-mips/toshiba-boards/pci.h linux-2.4.32-mct/include/asm-mips/toshiba-boards/pci.h
--- linux-2.4.32/include/asm-mips/toshiba-boards/pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/toshiba-boards/pci.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,23 @@
+/*
+ *  linux/include/asm-mips/toshiba-boards/pci.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ *
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_PCI_H
+#define __ASM_TOSHIBA_BOARDS_PCI_H
+
+extern struct resource toshibaboards_pci_io_resource;
+extern struct resource toshibaboards_pci_mem_resource;
+
+struct pci_dev;
+
+extern int (*toshibaboards_pci_map_irq)(struct pci_dev *dev, u8 slot, u8 pin);
+extern void (*toshibaboards_pci66_init)(void);
+extern struct pci_ops *toshibaboards_pci_ops;
+
+#endif /* __ASM_TOSHIBA_BOARDS_PCI_H */
diff -Naru linux-2.4.32/include/asm-mips/toshiba-boards/pmon.h linux-2.4.32-mct/include/asm-mips/toshiba-boards/pmon.h
--- linux-2.4.32/include/asm-mips/toshiba-boards/pmon.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/toshiba-boards/pmon.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,49 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_PMON_H 
+#define __ASM_TOSHIBA_BOARDS_PMON_H 
+
+#ifndef _LANGUAGE_ASSEMBLY
+struct pmon_vector {
+	int (*read)(int fd, char *buf, int size);
+	int (*write)(int fd, char *buf, int size);
+	int (*open)(char *name, int mode);
+	int (*close)(int fd);
+	int (*ioctl)(int fd, int request, void* arg);
+	int (*printf)(char *fmstr, ...);
+	int (*vsprintf)(char *dst, char *fmtstr, ...);
+	int (*ttctl)(int fd, int op, int ap1, int ap2);
+	void (*exit)(int status);
+	char *(*getenv)(char *name);
+	void (*onintr)(int code, long *dat);
+	void (*flush_cache)(int cache);
+	void (*_exception)(void);
+	int (*_fpstatesz)(void);
+	void (*_fpinit)(void);
+	void *(*_fpstate)(void);
+	void (*cop1)(void);
+	int (*adr2symoff)(char *dst, int value, int width);
+	int (*sym2adr)(long *v, char *label);
+	int (*getclkfreq)(void);
+	void (*_clkinit)(void);
+};
+
+extern struct pmon_vector *pmon_vector;
+
+extern void pmon_printf(char *fmt, ...);
+extern void pmon_halt(void);
+extern void set_pmon_debug_traps(void);
+extern unsigned long toshibaboards_memory_upper;
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+#define PMON_VECTOR	0xbfc00200
+#define PMON_VECTOR_R4K	0xbfc00500 /* with R4KEXCEPTIONS */
+#define PMON_VECTOR_TX39	0xbfc00500 /* with TX39_DEBUG_EXCEPTIONS */
+
+#endif /* __ASM_TOSHIBA_BOARDS_PMON_H */
diff -Naru linux-2.4.32/include/asm-mips/toshiba-boards/rbtx4925.h linux-2.4.32-mct/include/asm-mips/toshiba-boards/rbtx4925.h
--- linux-2.4.32/include/asm-mips/toshiba-boards/rbtx4925.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/toshiba-boards/rbtx4925.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,279 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Toshiba Corporation
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_RBTX4925_H 
+#define __ASM_TOSHIBA_BOARDS_RBTX4925_H 
+
+#include <asm/tx4925.h>
+#include <asm/addrspace.h>
+#include <asm/toshiba-boards/irq.h>
+
+/* CS */
+#if 1
+/* use PMON's setting */
+extern unsigned long rbtx4925_ce_base[8];
+#define RBTX4925_CE0	rbtx4925_ce_base[0]
+#define RBTX4925_CE1	rbtx4925_ce_base[1]
+#define RBTX4925_CE2	rbtx4925_ce_base[2]
+#define RBTX4925_CE3	rbtx4925_ce_base[3]
+#define RBTX4925_CE4	rbtx4925_ce_base[4]
+#define RBTX4925_CE5	rbtx4925_ce_base[5]
+#define RBTX4925_CE6	rbtx4925_ce_base[6]
+#define RBTX4925_CE7	rbtx4925_ce_base[7]
+#else
+#define RBTX4925_CE0	0x1e000000	/* 16M */
+#define RBTX4925_CE1	0x1c000000	/* 16M */
+#define RBTX4925_CE2	0x1b000000	/* 1M */
+#define RBTX4925_CE3	0x10000000	/* 64M */
+#endif
+
+/* Address map */
+#define RBTX4925_FPGA_REG_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00000000)
+#define RBTX4925_BOARD_REV_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00000000)
+#define RBTX4925_FPGA_REV_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00000002)
+#define RBTX4925_CFGA_STAT_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00000004)
+#define RBTX4925_CFGD_STAT_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00000006)
+#define RBTX4925_LED_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00001000)
+#define RBTX4925_DIPSW_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00001002)
+#define RBTX4925_IMASK_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00002000)
+#define RBTX4925_INTPOL_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00002002)
+#define RBTX4925_ISTAT_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00002004)
+#define RBTX4925_IMSTAT_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00002006)
+#define RBTX4925_SOFTINT_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00003000)
+#define RBTX4925_SIODTR_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00003002)
+#define RBTX4925_IMASK2_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00004000)
+#define RBTX4925_INTPOL2_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00004002)
+#define RBTX4925_ISTAT2_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00004004)
+#define RBTX4925_IMSTAT2_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00004006)
+#define RBTX4925_PIOSEL_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00005000)
+#define RBTX4925_SSFDC_WP_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00005002)
+#define RBTX4925_SOFTRESET_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00007000)
+#define RBTX4925_SOFTRESETLOCK_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00007002)
+#define RBTX4925_PCIRESET_ADDR	(KSEG1 + RBTX4925_CE2 + 0x00007004)
+#define RBTX4925_PCMCIA_BASE	(KSEG1 + RBTX4925_CE2 + 0x00010000)
+#define RBTX4925_ETHER_BASE	(KSEG1 + RBTX4925_CE2 + 0x00020000)
+
+/* JMI-TX39IO2 */
+#define RBTX4925_IOB_BASE	(KSEG1 + RBTX4925_CE3)
+
+/* Ethernet port address */
+#define RBTX4925_ETHER_ADDR	(RBTX4925_ETHER_BASE + 0x280)
+
+/* bits for ISTAT/IMASK/IMSTAT */
+#define RBTX4925_INTB_PCID	0
+#define RBTX4925_INTB_PCIC	1
+#define RBTX4925_INTB_PCIB	2
+#define RBTX4925_INTB_PCIA	3
+#define RBTX4925_INTB_DSR	4
+#define RBTX4925_INTB_INT2	5
+#define RBTX4925_INTB_INT3	6
+#define RBTX4925_INTB_SWI	7
+#define RBTX4925_INTF_PCID	(1 << RBTX4925_INTB_PCID)
+#define RBTX4925_INTF_PCIC	(1 << RBTX4925_INTB_PCIC)
+#define RBTX4925_INTF_PCIB	(1 << RBTX4925_INTB_PCIB)
+#define RBTX4925_INTF_PCIA	(1 << RBTX4925_INTB_PCIA)
+#define RBTX4925_INTF_DSR	(1 << RBTX4925_INTB_DSR)
+#define RBTX4925_INTF_INT2	(1 << RBTX4925_INTB_INT2)
+#define RBTX4925_INTF_INT3	(1 << RBTX4925_INTB_INT3)
+#define RBTX4925_INTF_SWI	(1 << RBTX4925_INTB_SWI)
+/* bits for ISTAT2/IMASK2/IMSTAT2 */
+#define RBTX4925_INT2B_PCMCIA	0
+#define RBTX4925_INT2F_PCMCIA	(1 << RBTX4925_INT2B_PCMCIA)
+/* bits for PIOSEL */
+#define RBTX4925_PIOSEL_SIO(ch)	(0x01<<(ch))
+#define RBTX4925_PIOSEL_NOPCTOE	0x04
+#define RBTX4925_PIOSEL_NOSMART	0x08
+#define RBTX4925_PIOSEL_NOACLINK	0x10
+#define RBTX4925_PIOSEL_NOPCMCIA	0x20
+
+#ifndef _LANGUAGE_ASSEMBLY
+#define rbtx4925_board_rev_ptr	\
+	((volatile unsigned char *)RBTX4925_BOARD_REV_ADDR)
+#define rbtx4925_fpga_rev_ptr	\
+	((volatile unsigned char *)RBTX4925_FPGA_REV_ADDR)
+#define rbtx4925_cfga_ptr	\
+	((volatile unsigned char *)RBTX4925_CFGA_ADDR)
+#define rbtx4925_cfgd_ptr	\
+	((volatile unsigned char *)RBTX4925_CFGD_ADDR)
+#define rbtx4925_led_ptr	\
+	((volatile unsigned char *)RBTX4925_LED_ADDR)
+#define rbtx4925_dipsw_ptr	\
+	((volatile unsigned char *)RBTX4925_DIPSW_ADDR)
+#define rbtx4925_imask_ptr	\
+	((volatile unsigned char *)RBTX4925_IMASK_ADDR)
+#define rbtx4925_intpol_ptr	\
+	((volatile unsigned char *)RBTX4925_INTPOL_ADDR)
+#define rbtx4925_istat_ptr	\
+	((volatile unsigned char *)RBTX4925_ISTAT_ADDR)
+#define rbtx4925_imstat_ptr	\
+	((volatile unsigned char *)RBTX4925_IMSTAT_ADDR)
+#define rbtx4925_softint_ptr	\
+	((volatile unsigned char *)RBTX4925_SOFTINT_ADDR)
+#define rbtx4925_siodtr_ptr	\
+	((volatile unsigned char *)RBTX4925_SIODTR_ADDR)
+#define rbtx4925_imask2_ptr	\
+	((volatile unsigned char *)RBTX4925_IMASK2_ADDR)
+#define rbtx4925_intpol2_ptr	\
+	((volatile unsigned char *)RBTX4925_INTPOL2_ADDR)
+#define rbtx4925_istat2_ptr	\
+	((volatile unsigned char *)RBTX4925_ISTAT2_ADDR)
+#define rbtx4925_imstat2_ptr	\
+	((volatile unsigned char *)RBTX4925_IMSTAT2_ADDR)
+#define rbtx4925_piosel_ptr	\
+	((volatile unsigned char *)RBTX4925_PIOSEL_ADDR)
+#define rbtx4925_ssfdc_wp_ptr	\
+	((volatile unsigned char *)RBTX4925_SSFDC_WP_ADDR)
+#define rbtx4925_softreset_ptr	\
+	((volatile unsigned char *)RBTX4925_SOFTRESET_ADDR)
+#define rbtx4925_softresetlock_ptr	\
+	((volatile unsigned char *)RBTX4925_SOFTRESETLOCK_ADDR)
+#define rbtx4925_pcireset_ptr	\
+	((volatile unsigned char *)RBTX4925_PCIRESET_ADDR)
+
+#define rbtx4925_led_on(n)	(*rbtx4925_led_ptr |= 1<<(n))
+#define rbtx4925_led_off(n)	(*rbtx4925_led_ptr = *rbtx4925_led_ptr &~ (1<<(n)))
+#define rbtx4925_led_toggle(n)	(*rbtx4925_led_ptr = *rbtx4925_led_ptr ^(1<<(n)))
+
+/* clock */
+#define RBTX4925_MASTER_CLOCK	20000000 /* 20MHz */
+#define RBTX4925_GBUSCLK	(RBTX4925_MASTER_CLOCK * 4) /* fixed */
+#define RBTX4925_IMCLK		(RBTX4925_GBUSCLK / 2) /* fixed */
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+
+/*
+ * IRQ mappings
+ */
+
+#define RBTX4925_SOFT_INT0	0	/* not used */
+#define RBTX4925_SOFT_INT1	1	/* not used */
+#define RBTX4925_IRC_INT	2
+#define RBTX4925_TIMER_INT	7
+
+/* These are the virtual IRQ numbers, we divide all IRQ's into
+ * 'spaces', the 'space' determines where and how to enable/disable
+ * that particular IRQ on an RBTX4925 machine.  Add new 'spaces' as new
+ * IRQ hardware is supported.
+ */
+#define RBTX4925_NR_IRQ_LOCAL	8
+#define RBTX4925_NR_IRQ_IRC	32	/* On-Chip IRC */
+#define RBTX4925_NR_IRQ_IOC	8
+#define RBTX4925_NR_IRQ_IOC2	8
+#define RBTX4925_NR_IRQ_PCMCIA	8
+#define RBTX4925_NR_IRQ_ISAC	8	/* JMI-TX39IO2 ISA */
+
+#define RBTX4925_IRQ_LOCAL	NR_ISA_IRQS
+#define RBTX4925_IRQ_IRC	(RBTX4925_IRQ_LOCAL + RBTX4925_NR_IRQ_LOCAL)
+#define RBTX4925_IRQ_IOC	(RBTX4925_IRQ_IRC + RBTX4925_NR_IRQ_IRC)
+#define RBTX4925_IRQ_IOC2	(RBTX4925_IRQ_IOC + RBTX4925_NR_IRQ_IOC)
+#define RBTX4925_IRQ_PCMCIA	(RBTX4925_IRQ_IOC2 + RBTX4925_NR_IRQ_IOC2)
+#define RBTX4925_IRQ_ISAC	(RBTX4925_IRQ_PCMCIA + RBTX4925_NR_IRQ_PCMCIA)
+#define RBTX4925_IRQ_END	RBTX4925_IRQ_ISAC
+
+#define RBTX4925_IRQ_LOCAL_SOFT0	(RBTX4925_IRQ_LOCAL + RBTX4925_SOFT_INT0)
+#define RBTX4925_IRQ_LOCAL_SOFT1	(RBTX4925_IRQ_LOCAL + RBTX4925_SOFT_INT0)
+#define RBTX4925_IRQ_LOCAL_IRC	(RBTX4925_IRQ_LOCAL + RBTX4925_IRC_INT)
+#define RBTX4925_IRQ_LOCAL_TIMER	(RBTX4925_IRQ_LOCAL + RBTX4925_TIMER_INT)
+#define RBTX4925_IRQ_IRC_WTOERR	(RBTX4925_IRQ_IRC + TX4925_IR_WTOERR)
+#define RBTX4925_IRQ_IRC_INT(n)	(RBTX4925_IRQ_IRC + TX4925_IR_INT(n))
+#define RBTX4925_IRQ_IRC_NDFMC	(RBTX4925_IRQ_IRC + TX4925_IR_NDFMD)
+#define RBTX4925_IRQ_IRC_SIO(n)	(RBTX4925_IRQ_IRC + TX4925_IR_SIO(n))
+#define RBTX4925_IRQ_IRC_DMA(n)	(RBTX4925_IRQ_IRC + TX4925_IR_DMA(n))
+#define RBTX4925_IRQ_IRC_PIO	(RBTX4925_IRQ_IRC + TX4925_IR_PIO)
+#define RBTX4925_IRQ_IRC_PDMAC	(RBTX4925_IRQ_IRC + TX4925_IR_PDMAC)
+#define RBTX4925_IRQ_IRC_PCIC	(RBTX4925_IRQ_IRC + TX4925_IR_PCIC)
+#define RBTX4925_IRQ_IRC_TMR(n)	(RBTX4925_IRQ_IRC + TX4925_IR_TMR(n))
+#define RBTX4925_IRQ_IRC_SPI	(RBTX4925_IRQ_IRC + TX4925_IR_SPI)
+#define RBTX4925_IRQ_IRC_RTC	(RBTX4925_IRQ_IRC + TX4925_IR_RTC)
+#define RBTX4925_IRQ_IRC_ACLC	(RBTX4925_IRQ_IRC + TX4925_IR_ACLC)
+#define RBTX4925_IRQ_IRC_ACLCPME	(RBTX4925_IRQ_IRC + TX4925_IR_ACLCPME)
+#define RBTX4925_IRQ_IRC_CHI	(RBTX4925_IRQ_IRC + TX4925_IR_CHI)
+#define RBTX4925_IRQ_IRC_PCIERR	(RBTX4925_IRQ_IRC + TX4925_IR_PCIERR)
+#define RBTX4925_IRQ_IRC_PCIPME	(RBTX4925_IRQ_IRC + TX4925_IR_PCIPME)
+#define RBTX4925_IRQ_IOC_PCID	(RBTX4925_IRQ_IOC + RBTX4925_INTB_PCID)
+#define RBTX4925_IRQ_IOC_PCIC	(RBTX4925_IRQ_IOC + RBTX4925_INTB_PCIC)
+#define RBTX4925_IRQ_IOC_PCIB	(RBTX4925_IRQ_IOC + RBTX4925_INTB_PCIB)
+#define RBTX4925_IRQ_IOC_PCIA	(RBTX4925_IRQ_IOC + RBTX4925_INTB_PCIA)
+#define RBTX4925_IRQ_IOC_DSR	(RBTX4925_IRQ_IOC + RBTX4925_INTB_DSR)
+#define RBTX4925_IRQ_IOC_INT2	(RBTX4925_IRQ_IOC + RBTX4925_INTB_INT2)
+#define RBTX4925_IRQ_IOC_INT3	(RBTX4925_IRQ_IOC + RBTX4925_INTB_INT3)
+#define RBTX4925_IRQ_IOC_SWI	(RBTX4925_IRQ_IOC + RBTX4925_INTB_SWI)
+#define RBTX4925_IRQ_IOC_PCMCIA	(RBTX4925_IRQ_IOC2 + RBTX4925_INT2B_PCMCIA)
+
+/* Modem (Do not use this. Set W1 to OPEN and use RBTX4925_IRQ_IOC_DSR */
+/* #define RBTX4925_IRQ_MODEM	RBTX4925_IRQ_IRC_INT(5) */
+/* IOC (PCI, etc) */
+#define RBTX4925_IRQ_IOCINT	RBTX4925_IRQ_IRC_INT(0)
+/* Onboard 10M Ether */
+#define RBTX4925_IRQ_ETHER	RBTX4925_IRQ_IRC_INT(1)
+
+
+/* LinkUp L1121 register definitions */
+#define L1121_IDR1	0x00
+#define L1121_IDR2	0x04
+#define L1121_IDR3	0x08
+#define L1121_IDR4	0x0c
+#define L1121_SR	0x10
+#define L1121_ISR	0x14
+#define L1121_EISR	0x18
+#define L1121_CR1	0x24
+#define L1121_CR2	0x28
+#define L1121_IER	0x2c
+#define L1121_ESNR	0x30
+#define L1121_ITSR	0x34
+#define L1121_ECLR	0x38
+#define L1121_CR3	0x3c
+#define L1121_DACCR	0x40
+#define L1121_DACDR	0x44
+
+#define L1121_IDR1_VAL	0x01
+#define L1121_IDR2_VAL	0x10
+#define L1121_IDR3_VAL	0x12
+#define L1121_IDR4_VAL	0x01
+/* for SR, ISR, EISR, IER, ESNR, ITSR, ECLR */
+#define L1121_CD1	7
+#define L1121_CD2	6
+#define L1121_IOIS16	5 /* IOIS16/WRP */
+#define L1121_VS1	4
+#define L1121_VS2	3
+#define L1121_BVD1	2
+#define L1121_BVD2	1
+#define L1121_RDY	0
+#define L1121_SR_CD1	(1<<L1121_CD1)
+#define L1121_SR_CD2	(1<<L1121_CD2)
+#define L1121_SR_IOIS16	(1<<L1121_IOIS16)
+#define L1121_SR_VS1	(1<<L1121_VS1)
+#define L1121_SR_VS2	(1<<L1121_VS2)
+#define L1121_SR_BVD1	(1<<L1121_BVD1)
+#define L1121_SR_BVD2	(1<<L1121_BVD2)
+#define L1121_SR_RDY	(1<<L1121_RDY)
+#define L1121_CR1_SOE	0x80
+#define L1121_CR1_APOE	0x20
+#define L1121_CR1_RESET	0x10
+#define L1121_CR1_STOE	0x08
+#define L1121_CR1_BIG	0x04
+#define L1121_CR1_IRQP	0x02
+#define L1121_CR1_DIRP	0x01
+#define L1121_CR2_PDCS	0x80
+#define L1121_CR2_RTRIM2	0x40
+#define L1121_CR2_RTRIM1	0x20
+#define L1121_CR2_DISS	0x10
+#define L1121_CR2_S4	0x08
+#define L1121_CR2_S3	0x04
+#define L1121_CR2_S2	0x02
+#define L1121_CR2_S1	0x01
+#define L1121_CR3_MIO	0x10
+#define L1121_CR3_CCDIE	0x08
+#define L1121_CR3_WIRQE	0x04
+#define L1121_CR3_WOR16E	0x02
+#define L1121_CR3_WORWE	0x01
+
+#define L1121_inb(reg)  (*(volatile unsigned char *)(RBTX4925_PCMCIA_BASE + (reg)))
+#define L1121_outb(val, reg)  (*(volatile unsigned char *)(RBTX4925_PCMCIA_BASE + (reg)) = (val))
+
+#endif /* __ASM_TOSHIBA_BOARDS_RBTX4925_H */
diff -Naru linux-2.4.32/include/asm-mips/toshiba-boards/rbtx4927.h linux-2.4.32-mct/include/asm-mips/toshiba-boards/rbtx4927.h
--- linux-2.4.32/include/asm-mips/toshiba-boards/rbtx4927.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/toshiba-boards/rbtx4927.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,181 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_RBTX4927_H 
+#define __ASM_TOSHIBA_BOARDS_RBTX4927_H 
+
+#include <asm/tx4927.h>
+#include <asm/addrspace.h>
+#include <asm/toshiba-boards/irq.h>
+
+/* CS */
+#if 1
+/* use PMON's setting */
+extern unsigned long rbtx4927_ce_base[8];
+#define RBTX4927_CE0	rbtx4927_ce_base[0]
+#define RBTX4927_CE1	rbtx4927_ce_base[1]
+#define RBTX4927_CE2	rbtx4927_ce_base[2]
+#define RBTX4927_CE3	rbtx4927_ce_base[3]
+#define RBTX4927_CE4	rbtx4927_ce_base[4]
+#define RBTX4927_CE5	rbtx4927_ce_base[5]
+#define RBTX4927_CE6	rbtx4927_ce_base[6]
+#define RBTX4927_CE7	rbtx4927_ce_base[7]
+#else
+#define RBTX4927_CE0	0x1f000000	/* 16M */
+#define RBTX4927_CE1	0x1e000000	/* 16M */
+#define RBTX4927_CE2	0x1c000000	/* 1M */
+#define RBTX4927_CE3	0x10000000	/* 64M */
+#endif
+
+/* Address map */
+#define RBTX4927_FPGA_REG_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00000000)
+#define RBTX4927_BOARD_REV_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00000000)
+#define RBTX4927_FPGA_REV_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00000002)
+#define RBTX4927_LED_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00001000)
+#define RBTX4927_DIPSW_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00001002)
+#define RBTX4927_IMASK_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00002000)
+#define RBTX4927_INTPOL_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00002002)
+#define RBTX4927_ISTAT_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00002004)
+#define RBTX4927_IMSTAT_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00002006)
+#define RBTX4927_SOFTINT_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00003000)
+#define RBTX4927_CFGA_STAT_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00004000)
+#define RBTX4927_CFGD_STAT_ADDR	(KSEG1 + RBTX4927_CE2 + 0x00004002)
+#define RBTX4927_SOFTRESET_ADDR	(KSEG1 + RBTX4927_CE2 + 0x0000f000)
+#define RBTX4927_SOFTRESETLOCK_ADDR	(KSEG1 + RBTX4927_CE2 + 0x0000f002)
+#define RBTX4927_PCIRESET_ADDR	(KSEG1 + RBTX4927_CE2 + 0x0000f006)
+#define RBTX4927_BRAMRTC_BASE	(KSEG1 + RBTX4927_CE2 + 0x00010000)
+#define RBTX4927_ETHER_BASE	(KSEG1 + RBTX4927_CE2 + 0x00020000)
+
+/* JMI-TX39IO2 */
+#define RBTX4927_IOB_BASE	(KSEG1 + RBTX4927_CE3)
+
+/* Ethernet port address */
+#define RBTX4927_ETHER_ADDR	(RBTX4927_ETHER_BASE + 0x280)
+
+/* IEEE1394 board */
+#define RBTX4927_JMY1394_BASE	(KSEG1 + RBTX4927_CE5)
+#define RBTX4927_PREMIER3_BASE	(RBTX4927_JMY1394_BASE + 0x00100000)
+
+/* bits for ISTAT/IMASK/IMSTAT */
+#define RBTX4927_INTB_PCID	0
+#define RBTX4927_INTB_PCIC	1
+#define RBTX4927_INTB_PCIB	2
+#define RBTX4927_INTB_PCIA	3
+#define RBTX4927_INTB_DSR	4
+#define RBTX4927_INTB_SWI	5
+#define RBTX4927_INTF_PCID	(1 << RBTX4927_INTB_PCID)
+#define RBTX4927_INTF_PCIC	(1 << RBTX4927_INTB_PCIC)
+#define RBTX4927_INTF_PCIB	(1 << RBTX4927_INTB_PCIB)
+#define RBTX4927_INTF_PCIA	(1 << RBTX4927_INTB_PCIA)
+#define RBTX4927_INTF_DSR	(1 << RBTX4927_INTB_DSR)
+#define RBTX4927_INTF_SWI	(1 << RBTX4927_INTB_SWI)
+
+#ifndef _LANGUAGE_ASSEMBLY
+#define rbtx4927_board_rev_ptr	\
+	((volatile unsigned char *)RBTX4927_BOARD_REV_ADDR)
+#define rbtx4927_fpga_rev_ptr	\
+	((volatile unsigned char *)RBTX4927_FPGA_REV_ADDR)
+#define rbtx4927_led_ptr	\
+	((volatile unsigned char *)RBTX4927_LED_ADDR)
+#define rbtx4927_dipsw_ptr	\
+	((volatile unsigned char *)RBTX4927_DIPSW_ADDR)
+#define rbtx4927_imask_ptr	\
+	((volatile unsigned char *)RBTX4927_IMASK_ADDR)
+#define rbtx4927_intpol_ptr	\
+	((volatile unsigned char *)RBTX4927_INTPOL_ADDR)
+#define rbtx4927_istat_ptr	\
+	((volatile unsigned char *)RBTX4927_ISTAT_ADDR)
+#define rbtx4927_imstat_ptr	\
+	((volatile unsigned char *)RBTX4927_IMSTAT_ADDR)
+#define rbtx4927_softint_ptr	\
+	((volatile unsigned char *)RBTX4927_SOFTINT_ADDR)
+#define rbtx4927_cfga_ptr	\
+	((volatile unsigned char *)RBTX4927_CFGA_ADDR)
+#define rbtx4927_cfgd_ptr	\
+	((volatile unsigned char *)RBTX4927_CFGD_ADDR)
+#define rbtx4927_softreset_ptr	\
+	((volatile unsigned char *)RBTX4927_SOFTRESET_ADDR)
+#define rbtx4927_softresetlock_ptr	\
+	((volatile unsigned char *)RBTX4927_SOFTRESETLOCK_ADDR)
+#define rbtx4927_pcireset_ptr	\
+	((volatile unsigned char *)RBTX4927_PCIRESET_ADDR)
+#define rbtx4927_bramrtc_ptr	\
+	((volatile unsigned char *)RBTX4927_BRAMRTC_BASE)
+
+#define rbtx4927_led_on(n)	(*rbtx4927_led_ptr |= 1<<(n))
+#define rbtx4927_led_off(n)	(*rbtx4927_led_ptr = *rbtx4927_led_ptr &~ (1<<(n)))
+#define rbtx4927_led_toggle(n)	(*rbtx4927_led_ptr = *rbtx4927_led_ptr ^(1<<(n)))
+
+/* clock */
+extern int rbtx4927_master_clock;
+extern int rbtx4927_gbus_clock;
+#define RBTX4927_GBUSCLK	rbtx4927_gbus_clock
+#define RBTX4927_IMCLK		(RBTX4927_GBUSCLK / 2)
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+
+/*
+ * IRQ mappings
+ */
+
+#define RBTX4927_SOFT_INT0	0	/* not used */
+#define RBTX4927_SOFT_INT1	1	/* not used */
+#define RBTX4927_IRC_INT	2
+#define RBTX4927_TIMER_INT	7
+
+/* These are the virtual IRQ numbers, we divide all IRQ's into
+ * 'spaces', the 'space' determines where and how to enable/disable
+ * that particular IRQ on an RBTX4927 machine.  Add new 'spaces' as new
+ * IRQ hardware is supported.
+ */
+#define RBTX4927_NR_IRQ_LOCAL	8
+#define RBTX4927_NR_IRQ_IRC	32	/* On-Chip IRC */
+#define RBTX4927_NR_IRQ_IOC	8	/* IOC */
+#define RBTX4927_NR_IRQ_ISAC	8	/* JMI-TX39IO2 ISA */
+
+#define RBTX4927_IRQ_LOCAL	NR_ISA_IRQS
+#define RBTX4927_IRQ_IRC	(RBTX4927_IRQ_LOCAL + RBTX4927_NR_IRQ_LOCAL)
+#define RBTX4927_IRQ_IOC	(RBTX4927_IRQ_IRC + RBTX4927_NR_IRQ_IRC)
+#define RBTX4927_IRQ_ISAC	(RBTX4927_IRQ_IOC + RBTX4927_NR_IRQ_IOC)
+#define RBTX4927_IRQ_END	RBTX4927_IRQ_ISAC
+
+#define RBTX4927_IRQ_LOCAL_SOFT0	(RBTX4927_IRQ_LOCAL + RBTX4927_SOFT_INT0)
+#define RBTX4927_IRQ_LOCAL_SOFT1	(RBTX4927_IRQ_LOCAL + RBTX4927_SOFT_INT0)
+#define RBTX4927_IRQ_LOCAL_IRC	(RBTX4927_IRQ_LOCAL + RBTX4927_IRC_INT)
+#define RBTX4927_IRQ_LOCAL_TIMER	(RBTX4927_IRQ_LOCAL + RBTX4927_TIMER_INT)
+#define RBTX4927_IRQ_IRC_ECCERR	(RBTX4927_IRQ_IRC + TX4927_IR_ECCERR)
+#define RBTX4927_IRQ_IRC_WTOERR	(RBTX4927_IRQ_IRC + TX4927_IR_WTOERR)
+#define RBTX4927_IRQ_IRC_INT(n)	(RBTX4927_IRQ_IRC + TX4927_IR_INT(n))
+#define RBTX4927_IRQ_IRC_SIO(n)	(RBTX4927_IRQ_IRC + TX4927_IR_SIO(n))
+#define RBTX4927_IRQ_IRC_DMA(n)	(RBTX4927_IRQ_IRC + TX4927_IR_DMA(n))
+#define RBTX4927_IRQ_IRC_PIO	(RBTX4927_IRQ_IRC + TX4927_IR_PIO)
+#define RBTX4927_IRQ_IRC_PDMAC	(RBTX4927_IRQ_IRC + TX4927_IR_PDMAC)
+#define RBTX4927_IRQ_IRC_PCIC	(RBTX4927_IRQ_IRC + TX4927_IR_PCIC)
+#define RBTX4927_IRQ_IRC_TMR(n)	(RBTX4927_IRQ_IRC + TX4927_IR_TMR(n))
+#define RBTX4927_IRQ_IRC_PCIERR	(RBTX4927_IRQ_IRC + TX4927_IR_PCIERR)
+#define RBTX4927_IRQ_IRC_PCIPMA	(RBTX4927_IRQ_IRC + TX4927_IR_PCIPMA)
+#define RBTX4927_IRQ_IRC_ACLC	(RBTX4927_IRQ_IRC + TX4927_IR_ACLC)
+#define RBTX4927_IRQ_IRC_ACKCPMA	(RBTX4927_IRQ_IRC + TX4927_IR_ACKCPMA)
+#define RBTX4927_IRQ_IOC_PCID	(RBTX4927_IRQ_IOC + RBTX4927_INTB_PCID)
+#define RBTX4927_IRQ_IOC_PCIC	(RBTX4927_IRQ_IOC + RBTX4927_INTB_PCIC)
+#define RBTX4927_IRQ_IOC_PCIB	(RBTX4927_IRQ_IOC + RBTX4927_INTB_PCIB)
+#define RBTX4927_IRQ_IOC_PCIA	(RBTX4927_IRQ_IOC + RBTX4927_INTB_PCIA)
+#define RBTX4927_IRQ_IOC_DSR	(RBTX4927_IRQ_IOC + RBTX4927_INTB_DSR)
+#define RBTX4927_IRQ_IOC_SWI	(RBTX4927_IRQ_IOC + RBTX4927_INTB_SWI)
+
+/* Modem (Do not use this. Set W28 to OPEN and use RBTX4927_IRQ_IOC_DSR */
+/* #define RBTX4927_IRQ_MODEM	RBTX4927_IRQ_IRC_INT(0) */
+/* IOC (PCI, etc) */
+#define RBTX4927_IRQ_IOCINT	RBTX4927_IRQ_IRC_INT(1)
+/* Onboard 10M Ether */
+#define RBTX4927_IRQ_ETHER	RBTX4927_IRQ_IRC_INT(3)
+
+/* IEEE1394 (Note that this may conflicts with JMI-TX39IO2 10M Ether...) */
+#define RBTX4927_IRQ_PREMIER3	RBTX4927_IRQ_IRC_INT(0)
+
+#endif /* __ASM_TOSHIBA_BOARDS_RBTX4927_H */
diff -Naru linux-2.4.32/include/asm-mips/toshiba-boards/tsdb.h linux-2.4.32-mct/include/asm-mips/toshiba-boards/tsdb.h
--- linux-2.4.32/include/asm-mips/toshiba-boards/tsdb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/toshiba-boards/tsdb.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,275 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1999-2001 Toshiba Corporation
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_TSDB_H 
+#define __ASM_TOSHIBA_BOARDS_TSDB_H 
+
+#include <asm/v320usc.h>
+#include <asm/addrspace.h>
+#include <asm/toshiba-boards/irq.h>
+
+/* LocalBus/PCI address */
+#if 1
+/*
+ * These definitions are differ from "SDB Hardware Specification" because:
+ *	1. MIPS/Linux is hard to use high(>=0x20000000) physaddr.
+ *	2. Many codes assume that 'bus(PCI) address' == 'physical address'.
+ */
+/* SDRAM Aperture */
+#define	TSDB_LB_SDRAM_APERTURE	0x00000000
+#define	TSDB_PCI_SDRAM_APERTURE	TSDB_LB_SDRAM_APERTURE
+#define	TSDB_SDRAM_APERTURE_ADBITS	4	/* 256M(AD[31:28]) */
+/* ROM Aperture */
+#define	TSDB_LB_ROM_APERTURE	0x1c000000
+#define	TSDB_PCI_ROM_APERTURE	0x00000000	/* NOT USED */
+#define	TSDB_ROM_APERTURE_ADBITS	6	/* 64M(AD[31:26]) */
+/* PCU Aperture LB/PCI address */
+#define	TSDB_LB_PCU_APERTURE	0x10000000
+#define	TSDB_PCI_PCU_APERTURE	0x00000000	/* NOT USED */
+#define	TSDB_PCU_APERTURE_ADBITS	5	/* 128M(AD[31:27]) */
+/* USC REG Aperture (64K) */
+#define	TSDB_LB_USCREG_APERTURE	0x18000000
+#define	TSDB_PCI_USCREG_APERTURE	TSDB_LB_USCREG_APERTURE
+/* PCI Aperture  */
+#define	TSDB_LB_PCI_APERTURE_0	0x19000000
+#define	TSDB_PCI_PCI_APERTURE_0	0x00000000
+#define	TSDB_PCI_APERTURE_0_ADBITS	8	/* 16M(AD[31:24]) */
+#define	TSDB_LB_PCI_APERTURE_1	0x08000000
+#define	TSDB_PCI_PCI_APERTURE_1	TSDB_LB_PCI_APERTURE_1
+#define	TSDB_PCI_APERTURE_1_ADBITS	5	/* 128M(AD[31:27]) */
+
+#else	/* definitions in SDB Hardware Specification */
+
+/* SDRAM Aperture */
+#define	TSDB_LB_SDRAM_APERTURE	0x00000000
+#define	TSDB_PCI_SDRAM_APERTURE	0x10000000
+#define	TSDB_SDRAM_APERTURE_ADBITS	4	/* 256M(AD[31:28]) */
+/* ROM Aperture */
+#define	TSDB_LB_ROM_APERTURE	0x1c000000
+#define	TSDB_PCI_ROM_APERTURE	0x00000000	/* NOT USED */
+#define	TSDB_ROM_APERTURE_ADBITS	6	/* 64M(AD[31:26]) */
+/* PCU Aperture */
+#define	TSDB_LB_PCU_APERTURE	0x10000000
+#define	TSDB_PCI_PCU_APERTURE	0x00000000	/* NOT USED */
+#define	TSDB_PCU_APERTURE_ADBITS	5	/* 128M(AD[31:27]) */
+/* USC REG Aperture (64K) */
+#define	TSDB_LB_USCREG_APERTURE	0x18000000
+#define	TSDB_PCI_USCREG_APERTURE	0x02000000
+/* PCI Aperture */
+#define	TSDB_LB_PCI_APERTURE_0	0x1a000000
+#define	TSDB_PCI_PCI_APERTURE_0	0x00000000
+#define	TSDB_PCI_APERTURE_0_ADBITS	7	/* 32M(AD[31:25]) */
+#define	TSDB_LB_PCI_APERTURE_1	0x40000000
+#define	TSDB_PCI_PCI_APERTURE_1	0x40000000
+#define	TSDB_PCI_APERTURE_1_ADBITS	3	/* 512M(AD[31:29) */
+
+#endif
+
+/* Address map */
+#define TSDB_SUPERIO_BASE	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x04000000)
+#define TSDB_BRAMRTC_BASE	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05000000)
+#define TSDB_DIPSW1_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05100000)
+#define TSDB_DIPSW2_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05100010)
+#define TSDB_LED_ADDR		(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05100020)
+#define TSDB_FLASHWP_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05100030)
+#define TSDB_LEDDISP_BASE	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05200000)
+#define TSDB_PCI_ISTAT_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05300000)
+#define TSDB_IOC_ISTAT_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05300010)
+#define TSDB_NMI_ISTAT_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05300020)
+#define TSDB_PCI_IMASK_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05300030)
+#define TSDB_IOC_IMASK_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05300040)
+#define TSDB_SOFTRESET_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05400000)
+#define TSDB_PCIRESET_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05500000)
+#define TSDB_SOFTINT_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05600000)
+#define TSDB_FPGA_REV_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05700000)
+#define TSDB_BOARD_REV_ADDR	(KSEG1 + TSDB_LB_PCU_APERTURE + 0x05700010)
+#define TSDB_ETHER_BASE		(KSEG1 + TSDB_LB_PCU_APERTURE + 0x06000000)
+#define TSDB_USC_BASE		(KSEG1 + TSDB_LB_USCREG_APERTURE)
+
+/* SuperIO Configuration Register */
+#define TSDB_SUPERIO_CONFIG	(TSDB_SUPERIO_BASE + 0x398)
+/* SuperIO SCC base address */
+#define TSDB_UART0_BASE	(TSDB_SUPERIO_BASE + 0x3f8)
+#define TSDB_UART1_BASE	(TSDB_SUPERIO_BASE + 0x2f8)
+#if 1
+#define TSDB_BASE_BAUD	(24000000 / 13 / 16)	/* 24MHz, prescaler:13 */
+#else
+#define TSDB_BASE_BAUD	(14318180 / 13 / 16)	/* 14.318MHz, prescaler:13 */
+#endif
+/* SuperIO Parallel port address (LPTB) */
+#define TSDB_LPT_ADDR	(TSDB_SUPERIO_BASE + 0x378)
+
+/* Ethernet port address */
+#define TSDB_ETHER_ADDR	(TSDB_ETHER_BASE + 0x300)
+
+
+/* bits for DIPSW1 */
+#define	TSDB_DIPSW1_APL5	0x80
+#define	TSDB_DIPSW1_APL4	0x40
+#define	TSDB_DIPSW1_APL3	0x20
+#define	TSDB_DIPSW1_APL2	0x10
+#define	TSDB_DIPSW1_APL1	0x08
+#define	TSDB_DIPSW1_FLASH_WP	0x04	/* System Flash Write Protect */
+#define	TSDB_DIPSW1_COMM	0x02	/* Debug Comm: Serial/Ether */
+#define	TSDB_DIPSW1_BOOTROM	0x01	/* Boot from Boot PROM */
+
+/* bits for DIPSW2 */
+#define	TSDB_DIPSW2_BUSE	0x80	/* Board Usage: CPCI/StandAlone */
+#define	TSDB_DIPSW2_CLOCK_4	0x00	/* 1:4 (reserved at TX43) */
+#define	TSDB_DIPSW2_CLOCK_2_5	0x20	/* 1:2.5 (1:1.5 at TX43) */
+#define	TSDB_DIPSW2_CLOCK_2	0x40	/* 1:2 */
+#define	TSDB_DIPSW2_CLOCK_3	0x60	/* 1:3 */
+#define	TSDB_DIPSW2_CLOCK_MASK	0x60	/* MaskterClock:SystemClock */
+#define	TSDB_DIPSW2_BIGENDIAN	0x10
+#define	TSDB_DIPSW2_BPROM_AC	0x08	/* Boot PROM can be accessed */
+#define	TSDB_DIPSW2_EPROMBOOT	0x04	/* Boot from ROM Emulator */
+#define	TSDB_DIPSW2_EXTROM_AC	0x02	/* Ext. ROM Can be accessed */
+#define	TSDB_DIPSW2_SYSIF_R43	0x01	/* Syscmd type: 43mode/49mode */
+
+/* bits for PCI_ISTAT/PCI_IMASK */
+#define TSDB_INTB_PCI_SERR	0
+#define TSDB_INTB_PCI_PERR	1
+#define TSDB_INTB_PCI_INTD	2
+#define TSDB_INTB_PCI_INTC	3
+#define TSDB_INTB_PCI_INTB	4
+#define TSDB_INTB_PCI_INTA	5
+#define TSDB_INTB_PCI_ENUM	6
+#define TSDB_INTF_PCI_INTA	(1 << TSDB_INTB_PCI_INTA)
+#define TSDB_INTF_PCI_INTB	(1 << TSDB_INTB_PCI_INTB)
+#define TSDB_INTF_PCI_INTC	(1 << TSDB_INTB_PCI_INTC)
+#define TSDB_INTF_PCI_INTD	(1 << TSDB_INTB_PCI_INTD)
+#define TSDB_INTF_PCI_PERR	(1 << TSDB_INTB_PCI_PERR)
+#define TSDB_INTF_PCI_SERR	(1 << TSDB_INTB_PCI_SERR)
+#define TSDB_INTF_PCI_ENUM	(1 << TSDB_INTB_PCI_ENUM)
+
+/* bits for IOC_ISTAT/IOC_IMASK */
+#define TSDB_INTB_IOC_SOFTINT	0
+#define TSDB_INTB_IOC_PUSHSW	1	/* Int. SW */
+#define TSDB_INTB_IOC_PAR	2	/* Parallel Port */
+#define TSDB_INTB_IOC_UART0	3	/* Debug UART */
+#define TSDB_INTB_IOC_UART1	4	/* User UART */
+#define TSDB_INTB_IOC_UART(ch)	(3 + (ch))
+#define TSDB_INTB_IOC_RTC	5
+#define TSDB_INTF_IOC_SOFTINT	(1 << TSDB_INTB_IOC_SOFTINT)
+#define TSDB_INTF_IOC_PUSHSW	(1 << TSDB_INTB_IOC_PUSHSW)
+#define TSDB_INTF_IOC_PAR	(1 << TSDB_INTB_IOC_PAR)
+#define TSDB_INTF_IOC_UART1	(1 << TSDB_INTB_IOC_UART1)
+#define TSDB_INTF_IOC_UART0	(1 << TSDB_INTB_IOC_UART0)
+#define TSDB_INTF_IOC_UART(ch)	(1 << TSDB_INTB_IOC_UART(ch))
+#define TSDB_INTF_IOC_RTC	(1 << TSDB_INTB_IOC_RTC)
+
+/* bits for NMI_ISTAT */
+#define TSDB_INTB_NMI_DEG	1
+#define TSDB_INTB_NMI_NMI	2
+#define TSDB_INTF_NMI_DEG	(1 << TSDB_INTB_NMI_DEG)
+#define TSDB_INTF_NMI_NMI	(1 << TSDB_INTB_NMI_NMI)
+
+#ifndef _LANGUAGE_ASSEMBLY
+#define tsdb_bramrtc_ptr	((volatile unsigned char *)TSDB_BRAMRTC_BASE)
+#define tsdb_dipsw1_ptr		((volatile unsigned char *)TSDB_DIPSW1_ADDR)
+#define tsdb_dipsw2_ptr		((volatile unsigned char *)TSDB_DIPSW2_ADDR)
+#define tsdb_led_ptr		((volatile unsigned char *)TSDB_LED_ADDR)
+#define tsdb_flashwp_ptr	((volatile unsigned char *)TSDB_FLASHWP_ADDR)
+#define tsdb_leddisp_ptr	((volatile unsigned char *)TSDB_LEDDISP_BASE)
+#define tsdb_pci_istat_ptr	((volatile unsigned char *)TSDB_PCI_ISTAT_ADDR)
+#define tsdb_ioc_istat_ptr	((volatile unsigned char *)TSDB_IOC_ISTAT_ADDR)
+#define tsdb_nmi_istat_ptr	((volatile unsigned char *)TSDB_NMI_ISTAT_ADDR)
+#define tsdb_pci_imask_ptr	((volatile unsigned char *)TSDB_PCI_IMASK_ADDR)
+#define tsdb_ioc_imask_ptr	((volatile unsigned char *)TSDB_IOC_IMASK_ADDR)
+#define tsdb_softreset_ptr	((volatile unsigned char *)TSDB_SOFTRESET_ADDR)
+#define tsdb_pcireset_ptr	((volatile unsigned char *)TSDB_PCIRESET_ADDR)
+#define tsdb_softint_ptr	((volatile unsigned char *)TSDB_SOFTINT_ADDR)
+#define tsdb_fpga_rev_ptr	((volatile unsigned char *)TSDB_FPGA_REV_ADDR)
+#define tsdb_board_rev_ptr	((volatile unsigned char *)TSDB_BOARD_REV_ADDR)
+
+#define tsdb_old_rtc()	(*tsdb_fpga_rev_ptr < 9)
+
+#define tsdb_led_on(n)		(*tsdb_led_ptr |= 1<<(n))
+#define tsdb_led_off(n)		(*tsdb_led_ptr = *tsdb_led_ptr &~ (1<<(n)))
+#define tsdb_led_toggle(n)	(*tsdb_led_ptr = *tsdb_led_ptr ^(1<<(n)))
+#define tsdb_leddisp_addr(addr)	(tsdb_leddisp_ptr+((addr)<<2))
+#define tsdb_leddisp_putc(n, c)	(*tsdb_leddisp_addr(0x38|((n)&7)) = (c))
+extern void tsdb_leddisp_puts(const char *s);
+extern void tsdb_leddisp_put(unsigned long val);
+#endif /* _LANGUAGE_ASSEMBLY */
+
+
+/*
+ * MIPS-IRQ mappings
+ *
+ *	USC0	MIPS-IP2(INT0)	USC Internal Interrupt
+ *	USC1	MIPS-IP3(INT1)	PCI Bus Interrupt, ENUM
+ *	ETHER	MIPS-IP5(INT3)	OnBoard Ether
+ *	IOC	MIPS-IP6(INT4)	UART, Parallel, PushSwitch
+ */
+#define TSDB_SOFT_INT0	0	/* not used */
+#define TSDB_SOFT_INT1	1	/* not used */
+#define TSDB_USC_INT	2
+#define TSDB_PCI_INT	3
+#define TSDB_STACK_INT0	4
+#define TSDB_STACK_INT1	5
+#define TSDB_ETHER_INT	5
+#define TSDB_IOC_INT	6
+#define TSDB_TIMER_INT	7
+
+
+/* These are the virtual IRQ numbers, we divide all IRQ's into
+ * 'spaces', the 'space' determines where and how to enable/disable
+ * that particular IRQ on an TSDB machine.  Add new 'spaces' as new
+ * IRQ hardware is supported.
+ */
+#define TSDB_NR_IRQ_LOCAL	8
+#define TSDB_NR_IRQ_PCI		8
+#define TSDB_NR_IRQ_IOC		16
+#define TSDB_NR_IRQ_USC		32
+
+#define TSDB_IRQ_LOCAL	NR_ISA_IRQS
+#define TSDB_IRQ_PCI	(TSDB_IRQ_LOCAL + TSDB_NR_IRQ_LOCAL)
+#define TSDB_IRQ_IOC	(TSDB_IRQ_PCI + TSDB_NR_IRQ_PCI)
+#define TSDB_IRQ_USC	(TSDB_IRQ_IOC + TSDB_NR_IRQ_IOC)
+#define TSDB_IRQ_END	(TSDB_IRQ_USC + TSDB_NR_IRQ_USC)
+#define TSDB_IRQ_IS_LOCAL(irq)	(TSDB_IRQ_LOCAL <= (irq) && (irq) < TSDB_IRQ_PCI)
+#define TSDB_IRQ_IS_PCI(irq)	(TSDB_IRQ_PCI <= (irq) && (irq) < TSDB_IRQ_IOC)
+#define TSDB_IRQ_IS_IOC(irq)	(TSDB_IRQ_IOC <= (irq) && (irq) < TSDB_IRQ_USC)
+#define TSDB_IRQ_IS_USC(irq)	(TSDB_IRQ_USC <= (irq) && (irq) < TSDB_IRQ_END)
+
+#define TSDB_IRQ_LOCAL_SOFT0	(TSDB_IRQ_LOCAL + TSDB_SOFT_INT0)
+#define TSDB_IRQ_LOCAL_SOFT1	(TSDB_IRQ_LOCAL + TSDB_SOFT_INT0)
+#define TSDB_IRQ_LOCAL_USC	(TSDB_IRQ_LOCAL + TSDB_USC_INT)
+#define TSDB_IRQ_LOCAL_PCI	(TSDB_IRQ_LOCAL + TSDB_PCI_INT)
+#define TSDB_IRQ_LOCAL_STACK0	(TSDB_IRQ_LOCAL + TSDB_STACK_INT0)
+#define TSDB_IRQ_LOCAL_STACK1	(TSDB_IRQ_LOCAL + TSDB_STACK_INT1)
+#define TSDB_IRQ_LOCAL_ETHER	(TSDB_IRQ_LOCAL + TSDB_ETHER_INT)
+#define TSDB_IRQ_LOCAL_IOC	(TSDB_IRQ_LOCAL + TSDB_IOC_INT)
+#define TSDB_IRQ_LOCAL_TIMER	(TSDB_IRQ_LOCAL + TSDB_TIMER_INT)
+#define TSDB_IRQ_PCI_INTA	(TSDB_IRQ_PCI + TSDB_INTB_PCI_INTA)
+#define TSDB_IRQ_PCI_INTB	(TSDB_IRQ_PCI + TSDB_INTB_PCI_INTB)
+#define TSDB_IRQ_PCI_INTC	(TSDB_IRQ_PCI + TSDB_INTB_PCI_INTC)
+#define TSDB_IRQ_PCI_INTD	(TSDB_IRQ_PCI + TSDB_INTB_PCI_INTD)
+#define TSDB_IRQ_PCI_PERR	(TSDB_IRQ_PCI + TSDB_INTB_PCI_PERR)
+#define TSDB_IRQ_PCI_SERR	(TSDB_IRQ_PCI + TSDB_INTB_PCI_SERR)
+#define TSDB_IRQ_PCI_ENUM	(TSDB_IRQ_PCI + TSDB_INTB_PCI_ENUM)
+#define TSDB_IRQ_IOC_SOFTINT	(TSDB_IRQ_IOC + TSDB_INTB_IOC_SOFTINT)
+#define TSDB_IRQ_IOC_PUSHSW	(TSDB_IRQ_IOC + TSDB_INTB_IOC_PUSHSW)
+#define TSDB_IRQ_IOC_PAR	(TSDB_IRQ_IOC + TSDB_INTB_IOC_PAR)
+#define TSDB_IRQ_IOC_UART0	(TSDB_IRQ_IOC + TSDB_INTB_IOC_UART0)
+#define TSDB_IRQ_IOC_UART1	(TSDB_IRQ_IOC + TSDB_INTB_IOC_UART1)
+#define TSDB_IRQ_IOC_UART(ch)	(TSDB_IRQ_IOC + TSDB_INTB_IOC_UART(ch))
+#define TSDB_IRQ_USC_TIMER0	(TSDB_IRQ_USC + USC_INTB_TIMER0)
+#define TSDB_IRQ_USC_TIMER1	(TSDB_IRQ_USC + USC_INTB_TIMER1)
+#define TSDB_IRQ_USC_DMA0	(TSDB_IRQ_USC + USC_INTB_DMA0)
+#define TSDB_IRQ_USC_DMA1	(TSDB_IRQ_USC + USC_INTB_DMA1)
+#define TSDB_IRQ_USC_HBI	(TSDB_IRQ_USC + USC_INTB_HBI)
+#define TSDB_IRQ_USC_WDI	(TSDB_IRQ_USC + USC_INTB_WDI)
+#define TSDB_IRQ_USC_BWI	(TSDB_IRQ_USC + USC_INTB_BWI)
+#define TSDB_IRQ_USC_PSLAVE_PI	(TSDB_IRQ_USC + USC_INTB_PSLAVE_PI)
+#define TSDB_IRQ_USC_PMASTER_PI	(TSDB_IRQ_USC + USC_INTB_PMASTER_PI)
+#define TSDB_IRQ_USC_PCI_T_ABORT	(TSDB_IRQ_USC + USC_INTB_PCI_T_ABORT)
+#define TSDB_IRQ_USC_PCI_M_ABORT	(TSDB_IRQ_USC + USC_INTB_PCI_M_ABORT)
+#define TSDB_IRQ_USC_DRAM_PI	(TSDB_IRQ_USC + USC_INTB_DRAM_PI)
+
+#endif /* __ASM_TOSHIBA_BOARDS_TSDB_H */
diff -Naru linux-2.4.32/include/asm-mips/toshiba-boards/tx4927evb.h linux-2.4.32-mct/include/asm-mips/toshiba-boards/tx4927evb.h
--- linux-2.4.32/include/asm-mips/toshiba-boards/tx4927evb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/toshiba-boards/tx4927evb.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,275 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#ifndef __ASM_TOSHIBA_BOARDS_TX4927EVB_H 
+#define __ASM_TOSHIBA_BOARDS_TX4927EVB_H 
+
+#include <asm/tx4927.h>
+#include <asm/addrspace.h>
+#include <asm/toshiba-boards/irq.h>
+
+/* CS */
+#if 1
+/* use PMON's setting */
+extern unsigned long tx4927evb_ce_base[8];
+#define TX4927EVB_CE0	tx4927evb_ce_base[0]
+#define TX4927EVB_CE1	tx4927evb_ce_base[1]
+#define TX4927EVB_CE2	tx4927evb_ce_base[2]
+#define TX4927EVB_CE3	tx4927evb_ce_base[3]
+#define TX4927EVB_CE4	tx4927evb_ce_base[4]
+#define TX4927EVB_CE5	tx4927evb_ce_base[5]
+#define TX4927EVB_CE6	tx4927evb_ce_base[6]
+#define TX4927EVB_CE7	tx4927evb_ce_base[7]
+#else
+#define TX4927EVB_CE0	0x1f000000	/* 16M */
+#define TX4927EVB_CE1	0x1e000000	/* 16M */
+#define TX4927EVB_CE2	0x1d000000	/* 16M */
+#define TX4927EVB_CE3	0x17f00000	/* 1M */
+#define TX4927EVB_CE4	0x14000000	/* 32M */
+#define TX4927EVB_CE5	0x17000000	/* 4M */
+#define TX4927EVB_CE6	0x16000000	/* 4M */
+#define TX4927EVB_CE7	0x16400000	/* 4M */
+#endif
+
+/* Address map */
+#define TX4927EVB_LEDDISP_BASE	(KSEG1 + TX4927EVB_CE3 + 0x00000000)
+#define TX4927EVB_BRAMRTC_BASE	(KSEG1 + TX4927EVB_CE3 + 0x00010000)
+#define TX4927EVB_SUPERIO_BASE	(KSEG1 + TX4927EVB_CE3 + 0x00020000)
+#define TX4927EVB_KBD_BASE	(KSEG1 + TX4927EVB_CE3 + 0x00030000)
+#define TX4927EVB_FPGA_REG_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040000)
+#define TX4927EVB_DIPSW3_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040000)
+#define TX4927EVB_DIPSW6_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040001)
+#define TX4927EVB_LED_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040002)
+#define TX4927EVB_SOFTRESET_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040003)
+#define TX4927EVB_PCIRESET_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040004)
+#define TX4927EVB_SOFTINT_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040005)
+#define TX4927EVB_INTPOL_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040006)
+#define TX4927EVB_INTPOL2_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040007)
+#define TX4927EVB_NUM_IOC_INTREGS	5
+#define TX4927EVB_ISTAT_ADDR(n)	(KSEG1 + TX4927EVB_CE3 + 0x00040010 + (n))
+#define TX4927EVB_IMASK_ADDR(n)	(KSEG1 + TX4927EVB_CE3 + 0x00040015 + (n))
+#define TX4927EVB_IMSTAT_ADDR(n)	(KSEG1 + TX4927EVB_CE3 + 0x0004001a + (n))
+#define TX4927EVB_NMI_STAT_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x0004001f)
+#define TX4927EVB_PCI_CLK_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040020)
+#define TX4927EVB_EXB_STAT_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040021)
+#define TX4927EVB_SIO_STAT_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040022)
+#define TX4927EVB_FPGA_REV_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040030)
+#define TX4927EVB_BOARD_REV_ADDR	(KSEG1 + TX4927EVB_CE3 + 0x00040031)
+
+#define TX4927EVB_ETHER_BASE		(KSEG1 + TX4927EVB_CE4)
+
+#define TX4927EVB_EXB0_BASE		(KSEG1 + TX4927EVB_CE6)
+#define TX4927EVB_EXB1_BASE		(KSEG1 + TX4927EVB_CE7)
+
+/* SuperIO Configuration Register */
+#define TX4927EVB_SUPERIO_CONFIG	(TX4927EVB_SUPERIO_BASE + 0x398)
+/* SuperIO SCC base address */
+#define TX4927EVB_UART0_BASE	(TX4927EVB_SUPERIO_BASE + 0x3f8)
+#define TX4927EVB_UART1_BASE	(TX4927EVB_SUPERIO_BASE + 0x2f8)
+#if 1
+#define TX4927EVB_BASE_BAUD	(24000000 / 13 / 16)	/* 24MHz, prescaler:13 */
+#else
+#define TX4927EVB_BASE_BAUD	(14318180 / 13 / 16)	/* 14.318MHz, prescaler:13 */
+#endif
+/* SuperIO Parallel port address (LPTB) */
+#define TX4927EVB_LPT_ADDR	(TX4927EVB_SUPERIO_BASE + 0x378)
+
+/* Ethernet port address (Jumperless Mode) */
+#define TX4927EVB_ETHER_ADDR	(TX4927EVB_ETHER_BASE + 0x01000280)
+
+/* Keyboard/Mouse */
+#define TX4927EVB_KBD_ADDR	(TX4927EVB_KBD_BASE + 0x60)
+
+/* IEEE1394 board */
+#define TX4927EVB_JMY1394_BASE	(KSEG1 + TX4927EVB_CE2)
+#define TX4927EVB_PREMIER3_BASE	(TX4927EVB_JMY1394_BASE + 0x00100000)
+
+/* bits for ISTAT0/IMASK0/IMSTAT0 */
+#define TX4927EVB_INT0B_RTC	0
+#define TX4927EVB_INT0B_MOUSE	1
+#define TX4927EVB_INT0B_KB	2
+#define TX4927EVB_INT0B_PIO	3
+#define TX4927EVB_INT0B_SIO(n)	(4 + (n))
+#define TX4927EVB_INT0F_RTC	(1 << TX4927EVB_INT0B_RTC)
+#define TX4927EVB_INT0F_MOUSE	(1 << TX4927EVB_INT0B_MOUSE)
+#define TX4927EVB_INT0F_KB	(1 << TX4927EVB_INT0B_KB)
+#define TX4927EVB_INT0F_PIO	(1 << TX4927EVB_INT0B_PIO)
+#define TX4927EVB_INT0F_SIO(n)	(1 << TX4927EVB_INT0B_SIO(n))
+
+/* bits for ISTAT1/IMASK1/IMSTAT1 */
+#define TX4927EVB_INT1B_EXBINT(n)	(n)
+#define TX4927EVB_INT1B_EXPIN	2
+#define TX4927EVB_INT1B_IDSR(n)	(3 + (n) * 2)
+#define TX4927EVB_INT1B_IDCD(n)	(4 + (n) * 2)
+#define TX4927EVB_INT1F_EXBINT(n)	(1 << TX4927EVB_INT1B_EXBINT(n))
+#define TX4927EVB_INT1F_EXPIN	(1 << TX4927EVB_INT1B_EXPIN)
+#define TX4927EVB_INT1F_IDSR(n)	(1 << TX4927EVB_INT1B_IDSR(n))
+#define TX4927EVB_INT1F_IDCD(n)	(1 << TX4927EVB_INT1B_IDCD(n))
+
+/* bits for ISTAT2/IMASK2/IMSTAT2 */
+#define TX4927EVB_INT2B_SOFTINT	0
+#define TX4927EVB_INT2B_PUSHSW	1
+#define TX4927EVB_INT2F_SOFTINT	(1 << TX4927EVB_INT2B_SOFTINT)
+#define TX4927EVB_INT2F_PUSHSW	(1 << TX4927EVB_INT2B_PUSHSW)
+
+/* bits for ISTAT3/IMASK3/IMSTAT3 */
+#define TX4927EVB_INT3B_PCID	0
+#define TX4927EVB_INT3B_PCIC	1
+#define TX4927EVB_INT3B_PCIB	2
+#define TX4927EVB_INT3B_PCIA	3
+#define TX4927EVB_INT3F_PCID	(1 << TX4927EVB_INT3B_PCID)
+#define TX4927EVB_INT3F_PCIC	(1 << TX4927EVB_INT3B_PCIC)
+#define TX4927EVB_INT3F_PCIB	(1 << TX4927EVB_INT3B_PCIB)
+#define TX4927EVB_INT3F_PCIA	(1 << TX4927EVB_INT3B_PCIA)
+
+/* bits for ISTAT4/IMASK4/IMSTAT4 */
+#define TX4927EVB_INT4B_LANC	0
+#define TX4927EVB_INT4F_LANC	(1 << TX4927EVB_INT4B_LANC)
+
+/* bits for NMI_STAT */
+#define TX4927EVB_INTB_NMI_EXB	0
+#define TX4927EVB_INTB_NMI_EXP	1
+#define TX4927EVB_INTB_NMI_PSW	2
+#define TX4927EVB_INTF_NMI_EXB	(1 << TX4927EVB_INTB_NMI_EXB)
+#define TX4927EVB_INTF_NMI_EXP	(1 << TX4927EVB_INTB_NMI_EXP)
+#define TX4927EVB_INTF_NMI_PSW	(1 << TX4927EVB_INTB_NMI_PSW)
+
+/* bits for PCI_CLK (S6) */
+#define TX4927EVB_PCI_CLK_HOST	0x80
+#define TX4927EVB_PCI_CLK_MASK	(0x0f << 3)
+#define TX4927EVB_PCI_CLK_33	(0x01 << 3)
+#define TX4927EVB_PCI_CLK_25	(0x04 << 3)
+#define TX4927EVB_PCI_CLK_66	(0x09 << 3)
+#define TX4927EVB_PCI_CLK_50	(0x0c << 3)
+#define TX4927EVB_PCI_CLK_ACK	0x04
+#define TX4927EVB_PCI_CLK_ACE	0x02
+#define TX4927EVB_PCI_CLK_ENDIAN	0x01
+
+/* bits for SIO_STAT */
+#define TX4927EVB_SIO_STAT_RI(ch)	(0x01 << (ch * 4))
+#define TX4927EVB_SIO_STAT_DSR(ch)	(0x02 << (ch * 4))
+#define TX4927EVB_SIO_STAT_DCD(ch)	(0x04 << (ch * 4))
+#define TX4927EVB_SIO_STAT_DTR(ch)	(0x08 << (ch * 4))
+
+#ifndef _LANGUAGE_ASSEMBLY
+#define tx4927evb_leddisp_ptr	\
+	((volatile unsigned char *)TX4927EVB_LEDDISP_BASE)
+#define tx4927evb_bramrtc_ptr	\
+	((volatile unsigned char *)TX4927EVB_BRAMRTC_BASE)
+#define tx4927evb_dipsw3_ptr	\
+	((volatile unsigned char *)TX4927EVB_DIPSW3_ADDR)
+#define tx4927evb_dipsw6_ptr	\
+	((volatile unsigned char *)TX4927EVB_DIPSW6_ADDR)
+#define tx4927evb_led_ptr	\
+	((volatile unsigned char *)TX4927EVB_LED_ADDR)
+#define tx4927evb_softreset_ptr	\
+	((volatile unsigned char *)TX4927EVB_SOFTRESET_ADDR)
+#define tx4927evb_pcireset_ptr	\
+	((volatile unsigned char *)TX4927EVB_PCIRESET_ADDR)
+#define tx4927evb_softint_ptr	\
+	((volatile unsigned char *)TX4927EVB_SOFTINT_ADDR)
+#define tx4927evb_intpol_ptr	\
+	((volatile unsigned char *)TX4927EVB_INTPOL_ADDR)
+#define tx4927evb_intpol2_ptr	\
+	((volatile unsigned char *)TX4927EVB_INTPOL2_ADDR)
+#define tx4927evb_istat_ptr(n)	\
+	((volatile unsigned char *)TX4927EVB_ISTAT_ADDR(n))
+#define tx4927evb_imask_ptr(n)	\
+	((volatile unsigned char *)TX4927EVB_IMASK_ADDR(n))
+#define tx4927evb_imstat_ptr(n)	\
+	((volatile unsigned char *)TX4927EVB_IMSTAT_ADDR(n))
+#define tx4927evb_nmi_stat_ptr	\
+	((volatile unsigned char *)TX4927EVB_NMI_STAT_ADDR)
+#define tx4927evb_pci_clk_ptr	\
+	((volatile unsigned char *)TX4927EVB_PCI_CLK_ADDR)
+#define tx4927evb_exb_stat_ptr	\
+	((volatile unsigned char *)TX4927EVB_EXB_STAT_ADDR)
+#define tx4927evb_sio_stat_ptr	\
+	((volatile unsigned char *)TX4927EVB_SIO_STAT_ADDR)
+#define tx4927evb_fpga_rev_ptr	\
+	((volatile unsigned char *)TX4927EVB_FPGA_REV_ADDR)
+#define tx4927evb_board_rev_ptr	\
+	((volatile unsigned char *)TX4927EVB_BOARD_REV_ADDR)
+
+#define tx4927evb_led_on(n)	(*tx4927evb_led_ptr |= 1<<(n))
+#define tx4927evb_led_off(n)	(*tx4927evb_led_ptr = *tx4927evb_led_ptr &~ (1<<(n)))
+#define tx4927evb_led_toggle(n)	(*tx4927evb_led_ptr = *tx4927evb_led_ptr ^(1<<(n)))
+#define tx4927evb_leddisp_addr(addr)	(tx4927evb_leddisp_ptr+((addr)<<2))
+#define tx4927evb_leddisp_putc(n, c)	(*tx4927evb_leddisp_addr(0x38|((n)&7)) = (c))
+extern void tx4927evb_leddisp_puts(const char *s);
+extern void tx4927evb_leddisp_put(unsigned long val);
+
+/* clock */
+extern int tx4927evb_master_clock;
+extern int tx4927evb_gbus_clock;
+#define TX4927EVB_GBUSCLK	tx4927evb_gbus_clock
+#define TX4927EVB_IMCLK		(TX4927EVB_GBUSCLK / 2)
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+
+/*
+ * IRQ mappings
+ */
+
+#define TX4927EVB_SOFT_INT0	0	/* not used */
+#define TX4927EVB_SOFT_INT1	1	/* not used */
+#define TX4927EVB_IRC_INT	2
+#define TX4927EVB_TIMER_INT	7
+
+/* These are the virtual IRQ numbers, we divide all IRQ's into
+ * 'spaces', the 'space' determines where and how to enable/disable
+ * that particular IRQ on an TX4927EVB machine.  Add new 'spaces' as new
+ * IRQ hardware is supported.
+ */
+#define TX4927EVB_NR_IRQ_LOCAL	8
+#define TX4927EVB_NR_IRQ_IRC	32	/* On-Chip IRC */
+#define TX4927EVB_NR_IRQ_IOC	8	/* IOC0, ... IOC4 */
+
+#define TX4927EVB_IRQ_LOCAL	NR_ISA_IRQS
+#define TX4927EVB_IRQ_IRC	(TX4927EVB_IRQ_LOCAL + TX4927EVB_NR_IRQ_LOCAL)
+#define TX4927EVB_IRQ_IOC0	(TX4927EVB_IRQ_IRC + TX4927EVB_NR_IRQ_IRC)
+#define TX4927EVB_IRQ_IOC(n)	(TX4927EVB_IRQ_IOC0 + TX4927EVB_NR_IRQ_IOC*(n))
+#define TX4927EVB_IRQ_END	TX4927EVB_IRQ_IOC(5)
+
+#define TX4927EVB_IRQ_LOCAL_SOFT0	(TX4927EVB_IRQ_LOCAL + TX4927EVB_SOFT_INT0)
+#define TX4927EVB_IRQ_LOCAL_SOFT1	(TX4927EVB_IRQ_LOCAL + TX4927EVB_SOFT_INT0)
+#define TX4927EVB_IRQ_LOCAL_IRC	(TX4927EVB_IRQ_LOCAL + TX4927EVB_IRC_INT)
+#define TX4927EVB_IRQ_LOCAL_TIMER	(TX4927EVB_IRQ_LOCAL + TX4927EVB_TIMER_INT)
+#define TX4927EVB_IRQ_IRC_ECCERR	(TX4927EVB_IRQ_IRC + TX4927_IR_ECCERR)
+#define TX4927EVB_IRQ_IRC_WTOERR	(TX4927EVB_IRQ_IRC + TX4927_IR_WTOERR)
+#define TX4927EVB_IRQ_IRC_INT(n)	(TX4927EVB_IRQ_IRC + TX4927_IR_INT(n))
+#define TX4927EVB_IRQ_IRC_SIO(n)	(TX4927EVB_IRQ_IRC + TX4927_IR_SIO(n))
+#define TX4927EVB_IRQ_IRC_DMA(n)	(TX4927EVB_IRQ_IRC + TX4927_IR_DMA(n))
+#define TX4927EVB_IRQ_IRC_PIO	(TX4927EVB_IRQ_IRC + TX4927_IR_PIO)
+#define TX4927EVB_IRQ_IRC_PDMAC	(TX4927EVB_IRQ_IRC + TX4927_IR_PDMAC)
+#define TX4927EVB_IRQ_IRC_PCIC	(TX4927EVB_IRQ_IRC + TX4927_IR_PCIC)
+#define TX4927EVB_IRQ_IRC_TMR(n)	(TX4927EVB_IRQ_IRC + TX4927_IR_TMR(n))
+#define TX4927EVB_IRQ_IRC_PCIERR	(TX4927EVB_IRQ_IRC + TX4927_IR_PCIERR)
+#define TX4927EVB_IRQ_IRC_PCIPMA	(TX4927EVB_IRQ_IRC + TX4927_IR_PCIPMA)
+#define TX4927EVB_IRQ_IRC_ACLC	(TX4927EVB_IRQ_IRC + TX4927_IR_ACLC)
+#define TX4927EVB_IRQ_IRC_ACKCPMA	(TX4927EVB_IRQ_IRC + TX4927_IR_ACKCPMA)
+#define TX4927EVB_IRQ_IOC_RTC	(TX4927EVB_IRQ_IOC(0) + TX4927EVB_INT0B_RTC)
+#define TX4927EVB_IRQ_IOC_MOUSE	(TX4927EVB_IRQ_IOC(0) + TX4927EVB_INT0B_MOUSE)
+#define TX4927EVB_IRQ_IOC_KB	(TX4927EVB_IRQ_IOC(0) + TX4927EVB_INT0B_KB)
+#define TX4927EVB_IRQ_IOC_PIO	(TX4927EVB_IRQ_IOC(0) + TX4927EVB_INT0B_PIO)
+#define TX4927EVB_IRQ_IOC_SIO(n)	(TX4927EVB_IRQ_IOC(0) + TX4927EVB_INT0B_SIO(n))
+#define TX4927EVB_IRQ_IOC_EXBINT(n)	(TX4927EVB_IRQ_IOC(1) + TX4927EVB_INT1B_EXBINT(n))
+#define TX4927EVB_IRQ_IOC_EXPIN	(TX4927EVB_IRQ_IOC(1) + TX4927EVB_INT1B_EXPIN)
+#define TX4927EVB_IRQ_IOC_IDSR(n)	(TX4927EVB_IRQ_IOC(1) + TX4927EVB_INT1B_IDSR(n))
+#define TX4927EVB_IRQ_IOC_IDCD(n)	(TX4927EVB_IRQ_IOC(1) + TX4927EVB_INT1B_IDCD(n))
+#define TX4927EVB_IRQ_IOC_SOFTINT	(TX4927EVB_IRQ_IOC(2) + TX4927EVB_INT2B_SOFTINT)
+#define TX4927EVB_IRQ_IOC_PUSHSW	(TX4927EVB_IRQ_IOC(2) + TX4927EVB_INT2B_PUSHSW)
+#define TX4927EVB_IRQ_IOC_PCID	(TX4927EVB_IRQ_IOC(3) + TX4927EVB_INT3B_PCID)
+#define TX4927EVB_IRQ_IOC_PCIC	(TX4927EVB_IRQ_IOC(3) + TX4927EVB_INT3B_PCIC)
+#define TX4927EVB_IRQ_IOC_PCIB	(TX4927EVB_IRQ_IOC(3) + TX4927EVB_INT3B_PCIB)
+#define TX4927EVB_IRQ_IOC_PCIA	(TX4927EVB_IRQ_IOC(3) + TX4927EVB_INT3B_PCIA)
+#define TX4927EVB_IRQ_IOC_LANC	(TX4927EVB_IRQ_IOC(4) + TX4927EVB_INT4B_LANC)
+
+#define TX4927EVB_IRQ_PREMIER3	TX4927EVB_IRQ_IOC_EXBINT(0)
+
+#endif /* __ASM_TOSHIBA_BOARDS_TX4927EVB_H */
diff -Naru linux-2.4.32/include/asm-mips/tx3927.h linux-2.4.32-mct/include/asm-mips/tx3927.h
--- linux-2.4.32/include/asm-mips/tx3927.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/tx3927.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,363 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000 Toshiba Corporation
+ */
+#ifndef __ASM_TX3927_H 
+#define __ASM_TX3927_H 
+
+#include <asm/txx927.h>
+
+#define TX3927_REG_BASE	0xfffe0000
+#define TX3927_REG_SIZE	0x00010000
+
+#define TX3927_SDRAMC_REG	(TX3927_REG_BASE + 0x8000)
+#define TX3927_ROMC_REG		(TX3927_REG_BASE + 0x9000)
+#define TX3927_DMA_REG		(TX3927_REG_BASE + 0xb000)
+#define TX3927_IRC_REG		(TX3927_REG_BASE + 0xc000)
+#define TX3927_PCIC_REG		(TX3927_REG_BASE + 0xd000)
+#define TX3927_CCFG_REG		(TX3927_REG_BASE + 0xe000)
+#define TX3927_NR_TMR	3
+#define TX3927_TMR_REG(ch)	((TX3927_REG_BASE + 0xf000) + (ch) * 0x100)
+#define TX3927_NR_SIO	2
+#define TX3927_SIO_REG(ch)	((TX3927_REG_BASE + 0xf300) + (ch) * 0x100)
+#define TX3927_PIO_REG		(TX3927_REG_BASE + 0xf500)
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+struct tx3927_sdramc_reg {
+	volatile unsigned long cr[8];
+	volatile unsigned long tr[3];
+	volatile unsigned long cmd;
+	volatile unsigned long smrs[2];
+};
+
+struct tx3927_romc_reg {
+	volatile unsigned long cr[8];
+};
+
+struct tx3927_dma_reg {
+	struct tx3927_dma_ch_reg {
+		volatile unsigned long cha;
+		volatile unsigned long sar;
+		volatile unsigned long dar;
+		volatile unsigned long cntr;
+		volatile unsigned long sair;
+		volatile unsigned long dair;
+		volatile unsigned long ccr;
+		volatile unsigned long csr;
+	} ch[4];
+	volatile unsigned long dbr[8];
+	volatile unsigned long tdhr;
+	volatile unsigned long mcr;
+	volatile unsigned long unused0;
+};
+
+struct tx3927_irc_reg {
+	volatile unsigned long cer;
+	volatile unsigned long cr[2];
+	volatile unsigned long unused0;
+	volatile unsigned long ilr[8];
+	volatile unsigned long unused1[4];
+	volatile unsigned long imr;
+	volatile unsigned long unused2[7];
+	volatile unsigned long scr;
+	volatile unsigned long unused3[7];
+	volatile unsigned long ssr;
+	volatile unsigned long unused4[7];
+	volatile unsigned long csr;
+};
+
+#include <asm/byteorder.h>
+
+#ifdef __BIG_ENDIAN
+#define endian_def_s2(e1,e2)	\
+	volatile unsigned short e1,e2
+#define endian_def_sb2(e1,e2,e3)	\
+	volatile unsigned short e1;volatile unsigned char e2,e3
+#define endian_def_b2s(e1,e2,e3)	\
+	volatile unsigned char e1,e2;volatile unsigned short e3
+#define endian_def_b4(e1,e2,e3,e4)	\
+	volatile unsigned char e1,e2,e3,e4
+#else
+#define endian_def_s2(e1,e2)	\
+	volatile unsigned short e2,e1
+#define endian_def_sb2(e1,e2,e3)	\
+	volatile unsigned char e3,e2;volatile unsigned short e1
+#define endian_def_b2s(e1,e2,e3)	\
+	volatile unsigned short e3;volatile unsigned char e2,e1
+#define endian_def_b4(e1,e2,e3,e4)	\
+	volatile unsigned char e4,e3,e2,e1
+#endif
+
+struct tx3927_pcic_reg {
+	endian_def_s2(did, vid);
+	endian_def_s2(pcistat, pcicmd);
+	endian_def_b4(cc, scc, rpli, rid);
+	endian_def_b4(unused0, ht, mlt, cls);
+	volatile unsigned long ioba;		/* +10 */
+	volatile unsigned long mba;
+	volatile unsigned long unused1[5];
+	endian_def_s2(svid, ssvid);
+	volatile unsigned long unused2;		/* +30 */
+	endian_def_sb2(unused3, unused4, capptr);
+	volatile unsigned long unused5;
+	endian_def_b4(ml, mg, ip, il);
+	volatile unsigned long unused6;		/* +40 */
+	volatile unsigned long istat;
+	volatile unsigned long iim;
+	volatile unsigned long rrt;
+	volatile unsigned long unused7[3];		/* +50 */
+	volatile unsigned long ipbmma;
+	volatile unsigned long ipbioma;		/* +60 */
+	volatile unsigned long ilbmma;
+	volatile unsigned long ilbioma;
+	volatile unsigned long unused8[9];
+	volatile unsigned long tc;		/* +90 */
+	volatile unsigned long tstat;
+	volatile unsigned long tim;
+	volatile unsigned long tccmd;
+	volatile unsigned long pcirrt;		/* +a0 */
+	volatile unsigned long pcirrt_cmd;
+	volatile unsigned long pcirrdt;
+	volatile unsigned long unused9[3];
+	volatile unsigned long tlboap;
+	volatile unsigned long tlbiap;
+	volatile unsigned long tlbmma;		/* +c0 */
+	volatile unsigned long tlbioma;
+	volatile unsigned long sc_msg;
+	volatile unsigned long sc_be;
+	volatile unsigned long tbl;		/* +d0 */
+	volatile unsigned long unused10[3];
+	volatile unsigned long pwmng;		/* +e0 */
+	volatile unsigned long pwmngs;
+	volatile unsigned long unused11[6];
+	volatile unsigned long req_trace;		/* +100 */
+	volatile unsigned long pbapmc;
+	volatile unsigned long pbapms;
+	volatile unsigned long pbapmim;
+	volatile unsigned long bm;		/* +110 */
+	volatile unsigned long cpcibrs;
+	volatile unsigned long cpcibgs;
+	volatile unsigned long pbacs;
+	volatile unsigned long iobas;		/* +120 */
+	volatile unsigned long mbas;
+	volatile unsigned long lbc;
+	volatile unsigned long lbstat;
+	volatile unsigned long lbim;		/* +130 */
+	volatile unsigned long pcistatim;
+	volatile unsigned long ica;
+	volatile unsigned long icd;
+	volatile unsigned long iiadp;		/* +140 */
+	volatile unsigned long iscdp;
+	volatile unsigned long mmas;
+	volatile unsigned long iomas;
+	volatile unsigned long ipciaddr;		/* +150 */
+	volatile unsigned long ipcidata;
+	volatile unsigned long ipcibe;
+};
+
+struct tx3927_ccfg_reg {
+	volatile unsigned long ccfg;
+	volatile unsigned long crir;
+	volatile unsigned long pcfg;
+	volatile unsigned long tear;
+	volatile unsigned long pdcr;
+};
+
+#undef endian_def_s2(e1,e2)
+#undef endian_def_sb2(e1,e2,e3)
+#undef endian_def_b2s(e1,e2,e3)
+#undef endian_def_b4(e1,e2,e3,e4)
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+/*
+ * SDRAMC
+ */
+
+/*
+ * ROMC
+ */
+
+/*
+ * DMA
+ */
+/* bits for MCR */
+#define TX3927_DMA_MCR_EIS(ch)	(0x10000000<<(ch))
+#define TX3927_DMA_MCR_DIS(ch)	(0x01000000<<(ch))
+#define TX3927_DMA_MCR_RSFIF	0x00000080
+#define TX3927_DMA_MCR_FIFUM(ch)	(0x00000008<<(ch))
+#define TX3927_DMA_MCR_LE	0x00000004
+#define TX3927_DMA_MCR_RPRT	0x00000002
+#define TX3927_DMA_MCR_MSTEN	0x00000001
+
+/* bits for CCRn */
+#define TX3927_DMA_CCR_DBINH	0x04000000
+#define TX3927_DMA_CCR_SBINH	0x02000000
+#define TX3927_DMA_CCR_CHRST	0x01000000
+#define TX3927_DMA_CCR_RVBYTE	0x00800000
+#define TX3927_DMA_CCR_ACKPOL	0x00400000
+#define TX3927_DMA_CCR_REQPL	0x00200000
+#define TX3927_DMA_CCR_EGREQ	0x00100000
+#define TX3927_DMA_CCR_CHDN	0x00080000
+#define TX3927_DMA_CCR_DNCTL	0x00060000
+#define TX3927_DMA_CCR_EXTRQ	0x00010000
+#define TX3927_DMA_CCR_INTRQD	0x0000e000
+#define TX3927_DMA_CCR_INTENE	0x00001000
+#define TX3927_DMA_CCR_INTENC	0x00000800
+#define TX3927_DMA_CCR_INTENT	0x00000400
+#define TX3927_DMA_CCR_CHNEN	0x00000200
+#define TX3927_DMA_CCR_XFACT	0x00000100
+#define TX3927_DMA_CCR_SNOP	0x00000080
+#define TX3927_DMA_CCR_DSTINC	0x00000040
+#define TX3927_DMA_CCR_SRCINC	0x00000020
+#define TX3927_DMA_CCR_XFSZ(order)	(((order) << 2) & 0x0000001c)
+#define TX3927_DMA_CCR_XFSZ_1W	TX3927_DMA_CCR_XFSZ(2)
+#define TX3927_DMA_CCR_XFSZ_4W	TX3927_DMA_CCR_XFSZ(4)
+#define TX3927_DMA_CCR_XFSZ_8W	TX3927_DMA_CCR_XFSZ(5)
+#define TX3927_DMA_CCR_XFSZ_16W	TX3927_DMA_CCR_XFSZ(6)
+#define TX3927_DMA_CCR_XFSZ_32W	TX3927_DMA_CCR_XFSZ(7)
+#define TX3927_DMA_CCR_MEMIO	0x00000002
+#define TX3927_DMA_CCR_ONEAD	0x00000001
+
+/* bits for CSRn */
+#define TX3927_DMA_CSR_CHNACT	0x00000100
+#define TX3927_DMA_CSR_ABCHC	0x00000080
+#define TX3927_DMA_CSR_NCHNC	0x00000040
+#define TX3927_DMA_CSR_NTRNFC	0x00000020
+#define TX3927_DMA_CSR_EXTDN	0x00000010
+#define TX3927_DMA_CSR_CFERR	0x00000008
+#define TX3927_DMA_CSR_CHERR	0x00000004
+#define TX3927_DMA_CSR_DESERR	0x00000002
+#define TX3927_DMA_CSR_SORERR	0x00000001
+
+/*
+ * IRC
+ */
+#define TX3927_IR_MAX_LEVEL	7
+
+/* IRCER : Int. Control Enable */
+#define TX3927_IRCER_ICE	0x00000001
+
+/* IRCR : Int. Control */
+#define TX3927_IRCR_LOW	0x00000000
+#define TX3927_IRCR_HIGH	0x00000001
+#define TX3927_IRCR_DOWN	0x00000002
+#define TX3927_IRCR_UP	0x00000003
+
+/* IRSCR : Int. Status Control */
+#define TX3927_IRSCR_EIClrE	0x00000100
+#define TX3927_IRSCR_EIClr_MASK	0x0000000f
+
+/* IRCSR : Int. Current Status */
+#define TX3927_IRCSR_IF	0x00010000
+#define TX3927_IRCSR_ILV_MASK	0x00000700
+#define TX3927_IRCSR_IVL_MASK	0x0000001f
+
+#define TX3927_IR_INT(ch)	(ch)
+#define TX3927_IR_SIO(ch)	(6 + (ch))
+#define TX3927_IR_DMA	8
+#define TX3927_IR_PIO	9
+#define TX3927_IR_PCI	10
+#define TX3927_IR_TMR(ch)	(13 + (ch))
+#define TX3927_NUM_IR	16
+
+/*
+ * PCIC
+ */
+/* bits for PCICMD */
+/* see PCI_COMMAND_XXX in linux/pci.h */
+
+/* bits for PCISTAT */
+/* see PCI_STATUS_XXX in linux/pci.h */
+#define PCI_STATUS_NEW_CAP	0x0010
+
+/* bits for TC */
+#define TX3927_PCIC_TC_OF16E	0x00000020
+#define TX3927_PCIC_TC_IF8E	0x00000010
+
+/* bits for IOBA/MBA */
+/* see PCI_BASE_ADDRESS_XXX in linux/pci.h */
+
+/* bits for PBAPMC */
+#define TX3927_PCIC_PBAPMC_RPBA	0x00000004
+#define TX3927_PCIC_PBAPMC_PBAEN	0x00000002
+#define TX3927_PCIC_PBAPMC_BMCEN	0x00000001
+
+/* bits for LBSTAT/LBIM */
+#define TX3927_PCIC_LBIM_ALL	0x0000003e
+
+/* bits for PCISTATIM (see also PCI_STATUS_XXX in linux/pci.h */
+#define TX3927_PCIC_PCISTATIM_ALL	0x0000f900
+
+/* bits for LBC */
+#define TX3927_PCIC_LBC_IBSE	0x00004000
+#define TX3927_PCIC_LBC_TIBSE	0x00002000
+#define TX3927_PCIC_LBC_TMFBSE	0x00001000
+#define TX3927_PCIC_LBC_HRST	0x00000800
+#define TX3927_PCIC_LBC_SRST	0x00000400
+#define TX3927_PCIC_LBC_EPCAD	0x00000200
+#define TX3927_PCIC_LBC_MSDSE	0x00000100
+#define TX3927_PCIC_LBC_CRR	0x00000080
+#define TX3927_PCIC_LBC_ILMDE	0x00000040
+#define TX3927_PCIC_LBC_ILIDE	0x00000020
+
+#define TX3927_PCIC_IDSEL_AD_TO_SLOT(ad)	((ad) - 11)
+#define TX3927_PCIC_MAX_DEVNU	TX3927_PCIC_IDSEL_AD_TO_SLOT(32)
+
+/*
+ * CCFG
+ */
+/* CCFG : Chip Configuration */
+#define TX3927_CCFG_TLBOFF	0x00020000
+#define TX3927_CCFG_BEOW	0x00010000
+#define TX3927_CCFG_WR	0x00008000
+#define TX3927_CCFG_TOE	0x00004000
+#define TX3927_CCFG_PCIXARB	0x00002000
+#define TX3927_CCFG_PCI3	0x00001000
+#define TX3927_CCFG_PSNP	0x00000800
+#define TX3927_CCFG_PPRI	0x00000400
+#define TX3927_CCFG_PLLM	0x00000030
+#define TX3927_CCFG_ENDIAN	0x00000004
+#define TX3927_CCFG_HALT	0x00000002
+#define TX3927_CCFG_ACEHOLD	0x00000001
+
+/* PCFG : Pin Configuration */
+#define TX3927_PCFG_SYSCLKEN	0x08000000
+#define TX3927_PCFG_SDRCLKEN_ALL	0x07c00000
+#define TX3927_PCFG_SDRCLKEN(ch)	(0x00400000<<(ch))
+#define TX3927_PCFG_PCICLKEN_ALL	0x003c0000
+#define TX3927_PCFG_PCICLKEN(ch)	(0x00040000<<(ch))
+#define TX3927_PCFG_SELALL	0x0003ffff
+#define TX3927_PCFG_SELCS	0x00020000
+#define TX3927_PCFG_SELDSF	0x00010000
+#define TX3927_PCFG_SELSIOC_ALL	0x0000c000
+#define TX3927_PCFG_SELSIOC(ch)	(0x00004000<<(ch))
+#define TX3927_PCFG_SELSIO_ALL	0x00003000
+#define TX3927_PCFG_SELSIO(ch)	(0x00001000<<(ch))
+#define TX3927_PCFG_SELTMR_ALL	0x00000e00
+#define TX3927_PCFG_SELTMR(ch)	(0x00000200<<(ch))
+#define TX3927_PCFG_SELDONE	0x00000100
+#define TX3927_PCFG_INTDMA_ALL	0x000000f0
+#define TX3927_PCFG_INTDMA(ch)	(0x00000010<<(ch))
+#define TX3927_PCFG_SELDMA_ALL	0x0000000f
+#define TX3927_PCFG_SELDMA(ch)	(0x00000001<<(ch))
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+#define tx3927_sdramcptr	((struct tx3927_sdramc_reg *)TX3927_SDRAMC_REG)
+#define tx3927_romcptr		((struct tx3927_romc_reg *)TX3927_ROMC_REG)
+#define tx3927_dmaptr		((struct tx3927_dma_reg *)TX3927_DMA_REG)
+#define tx3927_ircptr		((struct tx3927_irc_reg *)TX3927_IRC_REG)
+#define tx3927_pcicptr		((struct tx3927_pcic_reg *)TX3927_PCIC_REG)
+#define tx3927_ccfgptr		((struct tx3927_ccfg_reg *)TX3927_CCFG_REG)
+#define tx3927_tmrptr(ch)	((struct txx927_tmr_reg *)TX3927_TMR_REG(ch))
+#define tx3927_sioptr(ch)	((struct txx927_sio_reg *)TX3927_SIO_REG(ch))
+#define tx3927_pioptr		((struct txx927_pio_reg *)TX3927_PIO_REG)
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+#endif /* __ASM_TX3927_H */
diff -Naru linux-2.4.32/include/asm-mips/tx4925.h linux-2.4.32-mct/include/asm-mips/tx4925.h
--- linux-2.4.32/include/asm-mips/tx4925.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/tx4925.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,511 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#ifndef __ASM_MIPS_TX4925_H 
+#define __ASM_MIPS_TX4925_H 
+
+#include <asm/txx927.h>
+
+#define TX4925_REG_BASE	0xff1f0000
+#define TX4925_REG_SIZE	0x00010000
+
+#define TX4925_SDRAMC_REG	(TX4925_REG_BASE + 0x8000)
+#define TX4925_EBUSC_REG	(TX4925_REG_BASE + 0x9000)
+#define TX4925_DMA_REG		(TX4925_REG_BASE + 0xb000)
+#define TX4925_NDFMC_REG	(TX4925_REG_BASE + 0xc000)
+#define TX4925_PCIC_REG		(TX4925_REG_BASE + 0xd000)
+#define TX4925_CCFG_REG		(TX4925_REG_BASE + 0xe000)
+#define TX4925_NR_TMR	3
+#define TX4925_TMR_REG(ch)	((TX4925_REG_BASE + 0xf000) + (ch) * 0x100)
+#define TX4925_NR_SIO	2
+#define TX4925_SIO_REG(ch)	((TX4925_REG_BASE + 0xf300) + (ch) * 0x100)
+#define TX4925_PIO_REG		(TX4925_REG_BASE + 0xf500)
+#define TX4925_IRC_REG		(TX4925_REG_BASE + 0xf600)
+#define TX4925_ACLC_REG		(TX4925_REG_BASE + 0xf700)
+#define TX4925_RTC_REG		(TX4925_REG_BASE + 0xf900)
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+#include <asm/byteorder.h>
+
+struct tx4925_sdramc_reg {
+	volatile unsigned long cr[4];
+	volatile unsigned long unused0[4];
+	volatile unsigned long tr;
+	volatile unsigned long unused1[2];
+	volatile unsigned long cmd;
+	volatile unsigned long sfcmd;
+};
+
+struct tx4925_ebusc_reg {
+	struct {
+		volatile unsigned long cr;
+		volatile unsigned long bar;
+	} ch[8];
+};
+
+struct tx4925_dma_reg {
+	struct tx4925_dma_ch_reg {
+		volatile unsigned long cha;
+		volatile unsigned long sar;
+		volatile unsigned long dar;
+		volatile unsigned long cntr;
+		volatile unsigned long sair;
+		volatile unsigned long dair;
+		volatile unsigned long ccr;
+		volatile unsigned long csr;
+	} ch[4];
+	volatile unsigned long unused[9];
+	volatile unsigned long mfdr;
+	volatile unsigned long mcr;
+};
+
+struct tx4925_ndfmc_reg {
+	volatile unsigned long dtr;
+	volatile unsigned long mcr;
+	volatile unsigned long sr;
+	volatile unsigned long isr;
+	volatile unsigned long imr;
+	volatile unsigned long spr;
+	volatile unsigned long rstr;
+};
+
+struct tx4925_irc_reg {
+	volatile unsigned long cer;
+	volatile unsigned long cr[2];
+	volatile unsigned long unused0;
+	volatile unsigned long ilr[8];
+	volatile unsigned long unused1[4];
+	volatile unsigned long imr;
+	volatile unsigned long unused2[7];
+	volatile unsigned long scr;
+	volatile unsigned long unused3[7];
+	volatile unsigned long ssr;
+	volatile unsigned long unused4[7];
+	volatile unsigned long csr;
+};
+
+struct tx4925_pcic_reg {
+	volatile unsigned long pciid;
+	volatile unsigned long pcistatus;
+	volatile unsigned long pciccrev;
+	volatile unsigned long pcicfg1;
+	volatile unsigned long p2gm0plbase;		/* +10 */
+	volatile unsigned long p2gm1plbase;
+	volatile unsigned long p2gm2pbase;
+	volatile unsigned long p2giopbase;
+	volatile unsigned long unused0[3];		/* +20 */
+	volatile unsigned long pcisid;
+	volatile unsigned long unused1;		/* +30 */
+	volatile unsigned long pcicapptr;
+	volatile unsigned long unused2;
+	volatile unsigned long pcicfg2;
+	volatile unsigned long g2ptocnt;		/* +40 */
+	volatile unsigned long unused3[7];
+	volatile unsigned long g2pcfg;		/* +60 */
+	volatile unsigned long g2pstatus;
+	volatile unsigned long g2pmask;
+	volatile unsigned long unused4[7];
+	volatile unsigned long pcisstatus;
+	volatile unsigned long pcimask;
+	volatile unsigned long p2gcfg;		/* +90 */
+	volatile unsigned long p2gstatus;
+	volatile unsigned long p2gmask;
+	volatile unsigned long p2gccmd;
+	volatile unsigned long unused5[24];		/* +a0 */
+	volatile unsigned long pbareqport;		/* +100 */
+	volatile unsigned long pbacfg;
+	volatile unsigned long pbastatus;
+	volatile unsigned long pbamask;
+	volatile unsigned long pbabm;		/* +110 */
+	volatile unsigned long pbacreq;
+	volatile unsigned long pbacgnt;
+	volatile unsigned long pbacstate;
+	volatile unsigned long g2pm0gbase __attribute__ ((aligned (8))); /* +120 */
+	volatile unsigned long g2pm1gbase __attribute__ ((aligned (8)));
+	volatile unsigned long g2pm2gbase __attribute__ ((aligned (8)));
+	volatile unsigned long g2piogbase __attribute__ ((aligned (8)));
+	volatile unsigned long g2pmmask[3] __attribute__ ((aligned (8)));	/* +140 */
+	volatile unsigned long g2piomask;
+	volatile unsigned long g2pm0pbase __attribute__ ((aligned (8)));		/* +150 */
+	volatile unsigned long g2pm1pbase __attribute__ ((aligned (8)));
+	volatile unsigned long g2pm2pbase __attribute__ ((aligned (8)));
+	volatile unsigned long g2piopbase __attribute__ ((aligned (8)));
+	volatile unsigned long pciccfg __attribute__ ((aligned (8)));	/* +170 */
+	volatile unsigned long pcicstatus;
+	volatile unsigned long pcicmask;
+	volatile unsigned long unused6;
+	volatile unsigned long p2gm0gbase;		/* +180 */
+	volatile unsigned long p2gm0ctr;
+	volatile unsigned long p2gm1gbase;
+	volatile unsigned long p2gm1ctr;
+	volatile unsigned long p2gm2gbase;
+	volatile unsigned long p2gm2ctr;
+	volatile unsigned long p2giogbase;
+	volatile unsigned long p2gioctr;
+	volatile unsigned long g2pcfgadrs;		/* +1a0 */
+	volatile unsigned long g2pcfgdata;
+	volatile unsigned long unused7[2];
+	volatile unsigned long g2pidadrs __attribute__ ((aligned (8)));	/* +1b0 */
+	volatile unsigned long g2piddata __attribute__ ((aligned (8)));
+	volatile unsigned long g2pidcmd __attribute__ ((aligned (8)));
+	volatile unsigned long g2pintack __attribute__ ((aligned (8)));
+	volatile unsigned long g2pspc;
+	volatile unsigned long unused8[12];		/* +1d0 */
+	volatile unsigned long pdmca;		/* +200 */
+	volatile unsigned long pdmga;
+	volatile unsigned long pdmpa;
+	volatile unsigned long pdmctr;
+	volatile unsigned long pdmcfg;
+	volatile unsigned long pdmsts;
+};
+
+struct tx4925_ccfg_reg {
+	volatile unsigned long ccfg;
+	volatile unsigned long revid;
+	volatile unsigned long pcfg;
+	volatile unsigned long toea;
+	volatile unsigned long pdnctr;
+	volatile unsigned long unused0;
+	volatile unsigned long garbp;
+	volatile unsigned long unused1;
+	volatile unsigned long tocnt;
+	volatile unsigned long drqctr;
+	volatile unsigned long clkctr;
+	volatile unsigned long garbc;
+	volatile unsigned long ramp;
+	volatile unsigned long jmpadr;
+};
+
+struct tx4925_rtc_reg {
+	volatile unsigned long rtchi;
+	volatile unsigned long rtclo;
+	volatile unsigned long alarmhi;
+	volatile unsigned long alarmlo;
+	volatile unsigned long rtcctrl;
+	volatile unsigned long rtcint;
+};
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+/*
+ * SDRAMC
+ */
+
+/*
+ * EBUSC
+ */
+
+/*
+ * DMA
+ */
+/* bits for MCR */
+#define TX4925_DMA_MCR_EIS(ch)	(0x10000000<<(ch))
+#define TX4925_DMA_MCR_DIS(ch)	(0x01000000<<(ch))
+#define TX4925_DMA_MCR_RSFIF	0x00000080
+#define TX4925_DMA_MCR_FIFUM(ch)	(0x00000008<<(ch))
+#define TX4925_DMA_MCR_RPRT	0x00000002
+#define TX4925_DMA_MCR_MSTEN	0x00000001
+
+/* bits for CCRn */
+#define TX4925_DMA_CCR_IMMCHN	0x20000000
+#define TX4925_DMA_CCR_USEXFSZ	0x10000000
+#define TX4925_DMA_CCR_LE	0x08000000
+#define TX4925_DMA_CCR_DBINH	0x04000000
+#define TX4925_DMA_CCR_SBINH	0x02000000
+#define TX4925_DMA_CCR_CHRST	0x01000000
+#define TX4925_DMA_CCR_RVBYTE	0x00800000
+#define TX4925_DMA_CCR_ACKPOL	0x00400000
+#define TX4925_DMA_CCR_REQPL	0x00200000
+#define TX4925_DMA_CCR_EGREQ	0x00100000
+#define TX4925_DMA_CCR_CHDN	0x00080000
+#define TX4925_DMA_CCR_DNCTL	0x00060000
+#define TX4925_DMA_CCR_EXTRQ	0x00010000
+#define TX4925_DMA_CCR_INTRQD	0x0000e000
+#define TX4925_DMA_CCR_INTENE	0x00001000
+#define TX4925_DMA_CCR_INTENC	0x00000800
+#define TX4925_DMA_CCR_INTENT	0x00000400
+#define TX4925_DMA_CCR_CHNEN	0x00000200
+#define TX4925_DMA_CCR_XFACT	0x00000100
+#define TX4925_DMA_CCR_SMPCHN	0x00000020
+#define TX4925_DMA_CCR_XFSZ(order)	(((order) << 2) & 0x0000001c)
+#define TX4925_DMA_CCR_XFSZ_1W	TX4925_DMA_CCR_XFSZ(2)
+#define TX4925_DMA_CCR_XFSZ_2W	TX4925_DMA_CCR_XFSZ(3)
+#define TX4925_DMA_CCR_XFSZ_4W	TX4925_DMA_CCR_XFSZ(4)
+#define TX4925_DMA_CCR_XFSZ_8W	TX4925_DMA_CCR_XFSZ(5)
+#define TX4925_DMA_CCR_XFSZ_16W	TX4925_DMA_CCR_XFSZ(6)
+#define TX4925_DMA_CCR_XFSZ_32W	TX4925_DMA_CCR_XFSZ(7)
+#define TX4925_DMA_CCR_MEMIO	0x00000002
+#define TX4925_DMA_CCR_SNGAD	0x00000001
+
+/* bits for CSRn */
+#define TX4925_DMA_CSR_CHNEN	0x00000400
+#define TX4925_DMA_CSR_STLXFER	0x00000200
+#define TX4925_DMA_CSR_CHNACT	0x00000100
+#define TX4925_DMA_CSR_ABCHC	0x00000080
+#define TX4925_DMA_CSR_NCHNC	0x00000040
+#define TX4925_DMA_CSR_NTRNFC	0x00000020
+#define TX4925_DMA_CSR_EXTDN	0x00000010
+#define TX4925_DMA_CSR_CFERR	0x00000008
+#define TX4925_DMA_CSR_CHERR	0x00000004
+#define TX4925_DMA_CSR_DESERR	0x00000002
+#define TX4925_DMA_CSR_SORERR	0x00000001
+
+/*
+ * NDFMC
+ */
+
+/* NDFMCR : NDFMC Mode Control */
+#define TX4925_NDFMCR_WE	0x80
+#define TX4925_NDFMCR_ECC_ALL	0x60
+#define TX4925_NDFMCR_ECC_RESET	0x60
+#define TX4925_NDFMCR_ECC_READ	0x40
+#define TX4925_NDFMCR_ECC_ON	0x20
+#define TX4925_NDFMCR_ECC_OFF	0x00
+#define TX4925_NDFMCR_CE	0x10
+#define TX4925_NDFMCR_BSPRT	0x04
+#define TX4925_NDFMCR_ALE	0x02
+#define TX4925_NDFMCR_CLE	0x01
+
+/* NDFMCR : NDFMC Status */
+#define TX4925_NDFSR_BUSY	0x80
+
+/* NDFMCR : NDFMC Reset */
+#define TX4925_NDFRSTR_RST	0x01
+
+/*
+ * IRC
+ */
+#define TX4925_IR_MAX_LEVEL	7
+
+/* IRCER : Int. Control Enable */
+#define TX4925_IRCER_ICE	0x00000001
+
+/* IRCR : Int. Control */
+#define TX4925_IRCR_LOW	0x00000000
+#define TX4925_IRCR_HIGH	0x00000001
+#define TX4925_IRCR_DOWN	0x00000002
+#define TX4925_IRCR_UP	0x00000003
+
+/* IRSCR : Int. Status Control */
+#define TX4925_IRSCR_EIClrLE	0x00000100
+#define TX4925_IRSCR_EIClrL_MASK	0x0000000f
+
+/* IRCSR : Int. Current Status */
+#define TX4925_IRCSR_IF	0x00010000
+#define TX4925_IRCSR_ILV_MASK	0x00000700
+#define TX4925_IRCSR_IVL_MASK	0x0000001f
+
+#define TX4925_IR_WTOERR	1
+#define TX4925_NUM_IR_INT	8
+#define TX4925_IR_INT(n)	(2 + (n))
+#define TX4925_IR_NDFMC	11
+#define TX4925_NUM_IR_SIO	2
+#define TX4925_IR_SIO(n)	(12 + (n))
+#define TX4925_NUM_IR_DMA	4
+#define TX4925_IR_DMA(n)	(14 + (n))
+#define TX4925_IR_PIO	18
+#define TX4925_IR_PDMAC	19
+#define TX4925_IR_PCIC	10
+#define TX4925_NUM_IR_TMR	3
+#define TX4925_IR_TMR(n)	(21 + (n))
+#define TX4925_IR_SPI	24
+#define TX4925_IR_RTC	25
+#define TX4925_IR_ACLC	26
+#define TX4925_IR_ACLCPME	27
+#define TX4925_IR_CHI	28
+#define TX4925_IR_PCIERR	29
+#define TX4925_IR_PCIPME	30
+#define TX4925_NUM_IR	32
+
+/*
+ * PCIC
+ */
+/* bits for PCICMD */
+/* see PCI_COMMAND_XXX in linux/pci.h */
+
+/* bits for PCISTAT */
+/* see PCI_STATUS_XXX in linux/pci.h */
+
+/* bits for IOBA/MBA */
+/* see PCI_BASE_ADDRESS_XXX in linux/pci.h */
+
+/* bits for G2PCFG */
+#define TX4925_PCIC_G2PCFG_BSWAPM0	0x00000800
+#define TX4925_PCIC_G2PCFG_BSWAPM1	0x00000400
+#define TX4925_PCIC_G2PCFG_BSWAPM2	0x00000200
+#define TX4925_PCIC_G2PCFG_BSWAPIO	0x00000100
+#define TX4925_PCIC_G2PCFG_G2PM0EN	0x00000080
+#define TX4925_PCIC_G2PCFG_G2PM1EN	0x00000040
+#define TX4925_PCIC_G2PCFG_G2PM2EN	0x00000020
+#define TX4925_PCIC_G2PCFG_G2PIOEN	0x00000010
+#define TX4925_PCIC_G2PCFG_IRBER	0x00000008
+#define TX4925_PCIC_G2PCFG_BSWAPI	0x00000002
+#define TX4925_PCIC_G2PCFG_ASERR	0x00000001
+
+/* bits for G2PSTATUS/G2PMASK */
+#define TX4925_PCIC_G2PSTATUS_ALL	0x000001ff
+#define TX4925_PCIC_G2PSTATUS_IOBFE	0x00000100
+#define TX4925_PCIC_G2PSTATUS_IIBFE	0x00000080
+#define TX4925_PCIC_G2PSTATUS_MDFE	0x00000040
+#define TX4925_PCIC_G2PSTATUS_MDPE	0x00000020
+#define TX4925_PCIC_G2PSTATUS_IDICC	0x00000010
+#define TX4925_PCIC_G2PSTATUS_MIDPE	0x00000008
+#define TX4925_PCIC_G2PSTATUS_MIDFE	0x00000004
+#define TX4925_PCIC_G2PSTATUS_IDTTOE	0x00000002
+#define TX4925_PCIC_G2PSTATUS_IDRTOE	0x00000001
+
+/* bits for PCIMASK (see also PCI_STATUS_XXX in linux/pci.h */
+#define TX4925_PCIC_PCISTATUS_ALL	0x0000f900
+
+/* bits for PBACFG */
+#define TX4925_PCIC_PBACFG_FIXPA	0x00000008
+#define TX4925_PCIC_PBACFG_RPBA	0x00000004
+#define TX4925_PCIC_PBACFG_PBAEN	0x00000002
+#define TX4925_PCIC_PBACFG_BMCEN	0x00000001
+
+/* bits for PCICSTATUS/PCICMASK */
+#define TX4925_PCIC_PCICSTATUS_ALL	0x00000001
+#define TX4925_PCIC_PCICSTATUS_SERR	0x00000001
+
+/* bits for PCICCFG */
+#define TX4925_PCIC_PCICCFG_GBWC_MASK	0x000fff00
+#define TX4925_PCIC_PCICCFG_TOE	0x00000010
+#define TX4925_PCIC_PCICCFG_HRST	0x00000008
+#define TX4925_PCIC_PCICCFG_SRST	0x00000004
+#define TX4925_PCIC_PCICCFG_TCAR	0x00000002
+#define TX4925_PCIC_PCICCFG_LCFG	0x00000001
+
+/* bits for P2GMnCTR */
+#define TX4925_PCIC_P2GMnCTR_AM	0x1ff00000
+#define TX4925_PCIC_P2GMnCTR_TPRBL_MASK	0x00000700
+#define TX4925_PCIC_P2GMnCTR_TPRBL_1DW	0x00000000
+#define TX4925_PCIC_P2GMnCTR_TPRBL_4DW	0x00000100
+#define TX4925_PCIC_P2GMnCTR_TPRBL_8DW	0x00000200
+#define TX4925_PCIC_P2GMnCTR_TPRBL_16DW	0x00000300
+#define TX4925_PCIC_P2GMnCTR_TPRBL_32DW	0x00000400
+#define TX4925_PCIC_P2GMnCTR_TMCC	0x00000010
+#define TX4925_PCIC_P2GMnCTR_TMCE	0x00000008
+#define TX4925_PCIC_P2GMnCTR_PE	0x00000004
+#define TX4925_PCIC_P2GMnCTR_EN	0x00000002
+#define TX4925_PCIC_P2GMnCTR_BSWAP	0x00000001
+
+/* bits for P2GIOCTR */
+#define TX4925_PCIC_P2GIOCTR_AM	0x0000ff00
+#define TX4925_PCIC_P2GIOCTR_EN	0x00000002
+#define TX4925_PCIC_P2GIOCTR_BSWAP	0x00000001
+
+#define TX4925_PCIC_IDSEL_AD_TO_SLOT(ad)	((ad) - 11)
+#define TX4925_PCIC_MAX_DEVNU	TX4925_PCIC_IDSEL_AD_TO_SLOT(32)
+
+/*
+ * CCFG
+ */
+/* CCFG : Chip Configuration */
+#define TX4925_CCFG_RF_MASK	0x03000000
+#define TX4925_CCFG_RF_FULL	0x00000000
+#define TX4925_CCFG_RF_DIV2	0x01000000
+#define TX4925_CCFG_RF_DIV4	0x02000000
+#define TX4925_CCFG_RF_DIV8	0x03000000
+#define TX4925_CCFG_PCIMODE	0x00100000
+#define TX4925_CCFG_TINTDIS	0x00020000
+#define TX4925_CCFG_BEOW	0x00010000
+#define TX4925_CCFG_WR	0x00008000
+#define TX4925_CCFG_TOE	0x00004000
+#define TX4925_CCFG_PCIARB	0x00002000
+#define TX4925_CCFG_BSM	0x00001000
+#define TX4925_CCFG_SYSSP_MASK	0x000000c0
+#define TX4925_CCFG_BCLKSP_MASK	0x00000030
+#define TX4925_CCFG_PCTRCE	0x00000008
+#define TX4925_CCFG_ENDIAN	0x00000004
+#define TX4925_CCFG_WDRST	0x00000002
+#define TX4925_CCFG_UAEHOLD	0x00000001
+
+/* PCFG : Pin Configuration */
+#define TX4925_PCFG_SYSCLKEN	0x80000000
+#define TX4925_PCFG_SDCLKEN_ALL	0x60000000
+#define TX4925_PCFG_SDCLKEN(ch)	(0x20000000<<(ch))
+#define TX4925_PCFG_PCICLKEN_ALL	0x1c000000
+#define TX4925_PCFG_PCICLKEN(ch)	(0x04000000<<(ch))
+#define TX4925_PCFG_SELBCLK	0x00400000
+#define TX4925_PCFG_SELSPI	0x00200000
+#define TX4925_PCFG_SELCHIK	0x00100000
+#define TX4925_PCFG_SELCARD_ALL	0x000c0000
+#define TX4925_PCFG_SELCARD(ch)	(0x00040000<<(ch))
+#define TX4925_PCFG_SELCE_ALL	0x00030000
+#define TX4925_PCFG_SELCE(ch)	(0x00010000<<(ch))
+#define TX4925_PCFG_SELSIOC_ALL	0x0000c000
+#define TX4925_PCFG_SELSIOC(ch)	(0x00004000<<(ch))
+#define TX4925_PCFG_SELSIO_ALL	0x00003000
+#define TX4925_PCFG_SELSIO(ch)	(0x00001000<<(ch))
+#define TX4925_PCFG_ACKIN	0x00000800
+#define TX4925_PCFG_SELTMR_ALL	0x00000600
+#define TX4925_PCFG_SELTMR(ch)	(0x00000200<<(ch))
+#define TX4925_PCFG_SELDONE	0x00000100
+#define TX4925_PCFG_SELACLC	0x00000008
+#define TX4925_PCFG_SELNAND	0x00000004
+#define TX4925_PCFG_SELDMA_ALL	0x00000003
+#define TX4925_PCFG_SELDMA(ch)	(0x00000001<<(ch))
+
+/* DRQCTR : DMA Request Control */
+#define TX4925_DRQCTR_SIO0RX	0
+#define TX4925_DRQCTR_SIO1RX	1
+#define TX4925_DRQCTR_SIO0TX	2
+#define TX4925_DRQCTR_SIO1TX	3
+#define TX4925_DRQCTR_ACLC0	4
+#define TX4925_DRQCTR_ACLC1	5
+#define TX4925_DRQCTR_ACLC2	6
+#define TX4925_DRQCTR_ACLC3	7
+#define TX4925_DRQCTR_DREQ	8
+
+/* CLKCTR : Clock Control */
+#define TX4925_CLKCTR_PCICKE	0x08000000
+#define TX4925_CLKCTR_DMACKE	0x04000000
+#define TX4925_CLKCTR_DESCKE	0x02000000
+#define TX4925_CLKCTR_SIO0CKE	0x01000000
+#define TX4925_CLKCTR_SIO1CKE	0x00800000
+#define TX4925_CLKCTR_TMR0CKE	0x00400000
+#define TX4925_CLKCTR_TMR1CKE	0x00200000
+#define TX4925_CLKCTR_TMR2CKE	0x00100000
+#define TX4925_CLKCTR_CHICKE	0x00080000
+#define TX4925_CLKCTR_SPICKE	0x00040000
+#define TX4925_CLKCTR_ACLCKE	0x00020000
+#define TX4925_CLKCTR_PIOCKE	0x00010000
+#define TX4925_CLKCTR_PCIRSTI	0x00000800
+#define TX4925_CLKCTR_DMARSTI	0x00000400
+#define TX4925_CLKCTR_DESRSTI	0x00000200
+#define TX4925_CLKCTR_SIO0RSTI	0x00000100
+#define TX4925_CLKCTR_SIO1RSTI	0x00000080
+#define TX4925_CLKCTR_TMR0RSTI	0x00000040
+#define TX4925_CLKCTR_TMR1RSTI	0x00000020
+#define TX4925_CLKCTR_TMR2RSTI	0x00000010
+#define TX4925_CLKCTR_CHIRSTI	0x00000008
+#define TX4925_CLKCTR_SPIRSTI	0x00000004
+#define TX4925_CLKCTR_ACLRSTI	0x00000002
+#define TX4925_CLKCTR_PIORSTI	0x00000001
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+#define tx4925_sdramcptr	((struct tx4925_sdramc_reg *)TX4925_SDRAMC_REG)
+#define tx4925_ebuscptr		((struct tx4925_ebusc_reg *)TX4925_EBUSC_REG)
+#define tx4925_dmaptr		((struct tx4925_dma_reg *)TX4925_DMA_REG)
+#define tx4925_ndfmcptr		((struct tx4925_ndfmc_reg *)TX4925_NDFMC_REG)
+#define tx4925_ircptr		((struct tx4925_irc_reg *)TX4925_IRC_REG)
+#define tx4925_pcicptr		((struct tx4925_pcic_reg *)TX4925_PCIC_REG)
+#define tx4925_ccfgptr		((struct tx4925_ccfg_reg *)TX4925_CCFG_REG)
+#define tx4925_tmrptr(ch)	((struct txx927_tmr_reg *)TX4925_TMR_REG(ch))
+#define tx4925_sioptr(ch)	((struct txx927_sio_reg *)TX4925_SIO_REG(ch))
+#define tx4925_pioptr		((struct txx927_pio_reg *)TX4925_PIO_REG)
+#define tx4925_aclcptr		((struct tx4925_aclc_reg *)TX4925_ACLC_REG)
+#define tx4925_rtcptr		((struct tx4925_rtc_reg *)TX4925_RTC_REG)
+
+#define TX4925_REV_MAJ_MIN()	(tx4925_ccfgptr->revid & 0x00ff)
+#define TX4925_REV_PCODE()	(tx4925_ccfgptr->revid >> 16)
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+#endif /* __ASM_MIPS_TX4925_H */
diff -Naru linux-2.4.32/include/asm-mips/tx4927.h linux-2.4.32-mct/include/asm-mips/tx4927.h
--- linux-2.4.32/include/asm-mips/tx4927.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/tx4927.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,507 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ */
+#ifndef __ASM_MIPS_TX4927_H 
+#define __ASM_MIPS_TX4927_H 
+
+#include <asm/txx927.h>
+
+#define TX4927_REG_BASE	0xff1f0000
+#define TX4927_REG_SIZE	0x00010000
+
+#define TX4927_SDRAMC_REG	(TX4927_REG_BASE + 0x8000)
+#define TX4927_EBUSC_REG	(TX4927_REG_BASE + 0x9000)
+#define TX4927_DMA_REG		(TX4927_REG_BASE + 0xb000)
+#define TX4927_IRC_REG		(TX4927_REG_BASE + 0xf600)
+#define TX4927_PCIC_REG		(TX4927_REG_BASE + 0xd000)
+#define TX4927_CCFG_REG		(TX4927_REG_BASE + 0xe000)
+#define TX4927_NR_TMR	3
+#define TX4927_TMR_REG(ch)	((TX4927_REG_BASE + 0xf000) + (ch) * 0x100)
+#define TX4927_NR_SIO	2
+#define TX4927_SIO_REG(ch)	((TX4927_REG_BASE + 0xf300) + (ch) * 0x100)
+#define TX4927_PIO_REG		(TX4927_REG_BASE + 0xf500)
+#define TX4927_ACLC_REG		(TX4927_REG_BASE + 0xf700)
+
+#ifdef _LANGUAGE_ASSEMBLY
+#define _CONST64(c)	c
+#else
+#define _CONST64(c)	c##ull
+
+#include <asm/byteorder.h>
+
+#ifdef __BIG_ENDIAN
+#define endian_def_l2(e1,e2)	\
+	volatile unsigned long e1,e2
+#define endian_def_s2(e1,e2)	\
+	volatile unsigned short e1,e2
+#define endian_def_sb2(e1,e2,e3)	\
+	volatile unsigned short e1;volatile unsigned char e2,e3
+#define endian_def_b2s(e1,e2,e3)	\
+	volatile unsigned char e1,e2;volatile unsigned short e3
+#define endian_def_b4(e1,e2,e3,e4)	\
+	volatile unsigned char e1,e2,e3,e4
+#else
+#define endian_def_l2(e1,e2)	\
+	volatile unsigned long e2,e1
+#define endian_def_s2(e1,e2)	\
+	volatile unsigned short e2,e1
+#define endian_def_sb2(e1,e2,e3)	\
+	volatile unsigned char e3,e2;volatile unsigned short e1
+#define endian_def_b2s(e1,e2,e3)	\
+	volatile unsigned short e3;volatile unsigned char e2,e1
+#define endian_def_b4(e1,e2,e3,e4)	\
+	volatile unsigned char e4,e3,e2,e1
+#endif
+
+struct tx4927_sdramc_reg {
+	volatile unsigned long long cr[4];
+	volatile unsigned long long unused0[4];
+	volatile unsigned long long tr;
+	volatile unsigned long long unused1[2];
+	volatile unsigned long long cmd;
+};
+
+struct tx4927_ebusc_reg {
+	volatile unsigned long long cr[8];
+};
+
+struct tx4927_dma_reg {
+	struct tx4927_dma_ch_reg {
+		volatile unsigned long long cha;
+		volatile unsigned long long sar;
+		volatile unsigned long long dar;
+		endian_def_l2(unused0, cntr);
+		endian_def_l2(unused1, sair);
+		endian_def_l2(unused2, dair);
+		endian_def_l2(unused3, ccr);
+		endian_def_l2(unused4, csr);
+	} ch[4];
+	volatile unsigned long long dbr[8];
+	volatile unsigned long long tdhr;
+	volatile unsigned long long midr;
+	endian_def_l2(unused0, mcr);
+};
+
+struct tx4927_irc_reg {
+	volatile unsigned long cer;
+	volatile unsigned long cr[2];
+	volatile unsigned long unused0;
+	volatile unsigned long ilr[8];
+	volatile unsigned long unused1[4];
+	volatile unsigned long imr;
+	volatile unsigned long unused2[7];
+	volatile unsigned long scr;
+	volatile unsigned long unused3[7];
+	volatile unsigned long ssr;
+	volatile unsigned long unused4[7];
+	volatile unsigned long csr;
+};
+
+struct tx4927_pcic_reg {
+	volatile unsigned long pciid;
+	volatile unsigned long pcistatus;
+	volatile unsigned long pciccrev;
+	volatile unsigned long pcicfg1;
+	volatile unsigned long p2gm0plbase;		/* +10 */
+	volatile unsigned long p2gm0pubase;
+	volatile unsigned long p2gm1plbase;
+	volatile unsigned long p2gm1pubase;
+	volatile unsigned long p2gm2pbase;		/* +20 */
+	volatile unsigned long p2giopbase;
+	volatile unsigned long unused0;
+	volatile unsigned long pcisid;
+	volatile unsigned long unused1;		/* +30 */
+	volatile unsigned long pcicapptr;
+	volatile unsigned long unused2;
+	volatile unsigned long pcicfg2;
+	volatile unsigned long g2ptocnt;		/* +40 */
+	volatile unsigned long unused3[15];
+	volatile unsigned long g2pstatus;		/* +80 */
+	volatile unsigned long g2pmask;
+	volatile unsigned long pcisstatus;
+	volatile unsigned long pcimask;
+	volatile unsigned long p2gcfg;		/* +90 */
+	volatile unsigned long p2gstatus;
+	volatile unsigned long p2gmask;
+	volatile unsigned long p2gccmd;
+	volatile unsigned long unused4[24];		/* +a0 */
+	volatile unsigned long pbareqport;		/* +100 */
+	volatile unsigned long pbacfg;
+	volatile unsigned long pbastatus;
+	volatile unsigned long pbamask;
+	volatile unsigned long pbabm;		/* +110 */
+	volatile unsigned long pbacreq;
+	volatile unsigned long pbacgnt;
+	volatile unsigned long pbacstate;
+	volatile unsigned long long g2pmgbase[3];		/* +120 */
+	volatile unsigned long long g2piogbase;
+	volatile unsigned long g2pmmask[3];		/* +140 */
+	volatile unsigned long g2piomask;
+	volatile unsigned long long g2pmpbase[3];		/* +150 */
+	volatile unsigned long long g2piopbase;
+	volatile unsigned long pciccfg;		/* +170 */
+	volatile unsigned long pcicstatus;
+	volatile unsigned long pcicmask;
+	volatile unsigned long unused5;
+	volatile unsigned long long p2gmgbase[3];		/* +180 */
+	volatile unsigned long long p2giogbase;
+	volatile unsigned long g2pcfgadrs;		/* +1a0 */
+	volatile unsigned long g2pcfgdata;
+	volatile unsigned long unused6[8];
+	volatile unsigned long g2pintack;
+	volatile unsigned long g2pspc;
+	volatile unsigned long unused7[12];		/* +1d0 */
+	volatile unsigned long long pdmca;		/* +200 */
+	volatile unsigned long long pdmga;
+	volatile unsigned long long pdmpa;
+	volatile unsigned long long pdmcut;
+	volatile unsigned long long pdmcnt;		/* +220 */
+	volatile unsigned long long pdmsts;
+	volatile unsigned long long unused8[2];
+	volatile unsigned long long pdmdb[4];		/* +240 */
+	volatile unsigned long long pdmtdh;		/* +260 */
+	volatile unsigned long long pdmdms;
+};
+
+struct tx4927_ccfg_reg {
+	volatile unsigned long long ccfg;
+	volatile unsigned long long crir;
+	volatile unsigned long long pcfg;
+	volatile unsigned long long tear;
+	volatile unsigned long long clkctr;
+	volatile unsigned long long unused0;
+	volatile unsigned long long garbc;
+	volatile unsigned long long unused1;
+	volatile unsigned long long unused2;
+	volatile unsigned long long ramp;
+};
+
+struct tx4927_aclc_reg {
+	volatile unsigned long acctlen;
+	volatile unsigned long acctldis;
+	volatile unsigned long acregacc;
+	volatile unsigned long unused0;
+	volatile unsigned long acintsts;
+	volatile unsigned long acintmsts;
+	volatile unsigned long acinten;
+	volatile unsigned long acintdis;
+	volatile unsigned long acsemaph;
+	volatile unsigned long unused1[7];
+	volatile unsigned long acgpidat;
+	volatile unsigned long acgpodat;
+	volatile unsigned long acslten;
+	volatile unsigned long acsltdis;
+	volatile unsigned long acfifosts;
+	volatile unsigned long unused2[11];
+	volatile unsigned long acdmasts;
+	volatile unsigned long acdmasel;
+	volatile unsigned long unused3[6];
+	volatile unsigned long acaudodat;
+	volatile unsigned long acsurrdat;
+	volatile unsigned long accentdat;
+	volatile unsigned long aclfedat;
+	volatile unsigned long acaudiat;
+	volatile unsigned long unused4;
+	volatile unsigned long acmodoat;
+	volatile unsigned long acmodidat;
+	volatile unsigned long unused5[15];
+	volatile unsigned long acrevid;
+};
+
+#undef endian_def_l2
+#undef endian_def_s2(e1,e2)
+#undef endian_def_sb2(e1,e2,e3)
+#undef endian_def_b2s(e1,e2,e3)
+#undef endian_def_b4(e1,e2,e3,e4)
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+/*
+ * SDRAMC
+ */
+
+/*
+ * EBUSC
+ */
+
+/*
+ * DMA
+ */
+/* bits for MCR */
+#define TX4927_DMA_MCR_EIS(ch)	(0x10000000<<(ch))
+#define TX4927_DMA_MCR_DIS(ch)	(0x01000000<<(ch))
+#define TX4927_DMA_MCR_RSFIF	0x00000080
+#define TX4927_DMA_MCR_FIFUM(ch)	(0x00000008<<(ch))
+#define TX4927_DMA_MCR_RPRT	0x00000002
+#define TX4927_DMA_MCR_MSTEN	0x00000001
+
+/* bits for CCRn */
+#define TX4927_DMA_CCR_IMMCHN	0x20000000
+#define TX4927_DMA_CCR_USEXFSZ	0x10000000
+#define TX4927_DMA_CCR_LE	0x08000000
+#define TX4927_DMA_CCR_DBINH	0x04000000
+#define TX4927_DMA_CCR_SBINH	0x02000000
+#define TX4927_DMA_CCR_CHRST	0x01000000
+#define TX4927_DMA_CCR_RVBYTE	0x00800000
+#define TX4927_DMA_CCR_ACKPOL	0x00400000
+#define TX4927_DMA_CCR_REQPL	0x00200000
+#define TX4927_DMA_CCR_EGREQ	0x00100000
+#define TX4927_DMA_CCR_CHDN	0x00080000
+#define TX4927_DMA_CCR_DNCTL	0x00060000
+#define TX4927_DMA_CCR_EXTRQ	0x00010000
+#define TX4927_DMA_CCR_INTRQD	0x0000e000
+#define TX4927_DMA_CCR_INTENE	0x00001000
+#define TX4927_DMA_CCR_INTENC	0x00000800
+#define TX4927_DMA_CCR_INTENT	0x00000400
+#define TX4927_DMA_CCR_CHNEN	0x00000200
+#define TX4927_DMA_CCR_XFACT	0x00000100
+#define TX4927_DMA_CCR_SMPCHN	0x00000020
+#define TX4927_DMA_CCR_XFSZ(order)	(((order) << 2) & 0x0000001c)
+#define TX4927_DMA_CCR_XFSZ_1W	TX4927_DMA_CCR_XFSZ(2)
+#define TX4927_DMA_CCR_XFSZ_2W	TX4927_DMA_CCR_XFSZ(3)
+#define TX4927_DMA_CCR_XFSZ_4W	TX4927_DMA_CCR_XFSZ(4)
+#define TX4927_DMA_CCR_XFSZ_8W	TX4927_DMA_CCR_XFSZ(5)
+#define TX4927_DMA_CCR_XFSZ_16W	TX4927_DMA_CCR_XFSZ(6)
+#define TX4927_DMA_CCR_XFSZ_32W	TX4927_DMA_CCR_XFSZ(7)
+#define TX4927_DMA_CCR_MEMIO	0x00000002
+#define TX4927_DMA_CCR_SNGAD	0x00000001
+
+/* bits for CSRn */
+#define TX4927_DMA_CSR_CHNEN	0x00000400
+#define TX4927_DMA_CSR_STLXFER	0x00000200
+#define TX4927_DMA_CSR_CHNACT	0x00000100
+#define TX4927_DMA_CSR_ABCHC	0x00000080
+#define TX4927_DMA_CSR_NCHNC	0x00000040
+#define TX4927_DMA_CSR_NTRNFC	0x00000020
+#define TX4927_DMA_CSR_EXTDN	0x00000010
+#define TX4927_DMA_CSR_CFERR	0x00000008
+#define TX4927_DMA_CSR_CHERR	0x00000004
+#define TX4927_DMA_CSR_DESERR	0x00000002
+#define TX4927_DMA_CSR_SORERR	0x00000001
+
+/*
+ * IRC
+ */
+#define TX4927_IR_MAX_LEVEL	7
+
+/* IRCER : Int. Control Enable */
+#define TX4927_IRCER_ICE	0x00000001
+
+/* IRCR : Int. Control */
+#define TX4927_IRCR_LOW	0x00000000
+#define TX4927_IRCR_HIGH	0x00000001
+#define TX4927_IRCR_DOWN	0x00000002
+#define TX4927_IRCR_UP	0x00000003
+
+/* IRSCR : Int. Status Control */
+#define TX4927_IRSCR_EIClrHE	0x01000000
+#define TX4927_IRSCR_EIClrH_MASK	0x000f0000
+#define TX4927_IRSCR_EIClrLE	0x00000100
+#define TX4927_IRSCR_EIClrL_MASK	0x0000000f
+
+/* IRCSR : Int. Current Status */
+#define TX4927_IRCSR_IF	0x00010000
+#define TX4927_IRCSR_ILV_MASK	0x00000700
+#define TX4927_IRCSR_IVL_MASK	0x0000001f
+
+#define TX4927_IR_ECCERR	0
+#define TX4927_IR_WTOERR	1
+#define TX4927_NUM_IR_INT	6
+#define TX4927_IR_INT(n)	(2 + (n))
+#define TX4927_NUM_IR_SIO	2
+#define TX4927_IR_SIO(n)	(8 + (n))
+#define TX4927_NUM_IR_DMA	4
+#define TX4927_IR_DMA(n)	(10 + (n))
+#define TX4927_IR_PIO	14
+#define TX4927_IR_PDMAC	15
+#define TX4927_IR_PCIC	16
+#define TX4927_NUM_IR_TMR	3
+#define TX4927_IR_TMR(n)	(17 + (n))
+#define TX4927_IR_PCIERR	22
+#define TX4927_IR_PCIPME	23
+#define TX4927_IR_ACLC	24
+#define TX4927_IR_ACLCPME	25
+#define TX4927_NUM_IR	32
+
+/*
+ * PCIC
+ */
+/* bits for PCICMD */
+/* see PCI_COMMAND_XXX in linux/pci.h */
+
+/* bits for PCISTAT */
+/* see PCI_STATUS_XXX in linux/pci.h */
+
+/* bits for IOBA/MBA */
+/* see PCI_BASE_ADDRESS_XXX in linux/pci.h */
+
+/* bits for G2PSTATUS/G2PMASK */
+#define TX4927_PCIC_G2PSTATUS_ALL	0x00000003
+#define TX4927_PCIC_G2PSTATUS_TTOE	0x00000002
+#define TX4927_PCIC_G2PSTATUS_RTOE	0x00000001
+
+/* bits for PCIMASK (see also PCI_STATUS_XXX in linux/pci.h */
+#define TX4927_PCIC_PCISTATUS_ALL	0x0000f900
+
+/* bits for PBACFG */
+#define TX4927_PCIC_PBACFG_FIXPA	0x00000008
+#define TX4927_PCIC_PBACFG_RPBA	0x00000004
+#define TX4927_PCIC_PBACFG_PBAEN	0x00000002
+#define TX4927_PCIC_PBACFG_BMCEN	0x00000001
+
+/* bits for G2PMnGBASE */
+#define TX4927_PCIC_G2PMnGBASE_BSDIS	_CONST64(0x0000002000000000)
+#define TX4927_PCIC_G2PMnGBASE_ECHG	_CONST64(0x0000001000000000)
+
+/* bits for G2PIOGBASE */
+#define TX4927_PCIC_G2PIOGBASE_BSDIS	_CONST64(0x0000002000000000)
+#define TX4927_PCIC_G2PIOGBASE_ECHG	_CONST64(0x0000001000000000)
+
+/* bits for PCICSTATUS/PCICMASK */
+#define TX4927_PCIC_PCICSTATUS_ALL	0x000007dc
+#define TX4927_PCIC_PCICSTATUS_PMESID	0x00000400
+#define TX4927_PCIC_PCICSTATUS_TLBD	0x00000200
+#define TX4927_PCIC_PCICSTATUS_NIBD	0x00000100
+#define TX4927_PCIC_PCICSTATUS_ZIBD	0x00000080
+#define TX4927_PCIC_PCICSTATUS_PERRO	0x00000020
+#define TX4927_PCIC_PCICSTATUS_SERRO	0x00000010
+#define TX4927_PCIC_PCICSTATUS_GBED	0x00000008
+#define TX4927_PCIC_PCICSTATUS_IAA	0x00000004
+#define TX4927_PCIC_PCICSTATUS_IWB	0x00000002
+#define TX4927_PCIC_PCICSTATUS_E2PDONE	0x00000001
+
+/* bits for PCICCFG */
+#define TX4927_PCIC_PCICCFG_LBWC_MASK	0x0fff0000
+#define TX4927_PCIC_PCICCFG_HRST	0x00000800
+#define TX4927_PCIC_PCICCFG_SRST	0x00000400
+#define TX4927_PCIC_PCICCFG_IRBER	0x00000200
+#define TX4927_PCIC_PCICCFG_IMSE(ch)	(0x00000100>>(ch))
+#define TX4927_PCIC_PCICCFG_IMSE0	0x00000100
+#define TX4927_PCIC_PCICCFG_IMSE1	0x00000080
+#define TX4927_PCIC_PCICCFG_IMSE2	0x00000040
+#define TX4927_PCIC_PCICCFG_IISE	0x00000020
+#define TX4927_PCIC_PCICCFG_ATR	0x00000010
+#define TX4927_PCIC_PCICCFG_ICAE	0x00000008
+
+/* bits for P2GMnGBASE */
+#define TX4927_PCIC_P2GMnGBASE_TMEMEN	_CONST64(0x0000004000000000)
+#define TX4927_PCIC_P2GMnGBASE_TBSDIS	_CONST64(0x0000002000000000)
+#define TX4927_PCIC_P2GMnGBASE_TECHG	_CONST64(0x0000001000000000)
+
+/* bits for P2GIOGBASE */
+#define TX4927_PCIC_P2GIOGBASE_TIOEN	_CONST64(0x0000004000000000)
+#define TX4927_PCIC_P2GIOGBASE_TBSDIS	_CONST64(0x0000002000000000)
+#define TX4927_PCIC_P2GIOGBASE_TECHG	_CONST64(0x0000001000000000)
+
+#define TX4927_PCIC_IDSEL_AD_TO_SLOT(ad)	((ad) - 11)
+#define TX4927_PCIC_MAX_DEVNU	TX4927_PCIC_IDSEL_AD_TO_SLOT(32)
+
+/*
+ * CCFG
+ */
+/* CCFG : Chip Configuration */
+#define TX4927_CCFG_WDRST	_CONST64(0x0000020000000000)
+#define TX4927_CCFG_WDREXEN	_CONST64(0x0000010000000000)
+#define TX4927_CCFG_BCFG_MASK	_CONST64(0x000000ff00000000)
+#define TX4927_CCFG_TINTDIS	0x01000000
+#define TX4927_CCFG_PCI66	0x00800000
+#define TX4927_CCFG_PCIMIDE	0x00400000
+#define TX4927_CCFG_DIVMODE2_MASK	0x00080000
+#define TX4927_CCFG_DIVMODE2_4	0x00000000
+#define TX4927_CCFG_DIVMODE2_1	0x00080000
+#define TX4927_CCFG_DIVMODE_MASK	0x00060000
+#define TX4927_CCFG_DIVMODE_2	0x00000000
+#define TX4927_CCFG_DIVMODE_3	0x00020000
+#define TX4927_CCFG_DIVMODE_4	0x00040000
+#define TX4927_CCFG_DIVMODE_2_5	0x00060000
+#define TX4927_CCFG_BEOW	0x00010000
+#define TX4927_CCFG_WR	0x00008000
+#define TX4927_CCFG_TOE	0x00004000
+#define TX4927_CCFG_PCIXARB	0x00002000
+#define TX4927_CCFG_PCIDIVMODE_MASK	0x00001800
+#define TX4927_CCFG_PCIDIVMODE_2_5	0x00000000
+#define TX4927_CCFG_PCIDIVMODE_3	0x00000800
+#define TX4927_CCFG_PCIDIVMODE_5	0x00001000
+#define TX4927_CCFG_PCIDIVMODE_6	0x00001800
+#define TX4927_CCFG_SYSSP_MASK	0x000000c0
+#define TX4927_CCFG_ENDIAN	0x00000004
+#define TX4927_CCFG_HALT	0x00000002
+#define TX4927_CCFG_ACEHOLD	0x00000001
+
+/* PCFG : Pin Configuration */
+#define TX4927_PCFG_SDCLKDLY_MASK	0x30000000
+#define TX4927_PCFG_SDCLKDLY(d)	((d)<<28)
+#define TX4927_PCFG_SYSCLKEN	0x08000000
+#define TX4927_PCFG_SDCLKEN_ALL	0x07800000
+#define TX4927_PCFG_SDCLKEN(ch)	(0x00800000<<(ch))
+#define TX4927_PCFG_PCICLKEN_ALL	0x003f0000
+#define TX4927_PCFG_PCICLKEN(ch)	(0x00010000<<(ch))
+#define TX4927_PCFG_SEL2	0x00000200
+#define TX4927_PCFG_SEL1	0x00000100
+#define TX4927_PCFG_DMASEL_ALL	0x000000ff
+#define TX4927_PCFG_DMASEL0_MASK	0x00000003
+#define TX4927_PCFG_DMASEL1_MASK	0x0000000c
+#define TX4927_PCFG_DMASEL2_MASK	0x00000030
+#define TX4927_PCFG_DMASEL3_MASK	0x000000c0
+#define TX4927_PCFG_DMASEL0_DRQ0	0x00000000
+#define TX4927_PCFG_DMASEL0_SIO1	0x00000001
+#define TX4927_PCFG_DMASEL0_ACL0	0x00000002
+#define TX4927_PCFG_DMASEL0_ACL2	0x00000003
+#define TX4927_PCFG_DMASEL1_DRQ1	0x00000000
+#define TX4927_PCFG_DMASEL1_SIO1	0x00000004
+#define TX4927_PCFG_DMASEL1_ACL1	0x00000008
+#define TX4927_PCFG_DMASEL1_ACL3	0x0000000c
+#define TX4927_PCFG_DMASEL2_DRQ2	0x00000000	/* SEL2=0 */
+#define TX4927_PCFG_DMASEL2_SIO0	0x00000010	/* SEL2=0 */
+#define TX4927_PCFG_DMASEL2_ACL1	0x00000000	/* SEL2=1 */
+#define TX4927_PCFG_DMASEL2_ACL2	0x00000020	/* SEL2=1 */
+#define TX4927_PCFG_DMASEL2_ACL0	0x00000030	/* SEL2=1 */
+#define TX4927_PCFG_DMASEL3_DRQ3	0x00000000
+#define TX4927_PCFG_DMASEL3_SIO0	0x00000040
+#define TX4927_PCFG_DMASEL3_ACL3	0x00000080
+#define TX4927_PCFG_DMASEL3_ACL1	0x000000c0
+
+/* CLKCTR : Clock Control */
+#define TX4927_CLKCTR_ACLCKD	0x02000000
+#define TX4927_CLKCTR_PIOCKD	0x01000000
+#define TX4927_CLKCTR_DMACKD	0x00800000
+#define TX4927_CLKCTR_PCICKD	0x00400000
+#define TX4927_CLKCTR_TM0CKD	0x00100000
+#define TX4927_CLKCTR_TM1CKD	0x00080000
+#define TX4927_CLKCTR_TM2CKD	0x00040000
+#define TX4927_CLKCTR_SIO0CKD	0x00020000
+#define TX4927_CLKCTR_SIO1CKD	0x00010000
+#define TX4927_CLKCTR_ACLRST	0x00000200
+#define TX4927_CLKCTR_PIORST	0x00000100
+#define TX4927_CLKCTR_DMARST	0x00000080
+#define TX4927_CLKCTR_PCIRST	0x00000040
+#define TX4927_CLKCTR_TM0RST	0x00000010
+#define TX4927_CLKCTR_TM1RST	0x00000008
+#define TX4927_CLKCTR_TM2RST	0x00000004
+#define TX4927_CLKCTR_SIO0RST	0x00000002
+#define TX4927_CLKCTR_SIO1RST	0x00000001
+
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+#define tx4927_sdramcptr	((struct tx4927_sdramc_reg *)TX4927_SDRAMC_REG)
+#define tx4927_ebuscptr		((struct tx4927_ebusc_reg *)TX4927_EBUSC_REG)
+#define tx4927_dmaptr		((struct tx4927_dma_reg *)TX4927_DMA_REG)
+#define tx4927_ircptr		((struct tx4927_irc_reg *)TX4927_IRC_REG)
+#define tx4927_pcicptr		((struct tx4927_pcic_reg *)TX4927_PCIC_REG)
+#define tx4927_ccfgptr		((struct tx4927_ccfg_reg *)TX4927_CCFG_REG)
+#define tx4927_tmrptr(ch)	((struct txx927_tmr_reg *)TX4927_TMR_REG(ch))
+#define tx4927_sioptr(ch)	((struct txx927_sio_reg *)TX4927_SIO_REG(ch))
+#define tx4927_pioptr		((struct txx927_pio_reg *)TX4927_PIO_REG)
+#define tx4927_aclcptr		((struct tx4927_aclc_reg *)TX4927_ACLC_REG)
+
+#define TX4927_REV_MAJ_MIN()	((unsigned long)tx4927_ccfgptr->crir & 0x00ff)
+#define TX4927_REV_PCODE()	((unsigned long)tx4927_ccfgptr->crir >> 16)
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+#endif /* __ASM_MIPS_TX4927_H */
diff -Naru linux-2.4.32/include/asm-mips/txx927.h linux-2.4.32-mct/include/asm-mips/txx927.h
--- linux-2.4.32/include/asm-mips/txx927.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.32-mct/include/asm-mips/txx927.h	2006-12-02 15:08:43.000000000 +0100
@@ -0,0 +1,180 @@
+/*
+ * Common difinitins for TX3927/TX4927
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000 Toshiba Corporation
+ */
+#ifndef __ASM_TXX927_H 
+#define __ASM_TXX927_H 
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+struct txx927_tmr_reg {
+	volatile unsigned long tcr;
+	volatile unsigned long tisr;
+	volatile unsigned long cpra;
+	volatile unsigned long cprb;
+	volatile unsigned long itmr;
+	volatile unsigned long unused0[3];
+	volatile unsigned long ccdr;
+	volatile unsigned long unused1[3];
+	volatile unsigned long pgmr;
+	volatile unsigned long unused2[3];
+	volatile unsigned long wtmr;
+	volatile unsigned long unused3[43];
+	volatile unsigned long trr;
+};
+
+struct txx927_sio_reg {
+	volatile unsigned long lcr;
+	volatile unsigned long dicr;
+	volatile unsigned long disr;
+	volatile unsigned long cisr;
+	volatile unsigned long fcr;
+	volatile unsigned long flcr;
+	volatile unsigned long bgr;
+	volatile unsigned long tfifo;
+	volatile unsigned long rfifo;
+};
+
+struct txx927_pio_reg {
+	volatile unsigned long dout;
+	volatile unsigned long din;
+	volatile unsigned long dir;
+	volatile unsigned long od;
+	volatile unsigned long flag[2];
+	volatile unsigned long pol;
+	volatile unsigned long intc;
+	volatile unsigned long maskcpu;
+	volatile unsigned long maskext;
+};
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+/*
+ * TMR
+ */
+/* TMTCR : Timer Control */
+#define TXx927_TMTCR_TCE	0x00000080
+#define TXx927_TMTCR_CCDE	0x00000040
+#define TXx927_TMTCR_CRE	0x00000020
+#define TXx927_TMTCR_ECES	0x00000008
+#define TXx927_TMTCR_CCS	0x00000004
+#define TXx927_TMTCR_TMODE_MASK	0x00000003
+#define TXx927_TMTCR_TMODE_WDOG	0x00000002
+#define TXx927_TMTCR_TMODE_ITVL	0x00000000
+
+/* TMTISR : Timer Int. Status */
+#define TXx927_TMTISR_TPIBS	0x00000004
+#define TXx927_TMTISR_TPIAS	0x00000002
+#define TXx927_TMTISR_TIIS	0x00000001
+
+/* TMTITMR : Interval Timer Mode */
+#define TXx927_TMTITMR_TIIE	0x00008000
+#define TXx927_TMTITMR_TZCE	0x00000001
+
+/* TMTWTMR : Watchdog Timer Mode */
+#define TXx927_TMTWTMR_TWIE	0x00008000
+#define TXx927_TMTWTMR_WDIS	0x00000080
+#define TXx927_TMTWTMR_TWC	0x00000001
+
+/*
+ * SIO
+ */
+/* SILCR : Line Control */
+#define TXx927_SILCR_SCS_MASK	0x00000060
+#define TXx927_SILCR_SCS_IMCLK	0x00000000
+#define TXx927_SILCR_SCS_IMCLK_BG	0x00000020
+#define TXx927_SILCR_SCS_SCLK	0x00000040
+#define TXx927_SILCR_SCS_SCLK_BG	0x00000060
+#define TXx927_SILCR_UEPS	0x00000010
+#define TXx927_SILCR_UPEN	0x00000008
+#define TXx927_SILCR_USBL_MASK	0x00000004
+#define TXx927_SILCR_USBL_1BIT	0x00000004
+#define TXx927_SILCR_USBL_2BIT	0x00000000
+#define TXx927_SILCR_UMODE_MASK	0x00000003
+#define TXx927_SILCR_UMODE_8BIT	0x00000000
+#define TXx927_SILCR_UMODE_7BIT	0x00000001
+
+/* SIDICR : DMA/Int. Control */
+#define TXx927_SIDICR_TDE	0x00008000
+#define TXx927_SIDICR_RDE	0x00004000
+#define TXx927_SIDICR_TIE	0x00002000
+#define TXx927_SIDICR_RIE	0x00001000
+#define TXx927_SIDICR_SPIE	0x00000800
+#define TXx927_SIDICR_CTSAC	0x00000600
+#define TXx927_SIDICR_STIE_MASK	0x0000003f
+#define TXx927_SIDICR_STIE_OERS		0x00000020
+#define TXx927_SIDICR_STIE_CTSS		0x00000010
+#define TXx927_SIDICR_STIE_RBRKD	0x00000008
+#define TXx927_SIDICR_STIE_TRDY		0x00000004
+#define TXx927_SIDICR_STIE_TXALS	0x00000002
+#define TXx927_SIDICR_STIE_UBRKD	0x00000001
+
+/* SIDISR : DMA/Int. Status */
+#define TXx927_SIDISR_UBRK	0x00008000
+#define TXx927_SIDISR_UVALID	0x00004000
+#define TXx927_SIDISR_UFER	0x00002000
+#define TXx927_SIDISR_UPER	0x00001000
+#define TXx927_SIDISR_UOER	0x00000800
+#define TXx927_SIDISR_ERI	0x00000400
+#define TXx927_SIDISR_TOUT	0x00000200
+#define TXx927_SIDISR_TDIS	0x00000100
+#define TXx927_SIDISR_RDIS	0x00000080
+#define TXx927_SIDISR_STIS	0x00000040
+#define TXx927_SIDISR_RFDN_MASK	0x0000001f
+
+/* SICISR : Change Int. Status */
+#define TXx927_SICISR_OERS	0x00000020
+#define TXx927_SICISR_CTSS	0x00000010
+#define TXx927_SICISR_RBRKD	0x00000008
+#define TXx927_SICISR_TRDY	0x00000004
+#define TXx927_SICISR_TXALS	0x00000002
+#define TXx927_SICISR_UBRKD	0x00000001
+
+/* SIFCR : FIFO Control */
+#define TXx927_SIFCR_SWRST	0x00008000
+#define TXx927_SIFCR_RDIL_MASK	0x00000180
+#define TXx927_SIFCR_RDIL_1	0x00000000
+#define TXx927_SIFCR_RDIL_4	0x00000080
+#define TXx927_SIFCR_RDIL_8	0x00000100
+#define TXx927_SIFCR_RDIL_12	0x00000180
+#define TXx927_SIFCR_RDIL_MAX	0x00000180
+#define TXx927_SIFCR_TDIL_MASK	0x00000018
+#define TXx927_SIFCR_TDIL_MASK	0x00000018
+#define TXx927_SIFCR_TDIL_1	0x00000000
+#define TXx927_SIFCR_TDIL_4	0x00000001
+#define TXx927_SIFCR_TDIL_8	0x00000010
+#define TXx927_SIFCR_TDIL_MAX	0x00000010
+#define TXx927_SIFCR_TFRST	0x00000004
+#define TXx927_SIFCR_RFRST	0x00000002
+#define TXx927_SIFCR_FRSTE	0x00000001
+#define TXx927_SIO_TX_FIFO	8
+#define TXx927_SIO_RX_FIFO	16
+
+/* SIFLCR : Flow Control */
+#define TXx927_SIFLCR_RCS	0x00001000
+#define TXx927_SIFLCR_TES	0x00000800
+#define TXx927_SIFLCR_RTSSC	0x00000200
+#define TXx927_SIFLCR_RSDE	0x00000100
+#define TXx927_SIFLCR_TSDE	0x00000080
+#define TXx927_SIFLCR_RTSTL_MASK	0x0000001e
+#define TXx927_SIFLCR_RTSTL_MAX	0x0000001e
+#define TXx927_SIFLCR_TBRK	0x00000001
+
+/* SIBGR : Baudrate Control */
+#define TXx927_SIBGR_BCLK_MASK	0x00000300
+#define TXx927_SIBGR_BCLK_T0	0x00000000
+#define TXx927_SIBGR_BCLK_T2	0x00000100
+#define TXx927_SIBGR_BCLK_T4	0x00000200
+#define TXx927_SIBGR_BCLK_T6	0x00000300
+#define TXx927_SIBGR_BRD_MASK	0x000000ff
+
+/*
+ * PIO
+ */
+
+#endif /* __ASM_TXX927_H */
diff -Naru linux-2.4.32/include/linux/pci_ids.h linux-2.4.32-mct/include/linux/pci_ids.h
--- linux-2.4.32/include/linux/pci_ids.h	2005-11-16 20:12:54.000000000 +0100
+++ linux-2.4.32-mct/include/linux/pci_ids.h	2006-12-02 15:08:44.000000000 +0100
@@ -1490,6 +1490,9 @@
 #define PCI_DEVICE_ID_ITE_IT8181	0x8181
 #define PCI_DEVICE_ID_ITE_8872		0x8872
 
+#define PCI_DEVICE_ID_ITE_8211		0x8211
+#define PCI_DEVICE_ID_ITE_8212		0x8212
+
 #define PCI_DEVICE_ID_ITE_IT8330G_0    0xe886
 
 /* formerly Platform Tech */
diff -Naru linux-2.4.32/init/do_mounts.c linux-2.4.32-mct/init/do_mounts.c
--- linux-2.4.32/init/do_mounts.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-2.4.32-mct/init/do_mounts.c	2006-12-02 15:09:44.000000000 +0100
@@ -344,15 +344,28 @@
 	}
 	*s = '\0';
 }
-static void __init mount_block_root(char *name, int flags)
+static int __init mount_block_root(char *name, int flags)
 {
 	char *fs_names = __getname();
 	char *p;
 
 	get_fs_names(fs_names);
+	
+        /* wait 1 second for usb device*/
+        current->state = TASK_INTERRUPTIBLE;
+        schedule_timeout(HZ);
+
 retry:
+
 	for (p = fs_names; *p; p += strlen(p)+1) {
-		int err = sys_mount(name, "/root", p, flags, root_mount_data);
+		int err;
+
+		/* Skip JFFS2 as root fs */
+		if (!strcmp(p, "jffs2"))
+			continue;
+		
+		err = sys_mount(name, "/root", p, flags, root_mount_data);
+
 		switch (err) {
 			case 0:
 				goto out;
@@ -367,13 +380,16 @@
 		 * Allow the user to distinguish between failed open
 		 * and bad superblock on root device.
 		 */
+		/*
 		printk ("VFS: Cannot open root device \"%s\" or %s\n",
 			root_device_name, kdevname (ROOT_DEV));
 		printk ("Please append a correct \"root=\" boot option\n");
 		panic("VFS: Unable to mount root fs on %s",
 			kdevname(ROOT_DEV));
+		*/
+		break;
 	}
-	panic("VFS: Unable to mount root fs on %s", kdevname(ROOT_DEV));
+	return -1;
 out:
 	putname(fs_names);
 	sys_chdir("/root");
@@ -381,6 +397,7 @@
 	printk("VFS: Mounted root (%s filesystem)%s.\n",
 		current->fs->pwdmnt->mnt_sb->s_type->name,
 		(current->fs->pwdmnt->mnt_sb->s_flags & MS_RDONLY) ? " readonly" : "");
+	return 0;
 }
  
 #ifdef CONFIG_ROOT_NFS
@@ -759,34 +776,46 @@
 
 static void __init mount_root(void)
 {
+	/* try this root devices in the following order */
+	char *try[3] = { "/dev/nfs", "/dev/sda1", "/dev/mtdblock2" };
+	int  i, j, r;
+	for (i = 0, r = -1; i < 3 && r != 0; i++) {
+		printk("Trying root device %s... \n", try[i]);
+		for (j = 0; j < 3 && r != 0; j++) {
+			root_dev_setup(try[i]);
+			devfs_make_root(root_device_name);
+			create_dev("/dev/root", ROOT_DEV, root_device_name);
+#ifdef CONFIG_BLK_DEV_FD
+			if (MAJOR(ROOT_DEV) == FLOPPY_MAJOR) {
+				/* rd_doload is 2 for a dual initrd/ramload setup */
+				if (rd_doload==2) {
+					if (rd_load_disk(1)) {
+						ROOT_DEV = MKDEV(RAMDISK_MAJOR, 1);
+						create_dev("/dev/root", ROOT_DEV, NULL);
+					}
+				} else
+					change_floppy("root floppy");
+			}
+#endif
 #ifdef CONFIG_ROOT_NFS
-       if (MAJOR(ROOT_DEV) == NFS_MAJOR
-           && MINOR(ROOT_DEV) == NFS_MINOR) {
-		if (mount_nfs_root()) {
-			sys_chdir("/root");
-			ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
-			printk("VFS: Mounted root (nfs filesystem).\n");
-			return;
-		}
-		printk(KERN_ERR "VFS: Unable to mount root fs via NFS, trying floppy.\n");
-		ROOT_DEV = MKDEV(FLOPPY_MAJOR, 0);
-	}
+			if (MAJOR(ROOT_DEV) == NFS_MAJOR
+			    && MINOR(ROOT_DEV) == NFS_MINOR) {
+				if (mount_nfs_root()) {
+					sys_chdir("/root");
+					ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
+					printk("VFS: Mounted root (nfs filesystem).\n");
+					r = 0;
+				}
+			}
 #endif
-	devfs_make_root(root_device_name);
-	create_dev("/dev/root", ROOT_DEV, root_device_name);
-#ifdef CONFIG_BLK_DEV_FD
-	if (MAJOR(ROOT_DEV) == FLOPPY_MAJOR) {
-		/* rd_doload is 2 for a dual initrd/ramload setup */
-		if (rd_doload==2) {
-			if (rd_load_disk(1)) {
-				ROOT_DEV = MKDEV(RAMDISK_MAJOR, 1);
-				create_dev("/dev/root", ROOT_DEV, NULL);
+			if (r) {
+				r = mount_block_root("/dev/root", root_mountflags);
 			}
-		} else
-			change_floppy("root floppy");
+		}
+	}
+	if (r == -1) {
+		panic("VFS: Unable to mount root fs on %s", kdevname(ROOT_DEV));
 	}
-#endif
-	mount_block_root("/dev/root", root_mountflags);
 }
 
 #ifdef CONFIG_BLK_DEV_INITRD
diff -Naru linux-2.4.32/net/ipv4/ipconfig.c linux-2.4.32-mct/net/ipv4/ipconfig.c
--- linux-2.4.32/net/ipv4/ipconfig.c	2005-04-04 03:42:20.000000000 +0200
+++ linux-2.4.32-mct/net/ipv4/ipconfig.c	2006-12-02 15:08:44.000000000 +0100
@@ -86,8 +86,8 @@
 #define CONF_POST_OPEN		(1*HZ)	/* After opening: 1 second */
 
 /* Define the timeout for waiting for a DHCP/BOOTP/RARP reply */
-#define CONF_OPEN_RETRIES 	2	/* (Re)open devices twice */
-#define CONF_SEND_RETRIES 	6	/* Send six requests per open */
+#define CONF_OPEN_RETRIES 	1	/* (Re)open devices twice */
+#define CONF_SEND_RETRIES 	1	/* Send six requests per open */
 #define CONF_INTER_TIMEOUT	(HZ/2)	/* Inter-device timeout: 1/2 second */
 #define CONF_BASE_TIMEOUT	(HZ*2)	/* Initial timeout: 2 seconds */
 #define CONF_TIMEOUT_RANDOM	(HZ)	/* Maximum amount of randomization */
@@ -107,7 +107,7 @@
  */
 int ic_set_manually __initdata = 0;		/* IPconfig parameters set manually */
 
-int ic_enable __initdata = 0;			/* IP config enabled? */
+int ic_enable __initdata = 1;			/* IP config enabled? */
 
 /* Protocol choice */
 int ic_proto_enabled __initdata = 0
